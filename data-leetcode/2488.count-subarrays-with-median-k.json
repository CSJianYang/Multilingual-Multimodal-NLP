[
    {
        "title": "Count Subarrays With Median K",
        "question_content": "You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.\nReturn the number of non-empty subarrays in nums that have a median equal to k.\nNote:\n\n\tThe median of an array is the middle element after sorting the array in ascending order. If the array is of even length, the median is the left middle element.\n\t\n\t\tFor example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1] is 4.\n\t\n\t\n\tA subarray is a contiguous part of an array.\n\n&nbsp;\nExample 1:\n\nInput: nums = [3,2,1,4,5], k = 4\nOutput: 3\nExplanation: The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5].\n\nExample 2:\n\nInput: nums = [2,3,1], k = 3\nOutput: 1\nExplanation: [3] is the only subarray that has a median equal to 3.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t1 <= n <= 105\n\t1 <= nums[i], k <= n\n\tThe integers in nums are distinct.",
        "solutions": [
            {
                "id": 2851940,
                "title": "balance",
                "content": "A subarray has a median `k` if:\\n- It includes `k`\\n- Count `n[i] < k` is equal to count `n[i] > k` (odd-size subarrays).\\n- Count `n[i] < k` is one less than count `n[i] > k` (even-size subarrays).\\n  \\nOr, in other words, the balance between the count of smaller and larger elements is zero or one.\\n    \\nSince integers are distinct, we have only one `k` element in the array. So, we find it first.\\n    \\nThen, we go right from `k`, tracking the ballance and counting balances using a hash map.\\n    \\nFinally, we go left from `k`, tracking the balance, and counting complimentary balances in the hash map.\\n    \\n> Say the ballance is `-3` (more smaller elements). We look for value `3` and `4` in the hash map to count valid subarrays.\\n> This is how our balances look for `[7, 1, 3, 4, 2, 5 ,6], 4`, resulting in 5 valid subarrays.\\n    \\n![image](https://assets.leetcode.com/users/images/ff0e582a-f3d9-4531-be0a-c0e321601061_1669522039.1054294.png)\\n\\n    \\n**C++**\\n```cpp\\nint countSubarrays(vector<int>& n, int k) {\\n    unordered_map<int, int> cnt;\\n    int p = find(begin(n), end(n), k) - begin(n), res = 0;\\n    for(int i = p, bal = 0; i < n.size(); ++i) {\\n        bal += n[i] == k ? 0 : n[i] < k ? -1 : 1;\\n        ++cnt[bal];\\n    }\\n    for(int i = p, bal = 0; i >= 0; --i) {\\n        bal += n[i] == k ? 0 : n[i] < k ? -1 : 1;\\n        res += cnt[-bal] + cnt[-bal + 1];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countSubarrays(vector<int>& n, int k) {\\n    unordered_map<int, int> cnt;\\n    int p = find(begin(n), end(n), k) - begin(n), res = 0;\\n    for(int i = p, bal = 0; i < n.size(); ++i) {\\n        bal += n[i] == k ? 0 : n[i] < k ? -1 : 1;\\n        ++cnt[bal];\\n    }\\n    for(int i = p, bal = 0; i >= 0; --i) {\\n        bal += n[i] == k ? 0 : n[i] < k ? -1 : 1;\\n        res += cnt[-bal] + cnt[-bal + 1];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852402,
                "title": "python3-hashmap-counting-explained-o-n",
                "content": "**Intuition**\\n - We are looking for subarrays that contain ```k```.\\n - Elements are unique (from 1 to n).\\n - Since the subarray has to contain ```k```, and there is only one ```k```, we can start from ```k``` to build the subarrays.\\n\\nWhat makes a valid subarray (i.e., k as the median)?\\n - the number of elements larger than k == the number of elements smaller than k (odd length)\\n - the number of elements larger than k + 1 == the number of elements smaller than k (even length)\\n => large == small or large == small+1\\n\\n**Algorithm**\\nWe can check the elements before ```k``` and after ```k```, and count the number of elements larger/smaller than ```k```.\\n - let\\'s use ```l1``` and ```s1``` denoting the number of elements larger and smaller than k, **Before ```k```**.\\n - and ```l2```, ```s2``` denoting the number of elements larger and smaller than k, **After ```k```**.\\n => The above equation becomes: \\n - ```l1 + l2 == s1 + s2``` => ```l1 - s1 == s2 - l2```\\n - ```l1 + l2 == s1 + s2 + 1``` => ```l1 - s1 == s2 - l2 + 1```\\n\\nNow we can use a hash map to count the frequency of ```l1 - s1``` for the subarray before ```k``` (and contains ```k```).\\nThen, check if ```s2 - l2``` and ```s2 - l2 + 1``` in the hash map for the subarray after ```k``` (and contains ```k```) to compute the result.\\n\\n**TC** O(n), since we only go through the elements before ```k``` and after ```k``` once.\\n\\n```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        # Find the index of k in nums\\n        index = nums.index(k)\\n        \\n        # l (larger) is count of element>k\\n        # s (smaller) is count of element<k\\n        res = l1 = s1 = 0\\n        before = defaultdict(int)\\n        \\n        # run from index-1 to 0 (before index)\\n        for i in reversed(range(index)):\\n            # Increase l or s, and increase the differece in \\'before\\'\\n            if nums[i] > k: l1 += 1\\n            else: s1 += 1\\n            before[(l1-s1)] += 1\\n            \\n            # If the number of larger element and smaller element are the same,\\n            # we find a valid subarray which is nums[i:index+1], so increase res.\\n            if l1-s1==1 or l1-s1==0: res += 1\\n\\n        l2 = s2 = 0\\n        for i in range(index+1,len(nums)):\\n            if nums[i] > k: l2 += 1\\n            else: s2 += 1\\n            \\n            # we need the number of larger elements and smaller elements to be the same in a subarray,\\n            #    l1 + l2 == s1 + s2 or l1 + l2 + 1 == s1 + s2\\n            # => l1 - s1 == s2 - l2 or l1 - s1 == s2 - l2 + 1\\n            # so we need to check if s2-l2 or s2-l2+1 exist in before\\n            res += before[s2-l2] + before[s2-l2+1]\\n            \\n            if l2-s2==1 or l2-s2==0: res += 1\\n                \\n        return res+1\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```k```\n```k```\n```k```\n```k```\n```k```\n```k```\n```k```\n```l1```\n```s1```\n```k```\n```l2```\n```s2```\n```k```\n```l1 + l2 == s1 + s2```\n```l1 - s1 == s2 - l2```\n```l1 + l2 == s1 + s2 + 1```\n```l1 - s1 == s2 - l2 + 1```\n```l1 - s1```\n```k```\n```k```\n```s2 - l2```\n```s2 - l2 + 1```\n```k```\n```k```\n```k```\n```k```\n```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        # Find the index of k in nums\\n        index = nums.index(k)\\n        \\n        # l (larger) is count of element>k\\n        # s (smaller) is count of element<k\\n        res = l1 = s1 = 0\\n        before = defaultdict(int)\\n        \\n        # run from index-1 to 0 (before index)\\n        for i in reversed(range(index)):\\n            # Increase l or s, and increase the differece in \\'before\\'\\n            if nums[i] > k: l1 += 1\\n            else: s1 += 1\\n            before[(l1-s1)] += 1\\n            \\n            # If the number of larger element and smaller element are the same,\\n            # we find a valid subarray which is nums[i:index+1], so increase res.\\n            if l1-s1==1 or l1-s1==0: res += 1\\n\\n        l2 = s2 = 0\\n        for i in range(index+1,len(nums)):\\n            if nums[i] > k: l2 += 1\\n            else: s2 += 1\\n            \\n            # we need the number of larger elements and smaller elements to be the same in a subarray,\\n            #    l1 + l2 == s1 + s2 or l1 + l2 + 1 == s1 + s2\\n            # => l1 - s1 == s2 - l2 or l1 - s1 == s2 - l2 + 1\\n            # so we need to check if s2-l2 or s2-l2+1 exist in before\\n            res += before[s2-l2] + before[s2-l2+1]\\n            \\n            if l2-s2==1 or l2-s2==0: res += 1\\n                \\n        return res+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851944,
                "title": "java-python-3-c-1-pass-o-n-codes-count-the-prefix-sum-of-the-balance-of-greater-samller",
                "content": "**Key observation:** Within any subarray, the # of elements greater than median - the # of those less than median `= 0` or `1`.\\n\\nIn order to guarantee the median `k` to present in subarrays, we ONLY save into HashMap/dict the frequencies of the running balances BEFORE finding the median `k`. e.g., \\n\\n`nums = [7, 1, 3, 4, 2, 5, 6], k = 4`\\nrunning balance:\\n`bals =  [1, 0,-1,-1,-2,-1, 0]`\\nAt index:\\n-1: running balance = 0 Note: -1 is a vertual index for dummy value 0. \\n0: running balance = 1\\n1: running balance = 0\\n2: running balance = -1\\n3: running balance = -1, median k found! stop saving the frequencies into HashMap/dict.\\n4: running balance = -2, begin to count the # of subarrays but no subarray meet the requirement yet. \\n5: running balance = -1, there are `2` `-1`s at index `2` & `3`, respectively. The corresponding subarrays are from index `3` to `5` and `4` to `5`: `[4,2,5]` & `[4,5]`. Note: though `(-1 -1) == -2` at index `4`, it is not what we need, because the subarray from index `5` to index `5`, `[5]`, does not include median at index `3`.\\n6: running balance = 0, there are a `0` at index `1` and dummy value of `0` at index `-1`: `[3,4,2,5,6]` & `[7,1,3,4,2,5,6]`, and two `0 - 1 == -1`s at index `2` & `3`: `[3,4,2,5,6]` & `[4,2,5,6]`.\\n\\n\\nWe have to use the running balance after median to minus the running balance before the median. Otherwise, we could NOT make sure the median is in the subarray.\\n\\n----\\n\\nBased on the above, we implement the algorithm as follows: \\n1. Use a HashMap/dict to count the frequencies of the prefix sum of the running balance (bigger ones - smaller ones);\\n2. If `k` is the median of a subarray, it must present in the subarray. Therefore, before finding the median, no subarray ending at current element meets the problem requirement; \\n3. After finding `k`during traversal, no need to count the frequencies any more in the HashMap/dict. If `number of bigger ones == number of the smaller (or + 1)`, that is, `the difference between prefix sum of balances (bigger - smaller) is 0 or 1`, then `k`is the median of the subarray ending at current element;\\n4. Use the difference of prefix sums to get the count of the required number of subarrays.\\n\\n----\\n\\n```java\\n    public int countSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> prefixSumOfBalance = new HashMap<>();\\n        prefixSumOfBalance.put(0, 1); // Dummy value of 0\\'s frequency is 1.\\n        int ans = 0, runningBalance = 0;\\n        boolean found = false;\\n        for (int num : nums) {\\n            if (num < k) {\\n                --runningBalance;\\n            }else if (num > k) {\\n                ++runningBalance;\\n            }else {\\n                found = true;\\n            }\\n            if (found) {\\n                ans += prefixSumOfBalance.getOrDefault(runningBalance, 0) + prefixSumOfBalance.getOrDefault(runningBalance - 1, 0);\\n            }else {\\n             // prefixSumOfBalance.merge(runningBalance, 1, Integer::sum); // Similar to the following statement, but it is shorter.\\n                prefixSumOfBalance.put(runningBalance, prefixSumOfBalance.getOrDefault(runningBalance, 0) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        prefix_sum_of_balance = Counter([0]) # Dummy value of 0\\'s frequency is 1.\\n        running_balance = ans = 0\\n        found = False\\n        for num in nums:\\n            if num < k:\\n                running_balance -= 1\\n            elif num > k:\\n                running_balance += 1\\n            else:\\n                found = True\\n            if found:\\n                ans += prefix_sum_of_balance[running_balance] + prefix_sum_of_balance[running_balance - 1]    \\n            else:\\n                prefix_sum_of_balance[running_balance] += 1\\n        return ans\\n```\\nCredit to **@Sung-Lin** for his code and explanation.\\n```cpp\\n/*\\n        [ 7,  1,  3,  4,  2,  5,  6], 4\\n    bal   1,  0, -1, -1, -2, -1,  0\\n         |<- cnt ->| \\n    ans               1.  0.  1.  2+1                \\n                     -1 [4]\\n                             -1 [4,2,5]\\n                                  0 [3,4,2,5,6]\\n                                  0 [7,1,3,4,2,5,6]\\n                                 -1 [4,2,5,6]\\n                               \\n    cnt (prefix)\\n      1: 1 (idx 0)\\n      0: 2 (idx -1, 1)\\n     -1: 1 (idx 2)\\n\\n      e.g. 4(idx 3) -> -1\\n  => find  3(idx 2) -> -1 => idx 2+1(=3) ~ idx 3 => balance == -1 - -1 == 0\\n        \\n     curBalance - x == 0 or 1\\n  => x == curBalance or x == curBalance - 1\\n*/\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = (int) nums.size();\\n        \\n        unordered_map<int, int> cnt; // prefix\\n        cnt[0] = 1; // can be think as the prefix on index -1\\n        \\n        bool includeK = false;\\n        int balance = 0; \\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < k)\\n                balance--;\\n            else if (nums[i] > k)\\n                balance++;\\n            else // num[i] == k\\n                includeK = true;\\n            \\n            if (includeK) {\\n                // find x in prefix hashmap \\n                // greater - smaller == 0 or 1\\n                // => prefix[i] - prefix[x] == 0 or 1\\n                // => curBalance - prefix[x] == 0 or curBalance - prefix[x] == 1\\n                // => prefix[x] == curBalance or prefix[x] == curBalance - 1\\n                ans += cnt[balance] + cnt[balance - 1]; \\n            }\\n            else\\n                cnt[balance]++;\\n        }\\n        return ans;         \\n    }\\n};\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\n    public int countSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> prefixSumOfBalance = new HashMap<>();\\n        prefixSumOfBalance.put(0, 1); // Dummy value of 0\\'s frequency is 1.\\n        int ans = 0, runningBalance = 0;\\n        boolean found = false;\\n        for (int num : nums) {\\n            if (num < k) {\\n                --runningBalance;\\n            }else if (num > k) {\\n                ++runningBalance;\\n            }else {\\n                found = true;\\n            }\\n            if (found) {\\n                ans += prefixSumOfBalance.getOrDefault(runningBalance, 0) + prefixSumOfBalance.getOrDefault(runningBalance - 1, 0);\\n            }else {\\n             // prefixSumOfBalance.merge(runningBalance, 1, Integer::sum); // Similar to the following statement, but it is shorter.\\n                prefixSumOfBalance.put(runningBalance, prefixSumOfBalance.getOrDefault(runningBalance, 0) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        prefix_sum_of_balance = Counter([0]) # Dummy value of 0\\'s frequency is 1.\\n        running_balance = ans = 0\\n        found = False\\n        for num in nums:\\n            if num < k:\\n                running_balance -= 1\\n            elif num > k:\\n                running_balance += 1\\n            else:\\n                found = True\\n            if found:\\n                ans += prefix_sum_of_balance[running_balance] + prefix_sum_of_balance[running_balance - 1]    \\n            else:\\n                prefix_sum_of_balance[running_balance] += 1\\n        return ans\\n```\n```cpp\\n/*\\n        [ 7,  1,  3,  4,  2,  5,  6], 4\\n    bal   1,  0, -1, -1, -2, -1,  0\\n         |<- cnt ->| \\n    ans               1.  0.  1.  2+1                \\n                     -1 [4]\\n                             -1 [4,2,5]\\n                                  0 [3,4,2,5,6]\\n                                  0 [7,1,3,4,2,5,6]\\n                                 -1 [4,2,5,6]\\n                               \\n    cnt (prefix)\\n      1: 1 (idx 0)\\n      0: 2 (idx -1, 1)\\n     -1: 1 (idx 2)\\n\\n      e.g. 4(idx 3) -> -1\\n  => find  3(idx 2) -> -1 => idx 2+1(=3) ~ idx 3 => balance == -1 - -1 == 0\\n        \\n     curBalance - x == 0 or 1\\n  => x == curBalance or x == curBalance - 1\\n*/\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = (int) nums.size();\\n        \\n        unordered_map<int, int> cnt; // prefix\\n        cnt[0] = 1; // can be think as the prefix on index -1\\n        \\n        bool includeK = false;\\n        int balance = 0; \\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < k)\\n                balance--;\\n            else if (nums[i] > k)\\n                balance++;\\n            else // num[i] == k\\n                includeK = true;\\n            \\n            if (includeK) {\\n                // find x in prefix hashmap \\n                // greater - smaller == 0 or 1\\n                // => prefix[i] - prefix[x] == 0 or 1\\n                // => curBalance - prefix[x] == 0 or curBalance - prefix[x] == 1\\n                // => prefix[x] == curBalance or prefix[x] == curBalance - 1\\n                ans += cnt[balance] + cnt[balance - 1]; \\n            }\\n            else\\n                cnt[balance]++;\\n        }\\n        return ans;         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852005,
                "title": "simple-map",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we need to find the median and it depends only on the number of numbers less than k or greater than k. So we can change the array to 1 and -1 where nums[i]>k and nums[i]<k respectively. Now ,in order to get median ,we must include k in our subarray. So , starting form k (taking sum of elemnts), we will go left to find out the number of greater and smaller elements present till every index and store it in a hashmap.\\n eg. 3 2 1 4 5 k=4  ->  -1 -1 -1 0 1\\nNow going left from k  summation wd be   -3 -2 -1 0 1;\\n\\nNow we will go right taking sum from position of k to find the possible subarrays. If we have seen and entry in map (such that key i map + sum = 0 or 1 ) this means we found a possible subarray.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfor(int i =0;i<nums.size();i++){  //*** changing array to 0 1 and -1\\n            if(nums[i]>k)\\n            {\\n                nums[i]= 1;\\n            }\\n            else if(nums[i]<k){\\n                nums[i]= -1;\\n            }\\n            else{\\n                nums[i]=0;\\n            }\\n        }\\n                   \\n        int res = 0;\\n        int in = -1;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                in = i;    //*** index of k in array \\n                break;\\n            }\\n        }\\n        \\n        int sum = 0;\\n        unordered_map<int,int> hm;\\n        for(int i = in;i>=0;i--){ //*** going left \\n            sum += nums[i];\\n            hm[sum]++;\\n        }\\n        sum = 0;\\n        for(int i = in;i<nums.size();i++){  //*** going right \\n            sum += nums[i];\\n            int f = -1*sum;\\n            if(hm.count(f)!=0){\\n                res += (hm[f]);\\n            }\\n            f+=1;\\n             if(hm.count(f)!=0){\\n                res += (hm[f]);\\n            }\\n        }\\n        \\n        return res; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor(int i =0;i<nums.size();i++){  //*** changing array to 0 1 and -1\\n            if(nums[i]>k)\\n            {\\n                nums[i]= 1;\\n            }\\n            else if(nums[i]<k){\\n                nums[i]= -1;\\n            }\\n            else{\\n                nums[i]=0;\\n            }\\n        }\\n                   \\n        int res = 0;\\n        int in = -1;\\n        for(int i =0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                in = i;    //*** index of k in array \\n                break;\\n            }\\n        }\\n        \\n        int sum = 0;\\n        unordered_map<int,int> hm;\\n        for(int i = in;i>=0;i--){ //*** going left \\n            sum += nums[i];\\n            hm[sum]++;\\n        }\\n        sum = 0;\\n        for(int i = in;i<nums.size();i++){  //*** going right \\n            sum += nums[i];\\n            int f = -1*sum;\\n            if(hm.count(f)!=0){\\n                res += (hm[f]);\\n            }\\n            f+=1;\\n             if(hm.count(f)!=0){\\n                res += (hm[f]);\\n            }\\n        }\\n        \\n        return res; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852218,
                "title": "c-using-map-easy-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int segments(int n, vector<int> p, int m)\\n    {\\n    map<int, int> c;\\n    c[0] = 1;\\n    bool has = false;\\n    int sum = 0;\\n    long long ans = 0;\\n    for (int r = 0; r < n; r++) {\\n \\n        // If element is less than m\\n        if (p[r] < m)\\n            sum--;\\n \\n        // If element greater than m\\n        else if (p[r] > m)\\n            sum++;\\n \\n        // If m is found\\n        if (p[r] == m)\\n            has = true;\\n \\n        // Count the answer\\n        if (has)\\n            ans += c[sum] + c[sum - 1];\\n \\n        // Increment sum\\n        else\\n            c[sum]++;\\n    }\\n \\n    return ans;\\n}\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int res  = segments(nums.size(),nums,k);\\n        \\n        return res;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int segments(int n, vector<int> p, int m)\\n    {\\n    map<int, int> c;\\n    c[0] = 1;\\n    bool has = false;\\n    int sum = 0;\\n    long long ans = 0;\\n    for (int r = 0; r < n; r++) {\\n \\n        // If element is less than m\\n        if (p[r] < m)\\n            sum--;\\n \\n        // If element greater than m\\n        else if (p[r] > m)\\n            sum++;\\n \\n        // If m is found\\n        if (p[r] == m)\\n            has = true;\\n \\n        // Count the answer\\n        if (has)\\n            ans += c[sum] + c[sum - 1];\\n \\n        // Increment sum\\n        else\\n            c[sum]++;\\n    }\\n \\n    return ans;\\n}\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int res  = segments(nums.size(),nums,k);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852086,
                "title": "easy-map-solution",
                "content": "**Approach:**\\nFor a number to be median of an array, it must be included in the array and the count of numbers greater than it should be either equal to or 1 more than the count of numbers less than it.\\n\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        int n = nums.size();\\n        int less = 0, great = 0;\\n        int pivot = -1;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i] == k) {\\n                pivot = i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i=pivot; i<n; ++i) {\\n            if(nums[i] > k) great++;\\n            else if(nums[i] < k) less++;\\n            int key = great-less;\\n            if(m.find(key) != m.end()) m[key]++;\\n            else m.insert({key, 1});\\n        }\\n        \\n        int count = 0;\\n        less=great=0;\\n        for(int i=pivot; i>=0; --i) {\\n            if(nums[i] > k) great++;\\n            else if(nums[i] < k) less++;\\n            int key = less-great;\\n            if(m.find(key) != m.end()) count += m[key];\\n            if(m.find(key+1) != m.end()) count += m[key+1];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n**Java Code:**\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        int less = 0, great = 0;\\n        int pivot = -1;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i] == k) {\\n                pivot = i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i=pivot; i<n; ++i) {\\n            if(nums[i] > k) great++;\\n            else if(nums[i] < k) less++;\\n            map.put(great-less, map.getOrDefault(great-less, 0)+1);\\n        }\\n        \\n        int count = 0;\\n        less=great=0;\\n        for(int i=pivot; i>=0; --i) {\\n            if(nums[i] > k) great++;\\n            else if(nums[i] < k) less++;\\n            int key = less-great;\\n            count += map.getOrDefault(key, 0) + map.getOrDefault(key+1, 0);\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        int n = nums.size();\\n        int less = 0, great = 0;\\n        int pivot = -1;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i] == k) {\\n                pivot = i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i=pivot; i<n; ++i) {\\n            if(nums[i] > k) great++;\\n            else if(nums[i] < k) less++;\\n            int key = great-less;\\n            if(m.find(key) != m.end()) m[key]++;\\n            else m.insert({key, 1});\\n        }\\n        \\n        int count = 0;\\n        less=great=0;\\n        for(int i=pivot; i>=0; --i) {\\n            if(nums[i] > k) great++;\\n            else if(nums[i] < k) less++;\\n            int key = less-great;\\n            if(m.find(key) != m.end()) count += m[key];\\n            if(m.find(key+1) != m.end()) count += m[key+1];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854521,
                "title": "python-3-7-lines-w-example-t-m-71-86",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        d, iMed = defaultdict(int), nums.index(k)   #  Ex:  [3, 2, 1, 4, 5]   k = 4\\n        ans, diff, d[0] = 0, 0, 1\\n                                                    #   i     n    diff   ans      d\\n        for i, n in enumerate(nums):                #  \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\n                                                    #   0     3     -1     0    {0: 1, -1: 1}\\n            diff+= (n>k) - (n<k)                    #   1     2     -2     0    {0: 1, -1: 1, -2: 1}\\n                                                    #   2     1     -3     0    {0: 1, -1: 1, -2: 1, -3: 1}\\n            if i < iMed: d[diff]+= 1                #   3     4     -3     1    {0: 1, -1: 1, -2: 1, -3: 1, -4: 0}\\n                                                    #   4     5     -2     3    {0: 1, -1: 1, -2: 1, -3: 1, -4: 0}\\n            else: ans += (d[diff] + d[diff-1])      #                      |\\n                                                    #                    return 3\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/850759167/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*N*) / *O*(*N*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        d, iMed = defaultdict(int), nums.index(k)   #  Ex:  [3, 2, 1, 4, 5]   k = 4\\n        ans, diff, d[0] = 0, 0, 1\\n                                                    #   i     n    diff   ans      d\\n        for i, n in enumerate(nums):                #  \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\n                                                    #   0     3     -1     0    {0: 1, -1: 1}\\n            diff+= (n>k) - (n<k)                    #   1     2     -2     0    {0: 1, -1: 1, -2: 1}\\n                                                    #   2     1     -3     0    {0: 1, -1: 1, -2: 1, -3: 1}\\n            if i < iMed: d[diff]+= 1                #   3     4     -3     1    {0: 1, -1: 1, -2: 1, -3: 1, -4: 0}\\n                                                    #   4     5     -2     3    {0: 1, -1: 1, -2: 1, -3: 1, -4: 0}\\n            else: ans += (d[diff] + d[diff-1])      #                      |\\n                                                    #                    return 3\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852127,
                "title": "python3-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e728a9f475e5742bea7cf67ac2d1a98ab99fb206) for solutions of weekly 321. \\n\\n**Intuition**\\nThe subarray whose median is `k` has to include `k` itself. So we construct our subarrays starting from where `k` is located. \\nWe find the index of `k` (say `idx`). Then, we first move to the left and write down the difference of counts larger than k and smaller than `k`. \\nLater, we move to the right and calculate the same difference. Here, we can calculate the number of subarrays with median equal to `k` ending at the current index via `freq[-diff]`. \\n**Implementation**\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        idx = nums.index(k)\\n        freq = Counter()\\n        prefix = 0\\n        for i in reversed(range(idx+1)): \\n            prefix += int(nums[i] > k) - int(nums[i] < k)\\n            freq[prefix] += 1\\n        ans = prefix = 0 \\n        for i in range(idx, len(nums)): \\n            prefix += int(nums[i] > k) - int(nums[i] < k)\\n            ans += freq[-prefix] + freq[-prefix+1]\\n        return ans \\n```\\n**Complexity**\\nTime O(N)\\nSpace O(N)\\n\\nAlternative implementation inspired by @rock\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        freq = Counter({0 : 1})\\n        ans = diff = found = 0\\n        for x in nums: \\n            if x < k: diff -= 1\\n            elif x > k: diff += 1\\n            else: found = 1\\n            if found: ans += freq[diff] + freq[diff-1]\\n            else: freq[diff] += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        idx = nums.index(k)\\n        freq = Counter()\\n        prefix = 0\\n        for i in reversed(range(idx+1)): \\n            prefix += int(nums[i] > k) - int(nums[i] < k)\\n            freq[prefix] += 1\\n        ans = prefix = 0 \\n        for i in range(idx, len(nums)): \\n            prefix += int(nums[i] > k) - int(nums[i] < k)\\n            ans += freq[-prefix] + freq[-prefix+1]\\n        return ans \\n```\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        freq = Counter({0 : 1})\\n        ans = diff = found = 0\\n        for x in nums: \\n            if x < k: diff -= 1\\n            elif x > k: diff += 1\\n            else: found = 1\\n            if found: ans += freq[diff] + freq[diff-1]\\n            else: freq[diff] += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852074,
                "title": "c-counting-o-n-detailed-explaination",
                "content": "# Approach\\n\\nThe goal is to find the number of subarrays that have a median equal to $k$.\\n\\nLet `center` be the index of value $k$ (`nums[center] == k`), obviously `nums[center]` itself is a valid subarray, and let\\'s expand the subarray to the left and right.\\n\\n- The key to have a median $= k$ is balancing the number of elements less than $k$ and greater than $k$.\\n- Since the integers in `nums` are distinct, except `nums[center]`, `nums[i]` is eithor `< k` or `> k`.\\n- Let\\'s assign the elements a score:\\n  -  $< k$ scores $-1$\\n  -  $> k$ scores $1$\\n  -  $= k$ scores $0$\\n- A valid subarray should have total score $0$ or $1$\\n\\nConsidering the following 3 scenario with an example `nums = [4, 2, 3, 5, 1]`:\\n\\n1. the subarrays are end with `center`, such as `[4, 2, 3]`.\\n2. the subarrays are begin with `center`, such as `[3, 5]` and `[3, 5, 1]`.\\n3. the subarrays are across `center`, such as `[4, 2, 3, 5, 1]`.\\n\\nand let\\'s see how to compute the answer with these three scenario\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int center = -1;\\n        for ( int i=0; i<n; ++i )\\n            if ( nums[i] == k ) center = i;\\n        // k not found in nums\\n        if ( center == -1 ) return 0;\\n\\n        // init with 1 because nums[center] is an answer\\n        int ans = 1;\\n        // store the number of scores at the left, used for scenario 3\\n        unordered_map<int,int> cnt_l;\\n        for ( int i=center-1, sum=0; i>=0; --i ) {\\n            // sum is the accumulate score from center-1 to the left\\n            sum += (nums[i] < k) ? -1 : 1;\\n            // scenario 1: end with `center`\\n            if ( sum == 0 || sum == 1 ) ans++;\\n            // update the counter of this score\\n            cnt_l[sum]++;\\n        }\\n        for ( int i=center+1, sum=0; i<n; ++i ) {\\n            // sum is the accumulate score from center+1 to the right\\n            sum += (nums[i] < k) ? -1 : 1;\\n            // scenario 2: start with `center`\\n            if ( sum == 0 || sum == 1 ) ans++;\\n            // scenario 3: across `center`\\n            ans += cnt_l[-sum] + cnt_l[1-sum];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int center = -1;\\n        for ( int i=0; i<n; ++i )\\n            if ( nums[i] == k ) center = i;\\n        // k not found in nums\\n        if ( center == -1 ) return 0;\\n\\n        // init with 1 because nums[center] is an answer\\n        int ans = 1;\\n        // store the number of scores at the left, used for scenario 3\\n        unordered_map<int,int> cnt_l;\\n        for ( int i=center-1, sum=0; i>=0; --i ) {\\n            // sum is the accumulate score from center-1 to the left\\n            sum += (nums[i] < k) ? -1 : 1;\\n            // scenario 1: end with `center`\\n            if ( sum == 0 || sum == 1 ) ans++;\\n            // update the counter of this score\\n            cnt_l[sum]++;\\n        }\\n        for ( int i=center+1, sum=0; i<n; ++i ) {\\n            // sum is the accumulate score from center+1 to the right\\n            sum += (nums[i] < k) ? -1 : 1;\\n            // scenario 2: start with `center`\\n            if ( sum == 0 || sum == 1 ) ans++;\\n            // scenario 3: across `center`\\n            ans += cnt_l[-sum] + cnt_l[1-sum];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311077,
                "title": "c-hash-table",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long help(int n,vector<int> v,int k){\\n      long long ans=0;\\n      long long crr=0;\\n      map<long long,long long>m;\\n      m[0]=1;\\n      long long sum=0;\\n      for(int i=0;i<n;i++){\\n          if(v[i]<k){\\n              sum--;\\n              crr -= m[sum];\\n          }\\n          else {\\n              crr += m[sum];\\n              sum++;\\n          }\\n          ans+=crr;\\n          m[sum]++;\\n      }\\n      return ans;\\n  }\\n    int countSubarrays(vector<int>& v, int k) {\\n        int n=v.size();\\n        return help(n,v,k) - help(n,v,k+1);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/6e7fd028-fd06-4680-acf3-c952d7a98c46_1679138149.9420476.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long help(int n,vector<int> v,int k){\\n      long long ans=0;\\n      long long crr=0;\\n      map<long long,long long>m;\\n      m[0]=1;\\n      long long sum=0;\\n      for(int i=0;i<n;i++){\\n          if(v[i]<k){\\n              sum--;\\n              crr -= m[sum];\\n          }\\n          else {\\n              crr += m[sum];\\n              sum++;\\n          }\\n          ans+=crr;\\n          m[sum]++;\\n      }\\n      return ans;\\n  }\\n    int countSubarrays(vector<int>& v, int k) {\\n        int n=v.size();\\n        return help(n,v,k) - help(n,v,k+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852028,
                "title": "java-solution-with-detailed-explanation",
                "content": "\\n# Background:\\nIf K is the median of a sub array, then the subarray must contain K \\n\\nNow let\\u2019s compute the SUM OF SUBARRAY as follows, for each element in the subarray greater than K, add one to the sum. For each element in the subarray less than K, subtract one from the sum.\\nFor example suppose K = 4 and we have a subarray [3, 4, 1, 5, 6]\\nSUM OF SUBARRAY [3, 4, 1, 5, 6] -> [-1,0,-1,1,1] -> -1 + 0 + -1 + 1 + 1 = 0\\nNotice that for K to be the median of a subarray, the SUM OF SUBARRAY should be 0 for odd length and 1 for even length\\n\\n# Solution:\\nFirst find the index of K, for simplicity, let\\u2019s call that k\\n\\nThen for elements to the right, k <= r <= n - 1, compute the SUM OF SUBARRAY (k, r) on a rolling basis, and store the frequency of each unique sum using a frequency map\\n\\nNext iterate backwards from k to 0,  k >= l >= 0. During the iteration compute the SUM OF SUBARRAY (l, k) on a rolling basis. For each index, we want to compute the number of subarrays where the median is k that starts at that index l. Since the subarrays must contain the index k and the SUM OF SUBARRAY must be either 1 or 0. We can easily find the number of subarrays that has k as median starting as l by finding the frequency map created for the elements to the right and finding the frequency of the values ( 0 - SUM OF SUBARRAY ( l , k) ) and ( 1 - SUM OF SUBARRAY ( l , k)  ). \\n\\n\\nPlease upvote if you like the solution :)\\n\\n# Code \\n\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int idx = 0;\\n        \\n        for (int i = 0; i < nums.length; ++i){\\n            if (nums[i] == k){\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int sum = 0;\\n        \\n        for (int i = idx; i < nums.length; ++i){\\n            sum += nums[i] == k ? 0 : nums[i] > k ? 1 : -1;\\n            \\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        long result = 0;\\n        sum = 0;\\n        \\n        for (int i = idx; i >= 0; --i){\\n            sum += nums[i] == k ? 0 : nums[i] > k ? 1 : -1;\\n            \\n            result += map.getOrDefault(0 - sum , 0);\\n            result += map.getOrDefault(1 - sum , 0);\\n        }\\n        \\n        return (int) result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int idx = 0;\\n        \\n        for (int i = 0; i < nums.length; ++i){\\n            if (nums[i] == k){\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int sum = 0;\\n        \\n        for (int i = idx; i < nums.length; ++i){\\n            sum += nums[i] == k ? 0 : nums[i] > k ? 1 : -1;\\n            \\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        }\\n        \\n        long result = 0;\\n        sum = 0;\\n        \\n        for (int i = idx; i >= 0; --i){\\n            sum += nums[i] == k ? 0 : nums[i] > k ? 1 : -1;\\n            \\n            result += map.getOrDefault(0 - sum , 0);\\n            result += map.getOrDefault(1 - sum , 0);\\n        }\\n        \\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852112,
                "title": "c-sub-array-sum-easy-trick",
                "content": "Trick - turn every larger element to -1\\nevery smaller element to 1\\nevery equal element to some larger value (I have used 1e5 * 2)\\n\\nthen answer will be subset sum (1e5 * 2 ) + subset sum(1e5 * 2 - 1) [ for even sized sub array]\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int f = 0;\\n        \\n        int n = nums.size();\\n    \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n             if(nums[i] == k) nums[i] = 1e5 + 1e5;\\n             else if(nums[i] > k) nums[i] = -1;\\n             else nums[i] = 1;\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        k = 1e5 + 1e5;\\n        int sum =0;\\n        for(auto i:nums){\\n            sum+=i;\\n            \\n            if(sum==k) ans++;\\n            if(mp.find(sum - k)!= mp.end()) \\n            {\\n                ans+= mp[sum - k];\\n            }\\n            \\n            if(sum == k-1) ans++;\\n            if(mp.find(sum - (k-1))!= mp.end())\\n            {\\n                ans+= mp[sum - (k-1)];\\n            }\\n            \\n            mp[sum]++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int f = 0;\\n        \\n        int n = nums.size();\\n    \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n             if(nums[i] == k) nums[i] = 1e5 + 1e5;\\n             else if(nums[i] > k) nums[i] = -1;\\n             else nums[i] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2867210,
                "title": "python-o-n-picture-video-solution",
                "content": "You can watch the [video](https://youtu.be/oLEKpPXUgm4) solution.\\n\\n# Conditions for valid subarray\\n\\n\\n![image](https://assets.leetcode.com/users/images/86862115-3d3c-4073-8f26-12605859ce3e_1669914345.9148488.png)\\n\\nThe condition for a valid subarray:\\n* Must include `K`\\n* Difference in counts:\\n\\t* For **Odd length** subarray, ```no. of elements smaller than K = no. of elements greater than K ```\\n\\t* For **Even length** subarray, ```(no. of elements smaller than K) + 1 = no. of elements greater than K ```\\n\\n # Valid Subarrays\\n\\n![image](https://assets.leetcode.com/users/images/2bf09857-97bf-4295-9b62-84c7cf6a4164_1669914779.414956.png)\\n\\n# Counting pairs using our conditions\\n\\n![image](https://assets.leetcode.com/users/images/86578a00-7090-44af-9388-4c028205c417_1669914860.6937165.png)\\n\\n\\nSince we are dealing only with the difference between the count of **smaller** elements & **greater** elements, we can just store the difference between them for each index in our array starting from the **Median K**.\\n\\n```\\nbal += 1 if num > k else (-1 if num < k else 0)\\n```\\n\\nWe just have to do it for any one side ( let\\'s assume right) from **Median K**. \\n\\n![image](https://assets.leetcode.com/users/images/785bc191-cd01-417b-ab51-2ae471870f70_1669915194.3069923.png)\\n\\n\\nWe can store it in a HashMap where the key would be the `difference ( balance) ` and the value would be its `count`.\\n\\nWe now, have to go just left and using our conditions find pairs for both odd & even length.\\n\\nWhile going left, we have to calculate our `balance` on the fly, \\n* for the odd length subarrays, we have to try to pair it with  `cnt[-bal]`\\n* for the even length subarrays, we have to try to pair it with `cnt[-bal + 1]`.\\n\\n\\n# Time & Space Complexity\\n\\n`Time: O(n)` We are only going through the elements only once.\\n\\n`Space: O(n)` We are using a HashMap.\\n\\nIf you thought this was helpful, please upvote, like the video and subscribe to the channel.\\n\\nCheers.\\n\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        pos = nums.index(k)\\n        \\n        cnt = defaultdict(int)\\n        \\n        bal=0\\n        for i in range(pos, n):\\n            num = nums[i]\\n            \\n            bal += 1 if num > k else (-1 if num < k else 0)\\n            cnt[bal] += 1\\n            \\n        res=0\\n        bal=0\\n        for i in reversed(range(pos+1)):\\n            num = nums[i]\\n            \\n            bal += 1 if num > k else (-1 if num < k else 0)\\n            \\n            res += cnt[-bal] # ODD\\n            res += cnt[-bal + 1] # EVEN\\n            \\n        return res\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```no. of elements smaller than K = no. of elements greater than K ```\n```(no. of elements smaller than K) + 1 = no. of elements greater than K ```\n```\\nbal += 1 if num > k else (-1 if num < k else 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2853676,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        m[0] = 1;\\n        int found = 0, ans = 0, s = 0;\\n        \\n        for(int i : nums) {\\n            if(i == k) found = 1;\\n            else s += i < k ? -1 : 1;\\n\\n            if(found) ans += m[s - 1] + m[s];\\n            else m[s]++; \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        m[0] = 1;\\n        int found = 0, ans = 0, s = 0;\\n        \\n        for(int i : nums) {\\n            if(i == k) found = 1;\\n            else s += i < k ? -1 : 1;\\n\\n            if(found) ans += m[s - 1] + m[s];\\n            else m[s]++; \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852407,
                "title": "very-easy-beginner-friendly-c-solution-using-map-beats",
                "content": "```\\nint countSubarrays(vector<int>& p, int m) {\\n    map<int, int> c;\\n    c[0] = 1;\\n    bool flag = false;\\n    int sum = 0;\\n    int n=p.size();\\n    long long ans = 0;\\n    for (int i = 0; i < n; i++) {\\n \\n     \\n        if (p[i] < m)\\n            sum--;\\n        else if (p[i] > m)\\n            sum++;\\n        if (p[i] == m)\\n            flag = true;\\n        \\n        \\n        if (flag)\\n            ans += c[sum] + c[sum - 1];\\n        else\\n            c[sum]++;\\n    }\\n \\n    return ans;\\n    }\\n\\t\\n\\t//Upvote if u got the solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countSubarrays(vector<int>& p, int m) {\\n    map<int, int> c;\\n    c[0] = 1;\\n    bool flag = false;\\n    int sum = 0;\\n    int n=p.size();\\n    long long ans = 0;\\n    for (int i = 0; i < n; i++) {\\n \\n     \\n        if (p[i] < m)\\n            sum--;\\n        else if (p[i] > m)\\n            sum++;\\n        if (p[i] == m)\\n            flag = true;\\n        \\n        \\n        if (flag)\\n            ans += c[sum] + c[sum - 1];\\n        else\\n            c[sum]++;\\n    }\\n \\n    return ans;\\n    }\\n\\t\\n\\t//Upvote if u got the solution",
                "codeTag": "Unknown"
            },
            {
                "id": 2852297,
                "title": "number-of-subarrays-with-sum-k-breaks-to-standard-problem",
                "content": "**if median is k then u** need equal number of elements on both sides ? \\nthen ->\\n**for every index i cou**nt the numbers greater than and less than k then store the difference (diff)\\nthen search for diff and diff-1 why ?\\ndiff case  : suppose \\ncntl = number of elements less than k \\ncntr = number of elements greater than k \\n\\n**assume at i : cntl = 3, cntr = 7 , diff = -4**\\nthis difference can help if u search for this diff the all subarrys u can count why ?\\ncurrent cntl = 3, cntr = 7 , diff = -4\\nthen search for diff = -4 , if u get 3 suppose then there are 3 subaarys with median as k why ?\\n3 7 -> diff = -4 , \\n2 6  -> diff = -4 , the subaary between this have cntl = 1 ,cntr = 1   \\n1 5  -> diff = -4 , the subaary between this have cntl = 2 ,cntr = 2\\nso u can see that if we search for this diff we always get cntl == cntr \\nnow u can understand the code and think for even number of elements and do solve the pre requisite problem which is the heading itself \\n![image](https://assets.leetcode.com/users/images/a76616b2-1c07-43d8-b6f2-9057fbf7c7e1_1669522702.2926416.png)\\n\\n  \\n```\\nint countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        bool is = false;\\n        \\n        unordered_map<int,int> um;\\n        \\n        int cntl = 0, cntg = 0;\\n        um[0]++;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == k){\\n                is = true;\\n            }\\n            \\n            if(nums[i] > k){\\n                cntg++;\\n            }else{\\n                cntl++;\\n            }\\n            \\n            int diff = cntl - cntg;\\n            \\n            if(is == true){\\n                if(um.find(diff) != um.end()){\\n                    ans += um[diff];\\n                }\\n                if(um.find(diff-1) != um.end()){\\n                    ans += um[diff-1];\\n                }\\n            }\\n            if(is == false)\\n            um[diff]++;\\n        }\\n                \\n        return ans;\\n       \\n    }",
                "solutionTags": [],
                "code": "**if median is k then u** need equal number of elements on both sides ? \\nthen ->\\n**for every index i cou**nt the numbers greater than and less than k then store the difference (diff)\\nthen search for diff and diff-1 why ?\\ndiff case  : suppose \\ncntl = number of elements less than k \\ncntr = number of elements greater than k \\n\\n**assume at i : cntl = 3, cntr = 7 , diff = -4**\\nthis difference can help if u search for this diff the all subarrys u can count why ?\\ncurrent cntl = 3, cntr = 7 , diff = -4\\nthen search for diff = -4 , if u get 3 suppose then there are 3 subaarys with median as k why ?\\n3 7 -> diff = -4 , \\n2 6  -> diff = -4 , the subaary between this have cntl = 1 ,cntr = 1   \\n1 5  -> diff = -4 , the subaary between this have cntl = 2 ,cntr = 2\\nso u can see that if we search for this diff we always get cntl == cntr \\nnow u can understand the code and think for even number of elements and do solve the pre requisite problem which is the heading itself \\n![image](https://assets.leetcode.com/users/images/a76616b2-1c07-43d8-b6f2-9057fbf7c7e1_1669522702.2926416.png)\\n\\n  \\n```\\nint countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        bool is = false;\\n        \\n        unordered_map<int,int> um;\\n        \\n        int cntl = 0, cntg = 0;\\n        um[0]++;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == k){\\n                is = true;\\n            }\\n            \\n            if(nums[i] > k){\\n                cntg++;\\n            }else{\\n                cntl++;\\n            }\\n            \\n            int diff = cntl - cntg;\\n            \\n            if(is == true){\\n                if(um.find(diff) != um.end()){\\n                    ans += um[diff];\\n                }\\n                if(um.find(diff-1) != um.end()){\\n                    ans += um[diff-1];\\n                }\\n            }\\n            if(is == false)\\n            um[diff]++;\\n        }\\n                \\n        return ans;\\n       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2851992,
                "title": "c-easy",
                "content": "# **Intution : **\\n# First find the index of the element k \\t\\t         \\n# \\nNow create left array to store the number which may be the part of the left and tells the position of number \\'k\\' from the increment for the number which are less than \\'k\\' and decrement for the number which are greater than \\'k\\'         \\nIf contribute towards the left part then increment by 1 and if contribute towards the right part then decrement by 1\\n\\nNow create right array to store the number which may be the part of the right and tells the position of number \\'k\\' from the increment for the number which are greater than \\'k\\' and for the number which are less than \\'k\\'  \\t\\t\\t \\t\\t\\t         \\nIf contribute towards the left part then decrement by 1 and if contribute towards the right part then increment by 1\\n\\nSort both the left and right array \\t\\t \\t\\t         \\n\\nAfter sorting the subarray          \\nLet there are \\'x\\' element in right         \\nthen for the MEDIAN to be \\'k\\' there should be \\'x\\' or \\'x-1\\'element in left                  \\n\\nFor example array = [3, 4, 5, 6, 7]         \\nHere for element \\'5\\' to be MEDIAN, there are 2 element in the right and 2 element in the left                          \\narray = [3, 4, 5, 6, 7, 8]                         \\nHere for element \\'5\\' to be MEDIAN, there are 3 element in the right and 2 element in the left                           \\n\\n\\nFor each element \\'x\\' in right array          \\nfind how many element are there in left array which are equal to \\'x\\'  +   how many element are there in left array which are equal to \\'x-1\\'         \\n\\nApply Binary Search to find in O(logn) for each element \\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        \\n        int id = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == k ) {\\n                id = i;\\n                break;\\n            }\\n        }\\n        \\n        vector<int>left , right;\\n        left.push_back(0);\\n        right.push_back(0);\\n        \\n        int ct = 0;\\n        for(int i = id-1; i>=0; i--){\\n            if(nums[i] < k) ct++;\\n            else ct--;\\n            \\n            left.push_back(ct);\\n        }\\n        \\n        ct = 0;\\n        for(int i = id+1; i<nums.size(); i++){\\n            if(nums[i] > k) ct++;\\n            else ct--;\\n            \\n            right.push_back(ct);\\n        }\\n        \\n        sort(left.begin() , left.end());\\n        sort(right.begin() , right.end());\\n\\n        int ans  = 0;\\n        for(auto i : right){\\n            vector<int>::iterator lower, upper;\\n            lower = lower_bound(left.begin(), left.end() , i);\\n            upper = upper_bound(left.begin(), left.end() , i);            \\n            ans += upper - lower;\\n            \\n            \\n            lower = lower_bound(left.begin(), left.end() , i-1);\\n            upper = upper_bound(left.begin(), left.end() , i-1);            \\n            ans += upper - lower;\\n        }\\n        return ans;        \\n    }\\n    \\n};\\n```\\n\\n\\n\\n**Code with explanations**\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        \\n        //First find the index of the element k\\n        int id = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == k ) {\\n                id = i;\\n                break;\\n            }\\n        }\\n        \\n        // Now create left array to store the number which may be the part of the left subarray \\n        //     and tells the postion of number \\'k\\' from the left\\n        //     increment for the number which are less than \\'k\\' and decrement for the number which are greater than \\'k\\'\\n        // Now create right array to store the number which may be the part of the right subarray \\n        //     and tells the postion of number \\'k\\' from the right                \\n        //     increment for the number which are greater than \\'k\\' and decrement for the number which are less than \\'k\\' \\n        \\n        vector<int>left , right;\\n        left.push_back(0);\\n        right.push_back(0);\\n        \\n        int ct = 0;\\n        for(int i = id-1; i>=0; i--){\\n            if(nums[i] < k) ct++;\\n            else ct--;\\n            \\n            left.push_back(ct);\\n        }\\n        \\n        ct = 0;\\n        for(int i = id+1; i<nums.size(); i++){\\n            if(nums[i] > k) ct++;\\n            else ct--;\\n            \\n            right.push_back(ct);\\n        }\\n        \\n        //Sort both the left and right array\\n        sort(left.begin() , left.end());\\n        sort(right.begin() , right.end());\\n\\n//         After sorting the subarray \\n//         Let there are \\'x\\' element in right\\n//         then for the MEDIAN to be \\'k\\' there should be \\'x\\' or \\'x-1\\'element in left\\n        \\n//         For example array = [3, 4, 5, 6, 7]\\n//         Here for element \\'5\\' to be MEDIAN, there are 2 element in the right and 2 element in the left\\n                \\n//         array = [3, 4, 5, 6, 7, 8]                \\n//         Here for element \\'5\\' to be MEDIAN, there are 3 element in the right and 2 element in the left\\n        \\n        \\n        \\n        // For each element \\'x\\' in right array \\n        // find how many element are there in left array which are equal to \\'x\\'\\n        //     +  how many element are there in left array which are equal to \\'x-1\\'\\n        // Apply Binary Search to find in O(logn) for each element \\n        int ans  = 0;\\n        for(auto i : right){\\n            vector<int>::iterator lower, upper;\\n            lower = lower_bound(left.begin(), left.end() , i);\\n            upper = upper_bound(left.begin(), left.end() , i);            \\n            ans += upper - lower;            \\n            \\n            lower = lower_bound(left.begin(), left.end() , i-1);\\n            upper = upper_bound(left.begin(), left.end() , i-1);            \\n            ans += upper - lower;\\n        }\\n        return ans;        \\n    }\\n    \\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        \\n        int id = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == k ) {\\n                id = i;\\n                break;\\n            }\\n        }\\n        \\n        vector<int>left , right;\\n        left.push_back(0);\\n        right.push_back(0);\\n        \\n        int ct = 0;\\n        for(int i = id-1; i>=0; i--){\\n            if(nums[i] < k) ct++;\\n            else ct--;\\n            \\n            left.push_back(ct);\\n        }\\n        \\n        ct = 0;\\n        for(int i = id+1; i<nums.size(); i++){\\n            if(nums[i] > k) ct++;\\n            else ct--;\\n            \\n            right.push_back(ct);\\n        }\\n        \\n        sort(left.begin() , left.end());\\n        sort(right.begin() , right.end());\\n\\n        int ans  = 0;\\n        for(auto i : right){\\n            vector<int>::iterator lower, upper;\\n            lower = lower_bound(left.begin(), left.end() , i);\\n            upper = upper_bound(left.begin(), left.end() , i);            \\n            ans += upper - lower;\\n            \\n            \\n            lower = lower_bound(left.begin(), left.end() , i-1);\\n            upper = upper_bound(left.begin(), left.end() , i-1);            \\n            ans += upper - lower;\\n        }\\n        return ans;        \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        \\n        //First find the index of the element k\\n        int id = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == k ) {\\n                id = i;\\n                break;\\n            }\\n        }\\n        \\n        // Now create left array to store the number which may be the part of the left subarray \\n        //     and tells the postion of number \\'k\\' from the left\\n        //     increment for the number which are less than \\'k\\' and decrement for the number which are greater than \\'k\\'\\n        // Now create right array to store the number which may be the part of the right subarray \\n        //     and tells the postion of number \\'k\\' from the right                \\n        //     increment for the number which are greater than \\'k\\' and decrement for the number which are less than \\'k\\' \\n        \\n        vector<int>left , right;\\n        left.push_back(0);\\n        right.push_back(0);\\n        \\n        int ct = 0;\\n        for(int i = id-1; i>=0; i--){\\n            if(nums[i] < k) ct++;\\n            else ct--;\\n            \\n            left.push_back(ct);\\n        }\\n        \\n        ct = 0;\\n        for(int i = id+1; i<nums.size(); i++){\\n            if(nums[i] > k) ct++;\\n            else ct--;\\n            \\n            right.push_back(ct);\\n        }\\n        \\n        //Sort both the left and right array\\n        sort(left.begin() , left.end());\\n        sort(right.begin() , right.end());\\n\\n//         After sorting the subarray \\n//         Let there are \\'x\\' element in right\\n//         then for the MEDIAN to be \\'k\\' there should be \\'x\\' or \\'x-1\\'element in left\\n        \\n//         For example array = [3, 4, 5, 6, 7]\\n//         Here for element \\'5\\' to be MEDIAN, there are 2 element in the right and 2 element in the left\\n                \\n//         array = [3, 4, 5, 6, 7, 8]                \\n//         Here for element \\'5\\' to be MEDIAN, there are 3 element in the right and 2 element in the left\\n        \\n        \\n        \\n        // For each element \\'x\\' in right array \\n        // find how many element are there in left array which are equal to \\'x\\'\\n        //     +  how many element are there in left array which are equal to \\'x-1\\'\\n        // Apply Binary Search to find in O(logn) for each element \\n        int ans  = 0;\\n        for(auto i : right){\\n            vector<int>::iterator lower, upper;\\n            lower = lower_bound(left.begin(), left.end() , i);\\n            upper = upper_bound(left.begin(), left.end() , i);            \\n            ans += upper - lower;            \\n            \\n            lower = lower_bound(left.begin(), left.end() , i-1);\\n            upper = upper_bound(left.begin(), left.end() , i-1);            \\n            ans += upper - lower;\\n        }\\n        return ans;        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853941,
                "title": "c-prefix-sum-o-n-explanation",
                "content": "\\nIn the following source code, \\ncountSol(vk,q,0) will figure out all possible odd size subarray.\\ncountSol(vk,q,-1) will fiture out all possible even size subarray.\\nFor example, \\nInput: nums = [3,2,1,4,5], k = 4\\nOutput: 3\\nThe subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5].\\nThe cases [4] & [1,4,5] are counted up in countSol(vk,q,0).\\nThe case [4,5] is counted up in countSol(vk,q,-1). \\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size(), q=0;//q will be index of k in nums\\n        vector<int> vk = vector<int>(n,0);        \\n        for(int i = 0; i<n; i++) if((nums[i]-k)!=0) vk[i] = abs(nums[i]-k)/(nums[i]-k); //e.g. [3,2,1,4,5], k = 4, then let vk\\' = [-1,-1,-1,0,1]\\n        for(int i = 1; i<n; i++) vk[i] = vk[i-1] + vk[i]; //let vk be the prefix sum of vk\\'. \\n        for(int i = 0;i<n;i++) if(nums[i] == k) q = i;\\n        return countSol(vk,q,0) + countSol(vk,q,-1);\\n    }\\n\\t\\n    int countSol(vector<int>&vk, int &q, int added) {\\n        int n = vk.size(), ans=0;\\n        unordered_map<int,vector<int>> mpL, mpR;\\n        for(int L = 0; L<=q;L++) mpL[getSum(L,q,vk)+added].push_back(L); \\n        for(int R = q;R<n;R++) mpR[getSum(q,R,vk)].push_back(R);\\n        for(auto& [sum,idxs]:mpL) ans+=idxs.size() * mpR[sum*-1].size();\\n        return ans;\\n    }\\n\\n    int getSum(int L, int R, vector<int> &vk) {//return sum of vk\\'[L..R]\\n        int vk_R = vk[R], vk_L_1 = (L==0)?0:vk[L-1];\\n        return vk_R-vk_L_1;\\n    }\\n\\t\\n};\\n```\\n\\nTime complexity O(N)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size(), q=0;//q will be index of k in nums\\n        vector<int> vk = vector<int>(n,0);        \\n        for(int i = 0; i<n; i++) if((nums[i]-k)!=0) vk[i] = abs(nums[i]-k)/(nums[i]-k); //e.g. [3,2,1,4,5], k = 4, then let vk\\' = [-1,-1,-1,0,1]\\n        for(int i = 1; i<n; i++) vk[i] = vk[i-1] + vk[i]; //let vk be the prefix sum of vk\\'. \\n        for(int i = 0;i<n;i++) if(nums[i] == k) q = i;\\n        return countSol(vk,q,0) + countSol(vk,q,-1);\\n    }\\n\\t\\n    int countSol(vector<int>&vk, int &q, int added) {\\n        int n = vk.size(), ans=0;\\n        unordered_map<int,vector<int>> mpL, mpR;\\n        for(int L = 0; L<=q;L++) mpL[getSum(L,q,vk)+added].push_back(L); \\n        for(int R = q;R<n;R++) mpR[getSum(q,R,vk)].push_back(R);\\n        for(auto& [sum,idxs]:mpL) ans+=idxs.size() * mpR[sum*-1].size();\\n        return ans;\\n    }\\n\\n    int getSum(int L, int R, vector<int> &vk) {//return sum of vk\\'[L..R]\\n        int vk_R = vk[R], vk_L_1 = (L==0)?0:vk[L-1];\\n        return vk_R-vk_L_1;\\n    }\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852521,
                "title": "c-easy-solution-using-unordered-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        bool flag = false;\\n        int sum = 0;\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] < k){\\n                sum--;\\n            }\\n            else if(nums[i]>k){\\n                sum++;\\n            }\\n            if (nums[i] == k){\\n                flag=true;\\n            }\\n            if (flag){\\n                ans += mp[sum] + mp[sum - 1];\\n            }\\n            else{\\n                mp[sum]++;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        bool flag = false;\\n        int sum = 0;\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++){\\n            if (nums[i] < k){\\n                sum--;\\n            }\\n            else if(nums[i]>k){\\n                sum++;\\n            }\\n            if (nums[i] == k){\\n                flag=true;\\n            }\\n            if (flag){\\n                ans += mp[sum] + mp[sum - 1];\\n            }\\n            else{\\n                mp[sum]++;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852091,
                "title": "python-prefix-sum-o-n",
                "content": "First we transform `nums` into an array of -1, 0, 1: \\nn < k to -1, n == k to 0, n > k to 1.\\nFor example, `nums` = [5,1,3,4,2], k = 4 -> arr = [1,-1,-1,0,-1]\\n\\nFor a subarray with sum equals to 0, number of {n: n < k} = number of {n: n > k}.\\nFor a subarray with sum equals to 1, number of {n: n < k} = number of {n: n > k} - 1.\\nEvery subarray containing 0 and with sum equals to 0(odd length) or 1(even length) counts.\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        arr = []\\n        for n in nums:\\n            if n < k:\\n                arr.append(-1)\\n            elif n > k:\\n                arr.append(1)\\n            else:\\n                arr.append(0)\\n        \\n        book_pre = Counter()\\n        book_pre[0] = 1\\n        agg = 0\\n        check = False\\n        ans = 0\\n        for a in arr:\\n            if a == 0:\\n                check = True\\n            agg += a\\n            if check:\\n                ans += book_pre[agg] + book_pre[agg-1]\\n            else:\\n                book_pre[agg] += 1\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "First we transform `nums` into an array of -1, 0, 1: \\nn < k to -1, n == k to 0, n > k to 1.\\nFor example, `nums` = [5,1,3,4,2], k = 4 -> arr = [1,-1,-1,0,-1]\\n\\nFor a subarray with sum equals to 0, number of {n: n < k} = number of {n: n > k}.\\nFor a subarray with sum equals to 1, number of {n: n < k} = number of {n: n > k} - 1.\\nEvery subarray containing 0 and with sum equals to 0(odd length) or 1(even length) counts.\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        arr = []\\n        for n in nums:\\n            if n < k:\\n                arr.append(-1)\\n            elif n > k:\\n                arr.append(1)\\n            else:\\n                arr.append(0)\\n        \\n        book_pre = Counter()\\n        book_pre[0] = 1\\n        agg = 0\\n        check = False\\n        ans = 0\\n        for a in arr:\\n            if a == 0:\\n                check = True\\n            agg += a\\n            if check:\\n                ans += book_pre[agg] + book_pre[agg-1]\\n            else:\\n                book_pre[agg] += 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2852030,
                "title": "java-prefixsum-of-1-0-1-total-left-right-commented",
                "content": "1. find index of k, and convert array into -1, 0, 1\\n2.  calculate the prefix Sum\\n3. calculate three range: total [0, n - 1]  - left[0, idxK - 1] - right[idxK + 1]; ( exclude case without `k`)\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        // 1. find index of k, and convert array into -1, 0, 1\\n        int idxK = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < k) nums[i] = -1;\\n            else if (nums[i] > k) nums[i] = 1;\\n            else {\\n                idxK = i;\\n                nums[i] = 0;\\n            }\\n        }\\n        // 2. calculate the prefix Sum\\n        int[] prefixSum = new int[nums.length + 1];\\n        \\n        for (int i = 1; i < prefixSum.length; i++) prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        \\n        // 3. calculate three range: total [0, n - 1]  - left[0, idxK - 1] - right[idxK + 1];\\n        int left = helper(0, idxK, prefixSum);\\n        int right = helper(idxK + 1, nums.length, prefixSum);\\n        int total = helper( 0, nums.length, prefixSum);\\n        \\n        return total - left - right;\\n    }\\n    \\n    // calculate current interval, subarray sum = 0 and 1;\\n    private int helper(int l, int r, int[] prefixSum) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        \\n        int ans = 0;\\n        for (int i = l; i <= r; i++) {\\n            int currSum = prefixSum[i];\\n            \\n            if (counter.containsKey(currSum)) {\\n                ans += counter.get(currSum);\\n            }\\n            \\n            if (counter.containsKey(currSum - 1)) {\\n                ans += counter.get(currSum - 1);\\n            }\\n            \\n            counter.put(currSum, counter.getOrDefault(currSum, 0) + 1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        // 1. find index of k, and convert array into -1, 0, 1\\n        int idxK = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < k) nums[i] = -1;\\n            else if (nums[i] > k) nums[i] = 1;\\n            else {\\n                idxK = i;\\n                nums[i] = 0;\\n            }\\n        }\\n        // 2. calculate the prefix Sum\\n        int[] prefixSum = new int[nums.length + 1];\\n        \\n        for (int i = 1; i < prefixSum.length; i++) prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        \\n        // 3. calculate three range: total [0, n - 1]  - left[0, idxK - 1] - right[idxK + 1];\\n        int left = helper(0, idxK, prefixSum);\\n        int right = helper(idxK + 1, nums.length, prefixSum);\\n        int total = helper( 0, nums.length, prefixSum);\\n        \\n        return total - left - right;\\n    }\\n    \\n    // calculate current interval, subarray sum = 0 and 1;\\n    private int helper(int l, int r, int[] prefixSum) {\\n        Map<Integer, Integer> counter = new HashMap<>();\\n        \\n        int ans = 0;\\n        for (int i = l; i <= r; i++) {\\n            int currSum = prefixSum[i];\\n            \\n            if (counter.containsKey(currSum)) {\\n                ans += counter.get(currSum);\\n            }\\n            \\n            if (counter.containsKey(currSum - 1)) {\\n                ans += counter.get(currSum - 1);\\n            }\\n            \\n            counter.put(currSum, counter.getOrDefault(currSum, 0) + 1);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852025,
                "title": "python-multiply-diff-counts-around-median-o-n-solution-w-explanation",
                "content": "# Intuition\\n**Brute Force - O(n^3)**\\nYou should always start by coming up with the brute force solution. In this case, we can check every possible subarray, count the number of elements above/below the median, and check that the median exists in the subarray. As long as there are the same number of elements above/below, or there is 1 more above than below, then the subarray is accepted.\\n\\n\\nEx: [1,2,3,4], k=2\\n[1] - no\\n[1,2] - no\\n[1,2,3] - yes (1 below, 1 above)\\n[1,2,3,4] - yes (1 below, 2 above)\\n[2] - yes\\n[2,3] - yes (0 below, 1 above)\\n[2,3,4] - no\\n...other subarrays do not contain 3 so they would be invalid.\\n\\n\\n---\\n\\n\\n\\n**Optimization to O(n^2)**\\nSince the size of nums can be very large (up to 10^5), it\\'s clear we need a solution with O(n) time. It\\'s also clear that any subarray that doesn\\'t contain k is useless, so our 1st potential approach could be to find where k is in nums. After that, perhaps we can use some sort of left and right pointer, expand the subarray being considered around k, and verify the total number of above elements is equal to (or 1 more greater) than the number of below elements being considered. \\n\\nNote: The left pointer will consider elements to the left of the median, and the right pointer for elements to the right of the median\\n\\n\\nEx: [1,2,3,4,5], k=3\\nl=1,r=3 yes\\nl=1,r=4 yes\\nl=0,r=3 no\\nl=0,r=4 yes\\n(There is also the subarray of just [3], which we can manually add to the 4 above for a total of 5)\\n\\n\\nWhile this makes sense, this still requires us to consider every possible combination of left pointer and right pointer so that we cover all possible subarrays that contain the median. This results in O(n^2) runtime - still a little slow.\\n\\n\\n# Approach\\n**Optimization to O(n)**\\nThe realization we need to make to reach O(n) time is the fact that we are going to see the same differences between above/below on the left side and right side of the median. And, we might see those same differences multiple times.\\n\\nExample: Let med = index of the median.\\nSuppose at some l < med, we have 3 above and 1 below, then the diff is -2 total (below - above). In order to set k as the median with these 4 elements on the left (3 above/1 below) we need to know all the subarrays to the right of med which can \"balance out\" the missing 2 below from the left side. \\n\\nIf we calculate the diffs of the above/below counts for all r, where med < r < n, then we would know instantly whether there are any subarrays to the right which have a diff of 2 (ie 2 more below than above). That\\'s all we need to balance out our left side.\\n\\nThe only hitch here is if we have a diff of -2 occurring multiple times on the left side. In that case, every one of those will need a diff of 2 on the right side. And if there were multiple diffs of 2 occurring on the right side, then every one those is a valid r to pick for completing the subarray. To handle this, we can do a standard multiplication to add all possible combinations of left side and right matching diffs.\\n\\nNote: To accommodate the fact that even arrays need 1 more above than below, we also multiply by -diff - 1 on the right side, which  represents the diffs that would have one extra above to add to our total subarray.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n\\n- `diff` represents the difference between the number of above/below elements (ie below - above)\\n- We initialize `res` with the left/right diffs of 0 since that represents subarrays that use elements only on the left/right side of the median. (Likewise for -1, where we have one extra above than below only on one side.)\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        med_i = nums.index(k)\\n\\n        left_of_med_diff_counts = collections.defaultdict(int)\\n        diff = 0\\n        for l in range(med_i - 1, -1, -1):\\n            diff += 1 if nums[l] < k else -1\\n            left_of_med_diff_counts[diff] += 1\\n\\n        right_of_med_diff_counts = collections.defaultdict(int)\\n        diff = 0\\n        for r in range(med_i + 1, n):\\n            diff += 1 if nums[r] < k else -1\\n            right_of_med_diff_counts[diff] += 1\\n\\n        res = left_of_med_diff_counts[0] + right_of_med_diff_counts[0] \\\\\\n              + left_of_med_diff_counts[-1] + right_of_med_diff_counts[-1] + 1\\n        for diff, total in left_of_med_diff_counts.items():\\n            res += (total * right_of_med_diff_counts[-diff]) + (total * right_of_med_diff_counts[-diff - 1])\\n        return res\\n```\\n\\nI hope that was helpful! (Please upvote if so)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        med_i = nums.index(k)\\n\\n        left_of_med_diff_counts = collections.defaultdict(int)\\n        diff = 0\\n        for l in range(med_i - 1, -1, -1):\\n            diff += 1 if nums[l] < k else -1\\n            left_of_med_diff_counts[diff] += 1\\n\\n        right_of_med_diff_counts = collections.defaultdict(int)\\n        diff = 0\\n        for r in range(med_i + 1, n):\\n            diff += 1 if nums[r] < k else -1\\n            right_of_med_diff_counts[diff] += 1\\n\\n        res = left_of_med_diff_counts[0] + right_of_med_diff_counts[0] \\\\\\n              + left_of_med_diff_counts[-1] + right_of_med_diff_counts[-1] + 1\\n        for diff, total in left_of_med_diff_counts.items():\\n            res += (total * right_of_med_diff_counts[-diff]) + (total * right_of_med_diff_counts[-diff - 1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851948,
                "title": "javascript-count-left-right-balance",
                "content": "**Solution: Count Left & Right Balance**\\n\\nFor a subarray to have median of `k`:\\n  1. The subarray must contain `k`.\\n  2. `k` must be the middle element (if odd) or lower mid element (if even).\\n\\nCreate subarrays revolving around `nums[i] = k`.\\n\\nHow do we find whether `k` is the mid/lower mid element?\\n*   Starting from `k`, count the \"balance\" on the left and right of `k`.\\n\\t*   If `nums[i] < k`, add `-1` to the balance.\\n\\t*   If `nums[i] > k`, add `1` to the balance.\\n* If `k` is the mid element, the left balance + right balance = `0`.\\n* If `k` is the lower mid element, left balance + right balance = `1`.\\n\\nStore the count of left balances in a hashmap.\\nGo through each right balance,\\n  `Balance = 0`: Count the number of left balances that are equal to (`-right balance`)\\n  `Balance = 1`: Count the number of left balances that are equal to (`-right balance + 1`)\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n```\\nvar countSubarrays = function(nums, k) {\\n  let n = nums.length, kIndex = nums.indexOf(k);\\n  let map = new Map(), leftBalance = 0;\\n  map.set(0, 1);\\n  for (let i = kIndex - 1; i >= 0; i--) {\\n    leftBalance += nums[i] > k ? 1 : -1;\\n    map.set(leftBalance, (map.get(leftBalance) || 0) + 1);\\n  }\\n  \\n  let rightBalance = 0, ans = 0;\\n  for (let j = kIndex; j < n; j++) {\\n    if (nums[j] !== k) rightBalance += nums[j] > k ? 1 : -1;\\n    let oddComplement = -rightBalance; // k = mid\\n    let evenComplement = -rightBalance + 1; // k = lower mid\\n    ans += (map.get(oddComplement) || 0);\\n    ans += (map.get(evenComplement) || 0);\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countSubarrays = function(nums, k) {\\n  let n = nums.length, kIndex = nums.indexOf(k);\\n  let map = new Map(), leftBalance = 0;\\n  map.set(0, 1);\\n  for (let i = kIndex - 1; i >= 0; i--) {\\n    leftBalance += nums[i] > k ? 1 : -1;\\n    map.set(leftBalance, (map.get(leftBalance) || 0) + 1);\\n  }\\n  \\n  let rightBalance = 0, ans = 0;\\n  for (let j = kIndex; j < n; j++) {\\n    if (nums[j] !== k) rightBalance += nums[j] > k ? 1 : -1;\\n    let oddComplement = -rightBalance; // k = mid\\n    let evenComplement = -rightBalance + 1; // k = lower mid\\n    ans += (map.get(oddComplement) || 0);\\n    ans += (map.get(evenComplement) || 0);\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2851946,
                "title": "2-sum-prefix-suffix-o-n",
                "content": "# Intuition\\nWe can reduce this problem to a 2Sum after pre-processing \\n\\n# Approach\\n\\nlet idx be the index of k in nums\\n1. find the prefix array where pre[i]= # of element > k - # of element < k in num[i:idx]\\n2. find the suffix array where suf[i]= # of element > k - # of element < k in num[idx:i]\\n\\nif pre[i] + suf[j] = 0, for subarray nums[i:j+1], we have # of element > k = # of element < k  ==> k is the median (for odd cases)\\n\\nsimilarly, if pre[i] + suf[j] = 1, for subarray nums[i:j+1], we have # of element > k = 1 + # of element < k  ==> k is the median (for even cases)\\n\\nthen, we just need to find all (i,j) pair where pre[i] + suf[j] = 0 or 1\\nthis becomes a 2Sum problem\\n\\n# Complexity\\nO(N)\\n\\n# Code\\n\\n\\n```\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        pre = defaultdict(int)\\n        suf = defaultdict(int)\\n        n = len(nums)\\n        idx = nums.index(k)\\n\\n        cur = 0  # bigger - smaller\\n        for i in range(idx)[::-1]:\\n            cur += 1 if nums[i] > k else - 1\\n            pre[cur] += 1\\n\\n        cur = 0  # smaller - bigger\\n        for i in range(idx + 1, n):\\n            cur += 1 if nums[i] < k else - 1\\n            suf[cur] += 1\\n\\n        res = 1 + pre[0] + suf[0] + pre[1] + suf[-1]\\n        for k, v in pre.items():\\n            res += v * (suf[k]) + v * (suf[k - 1])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        pre = defaultdict(int)\\n        suf = defaultdict(int)\\n        n = len(nums)\\n        idx = nums.index(k)\\n\\n        cur = 0  # bigger - smaller\\n        for i in range(idx)[::-1]:\\n            cur += 1 if nums[i] > k else - 1\\n            pre[cur] += 1\\n\\n        cur = 0  # smaller - bigger\\n        for i in range(idx + 1, n):\\n            cur += 1 if nums[i] < k else - 1\\n            suf[cur] += 1\\n\\n        res = 1 + pre[0] + suf[0] + pre[1] + suf[-1]\\n        for k, v in pre.items():\\n            res += v * (suf[k]) + v * (suf[k - 1])\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3807039,
                "title": "o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& a, int k) {\\n        long long ans=0;\\n        int n=a.size();\\n        int pf[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]>k)\\n            {\\n                pf[i]=1;\\n            }\\n            else if(a[i]==k)\\n            {\\n                pf[i]=0;\\n            }\\n            else{\\n                pf[i]=-1;\\n            }\\n        }\\n        map<int,int> mp;\\n        int sum=0;\\n        mp[0]=1;\\n        bool f=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=pf[i];\\n            if(pf[i]==0||f)\\n            {\\n                f=true;\\n                ans+=mp[sum]+mp[sum-1];\\n            }\\n            else{\\n                mp[sum]++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& a, int k) {\\n        long long ans=0;\\n        int n=a.size();\\n        int pf[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]>k)\\n            {\\n                pf[i]=1;\\n            }\\n            else if(a[i]==k)\\n            {\\n                pf[i]=0;\\n            }\\n            else{\\n                pf[i]=-1;\\n            }\\n        }\\n        map<int,int> mp;\\n        int sum=0;\\n        mp[0]=1;\\n        bool f=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=pf[i];\\n            if(pf[i]==0||f)\\n            {\\n                f=true;\\n                ans+=mp[sum]+mp[sum-1];\\n            }\\n            else{\\n                mp[sum]++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965782,
                "title": "c-easy-map-solution-using-simple-balance",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n       map<int,int> mp;\\n       int cnt=0;// no of elements\\n       int i=0,n=nums.size();\\n        bool found=false;\\n        mp[0]=1;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(nums[i]<k)//elements left of k we decrease cnt\\n                cnt--;\\n            else if(nums[i]>k)// elements right of k we increase cnt\\n                cnt++;\\n            else\\n                found=true;\\n            if(found)\\n            {\\n                ans+=mp[cnt]+mp[cnt-1];//if odd no of elements then no of elements right of k is equal to no of elements to left of k \\n\\t\\t\\t\\t//basically left count is equal to right cnt\\n\\t\\t\\t}                                  //if even no of elements then no of elements left is 1 less than no of elements to right     \\n            else\\n            mp[cnt]++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n       map<int,int> mp;\\n       int cnt=0;// no of elements\\n       int i=0,n=nums.size();\\n        bool found=false;\\n        mp[0]=1;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(nums[i]<k)//elements left of k we decrease cnt\\n                cnt--;\\n            else if(nums[i]>k)// elements right of k we increase cnt\\n                cnt++;\\n            else\\n                found=true;\\n            if(found)\\n            {\\n                ans+=mp[cnt]+mp[cnt-1];//if odd no of elements then no of elements right of k is equal to no of elements to left of k \\n\\t\\t\\t\\t//basically left count is equal to right cnt\\n\\t\\t\\t}                                  //if even no of elements then no of elements left is 1 less than no of elements to right     \\n            else\\n            mp[cnt]++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854624,
                "title": "c-transform-the-input-array-and-use-the-approach-of-target-sum-problem",
                "content": "Steps:\\n1) First transform the input array -> set the nums[i] == k to 0; nums[i] < k to -1; nums[i] > k to 1\\n     So for example: nums = [3,2,1,4,5], k = 4; nums -> [-1,-1,-1,0,1]\\n2) Start a cummulative sum of the transformed input array, from the k value element and store the cummulative sum\\'s freq in a map\\n\\t mp[0]=1, mp[1]=1;\\n3) Start the target sum approach from index of k value all the way to zero index. For finding the target sum we start with cummulative sum of the transformed array and find the match for the targets in the map already store in step 2. Also, there will be two targets to look for, namely target = 0 and target = 1. The reason for value 0 is we are looking for an odd size subarray whose median is k, hence we need to have equal number of values less than and greater than k along with the k element. The reason for value 1 is that we are looking here for even size subarray and the median will be on the left most element after we partition this subarray into two equal parts.\\n\\t\\ttarget = 0 - sum;\\n\\t\\ttarget2 = 1 - sum;\\n\\t\\tThe counts in the frequency map to these values will give us subarrays with required property as decribed in the problem and will always have the k element a part of the subarray.\\n\\t\\t\\n```cpp\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        \\n        int pivot = -1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == k)\\n            {\\n                pivot = i;\\n                break;\\n            }\\n        }\\n        \\n        int sum = 0;\\n        for(int i = pivot; i < n; i++)\\n        {\\n            if (nums[i] == k) sum += 0;\\n            else if (nums[i] < k) sum -= 1;\\n            else sum += 1;\\n            \\n            mp[sum]++;\\n        }\\n        \\n        sum = 0; \\n        int ans = 0;\\n        for(int i = pivot; i >= 0; i--)\\n        {\\n            if (nums[i] == k) sum += 0;\\n            else if (nums[i] < k) sum -= 1;\\n            else sum += 1;\\n            \\n            int target = 0 - sum;\\n            if (mp[target]) ans += mp[target];\\n            int target2 = 1 - sum;\\n            if (mp[target2]) ans += mp[target2];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please up vote or provide your comments/suggestions for improvements**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        \\n        int pivot = -1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == k)\\n            {\\n                pivot = i;\\n                break;\\n            }\\n        }\\n        \\n        int sum = 0;\\n        for(int i = pivot; i < n; i++)\\n        {\\n            if (nums[i] == k) sum += 0;\\n            else if (nums[i] < k) sum -= 1;\\n            else sum += 1;\\n            \\n            mp[sum]++;\\n        }\\n        \\n        sum = 0; \\n        int ans = 0;\\n        for(int i = pivot; i >= 0; i--)\\n        {\\n            if (nums[i] == k) sum += 0;\\n            else if (nums[i] < k) sum -= 1;\\n            else sum += 1;\\n            \\n            int target = 0 - sum;\\n            if (mp[target]) ans += mp[target];\\n            int target2 = 1 - sum;\\n            if (mp[target2]) ans += mp[target2];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852658,
                "title": "explanation",
                "content": "# Tricky Subarray counting !!!!!\\n![image](https://assets.leetcode.com/users/images/7739a802-4958-4da8-9f7b-8607fb1112da_1669528086.4760113.jpeg)\\n![image](https://assets.leetcode.com/users/images/5cd9a95c-4573-4600-8412-af4a0bf36ba9_1669528086.3098383.jpeg)\\n![image](https://assets.leetcode.com/users/images/90d0fd47-c286-4e8d-9539-a988a6191952_1669528086.3535602.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int subarray(vector<int> &arr , int k , int index){\\n        map<int , int> mp;\\n        mp[0] = 1;\\n        int cnt = 0;\\n        int sm  = 0;\\n        \\n        for (int i = 0 ; i < arr.size() ; i++){\\n            sm += arr[i];\\n            \\n            if (i >= index and mp.find(sm - k) != mp.end()){\\n                cnt += mp[sm-k];\\n            }\\n            \\n            if (i < index){\\n                mp[sm] += 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    \\n    int countSubarrays(vector<int>& nums, int k) {\\n        vector<int> arr;\\n        int index = -1;\\n        for (int i = 0 ; i  < nums.size() ; i++){\\n            int val = 0;\\n            if (nums[i] > k) val = 1;\\n            if (nums[i] < k) val = -1;\\n            if (nums[i] == k) {index = i ; val = 0;}\\n            arr.push_back(val);\\n        }\\n        \\n        if (index == -1) return 0;\\n        return subarray(arr , 0, index ) + subarray(arr , 1 , index);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarray(vector<int> &arr , int k , int index){\\n        map<int , int> mp;\\n        mp[0] = 1;\\n        int cnt = 0;\\n        int sm  = 0;\\n        \\n        for (int i = 0 ; i < arr.size() ; i++){\\n            sm += arr[i];\\n            \\n            if (i >= index and mp.find(sm - k) != mp.end()){\\n                cnt += mp[sm-k];\\n            }\\n            \\n            if (i < index){\\n                mp[sm] += 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    \\n    int countSubarrays(vector<int>& nums, int k) {\\n        vector<int> arr;\\n        int index = -1;\\n        for (int i = 0 ; i  < nums.size() ; i++){\\n            int val = 0;\\n            if (nums[i] > k) val = 1;\\n            if (nums[i] < k) val = -1;\\n            if (nums[i] == k) {index = i ; val = 0;}\\n            arr.push_back(val);\\n        }\\n        \\n        if (index == -1) return 0;\\n        return subarray(arr , 0, index ) + subarray(arr , 1 , index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852199,
                "title": "c-count-the-left-side-and-check-the-right-side",
                "content": "**Idea**\\nLet `large` be the count of larger numbers and `small` be the count of smaller numbers. \\nCalculate the `difference` (= large - small) of both side.\\nNow assume at the index i, we have difference = 2, which means we have 2 more \"largers\" than \"smallers\".\\nSo what we only need to do, is to find the count of difference = -2 (2 more \"smallers\") and difference = -1 (1 more \"smaller\") and add them to the result.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int kpos;\\n        int res = 0;\\n        \\n        //Find the index of k \\n        for(int i = 0, cnt = 0; i < n; i++){\\n            if(nums[i] == k) kpos = i;\\n        }\\n        \\n        //Left side of k (including k)\\n        unordered_map<int, int> m;\\n        for(int i = kpos, large = 0, small = 0; i >= 0; i--){\\n            if(nums[i] > k) large++;\\n            if(nums[i] < k) small++;\\n            m[large - small]++;\\n        }\\n        \\n        //Right side of k (including k)\\n        for(int i = kpos, large = 0, small = 0; i < n; i++){\\n            if(nums[i] > k) large++;\\n            if(nums[i] < k) small++;\\n            int d = large - small; //e.g. If d = 2, then we need m[-2] and also m[-1]\\n            res += m[-d];\\n            res += m[-(d - 1)];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int kpos;\\n        int res = 0;\\n        \\n        //Find the index of k \\n        for(int i = 0, cnt = 0; i < n; i++){\\n            if(nums[i] == k) kpos = i;\\n        }\\n        \\n        //Left side of k (including k)\\n        unordered_map<int, int> m;\\n        for(int i = kpos, large = 0, small = 0; i >= 0; i--){\\n            if(nums[i] > k) large++;\\n            if(nums[i] < k) small++;\\n            m[large - small]++;\\n        }\\n        \\n        //Right side of k (including k)\\n        for(int i = kpos, large = 0, small = 0; i < n; i++){\\n            if(nums[i] > k) large++;\\n            if(nums[i] < k) small++;\\n            int d = large - small; //e.g. If d = 2, then we need m[-2] and also m[-1]\\n            res += m[-d];\\n            res += m[-(d - 1)];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851969,
                "title": "python3-counting-o-n-with-explanations",
                "content": "**Hint1:** We record 1 if `num > k`; -1 if `num < k`, and 0 if `num == k`.\\n\\n**Hint2:** Let `pos` denote the index of `k` in `nums`, where `k` is the median. Then the problem is equivalent to:\\n1. `pos` is in the indices of the subarray;\\n2. the sum of the subarray is either `0` or `1`.\\n\\n**Hint3:** Let `c_i` be the # of `num > k` - the # of `num < k` for `num` in `nums[pos..i]`. We count the frequencies of `c_i` using a hashmap `cnt`. Then, let `c_i` be the # of `num < k` - the # of `num > k` for `num` in `nums[i..pos]`.\\nNow for each `i`,\\n* `cnt[c_i]` is the number of valid subarrays with odd length in **Hint 2**\\n* `cnt[c_i + 1]` is the number valid subarrays with even length in **Hint 2**\\n\\nWe can sum them up to get the final `ans`.\\n\\n**Complexity**\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n \\n**Solution (credit to @endlesscheng)**\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\tpos = nums.index(k)\\n        cnt = defaultdict(int)\\n        cnt[0] = 1\\n        c = 0\\n        for i in range(pos + 1, len(nums)):\\n            c += 1 if nums[i] > k else -1\\n            cnt[c] += 1\\n\\n        ans = cnt[0] + cnt[1]\\n        c = 0\\n        for i in range(pos - 1, -1, -1):\\n            c += 1 if nums[i] < k else -1\\n            ans += cnt[c] + cnt[c + 1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\t\\tpos = nums.index(k)\\n        cnt = defaultdict(int)\\n        cnt[0] = 1\\n        c = 0\\n        for i in range(pos + 1, len(nums)):\\n            c += 1 if nums[i] > k else -1\\n            cnt[c] += 1\\n\\n        ans = cnt[0] + cnt[1]\\n        c = 0\\n        for i in range(pos - 1, -1, -1):\\n            c += 1 if nums[i] < k else -1\\n            ans += cnt[c] + cnt[c + 1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851945,
                "title": "c-prefix-sum-count-o-n-short",
                "content": "First, find the index of `k`. \\n\\nConstruct 2 prefix sum, the sum equals to the number of integers larger than `k`  minus the number of integers less than `k`.\\n\\nThe first prefix sum `L` is from the index of `k` to `0`.\\nThe second prefix sum `R` is from the index of `k` to `n-1`.\\nFor example: `nums = [3,2,1,4,5]`, `k = 4`.\\n`L = [0,-1,-2,-3]`, `R = [0,1]`\\n\\nNow the problem is transformed to find the number of pairs whose sum equals to 0 or 1, 0 is the odd case, 1 is the even case, where the pair is constructed by one from `L`, one from `R`.\\n\\nSo we can use an unordered_map to count the numbers in the `L`, and iterate `R` to get the total number of pairs.\\n\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& A, int k) {\\n        int n = A.size(), idx, res = 0;\\n        for(int i = 0; i < n; i++)\\n            if(A[i] == k) {idx = i; break;}\\n        vector<int> L(idx+1), R(n-idx);\\n        for(int i = 1; i < idx+1; i++)\\n            L[i] = L[i-1]+(A[idx-i]>k)-(A[idx-i]<k);\\n        for(int i = 1; i < n-idx; i++)\\n            R[i] = R[i-1]+(A[idx+i]>k)-(A[idx+i]<k);\\n        unordered_map<int, int> m;\\n        for(auto i : L) m[i]++;\\n        for(auto i : R){\\n            if(m.count(1-i)) res += m[1-i];\\n            if(m.count(-i)) res += m[-i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& A, int k) {\\n        int n = A.size(), idx, res = 0;\\n        for(int i = 0; i < n; i++)\\n            if(A[i] == k) {idx = i; break;}\\n        vector<int> L(idx+1), R(n-idx);\\n        for(int i = 1; i < idx+1; i++)\\n            L[i] = L[i-1]+(A[idx-i]>k)-(A[idx-i]<k);\\n        for(int i = 1; i < n-idx; i++)\\n            R[i] = R[i-1]+(A[idx+i]>k)-(A[idx+i]<k);\\n        unordered_map<int, int> m;\\n        for(auto i : L) m[i]++;\\n        for(auto i : R){\\n            if(m.count(1-i)) res += m[1-i];\\n            if(m.count(-i)) res += m[-i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071770,
                "title": "c-beginner-friendly-full-explanation-easy",
                "content": "```\\n class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        //valid subarrays will be starting from 0 to i where i being the index of k and ending at i to n\\n        //suppose i foudn a valid subarray between s and e\\n        //numbers greater than k between s to i be g1\\n        //number smaller than k be s1\\n        //from i to end \\n        //number greater than k be g2 and less than be s2\\n        // from given we know (g1+g2)-(s1+s2)=0 0r 1\\n        //----> (g1-s1)+(g2-s2)==0 o1 1\\n        //in first for loop we are calucalting g2-s2 at every index\\n        \\n        int n=nums.size();\\n        int ind=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==k)\\n            {\\n                ind=i;\\n            }\\n        }\\n        if(ind==-1)\\n        {\\n            return -1;\\n        }\\n        unordered_map<int,int>map;\\n        int diff=0;\\n        map[0]++;\\n        for(int i=ind+1;i<n;i++){\\n            if(nums[i]>k)\\n            {\\n                diff++;\\n            }\\n            \\n            else if(nums[i]<k) \\n            {\\n                diff--;\\n            }\\n            map[diff]++;\\n        }\\n        diff=0;\\n        int ans=0;\\n        //finding complement for the (g1-s1)\\n        //we have already counted g2-s2\\n        for(int i=ind;i>=0;i--)\\n        {\\n            if(nums[i]>k)\\n            {\\n                diff++;\\n            }\\n            else  if(nums[i]<k) \\n            {\\n                diff--;\\n            }\\n            ans+=map[0-diff];\\n            ans+=map[1-diff];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        //valid subarrays will be starting from 0 to i where i being the index of k and ending at i to n\\n        //suppose i foudn a valid subarray between s and e\\n        //numbers greater than k between s to i be g1\\n        //number smaller than k be s1\\n        //from i to end \\n        //number greater than k be g2 and less than be s2\\n        // from given we know (g1+g2)-(s1+s2)=0 0r 1\\n        //----> (g1-s1)+(g2-s2)==0 o1 1\\n        //in first for loop we are calucalting g2-s2 at every index\\n        \\n        int n=nums.size();\\n        int ind=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==k)\\n            {\\n                ind=i;\\n            }\\n        }\\n        if(ind==-1)\\n        {\\n            return -1;\\n        }\\n        unordered_map<int,int>map;\\n        int diff=0;\\n        map[0]++;\\n        for(int i=ind+1;i<n;i++){\\n            if(nums[i]>k)\\n            {\\n                diff++;\\n            }\\n            \\n            else if(nums[i]<k) \\n            {\\n                diff--;\\n            }\\n            map[diff]++;\\n        }\\n        diff=0;\\n        int ans=0;\\n        //finding complement for the (g1-s1)\\n        //we have already counted g2-s2\\n        for(int i=ind;i>=0;i--)\\n        {\\n            if(nums[i]>k)\\n            {\\n                diff++;\\n            }\\n            else  if(nums[i]<k) \\n            {\\n                diff--;\\n            }\\n            ans+=map[0-diff];\\n            ans+=map[1-diff];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225577,
                "title": "c-hints-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for(auto& it : nums) {\\n            it = it == k ? 0 : it > k ? 1 : -1;\\n        }\\n        int idx;\\n        for(auto i = 0; i < n; i++) {\\n            if(nums[i] == 0) {\\n                idx = i; break;\\n            }\\n        }\\n        unordered_map<int, int> map;\\n        int sum = 0;\\n        for(int i = idx; i >= 0; i--) {             // going left\\n            sum += nums[i];\\n            map[sum]++;\\n        }\\n        sum = 0;\\n        int ans = 0;\\n        for(int i = idx; i < n; i++) {              // going right\\n            sum += nums[i];\\n            ans += map[-sum];                       // if subarray is odd\\n            ans += map[-(sum - 1)];                 // if subarray is even, median is left middle element\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for(auto& it : nums) {\\n            it = it == k ? 0 : it > k ? 1 : -1;\\n        }\\n        int idx;\\n        for(auto i = 0; i < n; i++) {\\n            if(nums[i] == 0) {\\n                idx = i; break;\\n            }\\n        }\\n        unordered_map<int, int> map;\\n        int sum = 0;\\n        for(int i = idx; i >= 0; i--) {             // going left\\n            sum += nums[i];\\n            map[sum]++;\\n        }\\n        sum = 0;\\n        int ans = 0;\\n        for(int i = idx; i < n; i++) {              // going right\\n            sum += nums[i];\\n            ans += map[-sum];                       // if subarray is odd\\n            ans += map[-(sum - 1)];                 // if subarray is even, median is left middle element\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891122,
                "title": "java-easy-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int countSubarrays(int[] arr, int k) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        int index = -1;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(arr[i] == k){\\n                index = i;\\n                break;\\n            }\\n        }\\n        // System.out.println(\"\");\\n        int ans = 0;\\n        int bal = 0;\\n        for(int i = index + 1 ; i < arr.length ; i++){\\n            if(arr[i] > k){\\n                bal++;\\n            }else{\\n                bal--;\\n            }\\n            if(bal == 0 || bal == 1) ans++;\\n            insertInMap(map , bal);\\n        }\\n        bal = 0;\\n        for(int i = index - 1 ; i >= 0 ; i--){\\n            if(arr[i] > k){\\n                bal++;\\n            }else{\\n                bal--;\\n            }\\n            if(bal == 0 || bal == 1) ans++;\\n            if(map.containsKey(0 - bal)){\\n                ans += map.get(0 - bal);\\n            }\\n            if(map.containsKey(1 - bal)){\\n                ans += map.get(1 - bal);\\n            }\\n        }\\n        return ans+1;\\n    }\\n    private void insertInMap(HashMap<Integer , Integer> map , int ele){\\n        if(!map.containsKey(ele)){\\n            map.put(ele , 0);\\n        }\\n        map.put(ele , map.get(ele) + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] arr, int k) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        int index = -1;\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(arr[i] == k){\\n                index = i;\\n                break;\\n            }\\n        }\\n        // System.out.println(\"\");\\n        int ans = 0;\\n        int bal = 0;\\n        for(int i = index + 1 ; i < arr.length ; i++){\\n            if(arr[i] > k){\\n                bal++;\\n            }else{\\n                bal--;\\n            }\\n            if(bal == 0 || bal == 1) ans++;\\n            insertInMap(map , bal);\\n        }\\n        bal = 0;\\n        for(int i = index - 1 ; i >= 0 ; i--){\\n            if(arr[i] > k){\\n                bal++;\\n            }else{\\n                bal--;\\n            }\\n            if(bal == 0 || bal == 1) ans++;\\n            if(map.containsKey(0 - bal)){\\n                ans += map.get(0 - bal);\\n            }\\n            if(map.containsKey(1 - bal)){\\n                ans += map.get(1 - bal);\\n            }\\n        }\\n        return ans+1;\\n    }\\n    private void insertInMap(HashMap<Integer , Integer> map , int ele){\\n        if(!map.containsKey(ele)){\\n            map.put(ele , 0);\\n        }\\n        map.put(ele , map.get(ele) + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853386,
                "title": "prefix-for-greater-and-lesser-elements-balancing",
                "content": "\\n* Find the index of k which is pivot\\n* compute the prefix sum for greater and lesser elements of k (count of greater and lesser elements than k)\\n* First check the right side of the pivot\\n* If the difference number of greater and lesser elements is equal or 1 , we can consider that subarray will have the median as k\\n* Now check the left portion of the pivot\\n* Here we need to check the balance, so keep the combination of differences in a map while computing right portion\\n* While checking left portion, check the difference combo is present in the map and add to the result if present. \\n\\n\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef countSubarrays(self, a: List[int], k: int) -> int:\\n\\n\\t\\t\\t\\tn = len(a)\\n\\t\\t\\t\\tif k not in a: return 0\\n\\t\\t\\t\\tpvt = a.index(k)\\n\\n\\t\\t\\t\\tgreat = [0]*n\\n\\t\\t\\t\\tless = [0]*n \\n\\n\\t\\t\\t\\tfor i in range(pvt-1,-1,-1):\\n\\t\\t\\t\\t\\tgreat[i] = great[i+1]\\n\\t\\t\\t\\t\\tless[i] = less[i+1] \\n\\t\\t\\t\\t\\tif a[i]>k: great[i] += 1 \\n\\t\\t\\t\\t\\telse: less[i] += 1 \\n\\n\\t\\t\\t\\tfor i in range(pvt+1,n):\\n\\t\\t\\t\\t\\tgreat[i] = great[i-1]\\n\\t\\t\\t\\t\\tless[i] = less[i-1] \\n\\t\\t\\t\\t\\tif a[i]>k: great[i] += 1 \\n\\t\\t\\t\\t\\telse: less[i] += 1 \\n\\n\\n\\t\\t\\t\\tprint(great)\\n\\t\\t\\t\\tprint(less)\\n\\n\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\tdiff = defaultdict(int)\\n\\t\\t\\t\\tdiff[0] = 1\\n\\n\\t\\t\\t\\tfor i in range(pvt+1,n):\\n\\t\\t\\t\\t\\tif 0 <= great[i] - less[i] <= 1: res+=1\\n\\t\\t\\t\\t\\tdiff[great[i]-less[i]]+=1\\n\\n\\t\\t\\t\\tfor i in range(pvt):\\n\\t\\t\\t\\t\\tif less[i]-great[i] in diff or less[i]-great[i]+1 in diff:\\n\\t\\t\\t\\t\\t\\tres+=(diff[less[i]-great[i]]+diff[less[i]-great[i]+1])\\n\\n\\t\\t\\t\\treturn res+1\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n* Find the index of k which is pivot\\n* compute the prefix sum for greater and lesser elements of k (count of greater and lesser elements than k)\\n* First check the right side of the pivot\\n* If the difference number of greater and lesser elements is equal or 1 , we can consider that subarray will have the median as k\\n* Now check the left portion of the pivot\\n* Here we need to check the balance, so keep the combination of differences in a map while computing right portion\\n* While checking left portion, check the difference combo is present in the map and add to the result if present. \\n\\n\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef countSubarrays(self, a: List[int], k: int) -> int:\\n\\n\\t\\t\\t\\tn = len(a)\\n\\t\\t\\t\\tif k not in a: return 0\\n\\t\\t\\t\\tpvt = a.index(k)\\n\\n\\t\\t\\t\\tgreat = [0]*n\\n\\t\\t\\t\\tless = [0]*n \\n\\n\\t\\t\\t\\tfor i in range(pvt-1,-1,-1):\\n\\t\\t\\t\\t\\tgreat[i] = great[i+1]\\n\\t\\t\\t\\t\\tless[i] = less[i+1] \\n\\t\\t\\t\\t\\tif a[i]>k: great[i] += 1 \\n\\t\\t\\t\\t\\telse: less[i] += 1 \\n\\n\\t\\t\\t\\tfor i in range(pvt+1,n):\\n\\t\\t\\t\\t\\tgreat[i] = great[i-1]\\n\\t\\t\\t\\t\\tless[i] = less[i-1] \\n\\t\\t\\t\\t\\tif a[i]>k: great[i] += 1 \\n\\t\\t\\t\\t\\telse: less[i] += 1 \\n\\n\\n\\t\\t\\t\\tprint(great)\\n\\t\\t\\t\\tprint(less)\\n\\n\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\tdiff = defaultdict(int)\\n\\t\\t\\t\\tdiff[0] = 1\\n\\n\\t\\t\\t\\tfor i in range(pvt+1,n):\\n\\t\\t\\t\\t\\tif 0 <= great[i] - less[i] <= 1: res+=1\\n\\t\\t\\t\\t\\tdiff[great[i]-less[i]]+=1\\n\\n\\t\\t\\t\\tfor i in range(pvt):\\n\\t\\t\\t\\t\\tif less[i]-great[i] in diff or less[i]-great[i]+1 in diff:\\n\\t\\t\\t\\t\\t\\tres+=(diff[less[i]-great[i]]+diff[less[i]-great[i]+1])\\n\\n\\t\\t\\t\\treturn res+1\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2853254,
                "title": "c-map-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp; mp[0]++;\\n        int sum = 0, in = 0, re = 0;\\n        while(in<nums.size() && nums[in]!=k) in++;\\n        for(int i = in-1; i>=0;i--) {\\n            if(nums[i]>k) sum++; else sum--;\\n            mp[sum]++;\\n        }\\n        re = mp[0]+mp[1];\\n        sum = 0;\\n        for(int i = in+1; i<nums.size();++i){\\n            if(nums[i]>k) sum++; else sum--;\\n            re+=mp[-sum]+mp[-(sum-1)];\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp; mp[0]++;\\n        int sum = 0, in = 0, re = 0;\\n        while(in<nums.size() && nums[in]!=k) in++;\\n        for(int i = in-1; i>=0;i--) {\\n            if(nums[i]>k) sum++; else sum--;\\n            mp[sum]++;\\n        }\\n        re = mp[0]+mp[1];\\n        sum = 0;\\n        for(int i = in+1; i<nums.size();++i){\\n            if(nums[i]>k) sum++; else sum--;\\n            re+=mp[-sum]+mp[-(sum-1)];\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852871,
                "title": "using-hashmap-easy-c-solution",
                "content": "**Please upvote if you like.**\\n**Approach**\\n\\nLogic is that k would be median of a subarray if the count of smaller and greater value on the left side is 1 more than the count of smaller and greater value on the right side.\\n\\n\\nWe find the count of the smaller and greater value then the median k on the right side and we store the counting in the HashMap.\\nThen again we find the counting of smaller and greater value on the left side and we check that if the   -cnt and -cnt+1 exists on the right hand side then we add that in our answer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int pos;\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == k){\\n                pos = i;\\n                break;\\n            }\\n        }\\n        unordered_map<int,int>mp;\\n        int cnt = 0;\\n        for(int i = pos;i < n;i++){\\n            cnt += nums[i] == k ? 0 : nums[i] < k ? -1 : 1;\\n            mp[cnt]++;\\n        }\\n        for(int i = pos,cnt = 0;i >= 0;i--){\\n            cnt += nums[i] == k ? 0 : nums[i] < k ? -1 : 1;\\n            ans += mp[-cnt] + mp[-cnt+1];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int pos;\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == k){\\n                pos = i;\\n                break;\\n            }\\n        }\\n        unordered_map<int,int>mp;\\n        int cnt = 0;\\n        for(int i = pos;i < n;i++){\\n            cnt += nums[i] == k ? 0 : nums[i] < k ? -1 : 1;\\n            mp[cnt]++;\\n        }\\n        for(int i = pos,cnt = 0;i >= 0;i--){\\n            cnt += nums[i] == k ? 0 : nums[i] < k ? -1 : 1;\\n            ans += mp[-cnt] + mp[-cnt+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852759,
                "title": "python-short-solution-counter-of-difference",
                "content": "```\\ndef countSubarrays(self, nums: List[int], k: int) -> int:\\n\\tcount, idx = Counter([0]), nums.index(k)\\n\\tans = d = 0\\n\\tfor i in range(len(nums)):\\n\\t\\td -= (nums[i]<k)\\n\\t\\td += (nums[i]>k)\\n\\t\\tif i<idx:\\n\\t\\t\\tcount[d] += 1\\n\\t\\telse:\\n\\t\\t\\tans += (count[d]+count[d-1])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef countSubarrays(self, nums: List[int], k: int) -> int:\\n\\tcount, idx = Counter([0]), nums.index(k)\\n\\tans = d = 0\\n\\tfor i in range(len(nums)):\\n\\t\\td -= (nums[i]<k)\\n\\t\\td += (nums[i]>k)\\n\\t\\tif i<idx:\\n\\t\\t\\tcount[d] += 1\\n\\t\\telse:\\n\\t\\t\\tans += (count[d]+count[d-1])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2852424,
                "title": "python3-solution-with-freq-table",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        idx,freq,prefix = nums.index(k), Counter(), 0\\n        for i in reversed(range(idx+1)): \\n            prefix += int(nums[i] > k) - int(nums[i] < k)\\n            freq[prefix] += 1\\n        res= prefix = 0 \\n        for i in range(idx, len(nums)): \\n            prefix += int(nums[i] > k) - int(nums[i] < k)\\n            res += freq[-prefix] + freq[-prefix+1]\\n        return res \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        idx,freq,prefix = nums.index(k), Counter(), 0\\n        for i in reversed(range(idx+1)): \\n            prefix += int(nums[i] > k) - int(nums[i] < k)\\n            freq[prefix] += 1\\n        res= prefix = 0 \\n        for i in range(idx, len(nums)): \\n            prefix += int(nums[i] > k) - int(nums[i] < k)\\n            res += freq[-prefix] + freq[-prefix+1]\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852322,
                "title": "java-use-map-or-array-to-count-the-number-of-smaller-larger-items-around-k",
                "content": "# Intuition\\nThe idea is straightforwar, we just need to find k first, and count the number of smaller/larger items around it.\\n\\n# Approach\\n1. Find the index of k\\n2. Count the number of smaller/larger items on one side of k\\n3. Count the number of smaller/larger items on the other side (and calculate the result at the same time)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n\\nSolution 1: use a map to maintain the counts.\\n```\\nclass Solution {\\n\\n    /*\\n    Runtime 43 ms Beats 80%\\n    Memory 71.8 MB Beats 40%\\n\\n    Use a map to maitian the counts. \\n    */\\n    public int countSubarrays(int[] nums, int k) {\\n        int ind = 0;\\n        for (ind = 0; ind < nums.length; ind++) {\\n            if (nums[ind] == k) {\\n                break;\\n            }\\n        }\\n\\n        Map<Integer, Integer> diffCount = new HashMap<>();\\n        int diff = 0;\\n        for (int i = ind; i < nums.length; i++) {\\n            if (nums[i] > k) {\\n                diff++;\\n            } else if (nums[i] < k) {\\n                diff--;\\n            }\\n            diffCount.put(diff, diffCount.getOrDefault(diff, 0) + 1);\\n        }\\n\\n        int count = diffCount.get(0) + diffCount.getOrDefault(1, 0);\\n        diff = 0;\\n        for (int i = ind - 1; i >= 0; i--) {\\n            if (nums[i] > k) {\\n                diff++;\\n            } else if (nums[i] < k) {\\n                diff--;\\n            }\\n            count += diffCount.getOrDefault(-diff, 0);\\n            count += diffCount.getOrDefault(1 - diff, 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\nSolution 2: use an array to maintain the counts. Faster but less intuitive. The idea is the same.\\n```\\nclass Solution {\\n\\n    /*\\n    Runtime 6 ms Beats 100%\\n    Memory 71.8 MB Beats 40%\\n     */\\n    public int countSubarrays(int[] nums, int k) {\\n        int ind = 0;\\n        for (ind = 0; ind < nums.length; ind++) {\\n            if (nums[ind] == k) {\\n                break;\\n            }\\n        }\\n\\n        int[] diffs = new int[nums.length + 2];\\n\\n        int diff = 0;\\n        for (int i = ind; i < nums.length; i++) {\\n            if (nums[i] > k) {\\n                diff++;\\n            } else if (nums[i] < k) {\\n                diff--;\\n            }\\n            diffs[k + diff]++;\\n        }\\n\\n        int count = diffs[k] + diffs[k + 1];\\n        diff = 0;\\n        for (int i = ind - 1; i >= 0; i--) {\\n            if (nums[i] > k) {\\n                diff++;\\n            } else if (nums[i] < k) {\\n                diff--;\\n            }\\n            if (k - diff >= 0 && k - diff < diffs.length) {\\n                count += diffs[k - diff];\\n            }\\n            if (k - diff + 1 >= 0 && k - diff + 1 < diffs.length) {\\n                count += diffs[k - diff + 1];\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    /*\\n    Runtime 43 ms Beats 80%\\n    Memory 71.8 MB Beats 40%\\n\\n    Use a map to maitian the counts. \\n    */\\n    public int countSubarrays(int[] nums, int k) {\\n        int ind = 0;\\n        for (ind = 0; ind < nums.length; ind++) {\\n            if (nums[ind] == k) {\\n                break;\\n            }\\n        }\\n\\n        Map<Integer, Integer> diffCount = new HashMap<>();\\n        int diff = 0;\\n        for (int i = ind; i < nums.length; i++) {\\n            if (nums[i] > k) {\\n                diff++;\\n            } else if (nums[i] < k) {\\n                diff--;\\n            }\\n            diffCount.put(diff, diffCount.getOrDefault(diff, 0) + 1);\\n        }\\n\\n        int count = diffCount.get(0) + diffCount.getOrDefault(1, 0);\\n        diff = 0;\\n        for (int i = ind - 1; i >= 0; i--) {\\n            if (nums[i] > k) {\\n                diff++;\\n            } else if (nums[i] < k) {\\n                diff--;\\n            }\\n            count += diffCount.getOrDefault(-diff, 0);\\n            count += diffCount.getOrDefault(1 - diff, 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    /*\\n    Runtime 6 ms Beats 100%\\n    Memory 71.8 MB Beats 40%\\n     */\\n    public int countSubarrays(int[] nums, int k) {\\n        int ind = 0;\\n        for (ind = 0; ind < nums.length; ind++) {\\n            if (nums[ind] == k) {\\n                break;\\n            }\\n        }\\n\\n        int[] diffs = new int[nums.length + 2];\\n\\n        int diff = 0;\\n        for (int i = ind; i < nums.length; i++) {\\n            if (nums[i] > k) {\\n                diff++;\\n            } else if (nums[i] < k) {\\n                diff--;\\n            }\\n            diffs[k + diff]++;\\n        }\\n\\n        int count = diffs[k] + diffs[k + 1];\\n        diff = 0;\\n        for (int i = ind - 1; i >= 0; i--) {\\n            if (nums[i] > k) {\\n                diff++;\\n            } else if (nums[i] < k) {\\n                diff--;\\n            }\\n            if (k - diff >= 0 && k - diff < diffs.length) {\\n                count += diffs[k - diff];\\n            }\\n            if (k - diff + 1 >= 0 && k - diff + 1 < diffs.length) {\\n                count += diffs[k - diff + 1];\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851997,
                "title": "c-easy-unordered-map",
                "content": "# Intuition\\n1. All desired subarray should include k.\\n2. For a desired subarray A:\\n   Let x be the number of element greater than k.\\n   Let y be the number of element lower than k.\\n   x - y should be 0 or 1.\\n\\nThese two observations conclude following algorithm.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int target=0, res=1;\\n        unordered_map<int,int> record;\\n\\n        // k itself\\n        record[0]=1;\\n        \\n        // find position of k in nums\\n        for (; target<nums.size(); ++target)\\n            if (nums[target]==k) break;\\n        \\n        // left side\\n        for (int i=target-1, cur=0; i>=0; --i) {\\n            if (nums[i]>k) ++cur;\\n            else --cur;\\n            \\n            ++record[cur];\\n            if (cur==0 || cur==1) ++res;\\n        }\\n        \\n        // right side\\n        for (int i=target+1, cur=0; i<nums.size(); ++i) {\\n            if (nums[i]>k) ++cur;\\n            else --cur;\\n\\n            res+=record[-cur]+record[-cur+1]; \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int target=0, res=1;\\n        unordered_map<int,int> record;\\n\\n        // k itself\\n        record[0]=1;\\n        \\n        // find position of k in nums\\n        for (; target<nums.size(); ++target)\\n            if (nums[target]==k) break;\\n        \\n        // left side\\n        for (int i=target-1, cur=0; i>=0; --i) {\\n            if (nums[i]>k) ++cur;\\n            else --cur;\\n            \\n            ++record[cur];\\n            if (cur==0 || cur==1) ++res;\\n        }\\n        \\n        // right side\\n        for (int i=target+1, cur=0; i<nums.size(); ++i) {\\n            if (nums[i]>k) ++cur;\\n            else --cur;\\n\\n            res+=record[-cur]+record[-cur+1]; \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851995,
                "title": "java-prefix-sum-hashmap-o-n-detailed-math-explanation",
                "content": "Define:\\n- int `pivot`: where `nums[pivot] == k`\\n- Prefix sum array `smaller`: where `smaller[i+1]` is the number of `m` so that `nums[m] < k` and `0 <= m <= i <= nums.length`.\\n\\nGoal: count the number of `(i, j)` pairs where `0 <= i <= pivot <= j <= nums.length` and `smaller[j+1] - smaller[i] == (j - i) / 2`.\\n\\nLet\\'s do some basic transposition:\\n```\\nsmaller[j+1] - smaller[i] == (j - i) / 2\\n2 * (smaller[j+1] - smaller[i]) == (j - i) or (j - i - 1)\\n2 * smaller[j+1] - j == (2 * smaller[i] - i) or (2 * smaller[i] - i - 1)\\n```\\n\\nWe find some pattern here, so define\\n```\\nstatistic[i] = 2 * smaller[i] - i\\n```\\nthen the formula becomes\\n```\\nstatistic[j+1] + 1 == (statistic[i]) or (statistic[i] - 1)\\n```\\n\\nUse a map to store the count of each `statistic[i]`, where `0 <= i <= pivot`. And for each `j` where `pivot <= j <= nums.length`, add both `map.get(statistic[j+1] + 1)` and `map.get(statistic[j+1] + 2)` to the output.\\n\\n``` java\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] smaller = new int[n + 1];  // smaller[i + 1]: number of elements smaller than k in nums[0...i]\\n        int pivot = -1;  // nums[pivot] == k\\n        for (int i = 0; i < n; i++) {\\n            smaller[i + 1] = smaller[i];\\n            if (nums[i] < k) {\\n                smaller[i + 1]++;\\n            } else if (nums[i] == k) {\\n                pivot = i;\\n            }\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();  // statistics count map\\n        for (int i = 0; i <= pivot; i++) {\\n            int statistic = 2 * smaller[i] - i;\\n            map.put(statistic, map.getOrDefault(statistic, 0) + 1);\\n        }\\n        int count = 0;\\n        for (int j = pivot; j < n; j++) {\\n            int statistic = 2 * smaller[j + 1] - j;\\n            count += map.getOrDefault(statistic, 0);\\n            count += map.getOrDefault(statistic + 1, 0);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nsmaller[j+1] - smaller[i] == (j - i) / 2\\n2 * (smaller[j+1] - smaller[i]) == (j - i) or (j - i - 1)\\n2 * smaller[j+1] - j == (2 * smaller[i] - i) or (2 * smaller[i] - i - 1)\\n```\n```\\nstatistic[i] = 2 * smaller[i] - i\\n```\n```\\nstatistic[j+1] + 1 == (statistic[i]) or (statistic[i] - 1)\\n```\n``` java\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] smaller = new int[n + 1];  // smaller[i + 1]: number of elements smaller than k in nums[0...i]\\n        int pivot = -1;  // nums[pivot] == k\\n        for (int i = 0; i < n; i++) {\\n            smaller[i + 1] = smaller[i];\\n            if (nums[i] < k) {\\n                smaller[i + 1]++;\\n            } else if (nums[i] == k) {\\n                pivot = i;\\n            }\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();  // statistics count map\\n        for (int i = 0; i <= pivot; i++) {\\n            int statistic = 2 * smaller[i] - i;\\n            map.put(statistic, map.getOrDefault(statistic, 0) + 1);\\n        }\\n        int count = 0;\\n        for (int j = pivot; j < n; j++) {\\n            int statistic = 2 * smaller[j + 1] - j;\\n            count += map.getOrDefault(statistic, 0);\\n            count += map.getOrDefault(statistic + 1, 0);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851938,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        // for the definision of median in this problem,\\n        // suppose subarray A meets the condition\\n        \\n        // there are two cases\\n        // 1. odd number length: median(A) == k --> {x > k} - {x < k} == 0\\n        // 2. even number length: median(A) == k --> {x > k} - {x < k} == 1\\n        \\n        // We need to find subarrays that contains k that meet the above two cases\\n        // How? We count the diff ({x > k} - {x < k}) from k for all index to its left and right\\n        // And we try to find the corresponding right part for all left part.\\n        int m = nums.size();\\n        int i = 0;\\n        for (int j = 0; j < m; ++j) {\\n            if (nums[j] == k) {\\n                i = j;\\n                break;\\n            }\\n        }\\n        \\n        // count of {x > k} - {x < k}\\n        unordered_map<int, int> left, right;\\n        left[0] = 1;\\n        right[0] = 1;\\n        \\n        int cnt = 0;\\n        for (int j = i-1; j >= 0; --j) {\\n            if (nums[j] < k) cnt--;\\n            else cnt++;\\n            left[cnt]++;\\n        }\\n        \\n        cnt = 0;\\n        for (int j = i+1; j < m; ++j) {\\n            if (nums[j] < k) cnt--;\\n            else cnt++;\\n            right[cnt]++;\\n        }\\n        \\n\\n        int res = 0;\\n        for (auto &p: left) {\\n            // case 1\\n            auto it = right.find(0 - p.first);\\n            if (it != right.end()) res += p.second * it->second;\\n            \\n            // case 2\\n            it = right.find(1 - p.first);\\n            if (it != right.end()) res += p.second * it->second;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        // for the definision of median in this problem,\\n        // suppose subarray A meets the condition\\n        \\n        // there are two cases\\n        // 1. odd number length: median(A) == k --> {x > k} - {x < k} == 0\\n        // 2. even number length: median(A) == k --> {x > k} - {x < k} == 1\\n        \\n        // We need to find subarrays that contains k that meet the above two cases\\n        // How? We count the diff ({x > k} - {x < k}) from k for all index to its left and right\\n        // And we try to find the corresponding right part for all left part.\\n        int m = nums.size();\\n        int i = 0;\\n        for (int j = 0; j < m; ++j) {\\n            if (nums[j] == k) {\\n                i = j;\\n                break;\\n            }\\n        }\\n        \\n        // count of {x > k} - {x < k}\\n        unordered_map<int, int> left, right;\\n        left[0] = 1;\\n        right[0] = 1;\\n        \\n        int cnt = 0;\\n        for (int j = i-1; j >= 0; --j) {\\n            if (nums[j] < k) cnt--;\\n            else cnt++;\\n            left[cnt]++;\\n        }\\n        \\n        cnt = 0;\\n        for (int j = i+1; j < m; ++j) {\\n            if (nums[j] < k) cnt--;\\n            else cnt++;\\n            right[cnt]++;\\n        }\\n        \\n\\n        int res = 0;\\n        for (auto &p: left) {\\n            // case 1\\n            auto it = right.find(0 - p.first);\\n            if (it != right.end()) res += p.second * it->second;\\n            \\n            // case 2\\n            it = right.find(1 - p.first);\\n            if (it != right.end()) res += p.second * it->second;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952662,
                "title": "o-n-hash-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the number \\'k\\' to be median, the number of elements greater than \\'k\\' and less than \\'k\\' should differ by either 0 or 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPick an index to the left of the number \\'k\\', and check that to how many indexes on right of \\'k\\' can be extend the subarray to. We will also need to include subarrays that remain entirely towards left and right of \\'k\\'.\\n\\nWe need to maintain the balance between the numbers greater and less than \\'k\\'. If we know that on the left the balance is \\'x\\', then we can extend the subarray towards right to those indexes that give us the overall balance of 0 or 1. In other words, if the balance on the right is \\'-x\\' or \\'1-x\\', then the overall balance would be 0 or 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountSubarrays(int[] nums, int k) {\\n        Dictionary<int,int> record = new();\\n        int n = nums.Length;\\n        // Find position of \\'k\\' in the array.\\n        int pos = Array.FindIndex(nums, (a) => a == k);\\n        // Balance measures the difference b/w the count of numbers greater than and less than \\'k\\'. \\n        // Balance should be either 0 or 1 for the subarray to be valid.\\n        int balance = 0;\\n        // Set count to 1 because an array with only the number \\'k\\' is a valid subarray.\\n        int count = 1;\\n        // The loop makes a record of all the subarrays from \\'pos\\' to \\'i\\', and how far is \\'k\\' from the median position.\\n        for(int i=pos+1;i<n;i++) {\\n            if (nums[i] < k) balance--;\\n            else balance++;\\n            // This records subarrays that only extend on the right of pos.\\n            if (balance == 0 || balance == 1) count++;\\n            if (!record.ContainsKey(balance)) record.Add(balance,0);\\n            record[balance]++;\\n        }\\n        \\n\\n        balance = 0;\\n        // The loop tries to extend the subarray towards left, and checks in how many ways we can extend towards right\\n        // so that balance is either 0 or 1.\\n        for(int i=pos-1;i>=0;i--) {\\n            if (nums[i] < k) balance--;\\n            else balance++;\\n            // This records subarrays that only extend on the left of pos.\\n            if (balance == 0 || balance == 1) count++;\\n            // This records subarrays that only extend from left to right.\\n            count+= record.GetValueOrDefault(-balance) + record.GetValueOrDefault(1 - balance);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountSubarrays(int[] nums, int k) {\\n        Dictionary<int,int> record = new();\\n        int n = nums.Length;\\n        // Find position of \\'k\\' in the array.\\n        int pos = Array.FindIndex(nums, (a) => a == k);\\n        // Balance measures the difference b/w the count of numbers greater than and less than \\'k\\'. \\n        // Balance should be either 0 or 1 for the subarray to be valid.\\n        int balance = 0;\\n        // Set count to 1 because an array with only the number \\'k\\' is a valid subarray.\\n        int count = 1;\\n        // The loop makes a record of all the subarrays from \\'pos\\' to \\'i\\', and how far is \\'k\\' from the median position.\\n        for(int i=pos+1;i<n;i++) {\\n            if (nums[i] < k) balance--;\\n            else balance++;\\n            // This records subarrays that only extend on the right of pos.\\n            if (balance == 0 || balance == 1) count++;\\n            if (!record.ContainsKey(balance)) record.Add(balance,0);\\n            record[balance]++;\\n        }\\n        \\n\\n        balance = 0;\\n        // The loop tries to extend the subarray towards left, and checks in how many ways we can extend towards right\\n        // so that balance is either 0 or 1.\\n        for(int i=pos-1;i>=0;i--) {\\n            if (nums[i] < k) balance--;\\n            else balance++;\\n            // This records subarrays that only extend on the left of pos.\\n            if (balance == 0 || balance == 1) count++;\\n            // This records subarrays that only extend from left to right.\\n            count+= record.GetValueOrDefault(-balance) + record.GetValueOrDefault(1 - balance);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950969,
                "title": "used-vector-instead-of-hashmap-o-n-solution",
                "content": "# Intuition\\nThe approach is same as used by many people in the solutions section. This is just a modification of that only with better complexity. So please go through the hashmap approach before coming here.\\n\\n# Approach 1 (using hashmap)\\nPoint to note: For ```k``` to be the median, ```k``` must be in the subarray. Let ```medianInd=index of median```. So we will be going towards left from the median and towards right from the median. Moving towards left:  ```sum``` would be storing relative value of no. of values smaller than ```k``` and no. of values greater than ```k```. ```sum++``` if ```nums[i]>k``` and ```sum--``` if ```nums[i]<k```. Store these ```sum``` values in a map. \\n\\nLet us say no. of values less than k = ```L``` and no. of values greater than k = ```R```. \\n\\nNow we will be Moving towards right: ```ans``` would be incremented if ```mp[-sum]``` (subarray size=odd) is present -> this means if R-L (assuming R>L in this case and sum(in map) = R-L) is present on the left, then we have a counter L-R on the right  ```or``` map[-(sum-1)] (subarray size==even) is present.\\n\\nI know this is a bit complex to understand but just give it a dry run and you would surely understand.\\n\\n* Give a thought to why we iterated from ```medianInd``` and not only ```medianInd-1``` (on left) and ```medianInd+1``` (on right). I am leaving it on you to brainstorm.\\uD83D\\uDE09 \\nDo comment if you got it.\\n\\n# Code (Using Hashmap)\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        int medianInd=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==k){\\n                medianInd=i;\\n            }\\n        }\\n\\n        map<int,int> mp;\\n        int sum=0;\\n        for(int i=medianInd;i>=0;i--){\\n            if(nums[i]>k){\\n                sum++;\\n            }\\n            if(nums[i]<k){\\n                sum--;\\n            }\\n            mp[sum]++;\\n        }\\n\\n        int ans=0;\\n        sum=0;\\n        for(int i=medianInd;i<n;i++){\\n            if(nums[i]>k){\\n                sum++;\\n            }\\n            if(nums[i]<k){\\n                sum--;\\n            }\\n\\n            ans+=(mp[-sum]+mp[-(sum-1)]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Approach 2 (Without hashmap)\\nAs we know our sum can only lie between -n to +n, i.e. ```-n<=sum<=n```.\\nSo, we created a vector of size ```2*n + 1``` to store the ```sum``` occurences.\\nNow every key value in map is kind of ```shifted by +n``` in vector. \\nThat\\'s the reason we used ```v[sum+n]``` instead of ```mp[sum]```, ```v[-sum+n]``` instead of ```mp[-sum]``` and ```v[-(sum-1)+n]``` instead of  ```mp[-(sum-1)]```.\\nAnd that\\'s it\\uD83D\\uDE00.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        int medianInd=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==k){\\n                medianInd=i;\\n            }\\n        }\\n\\n        vector<int> v(2*n+1,0); // earlier map was used but as we know -n<=sum<=n, so we used a vector. Every key of i will now be at i+n.\\n        int sum=0;\\n        for(int i=medianInd;i>=0;i--){\\n            if(nums[i]>k){\\n                sum++;\\n            }\\n            if(nums[i]<k){\\n                sum--;\\n            }\\n            v[sum+n]++;  //mp[sum]++\\n        }\\n\\n        int ans=0;\\n        sum=0;\\n        for(int i=medianInd;i<n;i++){\\n            if(nums[i]>k){\\n                sum++;\\n            }\\n            if(nums[i]<k){\\n                sum--;\\n            }\\n\\n            ans+=(v[-sum+n]+v[-(sum-1)+n]); //ans+=(mp[-sum]+mp[-(sum-1)]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**I hope I was able to clear this Leetcode question to you. Please do upvote if you understood.**\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```k```\n```k```\n```medianInd=index of median```\n```sum```\n```k```\n```k```\n```sum++```\n```nums[i]>k```\n```sum--```\n```nums[i]<k```\n```sum```\n```L```\n```R```\n```ans```\n```mp[-sum]```\n```or```\n```medianInd```\n```medianInd-1```\n```medianInd+1```\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        int medianInd=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==k){\\n                medianInd=i;\\n            }\\n        }\\n\\n        map<int,int> mp;\\n        int sum=0;\\n        for(int i=medianInd;i>=0;i--){\\n            if(nums[i]>k){\\n                sum++;\\n            }\\n            if(nums[i]<k){\\n                sum--;\\n            }\\n            mp[sum]++;\\n        }\\n\\n        int ans=0;\\n        sum=0;\\n        for(int i=medianInd;i<n;i++){\\n            if(nums[i]>k){\\n                sum++;\\n            }\\n            if(nums[i]<k){\\n                sum--;\\n            }\\n\\n            ans+=(mp[-sum]+mp[-(sum-1)]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```-n<=sum<=n```\n```2*n + 1```\n```sum```\n```shifted by +n```\n```v[sum+n]```\n```mp[sum]```\n```v[-sum+n]```\n```mp[-sum]```\n```v[-(sum-1)+n]```\n```mp[-(sum-1)]```\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        int medianInd=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==k){\\n                medianInd=i;\\n            }\\n        }\\n\\n        vector<int> v(2*n+1,0); // earlier map was used but as we know -n<=sum<=n, so we used a vector. Every key of i will now be at i+n.\\n        int sum=0;\\n        for(int i=medianInd;i>=0;i--){\\n            if(nums[i]>k){\\n                sum++;\\n            }\\n            if(nums[i]<k){\\n                sum--;\\n            }\\n            v[sum+n]++;  //mp[sum]++\\n        }\\n\\n        int ans=0;\\n        sum=0;\\n        for(int i=medianInd;i<n;i++){\\n            if(nums[i]>k){\\n                sum++;\\n            }\\n            if(nums[i]<k){\\n                sum--;\\n            }\\n\\n            ans+=(v[-sum+n]+v[-(sum-1)+n]); //ans+=(mp[-sum]+mp[-(sum-1)]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829371,
                "title": "unordered-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& v, int k) {\\n        int index;\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            if(v[i]==k){\\n                index=i;\\n                break;\\n            }\\n        }\\n        int res=0;\\n        int sum=0;\\n        unordered_map<int,int>m;\\n        for(int i=index+1;i<n;i++){\\n            if(v[i]>k) sum++;\\n            else if(v[i]<k) sum--;\\n            m[sum]++;\\n        }\\n        m[0]++;\\n        sum=0;\\n        for(int i=index;i>=0;i--){\\n            if(v[i]>k) sum--;\\n            else if(v[i]<k) sum++;\\n            if(m.count(sum)) res+=m[sum];\\n            if(m.count(sum+1)) res+=m[sum+1]; \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& v, int k) {\\n        int index;\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            if(v[i]==k){\\n                index=i;\\n                break;\\n            }\\n        }\\n        int res=0;\\n        int sum=0;\\n        unordered_map<int,int>m;\\n        for(int i=index+1;i<n;i++){\\n            if(v[i]>k) sum++;\\n            else if(v[i]<k) sum--;\\n            m[sum]++;\\n        }\\n        m[0]++;\\n        sum=0;\\n        for(int i=index;i>=0;i--){\\n            if(v[i]>k) sum--;\\n            else if(v[i]<k) sum++;\\n            if(m.count(sum)) res+=m[sum];\\n            if(m.count(sum+1)) res+=m[sum+1]; \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787711,
                "title": "prefix-sum-variant-of-subarray-with-sum-k",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sum=0;\\n        int pivot;\\n        int count=0;\\n        map<int,int> mpp;\\n        mpp[0]=1;\\n        vector<int> arr(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<k)\\n                arr[i]=-1;\\n            if(nums[i]>k)\\n                arr[i]=1;\\n            if(nums[i]==k)\\n            {pivot =i;\\n            }\\n        }\\n        vector<int>prefix(n,0);\\n        for(int i=0;i<pivot;i++)\\n        {\\n            sum+=arr[i];\\n            mpp[sum]+=1;\\n                \\n        }\\n        sum-=arr[pivot];\\n        for(int i=pivot;i<n;i++)\\n        {\\n            sum+=arr[i];\\n             count += mpp[sum];\\n             count += mpp[sum-1];\\n        }\\n        return count;\\n        //finding subarray with total sum=0\\n        \\n        // subarray with total sum= -1.\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int sum=0;\\n        int pivot;\\n        int count=0;\\n        map<int,int> mpp;\\n        mpp[0]=1;\\n        vector<int> arr(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<k)\\n                arr[i]=-1;\\n            if(nums[i]>k)\\n                arr[i]=1;\\n            if(nums[i]==k)\\n            {pivot =i;\\n            }\\n        }\\n        vector<int>prefix(n,0);\\n        for(int i=0;i<pivot;i++)\\n        {\\n            sum+=arr[i];\\n            mpp[sum]+=1;\\n                \\n        }\\n        sum-=arr[pivot];\\n        for(int i=pivot;i<n;i++)\\n        {\\n            sum+=arr[i];\\n             count += mpp[sum];\\n             count += mpp[sum-1];\\n        }\\n        return count;\\n        //finding subarray with total sum=0\\n        \\n        // subarray with total sum= -1.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719341,
                "title": "c-solution-based-on-hints",
                "content": "```\\nclass Solution {\\npublic:\\n  int countSubarrays(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    int kIdx = -1;\\n    for (int i = 0; i < n; ++i) {\\n      if (nums[i] == k) kIdx = i;\\n      nums[i] = (nums[i] == k) ? 0 : ((nums[i] < k) ? -1 : 1);\\n    }\\n    vector<int> cumSums;\\n    vector<int> cumSumFreq(n + k + 1, 0);\\n    int cumSum = 0;\\n    for (int i = 0; i < n; ++i) {\\n      cumSum += nums[i];\\n      cumSums.push_back(cumSum);\\n      if (i >= kIdx) {\\n        cumSumFreq[cumSum + k]++;\\n      }\\n    }\\n    int tot = 0;\\n    int s = 0;\\n    for (int i = 0; i <= kIdx; ++i) {\\n      tot += cumSumFreq[s + 1 + k];\\n      tot += cumSumFreq[s + k];\\n      s = cumSums[i];\\n    }\\n    return tot;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int countSubarrays(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    int kIdx = -1;\\n    for (int i = 0; i < n; ++i) {\\n      if (nums[i] == k) kIdx = i;\\n      nums[i] = (nums[i] == k) ? 0 : ((nums[i] < k) ? -1 : 1);\\n    }\\n    vector<int> cumSums;\\n    vector<int> cumSumFreq(n + k + 1, 0);\\n    int cumSum = 0;\\n    for (int i = 0; i < n; ++i) {\\n      cumSum += nums[i];\\n      cumSums.push_back(cumSum);\\n      if (i >= kIdx) {\\n        cumSumFreq[cumSum + k]++;\\n      }\\n    }\\n    int tot = 0;\\n    int s = 0;\\n    for (int i = 0; i <= kIdx; ++i) {\\n      tot += cumSumFreq[s + 1 + k];\\n      tot += cumSumFreq[s + k];\\n      s = cumSums[i];\\n    }\\n    return tot;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717404,
                "title": "easy-to-understand-c-code-prefixsum-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## Please Upvote if it helps\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size(),k_ind = -1,prefixSum = 0,count = 0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == k){\\n                k_ind = i;\\n                break;\\n            }\\n        }\\n        // Its like updating nums[i] > k with 1 , nums[i] < k with -1 & nums[i] == k with 0\\n        // Now Count Subarrays of nums array having sum equal to 0 or 1 but subarray must also contain k(remember)\\n        for(int i=0;i<n;i++){\\n            int x = 0;\\n            if(nums[i] > k)\\n                x = 1;\\n            else if(nums[i] < k)\\n                x = -1;\\n            prefixSum += x;\\n            if(i >= k_ind){\\n                if(prefixSum == 0 || prefixSum == 1)\\n                    count++;\\n                if(mp.find(prefixSum) != mp.end())\\n                    count += mp[prefixSum];\\n                if(mp.find(prefixSum - 1) != mp.end())\\n                    count += mp[prefixSum - 1];\\n            }\\n            if(i < k_ind)\\n                mp[prefixSum]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size(),k_ind = -1,prefixSum = 0,count = 0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == k){\\n                k_ind = i;\\n                break;\\n            }\\n        }\\n        // Its like updating nums[i] > k with 1 , nums[i] < k with -1 & nums[i] == k with 0\\n        // Now Count Subarrays of nums array having sum equal to 0 or 1 but subarray must also contain k(remember)\\n        for(int i=0;i<n;i++){\\n            int x = 0;\\n            if(nums[i] > k)\\n                x = 1;\\n            else if(nums[i] < k)\\n                x = -1;\\n            prefixSum += x;\\n            if(i >= k_ind){\\n                if(prefixSum == 0 || prefixSum == 1)\\n                    count++;\\n                if(mp.find(prefixSum) != mp.end())\\n                    count += mp[prefixSum];\\n                if(mp.find(prefixSum - 1) != mp.end())\\n                    count += mp[prefixSum - 1];\\n            }\\n            if(i < k_ind)\\n                mp[prefixSum]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705965,
                "title": "js-clean-solution-with-logic-explained-easy-to-understand",
                "content": "# Approach\\nFor a subarray to have a median of k, there are three cases:\\n```\\n- case 1: [k] itself\\n- case 2: there is equal amount of numbers either bigger or smaller than k\\n        ex: [k-2, k-1, k, k+1, k+2]\\n- case 3: the number of values bigger than k - number of values smaller than k is 1\\n        ex: [k-1, k, k+1, k+2]\\n```\\n\\nSo if we start from k and count to the right side\\nwe can get the **balance** of a subarray with k included.\\nstart a balance count at 0, if we encounter a bigger element balance+1, else -1.\\nthen when the balance is 0 or 1, the subarray is a valid.\\n\\nNow start at k again to count to the left side.\\nStill 0 and 1s will make a valid subarray.\\n**Plus**\\nconsider a balance count -2 like this\\n\\n```\\n.....i......k.......j......l\\n     -2     0       2      3\\n```\\nIf we combine the balance count -2 on the left with the right hand side 2. We have a total balance count 0 which is case 2.\\nIf we combine -2 with 3, i.e. subarray from i to l. We have total balance 1 which is case 3.\\nHence, when we do left side balance counting, we have to check the right hand side stored (-balance) and (-balance+1) value to update total subarray count.\\n\\nTo quickly check for the right hand balance frequency, use a hash map to store the count of balance.\\n\\n# Complexity\\n- Time complexity:\\nstep 1: get index of k takes max O(N) time\\nstep 2: go from k to the end takes N-index(k) iterations\\nstep 3: go from index(k) to begining\\nstep 2 and step 3 together takes O(N)\\nSo total tiem is O(N)\\n\\n- Space complexity:\\nusing a hash map to store the right side balance frequency. the worst case could be storing all N-1 values with different balance count.\\nSo space is O(N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, k) {\\n  // look for k index\\n  // if no k return 0\\n  let idx = -1;\\n  for (let i=0; i<nums.length; i++) {\\n    if (nums[i] === k) idx = i;\\n  }\\n  if (idx === -1) return 0;\\n\\n  // go from k to the right to count 0s and 1s\\n  let rightBalanceFreq = new Map();\\n  let balance = 0;\\n  let count = 1;\\n  for (let i=idx+1; i<nums.length; i++) {\\n    balance += nums[i] > k ? 1:-1\\n    if (balance === 0 || balance === 1) count++;\\n    rightBalanceFreq.set(balance, (rightBalanceFreq.get(balance) || 0)+1);\\n  }\\n\\n  // go from k to the left to count\\n  // 0 and 1 will make a valid subarray already\\n  // then check the complementary of current balance\\n  // i.e. check -balance in rightBalanceMap\\n  // also -balance+1 can make a valid subarray\\n  balance = 0;\\n  for (let i=idx-1; i>=0; i--) {\\n    balance += nums[i] > k ? 1:-1;\\n    if (balance === 0 || balance === 1) count++;\\n    count += (rightBalanceFreq.get(-balance) || 0) + (rightBalanceFreq.get(-balance+1) || 0)\\n\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n- case 1: [k] itself\\n- case 2: there is equal amount of numbers either bigger or smaller than k\\n        ex: [k-2, k-1, k, k+1, k+2]\\n- case 3: the number of values bigger than k - number of values smaller than k is 1\\n        ex: [k-1, k, k+1, k+2]\\n```\n```\\n.....i......k.......j......l\\n     -2     0       2      3\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countSubarrays = function(nums, k) {\\n  // look for k index\\n  // if no k return 0\\n  let idx = -1;\\n  for (let i=0; i<nums.length; i++) {\\n    if (nums[i] === k) idx = i;\\n  }\\n  if (idx === -1) return 0;\\n\\n  // go from k to the right to count 0s and 1s\\n  let rightBalanceFreq = new Map();\\n  let balance = 0;\\n  let count = 1;\\n  for (let i=idx+1; i<nums.length; i++) {\\n    balance += nums[i] > k ? 1:-1\\n    if (balance === 0 || balance === 1) count++;\\n    rightBalanceFreq.set(balance, (rightBalanceFreq.get(balance) || 0)+1);\\n  }\\n\\n  // go from k to the left to count\\n  // 0 and 1 will make a valid subarray already\\n  // then check the complementary of current balance\\n  // i.e. check -balance in rightBalanceMap\\n  // also -balance+1 can make a valid subarray\\n  balance = 0;\\n  for (let i=idx-1; i>=0; i--) {\\n    balance += nums[i] > k ? 1:-1;\\n    if (balance === 0 || balance === 1) count++;\\n    count += (rightBalanceFreq.get(-balance) || 0) + (rightBalanceFreq.get(-balance+1) || 0)\\n\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3672169,
                "title": "o-n-one-pass-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        boolean self = false;\\n        int count = 0;\\n        int[] grt = new int[nums.length];\\n        int[] small = new int[nums.length];\\n        int p1 = 0; //previous for greater\\n        int p2 = 0; //previous for small\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            self = (self || (nums[i] == k));\\n            //System.out.println(self);\\n            if(nums[i] > k) p1++;\\n            else if(nums[i] < k) p2++;\\n            int curr = p1 - p2;\\n            if(self) {\\n                count += map.getOrDefault(curr, 0);\\n                count += map.getOrDefault(curr - 1, 0);\\n            }\\n            if(!self && nums[i] != k) {\\n                map.put(curr, map.getOrDefault(curr, 0) + 1);\\n                //System.out.println(curr + \" = \" + map.get(curr));\\n            }\\n            //System.out.println(count);\\n            //System.out.println();\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        boolean self = false;\\n        int count = 0;\\n        int[] grt = new int[nums.length];\\n        int[] small = new int[nums.length];\\n        int p1 = 0; //previous for greater\\n        int p2 = 0; //previous for small\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            self = (self || (nums[i] == k));\\n            //System.out.println(self);\\n            if(nums[i] > k) p1++;\\n            else if(nums[i] < k) p2++;\\n            int curr = p1 - p2;\\n            if(self) {\\n                count += map.getOrDefault(curr, 0);\\n                count += map.getOrDefault(curr - 1, 0);\\n            }\\n            if(!self && nums[i] != k) {\\n                map.put(curr, map.getOrDefault(curr, 0) + 1);\\n                //System.out.println(curr + \" = \" + map.get(curr));\\n            }\\n            //System.out.println(count);\\n            //System.out.println();\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639890,
                "title": "very-easy-97-converted-into-subarray-sum-with-equal-k",
                "content": "# Intuition\\nconverted into subarray sum with equal K\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint fun(vector<int>& nums, int k)\\n{\\n    int ans=0;\\n    int n=nums.size();\\n    unordered_map<int,int>mp;\\n    mp[0]=1;\\n    int sum=0,found=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        sum+=nums[i];\\n        if(nums[i]==0)\\n        {\\n            found=1;\\n        }\\n        if(found==1)\\n        {\\n            if(mp.find(sum-0)!=mp.end())\\n            ans+=mp[sum-0];\\n            if(mp.find(sum-1)!=mp.end())\\n            ans+=mp[sum-1];\\n        }\\n        else\\n        mp[sum]++;\\n    }\\n    return ans;\\n}\\n    int countSubarrays(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<k)\\n            {\\n                nums[i]=-1;\\n            }\\n            else if(nums[i]>k)\\n            {\\n                nums[i]=1;\\n            }\\n            else\\n            {\\n                nums[i]=0;\\n            }\\n        }\\n        return fun(nums,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint fun(vector<int>& nums, int k)\\n{\\n    int ans=0;\\n    int n=nums.size();\\n    unordered_map<int,int>mp;\\n    mp[0]=1;\\n    int sum=0,found=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        sum+=nums[i];\\n        if(nums[i]==0)\\n        {\\n            found=1;\\n        }\\n        if(found==1)\\n        {\\n            if(mp.find(sum-0)!=mp.end())\\n            ans+=mp[sum-0];\\n            if(mp.find(sum-1)!=mp.end())\\n            ans+=mp[sum-1];\\n        }\\n        else\\n        mp[sum]++;\\n    }\\n    return ans;\\n}\\n    int countSubarrays(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<k)\\n            {\\n                nums[i]=-1;\\n            }\\n            else if(nums[i]>k)\\n            {\\n                nums[i]=1;\\n            }\\n            else\\n            {\\n                nums[i]=0;\\n            }\\n        }\\n        return fun(nums,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593583,
                "title": "rust-o-n-with-single-hashmap",
                "content": "The problem uses an unusual definition of median, where the median of an even-length array is the lower middle number, not the average of the two middle numbers. \\n\\nAdditionally, because all array elements are distinct, there is exactly one element with value k in the array.\\n\\nThis means that the median of a subarray can be k **only** if it contains the single position k_pos where nums[k_pos] == k.\\n\\nSo, we can imagine picking an index i <= k_pos, and an index j >= k_pos, and considering the range nums[i..=j]. This range results in a median of k only if the count of numbers which are greater than k equals the count of numbers less than k, OR the count of numbers greater than k is 1 more than the count of numbers less than k.\\n\\nWe can split this subarray nums[i..=j] in half, considering the range nums[i..=k_pos] and nums[k_pos..=j]. If we want the net total of count(nums > k) - count(nums < k) to equal 0 or 1 overall, then that means we need the left net count + right net count to be 0 or 1.\\n\\nWe can scan on the left side to build up a count of how many subarrays exist for some i <= k_pos where nums[i..=k_pos] has each net count. Once we have this, we can then start from k_pos and scan rightward to get the similar count, and then sum up the number of left side only arrays which have the correct inverse net count.\\n\\n\\n# Complexity\\n- Time complexity: O(n), we do one scan of nums to find k_pos, and then two half-scans to build up the left balances and final output.\\n\\n- Space complexity: O(n) to store the hashmap of left balances.\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n\\n        let k_pos = if let Some(pos) = nums.iter().position(|&num| num == k) { pos } else {\\n            return 0;\\n        };\\n\\n        let mut left_balances = HashMap::<i32, i32>::new();\\n\\n        let mut running = 0;\\n\\n        for i in (0..=k_pos).rev() {\\n            if nums[i] > k {\\n                running += 1;\\n            } else if nums[i] < k{\\n                running -= 1;\\n            }\\n            *left_balances.entry(running).or_default() += 1;\\n        }\\n\\n        running = 0;\\n        let mut output = 0;\\n        for i in (k_pos..n) {\\n            if nums[i] > k {\\n                running += 1;\\n            } else if nums[i] < k{\\n                running -= 1;\\n            }\\n           output += left_balances.get(&(-running)).cloned().unwrap_or(0);\\n           output += left_balances.get(&(1-running)).cloned().unwrap_or(0);\\n        }\\n        output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n\\n        let k_pos = if let Some(pos) = nums.iter().position(|&num| num == k) { pos } else {\\n            return 0;\\n        };\\n\\n        let mut left_balances = HashMap::<i32, i32>::new();\\n\\n        let mut running = 0;\\n\\n        for i in (0..=k_pos).rev() {\\n            if nums[i] > k {\\n                running += 1;\\n            } else if nums[i] < k{\\n                running -= 1;\\n            }\\n            *left_balances.entry(running).or_default() += 1;\\n        }\\n\\n        running = 0;\\n        let mut output = 0;\\n        for i in (k_pos..n) {\\n            if nums[i] > k {\\n                running += 1;\\n            } else if nums[i] < k{\\n                running -= 1;\\n            }\\n           output += left_balances.get(&(-running)).cloned().unwrap_or(0);\\n           output += left_balances.get(&(1-running)).cloned().unwrap_or(0);\\n        }\\n        output\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583524,
                "title": "java-prefix-sum-o-n-unique-element-so-we-can-use-prefix-instead-of-heap",
                "content": "\\n# Code\\n```\\n/**\\n               *\\n[- - - - - - - # - - - - - - - - - - ]\\n\\nbulk loading: \\n    > bulk load until #\\n    > use two heap to find the medium\\nHowever, it took N2Log(N) time, which is pretty ackward;\\nwhat about we do a transformation on the array, to an array with -1, 0, 1\\n    0, 1, 2, 3, 4\\n   [0, 0, 0, $, 1]\\n[-, -, -, -, -, -]\\n 0, 1, 2, 3, 4, 5\\n */\\n\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        // transfer to the binary array\\n        int[] binary = new int[nums.length];\\n        int pos = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < k) binary[i] = -1;\\n            else if (nums[i] > k) binary[i] = 1;\\n            else {\\n                // mark the k position\\n                binary[i] = 0;\\n                pos = i;\\n            }\\n        }\\n        // count the prefix sum of the binary array for future repeated computation\\n        int[] prefix = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++) {\\n            prefix[i + 1] = prefix[i] + binary[i];\\n        }\\n        // count how many of each value before the k position\\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        for (int i = 0; i <= pos; i++) {\\n            m.put(prefix[i], m.getOrDefault(prefix[i], 0) + 1);\\n        }\\n        // starting from the k position, and then rolling out to find the subarray sum = 0 or -1\\n        int res = 0;\\n        for (int i = pos + 1; i < prefix.length; i++) {\\n            res += m.getOrDefault(prefix[i], 0) + m.getOrDefault(prefix[i] - 1, 0);\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n               *\\n[- - - - - - - # - - - - - - - - - - ]\\n\\nbulk loading: \\n    > bulk load until #\\n    > use two heap to find the medium\\nHowever, it took N2Log(N) time, which is pretty ackward;\\nwhat about we do a transformation on the array, to an array with -1, 0, 1\\n    0, 1, 2, 3, 4\\n   [0, 0, 0, $, 1]\\n[-, -, -, -, -, -]\\n 0, 1, 2, 3, 4, 5\\n */\\n\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        // transfer to the binary array\\n        int[] binary = new int[nums.length];\\n        int pos = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < k) binary[i] = -1;\\n            else if (nums[i] > k) binary[i] = 1;\\n            else {\\n                // mark the k position\\n                binary[i] = 0;\\n                pos = i;\\n            }\\n        }\\n        // count the prefix sum of the binary array for future repeated computation\\n        int[] prefix = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++) {\\n            prefix[i + 1] = prefix[i] + binary[i];\\n        }\\n        // count how many of each value before the k position\\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        for (int i = 0; i <= pos; i++) {\\n            m.put(prefix[i], m.getOrDefault(prefix[i], 0) + 1);\\n        }\\n        // starting from the k position, and then rolling out to find the subarray sum = 0 or -1\\n        int res = 0;\\n        for (int i = pos + 1; i < prefix.length; i++) {\\n            res += m.getOrDefault(prefix[i], 0) + m.getOrDefault(prefix[i] - 1, 0);\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556661,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        \\n        int i=0;\\n\\n        while(i<nums.length){\\n            if(k == nums[i])\\n                break;\\n            i++;\\n        }\\n\\n        Map<Integer,Integer> map = new HashMap<>();\\n\\n        int diff = 0;\\n\\n        //System.out.println(i);\\n        map.put(diff,map.getOrDefault(diff,0)+1);\\n\\n        for(int end=i+1;end<nums.length;end++){\\n            if(nums[end] > k)\\n                diff++;\\n            else\\n                diff--;\\n            map.put(diff,map.getOrDefault(diff,0)+1);\\n        }\\n\\n        diff = 0;\\n\\n        int count = 0;\\n\\n        if(map.containsKey(1 - diff))\\n            count += map.get(1 - diff);\\n\\n        if(map.containsKey(0 - diff))\\n            count += map.get(0 - diff);\\n\\n        for(int start=i-1;start>=0;start--){\\n            if(nums[start] > k)\\n                diff++;\\n            else\\n                diff--;\\n\\n            if(map.containsKey(1 - diff))\\n                 count += map.get(1 - diff);\\n                 \\n            if(map.containsKey(0 - diff))\\n                count += map.get(0 - diff);\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        \\n        int i=0;\\n\\n        while(i<nums.length){\\n            if(k == nums[i])\\n                break;\\n            i++;\\n        }\\n\\n        Map<Integer,Integer> map = new HashMap<>();\\n\\n        int diff = 0;\\n\\n        //System.out.println(i);\\n        map.put(diff,map.getOrDefault(diff,0)+1);\\n\\n        for(int end=i+1;end<nums.length;end++){\\n            if(nums[end] > k)\\n                diff++;\\n            else\\n                diff--;\\n            map.put(diff,map.getOrDefault(diff,0)+1);\\n        }\\n\\n        diff = 0;\\n\\n        int count = 0;\\n\\n        if(map.containsKey(1 - diff))\\n            count += map.get(1 - diff);\\n\\n        if(map.containsKey(0 - diff))\\n            count += map.get(0 - diff);\\n\\n        for(int start=i-1;start>=0;start--){\\n            if(nums[start] > k)\\n                diff++;\\n            else\\n                diff--;\\n\\n            if(map.containsKey(1 - diff))\\n                 count += map.get(1 - diff);\\n                 \\n            if(map.containsKey(0 - diff))\\n                count += map.get(0 - diff);\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555978,
                "title": "javascript-track-difference-using-hash-table",
                "content": "# Approach\\n- https://leetcode.com/problems/count-subarrays-with-median-k/solutions/2851940/balance/\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nvar countSubarrays = function(nums, k) {\\n    const count = { 0: 1 }, kIndex = nums.findIndex((a) => a == k);\\n\\n    for (let i = kIndex + 1, bal = 0; i < nums.length; i++)\\n        bal += nums[i] > nums[kIndex] ? 1 : -1, count[bal] = 1 + (count[bal] ?? 0);\\n\\n    let res = count[0] + (count[1] ?? 0);\\n    for (let i = kIndex - 1, bal = 0; i >= 0; i--)\\n        bal += nums[i] > nums[kIndex] ? 1 : -1,\\n        res += (count[-bal] ?? 0) + (count[-bal + 1] ?? 0);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar countSubarrays = function(nums, k) {\\n    const count = { 0: 1 }, kIndex = nums.findIndex((a) => a == k);\\n\\n    for (let i = kIndex + 1, bal = 0; i < nums.length; i++)\\n        bal += nums[i] > nums[kIndex] ? 1 : -1, count[bal] = 1 + (count[bal] ?? 0);\\n\\n    let res = count[0] + (count[1] ?? 0);\\n    for (let i = kIndex - 1, bal = 0; i >= 0; i--)\\n        bal += nums[i] > nums[kIndex] ? 1 : -1,\\n        res += (count[-bal] ?? 0) + (count[-bal + 1] ?? 0);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533171,
                "title": "easy-c-solution",
                "content": "# Intuition\\nIn summary, the code divides the array into two parts based on the index of the first occurrence of k. Then, it uses prefix sums and two unordered maps to efficiently count the subarrays on the left and right sides of the array with the desired sum.\\n\\n# Approach\\nThe calculatePrefixSum function calculates a prefix sum vector vk based on nums and k. This vector helps in finding the sum of subarrays efficiently.\\nThe findKIndex function finds the index (q) of the first occurrence of k in the nums vector. It will be used to divide the array into two parts: the left side (indices 0 to q) and the right side (indices q+1 to n-1).\\nThe countSolutions function counts the number of subarrays in the left side and right side of the array that sum up to a particular value. It uses two unordered maps (mpL and mpR) to store the sums and their corresponding indices.\\nIn the countSubarrays function, it calls countSolutions twice:\\nThe first call is with added = 0, which counts the subarrays in the left side of the array that sum up to a specific value.\\nThe second call is with added = -1, which counts the subarrays in the right side of the array that sum up to a specific value.\\nFinally, it returns the sum of the results obtained from the two calls to countSolutions. This sum represents the total count of subarrays with the sum equal to k.\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int q = findKIndex(nums, k);\\n        vector<int> vk = calculatePrefixSum(nums, k);\\n        return countSolutions(vk, q, 0) + countSolutions(vk, q, -1);\\n    }\\n\\n    int countSolutions(vector<int>& vk, int q, int added) {\\n        int n = vk.size();\\n        int ans = 0;\\n        unordered_map<int, vector<int>> mpL, mpR;\\n        for (int L = 0; L <= q; L++)\\n            mpL[getSubarraySum(L, q, vk) + added].push_back(L);\\n        for (int R = q; R < n; R++)\\n            mpR[getSubarraySum(q, R, vk)].push_back(R);\\n        for (auto& [sum, idxs] : mpL)\\n            ans += idxs.size() * mpR[sum * -1].size();\\n        return ans;\\n    }\\n\\n    int getSubarraySum(int L, int R, vector<int>& vk) {\\n        int vk_R = vk[R];\\n        int vk_L_1 = (L == 0) ? 0 : vk[L - 1];\\n        return vk_R - vk_L_1;\\n    }\\n\\n    int findKIndex(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                return i;\\n            }\\n        }\\n        return -1; // If k is not found, return -1\\n    }\\n\\n    vector<int> calculatePrefixSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> vk(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            if ((nums[i] - k) != 0) {\\n                vk[i] = abs(nums[i] - k) / (nums[i] - k);\\n            }\\n        }\\n        for (int i = 1; i < n; i++) {\\n            vk[i] = vk[i - 1] + vk[i];\\n        }\\n        return vk;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int q = findKIndex(nums, k);\\n        vector<int> vk = calculatePrefixSum(nums, k);\\n        return countSolutions(vk, q, 0) + countSolutions(vk, q, -1);\\n    }\\n\\n    int countSolutions(vector<int>& vk, int q, int added) {\\n        int n = vk.size();\\n        int ans = 0;\\n        unordered_map<int, vector<int>> mpL, mpR;\\n        for (int L = 0; L <= q; L++)\\n            mpL[getSubarraySum(L, q, vk) + added].push_back(L);\\n        for (int R = q; R < n; R++)\\n            mpR[getSubarraySum(q, R, vk)].push_back(R);\\n        for (auto& [sum, idxs] : mpL)\\n            ans += idxs.size() * mpR[sum * -1].size();\\n        return ans;\\n    }\\n\\n    int getSubarraySum(int L, int R, vector<int>& vk) {\\n        int vk_R = vk[R];\\n        int vk_L_1 = (L == 0) ? 0 : vk[L - 1];\\n        return vk_R - vk_L_1;\\n    }\\n\\n    int findKIndex(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                return i;\\n            }\\n        }\\n        return -1; // If k is not found, return -1\\n    }\\n\\n    vector<int> calculatePrefixSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> vk(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            if ((nums[i] - k) != 0) {\\n                vk[i] = abs(nums[i] - k) / (nums[i] - k);\\n            }\\n        }\\n        for (int i = 1; i < n; i++) {\\n            vk[i] = vk[i - 1] + vk[i];\\n        }\\n        return vk;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517376,
                "title": "c-simple-prefix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pre(n);\\n        unordered_map<int,int> mp;\\n        int k_found=-1;\\n        int diff=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<=k) diff++;\\n            else diff--;\\n\\n            if(nums[i]==k){\\n                k_found=i;\\n            }\\n            if(k_found==-1) pre[i]=diff;\\n            else{\\n                mp[diff]++;\\n            }\\n        }\\n        int ans=0;\\n        if(mp.count(0)) ans+=mp[0];\\n        if(mp.count(1)) ans+=mp[1];\\n        for(int i=0;i<k_found;i++){\\n            if(mp.count(pre[i])) ans+=mp[pre[i]];\\n            if(mp.count(pre[i]+1)) ans+=mp[pre[i]+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pre(n);\\n        unordered_map<int,int> mp;\\n        int k_found=-1;\\n        int diff=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<=k) diff++;\\n            else diff--;\\n\\n            if(nums[i]==k){\\n                k_found=i;\\n            }\\n            if(k_found==-1) pre[i]=diff;\\n            else{\\n                mp[diff]++;\\n            }\\n        }\\n        int ans=0;\\n        if(mp.count(0)) ans+=mp[0];\\n        if(mp.count(1)) ans+=mp[1];\\n        for(int i=0;i<k_found;i++){\\n            if(mp.count(pre[i])) ans+=mp[pre[i]];\\n            if(mp.count(pre[i]+1)) ans+=mp[pre[i]+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507237,
                "title": "c-letting-the-standard-c-library-do-all-the-work",
                "content": "Inspired by Vlad\\'s solution, https://leetcode.com/problems/count-subarrays-with-median-k/solutions/2851940/balance/?orderBy=most_votes.\\nSee his description for the theory behind.\\n\\nNotice **every** statement is a call to the Standard Library.\\n```\\nclass Solution {\\npublic:\\n\\tint countSubarrays(std::vector<int>& nums, int k) {\\n\\t\\t// Numbers really only matters in terms of greater than k or less than k\\n\\t\\t// So clamp them\\n\\t\\tfor (auto& x : nums) { x = std::clamp(x - k, -1, 1); }\\n\\t\\tauto iter = std::find(std::begin(nums), std::end(nums), 0);\\n\\n        // Calculating partial sums going away from k\\n\\t\\tstd::partial_sum(std::next(iter), std::end(nums), std::next(iter));\\n\\t\\tstd::partial_sum(std::reverse_iterator(iter), std::rend(nums), std::reverse_iterator(iter));\\n\\n\\t\\t// Counting subarrays of odd length starting or ending with k\\n\\t\\tauto result = static_cast<int>(std::count(std::cbegin(nums), std::cend(nums), 0));\\n\\t\\t\\n\\t\\t// Counting subarrays of even length starting or ending with k\\n\\t\\tresult += static_cast<int>(std::count(std::cbegin(nums), std::cend(nums), 1));\\n\\n\\t\\tauto count = std::unordered_map<int, int>();\\n\\t\\tstd::for_each(std::begin(nums), iter,\\n\\t\\t\\t[&count](auto sum) { ++count[sum]; });\\n\\n\\t\\t// Adding subarrays straddling k\\n\\t\\treturn std::accumulate(std::next(iter), std::end(nums), result,\\n\\t\\t\\t[&count](auto const& accu, auto sum) { return accu + count[0 - sum] + count[1 - sum]; });\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint countSubarrays(std::vector<int>& nums, int k) {\\n\\t\\t// Numbers really only matters in terms of greater than k or less than k\\n\\t\\t// So clamp them\\n\\t\\tfor (auto& x : nums) { x = std::clamp(x - k, -1, 1); }\\n\\t\\tauto iter = std::find(std::begin(nums), std::end(nums), 0);\\n\\n        // Calculating partial sums going away from k\\n\\t\\tstd::partial_sum(std::next(iter), std::end(nums), std::next(iter));\\n\\t\\tstd::partial_sum(std::reverse_iterator(iter), std::rend(nums), std::reverse_iterator(iter));\\n\\n\\t\\t// Counting subarrays of odd length starting or ending with k\\n\\t\\tauto result = static_cast<int>(std::count(std::cbegin(nums), std::cend(nums), 0));\\n\\t\\t\\n\\t\\t// Counting subarrays of even length starting or ending with k\\n\\t\\tresult += static_cast<int>(std::count(std::cbegin(nums), std::cend(nums), 1));\\n\\n\\t\\tauto count = std::unordered_map<int, int>();\\n\\t\\tstd::for_each(std::begin(nums), iter,\\n\\t\\t\\t[&count](auto sum) { ++count[sum]; });\\n\\n\\t\\t// Adding subarrays straddling k\\n\\t\\treturn std::accumulate(std::next(iter), std::end(nums), result,\\n\\t\\t\\t[&count](auto const& accu, auto sum) { return accu + count[0 - sum] + count[1 - sum]; });\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432645,
                "title": "golang-prefix-map",
                "content": "```\\npackage main\\n\\n\\nfunc countSubarrays(nums []int, k int) int {\\n\\tdict := make(map[int]int, len(nums)/2)\\n\\tdict[0] = 1\\n\\n\\tresult, sum, valid := 0, 0, false\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] < k {\\n\\t\\t\\tsum--\\n\\t\\t} else if nums[i] > k {\\n\\t\\t\\tsum++\\n\\t\\t} else {\\n\\t\\t\\tvalid = true\\n\\t\\t}\\n\\n\\t\\tif valid {\\n\\t\\t\\t// Check for matching prefix sum\\'s only after K has been encountered\\n\\t\\t\\tresult += dict[sum] + dict[sum-1]\\n\\t\\t} else {\\n\\t\\t\\t// Register the prefix till K is not encountered.\\n\\t\\t\\tdict[sum]++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\n\\nfunc countSubarrays(nums []int, k int) int {\\n\\tdict := make(map[int]int, len(nums)/2)\\n\\tdict[0] = 1\\n\\n\\tresult, sum, valid := 0, 0, false\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] < k {\\n\\t\\t\\tsum--\\n\\t\\t} else if nums[i] > k {\\n\\t\\t\\tsum++\\n\\t\\t} else {\\n\\t\\t\\tvalid = true\\n\\t\\t}\\n\\n\\t\\tif valid {\\n\\t\\t\\t// Check for matching prefix sum\\'s only after K has been encountered\\n\\t\\t\\tresult += dict[sum] + dict[sum-1]\\n\\t\\t} else {\\n\\t\\t\\t// Register the prefix till K is not encountered.\\n\\t\\t\\tdict[sum]++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323551,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) \\n    {\\n        unordered_map<int,int>l,r;\\n        int i=0;\\n        for(;i<nums.size();++i)\\n        {\\n           if(nums[i]==k)\\n               break;\\n        }\\n        if(i==nums.size())\\n            return 0;\\n        int j=i-1;\\n        int s=0;\\n        while(j>-1)\\n        {\\n            if(nums[j]>k)\\n                s-=1;\\n            else\\n                s+=1;\\n            ++l[s];\\n            --j;\\n        }\\n        j=i+1;\\n        s=0;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]>k)\\n                s+=1;\\n            else\\n                s-=1;\\n            ++r[s];\\n            ++j;\\n        }\\n        int c=1;\\n        for(auto a:l)\\n        {\\n            if(r.find(a.first)!=r.end())\\n            {\\n                c=c+a.second*r[a.first];\\n            }\\n            if(r.find(a.first+1)!=r.end())\\n            {\\n                c=c+a.second*r[a.first+1];\\n            }\\n        }\\n        if(r.find(1)!=r.end())\\n        {\\n            c=c+r[1];\\n        }\\n        if(r.find(0)!=r.end())\\n            c=c+r[0];\\n        if(l.find(-1)!=l.end())\\n        {\\n            c=c+l[-1];\\n        }\\n        if(l.find(0)!=l.end())\\n        {\\n            c=c+l[0];\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) \\n    {\\n        unordered_map<int,int>l,r;\\n        int i=0;\\n        for(;i<nums.size();++i)\\n        {\\n           if(nums[i]==k)\\n               break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3312869,
                "title": "o-n-solution-c-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is clear that we need to consider only those sub-array\\'s which contain the given median.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use the Hash-map and PrifixSum technique to solve this problem.\\nAt first we creat a hashmap of `<int,int>` to store the numbers and their frequencies which are less than or greater than the given median. Initially we make the 0th frequency 1.\\nwe use a `for loop` for traversal from 0 index as we find any number which is less than the median then we reduce the  `sum` by 1 and if number is greater than the median we incriment the `sum`.\\nas soon as we reach the median we marke the flag as `True`.\\nAs the flag is marked true we we star to adding the no. of sub array in `res`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nClearly the Time complexity is $$O(n)$$. As we traverse the the whole Array. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe Space Complexity will be $$O(n)$$. Because we use a Hashmap.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        m[0]++;\\n        int sum=0,res=0;\\n        bool flag=false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<k)   sum--;\\n            else if(nums[i]>k)  sum++;\\n            else    flag=true;\\n            if(flag)    res+=m[sum]+m[sum-1];\\n            else m[sum]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        m[0]++;\\n        int sum=0,res=0;\\n        bool flag=false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<k)   sum--;\\n            else if(nums[i]>k)  sum++;\\n            else    flag=true;\\n            if(flag)    res+=m[sum]+m[sum-1];\\n            else m[sum]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311619,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        pos = nums.index(k)\\n\\n        cnt = defaultdict(int)\\n\\n        bal = 0\\n        for i in range(pos, n):\\n            num = nums[i]\\n            bal += 1 if num > k else (-1 if num < k else 0)\\n            cnt[bal] += 1\\n        \\n        res = 0\\n        bal = 0\\n        for i in reversed(range(pos+1)):\\n            num = nums[i]\\n            bal += 1 if num > k else (-1 if num < k else 0)\\n            \\n            res += cnt[-bal]\\n            res += cnt[-bal+1]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        pos = nums.index(k)\\n\\n        cnt = defaultdict(int)\\n\\n        bal = 0\\n        for i in range(pos, n):\\n            num = nums[i]\\n            bal += 1 if num > k else (-1 if num < k else 0)\\n            cnt[bal] += 1\\n        \\n        res = 0\\n        bal = 0\\n        for i in reversed(range(pos+1)):\\n            num = nums[i]\\n            bal += 1 if num > k else (-1 if num < k else 0)\\n            \\n            res += cnt[-bal]\\n            res += cnt[-bal+1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310453,
                "title": "go-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc countSubarrays(nums []int, k int) int {\\n    n := len(nums)\\n    count := map[int]int{}\\n    p := -1\\n    for i, num := range nums {\\n        if num == k {\\n            p = i\\n            break\\n        }\\n    }\\n    bal := 0\\n    for i := p; i < n; i++ {\\n        if nums[i] == k {\\n            bal += 0\\n        } else if nums[i] < k {\\n            bal -= 1\\n        } else {\\n            bal += 1\\n        }\\n        if _, ok := count[bal]; !ok {\\n            count[bal] = 1\\n        } else {\\n            count[bal]++\\n        }\\n    }\\n    res := 0\\n    bal = 0\\n    for i := p; i >= 0; i-- {\\n        if nums[i] == k {\\n            bal += 0\\n        } else if nums[i] < k {\\n            bal -= 1\\n        } else {\\n            bal += 1\\n        }\\n        res += count[-bal] + count[-bal+1]\\n    }\\n    return res \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countSubarrays(nums []int, k int) int {\\n    n := len(nums)\\n    count := map[int]int{}\\n    p := -1\\n    for i, num := range nums {\\n        if num == k {\\n            p = i\\n            break\\n        }\\n    }\\n    bal := 0\\n    for i := p; i < n; i++ {\\n        if nums[i] == k {\\n            bal += 0\\n        } else if nums[i] < k {\\n            bal -= 1\\n        } else {\\n            bal += 1\\n        }\\n        if _, ok := count[bal]; !ok {\\n            count[bal] = 1\\n        } else {\\n            count[bal]++\\n        }\\n    }\\n    res := 0\\n    bal = 0\\n    for i := p; i >= 0; i-- {\\n        if nums[i] == k {\\n            bal += 0\\n        } else if nums[i] < k {\\n            bal -= 1\\n        } else {\\n            bal += 1\\n        }\\n        res += count[-bal] + count[-bal+1]\\n    }\\n    return res \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3296168,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\ntransform the numbers > k to 1, the numbers < k to -1, the numbers == k to 0,\\nuse prefix sum to track the balance between the numbers > k and numbers < k\\nif we have found k, and we can count the number of subarray\\nif subarray\\'s length is odd, and #(number > k) == #(number < k) in subarray (the sum of this subarray is 0), so we can use a hash map to track the number of the current sum we have got before,\\nif subarray\\'s length is even, and #(number > k) - #(number < k) == 1 (the sum of this subarray is 1), so we can find the the number of the current sum - 1 we have got before.\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nfrom collections import defaultdict\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        s = 0\\n        prefixsumToFreq = defaultdict(int)\\n        prefixsumToFreq[0] = 1\\n        found = False\\n        ans = 0\\n        for n in nums:\\n            if n < k: s -= 1\\n            elif n > k: s += 1\\n            else: found = True\\n            \\n            if found: ans = ans + prefixsumToFreq[s] + prefixsumToFreq[s-1]\\n            else: prefixsumToFreq[s] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```python\\n\\'\\'\\'\\ntransform the numbers > k to 1, the numbers < k to -1, the numbers == k to 0,\\nuse prefix sum to track the balance between the numbers > k and numbers < k\\nif we have found k, and we can count the number of subarray\\nif subarray\\'s length is odd, and #(number > k) == #(number < k) in subarray (the sum of this subarray is 0), so we can use a hash map to track the number of the current sum we have got before,\\nif subarray\\'s length is even, and #(number > k) - #(number < k) == 1 (the sum of this subarray is 1), so we can find the the number of the current sum - 1 we have got before.\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nfrom collections import defaultdict\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        s = 0\\n        prefixsumToFreq = defaultdict(int)\\n        prefixsumToFreq[0] = 1\\n        found = False\\n        ans = 0\\n        for n in nums:\\n            if n < k: s -= 1\\n            elif n > k: s += 1\\n            else: found = True\\n            \\n            if found: ans = ans + prefixsumToFreq[s] + prefixsumToFreq[s-1]\\n            else: prefixsumToFreq[s] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292333,
                "title": "c-count-left-and-right",
                "content": "# Intuition\\nfor a subarray, let cnt = num of values > k - num of value < k\\nto make k at medium, cnt must be 0 for odd size or 1 for even size.\\nuse two map to store the cnt of leftside and rightride subarray.\\nto make k at medium, left cnt + right cnt must be 0 or 1. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int res = 0, n = nums.size(), pos = find(begin(nums), end(nums), k) - nums.begin();      \\n        unordered_map<int,int> leftCnt = {{0,1}}, rightCnt = leftCnt;\\n        for(int i=pos-1, cnt=0; i>=0;i--){\\n            nums[i] > k? cnt++ : cnt--;\\n            leftCnt[cnt]++;\\n        }\\n        for(int i=pos+1, cnt=0; i<n;i++){\\n            nums[i] > k? cnt++ : cnt--;\\n            rightCnt[cnt]++;\\n        }\\n        for(auto [x, n] : leftCnt){\\n            res += n * rightCnt[-x]; //odd\\n            res += n * rightCnt[1-x]; //even\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int res = 0, n = nums.size(), pos = find(begin(nums), end(nums), k) - nums.begin();      \\n        unordered_map<int,int> leftCnt = {{0,1}}, rightCnt = leftCnt;\\n        for(int i=pos-1, cnt=0; i>=0;i--){\\n            nums[i] > k? cnt++ : cnt--;\\n            leftCnt[cnt]++;\\n        }\\n        for(int i=pos+1, cnt=0; i<n;i++){\\n            nums[i] > k? cnt++ : cnt--;\\n            rightCnt[cnt]++;\\n        }\\n        for(auto [x, n] : leftCnt){\\n            res += n * rightCnt[-x]; //odd\\n            res += n * rightCnt[1-x]; //even\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248387,
                "title": "swift-with-explanation",
                "content": "- Find the index of k - ***ind***\\n- Traverse from right to left (from ind-1 to 0) and count the balance that means which numbers predominates (from i to ind) \\u2013 numbers greater or less than k? If balance equals 0 - the parity between them. \\nCount and  Remember all balances in map dictionary\\n- Then loop from ind+1 to the end. \\n Add to var count all subarrays which satisfy 2 conditions:\\n   -  opposite balance between start and end (greater count equals less count)  - odd case\\n   - subarrays, where numberes greater k one more than less numbers  - even case\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func countSubarrays(_ nums: [Int], _ k: Int) -> Int {\\n        let ind = nums.firstIndex(of: k)! // find k in the array\\n        var map = [0: 1] // already including the zero balance for k itself (+1 count for 0 balance)\\n        var balance = 0   \\n        for i in (0..<ind).reversed() {  // count and remember all ballances left to k \\n            balance += (nums[i] > k) ? 1 : -1  \\n            map[balance, default: 0] += 1\\n        }\\n\\n        var count = (map[0] ?? 0) + (map[1] ?? 0) // already counting all subarrays with ballance equal to 0 and 1 \\n        balance = 0\\n        for i in ind+1..<nums.count {\\n            balance += nums[i] > k ? 1 : -1\\n            count += map[-balance] ?? 0   // cases when k is the MIDDLE median \\u2013 in odd subarrays\\n            count += map[-balance+1] ?? 0  // cases when k is the LEFT median for even subarrays\\n        }\\n        return count \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    func countSubarrays(_ nums: [Int], _ k: Int) -> Int {\\n        let ind = nums.firstIndex(of: k)! // find k in the array\\n        var map = [0: 1] // already including the zero balance for k itself (+1 count for 0 balance)\\n        var balance = 0   \\n        for i in (0..<ind).reversed() {  // count and remember all ballances left to k \\n            balance += (nums[i] > k) ? 1 : -1  \\n            map[balance, default: 0] += 1\\n        }\\n\\n        var count = (map[0] ?? 0) + (map[1] ?? 0) // already counting all subarrays with ballance equal to 0 and 1 \\n        balance = 0\\n        for i in ind+1..<nums.count {\\n            balance += nums[i] > k ? 1 : -1\\n            count += map[-balance] ?? 0   // cases when k is the MIDDLE median \\u2013 in odd subarrays\\n            count += map[-balance+1] ?? 0  // cases when k is the LEFT median for even subarrays\\n        }\\n        return count \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216913,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n       map<int,int> mp;\\n       int cnt=0;\\n       int i=0,n=nums.size();\\n        bool found=false;\\n        mp[0]=1;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(nums[i]<k)\\n                cnt--;\\n            else if(nums[i]>k)\\n                cnt++;\\n            else\\n                found=true;\\n            if(found)\\n            {\\n                ans+=mp[cnt]+mp[cnt-1];\\n\\t\\t\\t}                                 \\n            else\\n            mp[cnt]++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n       map<int,int> mp;\\n       int cnt=0;\\n       int i=0,n=nums.size();\\n        bool found=false;\\n        mp[0]=1;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(nums[i]<k)\\n                cnt--;\\n            else if(nums[i]>k)\\n                cnt++;\\n            else\\n                found=true;\\n            if(found)\\n            {\\n                ans+=mp[cnt]+mp[cnt-1];\\n\\t\\t\\t}                                 \\n            else\\n            mp[cnt]++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140169,
                "title": "c-prefix-sum-hash-count-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. A subarray can be a candidate only when it includes the element with value `k`, so we only check those subarrays.\\n2. They are distinct integers from `1` to `n`, so there must be and only be one element with value `k`.\\n3. If `k` is the median of the subarray, then\\n    `large_count` is the same as `small_count` or `small_count + 1`, where\\n    `small_count` is the number of elements in the subarray which are smaller than `k`, and\\n    `large_count` is the number of elements in the subarray which are larger than `k`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo an intuitive way is\\n1. traverse `nums` to find the index `mid` where `nums[mid]` is `k`\\n2. traverse each subarray including `nums[mid]`. Check if the subarray meets the condition `large_count == small_count || large_count == small_count + 1`\\n\\nThe condition we check can be actually replaced by\\n```\\n(large_count - small_count) == 0 || (large_count - small_count) == 1\\n```\\nand just use another variable named `large_offset_count` standing for `large_count - small_count`. So the condition becomes\\n```\\nlarge_offset_count == 0 || large_offset_count == 1\\n```\\n\\nTo traverse all the candidate subarrays, a brute force way is by double iteration.\\n- Iterate each `start` from `mid` ~ `0`.\\n- And for each `start` we iterate each `end` from `mid` ~ `nums.size()-1`.\\n- And for each pair of `start`, `end`, we traverse the subarray to count its`large_offset_count`.\\nIt takes $$O(N^3)$$ time to get all `large_offset_count[start][end]`\\n\\nSince the subarray`start ~ end` only differ single element from the subarray `start-1 ~ end`, if we already get `large_offset_count[start][end]`, we can immediately get `large_offset_count[start-1][end]` by only check `nums[start-1]`, instead of check the whole subarray again. It\\'s the same way we get `large_offset_count[start][end+1]`. So now it only takes $$O(N^2)$$ time to get all `large_offset_count[start][end]`.\\n\\nUntil now, each round of iteration for `start` still has to iterate the same range of `end` from `mid` to `nums.size()-1`. But we know each value in this range must be fixed during each iteration of `start`. So if we record every `large_offset_count[mid][end]` first, then we can get `large_offset_count[start][end]` by adding `large_offset_count[start][mid]` and `large_offset_count[mid][end]` without checking `nums[end]`. (Note there\\'s overlap at `mid`, but that\\'s fine since the overlapping value is `0`)\\n\\nFurthermore, we only care how many `large_offset_count[start][end]` are `0` or `1`, we don\\'t care the exact position of `start`, `end`. So for each `start`, we only care how many `large_offset_count[mid][end]` has the value `0 - large_offset_count[start][mid]` or `1 - large_offset_count[start][mid]`. To get the answer quickly, we use hash count to record the total number of each value of `large_offset_count[mid][end]` when we traverse each `end`, and then traverse each `start` to find the answer.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n    1. traverse `nums` to find `mid`, the index of value `k`.\\n    2. traverse each index behind `mid` (including) to generate hash count.\\n    3. traverse each index before `mid` (including) to find total number of subarrays with median as `k`.\\n- Space complexity: $$O(N)$$\\n    - value of hash key is the difference between the number of elements larger than `k` and the number of elements smaller than `k`. This value is among `-N + 1` ~ `N - 1`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int mid = find(nums.begin(), nums.end(), k) - nums.begin();\\n        \\n        int size = nums.size();\\n        unordered_map<int, int> large_offset_count; // consider the range [mid, size - 1]\\n        int cur_large_offset = 0; // consider the range [mid, i]\\n        for (int i = mid; i != size; ++i) {\\n            if (nums[i] > k)\\n                ++cur_large_offset;\\n            else if (nums[i] < k)\\n                --cur_large_offset;\\n            \\n            ++large_offset_count[cur_large_offset];\\n        }\\n        \\n        cur_large_offset = 0; // consider the range [i, mid]\\n        int count = 0;\\n        for (int i = mid; i >= 0; --i) {\\n            if (nums[i] > k)\\n                ++cur_large_offset;\\n            else if (nums[i] < k)\\n                --cur_large_offset;\\n            \\n            count += large_offset_count[0 - cur_large_offset];\\n            count += large_offset_count[1 - cur_large_offset];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n(large_count - small_count) == 0 || (large_count - small_count) == 1\\n```\n```\\nlarge_offset_count == 0 || large_offset_count == 1\\n```\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int mid = find(nums.begin(), nums.end(), k) - nums.begin();\\n        \\n        int size = nums.size();\\n        unordered_map<int, int> large_offset_count; // consider the range [mid, size - 1]\\n        int cur_large_offset = 0; // consider the range [mid, i]\\n        for (int i = mid; i != size; ++i) {\\n            if (nums[i] > k)\\n                ++cur_large_offset;\\n            else if (nums[i] < k)\\n                --cur_large_offset;\\n            \\n            ++large_offset_count[cur_large_offset];\\n        }\\n        \\n        cur_large_offset = 0; // consider the range [i, mid]\\n        int count = 0;\\n        for (int i = mid; i >= 0; --i) {\\n            if (nums[i] > k)\\n                ++cur_large_offset;\\n            else if (nums[i] < k)\\n                --cur_large_offset;\\n            \\n            count += large_offset_count[0 - cur_large_offset];\\n            count += large_offset_count[1 - cur_large_offset];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137847,
                "title": "prefix-sum-hashing-approach-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding a median of an array takes more time. But now we just need to find if an element K is the median or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndefining new metric called effective_sum : (K is median)\\nif(nums[i]>K) sum+=1;\\nif(nums[i]<K) sum+= -1;\\nif(nums[i]==K) sum+=0;\\n\\nassume k is the index of K \\nfor K to be the median of a subarray, the addition of effective_sum of left side and right side of k should be 0 (for odd size array) and 1 (for even sized array)\\n\\nso, maintain a map with sum as key and its frequency as value so that no.of subarrays possible can be found. \\n\\nnow for each index in the leftside : observing the number of subarrays possible, find the total number of subarrays with median K .\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int index = 0;\\n        int count = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==k){\\n                index = i;\\n                break;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=index;i<nums.length;i++){\\n            int value = nums[i]==k?0:(nums[i]>k)?1:-1;\\n            sum += value;\\n            map.put(sum,map.getOrDefault(sum,0)+1);\\n        }\\n        sum=0;\\n        for(int i=index;i>=0;i--){\\n            int value = nums[i]==k?0:(nums[i]>k)?1:-1;\\n            sum += value;\\n            count += map.getOrDefault(0-sum,0);\\n            count += map.getOrDefault(1-sum,0);\\n        }\\n        return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int index = 0;\\n        int count = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==k){\\n                index = i;\\n                break;\\n            }\\n        }\\n        int sum = 0;\\n        for(int i=index;i<nums.length;i++){\\n            int value = nums[i]==k?0:(nums[i]>k)?1:-1;\\n            sum += value;\\n            map.put(sum,map.getOrDefault(sum,0)+1);\\n        }\\n        sum=0;\\n        for(int i=index;i>=0;i--){\\n            int value = nums[i]==k?0:(nums[i]>k)?1:-1;\\n            sum += value;\\n            count += map.getOrDefault(0-sum,0);\\n            count += map.getOrDefault(1-sum,0);\\n        }\\n        return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098514,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n         int n = nums.size(),sum=0,count=0;\\n        bool flag = false;\\n        unordered_map<int,int>mp;\\n        mp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<k) sum--;  //decrease count when nums[i]<k\\n            \\n            else if(nums[i]>k) sum++; //increase count when nums[i]>k\\n            \\n            if(nums[i]==k) flag = true;\\n            \\n            if(flag){\\n                count += mp[sum] + mp[sum-1];   \\n               }\\n            else mp[sum]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n         int n = nums.size(),sum=0,count=0;\\n        bool flag = false;\\n        unordered_map<int,int>mp;\\n        mp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<k) sum--;  //decrease count when nums[i]<k\\n            \\n            else if(nums[i]>k) sum++; //increase count when nums[i]>k\\n            \\n            if(nums[i]==k) flag = true;\\n            \\n            if(flag){\\n                count += mp[sum] + mp[sum-1];   \\n               }\\n            else mp[sum]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092998,
                "title": "c-scan-a-side-of-the-vector-with-a-balance-map",
                "content": "\\n\\n```\\n// idea: prepare an unordered map, and then scan the longer partition from k.\\n// k divides the vector a into two partitions.\\n// we process the shorter partition into a map\\n// then scan the longer partition.\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& a, int k) {\\n        // find the pos of k\\n        int kPos = find(a.begin(), a.end(), k) - a.begin();\\n        // cout << \"k is at \" << kPos << endl;\\n        \\n        // k divides the vector a into two partitions.\\n        // we process the shorter partition into a map\\n        // then scan the longer partition.\\n        \\n        // but here for easier coding, we process the left-side partition ...\\n        unordered_map<int, int> m; // map from +/- diffs to positions\\n        ++m[0];\\n        for (int i = kPos - 1, bal = 0; i >= 0; --i) {\\n            bal += (a[i] > k) ? 1 : -1;\\n            ++m[bal];    \\n        }\\n        // in a[0...kPos],\\n        // k is the left median when bal equals 0 or 1\\n        int res = m[0] + m[1];\\n        \\n        // dbg\\n        // for (auto [diff, cnt] : m) {\\n        //     cout << \"diff: \" << diff << \" ==> \" << cnt << endl;\\n        // }\\n        \\n        // now, we scan the right-side partition\\n        for (int i = kPos + 1, bal = 0; i < (int)a.size(); ++i) {\\n            bal += (a[i] > k) ? 1 : -1;\\n            // find diff_x in the left-side, \\n            // such that `diff_x + bal` equals to 0 or 1.\\n            // ==> diff_x == `-bal` or `1 - bal`\\n            if (auto it = m.find(-bal); it != m.end()) {\\n                res += it->second;\\n            }\\n            if (auto it = m.find(1 - bal); it != m.end()) {\\n                res += it->second;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// idea: prepare an unordered map, and then scan the longer partition from k.\\n// k divides the vector a into two partitions.\\n// we process the shorter partition into a map\\n// then scan the longer partition.\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& a, int k) {\\n        // find the pos of k\\n        int kPos = find(a.begin(), a.end(), k) - a.begin();\\n        // cout << \"k is at \" << kPos << endl;\\n        \\n        // k divides the vector a into two partitions.\\n        // we process the shorter partition into a map\\n        // then scan the longer partition.\\n        \\n        // but here for easier coding, we process the left-side partition ...\\n        unordered_map<int, int> m; // map from +/- diffs to positions\\n        ++m[0];\\n        for (int i = kPos - 1, bal = 0; i >= 0; --i) {\\n            bal += (a[i] > k) ? 1 : -1;\\n            ++m[bal];    \\n        }\\n        // in a[0...kPos],\\n        // k is the left median when bal equals 0 or 1\\n        int res = m[0] + m[1];\\n        \\n        // dbg\\n        // for (auto [diff, cnt] : m) {\\n        //     cout << \"diff: \" << diff << \" ==> \" << cnt << endl;\\n        // }\\n        \\n        // now, we scan the right-side partition\\n        for (int i = kPos + 1, bal = 0; i < (int)a.size(); ++i) {\\n            bal += (a[i] > k) ? 1 : -1;\\n            // find diff_x in the left-side, \\n            // such that `diff_x + bal` equals to 0 or 1.\\n            // ==> diff_x == `-bal` or `1 - bal`\\n            if (auto it = m.find(-bal); it != m.end()) {\\n                res += it->second;\\n            }\\n            if (auto it = m.find(1 - bal); it != m.end()) {\\n                res += it->second;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3015918,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums, k):\\n        dict1, running_sum, total, found = collections.defaultdict(int), 0, 0, 0\\n\\n        dict1[0] = 1\\n\\n        for i in nums:\\n            if i > k:\\n                running_sum += 1\\n            elif i < k:\\n                running_sum -= 1\\n            else:\\n                found = 1\\n\\n            if found:\\n                total += dict1[running_sum-1] + dict1[running_sum]\\n            else:\\n                dict1[running_sum] += 1\\n\\n        return total\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums, k):\\n        dict1, running_sum, total, found = collections.defaultdict(int), 0, 0, 0\\n\\n        dict1[0] = 1\\n\\n        for i in nums:\\n            if i > k:\\n                running_sum += 1\\n            elif i < k:\\n                running_sum -= 1\\n            else:\\n                found = 1\\n\\n            if found:\\n                total += dict1[running_sum-1] + dict1[running_sum]\\n            else:\\n                dict1[running_sum] += 1\\n\\n        return total\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011445,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        for (int j = 0; j < n; ++j) {\\n            if (nums[j] == k) {\\n                i = j;\\n                break;\\n            }\\n        }\\n        int ans = 1;\\n        int d[n << 1 | 1];\\n        memset(d, 0, sizeof d);\\n        int mi = 0, mx = 0;\\n        for (int j = i + 1; j < n; ++j) {\\n            if (nums[j] < k) ++mi;\\n            else ++mx;\\n            if (mx - mi >= 0 && mx - mi <= 1) ++ans;\\n            ++d[mx - mi + n];\\n        }\\n        mi = 0, mx = 0;\\n        for (int j = i - 1; ~j; --j) {\\n            if (nums[j] < k) ++mi;\\n            else ++mx;\\n            if (mx - mi >= 0 && mx - mi <= 1) ++ans;\\n            ans += d[mi - mx + n] + d[mi - mx + n + 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        for (int j = 0; j < n; ++j) {\\n            if (nums[j] == k) {\\n                i = j;\\n                break;\\n            }\\n        }\\n        int ans = 1;\\n        int d[n << 1 | 1];\\n        memset(d, 0, sizeof d);\\n        int mi = 0, mx = 0;\\n        for (int j = i + 1; j < n; ++j) {\\n            if (nums[j] < k) ++mi;\\n            else ++mx;\\n            if (mx - mi >= 0 && mx - mi <= 1) ++ans;\\n            ++d[mx - mi + n];\\n        }\\n        mi = 0, mx = 0;\\n        for (int j = i - 1; ~j; --j) {\\n            if (nums[j] < k) ++mi;\\n            else ++mx;\\n            if (mx - mi >= 0 && mx - mi <= 1) ++ans;\\n            ans += d[mi - mx + n] + d[mi - mx + n + 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011442,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        for (int j = 0; j < n; ++j) {\\n            if (nums[j] == k) {\\n                i = j;\\n                break;\\n            }\\n        }\\n        int ans = 1;\\n        int d[n << 1 | 1];\\n        memset(d, 0, sizeof d);\\n        int mi = 0, mx = 0;\\n        for (int j = i + 1; j < n; ++j) {\\n            if (nums[j] < k) ++mi;\\n            else ++mx;\\n            if (mx - mi >= 0 && mx - mi <= 1) ++ans;\\n            ++d[mx - mi + n];\\n        }\\n        mi = 0, mx = 0;\\n        for (int j = i - 1; ~j; --j) {\\n            if (nums[j] < k) ++mi;\\n            else ++mx;\\n            if (mx - mi >= 0 && mx - mi <= 1) ++ans;\\n            ans += d[mi - mx + n] + d[mi - mx + n + 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        for (int j = 0; j < n; ++j) {\\n            if (nums[j] == k) {\\n                i = j;\\n                break;\\n            }\\n        }\\n        int ans = 1;\\n        int d[n << 1 | 1];\\n        memset(d, 0, sizeof d);\\n        int mi = 0, mx = 0;\\n        for (int j = i + 1; j < n; ++j) {\\n            if (nums[j] < k) ++mi;\\n            else ++mx;\\n            if (mx - mi >= 0 && mx - mi <= 1) ++ans;\\n            ++d[mx - mi + n];\\n        }\\n        mi = 0, mx = 0;\\n        for (int j = i - 1; ~j; --j) {\\n            if (nums[j] < k) ++mi;\\n            else ++mx;\\n            if (mx - mi >= 0 && mx - mi <= 1) ++ans;\\n            ans += d[mi - mx + n] + d[mi - mx + n + 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973197,
                "title": "golang-solution-detailed-explanation",
                "content": "# Keypoint\\n1. All numbers are distinct. So there is only one k in nums\\n2. **balanced**: if an array is balanced(count(moreK) - count(lessK) == 0 or 1) and contains k, it is a valid subarray. \\n3. split array with k. If left side and right side combined are balanced, the array has median k\\n3.1 First calculate balance of right side, record balance-count in a hashtable. Then calculate balance of left side, find count of balanced right side and add it to the result.\\n\\n# Code\\n```\\nfunc countSubarrays(nums []int, k int) int {\\n    n := len(nums)\\n    cnt := map[int]int{}\\n    p := -1\\n    for i, num := range nums {\\n        if num == k {\\n            p = i\\n            break\\n        }\\n    }\\n    bal := 0\\n    for i := p; i < n; i++ {\\n        if nums[i] == k {\\n            bal += 0\\n        } else if nums[i] < k {\\n            bal -= 1\\n        } else {\\n            bal += 1\\n        }\\n        if _, ok := cnt[bal]; !ok {\\n            cnt[bal] = 1\\n        } else {\\n            cnt[bal]++\\n        }\\n    }\\n    res := 0\\n    bal = 0\\n    for i := p; i >= 0; i-- {\\n        if nums[i] == k {\\n            bal += 0\\n        } else if nums[i] < k {\\n            bal -= 1\\n        } else {\\n            bal += 1\\n        }\\n        res += cnt[-bal] + cnt[-bal+1]\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countSubarrays(nums []int, k int) int {\\n    n := len(nums)\\n    cnt := map[int]int{}\\n    p := -1\\n    for i, num := range nums {\\n        if num == k {\\n            p = i\\n            break\\n        }\\n    }\\n    bal := 0\\n    for i := p; i < n; i++ {\\n        if nums[i] == k {\\n            bal += 0\\n        } else if nums[i] < k {\\n            bal -= 1\\n        } else {\\n            bal += 1\\n        }\\n        if _, ok := cnt[bal]; !ok {\\n            cnt[bal] = 1\\n        } else {\\n            cnt[bal]++\\n        }\\n    }\\n    res := 0\\n    bal = 0\\n    for i := p; i >= 0; i-- {\\n        if nums[i] == k {\\n            bal += 0\\n        } else if nums[i] < k {\\n            bal -= 1\\n        } else {\\n            bal += 1\\n        }\\n        res += cnt[-bal] + cnt[-bal+1]\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2962173,
                "title": "c-max-min-approach-o-n",
                "content": "# Approach\\n1. Count grater g1 and small s1 value from left of k and count grater g2 and small s2 right of k\\n2. Then for odd array g1+s1 == g2+s2 should be for k median and for even array g1+s1 = g2+s2-1\\nSuppose d1 = g1+s1\\nAnd d1 = g2+s2\\nThen following condition should be satisfied for k median\\n1. d1 = d2 or d1-d2 = 0\\n2. d1 = d2-1 or d2-d1 = 1\\n\\nSo we are checking diff from right side (After k) and storing in map and checking from left side \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    int ans=0;\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int len = nums.size();\\n        int i=0;\\n        map<int,int> rightDiff;\\n        int diff=0;\\n        rightDiff[diff]++;\\n        for(i=0;i<len;i++) if(nums[i]==k) break;\\n        for(int j=i+1;j<len;j++){\\n            if(nums[j]>k) diff++;\\n            else diff--;\\n            rightDiff[diff]++;\\n        }\\n         diff =0;\\n         ans+=rightDiff[1-diff]; \\n         ans+=rightDiff[0-diff];\\n         \\n        for(int j=i-1;j>=0;j--){\\n            if(nums[j]>k) diff++;\\n            else diff --;\\n            ans+=rightDiff[1-diff];\\n            ans+=rightDiff[0-diff];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int len = nums.size();\\n        int i=0;\\n        map<int,int> rightDiff;\\n        int diff=0;\\n        rightDiff[diff]++;\\n        for(i=0;i<len;i++) if(nums[i]==k) break;\\n        for(int j=i+1;j<len;j++){\\n            if(nums[j]>k) diff++;\\n            else diff--;\\n            rightDiff[diff]++;\\n        }\\n         diff =0;\\n         ans+=rightDiff[1-diff]; \\n         ans+=rightDiff[0-diff];\\n         \\n        for(int j=i-1;j>=0;j--){\\n            if(nums[j]>k) diff++;\\n            else diff --;\\n            ans+=rightDiff[1-diff];\\n            ans+=rightDiff[0-diff];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947764,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        nums = [0] + nums\\n        index = nums.index(k)\\n        for i in range(1,len(nums)):\\n            if nums[i] < k:\\n                nums[i] = nums[i-1] - 1\\n            elif nums[i] >k:\\n                nums[i] = nums[i-1] + 1\\n            else: #nums[i] == k\\n                nums[i] = nums[i-1]\\n        counter = Counter()\\n        for i in range(0,index):\\n            counter[nums[i]] += 1\\n        for i in range(index,len(nums)):\\n            num = nums[i]\\n            res += counter[num] + counter[num-1]\\n        return res\\n```\\n\\nIt is important to convert the nums array to prefix sum array. Consider the median, we need to guarantee that the (number of values < k) == (number of values > k) or ((number of values < k) - 1) == (number of values > k)",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        nums = [0] + nums\\n        index = nums.index(k)\\n        for i in range(1,len(nums)):\\n            if nums[i] < k:\\n                nums[i] = nums[i-1] - 1\\n            elif nums[i] >k:\\n                nums[i] = nums[i-1] + 1\\n            else: #nums[i] == k\\n                nums[i] = nums[i-1]\\n        counter = Counter()\\n        for i in range(0,index):\\n            counter[nums[i]] += 1\\n        for i in range(index,len(nums)):\\n            num = nums[i]\\n            res += counter[num] + counter[num-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939674,
                "title": "simplest-solution-cpp-prefix-and-suffix-sum",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n**Step 1-** Find Index of k. let idx be index\\n**Step 2-** Make nums[idx]=0.\\n        insert it in hashmap.\\n    mark every element greater than k as 1 and less than k as -1.\\nmake prefix sum after idx and suffix sum before idx.\\nfor example,    nums=[7,1,3,4,2,5,6]\\nour new array be like nums=[-1,-2,-1,0,-1,0,-1]\\n**Step 3-** store the count of every element from new array after index idx in hashmap.\\n**Step 4-** now from index 0 to index idx find complement of element or complement of element + 1 in hashmap, if found add the count to our answer. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int idx=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        \\n        unordered_map<int, int>mp;\\n        int ans=0;\\n        nums[idx]=0;\\n        mp[nums[idx]]++;\\n        for(int i=idx+1;i<nums.size();i++){\\n           if(nums[i]>k){\\n               nums[i]=nums[i-1]+1;\\n           }\\n           else if(nums[i]<k){\\n               nums[i]=nums[i-1]-1;\\n           }\\n           mp[nums[i]]++;\\n          \\n        }\\n        for(int i=idx-1;i>=0;i--){\\n            if(nums[i]>k){\\n               nums[i]=nums[i+1]+1;\\n           }\\n           else if(nums[i]<k){\\n               nums[i]=nums[i+1]-1;\\n           }\\n          \\n        }\\n        for(int i=idx;i>=0;i--){\\n            if(mp.find(-1*nums[i])!=mp.end()){\\n                ans+=mp[-1*nums[i]];\\n            }\\n            if(mp.find(-1*nums[i]+1)!=mp.end()){\\n                ans+=mp[-1*nums[i]+1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int idx=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        \\n        unordered_map<int, int>mp;\\n        int ans=0;\\n        nums[idx]=0;\\n        mp[nums[idx]]++;\\n        for(int i=idx+1;i<nums.size();i++){\\n           if(nums[i]>k){\\n               nums[i]=nums[i-1]+1;\\n           }\\n           else if(nums[i]<k){\\n               nums[i]=nums[i-1]-1;\\n           }\\n           mp[nums[i]]++;\\n          \\n        }\\n        for(int i=idx-1;i>=0;i--){\\n            if(nums[i]>k){\\n               nums[i]=nums[i+1]+1;\\n           }\\n           else if(nums[i]<k){\\n               nums[i]=nums[i+1]-1;\\n           }\\n          \\n        }\\n        for(int i=idx;i>=0;i--){\\n            if(mp.find(-1*nums[i])!=mp.end()){\\n                ans+=mp[-1*nums[i]];\\n            }\\n            if(mp.find(-1*nums[i]+1)!=mp.end()){\\n                ans+=mp[-1*nums[i]+1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930216,
                "title": "c-o-n",
                "content": "# Approach\\nTransfer the original array _nums as nums\\n1. when _nums[i] == k, nums[i] = 0\\n2. when _nums[i] < k, nums[i] = -1\\n3. when _nums[i] > k, nums[i] = 1\\n\\nThen for a subarray with k as median, the sum of the subarray should has following pattern:\\n1. when subarray length is odd, array should be like [X X k X X], where X are random numbers. nums should be [-1 -1 0 1 1], the sum is 0\\n2. when subarray length is even, array should be like [X k X X], where X are random numbers. nums should be [-1 0 1 1], the sum is 1\\n\\nWe use two maps to record prefix sum for odd length and even length prefix arrays separately.\\nIterate the array, calculate prefix sum $presum$ at each position, and find $presum - 1$ in the even length prefix map and find $presum$ in the odd length prefix map.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& _nums, int k) {\\n        int len = _nums.size();\\n        vector<int> nums(len);\\n        for (int i = 0; i < len; ++i) {\\n            if (_nums[i] == k) {\\n                nums[i] = 0;\\n                continue;\\n            }\\n            nums[i] = (_nums[i] - k) / abs(_nums[i] - k);\\n        }\\n        // [even, odd]\\n        array<unordered_map<int, int>, 2> pre;\\n        int presum = 0;\\n        ++pre[0][presum];\\n        int cur = 1;\\n        int cnt = 0;\\n        for (int i = 0; i < len; ++i) {\\n            presum += nums[i];\\n            cnt += pre[cur][presum - 1];\\n            cnt += pre[cur ^ 1][presum];\\n            ++pre[cur][presum];\\n            cur ^= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& _nums, int k) {\\n        int len = _nums.size();\\n        vector<int> nums(len);\\n        for (int i = 0; i < len; ++i) {\\n            if (_nums[i] == k) {\\n                nums[i] = 0;\\n                continue;\\n            }\\n            nums[i] = (_nums[i] - k) / abs(_nums[i] - k);\\n        }\\n        // [even, odd]\\n        array<unordered_map<int, int>, 2> pre;\\n        int presum = 0;\\n        ++pre[0][presum];\\n        int cur = 1;\\n        int cnt = 0;\\n        for (int i = 0; i < len; ++i) {\\n            presum += nums[i];\\n            cnt += pre[cur][presum - 1];\\n            cnt += pre[cur ^ 1][presum];\\n            ++pre[cur][presum];\\n            cur ^= 1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927808,
                "title": "python-counter-o-n",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        i = nums.index(k)\\n        lcounter = Counter()\\n        cursum = 0\\n        lcounter[0] = 1\\n        for j in range(i-1,-1,-1):\\n            cursum += -1 if nums[j] < k else 1\\n            lcounter[cursum] += 1\\n        res = lcounter[0] + lcounter[1]\\n        cursum = 0\\n        for j in range(i+1,n):\\n            cursum += 1 if nums[j] > k else -1\\n            res += lcounter[-cursum] + lcounter[-cursum+1]\\n        return res        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        i = nums.index(k)\\n        lcounter = Counter()\\n        cursum = 0\\n        lcounter[0] = 1\\n        for j in range(i-1,-1,-1):\\n            cursum += -1 if nums[j] < k else 1\\n            lcounter[cursum] += 1\\n        res = lcounter[0] + lcounter[1]\\n        cursum = 0\\n        for j in range(i+1,n):\\n            cursum += 1 if nums[j] > k else -1\\n            res += lcounter[-cursum] + lcounter[-cursum+1]\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923211,
                "title": "python-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        idx = -1\\n        for i, num in enumerate(nums):\\n            if num == k:\\n                idx = i\\n                break\\n        \\n        def default_value():\\n            return [0, 0]\\n        \\n        count = 1\\n        right_dict = defaultdict(default_value)\\n        sum_count = 0\\n        for i in range(idx+1, len(nums)):\\n            sum_count += 1 if nums[i] > k else -1\\n            right_dict[sum_count][(i-idx) % 2] += 1\\n            if sum_count == 0:\\n                count += 1\\n            if sum_count == 1 and (i-idx) % 2 == 1:\\n                count += 1\\n        \\n        sum_count = 0\\n        for i in range(idx-1, -1, -1):\\n            sum_count += 1 if nums[i] > k else -1\\n            count += right_dict[-sum_count][0] + right_dict[-sum_count][1]\\n            count += right_dict[1-sum_count][1] if (idx-i) % 2 == 0 else right_dict[1-sum_count][0]\\n            if sum_count == 0:\\n                count += 1\\n            if sum_count == 1 and (idx-i) % 2 == 1:\\n                count += 1\\n        \\n        return count\\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSubarrays(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        idx = -1\\n        for i, num in enumerate(nums):\\n            if num == k:\\n                idx = i\\n                break\\n        \\n        def default_value():\\n            return [0, 0]\\n        \\n        count = 1\\n        right_dict = defaultdict(default_value)\\n        sum_count = 0\\n        for i in range(idx+1, len(nums)):\\n            sum_count += 1 if nums[i] > k else -1\\n            right_dict[sum_count][(i-idx) % 2] += 1\\n            if sum_count == 0:\\n                count += 1\\n            if sum_count == 1 and (i-idx) % 2 == 1:\\n                count += 1\\n        \\n        sum_count = 0\\n        for i in range(idx-1, -1, -1):\\n            sum_count += 1 if nums[i] > k else -1\\n            count += right_dict[-sum_count][0] + right_dict[-sum_count][1]\\n            count += right_dict[1-sum_count][1] if (idx-i) % 2 == 0 else right_dict[1-sum_count][0]\\n            if sum_count == 0:\\n                count += 1\\n            if sum_count == 1 and (idx-i) % 2 == 1:\\n                count += 1\\n        \\n        return count\\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886193,
                "title": "simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, n: List[int], k: int) -> int:\\n        cou = Counter()\\n        cou[0] = 1\\n\\n        pre = 0\\n        i = 0\\n        while n[i] != k:\\n            if n[i] < k:\\n                pre += -1\\n            else:\\n                pre += 1\\n            cou[pre] += 1\\n            i += 1\\n\\n        res = 0\\n        for j in range(i , len(n)):\\n            if n[j] < k:\\n                pre += -1\\n            elif n[j] > k:\\n                pre += 1\\n            res += (cou[pre] + cou[pre - 1])\\n        \\n        return res\\n                \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, n: List[int], k: int) -> int:\\n        cou = Counter()\\n        cou[0] = 1\\n\\n        pre = 0\\n        i = 0\\n        while n[i] != k:\\n            if n[i] < k:\\n                pre += -1\\n            else:\\n                pre += 1\\n            cou[pre] += 1\\n            i += 1\\n\\n        res = 0\\n        for j in range(i , len(n)):\\n            if n[j] < k:\\n                pre += -1\\n            elif n[j] > k:\\n                pre += 1\\n            res += (cou[pre] + cou[pre - 1])\\n        \\n        return res\\n                \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884175,
                "title": "c-prefix-suffix-count-of-elements-greater-lesser-than-k-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int idx=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==k) {idx=i;break;}\\n        }\\n        if(idx==-1) return 0;\\n        vector<int>lower(n,0),higher(n,0);\\n        for(int i=idx-1;i>=0;i--){\\n            lower[i]=lower[i+1];\\n            higher[i]=higher[i+1];\\n            if(nums[i]<k) lower[i]=lower[i+1]+1;\\n            else higher[i]=higher[i+1]+1;\\n        }\\n        for(int i=idx+1;i<n;i++){\\n            lower[i]=lower[i-1];\\n            higher[i]=higher[i-1];\\n            if(nums[i]<k) lower[i]=lower[i-1]+1;\\n            else higher[i]=higher[i-1]+1;\\n        }\\n        int cnt=1;\\n        //subarrays to the right with idx as left end\\n        for(int i=idx+1;i<n;i++){\\n            if(i%2!=idx%2&&higher[i]==1+lower[i]) cnt++;\\n            else if(i%2==idx%2&&higher[i]==lower[i]) cnt++;\\n        }\\n        //subarrays to the left with idx as right end\\n        for(int i=idx-1;i>=0;i--){\\n            if(i%2!=idx%2&&higher[i]==1+lower[i]) cnt++;\\n            else if(i%2==idx%2&&higher[i]==lower[i]) cnt++;\\n        }\\n        //subarrays having idx as an intermediate index\\n        unordered_map<int,int>even,odd;\\n        for(int i=idx+1;i<n;i++){\\n            if(i%2) odd[higher[i]-lower[i]]++;\\n            else even[higher[i]-lower[i]]++;\\n        }\\n        for(int i=0;i<idx;i++){\\n            if(i&1){\\n                //even length subarrays\\n                cnt+=even[-higher[i]+lower[i]+1];\\n                //odd length subarrays\\n                cnt+=odd[-higher[i]+lower[i]];\\n            }\\n            else{\\n                //even length subarrays\\n                cnt+=odd[-higher[i]+lower[i]+1];\\n                //odd length subarrays\\n                cnt+=even[-higher[i]+lower[i]];\\n            }\\n        }\\n        return cnt;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int idx=-1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==k) {idx=i;break;}\\n        }\\n        if(idx==-1) return 0;\\n        vector<int>lower(n,0),higher(n,0);\\n        for(int i=idx-1;i>=0;i--){\\n            lower[i]=lower[i+1];\\n            higher[i]=higher[i+1];\\n            if(nums[i]<k) lower[i]=lower[i+1]+1;\\n            else higher[i]=higher[i+1]+1;\\n        }\\n        for(int i=idx+1;i<n;i++){\\n            lower[i]=lower[i-1];\\n            higher[i]=higher[i-1];\\n            if(nums[i]<k) lower[i]=lower[i-1]+1;\\n            else higher[i]=higher[i-1]+1;\\n        }\\n        int cnt=1;\\n        //subarrays to the right with idx as left end\\n        for(int i=idx+1;i<n;i++){\\n            if(i%2!=idx%2&&higher[i]==1+lower[i]) cnt++;\\n            else if(i%2==idx%2&&higher[i]==lower[i]) cnt++;\\n        }\\n        //subarrays to the left with idx as right end\\n        for(int i=idx-1;i>=0;i--){\\n            if(i%2!=idx%2&&higher[i]==1+lower[i]) cnt++;\\n            else if(i%2==idx%2&&higher[i]==lower[i]) cnt++;\\n        }\\n        //subarrays having idx as an intermediate index\\n        unordered_map<int,int>even,odd;\\n        for(int i=idx+1;i<n;i++){\\n            if(i%2) odd[higher[i]-lower[i]]++;\\n            else even[higher[i]-lower[i]]++;\\n        }\\n        for(int i=0;i<idx;i++){\\n            if(i&1){\\n                //even length subarrays\\n                cnt+=even[-higher[i]+lower[i]+1];\\n                //odd length subarrays\\n                cnt+=odd[-higher[i]+lower[i]];\\n            }\\n            else{\\n                //even length subarrays\\n                cnt+=odd[-higher[i]+lower[i]+1];\\n                //odd length subarrays\\n                cnt+=even[-higher[i]+lower[i]];\\n            }\\n        }\\n        return cnt;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882879,
                "title": "c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefixSum\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGiven a subarray A: \\nWe have 2 types of numbers:\\n1. A[i]<=k  -> -1\\n2. A[i]>k   ->  1\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        vector<int> numsMod, prefixSum(nums.size()+1, 0);\\n        unordered_map<int,int> m;\\n        int index=0, kIndex=0;\\n        for(auto &i: nums){\\n            index++;\\n            if(i<=k){\\n                numsMod.push_back(-1);\\n            }\\n            else{\\n                numsMod.push_back(1);\\n            }\\n            if(i==k)\\n                kIndex=index;\\n        }\\n        // cout<<kIndex<<endl;\\n        for(int i=1;i<prefixSum.size();i++){\\n            prefixSum[i]=prefixSum[i-1]+numsMod[i-1];\\n        }\\n        \\n        for(int i=1;i<prefixSum.size();i++){\\n            // cout<<prefixSum[i]<<\" \";\\n            if(i>=kIndex)\\n                m[prefixSum[i]]++;\\n        }\\n        // cout<<endl;\\n        // for(auto &i: m){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        int ans=0;\\n        for(int i=1;i<=kIndex;i++){\\n            if(i>=kIndex)\\n                m[prefixSum[i]]--;\\n            if(i<=kIndex+1){\\n                if(nums[i-1]<=k){\\n                    // cout<<\" \"<<prefixSum[i]<<\" \"<<m[prefixSum[i]]<<\" \"<<m[prefixSum[i]+1]<<endl;\\n                    ans+=m[prefixSum[i]];\\n                    ans+=m[prefixSum[i]+1];\\n                }\\n                else{\\n                    ans+=m[prefixSum[i]-1];\\n                    ans+=m[prefixSum[i]-2];\\n                }\\n                    \\n            }\\n            \\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        vector<int> numsMod, prefixSum(nums.size()+1, 0);\\n        unordered_map<int,int> m;\\n        int index=0, kIndex=0;\\n        for(auto &i: nums){\\n            index++;\\n            if(i<=k){\\n                numsMod.push_back(-1);\\n            }\\n            else{\\n                numsMod.push_back(1);\\n            }\\n            if(i==k)\\n                kIndex=index;\\n        }\\n        // cout<<kIndex<<endl;\\n        for(int i=1;i<prefixSum.size();i++){\\n            prefixSum[i]=prefixSum[i-1]+numsMod[i-1];\\n        }\\n        \\n        for(int i=1;i<prefixSum.size();i++){\\n            // cout<<prefixSum[i]<<\" \";\\n            if(i>=kIndex)\\n                m[prefixSum[i]]++;\\n        }\\n        // cout<<endl;\\n        // for(auto &i: m){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        int ans=0;\\n        for(int i=1;i<=kIndex;i++){\\n            if(i>=kIndex)\\n                m[prefixSum[i]]--;\\n            if(i<=kIndex+1){\\n                if(nums[i-1]<=k){\\n                    // cout<<\" \"<<prefixSum[i]<<\" \"<<m[prefixSum[i]]<<\" \"<<m[prefixSum[i]+1]<<endl;\\n                    ans+=m[prefixSum[i]];\\n                    ans+=m[prefixSum[i]+1];\\n                }\\n                else{\\n                    ans+=m[prefixSum[i]-1];\\n                    ans+=m[prefixSum[i]-2];\\n                }\\n                    \\n            }\\n            \\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2879603,
                "title": "java-clear-and-concise-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        /*\\n            if meet the larger integer, += 1;\\n            if meet the smaller integer, -= 1;\\n        */\\n\\n        /* find the index of k */\\n        int indexK = -1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == k) {\\n                indexK = i;\\n                break;\\n            }\\n        }\\n\\n        /* find the number of subarrays that ending at k */\\n        int prevSum = 0, leftAns = 0;\\n        Map<Integer, Integer> leftMap = new HashMap<>(); // left sum so far, index\\n        for (int i = indexK - 1; i >= 0; --i) {\\n            if (nums[i] < k) {\\n                prevSum -= 1;\\n            } else {\\n                prevSum += 1;\\n            }\\n            leftMap.put(prevSum, leftMap.getOrDefault(prevSum, 0) + 1);\\n            if (prevSum == 0 || prevSum == 1) leftAns += 1;\\n        }\\n\\n        /* find the number of subarrays that starting at k */\\n        int postSum = 0, rightAns = 0;\\n        Map<Integer, Integer> rightMap = new HashMap<>(); // right sum so far, index\\n        for (int i = indexK + 1; i < nums.length; ++i) {\\n            if (nums[i] < k) {\\n                postSum -= 1;\\n            } else {\\n                postSum += 1;\\n            }\\n            rightMap.put(postSum, rightMap.getOrDefault(postSum, 0) + 1);\\n            if (postSum == 0 || postSum == 1) rightAns += 1;\\n        }\\n\\n        /* find the number of subarrays that k is not at the border */\\n        int centralAns = 0;\\n        for (Map.Entry<Integer, Integer> entry : rightMap.entrySet()) {\\n            int val = entry.getKey();\\n            // we need to consider k as the middle element and left middle element situations\\n            int compTimes = leftMap.getOrDefault(0 - val, 0) + leftMap.getOrDefault(1 - val, 0);\\n            \\n            centralAns += entry.getValue() * compTimes;\\n        }\\n\\n        // note: we need to add itself at the end\\n        int ans = leftAns + centralAns + rightAns + 1;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        /*\\n            if meet the larger integer, += 1;\\n            if meet the smaller integer, -= 1;\\n        */\\n\\n        /* find the index of k */\\n        int indexK = -1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == k) {\\n                indexK = i;\\n                break;\\n            }\\n        }\\n\\n        /* find the number of subarrays that ending at k */\\n        int prevSum = 0, leftAns = 0;\\n        Map<Integer, Integer> leftMap = new HashMap<>(); // left sum so far, index\\n        for (int i = indexK - 1; i >= 0; --i) {\\n            if (nums[i] < k) {\\n                prevSum -= 1;\\n            } else {\\n                prevSum += 1;\\n            }\\n            leftMap.put(prevSum, leftMap.getOrDefault(prevSum, 0) + 1);\\n            if (prevSum == 0 || prevSum == 1) leftAns += 1;\\n        }\\n\\n        /* find the number of subarrays that starting at k */\\n        int postSum = 0, rightAns = 0;\\n        Map<Integer, Integer> rightMap = new HashMap<>(); // right sum so far, index\\n        for (int i = indexK + 1; i < nums.length; ++i) {\\n            if (nums[i] < k) {\\n                postSum -= 1;\\n            } else {\\n                postSum += 1;\\n            }\\n            rightMap.put(postSum, rightMap.getOrDefault(postSum, 0) + 1);\\n            if (postSum == 0 || postSum == 1) rightAns += 1;\\n        }\\n\\n        /* find the number of subarrays that k is not at the border */\\n        int centralAns = 0;\\n        for (Map.Entry<Integer, Integer> entry : rightMap.entrySet()) {\\n            int val = entry.getKey();\\n            // we need to consider k as the middle element and left middle element situations\\n            int compTimes = leftMap.getOrDefault(0 - val, 0) + leftMap.getOrDefault(1 - val, 0);\\n            \\n            centralAns += entry.getValue() * compTimes;\\n        }\\n\\n        // note: we need to add itself at the end\\n        int ans = leftAns + centralAns + rightAns + 1;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876699,
                "title": "java-map-prefixsum-o-n-simple-solution",
                "content": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefSumGreaterElement = new int[n];\\n        int[] prefSumSmallestElemet = new int[n];\\n        prefSumSmallestElemet[0] = nums[0] < k ? 1 : 0;\\n        prefSumGreaterElement[0] = nums[0] > k ? 1 : 0;\\n        for (int i = 1; i < n; i++) {\\n            prefSumGreaterElement[i] = nums[i] > k ? 1 + prefSumGreaterElement[i - 1] : prefSumGreaterElement[i - 1];\\n            prefSumSmallestElemet[i] = nums[i] < k ? 1 + prefSumSmallestElemet[i - 1] : prefSumSmallestElemet[i - 1];\\n        }\\n\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int ans = 0;\\n        boolean isKthReached = false;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                isKthReached = true;\\n            }\\n            if (isKthReached) {\\n                int diff = prefSumGreaterElement[i] - prefSumSmallestElemet[i];\\n                if (diff == 0 || diff == 1) {\\n                    ans++;\\n                }\\n                ans += count.getOrDefault(diff, 0);\\n                ans += count.getOrDefault(diff - 1, 0);\\n            } else {\\n                count.put(prefSumGreaterElement[i] - prefSumSmallestElemet[i],\\n                        count.getOrDefault(prefSumGreaterElement[i] - prefSumSmallestElemet[i], 0) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefSumGreaterElement = new int[n];\\n        int[] prefSumSmallestElemet = new int[n];\\n        prefSumSmallestElemet[0] = nums[0] < k ? 1 : 0;\\n        prefSumGreaterElement[0] = nums[0] > k ? 1 : 0;\\n        for (int i = 1; i < n; i++) {\\n            prefSumGreaterElement[i] = nums[i] > k ? 1 + prefSumGreaterElement[i - 1] : prefSumGreaterElement[i - 1];\\n            prefSumSmallestElemet[i] = nums[i] < k ? 1 + prefSumSmallestElemet[i - 1] : prefSumSmallestElemet[i - 1];\\n        }\\n\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int ans = 0;\\n        boolean isKthReached = false;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                isKthReached = true;\\n            }\\n            if (isKthReached) {\\n                int diff = prefSumGreaterElement[i] - prefSumSmallestElemet[i];\\n                if (diff == 0 || diff == 1) {\\n                    ans++;\\n                }\\n                ans += count.getOrDefault(diff, 0);\\n                ans += count.getOrDefault(diff - 1, 0);\\n            } else {\\n                count.put(prefSumGreaterElement[i] - prefSumSmallestElemet[i],\\n                        count.getOrDefault(prefSumGreaterElement[i] - prefSumSmallestElemet[i], 0) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873277,
                "title": "c-python-prefix-sum-map-explained",
                "content": "First find index where k lies.\\nNow create prefix sum on both sides of index seperately.Our prefix sum denotes number of numbers greater than k and less than k on each side of index.\\nNow our taks is simplifed to finding 2 numbers x && y, such that x+y==0 or x+y==1 such that we have k in our subarray, which means we need to solve for full array subtract left side and right side.Finally add 1 for the single element k as the answer.\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N)\\n\\nC++ Code :\\n\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector <int> &arr){\\n        map <int,int> cnt;\\n        long long ans=0;\\n        // find two nos x && y such that x+y==0 or x+y==1\\n        for (auto x:arr) ans+=cnt[-x]+cnt[1-x],cnt[x]++;\\n        return ans;\\n    }\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector <int> pre_sum(n,0);\\n        int idx;\\n        for (int i=0;i<n;i++){\\n            if (nums[i]==k) { \\n                idx=i;\\n                break;\\n            }\\n        }\\n        for (int i=idx+1;i<n;i++) pre_sum[i]=pre_sum[i-1]+((nums[i]>k)?1:-1);\\n        for (int i=idx-1;i>=0;i--) pre_sum[i]=pre_sum[i+1]+((nums[i]>k)?1:-1);\\n        vector <int> B,C;\\n        for (int i=0;i<n;i++) {\\n            if (i<idx) B.push_back(pre_sum[i]);\\n            else if (i>idx) C.push_back(pre_sum[i]);\\n        }\\n        return solve(pre_sum)-solve(B)-solve(C)+1;\\n    }\\n};\\n```\\n\\nPython Code:\\n\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        pre_sum=[0]*n\\n        idx=nums.index(k)\\n        for i in range(idx+1,n):\\n            pre_sum[i]=pre_sum[i-1]+(1 if nums[i]>k else -1)\\n        for i in range(idx-1,-1,-1):\\n            pre_sum[i]=pre_sum[i+1]+(1 if nums[i]>k else -1)\\n        def solve(arr):\\n            #find two nos x && y such that x+y==0 or x+y==1\\n            ans=0\\n            cnt=defaultdict(int)\\n            for x in arr:\\n                ans+=cnt[-x]+cnt[1-x]\\n                cnt[x]+=1\\n            return ans\\n        return solve(pre_sum)-solve(pre_sum[:idx])-solve(pre_sum[idx+1:])+1\\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector <int> &arr){\\n        map <int,int> cnt;\\n        long long ans=0;\\n        // find two nos x && y such that x+y==0 or x+y==1\\n        for (auto x:arr) ans+=cnt[-x]+cnt[1-x],cnt[x]++;\\n        return ans;\\n    }\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector <int> pre_sum(n,0);\\n        int idx;\\n        for (int i=0;i<n;i++){\\n            if (nums[i]==k) { \\n                idx=i;\\n                break;\\n            }\\n        }\\n        for (int i=idx+1;i<n;i++) pre_sum[i]=pre_sum[i-1]+((nums[i]>k)?1:-1);\\n        for (int i=idx-1;i>=0;i--) pre_sum[i]=pre_sum[i+1]+((nums[i]>k)?1:-1);\\n        vector <int> B,C;\\n        for (int i=0;i<n;i++) {\\n            if (i<idx) B.push_back(pre_sum[i]);\\n            else if (i>idx) C.push_back(pre_sum[i]);\\n        }\\n        return solve(pre_sum)-solve(B)-solve(C)+1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        pre_sum=[0]*n\\n        idx=nums.index(k)\\n        for i in range(idx+1,n):\\n            pre_sum[i]=pre_sum[i-1]+(1 if nums[i]>k else -1)\\n        for i in range(idx-1,-1,-1):\\n            pre_sum[i]=pre_sum[i+1]+(1 if nums[i]>k else -1)\\n        def solve(arr):\\n            #find two nos x && y such that x+y==0 or x+y==1\\n            ans=0\\n            cnt=defaultdict(int)\\n            for x in arr:\\n                ans+=cnt[-x]+cnt[1-x]\\n                cnt[x]+=1\\n            return ans\\n        return solve(pre_sum)-solve(pre_sum[:idx])-solve(pre_sum[idx+1:])+1\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873152,
                "title": "detailed-explanation-with-example-in-the-comments-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& arr, int k) {\\n        \\n        \\n        int sum = 0;\\n        \\n        int n = arr.size();\\n        int prefix[n];\\n        \\n        map<int , int> mp;\\n        \\n        for(int i = 0 ; i < n ; i ++  ) {\\n            \\n            if(arr[i] > k ) {\\n                prefix[i] = 1;\\n            }\\n            else if( arr[i] < k ) {\\n                prefix[i] = -1;\\n            }\\n            else\\n            {\\n                prefix[i] = 0;\\n            }\\n            \\n            if(i > 0 ) {\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n        \\n        int kpos = -1;\\n        \\n        for(int i = 0 ; i < n ; i ++ ) {\\n            if(arr[i] == k) {\\n                kpos = i ;\\n            }\\n        }\\n        \\n        \\n        for(int i = kpos ; i < n ; i ++ ) {\\n            mp[prefix[i]] ++;\\n        }\\n        \\n        /*\\n        \\n            I will use an example to show what i did to solve this question \\n            \\n            let the give array be as follows\\n            k = 4 (median)\\n            if an element in the array is greater then 4 , then use +1 , if lesser than -1 , if equal then 0 \\n            arr -> [3 , 7 , 2 , 1 , 4 , 6 , 5]\\n            p   -> [-1, 1, -1, -1 , 0 , 1 , 1]\\n          prefix-> [-1, 0, -1, -2, -2, -1 , 0]\\n          \\n          \\n            Now all those subarrays which will have p[i , ..... , j] -> 0 \\n            \\n            subarray sum = 0 // -> no of smaller and larger elements than k is equal \\n            subarray sum = 1 // -> no of elements larger - no of elements smaller  = 1 \\n            \\n            no we have to ensure that the subarray has k itself in it the array \\n            \\n            \\n            hence we will maintain a hashmap \\n            \\n            where we will store sum from kpos -> {position where k is present in the array } \\n            \\n            mp[prefix[kpos]] ++\\n            mp[prefix[kpos + 1]]++\\n            .\\n            .\\n            .\\n            mp[prefix[n - 1]]\\n            \\n            this means at the moment we have sum stored \\n            \\n            p[0] ..... p[kpos] , p[0] .... p[kpos + 1] , p[0] .... p[n - 1] \\n            \\n            \\n            so now we will check for the subarray starting at 0 \\n            \\n            sum += mp[0] // how many subarray from kpos position which have { no of elements smaller = no of elements larger}\\n            sum += mp[1] // how many subarray from kpos position which have {no of elements larger - no of elements smaller = 1 }\\n            \\n            all this subarrrays will have the median element  mind you \\n            \\n            \\n            \\n            for any subarray starting from i \\n            \\n            \\n            sum += mp[prefix[i - 1]] -> because for any subarray we will be subtracting  -prefix[i - 1] from it \\n            sum += mp[prefix[i  - 1] + 1 ] -> because after subtracting if we have 1 , for even length median subarray case \\n            \\n            \\n            and we will make our subarray start point go till upto kpos only \\n            \\n        */\\n        \\n        \\n        for(int i = 0 ; i <= kpos ; i ++ ) {\\n            \\n            if(i == 0 ) {\\n                sum += mp[0];  // for odd length median subarrays\\n                sum += mp[1]; // for even length median subarrays\\n            }\\n            else\\n            {\\n                sum += mp[prefix[i - 1]]; // for odd length subarrays\\n                sum += mp[prefix[i - 1] + 1]; // for even length subarrays \\n            }\\n        }\\n        \\n        return sum;\\n        \\n     }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countSubarrays(vector<int>& arr, int k) {\\n        \\n        \\n        int sum = 0;\\n        \\n        int n = arr.size();\\n        int prefix[n];\\n        \\n        map<int , int> mp;\\n        \\n        for(int i = 0 ; i < n ; i ++  ) {\\n            \\n            if(arr[i] > k ) {\\n                prefix[i] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2873096,
                "title": "java-prefix-array-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        \\n        int idx, n = nums.length, ans = 0;\\n        \\n        for(idx=0; idx<n; idx++)\\n            if(nums[idx] == k) break; // getting the idx for k\\n        \\n        int arr[][] = new int[n-idx][2]; // smaller v greater\\n        for(int i=idx+1, j=1; i<n; i++){\\n            if(nums[i] < k){\\n                arr[j][0] = arr[j-1][0] +1; // s++\\n                arr[j][1] = arr[j-1][1];    // g retains\\n            }\\n            else{\\n                arr[j][1] = arr[j-1][1] +1; // g++\\n                arr[j][0] = arr[j-1][0];    // s retains\\n            }\\n            j++;\\n        }\\n                \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++){\\n            int d2 = arr[i][1] - arr[i][0]; // g2 - s2\\n            map.put(d2, map.getOrDefault(d2, 0) +1);\\n        }\\n        \\n        int s1 = 0, g1 = 0;\\n        for(int i=idx; i>=0; i--){ // maintain cur g1 & s1 from idx to 0 and check\\n            if(nums[i] < k) s1++;\\n            else if(nums[i] > k) g1++;\\n            \\n            int d1 = g1 - s1; \\n            int cur = map.getOrDefault(0-d1, 0) + map.getOrDefault(1-d1, 0);\\n            \\n            ans += cur;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n/*\\nObservation:\\n    * g == s; OR (g - s) == 0; // towards both left n right side of the idx i.e in the subarray.\\n    * g == (s+1); OR (g - s) == 1; // towards both left n right side of the idx i.e in the subarray.\\n    * So, (g1+g2) - (s1+s2) == 0 / 1;\\n      OR\\n      (g1-s1) + (g2-s2) == 0 / 1;\\n      OR\\n      d1 + d2 == 0; Also, d1 + d2 == 1;\\n    * Therefore, we can pre-compute the d2\\'s frequencies from the right to the idx and store them in a map.\\n    * Then traverse from left to right and check for current d1 for the corresponding sum to be 0 or 1.\\n    * Hence, find 0-d1 for 0 & 1-d1 for 1 in the map.\\t\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        \\n        int idx, n = nums.length, ans = 0;\\n        \\n        for(idx=0; idx<n; idx++)\\n            if(nums[idx] == k) break; // getting the idx for k\\n        \\n        int arr[][] = new int[n-idx][2]; // smaller v greater\\n        for(int i=idx+1, j=1; i<n; i++){\\n            if(nums[i] < k){\\n                arr[j][0] = arr[j-1][0] +1; // s++\\n                arr[j][1] = arr[j-1][1];    // g retains\\n            }\\n            else{\\n                arr[j][1] = arr[j-1][1] +1; // g++\\n                arr[j][0] = arr[j-1][0];    // s retains\\n            }\\n            j++;\\n        }\\n                \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0; i<arr.length; i++){\\n            int d2 = arr[i][1] - arr[i][0]; // g2 - s2\\n            map.put(d2, map.getOrDefault(d2, 0) +1);\\n        }\\n        \\n        int s1 = 0, g1 = 0;\\n        for(int i=idx; i>=0; i--){ // maintain cur g1 & s1 from idx to 0 and check\\n            if(nums[i] < k) s1++;\\n            else if(nums[i] > k) g1++;\\n            \\n            int d1 = g1 - s1; \\n            int cur = map.getOrDefault(0-d1, 0) + map.getOrDefault(1-d1, 0);\\n            \\n            ans += cur;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n/*\\nObservation:\\n    * g == s; OR (g - s) == 0; // towards both left n right side of the idx i.e in the subarray.\\n    * g == (s+1); OR (g - s) == 1; // towards both left n right side of the idx i.e in the subarray.\\n    * So, (g1+g2) - (s1+s2) == 0 / 1;\\n      OR\\n      (g1-s1) + (g2-s2) == 0 / 1;\\n      OR\\n      d1 + d2 == 0; Also, d1 + d2 == 1;\\n    * Therefore, we can pre-compute the d2\\'s frequencies from the right to the idx and store them in a map.\\n    * Then traverse from left to right and check for current d1 for the corresponding sum to be 0 or 1.\\n    * Hence, find 0-d1 for 0 & 1-d1 for 1 in the map.\\t\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872616,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int ind = -1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] < k)\\n                nums[i] = -1;\\n            else if(nums[i] > k)\\n                nums[i] = 1;\\n            else{\\n                nums[i] = 0;\\n                ind = i;   \\n            }            \\n        }\\n        \\n        int[] prefixSum = new int[nums.length+1];\\n        for(int i=1; i<prefixSum.length; i++){\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n        }\\n        \\n        int left = helper(0, ind, prefixSum);\\n        int right = helper(ind+1, nums.length, prefixSum);\\n        int total = helper(0, nums.length, prefixSum);\\n        \\n        return total - left - right;\\n    }\\n    \\n    int helper(int l, int r, int[] prefixSum){\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int ans = 0;\\n        for(int i=l; i<=r; i++){\\n            int currSum = prefixSum[i];\\n            if(map.containsKey(currSum))\\n                ans += map.get(currSum);\\n            if(map.containsKey(currSum-1))\\n                ans += map.get(currSum-1);\\n            map.put(currSum, map.getOrDefault(currSum, 0) + 1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int ind = -1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] < k)\\n                nums[i] = -1;\\n            else if(nums[i] > k)\\n                nums[i] = 1;\\n            else{\\n                nums[i] = 0;\\n                ind = i;   \\n            }            \\n        }\\n        \\n        int[] prefixSum = new int[nums.length+1];\\n        for(int i=1; i<prefixSum.length; i++){\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n        }\\n        \\n        int left = helper(0, ind, prefixSum);\\n        int right = helper(ind+1, nums.length, prefixSum);\\n        int total = helper(0, nums.length, prefixSum);\\n        \\n        return total - left - right;\\n    }\\n    \\n    int helper(int l, int r, int[] prefixSum){\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int ans = 0;\\n        for(int i=l; i<=r; i++){\\n            int currSum = prefixSum[i];\\n            if(map.containsKey(currSum))\\n                ans += map.get(currSum);\\n            if(map.containsKey(currSum-1))\\n                ans += map.get(currSum-1);\\n            map.put(currSum, map.getOrDefault(currSum, 0) + 1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872088,
                "title": "c-solution",
                "content": "```\\nint countSubarrays(int* nums, int numsSize, int k){\\n    int at;\\n    int appear[200000] = {0};\\n    int count = 0;\\n    int ans = 1;\\n    for (int i = 0 ; i < numsSize ; i++){\\n        if (nums[i] == k) {\\n            appear[100000] = 1;\\n            at = i;\\n            i++;\\n            while (i < numsSize){\\n                if (nums[i] > k){\\n                    count++;\\n                } else {\\n                    count--;\\n                }\\n                if (count == 1 || count == 0){\\n                    ans++;\\n                }\\n                appear[count+100000]++;\\n                i++;\\n            }\\n        }\\n    }\\n    count = 0;\\n    for (int i = at-1 ; i >= 0 ; i--){\\n        if (nums[i] > k){\\n            count++;\\n        } else if (nums[i] < k){\\n            count--;\\n        }\\n        ans += appear[0-count+100000];\\n        ans += appear[1-count+100000];\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countSubarrays(int* nums, int numsSize, int k){\\n    int at;\\n    int appear[200000] = {0};\\n    int count = 0;\\n    int ans = 1;\\n    for (int i = 0 ; i < numsSize ; i++){\\n        if (nums[i] == k) {\\n            appear[100000] = 1;\\n            at = i;\\n            i++;\\n            while (i < numsSize){\\n                if (nums[i] > k){\\n                    count++;\\n                } else {\\n                    count--;\\n                }\\n                if (count == 1 || count == 0){\\n                    ans++;\\n                }\\n                appear[count+100000]++;\\n                i++;\\n            }\\n        }\\n    }\\n    count = 0;\\n    for (int i = at-1 ; i >= 0 ; i--){\\n        if (nums[i] > k){\\n            count++;\\n        } else if (nums[i] < k){\\n            count--;\\n        }\\n        ans += appear[0-count+100000];\\n        ans += appear[1-count+100000];\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2871129,
                "title": "rust-y",
                "content": "Beats 71%.\\n\\n# Code\\n```\\nuse std::cmp::max;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn count_subarrays(mut nums: Vec<i32>, mut k: i32) -> i32 {\\n        let mut ind: usize = 0;\\n        for (i, x) in nums.iter().enumerate() {\\n            if *x == k {\\n                ind = i;\\n            }\\n        }\\n        let mut dif: Vec<i32> = vec![0; nums.len()];\\n        for (i, x) in nums.iter().enumerate() {\\n            if i > ind {\\n                dif[i] = dif[i - 1];\\n                if *x > k {\\n                    dif[i] += 1;\\n                } else {\\n                    dif[i] -= 1;\\n                }\\n            }\\n        }\\n        let mut index: i32 = nums.len() as i32;\\n        for (i, x) in nums.iter().rev().enumerate() {\\n            index -= 1;\\n            if index < ind as i32 {\\n                dif[index as usize] = dif[(index + 1) as usize];\\n                if *x > k {\\n                    dif[index as usize] += 1;\\n                } else {\\n                    dif[index as usize] -= 1;\\n                }\\n            }\\n        }\\n        let mut ans: i32 = 0;\\n        let mut hm: HashMap<i32, i32> = HashMap::new();\\n        for (i, x) in dif.iter().enumerate() {\\n            if i >= ind {\\n                ans += hm.get(&(-*x)).unwrap_or(&0) + hm.get(&(-*x + 1)).unwrap_or(&0);\\n            }\\n            if i <= ind {\\n                if hm.contains_key(x) {\\n                    if let Some(val) = hm.get_mut(x) {\\n                        *val = *val + 1;\\n                    }\\n                } else {\\n                    hm.insert(*x, 1);\\n                }\\n            }\\n        }\\n        return ans as i32 + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn count_subarrays(mut nums: Vec<i32>, mut k: i32) -> i32 {\\n        let mut ind: usize = 0;\\n        for (i, x) in nums.iter().enumerate() {\\n            if *x == k {\\n                ind = i;\\n            }\\n        }\\n        let mut dif: Vec<i32> = vec![0; nums.len()];\\n        for (i, x) in nums.iter().enumerate() {\\n            if i > ind {\\n                dif[i] = dif[i - 1];\\n                if *x > k {\\n                    dif[i] += 1;\\n                } else {\\n                    dif[i] -= 1;\\n                }\\n            }\\n        }\\n        let mut index: i32 = nums.len() as i32;\\n        for (i, x) in nums.iter().rev().enumerate() {\\n            index -= 1;\\n            if index < ind as i32 {\\n                dif[index as usize] = dif[(index + 1) as usize];\\n                if *x > k {\\n                    dif[index as usize] += 1;\\n                } else {\\n                    dif[index as usize] -= 1;\\n                }\\n            }\\n        }\\n        let mut ans: i32 = 0;\\n        let mut hm: HashMap<i32, i32> = HashMap::new();\\n        for (i, x) in dif.iter().enumerate() {\\n            if i >= ind {\\n                ans += hm.get(&(-*x)).unwrap_or(&0) + hm.get(&(-*x + 1)).unwrap_or(&0);\\n            }\\n            if i <= ind {\\n                if hm.contains_key(x) {\\n                    if let Some(val) = hm.get_mut(x) {\\n                        *val = *val + 1;\\n                    }\\n                } else {\\n                    hm.insert(*x, 1);\\n                }\\n            }\\n        }\\n        return ans as i32 + 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2870232,
                "title": "java-3ms-o-n-faster-than-99-90-less-than-99-38",
                "content": "## Idea\\n* A subarray has median **k** meets one of the conditions\\n  * When subarry is odd length, \"smaller than k\" is equal to \"larger than k\"\\n  * When subarry is even length, \"smaller than k\"+1 is equal to \"larger than k\"\\n* Calculate the difference of \"smaller than k\" and \"larger than k\"\\n\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int key = k;\\n\\t\\t// keep how many times does each difference meets\\n        int[] diff = new int[nums.length+1];\\n        diff[key] = 1;\\n\\t\\t// Calculate diff before the position of number k\\n        int i = -1;\\n        while (nums[++i] != k) {\\n            if (nums[i] > k) diff[++key]++;\\n            else diff[--key]++;\\n        }\\n        \\n        int count = 0;\\n        count += diff[key]; // odd length subarray, right end is the position of k\\n        count += diff[key-1]; // even length subarray, right end is the position of k\\n        while (++i < nums.length) {\\n            if (nums[i] > k) key++;\\n            else key--;\\n            count += diff[key]; // odd length subarray, right end at i position\\n            count += diff[key-1]; // even length subarray, right end at i position\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int key = k;\\n\\t\\t// keep how many times does each difference meets\\n        int[] diff = new int[nums.length+1];\\n        diff[key] = 1;\\n\\t\\t// Calculate diff before the position of number k\\n        int i = -1;\\n        while (nums[++i] != k) {\\n            if (nums[i] > k) diff[++key]++;\\n            else diff[--key]++;\\n        }\\n        \\n        int count = 0;\\n        count += diff[key]; // odd length subarray, right end is the position of k\\n        count += diff[key-1]; // even length subarray, right end is the position of k\\n        while (++i < nums.length) {\\n            if (nums[i] > k) key++;\\n            else key--;\\n            count += diff[key]; // odd length subarray, right end at i position\\n            count += diff[key-1]; // even length subarray, right end at i position\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869693,
                "title": "rust-o-n-hashmap-counters",
                "content": "# Intuition\\nWhen the number is a median of some set, using the current description and conditions?\\nSo the first condition the set should contain the k.\\nThen, we can say k is a median in some odd-size set of different elements, whenever amount of elements bigger than k is the same as amout of elements smaller than k. Equivalently, for the even-sized set, there shoulbe exactly one element bigger than k more than elements smaller than k.\\n\\nSince all the elements are different our subarrays should start somewhere before or at element k, and and after or at element k. We can keep track \"balance\" - the difference between amounts of elements greater and smaller than k for each array prefix. \"Balance\" of a subarray is difference of balances of prefix array at its end and balance array just before it beginning. \\n\\nFinally, we need to find all subarrays which balance is 0 or 1, containing element k. So we can put all the balances before element k is occured in the counter-hashmap, to count potential subarray beginnings. And then we can iterate all potential endings, finding amount of begginging satisfying the difference is 0 or 1. \\n# Approach\\nFirst we find index of element k in the array.\\nThen we create hash map containing association of \"balance\" -> count of possible array prefixes with this balance. We start from balance = 0, and then iteratively update the balance, comparing element to k. We use signum as shortcut to subract 1 from balance if element is smaller than k and to add 1 when it\\'s bigger.\\nFor all the elements before the index of k we update the counter map, for all the elements starting from that index, we use this counter map to find-out how many good satisfying beginning we have.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nuse std::{collections::HashMap, iter::once};\\n\\nimpl Solution {\\n\\npub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\n    let mut balanceCounts: HashMap<_, _> = once((0, 1)).collect();\\n    let mut balance = 0;\\n    let mut res = 0;\\n    let mut found = false;\\n\\n    for x in nums {\\n        balance += (x - k).signum();\\n        found |= x == k;\\n        if found {\\n            let count = |i: i32| balanceCounts.get(&i).copied().unwrap_or(0);\\n            res += count(balance) + count(balance - 1);\\n        } else {\\n            *balanceCounts.entry(balance).or_insert(0) += 1;\\n        }\\n    }\\n    res\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nuse std::{collections::HashMap, iter::once};\\n\\nimpl Solution {\\n\\npub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\n    let mut balanceCounts: HashMap<_, _> = once((0, 1)).collect();\\n    let mut balance = 0;\\n    let mut res = 0;\\n    let mut found = false;\\n\\n    for x in nums {\\n        balance += (x - k).signum();\\n        found |= x == k;\\n        if found {\\n            let count = |i: i32| balanceCounts.get(&i).copied().unwrap_or(0);\\n            res += count(balance) + count(balance - 1);\\n        } else {\\n            *balanceCounts.entry(balance).or_insert(0) += 1;\\n        }\\n    }\\n    res\\n}\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869112,
                "title": "with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->With each number bigger we add 1 and small add - 1\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Consider all element left and right, if it smaller k we minus 1 and if bigger we add 1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int result = 0;\\n        int index = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == k) {\\n                index = i;\\n                result = 1;\\n                break;\\n            }\\n        }\\n        int left[index + 1];\\n        int right[nums.size() - index];\\n        left[index] = 0;\\n        right[0] = 0;\\n        for(int i = index - 1; i >= 0; i--) {\\n            if(nums[i] > k) left[i] = left[i + 1] + 1;\\n            else left[i] = left[i + 1] - 1;\\n            if(left[i] == 0 or left[i] == 1) result++;\\n        } \\n        for(int i = index + 1; i < nums.size(); i++) {\\n            if(nums[i] > k) right[i - index] = right[i - index - 1] + 1;\\n            else right[i - index] = right[i - index - 1] - 1;\\n            if(right[i - index] == 0 or right[i - index] == 1) result++;\\n        }\\n        if(sizeof(left) / sizeof(int) - 1 == 0 or sizeof(right) / sizeof(int) - 1 == 0) return result;\\n        int maxL = INT_MIN, minL = INT_MAX, maxR = INT_MIN, minR = INT_MAX;\\n        for(int i = 0; i < index; i++) {\\n            if(left[i] > maxL) maxL = left[i];\\n            if(left[i] < minL) minL = left[i];\\n        }\\n        for(int i = 1; i < nums.size() - index; i++) {\\n            if(right[i] > maxR) maxR = right[i];\\n            if(right[i] < minR) minR = right[i];\\n        }\\n        int sortL[maxL - minL + 1];\\n        int sortR[maxR - minR + 1];\\n        for(int i = 0; i < maxL - minL + 1 ; i++) {\\n            sortL[i] = 0;\\n        }\\n        for(int i = 0; i < maxR - minR + 1 ; i++) {\\n            sortR[i] = 0;\\n        }\\n        for(int i = 0; i < index; i++) {\\n            sortL[left[i] - minL]++;\\n        }\\n        for(int i = 1; i < nums.size() - index; i++) {\\n            sortR[right[i] - minR]++;\\n        }\\n        for(int i = 0; i < maxL - minL + 1; i++) {\\n            if(- (i + minL) >= minR and - (i + minL) <= maxR) result += sortL[i] * sortR[- (i + minL) - minR];\\n        }\\n        for(int i = 0; i < maxL - minL + 1; i++) {\\n            if(- (i + minL) + 1 >= minR and - (i + minL) + 1 <= maxR) result += sortL[i] * sortR[- (i + minL) + 1 - minR];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int result = 0;\\n        int index = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == k) {\\n                index = i;\\n                result = 1;\\n                break;\\n            }\\n        }\\n        int left[index + 1];\\n        int right[nums.size() - index];\\n        left[index] = 0;\\n        right[0] = 0;\\n        for(int i = index - 1; i >= 0; i--) {\\n            if(nums[i] > k) left[i] = left[i + 1] + 1;\\n            else left[i] = left[i + 1] - 1;\\n            if(left[i] == 0 or left[i] == 1) result++;\\n        } \\n        for(int i = index + 1; i < nums.size(); i++) {\\n            if(nums[i] > k) right[i - index] = right[i - index - 1] + 1;\\n            else right[i - index] = right[i - index - 1] - 1;\\n            if(right[i - index] == 0 or right[i - index] == 1) result++;\\n        }\\n        if(sizeof(left) / sizeof(int) - 1 == 0 or sizeof(right) / sizeof(int) - 1 == 0) return result;\\n        int maxL = INT_MIN, minL = INT_MAX, maxR = INT_MIN, minR = INT_MAX;\\n        for(int i = 0; i < index; i++) {\\n            if(left[i] > maxL) maxL = left[i];\\n            if(left[i] < minL) minL = left[i];\\n        }\\n        for(int i = 1; i < nums.size() - index; i++) {\\n            if(right[i] > maxR) maxR = right[i];\\n            if(right[i] < minR) minR = right[i];\\n        }\\n        int sortL[maxL - minL + 1];\\n        int sortR[maxR - minR + 1];\\n        for(int i = 0; i < maxL - minL + 1 ; i++) {\\n            sortL[i] = 0;\\n        }\\n        for(int i = 0; i < maxR - minR + 1 ; i++) {\\n            sortR[i] = 0;\\n        }\\n        for(int i = 0; i < index; i++) {\\n            sortL[left[i] - minL]++;\\n        }\\n        for(int i = 1; i < nums.size() - index; i++) {\\n            sortR[right[i] - minR]++;\\n        }\\n        for(int i = 0; i < maxL - minL + 1; i++) {\\n            if(- (i + minL) >= minR and - (i + minL) <= maxR) result += sortL[i] * sortR[- (i + minL) - minR];\\n        }\\n        for(int i = 0; i < maxL - minL + 1; i++) {\\n            if(- (i + minL) + 1 >= minR and - (i + minL) + 1 <= maxR) result += sortL[i] * sortR[- (i + minL) + 1 - minR];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867805,
                "title": "c-hashmap-prefix-sum",
                "content": "class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        \\n        vector<int> v(nums.size());\\n        int ind = -1;\\n        for(int i = 0;i < nums.size();i++){\\n            if(nums[i] == k){\\n                ind = i;\\n                v[i] = 0;\\n                continue;\\n            }\\n            v[i] = nums[i] < k?-1:1;    \\n        }\\n        \\n        map<int,int> mp;\\n        \\n        if(ind == -1) return 0;\\n        \\n        int sum = 0;\\n        for(int i = ind;i < v.size();i++){\\n            sum += v[i];\\n            mp[sum]++;\\n        }\\n        \\n        sum = 0;\\n        \\n        int ans  = 0;\\n        for(int i = ind;i >= 0;i--){\\n            sum += v[i];\\n            ans += mp[-sum];\\n            ans += mp[1-sum];\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        \\n        vector<int> v(nums.size());\\n        int ind = -1;\\n        for(int i = 0;i < nums.size();i++){\\n            if(nums[i] == k){\\n                ind = i;\\n                v[i] = 0;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2866353,
                "title": "c-hashtable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nonly larger or smaller than k does matter\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhash table to count \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        // check k position\\n        int idx = std::find(nums.begin(), nums.end(), k) - nums.begin();\\n        unordered_map<int, int> smap;\\n        long rsum = 0;\\n        for(int i=idx; i<nums.size(); i++){\\n            if(nums[i] > k) \\n                rsum++;\\n            else if(nums[i] < k)\\n                rsum--;\\n            smap[rsum]++;\\n        }\\n        long lsum = 0, ans = 0;\\n        for(int i=idx; i>=0; i--){\\n            if(nums[i] >k)\\n                lsum++;\\n            else if(nums[i] < k)\\n                lsum--;\\n            if(smap.find(-lsum) != smap.end())\\n                ans += smap[-lsum];\\n            if(smap.find(1-lsum) != smap.end())\\n                ans += smap[1-lsum];\\n        }\\n        return ans;\\n    }       \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        // check k position\\n        int idx = std::find(nums.begin(), nums.end(), k) - nums.begin();\\n        unordered_map<int, int> smap;\\n        long rsum = 0;\\n        for(int i=idx; i<nums.size(); i++){\\n            if(nums[i] > k) \\n                rsum++;\\n            else if(nums[i] < k)\\n                rsum--;\\n            smap[rsum]++;\\n        }\\n        long lsum = 0, ans = 0;\\n        for(int i=idx; i>=0; i--){\\n            if(nums[i] >k)\\n                lsum++;\\n            else if(nums[i] < k)\\n                lsum--;\\n            if(smap.find(-lsum) != smap.end())\\n                ans += smap[-lsum];\\n            if(smap.find(1-lsum) != smap.end())\\n                ans += smap[1-lsum];\\n        }\\n        return ans;\\n    }       \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862156,
                "title": "c-hashmap-solution",
                "content": "**Idea**\\n* We have to find median here it means in the subarray of odd length **n** there has to be **n/2** numbers less then **k** ans **n/2** greater than **k** for even length **n/2 -1** ans**n/2** respectively\\n* so if we change numbers greater than **k** into 1 ans less than -1 so we want subarray of sum **0** ans**1** \\n\\n**C++ Code**\\n```\\nint find(vector<int> &nums, int idx){\\n        unordered_map<int,int> mp;   //sum,cnt\\n        mp[0]++;\\n        int sum=0;\\n        int ans=0;\\n        //for zero\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(i>=idx){\\n                ans+=mp[sum]+mp[sum-1];\\n            }\\n            else{\\n                mp[sum]++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int countSubarrays(vector<int>& nums, int k) {\\n        int idx;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>k){\\n                nums[i]=1;\\n            }\\n            else if(nums[i]<k){\\n                nums[i]=-1;\\n            }\\n            else{\\n                nums[i]=0;\\n                idx=i;\\n            }\\n        }\\n        int ans=0;\\n        ans=find(nums,idx);\\n        return ans;\\n    }\\n\\t//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint find(vector<int> &nums, int idx){\\n        unordered_map<int,int> mp;   //sum,cnt\\n        mp[0]++;\\n        int sum=0;\\n        int ans=0;\\n        //for zero\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(i>=idx){\\n                ans+=mp[sum]+mp[sum-1];\\n            }\\n            else{\\n                mp[sum]++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int countSubarrays(vector<int>& nums, int k) {\\n        int idx;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>k){\\n                nums[i]=1;\\n            }\\n            else if(nums[i]<k){\\n                nums[i]=-1;\\n            }\\n            else{\\n                nums[i]=0;\\n                idx=i;\\n            }\\n        }\\n        int ans=0;\\n        ans=find(nums,idx);\\n        return ans;\\n    }\\n\\t//code by sachin\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2861459,
                "title": "translate-to-a-binary-1-1-array-first",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int K = -1;\\n        vector<int> binary(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] < k) {\\n                binary[i] = -1;\\n            } else if (nums[i] > k) {\\n                binary[i] = 1;\\n            } else {\\n                K = i;\\n            }\\n        }\\n        vector<int> prefix(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            prefix[i] = binary[i] + (i ? prefix[i - 1] : 0);\\n        }\\n        unordered_map<int, int> book;\\n        book[0] = 1;\\n        for (int i = 0; i < K; ++i) {\\n            ++book[prefix[i]];\\n        }\\n        int ans = 1;\\n        for (int i = K; i < n; ++i) {\\n            if (i == K) {\\n                if (i > 0) {\\n                    int prev = prefix[i - 1];\\n                    ans += book[prev] - 1;\\n                    ans += book[prev - 1];\\n                }\\n            } else {\\n                int curr = prefix[i];\\n                ans += book[curr];\\n                ans += book[curr - 1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int K = -1;\\n        vector<int> binary(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] < k) {\\n                binary[i] = -1;\\n            } else if (nums[i] > k) {\\n                binary[i] = 1;\\n            } else {\\n                K = i;\\n            }\\n        }\\n        vector<int> prefix(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            prefix[i] = binary[i] + (i ? prefix[i - 1] : 0);\\n        }\\n        unordered_map<int, int> book;\\n        book[0] = 1;\\n        for (int i = 0; i < K; ++i) {\\n            ++book[prefix[i]];\\n        }\\n        int ans = 1;\\n        for (int i = K; i < n; ++i) {\\n            if (i == K) {\\n                if (i > 0) {\\n                    int prev = prefix[i - 1];\\n                    ans += book[prev] - 1;\\n                    ans += book[prev - 1];\\n                }\\n            } else {\\n                int curr = prefix[i];\\n                ans += book[curr];\\n                ans += book[curr - 1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860701,
                "title": "easy-c-code-with-comments-o-n-time-complexity-o-n-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        \\n        // Get the index of k in nums. \\n        int idx = find(nums.begin(), nums.end(), k) - nums.begin();\\n        \\n        // Initialize answer with 1, since k itself is a subarray.\\n        int ans = 1;\\n        \\n        // Explore elements in left of k in nums.\\n        int leftLarger = 0, leftSmaller = 0;\\n        for(int i = idx - 1; i >= 0; i--) {\\n            if(nums[i] > k) {\\n                leftLarger++;\\n            } else {\\n                leftSmaller++;\\n            }\\n            \\n            // Get the difference. \\n            int diff = leftLarger - leftSmaller;\\n            // Store the difference.\\n            mp[diff]++;\\n            \\n            if(diff == 0 or diff == 1) {\\n                ans++;\\n            }\\n        }\\n        \\n        // Explore elements in right of k in nums.\\n        int rightLarger = 0, rightSmaller = 0;\\n        for(int i = idx + 1; i < n; i++) {\\n            if(nums[i] > k) {\\n                rightLarger++;\\n            } else {\\n                rightSmaller++;\\n            }\\n            \\n            // Get the difference. \\n            int diff = rightSmaller - rightLarger;\\n            // If diff or diff+1 is already present inside map, include it in answer.\\n            ans += mp[diff+1];\\n            ans += mp[diff];\\n            \\n            if(diff == 0 or diff == -1) {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        \\n        // Get the index of k in nums. \\n        int idx = find(nums.begin(), nums.end(), k) - nums.begin();\\n        \\n        // Initialize answer with 1, since k itself is a subarray.\\n        int ans = 1;\\n        \\n        // Explore elements in left of k in nums.\\n        int leftLarger = 0, leftSmaller = 0;\\n        for(int i = idx - 1; i >= 0; i--) {\\n            if(nums[i] > k) {\\n                leftLarger++;\\n            } else {\\n                leftSmaller++;\\n            }\\n            \\n            // Get the difference. \\n            int diff = leftLarger - leftSmaller;\\n            // Store the difference.\\n            mp[diff]++;\\n            \\n            if(diff == 0 or diff == 1) {\\n                ans++;\\n            }\\n        }\\n        \\n        // Explore elements in right of k in nums.\\n        int rightLarger = 0, rightSmaller = 0;\\n        for(int i = idx + 1; i < n; i++) {\\n            if(nums[i] > k) {\\n                rightLarger++;\\n            } else {\\n                rightSmaller++;\\n            }\\n            \\n            // Get the difference. \\n            int diff = rightSmaller - rightLarger;\\n            // If diff or diff+1 is already present inside map, include it in answer.\\n            ans += mp[diff+1];\\n            ans += mp[diff];\\n            \\n            if(diff == 0 or diff == -1) {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860520,
                "title": "python3-hashmap",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        hmap = defaultdict(int)\\n        ind = nums.index(k)\\n        bal,ans = 0,0\\n        for left in range(ind,-1,-1):\\n            if nums[left] < k:\\n                bal-=1\\n            elif nums[left] > k:\\n                bal+=1\\n            hmap[bal] +=1\\n        bal = 0\\n        for right in range(ind,n):\\n            if nums[right] < k:\\n                bal-=1\\n            elif nums[right] > k:\\n                bal+=1\\n            target_1 = -bal\\n            target_2 = 1 - bal\\n            ans+=hmap[target_1] + hmap[target_2]\\n        return ans \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        hmap = defaultdict(int)\\n        ind = nums.index(k)\\n        bal,ans = 0,0\\n        for left in range(ind,-1,-1):\\n            if nums[left] < k:\\n                bal-=1\\n            elif nums[left] > k:\\n                bal+=1\\n            hmap[bal] +=1\\n        bal = 0\\n        for right in range(ind,n):\\n            if nums[right] < k:\\n                bal-=1\\n            elif nums[right] > k:\\n                bal+=1\\n            target_1 = -bal\\n            target_2 = 1 - bal\\n            ans+=hmap[target_1] + hmap[target_2]\\n        return ans \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859887,
                "title": "c-o-n-hash-table-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        int idx=find(nums.begin(),nums.end(),k)-nums.begin();\\n        int res=0;\\n        int bal=0;\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            bal+=nums[i]==k?0:nums[i]<k?-1:1;\\n            mp[bal]++;\\n        }\\n        bal=0;\\n        for(int i=idx;i>=0;i--)\\n        {\\n            bal+=nums[i]==k?0:nums[i]<k?-1:1;\\n            res+=mp[-bal]+mp[-bal+1];\\n        }\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k)\\n    {\\n        unordered_map<int,int> mp;\\n        int idx=find(nums.begin(),nums.end(),k)-nums.begin();\\n        int res=0;\\n        int bal=0;\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            bal+=nums[i]==k?0:nums[i]<k?-1:1;\\n            mp[bal]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2859784,
                "title": "100-fastest",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        bool found = false;\\n        \\n        for(int& num : nums) {\\n            if(num < k) sum--;\\n            else if(num > k) sum++;\\n            else {\\n                found = true;   \\n            }\\n            \\n            if(found) {\\n                if(mp.find(sum) != mp.end()) {\\n                    ans += mp[sum];\\n                }\\n                \\n                if(mp.find(sum - 1) != mp.end()) {\\n                    ans += mp[sum - 1];\\n                }\\n            } else {\\n                mp[sum]++;\\n            }            \\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        int ans = 0;\\n        int sum = 0;\\n        bool found = false;\\n        \\n        for(int& num : nums) {\\n            if(num < k) sum--;\\n            else if(num > k) sum++;\\n            else {\\n                found = true;   \\n            }\\n            \\n            if(found) {\\n                if(mp.find(sum) != mp.end()) {\\n                    ans += mp[sum];\\n                }\\n                \\n                if(mp.find(sum - 1) != mp.end()) {\\n                    ans += mp[sum - 1];\\n                }\\n            } else {\\n                mp[sum]++;\\n            }            \\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858904,
                "title": "easy-to-understand-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int> freqMap;\\n        \\n        // find the poisition of the median element\\n        int i = 0;\\n        int n = nums.size();\\n        for (; i < n ; i++) {\\n            if (nums[i] == k)\\n                break;\\n        }\\n        \\n        // traverse backward to check the balance\\n        // where + means number of integers greater than median\\n        // -ve indicate number of integers lesser than median\\n        int medianIdx = i;\\n        int balance = 0;\\n        while (i >= 0) {\\n            if (nums[i] < k) {\\n                balance--;\\n            } else if (nums[i] > k){\\n                balance++;\\n            }\\n            freqMap[balance]++;\\n            i--;\\n        }\\n        int res = 0;\\n        balance = 0;\\n        for (int i = medianIdx; i < n; i++) {\\n            if (nums[i] < k) {\\n                balance--;\\n            } else if (nums[i] > k){\\n                balance++;\\n            }\\n            // check for odd length, for current balance we\\n            // should have already seen complementary balance\\n            // +2 on right then -2 on left so median will stay median\\n            auto it = freqMap.find(-1*balance);\\n            if (it != freqMap.end()) {\\n                res += it->second;\\n            }\\n            \\n            // for even length array we are allowed to keep 1 extra on right\\n            // so balance can be 1 less on the left, so we are looking for 1 less \\n            // number than the current balance\\n            it = freqMap.find(-1*(balance-1));\\n            if (it != freqMap.end()) {\\n                res += it->second;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        unordered_map<int,int> freqMap;\\n        \\n        // find the poisition of the median element\\n        int i = 0;\\n        int n = nums.size();\\n        for (; i < n ; i++) {\\n            if (nums[i] == k)\\n                break;\\n        }\\n        \\n        // traverse backward to check the balance\\n        // where + means number of integers greater than median\\n        // -ve indicate number of integers lesser than median\\n        int medianIdx = i;\\n        int balance = 0;\\n        while (i >= 0) {\\n            if (nums[i] < k) {\\n                balance--;\\n            } else if (nums[i] > k){\\n                balance++;\\n            }\\n            freqMap[balance]++;\\n            i--;\\n        }\\n        int res = 0;\\n        balance = 0;\\n        for (int i = medianIdx; i < n; i++) {\\n            if (nums[i] < k) {\\n                balance--;\\n            } else if (nums[i] > k){\\n                balance++;\\n            }\\n            // check for odd length, for current balance we\\n            // should have already seen complementary balance\\n            // +2 on right then -2 on left so median will stay median\\n            auto it = freqMap.find(-1*balance);\\n            if (it != freqMap.end()) {\\n                res += it->second;\\n            }\\n            \\n            // for even length array we are allowed to keep 1 extra on right\\n            // so balance can be 1 less on the left, so we are looking for 1 less \\n            // number than the current balance\\n            it = freqMap.find(-1*(balance-1));\\n            if (it != freqMap.end()) {\\n                res += it->second;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858142,
                "title": "python-o-n-time-o-n-space-with-prefix-sum-and-hashmap",
                "content": "```\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n#         find the index of median\\n        l,r=0,len(nums)\\n        ind=nums.index(k)\\n        dp=[0]*r\\n        ct=0\\n        dic=defaultdict(int)\\n        for i in range(r):\\n#             mark the num greater than k as 1, smaller than k as -1, and k as 0\\n            if nums[i]>k:\\n                nums[i]=1\\n            elif nums[i]<k:\\n                nums[i]=-1\\n            else:\\n                nums[i]=0\\n#                 prefix sum save to dp\\n            dp[i]=dp[i-1]+nums[i]\\n            if i<ind:\\n#        when less than ind, add to dic: {key: prefix sum, value: occurance}\\n                dic[dp[i]]+=1\\n            if i>=ind:\\n#             k is the median when the sum of the array ==0 or 1\\n#  find the num of dp[x], x in range [:ind) that == dp[i] or dp[i]-1\\n                ct+=dic[dp[i]]+dic[dp[i]-1]\\n                if dp[i]==0 or dp[i]==1:\\n#             consider the case subarray start from 0\\n                    ct+=1\\n        return ct\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n#         find the index of median\\n        l,r=0,len(nums)\\n        ind=nums.index(k)\\n        dp=[0]*r\\n        ct=0\\n        dic=defaultdict(int)\\n        for i in range(r):\\n#             mark the num greater than k as 1, smaller than k as -1, and k as 0\\n            if nums[i]>k:\\n                nums[i]=1\\n            elif nums[i]<k:\\n                nums[i]=-1\\n            else:\\n                nums[i]=0\\n#                 prefix sum save to dp\\n            dp[i]=dp[i-1]+nums[i]\\n            if i<ind:\\n#        when less than ind, add to dic: {key: prefix sum, value: occurance}\\n                dic[dp[i]]+=1\\n            if i>=ind:\\n#             k is the median when the sum of the array ==0 or 1\\n#  find the num of dp[x], x in range [:ind) that == dp[i] or dp[i]-1\\n                ct+=dic[dp[i]]+dic[dp[i]-1]\\n                if dp[i]==0 or dp[i]==1:\\n#             consider the case subarray start from 0\\n                    ct+=1\\n        return ct\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2857618,
                "title": "o-n",
                "content": "# Intuition\\n\\n\\nWe are looking for subarrays that contain k.\\nElements are unique (from 1 to n).\\nSince the subarray has to contain k, and there is only one k, we can start from k to build the subarrays.\\nWhat makes a valid subarray (i.e., k as the median)?\\n\\nthe number of elements larger than k == the number of elements smaller than k (odd length)\\nthe number of elements larger than k + 1 == the number of elements smaller than k (even length)\\n=> large == small or large == small+1\\n\\n\\n\\n\\n# Approach\\nWe can check the elements before k and after k, and count the number of elements larger/smaller than k.\\n\\nlet\\'s use l1 and s1 denoting the number of elements larger and smaller than k, Before k.\\nand l2, s2 denoting the number of elements larger and smaller than k, After k.\\n=> The above equation becomes:\\nl1 + l2 == s1 + s2 => l1 - s1 == s2 - l2\\nl1 + l2 == s1 + s2 + 1 => l1 - s1 == s2 - l2 + 1\\nNow we can use a hash map to count the frequency of l1 - s1 for the subarray before k (and contains k).\\nThen, check if s2 - l2 and s2 - l2 + 1 in the hash map for the subarray after k (and contains k) to compute the result.\\n\\n# Complexity\\n- Time complexity:\\n since we only go through the elements before k and after k once.\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        before=defaultdict()\\n        n=len(nums)\\n        ind=nums.index(k)\\n        ans=0\\n        l=s=0\\n        for i in range(ind-1,-1,-1):\\n            if nums[i]>k:\\n                l+=1\\n            else:\\n                s+=1\\n            if (l-s) not in before:\\n                before[l-s]=0    \\n            before[l-s]+=1\\n            if l==s or l-s==1:\\n                ans+=1\\n        l=s=0\\n        for i in range(ind+1,n):\\n            if nums[i]>k:\\n                l+=1\\n            else:\\n                s+=1\\n            if (s-l) in before:    \\n                  ans+=before[s-l]\\n            if (s-l+1) in before:\\n                ans+=before[s-l+1]      \\n            if l==s or l-s==1:\\n                ans+=1 \\n        return ans +1                             \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        before=defaultdict()\\n        n=len(nums)\\n        ind=nums.index(k)\\n        ans=0\\n        l=s=0\\n        for i in range(ind-1,-1,-1):\\n            if nums[i]>k:\\n                l+=1\\n            else:\\n                s+=1\\n            if (l-s) not in before:\\n                before[l-s]=0    \\n            before[l-s]+=1\\n            if l==s or l-s==1:\\n                ans+=1\\n        l=s=0\\n        for i in range(ind+1,n):\\n            if nums[i]>k:\\n                l+=1\\n            else:\\n                s+=1\\n            if (s-l) in before:    \\n                  ans+=before[s-l]\\n            if (s-l+1) in before:\\n                ans+=before[s-l+1]      \\n            if l==s or l-s==1:\\n                ans+=1 \\n        return ans +1                             \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856146,
                "title": "python-solution-beats-100-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Brute Force:**\\n    Check for all subarrays and find the median, if median==k, then count that array into answer. This approach will take O(n^3 logn).\\n\\n**Observations**:\\n1. Each number in the list is unique and in range from 1..n\\n2. Since the median is already given, we need not comput it and hence we need all those subarrays which fall in either of two categories:\\n    - **Odd number of items**: x items less than k and x items more than k. Total number of items: 2*x+1\\n    - **Even number of items**: x-1 items before k and x items after k. Total number of items will be 2*x.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTaking look at these couple of observations, we can infer that we only need count of elements lesser and greater than k. \\nWe can directly consider elements greater than k in array as ```\\n+1\\n``` and elements lesser than k as ```-1```.\\n\\nWe will further need a dictionary to store the sum of elements from index containing k till last element. Further, we will require this array as we traverse backward from ```index_k``` as we can match the number of elements.\\n\\nRead the inline comments with code for a better understanding.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    Time complexity for this approach will be ```O(n)```\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        #step 1: find the index of element containing k\\n        index_k,n = -1, len(nums)\\n        for i in range(len(nums)):\\n            if nums[i]==k:\\n                index_k = i\\n                break\\n        #Make a dictionary to store the sum of elements from index_k till n.\\n        d = defaultdict(int)\\n        current_sum = 0\\n        for x in range(index_k, n):\\n            if nums[x]>k:\\n                current_sum+=1\\n            elif nums[x]<k:\\n                current_sum-=1\\n                \\n            d[current_sum]+=1\\n        # print(d)\\n        #result stors the total number of arrays to be returned.\\n        result, current_sum = 0,0\\n        #Similar to what we previously did, sum up elements \\n        #from index_k till 0th index and match it against \\n        #dictionary items present. It should either match \\n        #left-right==0 for odd length subarray and \\n        #left+1-right==0 for even length subarray.\\n        #Add 1 to left half as it should have one lesser\\n        #element than right half of subarray\\n        for x in range(index_k, -1,-1):\\n            if nums[x]>k:\\n                current_sum+=1\\n            elif nums[x]<k:\\n                current_sum-=1\\n            # print(current_sum)\\n            result+= d[-1*current_sum] + d[1-current_sum]\\n        return result\\n            \\n```\\n\\n*Thanks for reading though the post. Upvote if you liked it*\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n+1\\n```\n```-1```\n```index_k```\n```O(n)```\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        #step 1: find the index of element containing k\\n        index_k,n = -1, len(nums)\\n        for i in range(len(nums)):\\n            if nums[i]==k:\\n                index_k = i\\n                break\\n        #Make a dictionary to store the sum of elements from index_k till n.\\n        d = defaultdict(int)\\n        current_sum = 0\\n        for x in range(index_k, n):\\n            if nums[x]>k:\\n                current_sum+=1\\n            elif nums[x]<k:\\n                current_sum-=1\\n                \\n            d[current_sum]+=1\\n        # print(d)\\n        #result stors the total number of arrays to be returned.\\n        result, current_sum = 0,0\\n        #Similar to what we previously did, sum up elements \\n        #from index_k till 0th index and match it against \\n        #dictionary items present. It should either match \\n        #left-right==0 for odd length subarray and \\n        #left+1-right==0 for even length subarray.\\n        #Add 1 to left half as it should have one lesser\\n        #element than right half of subarray\\n        for x in range(index_k, -1,-1):\\n            if nums[x]>k:\\n                current_sum+=1\\n            elif nums[x]<k:\\n                current_sum-=1\\n            # print(current_sum)\\n            result+= d[-1*current_sum] + d[1-current_sum]\\n        return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855996,
                "title": "python-o-n-to-count-greater-or-less-than-k-on-the-left-or-right-of-k-index",
                "content": "# Intuition\\nFirst, we need to find index of k in nums: kp. So the subarray we find is [i, i + 1, .., kp, ..., j]. if We want k is median of the subarray, there is equal number grearter than k and less than k, or one more grearter than k.\\n\\nThus the difference between greater and less matters. We use dict to store diff count one the left and right.\\n\\nThe final answer is sum of: (1) single k, 1 subarray. (2) The number of subarray start at kp that diff is 0 or 1. (3) The number of subarray end at kp that diff is 0 or 1. (4) kp is in the middle of subarray, diff on the left plus diff on the right is 0 or 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        left, right = defaultdict(int), defaultdict(int)\\n        kp = nums.index(k)\\n        greater, less = 0, 0\\n        for i in range(kp - 1, -1, -1):\\n            if nums[i] > k: greater += 1\\n            else: less += 1\\n            left[greater - less] += 1\\n        greater, less = 0, 0\\n        for i in range(kp + 1, len(nums)):\\n            if nums[i] > k: greater += 1\\n            else: less += 1\\n            right[greater - less] += 1\\n        return 1 + sum((right[-diff] + right[-diff + 1]) * v for diff, v in left.items()) + left[1] + right[1] + left[0] + right[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        left, right = defaultdict(int), defaultdict(int)\\n        kp = nums.index(k)\\n        greater, less = 0, 0\\n        for i in range(kp - 1, -1, -1):\\n            if nums[i] > k: greater += 1\\n            else: less += 1\\n            left[greater - less] += 1\\n        greater, less = 0, 0\\n        for i in range(kp + 1, len(nums)):\\n            if nums[i] > k: greater += 1\\n            else: less += 1\\n            right[greater - less] += 1\\n        return 1 + sum((right[-diff] + right[-diff + 1]) * v for diff, v in left.items()) + left[1] + right[1] + left[0] + right[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855589,
                "title": "c-solution-75-faster-runtime",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        \\n        map<int, int> left, right;\\n        int n=nums.size(), index = 0, l=0, g=0, ans=0;\\n        while(index < n){\\n            if( nums[index] == k )\\n                break;\\n            index += 1;\\n        }\\n        \\n        for(int i=index-1; i>=0; i--){\\n            l += (nums[i] < k)? 1 : 0;\\n            g += (nums[i] > k)? 1 : 0;\\n            left[(l-g)] += 1;\\n        }\\n        l=g=0;\\n        for(int i=index+1; i<n; i++){\\n            l += (nums[i] < k)? 1 : 0;\\n            g += (nums[i] > k)? 1 : 0;\\n            right[(l-g)] += 1;\\n        }\\n        \\n        for(auto &p : left){\\n            \\n            int temp = p.first;\\n            if( temp > 0 ){\\n                // Looking for greater elements //\\n                ans += (right[-temp] * p.second);\\n                ans += (right[-(temp+1)] * p.second);\\n            }\\n            else if( temp < 0 ){\\n                // Looking for smaller elements //\\n                temp = abs(temp);\\n                ans += (right[temp] * p.second);\\n                ans += (right[(temp-1)] * p.second);\\n            }\\n            else{\\n                ans += p.second;\\n                ans += (right[(temp-1)] * p.second);\\n            }\\n        }\\n        ans += right[0];\\n        ans += (left[0] * right[0]);\\n        ans += right[-1];\\n        ans += left[-1];\\n\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        \\n        map<int, int> left, right;\\n        int n=nums.size(), index = 0, l=0, g=0, ans=0;\\n        while(index < n){\\n            if( nums[index] == k )\\n                break;\\n            index += 1;\\n        }\\n        \\n        for(int i=index-1; i>=0; i--){\\n            l += (nums[i] < k)? 1 : 0;\\n            g += (nums[i] > k)? 1 : 0;\\n            left[(l-g)] += 1;\\n        }\\n        l=g=0;\\n        for(int i=index+1; i<n; i++){\\n            l += (nums[i] < k)? 1 : 0;\\n            g += (nums[i] > k)? 1 : 0;\\n            right[(l-g)] += 1;\\n        }\\n        \\n        for(auto &p : left){\\n            \\n            int temp = p.first;\\n            if( temp > 0 ){\\n                // Looking for greater elements //\\n                ans += (right[-temp] * p.second);\\n                ans += (right[-(temp+1)] * p.second);\\n            }\\n            else if( temp < 0 ){\\n                // Looking for smaller elements //\\n                temp = abs(temp);\\n                ans += (right[temp] * p.second);\\n                ans += (right[(temp-1)] * p.second);\\n            }\\n            else{\\n                ans += p.second;\\n                ans += (right[(temp-1)] * p.second);\\n            }\\n        }\\n        ans += right[0];\\n        ans += (left[0] * right[0]);\\n        ans += right[-1];\\n        ans += left[-1];\\n\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855052,
                "title": "c-one-run-counters",
                "content": "# Intuition\\nUse counters to count number of element greater or less than k at each position.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountSubarrays(int[] nums, int k) {\\n        int n = nums.Length;\\n        int res = 1;\\n        int p = 0;\\n        int[] D = new int[n+n];\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==k){\\n                p = i;\\n                break;\\n            }\\n        } \\n        int[,] Counter = new int[n,2]; //0>;1<\\n        Counter[p,0] = 0;\\n        Counter[p,1] = 0;\\n        \\n        for(int i=p-1;i>=0;i--)\\n        {\\n            if(nums[i]>k)\\n            {\\n                Counter[i,0] = Counter[i+1,0]+1;\\n                Counter[i,1] = Counter[i+1,1];\\n            }\\n            else\\n            {\\n                Counter[i,1] = Counter[i+1,1]+1;\\n                Counter[i,0] = Counter[i+1,0];\\n\\n            }\\n             \\n            if(Counter[i,1]==Counter[i,0]) \\n                res++;\\n            else if(Counter[i,1]+1==Counter[i,0]) \\n                res++;\\n            \\n            D[Counter[i,0]-Counter[i,1]+n]++;\\n        }\\n        \\n        for(int i=p+1;i<n;i++)\\n        {\\n           if(nums[i]>k)\\n            {\\n                Counter[i,0] = Counter[i-1,0]+1;\\n                Counter[i,1] = Counter[i-1,1];\\n            }\\n            else\\n            {\\n                Counter[i,1] = Counter[i-1,1]+1;\\n                Counter[i,0] = Counter[i-1,0];\\n\\n            }\\n            \\n            if(Counter[i,1]==Counter[i,0]) \\n                res+=1+D[n]+D[n+1];\\n            else if(Counter[i,1]+1==Counter[i,0]) \\n                res += 1+D[n]+D[n-1];\\n            else\\n                res += D[Counter[i,1]-Counter[i,0]+n] + D[Counter[i,1]-Counter[i,0]+n+1];\\n            \\n                \\n        }\\n        \\n      \\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountSubarrays(int[] nums, int k) {\\n        int n = nums.Length;\\n        int res = 1;\\n        int p = 0;\\n        int[] D = new int[n+n];\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==k){\\n                p = i;\\n                break;\\n            }\\n        } \\n        int[,] Counter = new int[n,2]; //0>;1<\\n        Counter[p,0] = 0;\\n        Counter[p,1] = 0;\\n        \\n        for(int i=p-1;i>=0;i--)\\n        {\\n            if(nums[i]>k)\\n            {\\n                Counter[i,0] = Counter[i+1,0]+1;\\n                Counter[i,1] = Counter[i+1,1];\\n            }\\n            else\\n            {\\n                Counter[i,1] = Counter[i+1,1]+1;\\n                Counter[i,0] = Counter[i+1,0];\\n\\n            }\\n             \\n            if(Counter[i,1]==Counter[i,0]) \\n                res++;\\n            else if(Counter[i,1]+1==Counter[i,0]) \\n                res++;\\n            \\n            D[Counter[i,0]-Counter[i,1]+n]++;\\n        }\\n        \\n        for(int i=p+1;i<n;i++)\\n        {\\n           if(nums[i]>k)\\n            {\\n                Counter[i,0] = Counter[i-1,0]+1;\\n                Counter[i,1] = Counter[i-1,1];\\n            }\\n            else\\n            {\\n                Counter[i,1] = Counter[i-1,1]+1;\\n                Counter[i,0] = Counter[i-1,0];\\n\\n            }\\n            \\n            if(Counter[i,1]==Counter[i,0]) \\n                res+=1+D[n]+D[n+1];\\n            else if(Counter[i,1]+1==Counter[i,0]) \\n                res += 1+D[n]+D[n-1];\\n            else\\n                res += D[Counter[i,1]-Counter[i,0]+n] + D[Counter[i,1]-Counter[i,0]+n+1];\\n            \\n                \\n        }\\n        \\n      \\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855008,
                "title": "rust-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut i = 0;\\n        while nums[i] != k { i += 1; }\\n        \\n        let (mut left, mut right) = (HashMap::<i32, i32>::new(), HashMap::<i32, i32>::new());\\n        \\n        let mut cnt = 0;\\n        *right.entry(cnt).or_default() += 1;\\n        for j in i + 1 .. n {\\n            cnt += if nums[j] > k { 1 } else { -1 };\\n            *right.entry(cnt).or_default() += 1;\\n        }\\n        \\n        cnt = 0;\\n         *left.entry(cnt).or_default() += 1;\\n        for j in (0 .. i).rev() {\\n            cnt += if nums[j] > k { 1 } else { -1 };\\n            *left.entry(cnt).or_default() += 1;\\n        }\\n        \\n        let mut ret = 0;\\n        for (key, val) in left {\\n            if let Some(cnt) = right.get(&(-key)) {\\n                ret += val * cnt;\\n            }\\n            if let Some(cnt) = right.get(&(1 - key)) {\\n                ret += val * cnt;\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut i = 0;\\n        while nums[i] != k { i += 1; }\\n        \\n        let (mut left, mut right) = (HashMap::<i32, i32>::new(), HashMap::<i32, i32>::new());\\n        \\n        let mut cnt = 0;\\n        *right.entry(cnt).or_default() += 1;\\n        for j in i + 1 .. n {\\n            cnt += if nums[j] > k { 1 } else { -1 };\\n            *right.entry(cnt).or_default() += 1;\\n        }\\n        \\n        cnt = 0;\\n         *left.entry(cnt).or_default() += 1;\\n        for j in (0 .. i).rev() {\\n            cnt += if nums[j] > k { 1 } else { -1 };\\n            *left.entry(cnt).or_default() += 1;\\n        }\\n        \\n        let mut ret = 0;\\n        for (key, val) in left {\\n            if let Some(cnt) = right.get(&(-key)) {\\n                ret += val * cnt;\\n            }\\n            if let Some(cnt) = right.get(&(1 - key)) {\\n                ret += val * cnt;\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854891,
                "title": "o-n-time",
                "content": "# Intuition\\nI can\\'t claim credit for this. I stumbled around for about an hour on the Weekly Contest yesterday and after looking at solutions, found votrubac\\'s solution here (https://leetcode.com/problems/count-subarrays-with-median-k/solutions/2851940/balance/). I highly recommend looking over that post for more details as I used it to gain the intuition to solve this one. This attempt and my solution were merely for my own edification.\\n\\nWe know from the description that a median is defined slightly differently than it usually is. From their description, even length subarrays consider the median to be the element left of center. Therefore, k is the median of the subarray when:\\n```\\n1. k is in the subarray\\n2. For odd length sorted subarray, k is the middle element\\n3. For even length sorted subarray, k is the left of middle element\\n```\\n\\nThis boils down to:\\n```\\n1. k must be in the subarray and one of the following must be true:\\n    1. # elements < k equals the # elements > k\\n    2. # elements < k is one less than the # elements > k\\n```\\n\\n# Approach\\n\\n1. Find index of k\\n2. Check either left or right of k first, arbitrarily, checking right\\n3. Store in a map the count of times a particular diff occurs to the right, keyed off of smaller to larger diff\\n4. Proceed left, using that map, checking for when the above intuition conditions occur (either the balance between the number of smaller/larger is 0 or larger is 1 greater)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(m)$$ where $$m$$ is the number of diffs between numbers larger/smaller than $$k$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountSubarrays(int[] nums, int k) {\\n        if (nums.Length == 0) {\\n            return 0;\\n        } else if (k == 0) {\\n            return 0;\\n        }\\n\\n        int kIndex = 0;\\n        while (nums[kIndex] != k) {\\n            kIndex++;\\n        }\\n\\n        Dictionary<int, int> diff = new Dictionary<int, int>();\\n        int weight = 0;\\n        for (int i = kIndex; i < nums.Length; i++) {\\n            weight += nums[i] == k ? 0 : nums[i] > k ? 1 : -1;\\n            if (!diff.ContainsKey(weight)) {\\n                diff.Add(weight, 0);\\n            }\\n            diff[weight] += 1;\\n        }\\n        \\n        int result = 0;\\n        weight = 0;\\n        for (int i = kIndex; i >= 0; i--) {\\n            weight += nums[i] == k ? 0 : nums[i] > k ? 1 : -1;\\n\\n            int zero = diff.ContainsKey(-weight) ? diff[-weight] : 0;\\n            int largerPlusOne = diff.ContainsKey(-weight + 1) ? diff[-weight + 1] : 0;\\n            result += zero + largerPlusOne;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n1. k is in the subarray\\n2. For odd length sorted subarray, k is the middle element\\n3. For even length sorted subarray, k is the left of middle element\\n```\n```\\n1. k must be in the subarray and one of the following must be true:\\n    1. # elements < k equals the # elements > k\\n    2. # elements < k is one less than the # elements > k\\n```\n```\\npublic class Solution {\\n    public int CountSubarrays(int[] nums, int k) {\\n        if (nums.Length == 0) {\\n            return 0;\\n        } else if (k == 0) {\\n            return 0;\\n        }\\n\\n        int kIndex = 0;\\n        while (nums[kIndex] != k) {\\n            kIndex++;\\n        }\\n\\n        Dictionary<int, int> diff = new Dictionary<int, int>();\\n        int weight = 0;\\n        for (int i = kIndex; i < nums.Length; i++) {\\n            weight += nums[i] == k ? 0 : nums[i] > k ? 1 : -1;\\n            if (!diff.ContainsKey(weight)) {\\n                diff.Add(weight, 0);\\n            }\\n            diff[weight] += 1;\\n        }\\n        \\n        int result = 0;\\n        weight = 0;\\n        for (int i = kIndex; i >= 0; i--) {\\n            weight += nums[i] == k ? 0 : nums[i] > k ? 1 : -1;\\n\\n            int zero = diff.ContainsKey(-weight) ? diff[-weight] : 0;\\n            int largerPlusOne = diff.ContainsKey(-weight + 1) ? diff[-weight + 1] : 0;\\n            result += zero + largerPlusOne;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854832,
                "title": "python-map-each-item-to-1-0-1-prefix-sum",
                "content": "If you like my solution, please upvote:)\\n\\nBased on the median definition in this problem, it does not matter what the value of each entry in the array: we only need to know the entry is above median, equal to median or below median.\\n\\nTherefore we do the mapping for each entry num in the array as follows:\\n1. num --> 1 if num > median\\n2. num -->0 if num == median\\n3. num -->-1 if num < median\\n\\nif there is no median in the array, there is no subarray, answer is 0\\n\\nOtherwise, find the index of the entry of the median (num == 0),  idx\\n\\nThe subarray should contain the idx and the sum of the subarray would be zero (if the length of subarray is odd) or one (if the length of subwarray is even)\\n\\nFind the presum of the mapped array nums, presum\\n Do the frequency table on the [0] + presum[:idx] and presum[idx:] respectively, counter_f and counter_b respectively\\n \\n This way can find for the key in counter_f, if key or key + 1 in counter_b, which gives the sum of subarray of 0 and 1 respectively.\\n\\n```\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        if k not in nums:\\n            return 0\\n        idx = nums.index(k)\\n        \\n        res = []\\n        for i, num in enumerate(nums):\\n            if num == k: res.append(0)\\n            elif num > k: res.append(1)\\n            else: res.append(-1)\\n                \\n        presum = list(accumulate(res))\\n        \\n        counter_f, counter_b = Counter([0] + presum[:idx]), Counter(presum[idx:]), \\n        res  =  0\\n        \\n        for front, val in counter_f.items():\\n            if front in counter_b:\\n                res += val * counter_b[front]\\n            if front + 1 in counter_b:\\n                res += val * counter_b[front + 1]\\n        \\n        return res\\n\\n\\n```\\n\\nRuntime: 508 ms, faster than 100.00% of Python3 online submissions for Count Subarrays With Median K.\\nMemory Usage: 28.4 MB, less than 85.71% of Python3 online submissions for Count Subarrays With Median K.\\n",
                "solutionTags": [],
                "code": "```\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        if k not in nums:\\n            return 0\\n        idx = nums.index(k)\\n        \\n        res = []\\n        for i, num in enumerate(nums):\\n            if num == k: res.append(0)\\n            elif num > k: res.append(1)\\n            else: res.append(-1)\\n                \\n        presum = list(accumulate(res))\\n        \\n        counter_f, counter_b = Counter([0] + presum[:idx]), Counter(presum[idx:]), \\n        res  =  0\\n        \\n        for front, val in counter_f.items():\\n            if front in counter_b:\\n                res += val * counter_b[front]\\n            if front + 1 in counter_b:\\n                res += val * counter_b[front + 1]\\n        \\n        return res\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2854233,
                "title": "java-simple-solution-o-n",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countSubarrays(int[] nums, int k) {\\n\\t\\t\\tint n = nums.length;\\n\\t\\t\\tint[] dp = new int[n];\\n\\t\\t\\tint idx = -1;\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tdp[i] = nums[i] < k ? -1 : (nums[i] > k ? 1 : 0);\\n\\t\\t\\t\\tif(nums[i] == k)\\n\\t\\t\\t\\t\\tidx = i;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++)\\n\\t\\t\\t\\tdp[i] += dp[i - 1];\\n\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tHashMap<Integer, Integer> hm = new HashMap();\\n\\t\\t\\thm.put(0, 1);\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tif(i >= idx) {\\n\\t\\t\\t\\t\\tif(hm.containsKey(dp[i])) \\n\\t\\t\\t\\t\\t\\tcount += hm.get(dp[i]);\\n\\t\\t\\t\\t\\tif(hm.containsKey(dp[i] - 1))\\n\\t\\t\\t\\t\\t\\tcount += hm.get(dp[i] - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\thm.put(dp[i], hm.getOrDefault(dp[i], 0) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countSubarrays(int[] nums, int k) {\\n\\t\\t\\tint n = nums.length;\\n\\t\\t\\tint[] dp = new int[n];\\n\\t\\t\\tint idx = -1;\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tdp[i] = nums[i] < k ? -1 : (nums[i] > k ? 1 : 0);\\n\\t\\t\\t\\tif(nums[i] == k)\\n\\t\\t\\t\\t\\tidx = i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2853869,
                "title": "hashmap-total-count",
                "content": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int i = 0, count = 0;\\n        while(nums[i] != k) i++;\\n        \\n        int j = i, total = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        while(j >= 0) {\\n            total += nums[j] == k ? 0 : nums[j] > k ? 1 : -1;\\n            hm.put(total, hm.getOrDefault(total, 0) + 1);\\n            j--;\\n        }\\n        j = i;\\n        total = 0;\\n        while(j < nums.length) {\\n            total += nums[j] == k ? 0 : nums[j] > k ? 1 : -1;\\n            count += hm.getOrDefault(-total, 0) + hm.getOrDefault(-total + 1, 0);\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int i = 0, count = 0;\\n        while(nums[i] != k) i++;\\n        \\n        int j = i, total = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        while(j >= 0) {\\n            total += nums[j] == k ? 0 : nums[j] > k ? 1 : -1;\\n            hm.put(total, hm.getOrDefault(total, 0) + 1);\\n            j--;\\n        }\\n        j = i;\\n        total = 0;\\n        while(j < nums.length) {\\n            total += nums[j] == k ? 0 : nums[j] > k ? 1 : -1;\\n            count += hm.getOrDefault(-total, 0) + hm.getOrDefault(-total + 1, 0);\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853733,
                "title": "using-properties-of-medians-of-numbers",
                "content": "# Intuition\\nwhen checking if the median of a set of numbers is equal to k, we only need to check if each number is greater than, less than, or equal to k. So we can just replace all the numbers < k to be -1, == k to be 0, > k to be 1. From there, the median of a subarray is k if and only if the sum of that subarray is either 0 or 1 and it contains k.\\n\\n# Approach\\nSince we are counting subarrays sums, we can do a prefix sum on nums. Since we want the subarray to contain k, we can have the end of the subarray be after k and the start to be before. Then, use a HashMap to count the number of times each value appears before k. Then, for each value after k add the number of times prefSum[i] appears or prefSum[i]-1 appears. Add all this to the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        // find the position of k\\n        int pos = 0;\\n        for(int i = 0; i<nums.length; i++) if(nums[i] == k) pos = i;\\n\\n        // converting to either -1, 0, 1\\n        for(int i = 0; i<nums.length; i++) nums[i] = nums[i] == k ? 0:(nums[i] > k ? 1:-1);\\n\\n        // prefix sum\\n        for(int i = 1; i<nums.length; i++) nums[i]+=nums[i-1];\\n\\n        // count of number\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        cnt.put(0, 1);\\n\\n        // counts before the position of k\\n        for(int i = 0; i<pos; i++){\\n            Integer get = cnt.get(nums[i]);\\n            if(get == null) get = 0;\\n            cnt.put(nums[i], get+1);\\n        }\\n\\n        // adds to answer after the position of k\\n        int ans = 0;\\n        for(int i = pos; i<nums.length; i++){\\n            Integer a = cnt.get(nums[i]), b = cnt.get(nums[i]-1);\\n            if(a == null) a = 0;\\n            if(b == null) b = 0;\\n            ans+=a+b;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        // find the position of k\\n        int pos = 0;\\n        for(int i = 0; i<nums.length; i++) if(nums[i] == k) pos = i;\\n\\n        // converting to either -1, 0, 1\\n        for(int i = 0; i<nums.length; i++) nums[i] = nums[i] == k ? 0:(nums[i] > k ? 1:-1);\\n\\n        // prefix sum\\n        for(int i = 1; i<nums.length; i++) nums[i]+=nums[i-1];\\n\\n        // count of number\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        cnt.put(0, 1);\\n\\n        // counts before the position of k\\n        for(int i = 0; i<pos; i++){\\n            Integer get = cnt.get(nums[i]);\\n            if(get == null) get = 0;\\n            cnt.put(nums[i], get+1);\\n        }\\n\\n        // adds to answer after the position of k\\n        int ans = 0;\\n        for(int i = pos; i<nums.length; i++){\\n            Integer a = cnt.get(nums[i]), b = cnt.get(nums[i]-1);\\n            if(a == null) a = 0;\\n            if(b == null) b = 0;\\n            ans+=a+b;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853622,
                "title": "python-counting-balancing-left-and-right-sides",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, A: List[int], k: int) -> int:\\n        if k not in A: return 0\\n        \\n        index, count, curr_state = A.index(k), Counter(), 0\\n        \\n        b = lambda x: (0 if x == k else (-1 if x < k else 1))\\n        \\n        for i in range(index, -1, -1):\\n            curr_state += b(A[i])            \\n            count[curr_state] += 1\\n                    \\n        curr_state = result = 0\\n        \\n        for i in range(index, len(A)):\\n            curr_state += b(A[i])\\n            result += count[-curr_state + 1] + count[-curr_state]\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, A: List[int], k: int) -> int:\\n        if k not in A: return 0\\n        \\n        index, count, curr_state = A.index(k), Counter(), 0\\n        \\n        b = lambda x: (0 if x == k else (-1 if x < k else 1))\\n        \\n        for i in range(index, -1, -1):\\n            curr_state += b(A[i])            \\n            count[curr_state] += 1\\n                    \\n        curr_state = result = 0\\n        \\n        for i in range(index, len(A)):\\n            curr_state += b(A[i])\\n            result += count[-curr_state + 1] + count[-curr_state]\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853421,
                "title": "c-one-pass-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& A, int k) {\\n        int preSum = 0, ans = 0;\\n        unordered_map<int, int> mp[2];\\n        mp[1][0] = 1;\\n        for(int i = 0, p = -1; i < A.size(); i++) {\\n            preSum  +=  A[i] > k ? 1 : A[i] < k ? -1 : 0;\\n            if(p < 0 && A[i] == k) p = i;\\n            if(p < 0) mp[i%2][preSum]++;\\n            else ans +=  mp[1-(p%2)][preSum-((i-p)%2)] + mp[p%2][preSum-(1-((i-p)%2))];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& A, int k) {\\n        int preSum = 0, ans = 0;\\n        unordered_map<int, int> mp[2];\\n        mp[1][0] = 1;\\n        for(int i = 0, p = -1; i < A.size(); i++) {\\n            preSum  +=  A[i] > k ? 1 : A[i] < k ? -1 : 0;\\n            if(p < 0 && A[i] == k) p = i;\\n            if(p < 0) mp[i%2][preSum]++;\\n            else ans +=  mp[1-(p%2)][preSum-((i-p)%2)] + mp[p%2][preSum-(1-((i-p)%2))];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853278,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> m;\\n    \\n        int idx = 0;\\n\\n        for(int i = 0; i < nums.size();i++){\\n            if(nums[i] == k){\\n               idx = i;\\n               break;\\n            }\\n        }\\n         \\n        int sum = 0;\\n        for(int i = idx; i >= 0;i--){\\n            if(nums[i] < k){\\n              sum--;\\n            }\\n            else if(nums[i] > k){\\n                sum++;\\n            }\\n\\n            m[sum]++;\\n        }\\n\\n        sum = 0;\\n        int ans = 0;\\n\\n        for(int i = idx;i < n;i++){\\n            if(nums[i] < k){\\n              sum--;\\n            }\\n\\n            else if(nums[i] > k){\\n                sum++;\\n            }\\n\\n            ans += m[-sum]; // -(sum)\\n            ans += m[-sum+1]; // -(sum - 1)\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> m;\\n    \\n        int idx = 0;\\n\\n        for(int i = 0; i < nums.size();i++){\\n            if(nums[i] == k){\\n               idx = i;\\n               break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2853253,
                "title": "c-hashmap-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int ans=0;\\n        int pivot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k){\\n                pivot=i;\\n                break;\\n            }\\n        }\\n        unordered_map<int,int> map1;\\n        map1[-1]=1;\\n        int sum=-1;\\n        cout<<pivot<<endl;\\n        for(int i=pivot-1;i>=0;i--){\\n            if(nums[i]<nums[pivot]){\\n                \\n                sum--;\\n            }\\n            else{\\n                sum++;\\n            }\\n            \\n            map1[sum]++;\\n            if(sum==0 || sum==-1) ans++;\\n        }\\n        sum=0;\\n        for(int i=pivot+1;i<nums.size();i++){\\n            if(nums[i]<nums[pivot]){\\n                sum--;\\n            }\\n            else sum++;\\n            cout<<sum<<\" \"<<map1[sum*(-1)]<<\" \"<<map1[(sum+1)*-1]<<endl;\\n            ans+=map1[sum*(-1)]+map1[(sum+1)*(-1)];\\n           \\n        }\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int ans=0;\\n        int pivot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k){\\n                pivot=i;\\n                break;\\n            }\\n        }\\n        unordered_map<int,int> map1;\\n        map1[-1]=1;\\n        int sum=-1;\\n        cout<<pivot<<endl;\\n        for(int i=pivot-1;i>=0;i--){\\n            if(nums[i]<nums[pivot]){\\n                \\n                sum--;\\n            }\\n            else{\\n                sum++;\\n            }\\n            \\n            map1[sum]++;\\n            if(sum==0 || sum==-1) ans++;\\n        }\\n        sum=0;\\n        for(int i=pivot+1;i<nums.size();i++){\\n            if(nums[i]<nums[pivot]){\\n                sum--;\\n            }\\n            else sum++;\\n            cout<<sum<<\" \"<<map1[sum*(-1)]<<\" \"<<map1[(sum+1)*-1]<<endl;\\n            ans+=map1[sum*(-1)]+map1[(sum+1)*(-1)];\\n           \\n        }\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2853038,
                "title": "simple-approach-using-map",
                "content": "Now Since elements are all distinct so for a subarray to have k as median it must have the index i s.t a[i]=k as part of it\\n\\nNow index i divides subarray into prefix and suffix. Lets say \\n**lp - no of elements <= k  in the prefix**\\n**ls - no of elements <= k  in the suffix**\\n**mp - no of elements > k  in the prefix**\\n**ms - no of elements > k  in the suffix**\\n\\nFor the subarry to have k as median there are two possible ways\\n\\n**lp + ls = mp + ms** or **lp + ls = mp+ms+1**\\n\\nSo we create map to store the results in prefix and then for every index in the suffix part we try to find out the no of subarrays which will end at that index and have same median as k\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& a, int k) {\\n        int ik=0,n=a.size();\\n        for(int i=0;i<n;i++){\\n            if(a[i]==k){\\n                ik=i;\\n                break;\\n            }\\n        }\\n        \\n        unordered_map<int,int> mpl;\\n        int l=0,m=0,ans=0;\\n        \\n        for(int i=ik;i>=0;i--){\\n            if(a[i]<=k)\\n                l++;\\n            else\\n                m++;\\n            mpl[l-m]++;\\n        }\\n        \\n        l=-1;m=0;\\n        for(int i=ik;i<n;i++){\\n            if(a[i]<=k)\\n                l++;\\n            else\\n                m++;              \\n            ans+=mpl[m-l+1]+mpl[m-l];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& a, int k) {\\n        int ik=0,n=a.size();\\n        for(int i=0;i<n;i++){\\n            if(a[i]==k){\\n                ik=i;\\n                break;\\n            }\\n        }\\n        \\n        unordered_map<int,int> mpl;\\n        int l=0,m=0,ans=0;\\n        \\n        for(int i=ik;i>=0;i--){\\n            if(a[i]<=k)\\n                l++;\\n            else\\n                m++;\\n            mpl[l-m]++;\\n        }\\n        \\n        l=-1;m=0;\\n        for(int i=ik;i<n;i++){\\n            if(a[i]<=k)\\n                l++;\\n            else\\n                m++;              \\n            ans+=mpl[m-l+1]+mpl[m-l];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852811,
                "title": "c-solution-subarray-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int p = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                p = i;\\n                break;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < k) {\\n                nums[i] = -1;\\n            } else if (nums[i] > k) {\\n                nums[i] = 1;\\n            } else {\\n                nums[i] = 0;\\n            }\\n        }\\n        map<int, int> freq;\\n        int sol = 0;\\n        int sum = 0;\\n        ++freq[sum];\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            if (i < p) {\\n                ++freq[sum];\\n            } else if (i >= p) {\\n                sol += freq[sum];\\n                sol += freq[sum - 1];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int p = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                p = i;\\n                break;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < k) {\\n                nums[i] = -1;\\n            } else if (nums[i] > k) {\\n                nums[i] = 1;\\n            } else {\\n                nums[i] = 0;\\n            }\\n        }\\n        map<int, int> freq;\\n        int sol = 0;\\n        int sum = 0;\\n        ++freq[sum];\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            if (i < p) {\\n                ++freq[sum];\\n            } else if (i >= p) {\\n                sol += freq[sum];\\n                sol += freq[sum - 1];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852766,
                "title": "java-2-solutions",
                "content": "# 2.two passes\\n```\\n\\t//2.two passes\\n    //Runtime: 18 ms, faster than 80.00% of Java online submissions for Count Subarrays With Median K.\\n    //Memory Usage: 56 MB, less than 60.00% of Java online submissions for Count Subarrays With Median K.\\n    //Time: O(N + N); Space:O(N)\\n    //Time: O(N); Space:O(N)\\n    public int countSubarrays(int[] nums, int k) {\\n        int res = 0, idx = -1;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, sum = 0; i < nums.length; i++) {\\n            if (nums[i] == k) idx = i;\\n            nums[i] = nums[i] == k ? 0 : nums[i] > k ?  1 : -1;\\n\\n            //count in right part\\n            if (idx >= 0) {\\n                sum += nums[i];\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n\\n        for (int i = idx, sum = 0; i >= 0; i--) {\\n            sum += nums[i];\\n            res += map.getOrDefault(-sum, 0) + map.getOrDefault(-sum + 1, 0);\\n        }\\n        return res;\\n    }\\n```\\n# 1.brute force\\n```\\n    //1.brute force\\n    //TLE\\n    //Time: O(N + N * N); Space: O(1)\\n    public int countSubarrays_1(int[] nums, int k) {\\n        int idx = -1, idxInOrder = 0, less = 0;\\n        int leftLen = 0, rightLen;\\n        int res = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (idx < 0) {\\n                leftLen++;\\n                if (nums[i] < k) idxInOrder++;\\n            }\\n            if (nums[i] == k) idx = i;\\n            if (idx > 0 && nums[i] < k) less++;\\n        }\\n        if (idx < 0) return res;\\n\\n        rightLen = nums.length - leftLen;\\n\\n        //Time: O(N * N)\\n        for (int i = 0; i <= idx; i++) {\\n            for (int j = idx; j < nums.length; j++) {\\n                if (j > idx && nums[j] < k) idxInOrder++;\\n\\n                int mid = (leftLen % 2 == 0) ? (leftLen / 2 - 1) : (leftLen / 2);\\n                if (idxInOrder == mid) res++;\\n\\n                leftLen++;\\n            }\\n            idxInOrder -= less;\\n            if (nums[i] < k) idxInOrder--;\\n            leftLen = leftLen - rightLen - 2;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t//2.two passes\\n    //Runtime: 18 ms, faster than 80.00% of Java online submissions for Count Subarrays With Median K.\\n    //Memory Usage: 56 MB, less than 60.00% of Java online submissions for Count Subarrays With Median K.\\n    //Time: O(N + N); Space:O(N)\\n    //Time: O(N); Space:O(N)\\n    public int countSubarrays(int[] nums, int k) {\\n        int res = 0, idx = -1;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, sum = 0; i < nums.length; i++) {\\n            if (nums[i] == k) idx = i;\\n            nums[i] = nums[i] == k ? 0 : nums[i] > k ?  1 : -1;\\n\\n            //count in right part\\n            if (idx >= 0) {\\n                sum += nums[i];\\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            }\\n        }\\n\\n        for (int i = idx, sum = 0; i >= 0; i--) {\\n            sum += nums[i];\\n            res += map.getOrDefault(-sum, 0) + map.getOrDefault(-sum + 1, 0);\\n        }\\n        return res;\\n    }\\n```\n```\\n    //1.brute force\\n    //TLE\\n    //Time: O(N + N * N); Space: O(1)\\n    public int countSubarrays_1(int[] nums, int k) {\\n        int idx = -1, idxInOrder = 0, less = 0;\\n        int leftLen = 0, rightLen;\\n        int res = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (idx < 0) {\\n                leftLen++;\\n                if (nums[i] < k) idxInOrder++;\\n            }\\n            if (nums[i] == k) idx = i;\\n            if (idx > 0 && nums[i] < k) less++;\\n        }\\n        if (idx < 0) return res;\\n\\n        rightLen = nums.length - leftLen;\\n\\n        //Time: O(N * N)\\n        for (int i = 0; i <= idx; i++) {\\n            for (int j = idx; j < nums.length; j++) {\\n                if (j > idx && nums[j] < k) idxInOrder++;\\n\\n                int mid = (leftLen % 2 == 0) ? (leftLen / 2 - 1) : (leftLen / 2);\\n                if (idxInOrder == mid) res++;\\n\\n                leftLen++;\\n            }\\n            idxInOrder -= less;\\n            if (nums[i] < k) idxInOrder--;\\n            leftLen = leftLen - rightLen - 2;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852715,
                "title": "c-using-prefix-sum-and-map-o-n-logn",
                "content": "# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> bigger(n), smaller(n);\\n        bigger[0] = (nums[0] > k);\\n        smaller[0] = (nums[0] < k);\\n        for(int i = 1; i < n; i++){\\n            bigger[i] = bigger[i - 1] + (nums[i] > k);\\n            smaller[i] = smaller[i - 1] + (nums[i] < k);\\n        }\\n        map<int, int> mp;\\n        mp[0] = 1;\\n        int idx = -1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == k){\\n                idx = i; break;\\n            }\\n        }\\n        if(idx == -1) return 0;\\n\\n        for(int i = 0; i < idx; i++){\\n            mp[bigger[i] - smaller[i]]++;\\n        }\\n\\n        int ans = 0;\\n        for(int i = idx; i < n; i++){\\n            int diff = bigger[i] - smaller[i];\\n            ans += mp[diff];\\n            ans += mp[diff - 1]; \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> bigger(n), smaller(n);\\n        bigger[0] = (nums[0] > k);\\n        smaller[0] = (nums[0] < k);\\n        for(int i = 1; i < n; i++){\\n            bigger[i] = bigger[i - 1] + (nums[i] > k);\\n            smaller[i] = smaller[i - 1] + (nums[i] < k);\\n        }\\n        map<int, int> mp;\\n        mp[0] = 1;\\n        int idx = -1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == k){\\n                idx = i; break;\\n            }\\n        }\\n        if(idx == -1) return 0;\\n\\n        for(int i = 0; i < idx; i++){\\n            mp[bigger[i] - smaller[i]]++;\\n        }\\n\\n        int ans = 0;\\n        for(int i = idx; i < n; i++){\\n            int diff = bigger[i] - smaller[i];\\n            ans += mp[diff];\\n            ans += mp[diff - 1]; \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852671,
                "title": "prefix-sum-o-n-time-and-space-java",
                "content": "# Intuition\\n\\nTHIS PROBLEM REDUCES TO FINDING NUMBER OF SUBARRAYS WITH SUM EITHER 1 or 0.\\n\\nFIRST MODIFY THE ARRAY, replace each element in the array with -1 or 0 or 1. \\n\\nif subarray sum is 0, it means that there are odd number of elements and median is k.\\nif subarray sum is 1, it means there are even number of elements and the median is k, since in this case, the lower middle is the meian.\\n\\n# Approach\\nMODIFY THE ARRAY AS BELOW\\n1. if a number is greater than k, it becomes 1,\\n2. if a number is lesser than k , it becomes -1,\\n3. if a number is k, it becomes 0.\\n\\nlet the index of 0 (k in the original array) be pos.\\nlet LEN be the length of the array.\\n\\nANS =   \\n        +NUMBER OF SUBARRAYS WITH SUM 0  in the ARRAY(0,LEN-1)\\n        +NUMBER OF SUBARRAYS WITH SUM 1 in the ARRAY (0,LEN-1)\\n        -NUMBER OF SUBARRAYS WITH SUM 0 in the ARRAY (0,pos-1)\\n        -NUMBER OF SUBARRAYS WITH SUM 1 in the ARRAY (0,pos-1)\\n        -NUMBER OF SUBARRAYS WITH SUM 0 in the ARRAY (pos+1, LEN-1)\\n        -NUMBER OF SUBARRAYS WITH SUM 1 in the ARRAY (pos+1, LEN-1)\\n\\n\\nconsider the case when the subaray sum is 0, but the sub array doesnt contain  the 0( k in the original array ).\\nsince we need 0 ( k in the original array ) to be the median, we subtract the number of subarrays which dont contain 0. \\nSince k  doesnt repeat in the original array, we can split the array into two distinct arrays: (0 to pos-1) and (pos+1 to LEN-1)\\n\\n# Complexity\\n- Time complexity:\\nO(N);\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]==k){\\n                nums[i]=0;\\n            }else if(nums[i]>k){\\n                nums[i] = 1;\\n            }else{\\n                nums[i] = -1;\\n            }\\n        }\\n        \\n        \\n        int ans  = 0;\\n        ans+=getCount(nums, nums.length, 1);\\n        ans+=getCount(nums, nums.length, 0);\\n        List<Integer> leftList = new ArrayList();\\n        List<Integer> rightList = new ArrayList();\\n        boolean seen = false;\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]!=0 && seen==false){\\n                leftList.add(nums[i]);\\n            }\\n            if(nums[i]!=0 && seen==true){\\n                rightList.add(nums[i]);\\n            }\\n            if(nums[i] ==0)\\n                seen = true;\\n            \\n        }\\n        int[] left = new int[leftList.size()];\\n        int j = 0;\\n        for(int pos = 0;pos<leftList.size();pos++){\\n            left[j++] = leftList.get(pos);\\n        }\\n        \\n        int[] right = new int[rightList.size()];\\n        j = 0;\\n        for(int pos = 0;pos<rightList.size();pos++){\\n            right[j++] = rightList.get(pos);\\n        }\\n        ans-=getCount(left, left.length,0);\\n        ans-=getCount(right, right.length,0);\\n        \\n        ans-=getCount(left, left.length,1);\\n        ans-=getCount(right, right.length,1);\\n        return ans;\\n    }\\n    \\n    private int getCount(int[] arr, int len, int k){\\n        Map<Integer, Integer> map = new HashMap();\\n        int[] pre = new int[len+1];\\n        for(int i = 0;i<len;i++){\\n            pre[i+1] = pre[i]+arr[i];\\n        }\\n        int ans = 0;\\n        map.put(0,1);\\n        for(int i = 0;i<len;i++){\\n            int pair = map.getOrDefault(pre[i+1]-k,0);\\n            ans+=pair;\\n            \\n            map.put(pre[i+1],map.getOrDefault(pre[i+1],0)+1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        \\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]==k){\\n                nums[i]=0;\\n            }else if(nums[i]>k){\\n                nums[i] = 1;\\n            }else{\\n                nums[i] = -1;\\n            }\\n        }\\n        \\n        \\n        int ans  = 0;\\n        ans+=getCount(nums, nums.length, 1);\\n        ans+=getCount(nums, nums.length, 0);\\n        List<Integer> leftList = new ArrayList();\\n        List<Integer> rightList = new ArrayList();\\n        boolean seen = false;\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]!=0 && seen==false){\\n                leftList.add(nums[i]);\\n            }\\n            if(nums[i]!=0 && seen==true){\\n                rightList.add(nums[i]);\\n            }\\n            if(nums[i] ==0)\\n                seen = true;\\n            \\n        }\\n        int[] left = new int[leftList.size()];\\n        int j = 0;\\n        for(int pos = 0;pos<leftList.size();pos++){\\n            left[j++] = leftList.get(pos);\\n        }\\n        \\n        int[] right = new int[rightList.size()];\\n        j = 0;\\n        for(int pos = 0;pos<rightList.size();pos++){\\n            right[j++] = rightList.get(pos);\\n        }\\n        ans-=getCount(left, left.length,0);\\n        ans-=getCount(right, right.length,0);\\n        \\n        ans-=getCount(left, left.length,1);\\n        ans-=getCount(right, right.length,1);\\n        return ans;\\n    }\\n    \\n    private int getCount(int[] arr, int len, int k){\\n        Map<Integer, Integer> map = new HashMap();\\n        int[] pre = new int[len+1];\\n        for(int i = 0;i<len;i++){\\n            pre[i+1] = pre[i]+arr[i];\\n        }\\n        int ans = 0;\\n        map.put(0,1);\\n        for(int i = 0;i<len;i++){\\n            int pair = map.getOrDefault(pre[i+1]-k,0);\\n            ans+=pair;\\n            \\n            map.put(pre[i+1],map.getOrDefault(pre[i+1],0)+1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852629,
                "title": "python3-dp-via-counter-with-thought-process",
                "content": "**Intuition**\\nLike other subarray problems, Let\\'s try to obtain valid_subarrays_start_from[idx] (or end_at[idx]) and then extend that results to idx+1 or idx-1 with O(1) time to obtain overall O(N) time complexity. \\n\\n**Observations**\\nSince valid subarrays need to contain k\\'s index, (k_idx) It would be helpful to focus on subarrays that start from k_idx, and consider this as a **base case**.\\n\\n* Input: [2,5,1,4,3,6] , k = 1\\n* In this case, k_idx = 2 (0-indexed), and subarrays start from k_idx is\\n* ```\\n   [1]           : Valid                    balance = 0\\n   [1, 4]        : Valid                    balance = 1\\n   [1, 4, 3]     : Invalid (3 is median)    balance = 2\\n   [1, 4, 3, 6]  : Invalid (3 is median)    balance = 3\\n   ```  \\n   \\n* Now, we need to clarify what differentiates valid and invalid.\\n\\t* If we define \"balance\" as \"the number of the larger number - the number of the smaller number,\"\\n\\t  * For odd-length cases, the balance must be 0.\\n\\t  * For even length cases, the balance must be 1.\\n  * It also indicates that **we need to manage counts per odd length subarrays and even length subarrays**.\\n\\n* We can define even_balance and odd_balance as a HashMap, which key is balance and the value is occurrence. And then, we register all base case\\'s subarray results to the counters.\\n\\t* If we do so, we can say `valid_subarrays_start_from[k_idx] = odd_balance[0] + even_balance[1]`\\n\\n\\n* Then,  We can use the above base case to obtain valid subarrays starting from **k_idx -1 .**\\n*  ```\\n   [5, 1]           : Valid   (even length & balance = 1)\\n   [5, 1, 4]        : InValid (odd length & balance = 2)\\n   [5, 1, 4, 3]     : Invalid (even length & balance = 3)\\n   [5, 1, 4, 3, 6]  : Invalid (odd length & balance = 4)\\n   ```  \\n   \\n* As you can see\\n\\t* Since the extend value (5) was greater than k, all balances are added by 1.\\n\\t* If it was smaller than k, all balance must have been reduced by 1.\\n    * All previous even subarrays become odd subarray, and all previous subarrays become even subarray.\\n\\n* To handle those changes,\\n\\t* Updating all counter values is costly, so rather than doing that, manage \"balance_offset\" when extending subarrays. We got a larger number in the above case, so balance_offset becomes 1 from 0.\\n\\t* Swap odd_balance and even_balance everytime we extend subarrays.\\n\\n* After applying those 2 operations, we can add the following to the total. \\n\\t* odd_balance[0-balance_offset]\\n\\t* even_balance[1-balance_offset]\\n\\n* We can Repeat the above operations until we reach index -1.\\n\\n**Code**\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        # Constants\\n        N = len(nums)\\n        k_idx = nums.index(k) # always exists\\n        \\n        # Variables\\n        odd_balance = Counter()\\n        even_balance = Counter()\\n        odd_balance[0] = 1 # for [k] itself.\\n        \\n        # Calc all balance of subslices start from k_idx, as a base.\\n        balance = 0\\n        for i in range(k_idx+1, N):\\n            if nums[i] > k:\\n                balance += 1\\n            else:\\n                balance -= 1\\n            \\n            # Select counter to update.\\n            is_odd = (i - k_idx) % 2 == 0\\n            if is_odd:\\n                odd_balance[balance] += 1 \\n            else:\\n                even_balance[balance] += 1    \\n        \\n        total = odd_balance[0] + even_balance[1]\\n        \\n        # Then, apply DP.\\n        b_offset = 0\\n        for i in range(k_idx-1, -1, -1):\\n            # Swap odd and even counter to handle subarray extension.\\n            odd_balance, even_balance = even_balance, odd_balance\\n            if nums[i] > k:\\n                b_offset += 1\\n            else:\\n                b_offset -= 1\\n            total += odd_balance[-b_offset]\\n            total += even_balance[-b_offset+1]\\n        \\n        return total\\n```\\n\\n**Complexity Analysis**\\n* Time Complexity: O(N)\\n* Memory Complexity: O(N)\\n\\n**Runtime**\\n* Runtime: 569 ms, faster than 85.71% of Python3 online submissions\\n* Memory Usage: 28.3 MB, less than 85.71% of Python3 online submissions\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n   [1]           : Valid                    balance = 0\\n   [1, 4]        : Valid                    balance = 1\\n   [1, 4, 3]     : Invalid (3 is median)    balance = 2\\n   [1, 4, 3, 6]  : Invalid (3 is median)    balance = 3\\n   ```\n```\\n   [5, 1]           : Valid   (even length & balance = 1)\\n   [5, 1, 4]        : InValid (odd length & balance = 2)\\n   [5, 1, 4, 3]     : Invalid (even length & balance = 3)\\n   [5, 1, 4, 3, 6]  : Invalid (odd length & balance = 4)\\n   ```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        # Constants\\n        N = len(nums)\\n        k_idx = nums.index(k) # always exists\\n        \\n        # Variables\\n        odd_balance = Counter()\\n        even_balance = Counter()\\n        odd_balance[0] = 1 # for [k] itself.\\n        \\n        # Calc all balance of subslices start from k_idx, as a base.\\n        balance = 0\\n        for i in range(k_idx+1, N):\\n            if nums[i] > k:\\n                balance += 1\\n            else:\\n                balance -= 1\\n            \\n            # Select counter to update.\\n            is_odd = (i - k_idx) % 2 == 0\\n            if is_odd:\\n                odd_balance[balance] += 1 \\n            else:\\n                even_balance[balance] += 1    \\n        \\n        total = odd_balance[0] + even_balance[1]\\n        \\n        # Then, apply DP.\\n        b_offset = 0\\n        for i in range(k_idx-1, -1, -1):\\n            # Swap odd and even counter to handle subarray extension.\\n            odd_balance, even_balance = even_balance, odd_balance\\n            if nums[i] > k:\\n                b_offset += 1\\n            else:\\n                b_offset -= 1\\n            total += odd_balance[-b_offset]\\n            total += even_balance[-b_offset+1]\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852568,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int countSubarrays(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    const int index_k = static_cast<int>(find(nums.begin(), nums.end(), k) - nums.begin());\\n    unordered_map<int, int> diff_to_count{{0, 1}};\\n    int diff = 0;\\n    for (int i = index_k - 1; i > -1; --i) {\\n      diff += nums[i] > k ? 1 : -1;\\n      ++diff_to_count[diff];\\n    }\\n    \\n    int ret = diff_to_count[0] + diff_to_count[1];\\n    int reversed_diff = 0;\\n    for (int i = index_k + 1; i < n; ++i) {\\n      reversed_diff += nums[i] < k ? 1 : -1;\\n      ret += diff_to_count[reversed_diff] + diff_to_count[reversed_diff + 1];\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int countSubarrays(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    const int index_k = static_cast<int>(find(nums.begin(), nums.end(), k) - nums.begin());\\n    unordered_map<int, int> diff_to_count{{0, 1}};\\n    int diff = 0;\\n    for (int i = index_k - 1; i > -1; --i) {\\n      diff += nums[i] > k ? 1 : -1;\\n      ++diff_to_count[diff];\\n    }\\n    \\n    int ret = diff_to_count[0] + diff_to_count[1];\\n    int reversed_diff = 0;\\n    for (int i = index_k + 1; i < n; ++i) {\\n      reversed_diff += nums[i] < k ? 1 : -1;\\n      ret += diff_to_count[reversed_diff] + diff_to_count[reversed_diff + 1];\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852554,
                "title": "o-n-solution-with-hash-map",
                "content": "# Intuition\\nSupposed the median is at the index m, then we are looking for pairs of indexes (i, j) where i <= m <= j, so that (the number of smaller numbers between i and m) + (the number of smaller numbers between m and j) + {0 or 1} == (the number of larger numbers between i and m) + (the number of larger numbers between m and j)\\n\\n=> (the number of smaller numbers between i and m) - (the number of larger numbers between i and m) + {0 or 1} == (the number of larger numbers between m and j) - (the number of smaller numbers between m and j)\\n\\n# Approach\\n1. find the position of the median\\n2. Starting from the median number in one direction, calculate the difference of counts of larger numbers and smaller numbers. Use a hash map to store the {differece => count}\\n3. Starting from the median number in the other direction, calculate the difference of counts of larger numbers and smaller numbers. Find whether thhere is a match in hashmap. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int m = 0;\\n        int n = nums.length;\\n        while (m < n && nums[m] != k) {\\n            m++;\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int more = 0;\\n        for (int i = m; i >= 0; i--) {\\n            if (nums[i] > k) {\\n                more++;\\n            } else if (nums[i] < k) {\\n                more--;\\n            }\\n            map.put(more, map.getOrDefault(more, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        int less = 0;\\n        for (int i = m; i < n; i++) {\\n            if (nums[i] < k) {\\n                less++;\\n            } else if (nums[i] > k) {\\n                less--;\\n            }\\n            count += map.getOrDefault(less, 0);\\n            count += map.getOrDefault(less + 1, 0);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int m = 0;\\n        int n = nums.length;\\n        while (m < n && nums[m] != k) {\\n            m++;\\n        }\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        int more = 0;\\n        for (int i = m; i >= 0; i--) {\\n            if (nums[i] > k) {\\n                more++;\\n            } else if (nums[i] < k) {\\n                more--;\\n            }\\n            map.put(more, map.getOrDefault(more, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        int less = 0;\\n        for (int i = m; i < n; i++) {\\n            if (nums[i] < k) {\\n                less++;\\n            } else if (nums[i] > k) {\\n                less--;\\n            }\\n            count += map.getOrDefault(less, 0);\\n            count += map.getOrDefault(less + 1, 0);\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852531,
                "title": "python-solution-using-map-o-n-and-o-n-similar-to-find-number-of-subarray-having-target-sum-s",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        kIndex=-1\\n        for i in range(len(nums)):\\n            if(nums[i]==k):\\n                nums[i]=0\\n                kIndex=i\\n            elif(nums[i]>k):\\n                nums[i]=1\\n            else:\\n                nums[i]=-1\\n        d={0:1}\\n        s=0\\n        ans=0\\n        for i in range(len(nums)):\\n            s+=nums[i]\\n            if(i>=kIndex):\\n                if(s-1 in d):\\n                    ans+=d[s-1]\\n                if(s in d):\\n                    ans+=d[s]\\n            else:\\n                if(s in d):\\n                    d[s]+=1\\n                else:\\n                    d[s]=1\\n        return ans\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        kIndex=-1\\n        for i in range(len(nums)):\\n            if(nums[i]==k):\\n                nums[i]=0\\n                kIndex=i\\n            elif(nums[i]>k):\\n                nums[i]=1\\n            else:\\n                nums[i]=-1\\n        d={0:1}\\n        s=0\\n        ans=0\\n        for i in range(len(nums)):\\n            s+=nums[i]\\n            if(i>=kIndex):\\n                if(s-1 in d):\\n                    ans+=d[s-1]\\n                if(s in d):\\n                    ans+=d[s]\\n            else:\\n                if(s in d):\\n                    d[s]+=1\\n                else:\\n                    d[s]=1\\n        return ans\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852485,
                "title": "easy-subarray-sum-k-java-solution",
                "content": "```\\n       public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int sum = 0, cnt = 0,res=0;\\n        Boolean b = false;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        for(int i = 0; i < n; ++i) {\\n            if(nums[i] < k) sum--;\\n            else if(nums[i] > k) sum++;\\n            else b = true;\\n            if(b) res += map.getOrDefault(sum,0) + map.getOrDefault(sum - 1,0);\\n            else map.put(sum,map.getOrDefault(sum,0)+1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n       public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int sum = 0, cnt = 0,res=0;\\n        Boolean b = false;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        for(int i = 0; i < n; ++i) {\\n            if(nums[i] < k) sum--;\\n            else if(nums[i] > k) sum++;\\n            else b = true;\\n            if(b) res += map.getOrDefault(sum,0) + map.getOrDefault(sum - 1,0);\\n            else map.put(sum,map.getOrDefault(sum,0)+1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852469,
                "title": "java-simple-count-solution-one-pass-o-n-6ms-beats-100",
                "content": "Since the value s may become negative at most -n, we start s = n and extend the cnt array into the length of 2 * n + 1. Use cnt array is simpler and faster than using HashMap in Java.\\n\\n```\\nclass Solution {\\n    // time = O(n), space = O(n)\\n    public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] cnt = new int[2 * n + 1];\\n        cnt[n]++;\\n\\n        int res = 0, s = n;\\n        boolean flag = false;\\n        for (int x : nums) {\\n            if (x > k) s++;\\n            else if (x < k) s--;\\n            if (x == k) flag = true;\\n            if (!flag) cnt[s]++;\\n            else res += cnt[s] + cnt[s - 1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // time = O(n), space = O(n)\\n    public int countSubarrays(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] cnt = new int[2 * n + 1];\\n        cnt[n]++;\\n\\n        int res = 0, s = n;\\n        boolean flag = false;\\n        for (int x : nums) {\\n            if (x > k) s++;\\n            else if (x < k) s--;\\n            if (x == k) flag = true;\\n            if (!flag) cnt[s]++;\\n            else res += cnt[s] + cnt[s - 1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852461,
                "title": "python-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        seen = collections.defaultdict(int)\\n        seen[0] = 1\\n        cnt = 0\\n        found = False\\n        res = 0\\n        for num in nums:\\n            if num > k:\\n                cnt -= 1\\n            else:\\n                cnt += 1\\n                if num == k:\\n                    found = True\\n            if found:\\n                res += seen[cnt]\\n                res += seen[cnt - 1]\\n            else:\\n                seen[cnt] += 1\\n        return res\\n\\n\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        seen.put(0, 1);\\n        int cnt = 0;\\n        boolean found = false;\\n        int res = 0;\\n        for (int num: nums) {\\n            if (num > k) {\\n                cnt --;\\n            } else {\\n                cnt ++;\\n                if (num == k) {\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                if (seen.containsKey(cnt)) {\\n                    res += seen.get(cnt);\\n                }\\n                if (seen.containsKey(cnt - 1)) {\\n                    res += seen.get(cnt - 1);\\n                }\\n            } else {\\n                seen.put(cnt, seen.getOrDefault(cnt, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        seen = collections.defaultdict(int)\\n        seen[0] = 1\\n        cnt = 0\\n        found = False\\n        res = 0\\n        for num in nums:\\n            if num > k:\\n                cnt -= 1\\n            else:\\n                cnt += 1\\n                if num == k:\\n                    found = True\\n            if found:\\n                res += seen[cnt]\\n                res += seen[cnt - 1]\\n            else:\\n                seen[cnt] += 1\\n        return res\\n\\n\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        seen.put(0, 1);\\n        int cnt = 0;\\n        boolean found = false;\\n        int res = 0;\\n        for (int num: nums) {\\n            if (num > k) {\\n                cnt --;\\n            } else {\\n                cnt ++;\\n                if (num == k) {\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                if (seen.containsKey(cnt)) {\\n                    res += seen.get(cnt);\\n                }\\n                if (seen.containsKey(cnt - 1)) {\\n                    res += seen.get(cnt - 1);\\n                }\\n            } else {\\n                seen.put(cnt, seen.getOrDefault(cnt, 0) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852418,
                "title": "javascript-hashmap-129ms",
                "content": "```\\nconst countSubarrays = (a, k) => permutationArrayWithMedianK(a, k);\\n\\nconst permutationArrayWithMedianK = (a, k) => {\\n    let m = new Map([[0, 1]]), find = false, balance = 0, res = 0;\\n    for (const x of a) {\\n        if (x < k) {\\n            balance--;\\n        } else if (x > k) {\\n            balance++;\\n        } else {\\n            find = true;\\n        }\\n        if (find) {\\n            // balance - 1, subarray length is even, has one more right\\n            res += (m.get(balance) || 0) + (m.get(balance - 1) || 0);\\n        } else {\\n            m.set(balance, m.get(balance) + 1 || 1);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nconst countSubarrays = (a, k) => permutationArrayWithMedianK(a, k);\\n\\nconst permutationArrayWithMedianK = (a, k) => {\\n    let m = new Map([[0, 1]]), find = false, balance = 0, res = 0;\\n    for (const x of a) {\\n        if (x < k) {\\n            balance--;\\n        } else if (x > k) {\\n            balance++;\\n        } else {\\n            find = true;\\n        }\\n        if (find) {\\n            // balance - 1, subarray length is even, has one more right\\n            res += (m.get(balance) || 0) + (m.get(balance - 1) || 0);\\n        } else {\\n            m.set(balance, m.get(balance) + 1 || 1);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852417,
                "title": "counting-the-difference-between-the-number-of-larger-and-smaller-numbers",
                "content": "# Approach\\nThe difference between the number of larger and smaller numbers can be 0 or 1. Traverse subarrays starting from 0 to index of k. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int CountSubarrays(int[] nums, int k)\\n    {\\n        int n = nums.Length;\\n        \\n        int i = 0;\\n        int diff1 = 0;\\n        while (nums[i] != k)\\n        {\\n            if (nums[i] < k)\\n            {\\n                diff1--;\\n            }\\n            else if (nums[i] > k)\\n            {\\n                diff1++;\\n            }\\n\\n            i++;\\n        }\\n        \\n        var dict = new Dictionary<int, int>();\\n\\n        int diff2 = 0;\\n        for (int j = i; j < n; j++)\\n        {\\n            if (nums[j] < k)\\n            {\\n                diff2--;\\n            }\\n            else if (nums[j] > k)\\n            {\\n                diff2++;\\n            }\\n\\n            if (!dict.ContainsKey(diff2))\\n            {\\n                dict.Add(diff2, 0);\\n            }\\n            dict[diff2]++;\\n        }\\n\\n        int count = 0;\\n\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (dict.ContainsKey(-diff1))\\n            {\\n                count += dict[-diff1];\\n            }\\n            if (dict.ContainsKey(1 - diff1))\\n            {\\n                count += dict[1 - diff1];\\n            }\\n\\n            if (nums[j] < k)\\n            {\\n                diff1++;\\n            }\\n            else if (nums[j] > k)\\n            {\\n                diff1--;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int CountSubarrays(int[] nums, int k)\\n    {\\n        int n = nums.Length;\\n        \\n        int i = 0;\\n        int diff1 = 0;\\n        while (nums[i] != k)\\n        {\\n            if (nums[i] < k)\\n            {\\n                diff1--;\\n            }\\n            else if (nums[i] > k)\\n            {\\n                diff1++;\\n            }\\n\\n            i++;\\n        }\\n        \\n        var dict = new Dictionary<int, int>();\\n\\n        int diff2 = 0;\\n        for (int j = i; j < n; j++)\\n        {\\n            if (nums[j] < k)\\n            {\\n                diff2--;\\n            }\\n            else if (nums[j] > k)\\n            {\\n                diff2++;\\n            }\\n\\n            if (!dict.ContainsKey(diff2))\\n            {\\n                dict.Add(diff2, 0);\\n            }\\n            dict[diff2]++;\\n        }\\n\\n        int count = 0;\\n\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (dict.ContainsKey(-diff1))\\n            {\\n                count += dict[-diff1];\\n            }\\n            if (dict.ContainsKey(1 - diff1))\\n            {\\n                count += dict[1 - diff1];\\n            }\\n\\n            if (nums[j] < k)\\n            {\\n                diff1++;\\n            }\\n            else if (nums[j] > k)\\n            {\\n                diff1--;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852403,
                "title": "java-simple-o-n",
                "content": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == k) {\\n                Map<Integer, Integer> mapL = new HashMap<>();\\n                int lqtK = 0;\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if (nums[j] <= k)\\n                        lqtK++;\\n                    int size = i - j;\\n                    int diff = lqtK - (size - lqtK);\\n                    mapL.put(diff, mapL.getOrDefault(diff, 0) + 1);\\n                }\\n                res += mapL.getOrDefault(0, 0) + mapL.getOrDefault(-1, 0); // right choose non\\n                mapL.put(0, mapL.getOrDefault(0, 0) + 1); // left choose non\\n                lqtK = 0;\\n                for (int j = i + 1; j < nums.length; j++) {\\n                    if (nums[j] <= k)\\n                        lqtK++;\\n                    int size = j - i;\\n                    int diff = lqtK - (size - lqtK);\\n                    res += mapL.getOrDefault(-diff, 0) + mapL.getOrDefault(-diff - 1, 0);\\n                }\\n                return res + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == k) {\\n                Map<Integer, Integer> mapL = new HashMap<>();\\n                int lqtK = 0;\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if (nums[j] <= k)\\n                        lqtK++;\\n                    int size = i - j;\\n                    int diff = lqtK - (size - lqtK);\\n                    mapL.put(diff, mapL.getOrDefault(diff, 0) + 1);\\n                }\\n                res += mapL.getOrDefault(0, 0) + mapL.getOrDefault(-1, 0); // right choose non\\n                mapL.put(0, mapL.getOrDefault(0, 0) + 1); // left choose non\\n                lqtK = 0;\\n                for (int j = i + 1; j < nums.length; j++) {\\n                    if (nums[j] <= k)\\n                        lqtK++;\\n                    int size = j - i;\\n                    int diff = lqtK - (size - lqtK);\\n                    res += mapL.getOrDefault(-diff, 0) + mapL.getOrDefault(-diff - 1, 0);\\n                }\\n                return res + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852400,
                "title": "based-on-megamind-great-idea-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countSubarrays = function (nums, k) {\\n  const LEN = nums.length;\\n  let kIdx;\\n  for (let i = 0; i < LEN; i++) {\\n    let val = nums[i];\\n    if (val < k) nums[i] = -1;\\n    else if (val > k) nums[i] = 1;\\n    else {\\n      nums[i] = 0;\\n      kIdx = i;\\n    }\\n  }\\n\\n  let map = new Map();\\n  let sum = 0;\\n  for (let i = kIdx; i >= 0; i--) {\\n    sum += nums[i];\\n    let freq = map.get(sum) || 0;\\n    freq++;\\n    map.set(sum, freq);\\n  }\\n\\n  sum = 0;\\n  let ans = 0;\\n  for (let i = kIdx; i < LEN; i++) {\\n    sum += nums[i];\\n    let opposit = 0 - sum;\\n    if (map.has(opposit)) ans += map.get(opposit);\\n\\n    opposit += 1;\\n    if (map.has(opposit)) ans += map.get(opposit);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countSubarrays = function (nums, k) {\\n  const LEN = nums.length;\\n  let kIdx;\\n  for (let i = 0; i < LEN; i++) {\\n    let val = nums[i];\\n    if (val < k) nums[i] = -1;\\n    else if (val > k) nums[i] = 1;\\n    else {\\n      nums[i] = 0;\\n      kIdx = i;\\n    }\\n  }\\n\\n  let map = new Map();\\n  let sum = 0;\\n  for (let i = kIdx; i >= 0; i--) {\\n    sum += nums[i];\\n    let freq = map.get(sum) || 0;\\n    freq++;\\n    map.set(sum, freq);\\n  }\\n\\n  sum = 0;\\n  let ans = 0;\\n  for (let i = kIdx; i < LEN; i++) {\\n    sum += nums[i];\\n    let opposit = 0 - sum;\\n    if (map.has(opposit)) ans += map.get(opposit);\\n\\n    opposit += 1;\\n    if (map.has(opposit)) ans += map.get(opposit);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852385,
                "title": "python3-balance-prefix-and-postfix-count-with-detailed-precomputations",
                "content": "```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        index = nums.index(k)\\n\\n        balances = []\\n        for num in nums:\\n            if num < k:\\n                balances.append(-1)\\n            elif num > k:\\n                balances.append(1)\\n            else:\\n                balances.append(0)\\n\\n        prefix_sum = [0]\\n        for num in balances[index+1:]:\\n            prefix_sum.append(prefix_sum[-1] + num)\\n        \\n        postfix_sum = [0]\\n        for num in balances[:index][::-1]:\\n            postfix_sum.append(postfix_sum[-1] + num)\\n        postfix_count = Counter(postfix_sum)\\n\\n        res = 0\\n        for i in range(index, n):\\n            balance = prefix_sum[i - index]\\n            res += postfix_count[1 - balance] + postfix_count[0 - balance]\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        index = nums.index(k)\\n\\n        balances = []\\n        for num in nums:\\n            if num < k:\\n                balances.append(-1)\\n            elif num > k:\\n                balances.append(1)\\n            else:\\n                balances.append(0)\\n\\n        prefix_sum = [0]\\n        for num in balances[index+1:]:\\n            prefix_sum.append(prefix_sum[-1] + num)\\n        \\n        postfix_sum = [0]\\n        for num in balances[:index][::-1]:\\n            postfix_sum.append(postfix_sum[-1] + num)\\n        postfix_count = Counter(postfix_sum)\\n\\n        res = 0\\n        for i in range(index, n):\\n            balance = prefix_sum[i - index]\\n            res += postfix_count[1 - balance] + postfix_count[0 - balance]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852360,
                "title": "map",
                "content": "```\\n    \\nint countSubarrays (const vector<int>&nums, int k){\\nint val = 0;\\n        map<int, int> m;\\n        m[0] = 1; // just idx\\n        int idx = find(nums.begin(), nums.end(), k) - nums.begin();\\n\\n        for (int i = idx - 1; i >= 0; i--) { // everything before k in array \\n            if (nums[i] > k) val += 1;\\n            else val -= 1;\\n            m[val] += 1;\\n        }\\n\\n        int val2 = 0;\\n\\n\\n        int ans = m[0] + m[1];\\n        for (int i = idx + 1; i < nums.size(); i++) { // everything after k in array \\n            if (nums[i] > k) val2 += 1;\\n            else val2 -= 1;\\n            ans += m[-val2] + m[-val2 + 1]; // need to include k \\n        }\\n        return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    \\nint countSubarrays (const vector<int>&nums, int k){\\nint val = 0;\\n        map<int, int> m;\\n        m[0] = 1; // just idx\\n        int idx = find(nums.begin(), nums.end(), k) - nums.begin();\\n\\n        for (int i = idx - 1; i >= 0; i--) { // everything before k in array \\n            if (nums[i] > k) val += 1;\\n            else val -= 1;\\n            m[val] += 1;\\n        }\\n\\n        int val2 = 0;\\n\\n\\n        int ans = m[0] + m[1];\\n        for (int i = idx + 1; i < nums.size(); i++) { // everything after k in array \\n            if (nums[i] > k) val2 += 1;\\n            else val2 -= 1;\\n            ans += m[-val2] + m[-val2 + 1]; // need to include k \\n        }\\n        return ans;\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852358,
                "title": "python-o-n-solution-balance-either-side",
                "content": "\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countSubarrays(self, nums: list[int], k: int) -> int:\\n\\n        for kIndex, v in enumerate(nums):\\n            if v == k:\\n                break\\n\\n        dLeft = defaultdict(lambda: 0)\\n        lessThanK = 0\\n        greaterThanK = 0\\n        for i in range(kIndex-1, -1, -1):\\n            v = nums[i]\\n            if v < k:\\n                lessThanK += 1\\n            else:\\n                greaterThanK += 1\\n            dLeft[greaterThanK - lessThanK] += 1\\n\\n        dRight = defaultdict(lambda: 0)\\n        lessThanK = 0\\n        greaterThanK = 0\\n        for i in range(kIndex + 1, len(nums)):\\n            v = nums[i]\\n            if v < k:\\n                lessThanK += 1\\n            else:\\n                greaterThanK += 1\\n            dRight[greaterThanK - lessThanK] += 1\\n\\n        total = 1 + dLeft[0] + dRight[0] + dLeft[1] + dRight[1]\\n        for k,v in dLeft.items():\\n            total += v * dRight[0-k]\\n            total += v * dRight[0-k+1]\\n\\n        return total\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def countSubarrays(self, nums: list[int], k: int) -> int:\\n\\n        for kIndex, v in enumerate(nums):\\n            if v == k:\\n                break\\n\\n        dLeft = defaultdict(lambda: 0)\\n        lessThanK = 0\\n        greaterThanK = 0\\n        for i in range(kIndex-1, -1, -1):\\n            v = nums[i]\\n            if v < k:\\n                lessThanK += 1\\n            else:\\n                greaterThanK += 1\\n            dLeft[greaterThanK - lessThanK] += 1\\n\\n        dRight = defaultdict(lambda: 0)\\n        lessThanK = 0\\n        greaterThanK = 0\\n        for i in range(kIndex + 1, len(nums)):\\n            v = nums[i]\\n            if v < k:\\n                lessThanK += 1\\n            else:\\n                greaterThanK += 1\\n            dRight[greaterThanK - lessThanK] += 1\\n\\n        total = 1 + dLeft[0] + dRight[0] + dLeft[1] + dRight[1]\\n        for k,v in dLeft.items():\\n            total += v * dRight[0-k]\\n            total += v * dRight[0-k+1]\\n\\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852341,
                "title": "top-python-answer-using-a-dictionary-hashmap-key-count-of-nums-greater-than-median-on-right",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nStart at the median and store the count of number greater than the median to the right of the median.\\n\\nStart at the median and count the number smaller than the median to the left and add the HM values of that count to the result.\\n\\nNeed to add both HM[0] and HM[1] since a median can happen if there is no number greater or smaller, or if there is one number greater than median.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n\\n\\n        ind = nums.index(k)\\n\\n        \\n        N = len(nums)\\n        \\n        res = 0\\n\\n        totG = 0\\n        totS = 0\\n        \\n\\n        count = 1\\n        \\n        hm = defaultdict(int)\\n        hm[0] = 1\\n        \\n        for i in range(ind+1,N):\\n            if nums[i] > k:\\n                totG += 1\\n            else:\\n                totG -= 1\\n            \\n            hm[totG] += 1\\n        \\n        \\n        res += hm[0] + hm[1]\\n\\n        totS = 0\\n        for i in range(ind-1,-1,-1):\\n            if nums[i] < k:\\n                totS += 1\\n            else:\\n                totS -= 1\\n            \\n            res += hm[totS] + hm[totS+1] \\n        \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n\\n\\n        ind = nums.index(k)\\n\\n        \\n        N = len(nums)\\n        \\n        res = 0\\n\\n        totG = 0\\n        totS = 0\\n        \\n\\n        count = 1\\n        \\n        hm = defaultdict(int)\\n        hm[0] = 1\\n        \\n        for i in range(ind+1,N):\\n            if nums[i] > k:\\n                totG += 1\\n            else:\\n                totG -= 1\\n            \\n            hm[totG] += 1\\n        \\n        \\n        res += hm[0] + hm[1]\\n\\n        totS = 0\\n        for i in range(ind-1,-1,-1):\\n            if nums[i] < k:\\n                totS += 1\\n            else:\\n                totS -= 1\\n            \\n            res += hm[totS] + hm[totS+1] \\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852334,
                "title": "replace-all-integers-smaller-than-k-by-1-and-greater-than-k-by-1-and-use-prefix-sums",
                "content": "# Intuition - Reduce it to a problem you already know how to solve \\n- If the median is $$k$$, then there have to be an equal number of greater and smaller integers. \\n- The exact value of the integer does not matter. Only it\\'s relation to $$k$$\\n- Take advantage of this and construct a new array of only $$-1, 0, 1$$.  \\n- Now we have to count the number of subarrays containing $$k$$ with sum $$0$$. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n[GitHub](https://github.com/MathProgrammer/LeetCode/tree/master/Contests/Weekly%20Contest%20321)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) \\n    {\\n        vector <int> A(nums.size());\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] < k)\\n            {\\n                A[i] = -1;\\n            }\\n            else if(nums[i] > k)\\n            {\\n                A[i] = 1;\\n            }\\n            else \\n            {\\n                A[i] = 0;\\n            }\\n        }\\n        \\n        int answer = 0, is_prefix = true;\\n        vector <int> sum(A.size() + 1, 0);\\n        map <int, int> prefix_frequency;\\n        map <int, int> suffix_frequency;\\n        prefix_frequency[0] = 1;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            sum[i] = A[i] + (i > 0 ? sum[i - 1] : 0);\\n            \\n            if(A[i] == 0)\\n            {\\n                is_prefix = false; \\n            }\\n            \\n            if(is_prefix)\\n            {\\n                prefix_frequency[sum[i]]++; \\n            }\\n            else \\n            {\\n                suffix_frequency[sum[i]]++;\\n                \\n                answer += prefix_frequency[sum[i] - 1] + prefix_frequency[sum[i]];\\n            }\\n            \\n            \\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) \\n    {\\n        vector <int> A(nums.size());\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] < k)\\n            {\\n                A[i] = -1;\\n            }\\n            else if(nums[i] > k)\\n            {\\n                A[i] = 1;\\n            }\\n            else \\n            {\\n                A[i] = 0;\\n            }\\n        }\\n        \\n        int answer = 0, is_prefix = true;\\n        vector <int> sum(A.size() + 1, 0);\\n        map <int, int> prefix_frequency;\\n        map <int, int> suffix_frequency;\\n        prefix_frequency[0] = 1;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            sum[i] = A[i] + (i > 0 ? sum[i - 1] : 0);\\n            \\n            if(A[i] == 0)\\n            {\\n                is_prefix = false; \\n            }\\n            \\n            if(is_prefix)\\n            {\\n                prefix_frequency[sum[i]]++; \\n            }\\n            else \\n            {\\n                suffix_frequency[sum[i]]++;\\n                \\n                answer += prefix_frequency[sum[i] - 1] + prefix_frequency[sum[i]];\\n            }\\n            \\n            \\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852324,
                "title": "python3-simple-solution-with-explanation-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Observation\\n\\nFor given subarrays with median equal to `k`, for example:\\n\\n(notation: `>k` means element greater than `k`, `<k` means element less than k)\\n```\\n>k  <k  k  >k  <k\\n\\n>k k\\n\\nk >k\\n\\n>k  <k  <k  k  >k  >k\\n```\\nWe notice that number of `>k` should be greater than number of `<k` no more than 1, i.e.,\\n```\\n0 <= (# of >k) - (# of <k) <= 1\\n```\\nLet `x = (# of >k) - (# of <k)`\\n\\nWe calculate `x` at each position toward right and left side expands from the position of k, for example:\\n```\\n             <-- -->\\nx   -1  -2  -1  0   1   2 \\n    >k  <k  <k  k  >k  >k\\n```\\n\\nx could be 0, 1, -1, -99, 123, and so on\\n\\nFor example, if `x` equal to -1 at some positions on the left side of k, we immediately know that at some positions on the right side of k, if x\\' equals to 1 or 2, it could form a valid subarray.\\n```\\nx   -1  -2  -1  0   1   2 \\n    >k  <k  <k  k  >k  >k\\n    |---------------|        valid subarray for x == -1\\n    |-------------------|    valid subarray for x == -1\\n             |------|        valid subarray for x == -1\\n             |----------|    valid subarray for x == -1\\n```\\n\\nSimilarly for `x = 0, -2, ...`, if we can find the corresponding x\\' on the other side, then we could summarize the number of valid subarrays, `x\\'` will be `-x` or `1-x`\\n\\nSo the number of valid subarray for given `x` will be `y`:\\n```\\ny = (indices of x on one side) * [(indices of -x) + (indices of 1-x) on the other side]\\n```\\n\\nAnd to summarize all subarrays: $\\\\sum_{x}(y)$\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n1. We use two hashmaps to summarized the number of indices of x on the left and right side, key is `x`, value is frequency.\\n\\n2. Iterate through one hashmap(left of right), and calcute corresponding `x\\'` by the key (`x\\' = -key or (1-key)`), then get the frequencies from the other hashmap, then aggregate the number of subarray we can find.\\n\\n\\n# Complexity\\n- Time complexity: $O(N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n`N` is length of input array, building hashmap costs $O(N)$, iterating through one hashmap costs no more than $O(N)$ \\n\\n- Space complexity: $O(N)$ for hashmap\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        N = len(nums)\\n        x = 0  # num of >k\\n        y = 0  # num of <k\\n        idx = nums.index(k)\\n        right = {0: 1}  # key: x - y, value: # of index\\n        left = {0: 1}\\n        \\n        rr = idx + 1\\n        x = y = 0\\n        while rr < N:\\n            if nums[rr] < k:\\n                y += 1\\n            else:\\n                x += 1\\n            if x - y not in right:\\n                right[x-y] = 0\\n            right[x-y] += 1\\n            rr += 1\\n        \\n        ll = idx - 1\\n        x = y = 0\\n        while ll >= 0:\\n            if nums[ll] < k:\\n                y += 1\\n            else:\\n                x += 1\\n            if x - y not in left:\\n                left[x-y] = 0\\n            left[x-y] += 1\\n            ll -= 1\\n\\n        count = 0\\n        for key, value in right.items():\\n            \\n            u =-key\\n            v = 1 - key\\n            count += value * (left.get(u, 0) + left.get(v, 0))\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n>k  <k  k  >k  <k\\n\\n>k k\\n\\nk >k\\n\\n>k  <k  <k  k  >k  >k\\n```\n```\\n0 <= (# of >k) - (# of <k) <= 1\\n```\n```\\n             <-- -->\\nx   -1  -2  -1  0   1   2 \\n    >k  <k  <k  k  >k  >k\\n```\n```\\nx   -1  -2  -1  0   1   2 \\n    >k  <k  <k  k  >k  >k\\n    |---------------|        valid subarray for x == -1\\n    |-------------------|    valid subarray for x == -1\\n             |------|        valid subarray for x == -1\\n             |----------|    valid subarray for x == -1\\n```\n```\\ny = (indices of x on one side) * [(indices of -x) + (indices of 1-x) on the other side]\\n```\n```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n\\n        N = len(nums)\\n        x = 0  # num of >k\\n        y = 0  # num of <k\\n        idx = nums.index(k)\\n        right = {0: 1}  # key: x - y, value: # of index\\n        left = {0: 1}\\n        \\n        rr = idx + 1\\n        x = y = 0\\n        while rr < N:\\n            if nums[rr] < k:\\n                y += 1\\n            else:\\n                x += 1\\n            if x - y not in right:\\n                right[x-y] = 0\\n            right[x-y] += 1\\n            rr += 1\\n        \\n        ll = idx - 1\\n        x = y = 0\\n        while ll >= 0:\\n            if nums[ll] < k:\\n                y += 1\\n            else:\\n                x += 1\\n            if x - y not in left:\\n                left[x-y] = 0\\n            left[x-y] += 1\\n            ll -= 1\\n\\n        count = 0\\n        for key, value in right.items():\\n            \\n            u =-key\\n            v = 1 - key\\n            count += value * (left.get(u, 0) + left.get(v, 0))\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852300,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  int countSubarrays(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    int kIdx = -1;\\n    for (int i = 0; i < n; ++i) {\\n      if (nums[i] == k) {\\n        kIdx = i;\\n        break;\\n      }\\n    }\\n    int numMore = 0, numLess = 0;\\n    unordered_map<int, int> leftOdd, leftEven, rightOdd, rightEven;\\n    for (int i = kIdx - 1; i >= 0; --i) {\\n      if (nums[i] > k) {\\n        numMore++;\\n      } else {\\n        numLess++;\\n      }\\n      int tot = numMore + numLess;\\n      int imbalance = numMore - numLess;\\n      if (tot % 2 == 0) {\\n        leftEven[imbalance]++;\\n      } else {\\n        leftOdd[imbalance]++;\\n      }\\n    }\\n    numMore = 0; numLess = 0;\\n    for (int i = kIdx + 1; i < n; ++i) {\\n      if (nums[i] > k) {\\n        numMore++;\\n      } else {\\n        numLess++;\\n      }\\n      if ((numMore + numLess) % 2 == 0) {\\n        rightEven[numMore - numLess]++;\\n      } else {\\n        rightOdd[numMore - numLess]++;\\n      }\\n    }\\n    \\n    int tot = 0;\\n    for (auto it = leftOdd.begin(); it != leftOdd.end(); ++it) {\\n      int imbalance = it->first;\\n      if (rightOdd.find(-imbalance) != rightOdd.end()) {\\n        tot += (it->second * rightOdd[-imbalance]);\\n      }\\n      if (rightEven.find(1 - imbalance) != rightEven.end()) {\\n        tot += (it->second * rightEven[1 - imbalance]);\\n      }\\n    }\\n    for (auto it = leftEven.begin(); it != leftEven.end(); ++it) {\\n      int imbalance = it->first;\\n      if (rightEven.find(-imbalance) != rightEven.end()) {\\n        tot += (it->second * rightEven[-imbalance]);\\n      }\\n      if (rightOdd.find(1 - imbalance) != rightOdd.end()) {\\n        tot += (it->second * rightOdd[1 - imbalance]);\\n      }\\n    }\\n    \\n    return tot + 1 + leftOdd[1] + rightOdd[1] +\\n      leftOdd[0] + leftEven[0] +\\n      rightOdd[0] + rightEven[0];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  int countSubarrays(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    int kIdx = -1;\\n    for (int i = 0; i < n; ++i) {\\n      if (nums[i] == k) {\\n        kIdx = i;\\n        break;\\n      }\\n    }\\n    int numMore = 0, numLess = 0;\\n    unordered_map<int, int> leftOdd, leftEven, rightOdd, rightEven;\\n    for (int i = kIdx - 1; i >= 0; --i) {\\n      if (nums[i] > k) {\\n        numMore++;\\n      } else {\\n        numLess++;\\n      }\\n      int tot = numMore + numLess;\\n      int imbalance = numMore - numLess;\\n      if (tot % 2 == 0) {\\n        leftEven[imbalance]++;\\n      } else {\\n        leftOdd[imbalance]++;\\n      }\\n    }\\n    numMore = 0; numLess = 0;\\n    for (int i = kIdx + 1; i < n; ++i) {\\n      if (nums[i] > k) {\\n        numMore++;\\n      } else {\\n        numLess++;\\n      }\\n      if ((numMore + numLess) % 2 == 0) {\\n        rightEven[numMore - numLess]++;\\n      } else {\\n        rightOdd[numMore - numLess]++;\\n      }\\n    }\\n    \\n    int tot = 0;\\n    for (auto it = leftOdd.begin(); it != leftOdd.end(); ++it) {\\n      int imbalance = it->first;\\n      if (rightOdd.find(-imbalance) != rightOdd.end()) {\\n        tot += (it->second * rightOdd[-imbalance]);\\n      }\\n      if (rightEven.find(1 - imbalance) != rightEven.end()) {\\n        tot += (it->second * rightEven[1 - imbalance]);\\n      }\\n    }\\n    for (auto it = leftEven.begin(); it != leftEven.end(); ++it) {\\n      int imbalance = it->first;\\n      if (rightEven.find(-imbalance) != rightEven.end()) {\\n        tot += (it->second * rightEven[-imbalance]);\\n      }\\n      if (rightOdd.find(1 - imbalance) != rightOdd.end()) {\\n        tot += (it->second * rightOdd[1 - imbalance]);\\n      }\\n    }\\n    \\n    return tot + 1 + leftOdd[1] + rightOdd[1] +\\n      leftOdd[0] + leftEven[0] +\\n      rightOdd[0] + rightEven[0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852292,
                "title": "java-dp-solution-showing-tle",
                "content": "\\'\\'\\'class Solution {\\n\\n    public int countSubarrays(int[] nums, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        int[] memo = new int[nums.length];\\n        Arrays.fill(memo,-1);\\n        return solve(nums,k,0,list,0,memo);\\n    }\\n    public int solve(int[]nums, int k, int n, List<Integer> list, int ans, int[]memo){\\n        if(n==nums.length)\\n            return ans;\\n        if(memo[n]!=-1)\\n            return memo[n];\\n\\t\\t\\t\\n        int median =1;\\n        for(int i=n; i<nums.length; i++){\\n            list.add(nums[i]);\\n            Collections.sort(list);\\n            if(list.size()%2 !=0){\\n                median = (list.size())/2;\\n                median = list.get(median);\\n                if(median == k)\\n                    ans++;\\n            }\\n            else{\\n                median = (list.size()/2)-1;\\n                median = list.get(median);\\n                if(median == k) \\n                    ans++;\\n            }\\n        }\\n        list.clear();\\n        memo[n] = solve(nums,k,n+1,list,ans,memo);\\n        return memo[n];\\n    }\\n}\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\n    public int countSubarrays(int[] nums, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        int[] memo = new int[nums.length];\\n        Arrays.fill(memo,-1);\\n        return solve(nums,k,0,list,0,memo);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2852288,
                "title": "easy-and-clean-solution-in-c",
                "content": "#### [\\uD83C\\uDFC6 Weekly Contest 321 All Solution Code Find Here](https://github.com/Md-Shamim-Ahmmed/LeetCode-Problem-Solution/tree/0f6df0fc0820e22f31c82347429feda0755a1dce/LeetCode%20Problems/2400%20to%202500)\\n\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int> &nums, int k) {\\n        int n = nums.size(), ind = -1;\\n        map<int, int> mp;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        int diff = 0;\\n        for (int i = ind; i >= 0; i--) {\\n            if (nums[i] < k)\\n                diff--;\\n            else if (nums[i] > k)\\n                diff++;\\n            mp[diff] = mp[diff] + 1;\\n        }\\n        int count = mp[0] + mp[1];\\n        int currdiff = 0;\\n        for (int i = ind + 1; i < n; i++) {\\n            if (nums[i] < k) currdiff--;\\n            else currdiff++;\\n            count += mp[-currdiff];\\n            count += mp[1 - currdiff];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int> &nums, int k) {\\n        int n = nums.size(), ind = -1;\\n        map<int, int> mp;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        int diff = 0;\\n        for (int i = ind; i >= 0; i--) {\\n            if (nums[i] < k)\\n                diff--;\\n            else if (nums[i] > k)\\n                diff++;\\n            mp[diff] = mp[diff] + 1;\\n        }\\n        int count = mp[0] + mp[1];\\n        int currdiff = 0;\\n        for (int i = ind + 1; i < n; i++) {\\n            if (nums[i] < k) currdiff--;\\n            else currdiff++;\\n            count += mp[-currdiff];\\n            count += mp[1 - currdiff];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852285,
                "title": "python-3-simple-hashmap",
                "content": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n        idx = nums.index(k)\\n        n, res = len(nums), 0\\n   \\n        dt1 = defaultdict(int)\\n        ll, lg = 0, 0\\n        for _ in range(idx)[::-1]:\\n            if nums[_] < k: ll += 1\\n            else: lg += 1\\n            if lg == ll+1 or lg == ll: res += 1\\n            dt1[lg - ll] += 1\\n              \\n        rl, rg = 0, 0       \\n        for _ in range(idx+1, n):\\n            if nums[_] < k: rl += 1\\n            else: rg += 1\\n            if rg == rl+1 or rg == rl: res += 1\\n            res += dt1[1+rl-rg]\\n            res += dt1[rl-rg]\\n        return res+1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSubarrays(self, nums: List[int], k: int) -> int:\\n        \\n        idx = nums.index(k)\\n        n, res = len(nums), 0\\n   \\n        dt1 = defaultdict(int)\\n        ll, lg = 0, 0\\n        for _ in range(idx)[::-1]:\\n            if nums[_] < k: ll += 1\\n            else: lg += 1\\n            if lg == ll+1 or lg == ll: res += 1\\n            dt1[lg - ll] += 1\\n              \\n        rl, rg = 0, 0       \\n        for _ in range(idx+1, n):\\n            if nums[_] < k: rl += 1\\n            else: rg += 1\\n            if rg == rl+1 or rg == rl: res += 1\\n            res += dt1[1+rl-rg]\\n            res += dt1[rl-rg]\\n        return res+1",
                "codeTag": "Java"
            },
            {
                "id": 2852270,
                "title": "reduce-problem-to-subarray-sum-equals-0-c-detailed-explanation",
                "content": "This problem was asked in google interview\\n\\nApproach:\\nset all elements greater than k to +1\\nset all elements smaller than k to -1\\nset all elements equal than k to 0\\n\\nNow, in an odd length array if k is median, there will be equal number of elements greater than k and smaller than k.\\nwhich means that for that subarray, sum of items in the modified array will be 0\\n\\nIn an even length array if k is median, there will be 1 more element greater than k (to put k in the left side of middle)\\n\\nSo, we need to find subarrays which are even in length and have sum  = 1 and subarrays which are odd in length and have sum = 0.\\n\\nRest of the problem is similar to https://leetcode.com/problems/subarray-sum-equals-k/\\nwith 1 twist: you need to take care of the length of the subarray.\\n\\nSo maintain 2 maps with even and odd length.\\nTake running sum till now.\\nIf current length is odd, then we need to find previous even length which has the sum = running_sum\\nand previous odd length with sum = running_sum - 1\\n\\nIf current length is even, then we need to find previous odd length which has the sum = running_sum\\nand previous even length with sum = running_sum - 1\\n\\nFind the number of subarrays using the previous problem logic\\n\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        for(int &num: nums) {\\n            if(num > k) {\\n                num = 1;\\n            } else if(num < k) {\\n                num = -1;\\n            } else {\\n                num = 0;\\n            }\\n        }\\n        \\n        map<int,int> oddMap, evenMap;\\n        oddMap.insert({ 0, 1 });\\n        long long sum = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            \\n            if(i % 2) {\\n                // odd number of elements till now\\n                cnt += oddMap[sum - 1];\\n                cnt += evenMap[sum];\\n                \\n                if(!oddMap.count(sum))\\n                    oddMap.insert({ sum, 1 });\\n                else\\n                    oddMap[sum]++;\\n            } else {\\n                // even number of elements till now\\n                cnt += oddMap[sum];\\n                cnt += evenMap[sum - 1];\\n                \\n                if(!evenMap.count(sum))\\n                    evenMap.insert({ sum, 1 });\\n                else\\n                    evenMap[sum]++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        for(int &num: nums) {\\n            if(num > k) {\\n                num = 1;\\n            } else if(num < k) {\\n                num = -1;\\n            } else {\\n                num = 0;\\n            }\\n        }\\n        \\n        map<int,int> oddMap, evenMap;\\n        oddMap.insert({ 0, 1 });\\n        long long sum = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            \\n            if(i % 2) {\\n                // odd number of elements till now\\n                cnt += oddMap[sum - 1];\\n                cnt += evenMap[sum];\\n                \\n                if(!oddMap.count(sum))\\n                    oddMap.insert({ sum, 1 });\\n                else\\n                    oddMap[sum]++;\\n            } else {\\n                // even number of elements till now\\n                cnt += oddMap[sum];\\n                cnt += evenMap[sum - 1];\\n                \\n                if(!evenMap.count(sum))\\n                    evenMap.insert({ sum, 1 });\\n                else\\n                    evenMap[sum]++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852263,
                "title": "simple-java-solution-hashmap",
                "content": "class Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int ind=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==k) { ind = i; break;}\\n        }\\n        Map<Integer,Integer> right = new HashMap<>();\\n        int kt=0;\\n        for(int i=ind+1;i<nums.length;i++){\\n            if(nums[i]>k) kt++;\\n            else kt--;\\n            right.put(kt,right.getOrDefault(kt,0)+1);\\n        }\\n        kt=0;\\n        Map<Integer,Integer> left = new HashMap<>();\\n        for(int i=ind-1;i>=0;i--){\\n            if(nums[i]>k) kt++;\\n            else kt--;\\n            left.put(kt,left.getOrDefault(kt,0)+1);\\n        }\\n        int val=0;\\n        for(Map.Entry<Integer,Integer> m : right.entrySet()){\\n            if(left.containsKey(m.getKey()*-1))\\n            val += (left.get(m.getKey()*-1)) * (m.getValue());\\n            if(left.containsKey (1- m.getKey()) )\\n            val += (left.get(1 - m.getKey())) * (m.getValue());\\n        }\\n        if(right.containsKey(0)) val += right.get(0);\\n        if(right.containsKey(1)) val += right.get(1);\\n        if(left.containsKey(0))   val += left.get(0);\\n        if(left.containsKey(1)) val += left.get(1);\\n        return val+1 ; // 1 is added for the subarray of number itself\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countSubarrays(int[] nums, int k) {\\n        int ind=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==k) { ind = i; break;}",
                "codeTag": "Java"
            },
            {
                "id": 2852258,
                "title": "running-sum-for-specific-subarray-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\nsay subarray [0..i]\\n\\nk is median , which means sum of subarray will be \\n        \\n[x, x, x, x ... k , x, x, x, x] , odd length  => [-1, -1 ..... k , 1 , 1, 1, 1, 1]    => sum == k\\n\\n[x, x, x ... k, x, x, x, x]       even length => [-1, -1 ..... k, 1, 1 , 1, 1]        => sum == k + 1\\n\\nelements smaller than k will be -1, those greater than k will be 1\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int kIdx = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < k) {\\n                nums[i] = -1e5-1;\\n            } else if (nums[i] > k) {\\n                nums[i] = 1e5+1;\\n            } else {\\n                // nums[i] == k\\n                kIdx = i;\\n            }\\n        }\\n        \\n        vector<long long> preSum(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                preSum[i] = nums[i];\\n            } else {\\n                preSum[i] += preSum[i - 1] + nums[i];\\n            }\\n        }\\n        \\n        unordered_map<long long, int> counter;\\n        counter[0] = 1;\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i >= kIdx) {\\n                // odd length, sum is k, preSum[j] - preSum[i] == k\\n                if (counter.count(preSum[i] - k)) {\\n                    cnt += counter[preSum[i] - k];\\n                }\\n                // even length, sum is preSum[j] - preSum[i] == k + x\\n                if (counter.count(preSum[i] - k - 1e5 - 1)) {\\n                    cnt += counter[preSum[i] - k - 1e5 - 1];\\n                }\\n            }\\n            counter[preSum[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nsay subarray [0..i]\\n\\nk is median , which means sum of subarray will be \\n        \\n[x, x, x, x ... k , x, x, x, x] , odd length  => [-1, -1 ..... k , 1 , 1, 1, 1, 1]    => sum == k\\n\\n[x, x, x ... k, x, x, x, x]       even length => [-1, -1 ..... k, 1, 1 , 1, 1]        => sum == k + 1\\n\\nelements smaller than k will be -1, those greater than k will be 1\\n```\n```\\nclass Solution {\\npublic:\\n    int countSubarrays(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int kIdx = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < k) {\\n                nums[i] = -1e5-1;\\n            } else if (nums[i] > k) {\\n                nums[i] = 1e5+1;\\n            } else {\\n                // nums[i] == k\\n                kIdx = i;\\n            }\\n        }\\n        \\n        vector<long long> preSum(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                preSum[i] = nums[i];\\n            } else {\\n                preSum[i] += preSum[i - 1] + nums[i];\\n            }\\n        }\\n        \\n        unordered_map<long long, int> counter;\\n        counter[0] = 1;\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i >= kIdx) {\\n                // odd length, sum is k, preSum[j] - preSum[i] == k\\n                if (counter.count(preSum[i] - k)) {\\n                    cnt += counter[preSum[i] - k];\\n                }\\n                // even length, sum is preSum[j] - preSum[i] == k + x\\n                if (counter.count(preSum[i] - k - 1e5 - 1)) {\\n                    cnt += counter[preSum[i] - k - 1e5 - 1];\\n                }\\n            }\\n            counter[preSum[i]]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1979440,
                "content": [
                    {
                        "username": "sudharsan___007",
                        "content": "[2,5,1,4,3,6]\\n1\\ncan anyone pls expalin this output\\n"
                    },
                    {
                        "username": "AndreasHzz",
                        "content": "this question is poorly phrased. in the case of subarray [5,1], the medium is 1 instead of (1+5)/2, same for [1,4]. Hence there are two more subarrays with medium to be 1."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "A subarray has a median k if:\\n\\nIt includes k\\nCount n[i] < k is equal to count n[i] > k (odd-size subarrays).\\nCount n[i] < k is one less than count n[i] > k (even-size subarrays).\\nOr, in other words, the balance between the count of smaller and larger elements is zero or one.\\n\\nSince integers are distinct, we have only one k element in the array. So, we find it first.\\n\\nThen, we go right from k, tracking the ballance and counting balances using a hash map.\\n\\nFinally, we go left from k, tracking the balance, and counting complimentary balances in the hash map."
                    },
                    {
                        "username": "follow_dream",
                        "content": "This test case nums = [3,2,1,4,5], k= 1 \\nCan anyone explain why the expected result should be 3. I only see 2 way which is (1) and (2,1). \\nThanks"
                    },
                    {
                        "username": "Raghubir",
                        "content": "[@NaralaMahesh](/NaralaMahesh)  How this has median 1 if we sort the subarray it will become [1,2,4] and median will be 2 right "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@NaralaMahesh](/NaralaMahesh) hell no, its median is 2"
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "[2,1,4] has median 1"
                    },
                    {
                        "username": "follow_dream",
                        "content": "Got it now thank you both. Sometime i am so dumb !"
                    },
                    {
                        "username": "espadandy",
                        "content": "[1,4]"
                    },
                    {
                        "username": "qing306038",
                        "content": "There's another way: [1,4], which the median is still 1"
                    }
                ]
            },
            {
                "id": 1705785,
                "content": [
                    {
                        "username": "sudharsan___007",
                        "content": "[2,5,1,4,3,6]\\n1\\ncan anyone pls expalin this output\\n"
                    },
                    {
                        "username": "AndreasHzz",
                        "content": "this question is poorly phrased. in the case of subarray [5,1], the medium is 1 instead of (1+5)/2, same for [1,4]. Hence there are two more subarrays with medium to be 1."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "A subarray has a median k if:\\n\\nIt includes k\\nCount n[i] < k is equal to count n[i] > k (odd-size subarrays).\\nCount n[i] < k is one less than count n[i] > k (even-size subarrays).\\nOr, in other words, the balance between the count of smaller and larger elements is zero or one.\\n\\nSince integers are distinct, we have only one k element in the array. So, we find it first.\\n\\nThen, we go right from k, tracking the ballance and counting balances using a hash map.\\n\\nFinally, we go left from k, tracking the balance, and counting complimentary balances in the hash map."
                    },
                    {
                        "username": "follow_dream",
                        "content": "This test case nums = [3,2,1,4,5], k= 1 \\nCan anyone explain why the expected result should be 3. I only see 2 way which is (1) and (2,1). \\nThanks"
                    },
                    {
                        "username": "Raghubir",
                        "content": "[@NaralaMahesh](/NaralaMahesh)  How this has median 1 if we sort the subarray it will become [1,2,4] and median will be 2 right "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@NaralaMahesh](/NaralaMahesh) hell no, its median is 2"
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "[2,1,4] has median 1"
                    },
                    {
                        "username": "follow_dream",
                        "content": "Got it now thank you both. Sometime i am so dumb !"
                    },
                    {
                        "username": "espadandy",
                        "content": "[1,4]"
                    },
                    {
                        "username": "qing306038",
                        "content": "There's another way: [1,4], which the median is still 1"
                    }
                ]
            },
            {
                "id": 1698393,
                "content": [
                    {
                        "username": "sudharsan___007",
                        "content": "[2,5,1,4,3,6]\\n1\\ncan anyone pls expalin this output\\n"
                    },
                    {
                        "username": "AndreasHzz",
                        "content": "this question is poorly phrased. in the case of subarray [5,1], the medium is 1 instead of (1+5)/2, same for [1,4]. Hence there are two more subarrays with medium to be 1."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "A subarray has a median k if:\\n\\nIt includes k\\nCount n[i] < k is equal to count n[i] > k (odd-size subarrays).\\nCount n[i] < k is one less than count n[i] > k (even-size subarrays).\\nOr, in other words, the balance between the count of smaller and larger elements is zero or one.\\n\\nSince integers are distinct, we have only one k element in the array. So, we find it first.\\n\\nThen, we go right from k, tracking the ballance and counting balances using a hash map.\\n\\nFinally, we go left from k, tracking the balance, and counting complimentary balances in the hash map."
                    },
                    {
                        "username": "follow_dream",
                        "content": "This test case nums = [3,2,1,4,5], k= 1 \\nCan anyone explain why the expected result should be 3. I only see 2 way which is (1) and (2,1). \\nThanks"
                    },
                    {
                        "username": "Raghubir",
                        "content": "[@NaralaMahesh](/NaralaMahesh)  How this has median 1 if we sort the subarray it will become [1,2,4] and median will be 2 right "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@NaralaMahesh](/NaralaMahesh) hell no, its median is 2"
                    },
                    {
                        "username": "NaralaMahesh",
                        "content": "[2,1,4] has median 1"
                    },
                    {
                        "username": "follow_dream",
                        "content": "Got it now thank you both. Sometime i am so dumb !"
                    },
                    {
                        "username": "espadandy",
                        "content": "[1,4]"
                    },
                    {
                        "username": "qing306038",
                        "content": "There's another way: [1,4], which the median is still 1"
                    }
                ]
            }
        ]
    }
]