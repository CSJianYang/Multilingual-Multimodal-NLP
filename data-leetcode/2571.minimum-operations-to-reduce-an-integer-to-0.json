[
    {
        "title": "Minimum Operations to Reduce an Integer to 0",
        "question_content": "You are given a positive integer n, you can do the following operation any number of times:\n\n\tAdd or subtract a power of 2 from n.\n\nReturn the minimum number of operations to make n equal to 0.\nA number x is power of 2 if x == 2i&nbsp;where i >= 0.\n&nbsp;\nExample 1:\n\nInput: n = 39\nOutput: 3\nExplanation: We can do the following operations:\n- Add 20 = 1 to n, so now n = 40.\n- Subtract 23 = 8 from n, so now n = 32.\n- Subtract 25 = 32 from n, so now n = 0.\nIt can be shown that 3 is the minimum number of operations we need to make n equal to 0.\n\nExample 2:\n\nInput: n = 54\nOutput: 3\nExplanation: We can do the following operations:\n- Add 21 = 2 to n, so now n = 56.\n- Add 23 = 8 to n, so now n = 64.\n- Subtract 26 = 64 from n, so now n = 0.\nSo the minimum number of operations is 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105",
        "solutions": [
            {
                "id": 3203994,
                "title": "java-c-python-1-line-solution",
                "content": "# **Intuition**\\nTake a look at the binary of `n`:\\n\\nIf there is an alone `1`, like ..00001,\\nit takes at leat one operation to remove.\\nand we can remove it in one operation.\\nSo we do `res++` and `n >>= 2`,\\nremove two last bits.\\n\\n\\nIf there are multiple `1`s, like ..0000111,\\nwe can\\'t remove them in one single operation,\\nso it takes at least two operation to remove,\\nFor example of `..0000111`\\nwe can add `1` and then remove `1000`.\\nSo we do `n++` and remove the last bit `0`.\\n<br>\\n\\n# **Explanation**\\nBy this stratagy in intuition,\\nwe only need to take care of the the continuous `1` in binary of `n`.\\nIf it\\'s single `1`, `res += 1`\\nIf it\\'s multiple `1`s, `res += 2`\\n<br>\\n\\n# **Complexity**\\nTime `O(logn)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minOperations(int n) {\\n        int res = 0;\\n        while (n > 0) {\\n            if ((n & 3) == 3) {\\n                n++;\\n                res++;\\n            } else {\\n                res += n & 1;\\n                n >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minOperations(int n) {\\n        int res = 0;\\n        while (n > 0) {\\n            if ((n & 3) == 3) {\\n                n++;\\n                res++;\\n            } else {\\n                res += n & 1;\\n                n >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minOperations(self, n: int) -> int:\\n        res = 0\\n        while n > 0:\\n            if n % 2 == 0:\\n                n >>= 1\\n            elif (n & 2) > 0:\\n                n += 1\\n                res += 1\\n            else:\\n                res += 1\\n                n >>= 2\\n        return res\\n```\\n<br>\\n\\n# **Solution 2: One Line**\\n\\nReference: https://oeis.org/A007302\\n\\nHere is a trick to transform multiplt 1s:\\n\\n**For case of single 1: 01**\\nn           = 01,\\nn * 2       = 10,\\nn * 3       = 11,\\nn ^ (n * 3) = 10,\\n\\n**For case multiple 1s: ..0011...1**\\nn           = 0011111,\\nn * 2       = 0111110,\\nn * 3       = 1011101,\\nn ^ (n * 3) = 1000010,\\n\\nAll `0011..1` turns into two `1`s.\\n\\n\\n**For case multiple 1s with some single 0 in the middle**\\nn           = 0011101011,\\nn * 2       = 0111010110,\\nn * 3       = 1011000001,\\nn ^ (n * 3) = 1000101010,\\n\\nStill turns into two 1s on both side,\\nand the single 0s in the middle will turn into 1s.\\n\\n\\nSo to conclude,\\nWe just need to count bits of `n ^ (n * 3)`.\\n\\n**Java**\\n```java\\n    public int minOperations(int n) {\\n        return Integer.bitCount(n ^ (n * 3));\\n    }\\n```\\n**C++**\\n```cpp\\n    int minOperations(int n) {\\n        return __builtin_popcount(n ^ (n * 3));\\n    }\\n```\\n**Python**\\n```py\\n    def minOperations(self, n: int) -> int:\\n        return (n ^ (n * 3)).bit_count()\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minOperations(int n) {\\n        int res = 0;\\n        while (n > 0) {\\n            if ((n & 3) == 3) {\\n                n++;\\n                res++;\\n            } else {\\n                res += n & 1;\\n                n >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minOperations(int n) {\\n        int res = 0;\\n        while (n > 0) {\\n            if ((n & 3) == 3) {\\n                n++;\\n                res++;\\n            } else {\\n                res += n & 1;\\n                n >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minOperations(self, n: int) -> int:\\n        res = 0\\n        while n > 0:\\n            if n % 2 == 0:\\n                n >>= 1\\n            elif (n & 2) > 0:\\n                n += 1\\n                res += 1\\n            else:\\n                res += 1\\n                n >>= 2\\n        return res\\n```\n```java\\n    public int minOperations(int n) {\\n        return Integer.bitCount(n ^ (n * 3));\\n    }\\n```\n```cpp\\n    int minOperations(int n) {\\n        return __builtin_popcount(n ^ (n * 3));\\n    }\\n```\n```py\\n    def minOperations(self, n: int) -> int:\\n        return (n ^ (n * 3)).bit_count()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3203728,
                "title": "greedy",
                "content": "It can be shown that it\\'s always better to add a power of two if it decreases the number of bits.\\n\\nFor example, for `01110110` (5 bits), we need 3 operations:\\n- Add `10` -> `01111000` (4 bits)\\n- Add `1000` -> `10000000` (1 bit)\\n- Remove the remaining bit.\\n\\n**C++**\\n```cpp\\nint minOperations(int n) {\\n    int res = 0;\\n    for (int i = 0; i < 14; ++i)\\n        if (__builtin_popcount(n + (1 << i)) < __builtin_popcount(n)) {\\n            n += 1 << i;\\n            ++res;\\n        }\\n    return res + __builtin_popcount(n);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minOperations(int n) {\\n    int res = 0;\\n    for (int i = 0; i < 14; ++i)\\n        if (__builtin_popcount(n + (1 << i)) < __builtin_popcount(n)) {\\n            n += 1 << i;\\n            ++res;\\n        }\\n    return res + __builtin_popcount(n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203829,
                "title": "c-nearest-power-of-2-recursion-easy-100-time-51-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n      int x = 1, y = 1;\\n      if(n <= 0) return 0;  \\n      if(n == 1) return 1;\\n      while(x * 2 < n) x *= 2;\\n      y = x * 2 - n;\\n      x = n - x;\\n      int low = minOperations(x);\\n      int high = minOperations(y);\\n      return min(low, high) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n      int x = 1, y = 1;\\n      if(n <= 0) return 0;  \\n      if(n == 1) return 1;\\n      while(x * 2 < n) x *= 2;\\n      y = x * 2 - n;\\n      x = n - x;\\n      int low = minOperations(x);\\n      int high = minOperations(y);\\n      return min(low, high) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204095,
                "title": "easiest-solution-better-than-the-most-voted-one-explained",
                "content": "# Intuition\\n\\nMath Property: Any number can be expressed as the sum (or difference) of powers of two.\\nWouldn\\'t it be optimal if we always choose the closest power of 2 everytime in order to perfrom the add or subtract operation?\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBe greedy, and always subtract the nearest power of 2 from `n`.\\nNote: By `subtract` I do not mean directly subtract, but absolute subtract.\\nSee the code for more understanding.\\n\\n\\n# Some More Explanation\\n\\nWe want to **minimize** the no. of ops for reducing n to 0.\\nWe\\'re allowed to subtract **as well as add** (imp.) any power of 2 in order to achieve the goal.\\n\\nBasically we want to reduce n to 0 as soon as possible i.e. with minimum no. of ops, so wouldn\\'t it be optimal to always subtract the closest power of 2 from n, so that it come as close as possible to 0 with every op!\\n\\nTake an example:\\n`n = 127`\\nClosest power of 2: `128`\\n`n -= 128` => `n` becomes `-1`\\nNow, back to that \"imp.\" I marked above, we\\'re allowed to add a power of 2 too.\\nSo, for that reason it doesn\\'t matter if n goes -ve even if we only wanted to make it till 0, because at any time we can then add new closest power of 2 to n so that n goes to 0.\\nContinuing with the example,\\n`n` was `-1`\\nClosest power of 2: `1`\\n`n += 1` => `n` becomes `0`\\n\\nHope it helps.\\n\\n\\n# Complexity\\n\\n- Time complexity: $$O(log2(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(log2(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code w/ Comments\\n\\n```py\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n\\n        from math import log2\\n\\n        # Powers of 2: TC = SC = O(log2(n))\\n        \\'\\'\\'\\n        powers = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072]\\n        # Why required till 131072 only? Because n <= 10^5.\\n        \\'\\'\\'\\n        # (Good Practice) Keep it dynamic so that even if n > 10^5, code will work:\\n        # powers = [2**i for i in range(int(log2(n))+2)]\\n        powers = [1 << i for i in range(int(log2(n))+2)]\\n\\n        ops = 0\\n\\n        # While `n` doesn\\'t become 0:\\n        while n:  # TC = O(1) because it doesn\\'t matter what `n` is, we\\'re directly subtracting the closest power of 2 from\\n            # it, so, it will fall to 0 in a couple of ops only (take a big number and check yourself to get the hang of it)\\n\\n            # Find the power of 2 which is closest to n: TC = O(log2(n))\\n            \\'\\'\\'\\n            min_diff, closest = float(\\'inf\\'), None\\n            for p in powers:\\n                if abs(n-p) < min_diff:\\n                    min_diff, closest = abs(n-p), p\\n            \\'\\'\\'\\n            # One-liner of above (Thanks for pointing it out @SmittyWerbenjagermanjensen):\\n            closest = min(powers, key=lambda p: abs(n-p))\\n\\n            # (Absolute) Subtract it (the closest power of 2):\\n            n = abs(n-closest)\\n\\n            ops += 1\\n\\n        return ops\\n```\\n\\n\\n# Just Code\\n\\n```py\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n\\n        pows = [1 << i for i in range(int(log2(n))+2)]\\n        ops = 0\\n\\n        while n:\\n            closest = min(pows, key=lambda p: abs(n-p))\\n            n = abs(n-closest)\\n            ops += 1\\n\\n        return ops\\n```\\n\\n\\n**I\\'m posting this because I saw the posted solutions and realized they are not the easiest,**\\n**So, like this so that it goes to top.**\\n**Thanks!**\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```py\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n\\n        from math import log2\\n\\n        # Powers of 2: TC = SC = O(log2(n))\\n        \\'\\'\\'\\n        powers = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072]\\n        # Why required till 131072 only? Because n <= 10^5.\\n        \\'\\'\\'\\n        # (Good Practice) Keep it dynamic so that even if n > 10^5, code will work:\\n        # powers = [2**i for i in range(int(log2(n))+2)]\\n        powers = [1 << i for i in range(int(log2(n))+2)]\\n\\n        ops = 0\\n\\n        # While `n` doesn\\'t become 0:\\n        while n:  # TC = O(1) because it doesn\\'t matter what `n` is, we\\'re directly subtracting the closest power of 2 from\\n            # it, so, it will fall to 0 in a couple of ops only (take a big number and check yourself to get the hang of it)\\n\\n            # Find the power of 2 which is closest to n: TC = O(log2(n))\\n            \\'\\'\\'\\n            min_diff, closest = float(\\'inf\\'), None\\n            for p in powers:\\n                if abs(n-p) < min_diff:\\n                    min_diff, closest = abs(n-p), p\\n            \\'\\'\\'\\n            # One-liner of above (Thanks for pointing it out @SmittyWerbenjagermanjensen):\\n            closest = min(powers, key=lambda p: abs(n-p))\\n\\n            # (Absolute) Subtract it (the closest power of 2):\\n            n = abs(n-closest)\\n\\n            ops += 1\\n\\n        return ops\\n```\n```py\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n\\n        pows = [1 << i for i in range(int(log2(n))+2)]\\n        ops = 0\\n\\n        while n:\\n            closest = min(pows, key=lambda p: abs(n-p))\\n            n = abs(n-closest)\\n            ops += 1\\n\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203724,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(log n)$$ --> It\\'s log n base 2\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int c=0;\\n        while(n!=0)\\n        {\\n            if(n%2==1)\\n            {\\n                if((n==1)||(n&2)==0)\\n                {\\n                    n -= 1;\\n                }\\n                else\\n                {\\n                    n += 1;\\n                }\\n                c++;\\n                \\n            }\\n            else\\n            {\\n                n/=2;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int c=0;\\n        while(n!=0)\\n        {\\n            if(n%2==1)\\n            {\\n                if((n==1)||(n&2)==0)\\n                {\\n                    n -= 1;\\n                }\\n                else\\n                {\\n                    n += 1;\\n                }\\n                c++;\\n                \\n            }\\n            else\\n            {\\n                n/=2;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203803,
                "title": "java-nearest-power-of-2-explained-faster-than-100",
                "content": "Do UPVOTE\\uD83D\\uDC4D\\uD83C\\uDFFB\\u2764\\n\\n**Approach:**\\nWe find the ***nearest*** power of 2 using the `Math.log()` method and update our `n` accordingly.\\n```\\npublic int minOperations(int n) {\\n      int c=0;\\n      while(n > 0){\\n         c++;\\n         double x = Math.log(n) / Math.log(2);\\n          \\n         int prevPower = (int) Math.pow(2,(int) x);\\n         int nextPower = (int) Math.pow(2,(int) x + 1);\\n          \\n         int diff1 = n - prevPower;\\n         int diff2 = nextPower - n;\\n          \\n         if(diff1 < diff2) n = diff1;\\n         else n = diff2;\\n      }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic int minOperations(int n) {\\n      int c=0;\\n      while(n > 0){\\n         c++;\\n         double x = Math.log(n) / Math.log(2);\\n          \\n         int prevPower = (int) Math.pow(2,(int) x);\\n         int nextPower = (int) Math.pow(2,(int) x + 1);\\n          \\n         int diff1 = n - prevPower;\\n         int diff2 = nextPower - n;\\n          \\n         if(diff1 < diff2) n = diff1;\\n         else n = diff2;\\n      }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203785,
                "title": "hell-lot-of-conditions",
                "content": "# Approach\\n### Trick : Remove all 1\\'s from the binary value to get 0 & combination of multiple 1 can be removed by adding 1 to it first then remove a single 1 from the result.\\n\\nSo lets observe few cases first :\\n- For n = 39, binary 100110\\n    we can simply remove 100000, 100, 10 and in 3 operations we achive the 0 value\\n\\n- For n = 54, binary 110110\\n    Here also simply remove 100000, 100000, 100, 10 and we will achive 0 value.\\n    But there is one other way, lets try to have set of continuous 1\\n    adding 1 to 1st index(0 is start index) from left, we will get\\n    110110 + 10 => 111000 ( 1 operation )\\n    now we can add 1 more to 3rd index, we will get \\n    111000 + 1000 => 1000000  (1 operation )\\n    now simply remove this 1000000 ( 1 operation )\\n\\nIn above two, we found there is two way we can remove 1 ( basicaly 2\\'s power) :\\n1. Simply count number of 1s and remove it.\\n2. There can be optimal way, by simply adding 1 to a group of cont. 1s to make it single 1 and then remove that 1. 2 operations, so if the continuous 1\\'s count is more than 2 then we need to do only 2 operations \\n\\nBut here we can have a third case as well,\\nn = 22, 10110\\nHere after adding 1 to 1st index from left, we get\\n10110 + 10 => 11000\\n\\nNow we have another set of 1s together, so don\\'t have to remove 1 that we do in above case. Rather we cont. to add 1s to 3rd index and get\\n11000 + 1000 => 100000\\n now simply remove 1.\\n\\nSo its a bit tricky to  make other realise this, but you can just simply think that -> you need to remove all 1\\'s from the binary value to get 0 & combination of multiple 1 can be removed by adding 1 to it first then remove a single 1 from the result. final three cases :\\n\\n1. when we have only 1 count, no need to add any 1 or grouping\\n2. if we have 1 just next to current zero then simply ans++, to count addition of 1 to the existing group of 1 to single 1 \\n3. when combination of 1s found with two zeros in cont. found then simply convert this 1\\'s to zero with 2 more operations\\n\\n\\n```\\n    int minOperations(int n) {\\n        int count = 0, ans = 0;\\n        for(int i = 0; i <= log2(n); ++i){\\n            if(n & (1 << i )) {  count++; } //when bit is 1\\n            else if(count) {                //when bit is 0 but count is > 0\\n                if(count == 1) { ans += 1; count = 0; }              //when we have only 1 count, no need to add any 1 or grouping\\n                else if(count && n & (1 << (i+1)) ) { ans += 1; count = 1; }   //if we have 1 just next to current zero then simply ans++, to count addition of 1 to the existing group of 1 to single 1 \\n                else { ans += 2; count = 0;  } // when combination of 1s found with two zeros in cont. found then simply convert this 1\\'s to zero with 2 more operations\\n            }\\n        }\\n        ans += (count < 2)?count:2;\\n        return (ans);\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minOperations(int n) {\\n        int count = 0, ans = 0;\\n        for(int i = 0; i <= log2(n); ++i){\\n            if(n & (1 << i )) {  count++; } //when bit is 1\\n            else if(count) {                //when bit is 0 but count is > 0\\n                if(count == 1) { ans += 1; count = 0; }              //when we have only 1 count, no need to add any 1 or grouping\\n                else if(count && n & (1 << (i+1)) ) { ans += 1; count = 1; }   //if we have 1 just next to current zero then simply ans++, to count addition of 1 to the existing group of 1 to single 1 \\n                else { ans += 2; count = 0;  } // when combination of 1s found with two zeros in cont. found then simply convert this 1\\'s to zero with 2 more operations\\n            }\\n        }\\n        ans += (count < 2)?count:2;\\n        return (ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224068,
                "title": "java-easy-nearest-power-of-2-bit-manipulation-simple-observation",
                "content": "**Basically you have to see the minimum difference between nearest power of 2 nearer to the number. The power of 2 that is just below the number and the power of 2 that is just above the number. Just compute the difference of both the nearest power of 2 with the number and check the minimum difference. Then the minimum difference is then recalculated for the nearest power of 2 below the minimum difference and above the minimum difference. The number of times the while loop will execute is the answer. Just try to dry run once you will get it.**\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int x=n;\\n        int cnt=0;\\n        while(x!=0){\\n            int floor=(int)Math.floor(Math.log(x)/Math.log(2));\\n            int ceil=(int)Math.ceil(Math.log(x)/Math.log(2));\\n            x=Math.min(Math.abs((1<<floor)-x),Math.abs((1<<ceil)-x));\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/535249bd-b78f-422e-9ef9-93264d01cb77_1677217770.504339.png)\\n\\n![image](https://assets.leetcode.com/users/images/bba7e980-e331-4cf4-89d1-8aa9f1e7a5f3_1677217777.7516582.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int x=n;\\n        int cnt=0;\\n        while(x!=0){\\n            int floor=(int)Math.floor(Math.log(x)/Math.log(2));\\n            int ceil=(int)Math.ceil(Math.log(x)/Math.log(2));\\n            x=Math.min(Math.abs((1<<floor)-x),Math.abs((1<<ceil)-x));\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205878,
                "title": "c-beats-100-brief-explanation-simple-approch",
                "content": "# Intuition\\ncheck from number of consecutive 1\\'s if it is easier to delete or add.\\n\\n# Approach\\nconvert number into bits and store it in string. calculate number of consecutive 1\\'s in string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n\\nPLS UPVOTE IF YOU LIKE IT!!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int cnt = 0;\\n        string s = \"\";\\n\\n        int m = n;\\n        while(m)\\n        {\\n            if(m%2 == 0)\\n            s += \\'0\\';\\n            else\\n            s += \\'1\\';\\n\\n            m /= 2; \\n        }\\n\\n        int k = 0;\\n\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                if(k > 1)\\n                {\\n                    cnt++;\\n                    s[i] = \\'1\\';\\n                    k = 1;\\n                }\\n                else if(k == 1)\\n                {\\n                    cnt++;\\n                    k = 0;\\n                }\\n            }\\n            else\\n            k++;\\n        }\\n\\n        if(k > 0)\\n        {\\n            if(k == 1)\\n            cnt++; \\n            else\\n            cnt += 2;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int cnt = 0;\\n        string s = \"\";\\n\\n        int m = n;\\n        while(m)\\n        {\\n            if(m%2 == 0)\\n            s += \\'0\\';\\n            else\\n            s += \\'1\\';\\n\\n            m /= 2; \\n        }\\n\\n        int k = 0;\\n\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'0\\')\\n            {\\n                if(k > 1)\\n                {\\n                    cnt++;\\n                    s[i] = \\'1\\';\\n                    k = 1;\\n                }\\n                else if(k == 1)\\n                {\\n                    cnt++;\\n                    k = 0;\\n                }\\n            }\\n            else\\n            k++;\\n        }\\n\\n        if(k > 0)\\n        {\\n            if(k == 1)\\n            cnt++; \\n            else\\n            cnt += 2;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203727,
                "title": "python-easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe don\\'t care if we need to increase or decrease the value to the power of 2 to achieve the goal\\n\\nJust focus on how to make n become 0 and count the number of times\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn order to ensure that n is closer to 0 each time\\n1. Find the power of 2 greater than `n` and the power of 2 less than n\\n2. Take the smallest difference between `n` and the power of 2\\n3. Update `n` using the minimum difference\\n4. Until `n` to 0\\n\\nFor example:  `n` = 39\\nFirst time `n` update to min( |32-39|, |64-39| ) = min(7, 25) = 7\\nSecond time `n` update to min( |8-7|, |4-7| ) = min(1, 3) = 1\\nThird time `n` update to min( |2-1|, |1-1| ) = min(1, 0) = 0\\nwhen n == 0, exit the while and return 3 of times\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O( (log n)^2 )$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        cnt = 0\\n        while n:\\n            exp = 1\\n            while 2**exp < n: exp += 1\\n            n = min(abs(2**exp - n), abs(2**(exp-1) - n))\\n            cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        cnt = 0\\n        while n:\\n            exp = 1\\n            while 2**exp < n: exp += 1\\n            n = min(abs(2**exp - n), abs(2**(exp-1) - n))\\n            cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204223,
                "title": "using-binary-search-c-100-time",
                "content": "``` \\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int>v;\\n        v.push_back(1);\\n        int x = 1;\\n        for(int i=1;i<=17;i++) {\\n            if(x==n) return 1;\\n            x *= 2;\\n            v.push_back(x);\\n        }\\n        x = n;\\n        int ans = 0;\\n        while(true){\\n            ans++;\\n            auto it = lower_bound(v.begin(),v.end(),n);\\n            if(*it==n) break;\\n            n = min(n-*(it-1),*it-n);\\n            if(n<=0) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int>v;\\n        v.push_back(1);\\n        int x = 1;\\n        for(int i=1;i<=17;i++) {\\n            if(x==n) return 1;\\n            x *= 2;\\n            v.push_back(x);\\n        }\\n        x = n;\\n        int ans = 0;\\n        while(true){\\n            ans++;\\n            auto it = lower_bound(v.begin(),v.end(),n);\\n            if(*it==n) break;\\n            n = min(n-*(it-1),*it-n);\\n            if(n<=0) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203747,
                "title": "c-stack",
                "content": "# Stack\\nEach time we encounter a lone 1, we just want to subtract it. However, if we encounter a group, we want to replace it with a 1 at the next possible 0. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ops = 0;\\n        unsigned stack = n;\\n        \\n        while(stack > 0) {\\n            if(stack & 1) {\\n                ops++;\\n                stack >>= 1;\\n                \\n                if(!(stack & 1)) continue;\\n                while(stack & 1) stack >>= 1;\\n                stack |= 1;\\n            }\\n            else stack >>= 1;\\n        }\\n        \\n        return ops;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ops = 0;\\n        unsigned stack = n;\\n        \\n        while(stack > 0) {\\n            if(stack & 1) {\\n                ops++;\\n                stack >>= 1;\\n                \\n                if(!(stack & 1)) continue;\\n                while(stack & 1) stack >>= 1;\\n                stack |= 1;\\n            }\\n            else stack >>= 1;\\n        }\\n        \\n        return ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204768,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=YQVgHC9vNUE) if you are interested.\\n\\n---\\n\\n```py\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        def dp(x):\\n            # reach 0 -> 0 operation\\n            if x == 0: return 0\\n            # if x is a power of 2, \\n            # we need 1 operation (i.e. subtract itself)\\n            if (x & (x - 1)) == 0: return 1\\n            # otherwise we either add / subtract the lsb to x\\n            # e.g. 0111 -> 1000 -> 0000\\n            # e.g. 1001 -> 1000 -> 0000\\n            return min(dp(x + (x & -x)), dp(x - (x & -x))) + 1\\n        return dp(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```py\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        def dp(x):\\n            # reach 0 -> 0 operation\\n            if x == 0: return 0\\n            # if x is a power of 2, \\n            # we need 1 operation (i.e. subtract itself)\\n            if (x & (x - 1)) == 0: return 1\\n            # otherwise we either add / subtract the lsb to x\\n            # e.g. 0111 -> 1000 -> 0000\\n            # e.g. 1001 -> 1000 -> 0000\\n            return min(dp(x + (x & -x)), dp(x - (x & -x))) + 1\\n        return dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203929,
                "title": "easy-recursion-c-nearest-power-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    ll power(int x){\\n        ll res = 1;\\n        for(int i = 0;i<x;i++){\\n            res*=2;\\n        }\\n        return res;\\n    }\\n    int minOperations(int n) {\\n        if(n==0) return 0;\\n        int pt = log2(n);\\n        int mn = power(pt);\\n        int mx = power(pt+1);\\n        int diff1 = n - mn;\\n        int diff2 = mx - n;\\n        if(diff1 > diff2){\\n            return 1 + minOperations(diff2);\\n        }\\n        else{\\n            return 1 + minOperations(diff1);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    ll power(int x){\\n        ll res = 1;\\n        for(int i = 0;i<x;i++){\\n            res*=2;\\n        }\\n        return res;\\n    }\\n    int minOperations(int n) {\\n        if(n==0) return 0;\\n        int pt = log2(n);\\n        int mn = power(pt);\\n        int mx = power(pt+1);\\n        int diff1 = n - mn;\\n        int diff2 = mx - n;\\n        if(diff1 > diff2){\\n            return 1 + minOperations(diff2);\\n        }\\n        else{\\n            return 1 + minOperations(diff1);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204443,
                "title": "easy-recursive-solution-c",
                "content": "**Recursive Solution**\\n**Check Nearest Power Of 2**\\n- Find Nearest Power of 2\\n- Check if you want to go Down or Up\\n\\n***Like for***  ```n = 7```\\n**log2(7) = 2 -> We can go ```pow(2, 2) = 4``` and ```pow(2, 2 + 1) = 8```**\\n- ***if We go 4*** \\nThere will be a recursive call for 3 from that we will go to 2 and 4 ... You can make recursive tree for that\\n- **If we go 8\\n```log2(8) = 3 -> pow(2, 3) = 8 -> 8 - 8 = 0```**\\n\\n**At last going ```4``` will take 3 steps and going to ```8``` will take 2 steps**\\n\\n---\\n\\n---\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int nearPower = log2(n);\\n        int a = pow(2, nearPower), b = pow(2, nearPower + 1);\\n        if((n - a == 0) || (b - n == 0))          \\n            return 1;\\n        return min(minOperations(n - a) + 1, minOperations(b - n) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```n = 7```\n```pow(2, 2) = 4```\n```pow(2, 2 + 1) = 8```\n```log2(8) = 3 -> pow(2, 3) = 8 -> 8 - 8 = 0```\n```4```\n```8```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int nearPower = log2(n);\\n        int a = pow(2, nearPower), b = pow(2, nearPower + 1);\\n        if((n - a == 0) || (b - n == 0))          \\n            return 1;\\n        return min(minOperations(n - a) + 1, minOperations(b - n) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207208,
                "title": "recursive-one-liner-without-library-calls-the-only-rigorous-proof",
                "content": "# Code\\n```\\npublic static int minOperations(int n) {\\n\\treturn n == 0 ? 0 : (n & 1) + minOperations((n + 1) >>> ((n & 1) + 1));\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$O(\\\\log n)$\\n\\n- Space complexity:\\n$O(1)$\\n\\n# Proof\\n\\nLet $f(x)$ be a shorthand for `minOperations(x)`. First off, it is convenient to start from $x=0$. The number is already $0$, so we don\\'t have to do anything, thus\\n\\n$f(0)=0 \\\\qquad (1)$\\n\\nFor $x \\\\ge 0$, we need to apply some operations to convert it to $0$. Notice that\\n\\n- The order of operations is not important.\\n- An optimal sequence cannot contain two or more additions of the same power of $2$, since $2^i + 2^i = 2^{i+1}$ and we could replace two operations by one, thereby reducing the total number of operations.\\n- An optimal sequence cannot contain two or more subtractions of the same power, for the same reason.\\n- An optimal sequence cannot contain both addition and subtraction of the same power at the same time since they, in effect, annihilate each other.\\n\\nThus, any optimal sequence for $x$ contains at most one occurrence of each power of $2$, either as an addend or as a subtrahend. Since they reduce $x$ to $0$, their signed sum must be equal to $-x$. It can be written down as the following representation of $x$:\\n\\n$x=\\\\sum\\\\limits_{i=0}^m k_i\\\\,2^i$, where $m \\\\ge 0$ and each $k_i$ is either $-1$, $0$, or $1$. $\\\\quad (2)$\\n\\nThe total number of operations (let\\'s call it ___cost___ ) is then calculated by\\n\\n$f(x)=\\\\sum\\\\limits_{i=0}^m |k_i|.$\\n\\nFrom $(2)$, we can see that if $x$ is even, $x=2x\\'$, then $k_0$ must be $0$. Dividing $(2)$ by $2$, we get:\\n\\n$x\\'=\\\\sum\\\\limits_{i=1}^m k_i\\\\,2^{i-1}=\\\\sum\\\\limits_{i=0}^{m-1} k_{i+1}\\\\,2^i \\\\qquad (2\\')$\\n\\nThis is a representation of $x\\'$, of the same kind as $(2)$ is for $x$. It must be optimal in terms of cost, otherwise we could decrease the cost for $x$. We obtained a one-to-one correspondence between optimal sequences for $x=2x\\'$ and those for $x\\'$. Thus $f(2x\\')=f(x\\')$, or, in other words, for any $x \\\\ge 0$ :\\n\\n$f(2x)=f(x) \\\\qquad (3)$ \\n\\nOn the other hand, if $x$ is odd, $x=2x\\'+1$, then $k_0$ in $(2)$ must also be odd. If $k_0=1$, then by subtracting $1$ from both parts of $(2)$ and dividing them by $2$, we get $(2\\')$ again. If $k_0=-1$, then by adding $1$ to both parts of $(2)$ and dividing them by $2$, we get $(2\\')$ with the left side changed to $x\\'+1$. This shows that optimal sequences for $2x\\'+1$ must be searched for among those for either $x\\'$ or $x\\'+1$. We choose the one with the lowest cost, shift indices and insert $k_0=\\\\pm 1$ into the sequence thereby increasing the cost by $1$. In other words, for any $x \\\\ge 0$ we have:\\n\\n$f(2x+1)=\\\\min(f(x),\\\\,f(x+1))+1 \\\\qquad (4)$\\n\\nThat was the hardest part of formalizing the problem. $(1),(3),(4)$ are already enough to produce a working program that runs in $O(\\\\log n)$ time.\\n\\n<details>\\n\\t<summary>Intermediate code (not optimized) &nbsp;<i>(click to expand)</i></summary>\\t\\n<br/>\\n\\n\\t// Helper function, returns { minOperations(n), minOperations(n + 1) }\\n\\tprivate static int[] minOpInternal(int n) {\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn new int[] { 0, 1 }; // { f(0), f(1) }\\n\\t\\tint x = n / 2;\\n\\t\\tint[] minOpHalf = minOpInternal(x);\\n\\t\\tint fx = minOpHalf[0]; // f(x)\\n\\t\\tint fx1 = minOpHalf[1]; // f(x+1)\\n\\t\\tint f2x1 = Math.min(fx, fx1) + 1; // f(2x+1)\\n\\t\\tif (n % 2 == 0) // n = 2x\\n\\t\\t\\treturn new int[] { fx, f2x1 }; // { f(2x), f(2x+1) }\\n\\t\\telse // n = 2x+1\\n\\t\\t\\treturn new int[] { f2x1, fx1 }; // { f(2x+1), f(2x+2) }\\n\\t}\\n\\n\\tpublic static int minOperations(int n) {\\n\\t\\treturn minOpInternal(n)[0];\\n\\t}\\n</details>\\n<br/>\\n\\nBut we can go further and notice that for any $x \\\\ge 0$ :\\n\\n$f(x)-1 \\\\le f(x+1) \\\\le f(x)+1 \\\\qquad (5)$\\n\\n<details>\\n\\t<summary>Proof &nbsp;<i>(click to expand)</i></summary>\\n<br/>\\n\\nThis follows directly from the definition of $f(x)$: one of the ways to transform $x + 1$ is to subtract $1$ from it and further transform $x$, thus $f(x+1) \\\\le 1 + f(x)$. On the other hand, one of the ways to transform $x$ is to add $1$ to it and further transform $x + 1$, thus $f(x) \\\\le 1 + f(x+1)$.\\n\\nYou can also prove it by induction, it follows from $(1),(3),(4)$.\\n</details>\\n<br/>\\n\\nand, consequently, prove that\\n\\n$f(4x+1)=f(x)+1 \\\\qquad \\\\quad (6)$\\n$f(4x+3)=f(x+1)+1 \\\\qquad (7)$\\n\\n<details>\\n\\t<summary>Proof &nbsp;<i>(click to expand)</i></summary>\\n<br/>\\n\\nWe use $(4)$ for both cases, then apply $(3)$ and $(4)$ again:\\n\\n$$f(4x+1)=f(2(2x)+1)=\\\\min(f(2x),f(2x+1))+1=\\\\min(f(x),\\\\min(f(x),f(x+1))+1)+1\\\\,;$$\\n\\n$$f(4x+3)=f(2(2x+1)+1)=\\\\min(f(2x+1),f(2x+2))+1=\\\\min(\\\\min(f(x),f(x+1))+1,f(x+1))+1\\\\,.$$\\n\\nNow it\\'s time to use $(5)$: since $f(x+1) \\\\ge f(x)-1$, $\\\\min(f(x),f(x+1)) \\\\ge f(x)-1$, hence $\\\\min(f(x),\\\\min(f(x),f(x+1))+1)=f(x)$ and we get $f(4x+1)=f(x)+1$.\\n\\nSimilarly, since $f(x) \\\\ge f(x+1)-1$, $\\\\min(f(x),f(x+1)) \\\\ge f(x+1)-1$, hence $\\\\min(\\\\min(f(x),f(x+1))+1,f(x+1))=f(x+1)$ and we get $f(4x+3)=f(x+1)+1$.\\n</details>\\n<br/>\\n\\nThe recurrence relations $(3),(6),(7),$ along with the initial condition $(1),$ define the basis for the recursive one-liner given at the beginning of this solution.\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\npublic static int minOperations(int n) {\\n\\treturn n == 0 ? 0 : (n & 1) + minOperations((n + 1) >>> ((n & 1) + 1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204610,
                "title": "video-solution-greedy-recursion-both-c",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=O3VbqTLzTu8\\n\\n# Recursion Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n==0 || n==1)\\n            return n;\\n        \\n        int val = 1;\\n        while(val * 2 < n)\\n            val = val * 2;\\n        \\n        return 1 + min( minOperations(val*2 - n) ,  minOperations(n - val) );\\n    }\\n};\\n```\\n\\n# Greedy Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res = 0;\\n        for (int i = 0; i < 17; ++i)\\n            if (__builtin_popcount(n + (1 << i)) < __builtin_popcount(n)) {\\n                n = n + (1 << i);\\n                ++res;\\n            }\\n        return res + __builtin_popcount(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n==0 || n==1)\\n            return n;\\n        \\n        int val = 1;\\n        while(val * 2 < n)\\n            val = val * 2;\\n        \\n        return 1 + min( minOperations(val*2 - n) ,  minOperations(n - val) );\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res = 0;\\n        for (int i = 0; i < 17; ++i)\\n            if (__builtin_popcount(n + (1 << i)) < __builtin_popcount(n)) {\\n                n = n + (1 << i);\\n                ++res;\\n            }\\n        return res + __builtin_popcount(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203852,
                "title": "java-fully-explained-recursive-easy-and-intuitive",
                "content": "# ***Do Upvote if you like the Explanation* \\u2B06\\uFE0F**\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n- The code implements a recursive approach to solve this problem. The base case is when n is already 0, in which case the function returns 0.\\n\\n- In the recursive step, the code first computes the two closest powers of 2 to n, using the floor and ceil functions from the Math library in Java. These powers of 2 are denoted by a and b, where a <= n <= b.\\n\\n- The code then checks which of the two powers of 2 is closer to n. If b is closer, then the code adds 2^b - n to n, and the recursive call is made with the new value of n. Otherwise, the code subtracts n - 2^a from n, and the recursive call is made with the new value of n.\\n\\n- In either case, the function returns 1 plus the result of the recursive call, since one operation has been performed. This recursive process continues until n becomes 0.\\n# Complexity\\n- Time complexity: O(log^2 n)\\n- The time complexity of the minOperations function is logarithmic, O(log n), because it uses the logarithm function to compute the closest power of 2 to n. The recursive calls to minOperations also have logarithmic time complexity. Therefore, the overall time complexity of the algorithm is O(log^2 n).\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n- Space complexity: O(logn)\\n- The space complexity is also logarithmic because the function uses the call stack to keep track of the recursive calls. Since the depth of the call stack is proportional to the logarithm of n, the space complexity is O(log n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        if (n == 0)\\n            return 0;\\n        int a = (int) Math.floor(Math.log(n) / Math.log(2));\\n        int b = (int) Math.ceil(Math.log(n) / Math.log(2));\\n        if (Math.abs(Math.pow(2, a) - n) > Math.abs(Math.pow(2, b) - n))\\n            return 1 + minOperations(Math.abs((int) Math.pow(2, b) - n));\\n        else\\n            return 1 + minOperations(Math.abs((int) Math.pow(2, a) - n));\\n    }\\n}\\n\\n```\\n\\n![cat upvote.jpeg](https://assets.leetcode.com/users/images/a478bb19-5021-4ac8-9520-874da65961d4_1676779802.2251565.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        if (n == 0)\\n            return 0;\\n        int a = (int) Math.floor(Math.log(n) / Math.log(2));\\n        int b = (int) Math.ceil(Math.log(n) / Math.log(2));\\n        if (Math.abs(Math.pow(2, a) - n) > Math.abs(Math.pow(2, b) - n))\\n            return 1 + minOperations(Math.abs((int) Math.pow(2, b) - n));\\n        else\\n            return 1 + minOperations(Math.abs((int) Math.pow(2, a) - n));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203906,
                "title": "c-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string convert(int n)\\n    {\\n        string ans;\\n        while(n>0)\\n        {\\n            ans+=(n%2==0?\\'0\\':\\'1\\');\\n            n=n/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    int find(string &val)\\n    {\\n       int ans=0;\\n        for(int i=0;i<val.size();i++)\\n        {\\n            if(val[i]==\\'1\\')\\n                ans++;\\n        }\\n        return ans;\\n    }\\n    int minOperations(int n) {\\n       int ans=INT_MAX;\\n        long long val=n+1e5;\\n        long long int curr=n;\\n        while(curr<=val)\\n        {\\n            string s=convert(curr);\\n            int x=find(s);\\n            s=convert(curr-n);\\n            int y=find(s);\\n            ans=min(ans,x+y);\\n            if(ans==1)\\n                break;\\n            \\n            curr++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convert(int n)\\n    {\\n        string ans;\\n        while(n>0)\\n        {\\n            ans+=(n%2==0?\\'0\\':\\'1\\');\\n            n=n/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    int find(string &val)\\n    {\\n       int ans=0;\\n        for(int i=0;i<val.size();i++)\\n        {\\n            if(val[i]==\\'1\\')\\n                ans++;\\n        }\\n        return ans;\\n    }\\n    int minOperations(int n) {\\n       int ans=INT_MAX;\\n        long long val=n+1e5;\\n        long long int curr=n;\\n        while(curr<=val)\\n        {\\n            string s=convert(curr);\\n            int x=find(s);\\n            s=convert(curr-n);\\n            int y=find(s);\\n            ans=min(ans,x+y);\\n            if(ans==1)\\n                break;\\n            \\n            curr++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203856,
                "title": "c-simple-easy-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs you first see the problem you get the idea that we have to reach to the nearest power of 2 to get the minimum no. of operations to make n equal to 0. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse recursion.\\nYou can understand by this example.\\n<br>\\n![WhatsApp Image 2023-02-19 at 09.31.09.jpg](https://assets.leetcode.com/users/images/e46aacb9-e06b-4470-b543-5c0069b728e8_1676779586.5106668.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: log(n) [depth of recursion tree]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: log(n) [recursion stack]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        minOps(n, ans);\\n        return ans;\\n    }\\n    \\n    void minOps(int n, int& ans){\\n        int i=1;\\n        \\n        while(i<n)\\n            i *= 2;\\n        \\n        if(i==n){\\n            ans++;\\n            return;\\n        }\\n        \\n        (i-n) < (n-(i/2)) ? n = i-n : n = n-(i/2);\\n        ans++;\\n        minOps(n, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        minOps(n, ans);\\n        return ans;\\n    }\\n    \\n    void minOps(int n, int& ans){\\n        int i=1;\\n        \\n        while(i<n)\\n            i *= 2;\\n        \\n        if(i==n){\\n            ans++;\\n            return;\\n        }\\n        \\n        (i-n) < (n-(i/2)) ? n = i-n : n = n-(i/2);\\n        ans++;\\n        minOps(n, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203990,
                "title": "java-brute-force-recursion-time-and-space-o-log-n",
                "content": "Our primary goal is to convert the number to a power of 2 in min operations, so I just applied the brute force approach by recursively calling function in the following ways:\\n\\n(n - highest power of 2 just greater than n) + 1\\n(highest power of 2 just smaller than n - n) + 1\\n\\nI used log(n) to the base 2 to find the exponent value e where 2 ^ e <= n.\\n\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        // if the curr value is a power of 2, there is only one subtraction needed\\n        if ((n & (n - 1)) == 0)\\n            return 1;\\n\\n        // highest power of 2 just greater than current value - current value\\n        int diff1 = (1 << ((int)(Math.log(n) / Math.log(2)) + 1)) - n;\\n\\n        // current value - highest power of 2 just smaller than current value\\n        int diff2 = n - (1 << (int)(Math.log(n) / Math.log(2)));\\n\\t\\t\\n\\t\\t// we add 1 in both the cases\\n        return Math.min(minOperations(diff1), minOperations(diff2)) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        // if the curr value is a power of 2, there is only one subtraction needed\\n        if ((n & (n - 1)) == 0)\\n            return 1;\\n\\n        // highest power of 2 just greater than current value - current value\\n        int diff1 = (1 << ((int)(Math.log(n) / Math.log(2)) + 1)) - n;\\n\\n        // current value - highest power of 2 just smaller than current value\\n        int diff2 = n - (1 << (int)(Math.log(n) / Math.log(2)));\\n\\t\\t\\n\\t\\t// we add 1 in both the cases\\n        return Math.min(minOperations(diff1), minOperations(diff2)) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204309,
                "title": "easiest-among-all-c-solution-no-bit-manipulation-no-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*Lets say you have a number n,so one thing is clear that we have to reach to its upper and lower bound which is power of two.To simplify lets take an example. \\nE.g- \\nn=7;\\nso nearest upper and lower power of 2 of n is  4 and 8 respectively.\\nNow if we can find minimum steps or operation to reach either 4 or 8.\\nWe can easily observe that total no of steps will be \\n(min steps to reach 4 or 8 +1);*\\n\\n\\n---\\n\\nI you have not understood till here, you will look the explanation below.\\n\\nLets look at some of the small test cases:\\nn=1  ans=1;   n=6 ans=2;\\nn=2  ans=1;   n=7 ans=2;\\nn=3  ans=2;   n=8 ans=1;\\nn=4  ans=1;\\nn=5  ans=2;\\n\\n```\\nIMPORTANT OBSERVATION: Steps required to move from n to 0 is same as 0 to n.\\n```\\n\\nNow lets take n=7;\\nSo we can say that either we will move to 8 or to 4.\\n**Case 1**:Move to 4 ->so we need to subtract 3.\\ni.e we need to get a value 3 by doing minimum operations of two.\\nwhich is equal to 2.\\n[Beacause 3 can be obtained from 0 by 2 steps].\\n\\n**Case 2**:Move to 8 ->similarly we have to move a difference of 1 from 7 to achieve a power of two.\\nSo 1 can be obtained from 0 by 1 step using power of two.\\n\\n---\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSo we will do following steps:\\n```\\nMove from i to n\\n1.Find upper and lower power of two nearast to i.\\n2.Find the difference of (i and lower) and (upper and i)\\n    i.e->find value of i-lower and upper-i\\n3.Now from the stored value we will find the minimum of(dp[i-lower],dp[upper-i]);\\n4. So ans of dp[i]=min(dp[i-lower],dp[upper-i])+1;\\n5. So we now got dp[i] which is stored in dp table.\\n```\\n\\nLOOK AT THE CODE BELOW\\n\\n# Complexity\\n- Time complexity:O(N);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(N);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n<=2){return 1;}\\n        vector<int>dp(n+1,1);\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=1;\\n        dp[3]=2;\\n        for(int i=4;i<=n;i++){\\n            int power=log2(i);\\n            int low=pow(2,p);//lower bound\\n            int high=low*2;//upper bound\\n            if(low==i){dp[i]=1;}// if i is a power of 2 then ans wil\\n//be 1.\\n            else\\n            dp[i]=min(dp[i-low],dp[high-i])+1;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n***Hope you like it.\\nThank You. :D***\\n***Feel free to comment if explanation is not understandable.***\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nIMPORTANT OBSERVATION: Steps required to move from n to 0 is same as 0 to n.\\n```\n```\\nMove from i to n\\n1.Find upper and lower power of two nearast to i.\\n2.Find the difference of (i and lower) and (upper and i)\\n    i.e->find value of i-lower and upper-i\\n3.Now from the stored value we will find the minimum of(dp[i-lower],dp[upper-i]);\\n4. So ans of dp[i]=min(dp[i-lower],dp[upper-i])+1;\\n5. So we now got dp[i] which is stored in dp table.\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if(n<=2){return 1;}\\n        vector<int>dp(n+1,1);\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=1;\\n        dp[3]=2;\\n        for(int i=4;i<=n;i++){\\n            int power=log2(i);\\n            int low=pow(2,p);//lower bound\\n            int high=low*2;//upper bound\\n            if(low==i){dp[i]=1;}// if i is a power of 2 then ans wil\\n//be 1.\\n            else\\n            dp[i]=min(dp[i-low],dp[high-i])+1;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204040,
                "title": "easy-java-solution-100-faster-0ms",
                "content": "\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n\\n     List<Integer> power =new ArrayList<>();\\n       int count=0;\\n      while(n>0)\\n      {  \\n          int diff=0;\\n          for(int i=0;i<30;i++)\\n          {\\n            int val1=(int)Math.pow(2,i);\\n            int val2=(int)Math.pow(2,i+1);\\n              if(n>val1 && n<val2)\\n              {\\n                  diff=Math.min(n-val1,val2-n);\\n                  break;\\n              }\\n          }\\n          count++;\\n          n=diff;\\n      }\\n      return  count;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n\\n     List<Integer> power =new ArrayList<>();\\n       int count=0;\\n      while(n>0)\\n      {  \\n          int diff=0;\\n          for(int i=0;i<30;i++)\\n          {\\n            int val1=(int)Math.pow(2,i);\\n            int val2=(int)Math.pow(2,i+1);\\n              if(n>val1 && n<val2)\\n              {\\n                  diff=Math.min(n-val1,val2-n);\\n                  break;\\n              }\\n          }\\n          count++;\\n          n=diff;\\n      }\\n      return  count;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203838,
                "title": "recursive-solution-with-intuition-and-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. So we have 2 operations either add a power of 2 to n or subtract a power of 2 from n.\\n2. So first thing comes in mind for choices is recursion. \\nWe have 2 Choices either choose 2^log2(n) or 2^log2(n)+1.\\n3. We choosing above choices because we need to find minimum operations and if we find nearest power of 2 with respect to n then we get minimum operations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if n is already a power of 2 or not if true, then return 1.\\n2. Find the nearest power of 2 and perform recursion.\\n3. See the below code to understand better.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if((n&(n-1))==0)\\n            return 1;\\n\\n        int leftNearestPower=log2(n);\\n        int rightNearestPower=leftNearestPower+1;\\n\\n        return min(1+(minOperationsn-(1<<leftNearestPower)), \\n                  1+minOperations((1<<rightNearestPower)-n));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if((n&(n-1))==0)\\n            return 1;\\n\\n        int leftNearestPower=log2(n);\\n        int rightNearestPower=leftNearestPower+1;\\n\\n        return min(1+(minOperationsn-(1<<leftNearestPower)), \\n                  1+minOperations((1<<rightNearestPower)-n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203782,
                "title": "power-of-2-less-than-and-greater-than-n-c",
                "content": "```\\n  \\n    int minOperations(int n) {\\n        if (n==0) return 0;\\n        int a=floor(log2(n)); //power of 2 which is less than n\\n        a=(int)pow(2,a);\\n        int b=ceil(log2(n));  //power of 2 which is greater than n\\n        b=(int)pow(2,b);\\n        \\n        if (n-a>b-n)\\n            return 1+minOperations(b-n);\\n        else\\n            return 1+minOperations(n-a);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  \\n    int minOperations(int n) {\\n        if (n==0) return 0;\\n        int a=floor(log2(n)); //power of 2 which is less than n\\n        a=(int)pow(2,a);\\n        int b=ceil(log2(n));  //power of 2 which is greater than n\\n        b=(int)pow(2,b);\\n        \\n        if (n-a>b-n)\\n            return 1+minOperations(b-n);\\n        else\\n            return 1+minOperations(n-a);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545450,
                "title": "100-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0, x = 0;\\n        while(n){\\n            x = 0;\\n            if(n&1){\\n                while(n && n&1){\\n                    x++;\\n                    n >>= 1;\\n                }\\n                ans++;\\n                if(x>1){\\n                    n |= 1;\\n                }\\n            }else{\\n                n >>= 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0, x = 0;\\n        while(n){\\n            x = 0;\\n            if(n&1){\\n                while(n && n&1){\\n                    x++;\\n                    n >>= 1;\\n                }\\n                ans++;\\n                if(x>1){\\n                    n |= 1;\\n                }\\n            }else{\\n                n >>= 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209210,
                "title": "easiest-recursive-solution-to-understand",
                "content": "# Intuition and Approach\\nGet the next nearest power of 2 and previous nearest power of 2 to a particular number.\\nTry to reach to a power of 2 from both these values and add +1 operation on the way.\\nIf we reach a power of 2 we know that it will take 1 operation to get to 0 so return 1. This is our base case.\\n\\n# Whats log2(n) ?\\nlog2() is mathematical logarithmic of a number with base 2 which gives us nearest power of 2 to the number\\nExample\\nlog2(16) = 4   // 2^4 = 16 it means for number 16 2^4 is nearest\\nlog2(20) = 4.322 which is 4 in integer which means for number 20 2^4 is nearest\\nsimilarly log2(n) = x means for number n 2^x is the nearest power of 2\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPower2(int val){\\n        bitset<32> b(val);\\n        return b.count()==1;\\n    }\\n    int minOperations(int n) {\\n        int log = log2(n);\\n        if(isPower2(n)) return 1;\\n        int nextVal = (1<<(log+1)); // Next nearest power of 2. \\n        int prevVal = (1<<(log)); // Previous nearest power of 2.\\n        return 1 + min(minOperations(nextVal-n),minOperations(n-prevVal));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPower2(int val){\\n        bitset<32> b(val);\\n        return b.count()==1;\\n    }\\n    int minOperations(int n) {\\n        int log = log2(n);\\n        if(isPower2(n)) return 1;\\n        int nextVal = (1<<(log+1)); // Next nearest power of 2. \\n        int prevVal = (1<<(log)); // Previous nearest power of 2.\\n        return 1 + min(minOperations(nextVal-n),minOperations(n-prevVal));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207370,
                "title": "c-beats-100-runtime-100-memory-bitmask-easy-explanation-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne of the best solutions, I believe this is comparatively easy to understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIncrease `res` by 1 for single 1 bit (Subtracting a power of two) and\\nIncrease `res` by 1 for group of 1 bits, but set current 0 bit to 1. (Adding a power of two to the group of 1s).\\nPlease refer the comments in code for better understanding.\\nDo upvote if helpful.\\n\\n# Complexity\\n- Time complexity: `O(log N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if((n & (n - 1)) == 0) return 1; // a power of 2\\n        int res = 0, oneCnt = 0;\\n        // traverse each bit from lsb to msb\\n        for(int i = 0; (1 << i) < n; i++){\\n            if(n & (1 << i)) // current bit is set\\n                oneCnt++;\\n            else{ // the current bit is 0\\n                if(oneCnt == 1){ // single 1 bit means we subtract n by 10..0 (1 is the current+1 bit)\\n                    // this changes the single 1 bit in right to a 0 bit and current bit remains a 0.\\n                    res++; oneCnt = 0;\\n                }\\n                else if(oneCnt > 1){ // adding a 1(=2^0) to a group of ones will give a 1 at current bit and rest to right are already made zeros\\n                    res++; oneCnt = 1;\\n                }\\n            }\\n        }\\n        // for msb bit, if there are a group of ones,\\n        if(oneCnt == 1) res++; // can subtract by a power of 2 to get 0\\n        else if(oneCnt > 1) res += 2; // changing 1s to 0 by adding 1 which results in a power of 2\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if((n & (n - 1)) == 0) return 1; // a power of 2\\n        int res = 0, oneCnt = 0;\\n        // traverse each bit from lsb to msb\\n        for(int i = 0; (1 << i) < n; i++){\\n            if(n & (1 << i)) // current bit is set\\n                oneCnt++;\\n            else{ // the current bit is 0\\n                if(oneCnt == 1){ // single 1 bit means we subtract n by 10..0 (1 is the current+1 bit)\\n                    // this changes the single 1 bit in right to a 0 bit and current bit remains a 0.\\n                    res++; oneCnt = 0;\\n                }\\n                else if(oneCnt > 1){ // adding a 1(=2^0) to a group of ones will give a 1 at current bit and rest to right are already made zeros\\n                    res++; oneCnt = 1;\\n                }\\n            }\\n        }\\n        // for msb bit, if there are a group of ones,\\n        if(oneCnt == 1) res++; // can subtract by a power of 2 to get 0\\n        else if(oneCnt > 1) res += 2; // changing 1s to 0 by adding 1 which results in a power of 2\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205121,
                "title": "python-3-7-lines-w-example-and-explanation-t-m-21-ms-13-8-mb",
                "content": "Here\\'s the plan:\\n- We determine the binary string for`n`and`split`it on the zeros.\\n- We`map`the elements in the`split`list to their`len`integers.\\n- If the mapped element is one, we increment`ans`by one (the subtract option); if greater than one, we increment`ans`as well as the next element by one as a carry digit (the add option).\\n\\nThere are a few other wrinkles, but that\\'s the gist of it.\\n\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int: # Example: n = 883 = 0b_1101110011\\n                                           \\n        n, ans = bin(n)[2:].split(\\'0\\'), 0   #          n = [\\'11\\', \\'111\\',\\'\\',\\'11\\']\\n        \\n        n = list(map(len,n))+[0]            #          n = [  2 ,    3 , 0,  2 ] + [0]\\n\\n        for i in range(len(n)-1):           #    i    ans     n            \\n            if n[i]:                        #   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013     \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                ans+= 1                     #                 [2,3,0,2,0]\\n                n[i+1]+= n[i] > 1           #    0     1      [_,4,0,2,0]\\n                                            #    1     2      [_,_,1,2,0]\\n        return ans + n[-1]                  #    2     3      [_,_,_,2,0]\\n                                            #    3     4      [_,_,_,_,1]\\n                                            # return 4 + 1 = 5\\n```\\n[](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int: # Example: n = 883 = 0b_1101110011\\n                                           \\n        n, ans = bin(n)[2:].split(\\'0\\'), 0   #          n = [\\'11\\', \\'111\\',\\'\\',\\'11\\']\\n        \\n        n = list(map(len,n))+[0]            #          n = [  2 ,    3 , 0,  2 ] + [0]\\n\\n        for i in range(len(n)-1):           #    i    ans     n            \\n            if n[i]:                        #   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013     \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                ans+= 1                     #                 [2,3,0,2,0]\\n                n[i+1]+= n[i] > 1           #    0     1      [_,4,0,2,0]\\n                                            #    1     2      [_,_,1,2,0]\\n        return ans + n[-1]                  #    2     3      [_,_,_,2,0]\\n                                            #    3     4      [_,_,_,_,1]\\n                                            # return 4 + 1 = 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203775,
                "title": "python-beats-100-bit-explanation-runtime",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Aproach\\nFirst, convert `n` to binary. We start from the least significant digit (rightmost) and work our way to the most significant digit (leftmost). If there is an isolated one (ie. $$1010_2$$), we just remove the corresponding power of two. However, if there are consecutive 1\\'s, adding a power of two will minimize the resulting number of bits: \\n(ie. $$10111_2 + 1_2 \\\\rightarrow 11000_2 + 1000_2 \\\\rightarrow 100000_2 - 100000_2 \\\\rightarrow 0_2$$)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        bin_rep = bin(n)[2:]\\n        num_ops = 0\\n        consecutive_ones = 0\\n        for i in range(len(bin_rep)-1,-1,-1):\\n            if bin_rep[i] == \"1\":\\n                consecutive_ones += 1\\n            else:\\n                if consecutive_ones == 1:\\n                    consecutive_ones = 0\\n                    num_ops += 1\\n                elif consecutive_ones > 1:\\n                    consecutive_ones = 1\\n                    num_ops += 1\\n        if consecutive_ones == 1:\\n            num_ops += 1\\n        elif consecutive_ones > 1:\\n            num_ops += 2\\n        return num_ops\\n```\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        bin_rep = bin(n)[2:]\\n        num_ops = 0\\n        consecutive_ones = 0\\n        for i in range(len(bin_rep)-1,-1,-1):\\n            if bin_rep[i] == \"1\":\\n                consecutive_ones += 1\\n            else:\\n                if consecutive_ones == 1:\\n                    consecutive_ones = 0\\n                    num_ops += 1\\n                elif consecutive_ones > 1:\\n                    consecutive_ones = 1\\n                    num_ops += 1\\n        if consecutive_ones == 1:\\n            num_ops += 1\\n        elif consecutive_ones > 1:\\n            num_ops += 2\\n        return num_ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220776,
                "title": "java-using-treeset-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        TreeSet<Integer> t=new TreeSet<>();\\n        for(int i=0;i<=17;i++){\\n            t.add((int)Math.pow(2,i));\\n        }\\n        /*\\n        [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384,\\n         32768, 65536, 131072]\\n        n is between 1 to 10^5(100000).2^17 is sufficient for this constraints\\n        */\\n        int count=0;\\n        while(n!=0)\\n        {\\n            count++;\\n            int l=t.floor(n);\\n            int h=t.ceiling(n);\\n            if(l==n||h==n)break;\\n            if(h-n>=n-l){\\n                n=n-l;\\n            }else{\\n                n=h-n;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        TreeSet<Integer> t=new TreeSet<>();\\n        for(int i=0;i<=17;i++){\\n            t.add((int)Math.pow(2,i));\\n        }\\n        /*\\n        [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384,\\n         32768, 65536, 131072]\\n        n is between 1 to 10^5(100000).2^17 is sufficient for this constraints\\n        */\\n        int count=0;\\n        while(n!=0)\\n        {\\n            count++;\\n            int l=t.floor(n);\\n            int h=t.ceiling(n);\\n            if(l==n||h==n)break;\\n            if(h-n>=n-l){\\n                n=n-l;\\n            }else{\\n                n=h-n;\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204442,
                "title": "simple-java-binary-search-solution-100-faster",
                "content": "\\t\\tIntution:we need the power of 2 number which is closest to n\\n\\t\\t\\t\\t\\t so for that purpose i m using binary search it will give\\n\\t\\t\\t\\t\\t me 2 values low and high and finding the one by subtracting it with n\\n\\t\\t\\t\\t\\t to get the number with minimum difference\\n\\t\\t\\t\\t\\t kept repeating this process\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t TC:O(log2n)\\n\\t\\t\\t\\t\\t Ps;idk if the tc is correct, corrections in TC is highly appreciated\\n\\n\\t\\t\\tint count =0;\\n\\t\\t\\twhile (n>0) {\\n\\t\\t\\t\\tInteger l=0, h=n+1;\\n\\t\\t\\t\\twhile (l <= h) {\\n\\t\\t\\t\\t\\tInteger mid = l + (h - l) / 2;\\n\\t\\t\\t\\t\\tif (Math.pow(2, mid) == n){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\treturn count;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (Math.pow(2, mid) > n) {\\n\\t\\t\\t\\t\\t\\th = mid - 1;\\n\\t\\t\\t\\t\\t} else if (Math.pow(2, mid) < n) {\\n\\t\\t\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint min = (int) 1e9;\\n\\t\\t\\t\\tint lowDifference = (int) Math.pow(2, l);\\n\\t\\t\\t\\tint highDifference = (int) Math.pow(2, h);\\n\\n\\t\\t\\t\\tmin = Math.min(lowDifference - n, n - highDifference);\\n\\t\\t\\t\\tn=min;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tDo upvote if it helps :D",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\t\\tIntution:we need the power of 2 number which is closest to n\\n\\t\\t\\t\\t\\t so for that purpose i m using binary search it will give\\n\\t\\t\\t\\t\\t me 2 values low and high and finding the one by subtracting it with n\\n\\t\\t\\t\\t\\t to get the number with minimum difference\\n\\t\\t\\t\\t\\t kept repeating this process\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t TC:O(log2n)\\n\\t\\t\\t\\t\\t Ps;idk if the tc is correct, corrections in TC is highly appreciated\\n\\n\\t\\t\\tint count =0;\\n\\t\\t\\twhile (n>0) {\\n\\t\\t\\t\\tInteger l=0, h=n+1;\\n\\t\\t\\t\\twhile (l <= h) {\\n\\t\\t\\t\\t\\tInteger mid = l + (h - l) / 2;\\n\\t\\t\\t\\t\\tif (Math.pow(2, mid) == n){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\treturn count;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (Math.pow(2, mid) > n) {\\n\\t\\t\\t\\t\\t\\th = mid - 1;\\n\\t\\t\\t\\t\\t} else if (Math.pow(2, mid) < n) {\\n\\t\\t\\t\\t\\t\\tl = mid + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint min = (int) 1e9;\\n\\t\\t\\t\\tint lowDifference = (int) Math.pow(2, l);\\n\\t\\t\\t\\tint highDifference = (int) Math.pow(2, h);\\n\\n\\t\\t\\t\\tmin = Math.min(lowDifference - n, n - highDifference);\\n\\t\\t\\t\\tn=min;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tDo upvote if it helps :D",
                "codeTag": "Unknown"
            },
            {
                "id": 3204100,
                "title": "simple-intuitive-recursive-nearest-power-of-2",
                "content": "# Intuition\\nAs the question says to reduce the given integer n to 0 by adding or subtrating power of 2 from n.\\nSo, the intuition is to make the given number to the closest power of two either by adding or subtracting any power of 2 whichever causes less moves.\\n\\n# Approach\\nBase Case:-\\nIf the given number is of power of 2, simple we can return 1.\\n\\nOtherwise, we have 2 cases:-\\n1. make given number power of 2 by adding some power of 2.\\n2. make given number power of 2 by subtracting some power of 2.\\n\\nTo get the how many moves is required to get the nearest power of 2, we can call the minOperations function for the above 2 cases. Just add 1 to min of above 2 cases to get the required answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // power of 2 less than or equal to n\\n        int p = log2(n);\\n        \\n        // Base Case:- If n is already a power of 2\\n        if((1 << p) == n) return 1;\\n        \\n        // getting next power of 2\\n        int np = p + 1;\\n        \\n        // number to be subtracted for going previous power of 2\\n        int diff1 = n - (1 << p);\\n\\n        // number to be subtracted for going previous power of 2        \\n        int diff2 = (1 << np) - n;\\n        \\n        // getting min of two above possible outcomes\\n        return 1 + min(minOperations(diff1), minOperations(diff2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // power of 2 less than or equal to n\\n        int p = log2(n);\\n        \\n        // Base Case:- If n is already a power of 2\\n        if((1 << p) == n) return 1;\\n        \\n        // getting next power of 2\\n        int np = p + 1;\\n        \\n        // number to be subtracted for going previous power of 2\\n        int diff1 = n - (1 << p);\\n\\n        // number to be subtracted for going previous power of 2        \\n        int diff2 = (1 << np) - n;\\n        \\n        // getting min of two above possible outcomes\\n        return 1 + min(minOperations(diff1), minOperations(diff2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203962,
                "title": "java-simple-beats-100-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {  \\n  public int minOperations(int n) {\\n    var ans = 0;\\n    \\n    for (var diff = n-1; diff >= 0; n = diff, diff--, ans++)\\n      for (var i=1; i < n && Math.abs(n - i*2) < diff; i *= 2)\\n        diff = Math.abs(n - i*2);\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {  \\n  public int minOperations(int n) {\\n    var ans = 0;\\n    \\n    for (var diff = n-1; diff >= 0; n = diff, diff--, ans++)\\n      for (var i=1; i < n && Math.abs(n - i*2) < diff; i *= 2)\\n        diff = Math.abs(n - i*2);\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203791,
                "title": "python3-carry",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/485c537c6fa9056ce656959ea352d2a68cef473f) for solutions of weekly 333. \\n\\n**Intuition**\\nIf a set bit has neighbor set bit (including the carried set bit), it is beneficial to group them by adding; \\nIf a set bit has no neighbor, it is beneficial to subtract. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        ans = carry = 0\\n        while n: \\n            carry += n & 1\\n            if carry == 1: \\n                if n & 2: carry = 1\\n                else: carry = 0 \\n                ans += 1\\n            carry = min(1, carry)\\n            n >>= 1\\n        return ans + carry\\n```\\n\\n**Complexity**\\nTime `O(logN)`\\nSpace `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        ans = carry = 0\\n        while n: \\n            carry += n & 1\\n            if carry == 1: \\n                if n & 2: carry = 1\\n                else: carry = 0 \\n                ans += 1\\n            carry = min(1, carry)\\n            n >>= 1\\n        return ans + carry\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995910,
                "title": "recursion-easy-cpp-soltuion-power-of-2",
                "content": "```\\nclass Solution {\\nprivate:    \\n    bool helpme_2(int n)\\n    {\\n        if (n == 0)    return false;\\n        while (n != 1)\\n        {\\n            if (n % 2 != 0)   return false;;\\n            n = n / 2;\\n        }\\n        return true;\\n    }\\n    \\n    int helpme(int n)\\n    {\\n        if (n == 0)   return 1;\\n\\n        if (helpme_2(n))   return 1;\\n        \\n        long long res = 1;\\n        int count = 0;\\n        while(res < n)\\n        {\\n            res = res* 2;\\n            count += 1;\\n        }\\n        long long peeche = pow(2,count-1);\\n        long long aage = pow(2, count);\\n\\n        return 1 + min(helpme(n-peeche) , helpme(aage-n));\\n    }\\n    \\npublic:\\n    int minOperations(int n)\\n    {\\n        return helpme(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:    \\n    bool helpme_2(int n)\\n    {\\n        if (n == 0)    return false;\\n        while (n != 1)\\n        {\\n            if (n % 2 != 0)   return false;;\\n            n = n / 2;\\n        }\\n        return true;\\n    }\\n    \\n    int helpme(int n)\\n    {\\n        if (n == 0)   return 1;\\n\\n        if (helpme_2(n))   return 1;\\n        \\n        long long res = 1;\\n        int count = 0;\\n        while(res < n)\\n        {\\n            res = res* 2;\\n            count += 1;\\n        }\\n        long long peeche = pow(2,count-1);\\n        long long aage = pow(2, count);\\n\\n        return 1 + min(helpme(n-peeche) , helpme(aage-n));\\n    }\\n    \\npublic:\\n    int minOperations(int n)\\n    {\\n        return helpme(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223157,
                "title": "simple-c-solution-greedy-solution-pre-computation",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int minOperations(int n)\\n        {\\n            vector<int> vec;\\n            int x = 1;\\n            while (x <= 1e6)\\n            {\\n                vec.push_back(x);\\n                x += x;\\n            }\\n            int cnt = 0;\\n            while (n != 0)\\n            {\\n                cnt++;\\n                int l = lower_bound(vec.begin(), vec.end(), n) - vec.begin();\\n                if (vec[l] == n) n = 0;\\n                else\\n                {\\n                    if (n - vec[l - 1] < vec[l] - n)\\n                        n = n - vec[l - 1];\\n                    else\\n                        n = vec[l] - n;\\n                }\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minOperations(int n)\\n        {\\n            vector<int> vec;\\n            int x = 1;\\n            while (x <= 1e6)\\n            {\\n                vec.push_back(x);\\n                x += x;\\n            }\\n            int cnt = 0;\\n            while (n != 0)\\n            {\\n                cnt++;\\n                int l = lower_bound(vec.begin(), vec.end(), n) - vec.begin();\\n                if (vec[l] == n) n = 0;\\n                else\\n                {\\n                    if (n - vec[l - 1] < vec[l] - n)\\n                        n = n - vec[l - 1];\\n                    else\\n                        n = vec[l] - n;\\n                }\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221879,
                "title": "very-easy-solution-simple-explanation-with-example-c",
                "content": "# Approach\\nLook for the set bits (represented as 1 in binary) in the binary of `n` starting from right side, whenever a set bit is found there will be two cases:\\n\\n1. We can remove that set bit i.e. subtract its equivalent decimal value from `n`\\n\\n2. We can add that set bit i.e. add its equivalent decimal value to `n`\\n\\nIn one of the above cases, we will have a number which has lower number of set bits.\\n\\nThe case having lower number of set bits will become our new `n`.\\n\\nWe will repeat above process and increase our count until `n` becomes 0.\\n\\nWe can count number of set bits quickly using `__builtin_popcount`.\\n\\n# Example\\n- If binary is 110010 (3 set bits) then subtracting 2 (represented as 10 in binary) will give 110000 which has 2 set bits, and adding 2 will give 110100 which has 3 set bits, so we will choose case 1 because it leads us towards lower number of set bits.\\n\\n- If binary is 00111 (3 set bits) then adding 1 will give 01000 which has 1 set bit, and subtracting 1 will give 00110 having 2 set bits, so we will go with case 1 as it leads us towards lower number of set bits.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int cnt = 0;\\n        while (n) {\\n            cnt++;\\n            for (int i = 0; n >= (1 << i); i++) {\\n                if (n & (1 << i)) {\\n                    if (__builtin_popcount(n - (1 << i)) < __builtin_popcount(n + (1 << i))) {\\n                        n -= (1 << i);\\n                    }\\n                    else n += (1 << i);\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Update\\nWe can remove the inner for-loop by directly using a formula to find the equivalent decimal value of the rightmost set bit: `n & ~(n - 1)`.\\n\\n# Updated Code\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int cnt = 0, i = 0;\\n        while (n) {\\n            cnt++;\\n            if (__builtin_popcount(n - (n & ~(n - 1))) < __builtin_popcount(n + (n & ~(n - 1)))) {\\n                n -= (n & ~(n - 1));\\n            }\\n            else n += (n & ~(n - 1));\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int cnt = 0;\\n        while (n) {\\n            cnt++;\\n            for (int i = 0; n >= (1 << i); i++) {\\n                if (n & (1 << i)) {\\n                    if (__builtin_popcount(n - (1 << i)) < __builtin_popcount(n + (1 << i))) {\\n                        n -= (1 << i);\\n                    }\\n                    else n += (1 << i);\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int cnt = 0, i = 0;\\n        while (n) {\\n            cnt++;\\n            if (__builtin_popcount(n - (n & ~(n - 1))) < __builtin_popcount(n + (n & ~(n - 1)))) {\\n                n -= (n & ~(n - 1));\\n            }\\n            else n += (n & ~(n - 1));\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208121,
                "title": "recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Let n = 39\\n2. Since we can only +/- a power-of-2 to/from n, it would be better to find the two closest power-of-2 w.r.t n.\\n3. For n = 39, the closest power-of-2 are 32 and 64. (By closest, I mean one less than 39 and one more than 39). Hence, 32 < 39 < 64.\\n4. Now check which one of the two closest power-of-2 has the minimum distance with n. In above case, 32 wins. (39-32 < 64-39).\\n5. So, now our task reduces to -> Minimum steps to convert 39 to 32. Because, once we convert 39 to 32, there\\'s only 1 step involved which is => subtract 32 (because remember, 32 is the power-of-2).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor the above case (n = 39), we found out that the closest power-of-2 is 32. \\nDiff = 39 - 32 = 7.\\nRepeat the intuition of n = 7. Why does this approach works ? Because, our goal is to convert 39 -> 32. The only gap that\\'s preventing us to convert 39 into 32 is 7. So, we have to count the steps to reduce 7 -> 0 and add 1 extra step for subtracting 32 from our desired end result 32.\\nNote that I didn\\'t know of this approach beforehand. It was through trial/errors and some prior knowledge of bitmasking (especially the concept of lowerOneBit and higherOneBit) which helped me to figure out the solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAlthough it\\'s a recursive solution, I\\'m not sure if the time complexity is exponential. Indeed, I think it\\'s fairly constant. Because each time I\\'m just finding the difference b/w the number and it\\'s closest power-of-2. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        System.out.println(n);\\n        if((n & (n-1)) == 0) return 1;\\n        int right = 1 << ((int)(Math.log(n) / Math.log(2)) + 1);\\n        int left = Integer.highestOneBit(n);\\n        int diff = Math.min(Math.abs(n - right), Math.abs(n - left));\\n        return minOperations(diff) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        System.out.println(n);\\n        if((n & (n-1)) == 0) return 1;\\n        int right = 1 << ((int)(Math.log(n) / Math.log(2)) + 1);\\n        int left = Integer.highestOneBit(n);\\n        int diff = Math.min(Math.abs(n - right), Math.abs(n - left));\\n        return minOperations(diff) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206700,
                "title": "video-explanation-both-dijkstra-bfs",
                "content": "# Video Explanation\\n\\nhttps://youtu.be/0hD4lRfK-OQ\\n\\n# Code\\n```\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int> cost (2*n+1, 20);\\n        cost[0] = 0;\\n        \\n        set<pair<int, int>> q;\\n        for (int j = 0; j <= 2*n; j ++) q.insert({cost[j], j});\\n        \\n        while (!q.empty()){\\n            pair<int, int> cur = *q.begin();\\n            q.erase (q.begin());\\n            \\n            if (cur.S == n) return cur.F;\\n            \\n            for (int j = 0; j < 18; j ++) {\\n                int dest = cur.S + (1 << j);\\n                if (dest <= 2*n) {\\n                    int new_cost = cur.F + 1;\\n                    if (new_cost < cost[dest]) {\\n                        q.erase ({cost[dest], dest});\\n                        cost[dest] = new_cost;\\n                        q.insert({cost[dest], dest});\\n                    }\\n                }\\n                \\n                dest = cur.S - (1 << j);\\n                if (dest > 0) {\\n                    int new_cost = cur.F + 1;\\n                    if (new_cost < cost[dest]) {\\n                        q.erase ({cost[dest], dest});\\n                        cost[dest] = new_cost;\\n                        q.insert({cost[dest], dest});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        assert(false);\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int> cost (2*n+1, 20);\\n        cost[0] = 0;\\n        \\n        set<pair<int, int>> q;\\n        for (int j = 0; j <= 2*n; j ++) q.insert({cost[j], j});\\n        \\n        while (!q.empty()){\\n            pair<int, int> cur = *q.begin();\\n            q.erase (q.begin());\\n            \\n            if (cur.S == n) return cur.F;\\n            \\n            for (int j = 0; j < 18; j ++) {\\n                int dest = cur.S + (1 << j);\\n                if (dest <= 2*n) {\\n                    int new_cost = cur.F + 1;\\n                    if (new_cost < cost[dest]) {\\n                        q.erase ({cost[dest], dest});\\n                        cost[dest] = new_cost;\\n                        q.insert({cost[dest], dest});\\n                    }\\n                }\\n                \\n                dest = cur.S - (1 << j);\\n                if (dest > 0) {\\n                    int new_cost = cur.F + 1;\\n                    if (new_cost < cost[dest]) {\\n                        q.erase ({cost[dest], dest});\\n                        cost[dest] = new_cost;\\n                        q.insert({cost[dest], dest});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        assert(false);\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204470,
                "title": "best-solution-with-o-logn-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int c=0;\\n        while(n!=0)\\n        {\\n            int i=0;\\n            for(i=0;i<=32;i++)\\n           { if(pow(2,i)>n)\\n                break;}\\n            n=min(n-pow(2,i-1),pow(2,i)-n);\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int c=0;\\n        while(n!=0)\\n        {\\n            int i=0;\\n            for(i=0;i<=32;i++)\\n           { if(pow(2,i)>n)\\n                break;}\\n            n=min(n-pow(2,i-1),pow(2,i)-n);\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204266,
                "title": "based-on-great-idea-from-alpha-690163",
                "content": "# Intuition\\nComments:\\nWhen n is even number, divide by 2 (operation no change)\\nWhen n is odd number, operation count added by 1\\nIf n is 1 (base case) or last 2 digits of n is 01, minus n by 1\\nelse add n by 1.\\nThe logic behind choose add 1 or minus 1, is how to make last 2 digit to 0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minOperations = function (n) {\\n  let oneArr = [];\\n  let ans = 0;\\n  while (n !== 0) {\\n    if (n % 2 === 1) {\\n      ans++;\\n      if (n === 1 || (n & 2) === 0) n--;\\n      else n++;\\n    } else n /= 2;\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minOperations = function (n) {\\n  let oneArr = [];\\n  let ans = 0;\\n  while (n !== 0) {\\n    if (n % 2 === 1) {\\n      ans++;\\n      if (n === 1 || (n & 2) === 0) n--;\\n      else n++;\\n    } else n /= 2;\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204167,
                "title": "greedy-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        string str = \"\";\\n        while(n){\\n            if(n&1){\\n                str = str+\\'1\\';\\n            }else{\\n                str = str+\\'0\\';\\n            }\\n            n >>= 1;\\n        }\\n        int ans = 0,o,z;\\n        for(int i = 0; i < str.length();){\\n            o = 0, z = 0;\\n            while(i<str.length()&&str[i]==\\'0\\'){\\n                z++;\\n                i++;\\n            }\\n            while(i<str.length()&&str[i]==\\'1\\'){\\n                o++;\\n                i++;\\n            }\\n            if(o==1){\\n                ans++;\\n            }else if(o){\\n                if(i<str.length()){\\n                    ans++;\\n                    str[i] = \\'1\\';\\n                }else{\\n                    ans += 2;\\n                }\\n            }\\n            // cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        string str = \"\";\\n        while(n){\\n            if(n&1){\\n                str = str+\\'1\\';\\n            }else{\\n                str = str+\\'0\\';\\n            }\\n            n >>= 1;\\n        }\\n        int ans = 0,o,z;\\n        for(int i = 0; i < str.length();){\\n            o = 0, z = 0;\\n            while(i<str.length()&&str[i]==\\'0\\'){\\n                z++;\\n                i++;\\n            }\\n            while(i<str.length()&&str[i]==\\'1\\'){\\n                o++;\\n                i++;\\n            }\\n            if(o==1){\\n                ans++;\\n            }else if(o){\\n                if(i<str.length()){\\n                    ans++;\\n                    str[i] = \\'1\\';\\n                }else{\\n                    ans += 2;\\n                }\\n            }\\n            // cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3203768,
                "title": "c-concise-solution-using-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int set(int n)\\n    {\\n        int cnt=0;\\n        while(n)\\n        {\\n            if(n&1==1)cnt++;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        for(int i=0;i<17;i++)\\n        {\\n            int x=n+(int)pow(2,i);\\n            if(set(x)<=set(n)-1){\\n                n=x;\\n                ans++;\\n            }\\n        }\\n        return ans+set(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    int set(int n)\\n    {\\n        int cnt=0;\\n        while(n)\\n        {\\n            if(n&1==1)cnt++;\\n            n=n>>1;\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        for(int i=0;i<17;i++)\\n        {\\n            int x=n+(int)pow(2,i);\\n            if(set(x)<=set(n)-1){\\n                n=x;\\n                ans++;\\n            }\\n        }\\n        return ans+set(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857654,
                "title": "short-and-easy-recursive-solution-using-nearest-powers-of-2-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if((n & n-1) == 0) return 1;\\n        int ones = log2(n);\\n        int low = pow(2,ones);\\n        int high = pow(2,ones+1);\\n        return 1 +  min(minOperations(n-low), minOperations(high-n));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if((n & n-1) == 0) return 1;\\n        int ones = log2(n);\\n        int low = pow(2,ones);\\n        int high = pow(2,ones+1);\\n        return 1 +  min(minOperations(n-low), minOperations(high-n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568243,
                "title": "2571-minimum-operations-to-reduce-an-integer-to-0-java",
                "content": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ans=0;\\n        while(n>0)\\n        {\\n            if((n&1)==1)\\n            {\\n                ans++;\\n                n=n/2;\\n                if((n&1)==1)\\n                {\\n                    n++;\\n                }\\n            }\\n            else\\n            {\\n                n=n/2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int ans=0;\\n        while(n>0)\\n        {\\n            if((n&1)==1)\\n            {\\n                ans++;\\n                n=n/2;\\n                if((n&1)==1)\\n                {\\n                    n++;\\n                }\\n            }\\n            else\\n            {\\n                n=n/2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523577,
                "title": "beats-100-c-code",
                "content": "# Approach\\n // The strategy is that when the end of n is\\n    //   - consecutive 1s, add 1 (2^0).\\n    //   - single 1, minus 1 (2^0).\\n    //   - 0, minus 2^k to omit the last 1. Equivalently, n >> 1.\\n    //\\n    // E.g.\\n    //\\n    //         n = (101)2\\n    // n -= 2^0 -> (100)2\\n    // n -= 2^2 -> (0)2\\n    //         n = (1011)2\\n    // n += 2^0 -> (1100)2\\n    // n -= 2^2 -> (1000)2\\n    // n -= 2^3 -> (0)2\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minOperations(int n) {\\n   \\n    int ans = 0;\\n\\n    while (n > 0)\\n      if ((n & 3) == 3) {\\n        ++n;\\n        ++ans;\\n      } else if ((n & 1) == 1) {\\n        --n;\\n        ++ans;\\n      } else {\\n        n >>= 1;\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minOperations(int n) {\\n   \\n    int ans = 0;\\n\\n    while (n > 0)\\n      if ((n & 3) == 3) {\\n        ++n;\\n        ++ans;\\n      } else if ((n & 1) == 1) {\\n        --n;\\n        ++ans;\\n      } else {\\n        n >>= 1;\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389226,
                "title": "simple-dp-solution-with-explanation-c",
                "content": "Intuition:\\nstep 1: Think of how we can get to particular power of 2 using operations.\\n\\nstep 2: For every no. we have to eventually convert it into lower or higher power of 2, then we have to subsract the same no. in the last step to get the value equal to 0.\\n\\nstep 3: Transition--> we have to count the min of  steps to reach just lower or higher power of 2 and add 1 to the soln to get the ans\\n\\n```\\nclass Solution\\n{\\n    public:\\n        int minOperations(int n)\\n        {\\n            vector<int> dp(2*n+1, -1);\\n            dp[0] = 0;\\n            dp[1] = 1;\\n            for (int i = 1; i < 2 *n + 1; i = i *2)\\n            {\\n                dp[i] = 1;\\n            }\\n            for (int i = 1; i < n + 1; i++)\\n            {\\n                int x = ceil(log2(i));\\n                if (dp[i] != 1)\\n                {\\n\\t\\t\\t\\t\\n                            // dp[i] = min((dp[pow(2, x) - i] + dp[pow(2, x)]), (dp[i - pow(2, x - 1)] + dp[pow(2, x - 1)]));\\n\\t\\t\\t\\t\\tdp[i] = min(dp[pow(2, x) - i], dp[i - pow(2, x - 1)])+1;\\n                }\\n            }\\n            return dp[n];\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minOperations(int n)\\n        {\\n            vector<int> dp(2*n+1, -1);\\n            dp[0] = 0;\\n            dp[1] = 1;\\n            for (int i = 1; i < 2 *n + 1; i = i *2)\\n            {\\n                dp[i] = 1;\\n            }\\n            for (int i = 1; i < n + 1; i++)\\n            {\\n                int x = ceil(log2(i));\\n                if (dp[i] != 1)\\n                {\\n\\t\\t\\t\\t\\n                            // dp[i] = min((dp[pow(2, x) - i] + dp[pow(2, x)]), (dp[i - pow(2, x - 1)] + dp[pow(2, x - 1)]));\\n\\t\\t\\t\\t\\tdp[i] = min(dp[pow(2, x) - i], dp[i - pow(2, x - 1)])+1;\\n                }\\n            }\\n            return dp[n];\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381484,
                "title": "detailed-explanation-of-why-bit-count-n-3n",
                "content": "# Abstract\\nHere a detailed explanation of why the minimum operations is ```bit_count(n ^ 3n)``` is present. ```bit_count(n)``` is how many ```1```\\'s in ```n```\\'s binary form, ```^``` means bitwise XOR (exclusive-or).\\n\\n# Introduction\\n\\nFor $n \\\\in \\\\mathbb{N^*}$\\uFF0Can operation is defined to add or substract $2^k$ from $n$\\uFF0Cwhere $k \\\\in \\\\mathbb{N^*}$\\n\\nWe want to find the minimum operations to change $n$ to $0$\\n\\nDenote the number of minimum operations to be $f(n)$, it\\'s easy to show that $f(0)=0,f(1)=1$\\n\\nDenote $B(n)$ for ```bit_count(n)``` for short\\n\\nNow we want to prove $f(n)=B(n\\\\wedge 3n)$\\n\\nFor a certain $n$, if we have:\\n\\n$n+a_12^{k_1}+a_22^{k_2}+\\\\cdots+a_m2^{k_m}=0$, \\nwhere $a_i \\\\in \\\\{-1,1\\\\},k_i \\\\in \\\\mathbb{N^*},1 \\\\le i \\\\le m$\\n\\nThen we have an operation sequence to change $n$ to $0$, whose length is $m$\\n\\nTo make $m$ as small as possible, no $k_i$ and $k_j$ ($i \\\\neq j$) should be equal, otherwise they either canceled each other (when $a_i = -a_j$) or add up to a single item $2^{k_i+1}$, both cases will make $m$ smaller.\\n\\nSince addition is commutative, we can assume:\\n\\n$0 \\\\le k_1 < k_2 < \\\\cdots <k_m$\\n\\n# A way of presenting 0/1 strings\\n\\nTo make things easy, we use binary numbers and its 0/1 string counterpart interchangeably below. Here are some examples:\\n\\n$X$ denotes a random 0/1 strings, also a random number. i.e., if $X=5$, then $X=010$. Similarly, $Y$ can also be used just like $X$\\n\\n$X01$ means 0/1 string $X$ followed by $01$. i.e., if $X=5$, then $X01=10101$\\n\\n$X0^k$ means 0/1 string $X$ followed by $k$ $0$s. i.e., if $X=5$, then $X0^3=101000$\\n\\n$(X+1)1$ means firstly regard $X$ as a number, add it with $1$, and then regard $X+1$ as 0/1 string, finally followed by an $1$. i.e., if $X=5$, then $(X+1)1=1101$\\n\\nHere is the definition of $B(n)$ using the notations above:\\n\\n$B(0)=0,B(1)=1,B(XY)=B(X)+B(Y)$\\n\\n# Some properties of $f(n)$\\n\\n## Property #1:\\n\\n$$\\nf(n)=\\n\\\\begin{cases}\\nf(n/2),& \\\\text{n is even} \\\\\\\\\\n1+\\\\min(f(n+1),f(n-1)),& \\\\text{n is odd}\\n\\\\end{cases}\\n$$\\n\\nProof:\\n\\nIf $n$ is even, then the minimum operation sequence of $n$ :\\n\\n$k_1, k_2, \\\\cdots , k_m$\\n\\ncan be directly mapped to the minimum operation sequence of $n/2$:\\n$k_1-1, k_2-1, \\\\cdots, k_m-1$\\n\\nThe same mapping relation also works reversly.\\n\\nIf $n$ is odd, then $k_1=0$, because any $k_i>0$ won\\'t eliminate the lowest bit of $n$. We can either add or substract $2^0$ from $n$ and then change $n+1$ or $n-1$ to $0$\\n\\n## Property #2:\\n\\nWhen $k\\\\ge1$\\uFF0C$f(X0^k)=f(X)$\\n\\nProof\\uFF1A\\n\\nRepeatedly apply Property #1, and note that $X0^k$ is always even.\\n\\n## Property #3\\n\\n$f(X) \\\\le 1+f(X\\\\pm 1)$\\n\\nProof\\uFF1A\\n\\nFrom number $X$\\uFF0Cwe can change it to $0$ by the operation sequence below:\\n\\n1. Substract $2^0$, then $X$ becomes $X-1$\\n2. Find the minimum operation sequence for $X-1$\\n\\nSo we get a operation sequence for $X$, whose length is $1+f(X-1)$. However, it is not necessary the optimal (mininum) operation sequence for $X$, hence $f(X) \\\\le 1+f(X-1)$. The same discussion applies to $X+1$.\\n\\n## Property #4\\n\\n$f(X) \\\\le f(X1) \\\\le f(X)+1$\\n\\nProof \\uFF1A\\n\\nLeft $\\\\le$: \\n\\n$X1$ is odd\\uFF0Cby Property #1\\uFF1A\\n\\n$f(X1)=1+\\\\min(f(X1+1),f(X1-1))=1+\\\\min[f((X+1)0),f(X0)]$\\n\\nby Property #2:\\n\\n$f(X1)=1+\\\\min(f(X+1),f(X)) \\\\ge 1+\\\\min(f(X)-1,f(X))=f(X)$\\uFF0Cby Property #3\\n\\nRight $\\\\le$:\\n\\n$f(X)+1=f(X0)+1 \\\\ge f(X0+1)=f(X1)$\\uFF0Cby Property #1 and #3.\\n\\n## Property #5\\n\\n$f(X1) \\\\le f(X01) \\\\le 1+f(X1)$\\n\\nProof\\uFF1A\\n\\nLeft $\\\\le$:\\n\\n$f(X01)=1+\\\\min(f(X01+1),f(X01-1))=1+\\\\min(f(X1),f(X))$\\n\\n$=\\\\min(f(X1)+1,f(X)+1) \\\\ge \\\\min(f(X1)+1,f(X1)) = f(X1)$\\uFF0Cby Property #4\\n\\nRight $\\\\le$:\\n\\n$f(X01)=1+\\\\min(f(X1),f(X))\\\\le 1+f(X1)$\\uFF0Cby Property #4\\n\\n## Property #6\\n\\n$f(X01)=1+f(X)$\\n\\nProof\\uFF1A\\n\\n$f(X01)=1+\\\\min(f(X1),f(X)) =1+f(X)$\\uFF0Cby Property #4\\n\\n## Property #7\\n\\nIf $k \\\\ge 2$\\uFF0Cthen $f(X01^k)=1+f(X1)$\\n\\nProof\\uFF1A\\n\\nWe present a proof by induction. First prove $f(X011)=1+f(X1)$:\\n\\n$f(X011)=1+\\\\min(f(X011+1),f(X011-1))=1+\\\\min(f(X1),f(X01))=1+f(X1)$, by Property #5\\n\\nThen:\\n\\n$f(X01^{k+1})=1+\\\\min(f(X10^{k+1}),f(X01^k0))=1+\\\\min(f(X1),f(X01^k))$\\n\\nBy induction\\uFF0C$f(X01^k)=1+f(X1)$\\uFF0Chence\\n\\n$f(X01^{k+1})=1+\\\\min(f(X1),1+f(X1))=1+f(X1)$\\n\\n\\n# Proof of $f(n)=B(n\\\\wedge 3n)$\\n\\nWe present a proof by induction. It\\'s easy to test for $n=0,1$, the conclusion holds.\\n\\n---\\n\\nCase 1: $n$ is even, that is $n=X0$\\n\\nThen $2n=X00,3n=n+2n=(3X)0,n\\\\wedge 3n=(X\\\\wedge 3X)0$\\n\\nWe have $f(n)=f(X0)=f(X)=B(X\\\\wedge3X)=B((X\\\\wedge 3X)0)=B(n \\\\wedge 3n)$\\n\\n---\\n\\nCase 2: if $n=X01$\\n\\nThen $2n=X010,3n=(3X)11,n\\\\wedge 3n=(X\\\\wedge 3X)10$\\n\\nBy Property #6\\uFF0C$f(n)=f(X01)=1+f(X)=1+B(X\\\\wedge 3X)=B((X\\\\wedge 3X)10)=B(n \\\\wedge 3n)$\\n\\n---\\n\\nCase 3: if $n=X01^k$\\uFF0C$k \\\\ge 2$\\n\\nThen $2n=X01^k0,3n=n+2n=(3X+1)01^{k-2}01,n\\\\wedge 3n=[X\\\\wedge (3X+1)]0^{k-1}10$\\n\\nNow we compute $f(X1)=B(X1 \\\\wedge (3[X1]))$\\n\\n$2[X1]=X10,3[X1]=X1+2[X1]=(3X+1)1,X1 \\\\wedge 3[X1]=X\\\\wedge(3X+1)0$\\n\\nHence $f(X1)=B(X\\\\wedge(3X+1))$\\n\\nBy Property #7\\uFF0C$f(n)=f(X01^k)=1+f(X1)=1+B(X\\\\wedge(3X+1))=B([X\\\\wedge(3X+1)]0^{k-1}10)=B(n\\\\wedge 3n)$\\n\\nQ.E.D\\n\\n---\\n\\n# Conclusion\\n\\nHope my proof doesn\\'t confuse you too much :)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```bit_count(n ^ 3n)```\n```bit_count(n)```\n```1```\n```n```\n```^```\n```bit_count(n)```",
                "codeTag": "Unknown"
            },
            {
                "id": 3379658,
                "title": "c-100-faster-0ms-iterative-solution",
                "content": "# Complexity\\n- Time complexity: `O(N * log2 N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int k) {\\n        \\n        // store powers of two\\n        vector<int>PowersOf2;\\n        PowersOf2.push_back(1);\\n\\n        // convert imput in long long for runtime error\\n        long long n = k , ind = 0;\\n\\n        // calculating & storing powers of 2 till n\\n        while(PowersOf2[ind] <= n)  PowersOf2.push_back(PowersOf2[ind++] * 2); \\n        if(PowersOf2[ind-1] == n) return 1;\\n\\n        // size of vector which is storing power of 2\\n        int sz = ind+1;\\n\\n        // variable storing nearest power of 2 of n & number of operations\\n        int nearest = k, operations = 0;  \\n\\n        // distance between nearest power of 2 & n\\n        int minDiff = k;\\n\\n\\n        // while n greater than 0\\n        while(n){\\n            \\n            // reset difference\\n            minDiff = k;\\n\\n            // find nearest power of 2 from n\\n            for(int i=0;i<sz;i++){\\n\\n                // update difference \\n                if(minDiff > abs(PowersOf2[i] - n)){\\n                    nearest = PowersOf2[i];\\n                    minDiff = abs(PowersOf2[i] - n);\\n                }\\n\\n            }\\n            operations++;\\n            n = abs(n - nearest);\\n\\n        }\\n\\n\\n        return operations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int k) {\\n        \\n        // store powers of two\\n        vector<int>PowersOf2;\\n        PowersOf2.push_back(1);\\n\\n        // convert imput in long long for runtime error\\n        long long n = k , ind = 0;\\n\\n        // calculating & storing powers of 2 till n\\n        while(PowersOf2[ind] <= n)  PowersOf2.push_back(PowersOf2[ind++] * 2); \\n        if(PowersOf2[ind-1] == n) return 1;\\n\\n        // size of vector which is storing power of 2\\n        int sz = ind+1;\\n\\n        // variable storing nearest power of 2 of n & number of operations\\n        int nearest = k, operations = 0;  \\n\\n        // distance between nearest power of 2 & n\\n        int minDiff = k;\\n\\n\\n        // while n greater than 0\\n        while(n){\\n            \\n            // reset difference\\n            minDiff = k;\\n\\n            // find nearest power of 2 from n\\n            for(int i=0;i<sz;i++){\\n\\n                // update difference \\n                if(minDiff > abs(PowersOf2[i] - n)){\\n                    nearest = PowersOf2[i];\\n                    minDiff = abs(PowersOf2[i] - n);\\n                }\\n\\n            }\\n            operations++;\\n            n = abs(n - nearest);\\n\\n        }\\n\\n\\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350342,
                "title": "c-100-beats-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       vector<int> bits(32,0);int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            bits[31-i]=n&1; n=n>>1;\\n        }\\n        for(int i =0; i<32; i++)\\n        {\\n            cout << bits[i] << \" \";\\n        }\\n        for(int i=31; i>=0; i--)\\n        {\\n            if(bits[i]==1)\\n            {\\n                if(i-1>=0 && bits[i-1]==0)\\n                {\\n                    ans++;\\n                    continue;\\n                }\\n                while(i>=0 && bits[i]==1)\\n                {\\n                    i--;\\n                }\\n                ans++;\\n                if(i>=0)\\n                bits[i] = 1;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       vector<int> bits(32,0);int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            bits[31-i]=n&1; n=n>>1;\\n        }\\n        for(int i =0; i<32; i++)\\n        {\\n            cout << bits[i] << \" \";\\n        }\\n        for(int i=31; i>=0; i--)\\n        {\\n            if(bits[i]==1)\\n            {\\n                if(i-1>=0 && bits[i-1]==0)\\n                {\\n                    ans++;\\n                    continue;\\n                }\\n                while(i>=0 && bits[i]==1)\\n                {\\n                    i--;\\n                }\\n                ans++;\\n                if(i>=0)\\n                bits[i] = 1;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3295130,
                "title": "short-and-simple-code",
                "content": "# Intuition :\\n **step 1 : Find Nearest 2 power for the given n.\\n step 2 : Modify n = max(nearest 2 power, n) - min(nearest 2 power, n);\\nDo above Two steps until n becomes zero, and keep count of performing above two steps.\\nReturn the count. Thats all!.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0;\\n        while(n!=0){\\n            ans++;\\n            n = max(( 1<<(int)round(log2(n)) ), n ) - min (( 1<<(int)round(log2(n)) ), n );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0;\\n        while(n!=0){\\n            ans++;\\n            n = max(( 1<<(int)round(log2(n)) ), n ) - min (( 1<<(int)round(log2(n)) ), n );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290589,
                "title": "0ms-o-log-n-simplest-solution-no-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  * We either remove a bit or add a bit (or don\\'t touch it). For the same bit positon we never operate more than once.\\n  * Adding a bit can be better than removing if there are continous bit 1s.\\n  * Specifically shape `11011` requires only 3 ops, meaning promoting continous bit 1s rather than removing them is the way to go.\\n  * We never operate on the bit positions *below* the lowest bit 1 of n\\n  * Leading or trailing 0s on n are irelevant.\\n  * We *have to* operate on the lowest bit 1 of n.\\n  * We can remove the lowest bit 1 of n or add a bit to \"promote\" it.\\n  * If there are more than one continuous bit 1s starting at the lowest bit 1 of n then add a bit is always as good as, if not better than, removing it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start from the lowest bits of n by choosing removing or adding depending on whether there are continunous bit 1s.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(\\\\log N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int minOperations(int n) {\\n    int ops = 0;\\n    while (n > 0) {\\n      switch (n & 3) {\\n        case 3: ++n;  /* fallthrough intended */\\n        case 1: ++ops;  /* fallthrough intended */\\n        case 0: n /= 4; break;\\n        default: n /= 2; break;\\n      }\\n    }\\n    return ops;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minOperations(int n) {\\n    int ops = 0;\\n    while (n > 0) {\\n      switch (n & 3) {\\n        case 3: ++n;  /* fallthrough intended */\\n        case 1: ++ops;  /* fallthrough intended */\\n        case 0: n /= 4; break;\\n        default: n /= 2; break;\\n      }\\n    }\\n    return ops;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271804,
                "title": "binary-search-better-than-100-of-the-solutions",
                "content": "# Intuition\\n\\n\\n# Approach\\nFirstly made an array in which all the power elements of 2 are stored till the range i. Then apllying binary searh to find the just smallest and just graetes element. to which ever n is closer a recursive call is made by increementing a variable ans every time.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\n Auxilarry space(O(log(n)))\\n\\n# Code\\n```\\nclass Solution {\\n    int ans=0;\\n    public int minOperations(int n) {\\n        helper(n);\\n        return ans;\\n    }\\n    \\n    private void helper(int n){\\n          int i=0;\\n        if(n==0)return ;\\n        while(Math.pow(2,i)<n)i++;\\n        \\n        int []arr=new int[i+1];\\n        for(int j=0;j<=i;j++){\\n            arr[j]=(int)Math.pow(2,j);\\n          \\n        }\\n        \\n        int start=0;int end=arr.length-1;\\n        int s=-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n         \\n            if(arr[mid]<=n){\\n                s=arr[mid];\\n                start=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        int l=-1;\\n         start=0; end=arr.length-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n           \\n            if(arr[mid]<n){\\n               \\n                start=mid+1;\\n            }else{\\n                 l=arr[mid];\\n                end=mid-1;\\n            }\\n        }\\n     \\n        \\n        if(s==n || l==n){\\n            ans++;\\n            return ;\\n        }\\n        if(n-s>l-n){\\n            n=l-n;\\n            ans++;\\n            helper(n);\\n        }\\n        else{\\n             n=n-s;\\n            ans++;\\n            helper(n);\\n        }\\n        return ;\\n    \\n}}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    public int minOperations(int n) {\\n        helper(n);\\n        return ans;\\n    }\\n    \\n    private void helper(int n){\\n          int i=0;\\n        if(n==0)return ;\\n        while(Math.pow(2,i)<n)i++;\\n        \\n        int []arr=new int[i+1];\\n        for(int j=0;j<=i;j++){\\n            arr[j]=(int)Math.pow(2,j);\\n          \\n        }\\n        \\n        int start=0;int end=arr.length-1;\\n        int s=-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n         \\n            if(arr[mid]<=n){\\n                s=arr[mid];\\n                start=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        int l=-1;\\n         start=0; end=arr.length-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n           \\n            if(arr[mid]<n){\\n               \\n                start=mid+1;\\n            }else{\\n                 l=arr[mid];\\n                end=mid-1;\\n            }\\n        }\\n     \\n        \\n        if(s==n || l==n){\\n            ans++;\\n            return ;\\n        }\\n        if(n-s>l-n){\\n            n=l-n;\\n            ans++;\\n            helper(n);\\n        }\\n        else{\\n             n=n-s;\\n            ans++;\\n            helper(n);\\n        }\\n        return ;\\n    \\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255806,
                "title": "very-short-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMath\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple math with logarithms;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*log(n));\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        \\n        int ans = 0;\\n        \\n        while(n!=0){\\n        int val  =  log2(n);\\n          //  cout<<val<<endl;\\n        \\n        int i = pow(2,val);\\n        int j = pow(2, val+1);\\n        \\n             n = min(abs(i-n), abs(j-n));\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        \\n        int ans = 0;\\n        \\n        while(n!=0){\\n        int val  =  log2(n);\\n          //  cout<<val<<endl;\\n        \\n        int i = pow(2,val);\\n        int j = pow(2, val+1);\\n        \\n             n = min(abs(i-n), abs(j-n));\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3239841,
                "title": "0ms-faster-than-100-binary-search",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(int n) {\\n\\t\\t\\tvector<int> ans ;\\n\\t\\t\\tlong long i=1,x=1;\\n\\t\\t\\twhile(x<1e6){\\n\\t\\t\\t\\tans.push_back(x);\\n\\t\\t\\t\\tx = pow(2,i++);\\n\\t\\t\\t}\\n\\t\\t   int t = n;\\n\\t\\t\\tint res=0;\\n\\t\\t\\twhile(t!=0){\\n\\n\\t\\t\\t\\tint ind = lower_bound(ans.begin(),ans.end(),t) - ans.begin();\\n\\t\\t\\t\\tif(ans[ind] == t) { res++; return res;}\\n\\t\\t\\t\\tlong long a = (ind-1>=0)?ans[ind-1]:INT_MAX;\\n\\t\\t\\t\\tlong long b = ans[ind];\\n\\t\\t\\t\\tif(abs(t-a) < abs(t-b) ) t = abs(t-a);\\n\\t\\t\\t\\telse t = abs(t-b);\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(int n) {\\n\\t\\t\\tvector<int> ans ;\\n\\t\\t\\tlong long i=1,x=1;\\n\\t\\t\\twhile(x<1e6){\\n\\t\\t\\t\\tans.push_back(x);\\n\\t\\t\\t\\tx = pow(2,i++);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3236668,
                "title": "c-simplest-solution-0ms-recursion-nearest-power-of-two",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGo with nearest power of two\\n\\n# Approach\\n- <!-- Describe your approach to solving the problem. -->First find power of two which is just greater than and less than n.\\n- If the power is equal to *n* return count\\n- Else continue same approach with the power nearest to *n*.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int solve(int n,int count){\\n        int x=0,i=1;\\n        while(x<=n)\\n            x=pow(2,i++);\\n        if(x/2==n)\\n            return count;\\n        int a=x/2;\\n        int b=x;\\n        return solve(min(abs(n-a),abs(n-b)),count+1);\\n    }\\n    int minOperations(int n) {\\n        return solve(n,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int solve(int n,int count){\\n        int x=0,i=1;\\n        while(x<=n)\\n            x=pow(2,i++);\\n        if(x/2==n)\\n            return count;\\n        int a=x/2;\\n        int b=x;\\n        return solve(min(abs(n-a),abs(n-b)),count+1);\\n    }\\n    int minOperations(int n) {\\n        return solve(n,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232545,
                "title": "c-easiest-solution-0ms-constant-time-and-space-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int i = 0 , ans = 0;\\n\\n        while(n)\\n        {\\n            //If Last Bit is Set \\n            if(n&1)\\n            {  \\n               //Increment the ans as we will be substracting or adding   \\n               ans++;\\n               //Right Shift\\n               n>>= 1;\\n\\n               //Now If Last Bit is set \\n               //Then we have got 2 set bits consecutive ly\\n               //Now remove all consecutive set bits \\n               //And when last bit is zero make it one \\n               //If This below consition is true then we are adding \\n               // else we are substracting\\n               if(n&1)\\n               {\\n                   while(n&1)\\n                   n>>=1;\\n                   n++;\\n               }\\n            }\\n            //If Last Bit is 0\\n            // Just RIght Shift By One \\n            else\\n            n >>= 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int i = 0 , ans = 0;\\n\\n        while(n)\\n        {\\n            //If Last Bit is Set \\n            if(n&1)\\n            {  \\n               //Increment the ans as we will be substracting or adding   \\n               ans++;\\n               //Right Shift\\n               n>>= 1;\\n\\n               //Now If Last Bit is set \\n               //Then we have got 2 set bits consecutive ly\\n               //Now remove all consecutive set bits \\n               //And when last bit is zero make it one \\n               //If This below consition is true then we are adding \\n               // else we are substracting\\n               if(n&1)\\n               {\\n                   while(n&1)\\n                   n>>=1;\\n                   n++;\\n               }\\n            }\\n            //If Last Bit is 0\\n            // Just RIght Shift By One \\n            else\\n            n >>= 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229986,
                "title": "python-easy-solution-bits-manipulation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s consider example with `n = 0b10111`. Each non-zero bit can be turned off one by one by subtracting `1` if the last bit is `1` and shifting zero-bits right otherwise (shifting does not count as an operation in this problem). Thus the maximum number of operations needed is equal to the number of non-zero bits. But, in our example if `1` is added to `n` we will get `0b11000` with only 2 non-zero bits left. \\n\\nThis suggests that if a binary representation of `n` ends with 2 or more sequential non-zero bits it is better to add `1`. Otherwise, we subtract `1` to eliminate \"lonely\" non-zero bit. Zero bits on the right are just ignored (eliminated with right shift).\\n\\n# Complexity\\n- Time complexity: O(log n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            if n & 1: # last bit is 1\\n                if (n >> 1) & 1: # last but 1 bit is also 1\\n                    n += 1\\n                ans += 1\\n            n >>= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            if n & 1: # last bit is 1\\n                if (n >> 1) & 1: # last but 1 bit is also 1\\n                    n += 1\\n                ans += 1\\n            n >>= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225598,
                "title": "easiest-solution-simple-observations-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink in binary of $n$ and try to remove consecutive 1\\'s with min operations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### **Greedy approach**. \\n\\n##### *Observations* : -\\n1. Consecutive 1\\'s of `count > 1` can be easily removed by $2$ operations. \\nexample: `01110 --> 10000 --> 00000`\\nnow if we individually subtract all bits, we always get a count of operations > 1. So, performing 2 operations in this way is never the worse.\\n\\n2. If *count of consecutive 1\\'s is 1* then it\\'s always optimal to simply perform 1 operation of subtraction.\\n3. An interesting thing to note is when the string looks like $1101, 11011$ i.e. there is single \\'0\\' between \\'1\\'s on both side. In this case, we can set this bit and club the whole bits in a group of consecutive 1\\'s and finally perform 2 operations as described in $point\\\\ 1 $ \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(log2(n))`\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(log2(n))`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        string dig = \"\"; \\n        while(n){\\n            int rem = n%2; \\n            dig+=(\\'0\\'+rem);\\n            n>>=1; \\n        }\\n        int ans = 0;\\n        int consec = 1; \\n        reverse(dig.begin(),dig.end()); \\n        for(int i=1; i<dig.size()-1; ++i){\\n            if(dig[i]==\\'0\\' && dig[i-1]==\\'1\\' && dig[i+1]==\\'1\\' && consec>1){\\n                dig[i] = \\'1\\'; \\n                ans++; \\n            }\\n            if(dig[i]==dig[i-1]){\\n                consec++; \\n            }\\n            else{\\n                consec = 1; \\n            }\\n        }\\n\\n        int count = 1; \\n        for(int i=1; i<dig.size(); ++i){\\n            if(dig[i-1]==dig[i]){\\n                count++; \\n            }\\n            else{\\n                if(dig[i-1]==\\'1\\'){\\n                    if(count==1) ans++;\\n                    else{\\n                        ans+=2; \\n                    }\\n                }\\n                count = 1;\\n            }\\n        }\\n        if(dig[(int)dig.size()-1]==\\'1\\'){\\n            if(count==1) ans++;\\n            else ans+=2; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        string dig = \"\"; \\n        while(n){\\n            int rem = n%2; \\n            dig+=(\\'0\\'+rem);\\n            n>>=1; \\n        }\\n        int ans = 0;\\n        int consec = 1; \\n        reverse(dig.begin(),dig.end()); \\n        for(int i=1; i<dig.size()-1; ++i){\\n            if(dig[i]==\\'0\\' && dig[i-1]==\\'1\\' && dig[i+1]==\\'1\\' && consec>1){\\n                dig[i] = \\'1\\'; \\n                ans++; \\n            }\\n            if(dig[i]==dig[i-1]){\\n                consec++; \\n            }\\n            else{\\n                consec = 1; \\n            }\\n        }\\n\\n        int count = 1; \\n        for(int i=1; i<dig.size(); ++i){\\n            if(dig[i-1]==dig[i]){\\n                count++; \\n            }\\n            else{\\n                if(dig[i-1]==\\'1\\'){\\n                    if(count==1) ans++;\\n                    else{\\n                        ans+=2; \\n                    }\\n                }\\n                count = 1;\\n            }\\n        }\\n        if(dig[(int)dig.size()-1]==\\'1\\'){\\n            if(count==1) ans++;\\n            else ans+=2; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222068,
                "title": "2571-minimum-operations-to-reduce-an-integer-to-0",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int nn=n,c=0;\\n        while(n>0){\\n            //cout<<c<<\" \"<<n<<\" \"<<(int)log2(n)<<\\'\\\\n\\';\\n            if(n - (int)pow(2,(int)log2(n))==0)\\n                return c+1;\\n            if(n - (int)pow(2,(int)log2(n)) > (int)pow(2,(int)log2(n)+1) - n){\\n                c++;\\n                n=(int)pow(2,(int)log2(n)+1) - n;\\n            }\\n            else{\\n                c++;\\n                n=n - (int)pow(2,(int)log2(n));\\n            }\\n            }\\n                    return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int nn=n,c=0;\\n        while(n>0){\\n            //cout<<c<<\" \"<<n<<\" \"<<(int)log2(n)<<\\'\\\\n\\';\\n            if(n - (int)pow(2,(int)log2(n))==0)\\n                return c+1;\\n            if(n - (int)pow(2,(int)log2(n)) > (int)pow(2,(int)log2(n)+1) - n){\\n                c++;\\n                n=(int)pow(2,(int)log2(n)+1) - n;\\n            }\\n            else{\\n                c++;\\n                n=n - (int)pow(2,(int)log2(n));\\n            }\\n            }\\n                    return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3219186,
                "title": "0ms-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count =0;\\n        int diff1=0;\\n        int diff2=0;\\n        int ans=0;\\n    \\n        while(n!=0)\\n        {\\n         \\n          ans=Math.abs( (int) (Math.log(n)/Math.log(2)));\\n\\n         diff1=Math.abs(n-((int)Math.pow(2,ans)));\\n         diff2=Math.abs(n-2*((int)Math.pow(2,ans)));\\n         if(diff1<diff2)\\n         {\\n             \\n             n=Math.abs(n-((int)Math.pow(2,ans)));\\n             count++;\\n\\n         }\\n         else \\n         {\\n           n=Math.abs (n-2*((int)Math.pow(2,ans))); \\n           count++;\\n         }\\n\\n        \\n          \\n        }\\n        return count;\\n     \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count =0;\\n        int diff1=0;\\n        int diff2=0;\\n        int ans=0;\\n    \\n        while(n!=0)\\n        {\\n         \\n          ans=Math.abs( (int) (Math.log(n)/Math.log(2)));\\n\\n         diff1=Math.abs(n-((int)Math.pow(2,ans)));\\n         diff2=Math.abs(n-2*((int)Math.pow(2,ans)));\\n         if(diff1<diff2)\\n         {\\n             \\n             n=Math.abs(n-((int)Math.pow(2,ans)));\\n             count++;\\n\\n         }\\n         else \\n         {\\n           n=Math.abs (n-2*((int)Math.pow(2,ans))); \\n           count++;\\n         }\\n\\n        \\n          \\n        }\\n        return count;\\n     \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218270,
                "title": "c-recursion-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n\\n- Space complexity:$$O(logn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int l=__builtin_popcountl(n);\\n        if(l<=1){ return l;}\\n        return 1 + min(minOperations(n+(n&(-n))), minOperations(n-(n&(-n))));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int l=__builtin_popcountl(n);\\n        if(l<=1){ return l;}\\n        return 1 + min(minOperations(n+(n&(-n))), minOperations(n-(n&(-n))));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211552,
                "title": "o-1-time-complexity-and-o-1-space-complexity-bit-manipulation-c-easy-and-simple",
                "content": "\\n# Complexity\\n- Time complexity:\\no(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        while(n){\\n            int cnt=0;\\n            if(n&1){\\n                while(n&1){\\n                    cnt++;n=n>>1;\\n                }\\n            }\\n            else n=n>>1;\\n            if(cnt==1)ans++;\\n            else if(cnt>1){\\n                ans++;\\n                n+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nUpvote If you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        while(n){\\n            int cnt=0;\\n            if(n&1){\\n                while(n&1){\\n                    cnt++;n=n>>1;\\n                }\\n            }\\n            else n=n>>1;\\n            if(cnt==1)ans++;\\n            else if(cnt>1){\\n                ans++;\\n                n+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nUpvote If you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211483,
                "title": "o-log-n-recursive-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSuppose we want to find minimum number of times we need to do operations to make it zero.\\nexample 51\\n\\n    51 can be either made -> 32 or 64 and from 32 and 64 it will take 1 step.\\n\\nNow we need to findout the number of steps to find the create `51-32 = 19 and 64-51 = 13` and we choose the minimum of the same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCreate a recursive function which tells the minimum of operation in which we can make n using power of 2 operations.\\n\\neg = 51\\n\\nfirst find lower and upper bound, b = int(log(51, 2)) = 5\\nlower = pow(2, b)\\nupper = pow(2, b+1)\\n\\ndifference1 = n - lower\\ndifference2 = upper - n\\n\\nreturn 1 + min(difference1, diff2)\\n\\nBase condition - > if n == pow(2, b), means we have reach a power of 2, therefore we require 1 step return 1\\n\\n# Complexity\\n- Time complexity: O(log(n)) # difference ko power of 2 mein karna\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(n)) # stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n           \\n        import math\\n        def minSteps(n):\\n\\n            v = int(math.log(n, 2))  # O(1)\\n\\n            if n == pow(2, v): # O(1)\\n                return 1\\n            \\n            low = pow(2, v) # O(1)\\n            high = pow(2, v+1) # O(1)\\n\\n            d1 = n - low\\n            d2 = high - n\\n\\n            return 1 + min(minSteps(d1), minSteps(d2))\\n        \\n        return minSteps(n)\\n\\n\\n\\n\\n\\n        # continuous 1 logic but issue\\n        # a = bin(n)[2:]\\n        \\n        # l = len(a)\\n        \\n        # e = l-1\\n        # print(a)\\n        # moves = 0\\n        # continuous = 0\\n        # while e >= 0:\\n            \\n        #     if a[e] == \\'1\\':\\n        #         continuous += 1\\n        #     else:\\n        #         if continuous == 0: \\n        #             pass\\n        #         elif continuous == 1:\\n        #             moves += 1\\n        #         else:\\n        #             print(moves, e, continuous)\\n        #             moves += 2\\n        #         continuous = 0\\n            \\n        #     e -= 1\\n\\n        # if continuous == 0: \\n        #     pass\\n        # elif continuous == 1:\\n        #     moves += 1\\n        # else:\\n        #     moves += 2\\n        \\n        # return moves\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n           \\n        import math\\n        def minSteps(n):\\n\\n            v = int(math.log(n, 2))  # O(1)\\n\\n            if n == pow(2, v): # O(1)\\n                return 1\\n            \\n            low = pow(2, v) # O(1)\\n            high = pow(2, v+1) # O(1)\\n\\n            d1 = n - low\\n            d2 = high - n\\n\\n            return 1 + min(minSteps(d1), minSteps(d2))\\n        \\n        return minSteps(n)\\n\\n\\n\\n\\n\\n        # continuous 1 logic but issue\\n        # a = bin(n)[2:]\\n        \\n        # l = len(a)\\n        \\n        # e = l-1\\n        # print(a)\\n        # moves = 0\\n        # continuous = 0\\n        # while e >= 0:\\n            \\n        #     if a[e] == \\'1\\':\\n        #         continuous += 1\\n        #     else:\\n        #         if continuous == 0: \\n        #             pass\\n        #         elif continuous == 1:\\n        #             moves += 1\\n        #         else:\\n        #             print(moves, e, continuous)\\n        #             moves += 2\\n        #         continuous = 0\\n            \\n        #     e -= 1\\n\\n        # if continuous == 0: \\n        #     pass\\n        # elif continuous == 1:\\n        #     moves += 1\\n        # else:\\n        #     moves += 2\\n        \\n        # return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209790,
                "title": "2-line-c-solution-brute-force-and-efficient",
                "content": "# Intuition\\n Choose **closest power of 2** everytime whether add or subtract operation \\n\\n\\n# Approach\\nTake absolute minimum between *(n - previous power)* and *(next power - n)* and assign to N and repeat till $$N = 0$$.\\n\\n# Complexity\\n- Time complexity: $$O(log2(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ops = 0;\\n        while(n) \\n        {\\n            int x = log2(n);\\n            n = min(n-(1<<x), (1<<(x+1))-n);\\n            ops++;\\n        }\\n        return ops;\\n    }\\n};\\n```\\n# Upvote\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ops = 0;\\n        while(n) \\n        {\\n            int x = log2(n);\\n            n = min(n-(1<<x), (1<<(x+1))-n);\\n            ops++;\\n        }\\n        return ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209625,
                "title": "math-greedy-with-short-explanation",
                "content": "# Intuition\\nGo to the nearest power of two.\\nFor example, n = 54;\\nThe process goes like this:\\n\\nNearest power of 2: 2^6 \\n|54-2^6| = 10, count = 1\\nNearest power of 2: 2^3  \\n|10-2^3| = 2, count = 2\\nNearest power of 2: 2^1\\n|2-2^1| = 0, count = 3\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int diff = n;\\n        int count = 0;\\n        while(diff!=0){\\n            int x = round(log2(diff));\\n            int m = pow(2,x);\\n            diff = abs(m-diff);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int diff = n;\\n        int count = 0;\\n        while(diff!=0){\\n            int x = round(log2(diff));\\n            int m = pow(2,x);\\n            diff = abs(m-diff);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208065,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        pows = [2 ** num for num in range(17)]\\n        count = 0\\n        \\n        while n:\\n            for i in range(len(pows)):\\n                if pows[i] > n:\\n                    break\\n                    \\n            n = min(abs(pows[i] - n), abs(pows[i - 1] - n))\\n            count += 1\\n                        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        pows = [2 ** num for num in range(17)]\\n        count = 0\\n        \\n        while n:\\n            for i in range(len(pows)):\\n                if pows[i] > n:\\n                    break\\n                    \\n            n = min(abs(pows[i] - n), abs(pows[i - 1] - n))\\n            count += 1\\n                        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207348,
                "title": "c-recursion-easy-6-line-solution-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int m1=1;\\n        for (; m1<n; m1<<=1) ;\\n        if (m1==n) return 1;\\n        int m2=m1>>1;\\n        if (m1-n>n-m2) return 1+minOperations(n-m2);\\n        else return 1+minOperations(m1-n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int m1=1;\\n        for (; m1<n; m1<<=1) ;\\n        if (m1==n) return 1;\\n        int m2=m1>>1;\\n        if (m1-n>n-m2) return 1+minOperations(n-m2);\\n        else return 1+minOperations(m1-n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207124,
                "title": "no-bit-manipulation-simplest-approach-java",
                "content": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int ans = 0;\\n        \\n        if(n<2 || (n & (n - 1)) == 0)      //This other condition is to check proper exponent of 2\\n            return 1;\\n        \\n        while(n!=0){\\n            \\n            int i = (int)(Math.log(n)/Math.log(2)); \\n\\t\\t //This will give floor value of closest power of 2 like n = 39 then i = 5 as 2^5 = 32\\n            int prev = (int)Math.pow(2,i);\\n            int next = (int)Math.pow(2,++i);\\n            if(next-n<=n-prev){\\n                n = next-n;\\n            }\\n            \\n            else{\\n               n = n-prev; \\n            }\\n             ans++;\\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int ans = 0;\\n        \\n        if(n<2 || (n & (n - 1)) == 0)      //This other condition is to check proper exponent of 2\\n            return 1;\\n        \\n        while(n!=0){\\n            \\n            int i = (int)(Math.log(n)/Math.log(2)); \\n\\t\\t //This will give floor value of closest power of 2 like n = 39 then i = 5 as 2^5 = 32\\n            int prev = (int)Math.pow(2,i);\\n            int next = (int)Math.pow(2,++i);\\n            if(next-n<=n-prev){\\n                n = next-n;\\n            }\\n            \\n            else{\\n               n = n-prev; \\n            }\\n             ans++;\\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206609,
                "title": "java-intuitive-solution-easy-100-faster-comments",
                "content": "# Intuition\\n- We have to add or subtract the power of two and the number of operations should be minimum.\\n- Therefore we have to find the difference between the n and the power of 2 closest to n\\n\\n# Approach\\nWe can iterative over n until it\\'s value turns equal to zero. With each iteration we will replace n with the difference of n and the power of 2 closest to the n.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        // all power of 2\\'s till 10^5 as given in the constraints \\n        int[] arr = new int[]{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072};\\n        // left and right for binary search\\n        int left = 0;\\n        int right = arr.length - 1;\\n        int res = 0;\\n        // repeating the process until we get n = 0\\n        while(n > 0){\\n            // finding the two numbers from the array which are closest to the n\\n            while(left <= right){\\n                int mid = (left + right)/2;\\n                if(arr[mid] > n) right = mid - 1;\\n                else left = mid + 1;\\n            }\\n            int t = Math.abs(n - arr[left]);\\n            n = Math.abs(n - arr[right]);\\n            // substituting n by the min of n and t\\n            n = Math.min(n, t);\\n            left = 0;\\n            // counting number of operations\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        // all power of 2\\'s till 10^5 as given in the constraints \\n        int[] arr = new int[]{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072};\\n        // left and right for binary search\\n        int left = 0;\\n        int right = arr.length - 1;\\n        int res = 0;\\n        // repeating the process until we get n = 0\\n        while(n > 0){\\n            // finding the two numbers from the array which are closest to the n\\n            while(left <= right){\\n                int mid = (left + right)/2;\\n                if(arr[mid] > n) right = mid - 1;\\n                else left = mid + 1;\\n            }\\n            int t = Math.abs(n - arr[left]);\\n            n = Math.abs(n - arr[right]);\\n            // substituting n by the min of n and t\\n            n = Math.min(n, t);\\n            left = 0;\\n            // counting number of operations\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206523,
                "title": "beats-100-easy-c-solution-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int count = 0;\\n        int rem = 0;\\n        bool flag = false;\\n        while(n != 0){\\n            rem = 0;\\n            while(n % int(pow(2, rem)) != n){\\n                if ((n & n - 1) == 0){\\n                    count++;\\n                    flag = true;\\n                    break;\\n                }\\n                rem++;        \\n            }\\n            if(flag == true){\\n                break;\\n            }\\n            int diff1 = n - int(pow(2, rem));\\n            int diff2 = n - int(pow(2, rem - 1));\\n            if(abs(diff1) > abs(diff2)){\\n                n = abs(diff2);\\n            }\\n            else if(abs(diff1) <= abs(diff2)){\\n                n = abs(diff1);\\n            }\\n            count++;\\n\\n        }\\n        return count;\\n\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int count = 0;\\n        int rem = 0;\\n        bool flag = false;\\n        while(n != 0){\\n            rem = 0;\\n            while(n % int(pow(2, rem)) != n){\\n                if ((n & n - 1) == 0){\\n                    count++;\\n                    flag = true;\\n                    break;\\n                }\\n                rem++;        \\n            }\\n            if(flag == true){\\n                break;\\n            }\\n            int diff1 = n - int(pow(2, rem));\\n            int diff2 = n - int(pow(2, rem - 1));\\n            if(abs(diff1) > abs(diff2)){\\n                n = abs(diff2);\\n            }\\n            else if(abs(diff1) <= abs(diff2)){\\n                n = abs(diff1);\\n            }\\n            count++;\\n\\n        }\\n        return count;\\n\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206497,
                "title": "o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Maths**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**constant space**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       \\n        int t=0;\\n        while(n!=0){\\n             int x=log2(n);\\n        int dif=abs(n-pow(2,x));\\n        int dif2=pow(2,x+1)-n;\\n         n=min(dif,dif2);\\n            t++;\\n            //cout<<n<<\" \";\\n            \\n        }\\n        return t;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       \\n        int t=0;\\n        while(n!=0){\\n             int x=log2(n);\\n        int dif=abs(n-pow(2,x));\\n        int dif2=pow(2,x+1)-n;\\n         n=min(dif,dif2);\\n            t++;\\n            //cout<<n<<\" \";\\n            \\n        }\\n        return t;\\n     \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3206338,
                "title": "c-easy-iterative-time-100-space-100",
                "content": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tint minOperations(int x)\\n\\t\\t{\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\twhile (x != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back(x % 2);\\n\\t\\t\\t\\tx /= 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint i = 0, cnt = 0;\\n\\t\\t\\twhile (v.size() < 32) v.push_back(0);\\n\\t\\t\\t\\n\\t\\t\\tfor (i = 0; i < 32; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (v[i] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = i;\\n\\t\\t\\t\\t\\twhile (v[i + 1] == 1 && i + 1 < 32)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (l - i == 0) cnt++; // If 1 consecutive 1\\'s (001000)\\n\\t\\t\\t\\t\\telse         // If more than 1 consecutive 1\\'s (001100)or(00111100)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tv[i + 1] = 1;\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tint minOperations(int x)\\n\\t\\t{\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\twhile (x != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back(x % 2);\\n\\t\\t\\t\\tx /= 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint i = 0, cnt = 0;\\n\\t\\t\\twhile (v.size() < 32) v.push_back(0);\\n\\t\\t\\t\\n\\t\\t\\tfor (i = 0; i < 32; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (v[i] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint l = i;\\n\\t\\t\\t\\t\\twhile (v[i + 1] == 1 && i + 1 < 32)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (l - i == 0) cnt++; // If 1 consecutive 1\\'s (001000)\\n\\t\\t\\t\\t\\telse         // If more than 1 consecutive 1\\'s (001100)or(00111100)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tv[i + 1] = 1;\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206322,
                "title": "4-lines-100-easy-greedy-math-nearest-power-of-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are only two operations to choose from :\\n1. Either Subtract pow(2,x)\\n2. Or Add pow(2,x)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedily if we choose to reach the nearest power of 2, it will eventually need fewer steps\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$ ( Reduced to O(1) if replaced with Iteration)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n***Please Upvote to help me continue posting solutions : )***\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(int n){\\n        // here we Got our Answe\\n        if(n==0)\\n            return 0;\\n        \\n        int ans=log2(n);\\n\\n        //Nearest power of 2 less than n\\n        int num1=abs(n-pow(2,ans));\\n\\n        //Nearest power of 2 more than n\\n        int num2=abs(n-pow(2,ans+1));\\n        \\n        //Considering the minimum to reduce the steps\\n        int mini=min(num1,num2);\\n        \\n        return 1+helper(mini);    \\n    }\\n    \\n    int minOperations(int n) {\\n        \\n        int ans=helper(n);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(int n){\\n        // here we Got our Answe\\n        if(n==0)\\n            return 0;\\n        \\n        int ans=log2(n);\\n\\n        //Nearest power of 2 less than n\\n        int num1=abs(n-pow(2,ans));\\n\\n        //Nearest power of 2 more than n\\n        int num2=abs(n-pow(2,ans+1));\\n        \\n        //Considering the minimum to reduce the steps\\n        int mini=min(num1,num2);\\n        \\n        return 1+helper(mini);    \\n    }\\n    \\n    int minOperations(int n) {\\n        \\n        int ans=helper(n);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205992,
                "title": "simple-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int op = 1;\\n        while(n != 0){\\n            int num = 1;\\n            while(num <= n){\\n                if(num == n){\\n                   return op; \\n                } \\n                num *= 2;\\n            }\\n            n = Math.min(num-n,n-num/2);\\n            op++;\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int op = 1;\\n        while(n != 0){\\n            int num = 1;\\n            while(num <= n){\\n                if(num == n){\\n                   return op; \\n                } \\n                num *= 2;\\n            }\\n            n = Math.min(num-n,n-num/2);\\n            op++;\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205695,
                "title": "easy-dp-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n    */\\n    int minOperations(int n) {\\n        vector<int> dp(1000000,0);\\n        dp[0] = 0;dp[1] = 1;dp[2] = 1;dp[3] = 2;dp[4] = 1;dp[5] = 2;dp[6] = 2;\\n        vector<int> poww;\\n        for(int i = 0 ; i <= 19 ; i++){\\n            poww.push_back(pow(2,i));\\n            dp[pow(2,i)] = 1;\\n        }\\n        for(int i = 7 ; i <= n ; i++){\\n            int one = i;\\n            int two = i;\\n            if(dp[i] == 1){\\n                continue;\\n            }else{\\n                int ind = lower_bound(poww.begin(),poww.end(),i) - poww.begin();\\n                dp[i] = min(dp[i - poww[ind - 1]],dp[poww[ind] - i]) + 1;\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    */\\n    int minOperations(int n) {\\n        vector<int> dp(1000000,0);\\n        dp[0] = 0;dp[1] = 1;dp[2] = 1;dp[3] = 2;dp[4] = 1;dp[5] = 2;dp[6] = 2;\\n        vector<int> poww;\\n        for(int i = 0 ; i <= 19 ; i++){\\n            poww.push_back(pow(2,i));\\n            dp[pow(2,i)] = 1;\\n        }\\n        for(int i = 7 ; i <= n ; i++){\\n            int one = i;\\n            int two = i;\\n            if(dp[i] == 1){\\n                continue;\\n            }else{\\n                int ind = lower_bound(poww.begin(),poww.end(),i) - poww.begin();\\n                dp[i] = min(dp[i - poww[ind - 1]],dp[poww[ind] - i]) + 1;\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205223,
                "title": "3-approaches-recursive-greedy-bfs",
                "content": "**Recursion**\\n```\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 int minOperations(int n) {\\n        int x = 1;\\n        if(n <= 0)return 0;\\n        if(n == 1)return 1;\\n        while(x * 2 < n)x *= 2;\\n        return min(minOperations(n - x), minOperations(x * 2 - n)) + 1;\\n    }\\n};\\n```\\n\\n**Getting nearest to n (Greedy)**\\n```\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 int minOperations(int n) {\\n        int res = 0;\\n        \\n        while(n){\\n            int less = pow(2, floor(log2(n)));\\n            int more = pow(2, ceil(log2(n)));\\n            \\n            if(n - less > more - n)n = more - n;\\n            else n = n - less;\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Using BFS**\\n```\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 int minOperations(int n) {\\n        int res = 1;\\n        queue<int>q;\\n        q.push(n);\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0 ; i < size ; i++){\\n                int f = q.front();\\n                q.pop();\\n                if(!(f & (f - 1)))return res;\\n                // 39 = 2 ^ x -> x = log2(39)\\n                \\n                int x = log2(f);\\n                \\n                // Pushing one greater and one lesser \\n                q.push(pow(2, x + 1) - f);\\n                q.push(f-pow(2, x ));\\n            }         \\n            res++;   \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please upvote if you liked it !!**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 int minOperations(int n) {\\n        int x = 1;\\n        if(n <= 0)return 0;\\n        if(n == 1)return 1;\\n        while(x * 2 < n)x *= 2;\\n        return min(minOperations(n - x), minOperations(x * 2 - n)) + 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 int minOperations(int n) {\\n        int res = 0;\\n        \\n        while(n){\\n            int less = pow(2, floor(log2(n)));\\n            int more = pow(2, ceil(log2(n)));\\n            \\n            if(n - less > more - n)n = more - n;\\n            else n = n - less;\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\xA0\\xA0\\xA0 int minOperations(int n) {\\n        int res = 1;\\n        queue<int>q;\\n        q.push(n);\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0 ; i < size ; i++){\\n                int f = q.front();\\n                q.pop();\\n                if(!(f & (f - 1)))return res;\\n                // 39 = 2 ^ x -> x = log2(39)\\n                \\n                int x = log2(f);\\n                \\n                // Pushing one greater and one lesser \\n                q.push(pow(2, x + 1) - f);\\n                q.push(f-pow(2, x ));\\n            }         \\n            res++;   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205168,
                "title": "python-bfs-solution-easy-to-understand-but-slower-than-greedy-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        l=[]\\n        for i in range(20):\\n            l.append(2**i)\\n        q=deque()\\n        q.append([0,n])\\n        st=set()\\n        while q:\\n            x=q.popleft()\\n            a=x[0]\\n            b=x[1]\\n            if b==0:\\n                return a\\n            for e in l:\\n                if b-e>=0 and b-e not in st:\\n                    q.append([a+1,b-e])\\n                    st.add(b-e)\\n                if b+e<=2*n and b+e not in st:\\n                    q.append([a+1,b+e])\\n                    st.add(b+e)       \\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        l=[]\\n        for i in range(20):\\n            l.append(2**i)\\n        q=deque()\\n        q.append([0,n])\\n        st=set()\\n        while q:\\n            x=q.popleft()\\n            a=x[0]\\n            b=x[1]\\n            if b==0:\\n                return a\\n            for e in l:\\n                if b-e>=0 and b-e not in st:\\n                    q.append([a+1,b-e])\\n                    st.add(b-e)\\n                if b+e<=2*n and b+e not in st:\\n                    q.append([a+1,b+e])\\n                    st.add(b+e)       \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205039,
                "title": "c-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that we must deal with the nearest power of two for the given number each time we alter it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will have a function that gives me the nearest power of 2 for a given number. It may be greater than the number or lesser than it, but the purpose of the function \"nearest(int n)\" is the nearest power of 2.\\n\\nNow we will reduce the value of \\'n\\' with respect to the nearest power of 2 (we take the absolute value because depending on the situation we may move upwords or downwards for the nearest power of 2). We contniue this till the number is not 0 and with the help of a counter we can obtain the minimum operations required.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nearest(int n){\\n        int temp = 1;\\n        while(temp<n){\\n            temp = temp<<1;\\n        }\\n        if((temp-n)<(n - temp/2)){\\n            return temp;\\n        }\\n        else return temp/2;\\n    }\\n    \\n    int minOperations(int n) {\\n        int ans = 0;\\n        while(n!=0){\\n            n = abs(n - nearest(n));\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nearest(int n){\\n        int temp = 1;\\n        while(temp<n){\\n            temp = temp<<1;\\n        }\\n        if((temp-n)<(n - temp/2)){\\n            return temp;\\n        }\\n        else return temp/2;\\n    }\\n    \\n    int minOperations(int n) {\\n        int ans = 0;\\n        while(n!=0){\\n            n = abs(n - nearest(n));\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204925,
                "title": "easy-java-solution-using-greedy-100-beats",
                "content": "\\n# Approach\\nWe have taken the nearest largest possible value for the number that is the multiple of 2 and nearest smaller possible value that is  the\\nmultiple of 2 . Then we have check the smaller value as we can easily achive it . So we will take the smaller value and then tarfer the smaller value till it become zero .\\nWe will count how many times loops has been iterated to get the zero that will be our ans.\\n\\nFor any doubt , you can ask in comment section.\\n\\nLike it , if you liked this approach. \\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count=0;\\n        while(n!=0)\\n        {\\n            int c=1;\\n            while(c<=n)\\n            {\\n                c*=2; \\n            }\\n            int s=n-(c/2);\\n            int h =c-n;\\n            if(h>s)\\n            {\\n                n=s;\\n                count++;\\n            }else\\n            {\\n                n=h;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count=0;\\n        while(n!=0)\\n        {\\n            int c=1;\\n            while(c<=n)\\n            {\\n                c*=2; \\n            }\\n            int s=n-(c/2);\\n            int h =c-n;\\n            if(h>s)\\n            {\\n                n=s;\\n                count++;\\n            }else\\n            {\\n                n=h;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204629,
                "title": "cpp-0ms-runtime-recursion-bit-manipulation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe **`helper`** function performs one operation for each recursive call, and keep track of the total number of operations in **s**.\\n\\n**base case**: If **n** is power of **2** return from **`helper`** as we need only one operation.\\n\\n**recursive case:** First find the closest power of **2** then\\ncalculate the difference between the closest power of **2** and **n**. then recursively call the **`helper`** function with the new difference.\\n\\n**Example:** input n = 39:\\n    1. ***n = 39*** is not a power of **2**.\\n    2. closest power of **2** is **32**.\\n    3. The difference between **39** and **32** is **7**, and the total number of operations performed so far is **1**.\\n    4. **7** is not a power of **2**, so we find the closest power of **2** is **8**.\\n    5. The difference between **7** and **8** is **1**, and the total number of operations performed so far is **2**.\\n    6. **1** is a power of **2**, so we only need one more operation to reduce it to **0**.\\n    7. The total number of operations performed to reduce **n = 39** to **0** is **3**, which is the minimum number of operations.\\n    \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int s = 0;\\n    void helper(int n){\\n        s = s+1;\\n        if(((-n&n)^n) == 0){\\n            return;\\n        }else{\\n            int c = 1;\\n            while(c<n){\\n                c*=2;\\n            }\\n            if((n-(c/2)) >= (c-n)){\\n                helper(c-n);\\n            }else{\\n                helper(n-(c/2));\\n            }\\n        }\\n    }\\n    int minOperations(int n) {\\n        helper(n);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int s = 0;\\n    void helper(int n){\\n        s = s+1;\\n        if(((-n&n)^n) == 0){\\n            return;\\n        }else{\\n            int c = 1;\\n            while(c<n){\\n                c*=2;\\n            }\\n            if((n-(c/2)) >= (c-n)){\\n                helper(c-n);\\n            }else{\\n                helper(n-(c/2));\\n            }\\n        }\\n    }\\n    int minOperations(int n) {\\n        helper(n);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204625,
                "title": "bfs-in-java",
                "content": "# Intuition\\nLevel wise traversal from the the root (n = 0).\\n\\n# Approach\\nBreadth first travesal from the root node 0. Increment operation counter on each level. If the required number is found, return the counter.\\n\\n# Complexity\\n- Time complexity:\\nNo idea\\n\\n- Space complexity:\\nNo idea\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        queue.add(0);\\n        \\n        int ops = 0;\\n        Set<Integer> seen = new HashSet<>();\\n        seen.add(0);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int num = queue.poll();\\n                if (num == n) return ops;\\n                \\n                for (int j = 0; ((int)Math.pow(2, j)+num) <= 100000; j++) {\\n                    int p = (int)Math.pow(2, j) + num;\\n                    if (seen.contains(p)) continue;\\n                    seen.add(p);\\n                    queue.add(p);\\n                }\\n                for (int j = 0; (num-(int)Math.pow(2, j)) >= 0; j++) {\\n                    int p = num - (int)Math.pow(2, j);\\n                    if (seen.contains(p)) continue;\\n                    seen.add(p);\\n                    queue.add(p);\\n                }\\n            }\\n            ops++;\\n        }\\n        \\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        queue.add(0);\\n        \\n        int ops = 0;\\n        Set<Integer> seen = new HashSet<>();\\n        seen.add(0);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int num = queue.poll();\\n                if (num == n) return ops;\\n                \\n                for (int j = 0; ((int)Math.pow(2, j)+num) <= 100000; j++) {\\n                    int p = (int)Math.pow(2, j) + num;\\n                    if (seen.contains(p)) continue;\\n                    seen.add(p);\\n                    queue.add(p);\\n                }\\n                for (int j = 0; (num-(int)Math.pow(2, j)) >= 0; j++) {\\n                    int p = num - (int)Math.pow(2, j);\\n                    if (seen.contains(p)) continue;\\n                    seen.add(p);\\n                    queue.add(p);\\n                }\\n            }\\n            ops++;\\n        }\\n        \\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204293,
                "title": "c-math-5-line-solution-in-depth-explanation",
                "content": "# Intuition\\nThere are two pieces of intuition that are integral to completing this problem. \\n\\nFirst, we should reframe the question so that we can better formulate an algorithm. Another way to think about this problem is that we are trying to find the **distance** between $$0$$ and $$n$$, where our distance is a single operation of a power of two. This observation means that for a given integer $$n$$, we are trying to number of **optimal**  operations that get us to $$0$$. In order to figure this out, we need to figure out what the definition of an optimal operation is. \\n\\nIf an integer $$n$$  can be represented by a power of $$2$$, then it follows that $$log_2(n) = $$ a whole integer. If it cannot be represented by a power of $$2$$, then the result of the log will fall between some integers. For example:\\n\\n$$log_2(39) = 5.2854022189$$\\n$$log_2(64) = 6$$\\n\\nIf we are only allowed to subtract numbers which are powers of $$2$$, then it makes sense for us to subtract the power of $$2$$ CLOSEST to the $$log_2$$ of our function, aka the nearest whole number to the log of our integer. Cool. Lets look at an example using what we\\'ve learned\\n\\nGiven the following example:\\n$$n = 39$$\\nFind the minimum number of power of two operations to equal zero.\\n\\nLets try to find the most optimal turn. Intuition should point you torwards checking if $$n$$ is a power of two. If it isnt(it isnt), then we want to operate on n such that the result is as close as possible to $$0$$. \\n\\n$$log_2(39) = 5.2854022189, \\\\lfloor 5.2854022189 \\\\rceil = 5$$\\n\\nIt is most optimal to subtract $$32$$, as we then get $$7$$, which is closer to $$0$$. \\n\\nContinuing onward we are presented with an interesting choice. You might notice that $$2^0 = 1$$ and that $$1 + 7 = 8$$ which is a power of $$2$$. This means that in two additional operations, we can get 0! The issue is how do we know that we should add or when we should subtract?\\n\\nThinking about this further will lead to the discovery that there is no difference in distance($$n$$ from $$0$$ in number of operations) between first adding $$1$$ then subtracting $$8$$, or subtracting $$8$$ then adding $$1$$. This is huge! This means we can standardize our operations by taking the absolute value of our result, as $$distance(n) = distance(-n)$$. \\n\\nWe can now derive that by applying these two facts over and over again we get 0. Now we can finally begin to construct an algorithm.\\n\\n\\n# Approach\\n1. Initialize some counter $$C = 0$$ and being iterating through the steps below.\\n2. Find decimal $$i$$ where $$i = log_2(n)$$\\n3. Round $$i$$ to the nearest whole number. This gives us the power of  $$2$$ which is closest to $$n$$.\\n4. Subtract $$2^i$$ such that $$n =n - 2^i$$ to get the result of $$n$$ after performing the most optimal operation that results in the closest distance(number of operations to 0).\\n5. Set $$n = |n|$$, since addition and subtraction operations are irrelevant to our algorithm.\\n6. Increment $$C$$ by 1\\n7. Repeat steps $$2 \\\\dots6$$ until $$n = 0$$, return $$C$$\\n# Complexity\\n- Time complexity:\\n\\nThis is a little tricky to define and to be completely honest im not sure. `pow`is defined [here](https://www.quora.com/What-is-the-time-complexity-of-the-pow-function-in-c++-language-Is-it-log-b-or-O-1), as $$O(log(2))$$. `log` is also kinda weird, and from [what I can find](https://stackoverflow.com/questions/7317414/what-is-the-complexity-of-the-log-function) `log2` is $$O(1)$$. Its slightly more difficult to define the time complexity since if we knew it would be our answer, as our while loop is defined by the number of operations. As an upper bound, we can use $$\\\\Theta(log_2n)$$.\\n\\n- Space complexity:\\n$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int counter = 0;\\n        while(n > 0){\\n            n = abs(n - pow(2, round(log2(n))));\\n            ++counter;\\n        }\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int counter = 0;\\n        while(n > 0){\\n            n = abs(n - pow(2, round(log2(n))));\\n            ++counter;\\n        }\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204277,
                "title": "python-recursion-short-clean",
                "content": "# Intuition\\nLet ``f(x)`` be answer for `x` (minimum number of actions).\\nLet\\'s deduct this problem for `odd` and `even` cases:\\n1. If `x` is odd (`x%2==1`), it means that we MUST perform one of two operation `add 1` or `remove 1` (this is the only way we can get rid of that trailing `1`). In this case we get recursive equation `f(x)=min(f(x+1),f(x-1))+1`\\n2. If `x` is even (`x%2==0`), it means that we SHOULD NOT touch last bit at all, anyways adding or removing one from it will only increase operations count. In this case `f(x)=f(x//2)`.\\n\\nWhich gives us recursive solution.\\n\\nCareful reader might ask: since there is branch `f(x)=..f(x+1)..` it could exlode. But because we only do it for odd case, next time it gets divided by 2. So \"dangerous\" path will be `x -> x+1 -> (x+1)//2`. \"Dangerous\" number here is `1` (since `1 == (1+1)//2`), so we stop at `1` (since answer is `1` for sure), for `x > 1` dangerous path is always decreasing.\\n\\n\\n\\n# Approach\\nUse recursion with memoization for equations above. \\nStop condition `x <= 1`\\n\\n\\n# Complexity\\n- Time complexity: `O(log(n))`\\nEvery two steps number gets halved.\\n\\n- Space complexity: `O(log(n))`\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        @cache\\n        def f(x):\\n            if x <= 1: return x\\n            return 1+min(f(x-1), f(x+1)) if x%2==1 else f(x//2)\\n        return f(n)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        @cache\\n        def f(x):\\n            if x <= 1: return x\\n            return 1+min(f(x-1), f(x+1)) if x%2==1 else f(x//2)\\n        return f(n)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204224,
                "title": "python3-easy-bitwise-calculation",
                "content": "# Intuition\\nAn integer becomes zero when it has no bit set (i.e. 1). the max operations if we only substract , can be as many as there are number of 1s.\\nHowever, there is a way to minimize the operations , if we have\\nconsectives 1s more than once in number say 00001111 , if we add 1 to this number then this become 00010000 which needs one more extra operation (add 1 + make new 1 to zero i.e substrat = 2 op only), note originally it would be 4 ops , if we convert all 1 to 0.\\nBased on above idea , we can reduce number of ops.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        \\n        count = 0\\n        op_count = 0\\n        \\n        for i in range(32):\\n            # if bit is set , count it\\n            if n & (1 << i):\\n                count += 1\\n                \\n            else:\\n                # if more than one consective 1s\\n                # we can all  make 0 ,by add 1 to it\\n                if count > 1:\\n                    op_count += 1\\n                    count = 1 # 11101110-> 11110000\\n                # if chain of consective 1s break, we need to make it 0\\n                elif count == 1:\\n                    op_count += 1\\n                    count = 0\\n                else:\\n                    count = 0 \\n                \\n        return op_count\\n                    \\n                    \\n                \\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        \\n        count = 0\\n        op_count = 0\\n        \\n        for i in range(32):\\n            # if bit is set , count it\\n            if n & (1 << i):\\n                count += 1\\n                \\n            else:\\n                # if more than one consective 1s\\n                # we can all  make 0 ,by add 1 to it\\n                if count > 1:\\n                    op_count += 1\\n                    count = 1 # 11101110-> 11110000\\n                # if chain of consective 1s break, we need to make it 0\\n                elif count == 1:\\n                    op_count += 1\\n                    count = 0\\n                else:\\n                    count = 0 \\n                \\n        return op_count\\n                    \\n                    \\n                \\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204163,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy observation, if we want to make 39 to 0, we would like to make it 32 first, so we can subtract it in 1 ops. In order to get to 32, we need to make 7 to 0, the closest number in power of 2 is 8. following we just need to fix the difference of 1, which is $2^0$.\\n\\nSo, our goal is greedily make the number to the closest power of 2 in each iteration, and return how much iteration we did.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe calculate the closest number in power of 2 and compute the difference between n and the number for next iteration.\\n\\nin order to do so, we compute log base 2 in each iteration and round it to the closest integer.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int count = 0;\\n        while(n != 0) {\\n            int log = roundedLog2(n);\\n            n = Math.abs(n-(int)Math.pow(2, log));\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public static int roundedLog2(int N)\\n    {\\n        int result = (int)Math.round(Math.log(N) / Math.log(2));\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        \\n        int count = 0;\\n        while(n != 0) {\\n            int log = roundedLog2(n);\\n            n = Math.abs(n-(int)Math.pow(2, log));\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public static int roundedLog2(int N)\\n    {\\n        int result = (int)Math.round(Math.log(N) / Math.log(2));\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204151,
                "title": "2-lines-solution-using-recursion",
                "content": "# Approach\\n- First find the cell and floor of the log2(n)\\n- Example : n = 54\\n     --> First step : n = 54\\n         low = floor(log2(54)) = 32\\n         high = ceil(log2(54)) = 64\\n         tlow = 54 - 32 = 22\\n         thigh = 64 - 54 = 10\\n    \\n     --> Second Step: n = 10 (tlow)  \\n          low = floor(log2(10)) = 8\\n          high = ceil(log2(10)) = 16\\n          tlow = 2\\n          thigh = 6\\n    \\n     --> Third Step: n = 2 (tlow)  \\n          low = floor(log2(2)) = 2\\n          high = ceil(log2(10)) = 2\\n          tlow = 0\\n          thigh = 0\\n        \\n- Now n = 0 , So return total step 3\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (n == 0) return 0;\\n        int low = floor(log2(n));\\n        int high = ceil(log2(n));\\n        \\n        int tlow = n - pow(2,low);\\n        int thigh = pow(2,high) - n;\\n        \\n        if(tlow > thigh) return 1+minOperations(thigh);\\n        return 1+minOperations(tlow);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (n == 0) return 0;\\n        int low = floor(log2(n));\\n        int high = ceil(log2(n));\\n        \\n        int tlow = n - pow(2,low);\\n        int thigh = pow(2,high) - n;\\n        \\n        if(tlow > thigh) return 1+minOperations(thigh);\\n        return 1+minOperations(tlow);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204087,
                "title": "very-easy-beginner-friendly-solution-100-acceptance",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res=1;\\n        while(res*2<=n) res*=2;\\n        int high=res*2;\\n        if(res==n){\\n            return 1;\\n        }\\n        return 1+minOperations(min(n-res,high-n));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res=1;\\n        while(res*2<=n) res*=2;\\n        int high=res*2;\\n        if(res==n){\\n            return 1;\\n        }\\n        return 1+minOperations(min(n-res,high-n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204073,
                "title": "c-bfs-o-nlogn-time-o-n-space",
                "content": "# Intuition\\nThis is a common problem solved using `BFS` (hint is we need to find the minimum operations)\\n\\n# Approach\\nRun a BFS with source as n and destination as 0. Don\\'t go out of bounds `[0, largest_power_of_2_greater_than_n]`. The reason for taking the largest power of 2 greater than n is because it doesn\\'t make sense to go above that since we can get to 0 in one step from the largest power of 2 greater than n\\n\\n# Complexity\\n- Time complexity: `O(nlogn)` since we have n nodes and nlogn edges\\n\\n- Space complexity: `O(n)` since limit will be atmost `2n`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n      vector<int> pows{1};\\n      int lim = 1;\\n      while (lim <= n) {\\n        lim *= 2;\\n        pows.push_back(lim);\\n      }\\n      const int INF = 1e9;\\n      \\n      queue<int> q;\\n      q.push(n);\\n      vector<bool> visited(lim + 1);\\n      visited[n] = 1;\\n      vector<int> dist(lim + 1, INF);\\n      dist[n] = 0;\\n      \\n      while (!q.empty()) {\\n        int x = q.front(); q.pop();\\n        if (x == 0) return dist[0];\\n        \\n        for (auto &p: pows) {\\n          if (x + p <= lim && !visited[x + p]) {\\n            visited[x + p] = true;\\n            q.push(x + p);\\n            dist[x + p] = 1 + dist[x];\\n          }\\n          if (x - p >= 0 && !visited[x - p]) {\\n            visited[x - p] = true;\\n            q.push(x - p);\\n            dist[x - p] = 1 + dist[x];\\n          }\\n        }\\n      }\\n      \\n      return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n      vector<int> pows{1};\\n      int lim = 1;\\n      while (lim <= n) {\\n        lim *= 2;\\n        pows.push_back(lim);\\n      }\\n      const int INF = 1e9;\\n      \\n      queue<int> q;\\n      q.push(n);\\n      vector<bool> visited(lim + 1);\\n      visited[n] = 1;\\n      vector<int> dist(lim + 1, INF);\\n      dist[n] = 0;\\n      \\n      while (!q.empty()) {\\n        int x = q.front(); q.pop();\\n        if (x == 0) return dist[0];\\n        \\n        for (auto &p: pows) {\\n          if (x + p <= lim && !visited[x + p]) {\\n            visited[x + p] = true;\\n            q.push(x + p);\\n            dist[x + p] = 1 + dist[x];\\n          }\\n          if (x - p >= 0 && !visited[x - p]) {\\n            visited[x - p] = true;\\n            q.push(x - p);\\n            dist[x - p] = 1 + dist[x];\\n          }\\n        }\\n      }\\n      \\n      return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204071,
                "title": "recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(logn)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int compute(int n)\\n    {\\n        if(n<=0) return 0;\\n        else\\n        {\\n            int t1 = log2(n);\\n            int t2 = ceil(log2(n));\\n            int temp = pow(2,t2) - n;\\n            int t = 1 + compute(n - pow(2,t1));\\n            int r = 1 + compute(temp);\\n            \\n            return min(t,r);\\n        }\\n    }\\n    \\n    int minOperations(int n) {\\n       \\n        return compute(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int compute(int n)\\n    {\\n        if(n<=0) return 0;\\n        else\\n        {\\n            int t1 = log2(n);\\n            int t2 = ceil(log2(n));\\n            int temp = pow(2,t2) - n;\\n            int t = 1 + compute(n - pow(2,t1));\\n            int r = 1 + compute(temp);\\n            \\n            return min(t,r);\\n        }\\n    }\\n    \\n    int minOperations(int n) {\\n       \\n        return compute(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204060,
                "title": "easy-to-understand",
                "content": "# Intuition\\n    Nearest power of 2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(1)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int getpow(int n)\\n    {\\n          int i=1;\\n          int ans=0;\\n          while(i<=n)\\n          {\\n              i=i*2;\\n              ans++;\\n          }\\n        \\n        return ans-1;\\n    }\\n    \\n    int minOperations(int n) {\\n          \\n        \\n        if(n==1) return 1;\\n        int res=0;\\n        while(n>0){\\n            \\n            res++;\\n            int minp=getpow(n);\\n            int n1=n-pow(2,minp);\\n            int maxp=minp+1;\\n            int n2=pow(2,maxp)-n;\\n            n=min(n1,n2);\\n\\n        }\\n      \\n    \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getpow(int n)\\n    {\\n          int i=1;\\n          int ans=0;\\n          while(i<=n)\\n          {\\n              i=i*2;\\n              ans++;\\n          }\\n        \\n        return ans-1;\\n    }\\n    \\n    int minOperations(int n) {\\n          \\n        \\n        if(n==1) return 1;\\n        int res=0;\\n        while(n>0){\\n            \\n            res++;\\n            int minp=getpow(n);\\n            int n1=n-pow(2,minp);\\n            int maxp=minp+1;\\n            int n2=pow(2,maxp)-n;\\n            n=min(n1,n2);\\n\\n        }\\n      \\n    \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204035,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (n==0)\\n            return 0;\\n        int low = floor(log2(n));\\n        int high = ceil(log2(n));\\n        int tlow = abs(pow(2,low)-n),thigh = abs(pow(2,high)-n);\\n        if(tlow > thigh)\\n            return 1+minOperations(thigh);\\n        return 1+minOperations(tlow);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (n==0)\\n            return 0;\\n        int low = floor(log2(n));\\n        int high = ceil(log2(n));\\n        int tlow = abs(pow(2,low)-n),thigh = abs(pow(2,high)-n);\\n        if(tlow > thigh)\\n            return 1+minOperations(thigh);\\n        return 1+minOperations(tlow);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204029,
                "title": "python-easy-solution",
                "content": "\\n    def minOperations(self, n: int) -> int:\\n        def rec(n,counter = 0):\\n            if self.check(n):\\n                return counter+1\\n            i = 1\\n            m = 2\\n            while n > m:\\n\\n                m=pow(2,i)\\n\\n                i+=1\\n\\n            if abs(m-n) < abs(n - (m//2)):\\n                h = abs(m-n)\\n                return rec(h, counter + 1)\\n            else:\\n                h = abs(n - m//2)\\n                return rec(h, counter + 1)\\n\\n\\n        return rec(n)\\n\\n\\n\\n    def check(self,n):\\n        l = 1\\n        i = 0\\n        while l < pow(2,100):\\n            if n == l:\\n                return True\\n            l = pow(2,i)\\n            i +=1\\n        return False\\n        \\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\n    def minOperations(self, n: int) -> int:\\n        def rec(n,counter = 0):\\n            if self.check(n):\\n                return counter+1\\n            i = 1\\n            m = 2\\n            while n > m:\\n\\n                m=pow(2,i)\\n\\n                i+=1\\n\\n            if abs(m-n) < abs(n - (m//2)):\\n                h = abs(m-n)\\n                return rec(h, counter + 1)\\n            else:\\n                h = abs(n - m//2)\\n                return rec(h, counter + 1)\\n\\n\\n        return rec(n)\\n\\n\\n\\n    def check(self,n):\\n        l = 1\\n        i = 0\\n        while l < pow(2,100):\\n            if n == l:\\n                return True\\n            l = pow(2,i)\\n            i +=1\\n        return False\\n        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 3204028,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        c = [2**i for i in range(18)]\\n        counter = 0\\n        while n != 0:\\n            d = [abs(n-k) for k in c]\\n            counter += 1\\n            n = min(d)\\n        return counter\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        c = [2**i for i in range(18)]\\n        counter = 0\\n        while n != 0:\\n            d = [abs(n-k) for k in c]\\n            counter += 1\\n            n = min(d)\\n        return counter\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204015,
                "title": "python3-check-groups-of-zeros-and-ones-quick-and-simple",
                "content": "# Intuition\\nWhen we have group of only one `\\'1\\'`, we eliminate it in one step (subtraction).\\nWhen we have group of more ones, we eliminate it in two steps (add and subtract).\\n\\nWhen we have group of one `\\'0\\'`, we are not doing subtraction, instead we join new created `\\'1\\'` to the nexh group of ones.\\n\\nWe are processing it from right to left.\\n\\n# Example:\\n`n = 3995` \\nBinary it is `0111110011011` \\n`re.findall(\\'1+|0+\\',\\'0111110011011\\')` is `[\\'0\\', \\'11111\\', \\'00\\', \\'11\\', \\'0\\', \\'11\\']`\\n\\nIteration 1:\\nThe last two groups are `\\'11\\'` and `\\'0\\'`.\\nWe eliminate ones in one step and we have one new `\\'1\\'` which we add to the next group of ones.\\n\\nIteration 2:\\nNow we have two groups: `\\'111\\'` and `\\'00\\'`.\\nWe eliminate ones in two steps.\\n\\nIteration 3:\\nNow we have two groups: `\\'11111\\'` and `\\'0\\'`.\\nWe eliminate ones in two steps.\\n\\nWe made 1 + 2 + 2 = 5 steps.\\nAnswer is 5.\\n\\n# Code\\n```\\n    def minOperations(self, n: int) -> int:\\n        b=\\'0\\'+bin(n)[2:].strip(\\'0\\')\\n        groups=re.findall(\\'1+|0+\\',b)\\n        i=1\\n        answ=0\\n        while i<len(groups):\\n            if len(groups[-i])==1:\\n                answ+=1\\n            elif 1<len(groups[-i-1]):\\n                answ+=2\\n            else:\\n                answ+=1\\n                if i+2<=len(groups):\\n                    groups[-i-2]+=\\'1\\'\\n                else:\\n                    answ+=1\\n            i+=2\\n        return answ \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def minOperations(self, n: int) -> int:\\n        b=\\'0\\'+bin(n)[2:].strip(\\'0\\')\\n        groups=re.findall(\\'1+|0+\\',b)\\n        i=1\\n        answ=0\\n        while i<len(groups):\\n            if len(groups[-i])==1:\\n                answ+=1\\n            elif 1<len(groups[-i-1]):\\n                answ+=2\\n            else:\\n                answ+=1\\n                if i+2<=len(groups):\\n                    groups[-i-2]+=\\'1\\'\\n                else:\\n                    answ+=1\\n            i+=2\\n        return answ \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3203879,
                "title": "best-java-solution-without-bit-manipulation-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int i=0; int c=0;\\n        while(n>0){\\n            if(Math.pow(2,i)==n)\\n            {  n=n-(int)Math.pow(2,i);\\n            c++;\\n             break;\\n            }\\n             if(Math.pow(2,i)>n){\\n                n=(int)Math.min((Math.pow(2,i)-n),n-Math.pow(2,i-1));\\n                 c++;\\n                 i=-1;\\n             }\\n            i++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int i=0; int c=0;\\n        while(n>0){\\n            if(Math.pow(2,i)==n)\\n            {  n=n-(int)Math.pow(2,i);\\n            c++;\\n             break;\\n            }\\n             if(Math.pow(2,i)>n){\\n                n=(int)Math.min((Math.pow(2,i)-n),n-Math.pow(2,i-1));\\n                 c++;\\n                 i=-1;\\n             }\\n            i++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203865,
                "title": "easiest-cpp-solution",
                "content": "Greedy: We just need to make n as small as possible by adding/substracting the closest Power of 2. In the below code if you observe n is getting smaller in every iteration of while loop until n==0.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int cnt=0, a, b;\\n        while(n) {\\n            cnt++;\\n            a = pow(2, ceil(log(n)/log(2)));\\n            b = pow(2, floor(log(n)/log(2)));\\n            if(a-n < n-b) n = a-n;\\n            else n = n-b;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int cnt=0, a, b;\\n        while(n) {\\n            cnt++;\\n            a = pow(2, ceil(log(n)/log(2)));\\n            b = pow(2, floor(log(n)/log(2)));\\n            if(a-n < n-b) n = a-n;\\n            else n = n-b;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203823,
                "title": "decrease-no-of-setbits",
                "content": "# [See One line recursive solution](https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3203743/one-line/)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res = 0;\\n        for(int i= 0;i<31;i++)if(noOfOnes(n+ pow(2,i)) < noOfOnes(n))++res, n += pow(2,i);\\n        return res + noOfOnes(n);        \\n    }\\nprivate:\\n    int noOfOnes(int n,int res = 0){\\n       while(n)res++,n = n&(n-1);\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int res = 0;\\n        for(int i= 0;i<31;i++)if(noOfOnes(n+ pow(2,i)) < noOfOnes(n))++res, n += pow(2,i);\\n        return res + noOfOnes(n);        \\n    }\\nprivate:\\n    int noOfOnes(int n,int res = 0){\\n       while(n)res++,n = n&(n-1);\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203822,
                "title": "easy-recursive-approach-with-comments",
                "content": "# Approach\\nWe will Subtract the number from the powers of 2 until we get an element that is power of 2\\n\\n# Complexity\\n```Time Complexity : O(3 * logn * (2 ^ (log n ^ 3))) => O(9 * n *logn) => O(n * logn)```\\n\\n```Space Complexity : O(1)```\\n\\nI think this is the time complexity, let me know if I made a mistake in calculating it\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Checking if n is the power of 2\\n    bool isPowerOf2(int &n){\\n        int val = 1;\\n        \\n        while(val < n)\\n            val = val*2;\\n        \\n        return val==n;\\n    }\\n    \\n    // Calculating the largest value which is smaller than n and is a power of 2\\n    int helper1(int &n){\\n        int val = 1;\\n        \\n        while(val*2 < n)\\n            val = val*2;\\n        \\n        return val;\\n    }\\n    \\n// Calculating the smallest value which is larget than n and is a power of 2\\n    int helper2(int &n){\\n        int val = 1;\\n        \\n        while(val < n)\\n            val = val*2;\\n        \\n        return val;\\n    }\\n    \\n    int helper(int n){\\n        if(isPowerOf2(n))   // If the value is a power of 2, then we need 1 operation to make it 0\\n            return 1;\\n        \\n        int min_val = helper1(n);   // Largest element we can subtract from n which is a power of 2\\n        int max_val = helper2(n);   // Smallest element that can subtract n which is a power of 2\\n        \\n        return (1 + min(helper(n - min_val), helper(max_val - n))); \\n    }\\n    \\n    int minOperations(int n) {\\n        return helper(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```Time Complexity : O(3 * logn * (2 ^ (log n ^ 3))) => O(9 * n *logn) => O(n * logn)```\n```Space Complexity : O(1)```\n```\\nclass Solution {\\npublic:\\n    // Checking if n is the power of 2\\n    bool isPowerOf2(int &n){\\n        int val = 1;\\n        \\n        while(val < n)\\n            val = val*2;\\n        \\n        return val==n;\\n    }\\n    \\n    // Calculating the largest value which is smaller than n and is a power of 2\\n    int helper1(int &n){\\n        int val = 1;\\n        \\n        while(val*2 < n)\\n            val = val*2;\\n        \\n        return val;\\n    }\\n    \\n// Calculating the smallest value which is larget than n and is a power of 2\\n    int helper2(int &n){\\n        int val = 1;\\n        \\n        while(val < n)\\n            val = val*2;\\n        \\n        return val;\\n    }\\n    \\n    int helper(int n){\\n        if(isPowerOf2(n))   // If the value is a power of 2, then we need 1 operation to make it 0\\n            return 1;\\n        \\n        int min_val = helper1(n);   // Largest element we can subtract from n which is a power of 2\\n        int max_val = helper2(n);   // Smallest element that can subtract n which is a power of 2\\n        \\n        return (1 + min(helper(n - min_val), helper(max_val - n))); \\n    }\\n    \\n    int minOperations(int n) {\\n        return helper(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203767,
                "title": "python-3-my-brute-force-kinda-way-bfs",
                "content": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        q =  deque( [n] )\\n        seen = set( [n] )\\n        res = -1\\n        \\n        while q:\\n            res += 1\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                \\n                if cur == 0:\\n                    return res\\n                \\n                for i in range(17):\\n                    t = 1 << i\\n                    \\n                    if cur + t <= 2 ** 17 and cur + t not in seen:\\n                        q.append(cur + t)\\n                        seen.add(cur + t)\\n                    if cur - t >= -(2 ** 17) and cur - t not in seen:\\n                        q.append(cur - t)\\n                        seen.add(cur - t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        q =  deque( [n] )\\n        seen = set( [n] )\\n        res = -1\\n        \\n        while q:\\n            res += 1\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                \\n                if cur == 0:\\n                    return res\\n                \\n                for i in range(17):\\n                    t = 1 << i\\n                    \\n                    if cur + t <= 2 ** 17 and cur + t not in seen:\\n                        q.append(cur + t)\\n                        seen.add(cur + t)\\n                    if cur - t >= -(2 ** 17) and cur - t not in seen:\\n                        q.append(cur - t)\\n                        seen.add(cur - t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203743,
                "title": "one-line",
                "content": "# [Second solution](https://leetcode.com/discuss/topic/3203823/decrease-no-of-setbits/)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return !n?0:(abs(pow(2,floor((double)log2(n)))-n)>abs(pow(2,ceil((double)log2(n)))-n))? \\n               1+ minOperations((abs(pow(2,ceil((double)log2(n)))-n))):1+ minOperations((abs(pow(2,floor((double)log2(n)))-n)));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        return !n?0:(abs(pow(2,floor((double)log2(n)))-n)>abs(pow(2,ceil((double)log2(n)))-n))? \\n               1+ minOperations((abs(pow(2,ceil((double)log2(n)))-n))):1+ minOperations((abs(pow(2,floor((double)log2(n)))-n)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203738,
                "title": "2571-minimum-operations-to-reduce-an-integer-to-0-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n         int count = 0;\\n    while (n != 0) {\\n        if (n % 2 == 0) {\\n            n /= 2;\\n        } else {\\n            if (n == 1 || (n & 2) == 0) {\\n                n -= 1;\\n            } else {\\n                n += 1;\\n            }\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n         int count = 0;\\n    while (n != 0) {\\n        if (n % 2 == 0) {\\n            n /= 2;\\n        } else {\\n            if (n == 1 || (n & 2) == 0) {\\n                n -= 1;\\n            } else {\\n                n += 1;\\n            }\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203731,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (1 == __builtin_popcount(n))\\n            return 1;\\n        auto a = pow(2, (int)log2(n));\\n        auto b = pow(2, (int)log2(n) + 1);\\n        auto na = minOperations(n - a);\\n        auto nb = minOperations(b - n);\\n        return min(na, nb) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (1 == __builtin_popcount(n))\\n            return 1;\\n        auto a = pow(2, (int)log2(n));\\n        auto b = pow(2, (int)log2(n) + 1);\\n        auto na = minOperations(n - a);\\n        auto nb = minOperations(b - n);\\n        return min(na, nb) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203717,
                "title": "java-1-line-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return Integer.bitCount(n ^ (3 * n));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return Integer.bitCount(n ^ (3 * n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203711,
                "title": "c-recursion-easy-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Check if the no. is near to its just smallerpowerOf2 or just greater.\\n    Whichever near, reduce the the no. by the difference between them.\\n    Do this process recursively and increasing count everytime by 1.\\n    Stop when the no. becomes 0 or powOf2.  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool powOfTwo(int n) {        \\n        if(n==1) return true;\\n        \\n        return log10(n)/log10(2) == int(log10(n)/log10(2)) ? true : false;\\n    }\\n    \\n    int helper(int n){\\n        if(n==0) return 0;\\n        else if(powOfTwo(n)) return 1;\\n        \\n        // Finding the last bit which is 1 to generate equivalent power of 2\\n        int setbit=ceil(log2(n+1));\\n\\n        // Generating smaller and larger nos.\\n        int prev=1<<(setbit-1);\\n        int next=(prev<<1);\\n        \\n        if(n-prev <= next-n) return helper(n-prev)+1;\\n        else return helper(next-n)+1;\\n    }\\n    \\n    int minOperations(int n) {\\n        \\n        return helper(n);       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool powOfTwo(int n) {        \\n        if(n==1) return true;\\n        \\n        return log10(n)/log10(2) == int(log10(n)/log10(2)) ? true : false;\\n    }\\n    \\n    int helper(int n){\\n        if(n==0) return 0;\\n        else if(powOfTwo(n)) return 1;\\n        \\n        // Finding the last bit which is 1 to generate equivalent power of 2\\n        int setbit=ceil(log2(n+1));\\n\\n        // Generating smaller and larger nos.\\n        int prev=1<<(setbit-1);\\n        int next=(prev<<1);\\n        \\n        if(n-prev <= next-n) return helper(n-prev)+1;\\n        else return helper(next-n)+1;\\n    }\\n    \\n    int minOperations(int n) {\\n        \\n        return helper(n);       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203706,
                "title": "easiest-java-solution",
                "content": "# Intuition\\nFind Power of 2 to the nearest n.\\nFind the difference of pow 2 and n;\\nupdate n to diff.\\n \\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count=0;\\n        while(n!=0){\\n            int pow=1;\\n            int prevPow=pow;\\n            while(pow<n){\\n                prevPow=pow;\\n                pow=pow<<1;\\n            }\\n            int nearest=Math.min(n-prevPow,pow-n);\\n            n=nearest;\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count=0;\\n        while(n!=0){\\n            int pow=1;\\n            int prevPow=pow;\\n            while(pow<n){\\n                prevPow=pow;\\n                pow=pow<<1;\\n            }\\n            int nearest=Math.min(n-prevPow,pow-n);\\n            n=nearest;\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203703,
                "title": "python-bfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        largest = 10**5\\n        lst = []\\n        i = 0\\n        res = 1\\n        # Populate list of all possible 2*i while 2*i < 10**5\\n        while res < largest:\\n            lst.append(res)\\n            i += 1\\n            res = 2**i\\n        \\n        \\n        q = deque([n])\\n        operations = 0\\n        visited = set()\\n        while q:\\n            for _ in range(len(q)):\\n                num = q.popleft()\\n                if num in visited:\\n                    continue\\n                visited.add(num)\\n                if num == 0:\\n                    return operations\\n                \\n                # add\\n                for val in lst:\\n                    # Make sure q doesn\\'t get too large with unnessecarry large numbers \\n                    if num + val < 100000:\\n                        q.append(num + val)\\n                \\n                # Subtract\\n                for val in lst:\\n                    # No negatives\\n                    if val > num:\\n                        break\\n                    q.append(num - val)\\n            operations += 1\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        largest = 10**5\\n        lst = []\\n        i = 0\\n        res = 1\\n        # Populate list of all possible 2*i while 2*i < 10**5\\n        while res < largest:\\n            lst.append(res)\\n            i += 1\\n            res = 2**i\\n        \\n        \\n        q = deque([n])\\n        operations = 0\\n        visited = set()\\n        while q:\\n            for _ in range(len(q)):\\n                num = q.popleft()\\n                if num in visited:\\n                    continue\\n                visited.add(num)\\n                if num == 0:\\n                    return operations\\n                \\n                # add\\n                for val in lst:\\n                    # Make sure q doesn\\'t get too large with unnessecarry large numbers \\n                    if num + val < 100000:\\n                        q.append(num + val)\\n                \\n                # Subtract\\n                for val in lst:\\n                    # No negatives\\n                    if val > num:\\n                        break\\n                    q.append(num - val)\\n            operations += 1\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078326,
                "title": "non-complex-easily-readable-python-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        \\n        def get_low_high(n):\\n            x = 0\\n            while pow(2, x) < n:\\n                x += 1 \\n            lower = x\\n            high = x - 1\\n            return lower, high\\n\\n        min_operations = 0\\n        while(n !=0):\\n            lower, high = get_low_high(n)\\n            left_dist = abs(n - pow(2, lower))\\n            right_dist = abs(n- pow(2, high))\\n            n = min(left_dist, right_dist)\\n            min_operations += 1\\n        \\n        return min_operations\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        \\n        def get_low_high(n):\\n            x = 0\\n            while pow(2, x) < n:\\n                x += 1 \\n            lower = x\\n            high = x - 1\\n            return lower, high\\n\\n        min_operations = 0\\n        while(n !=0):\\n            lower, high = get_low_high(n)\\n            left_dist = abs(n - pow(2, lower))\\n            right_dist = abs(n- pow(2, high))\\n            n = min(left_dist, right_dist)\\n            min_operations += 1\\n        \\n        return min_operations\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033082,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int temp=1;\\n        if (n==0) return 0;\\n        while(n>temp){\\n            temp=temp*2;    \\n        }\\n        return 1+minOperations( Math.min(n-temp/2, temp-n)   );\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int temp=1;\\n        if (n==0) return 0;\\n        while(n>temp){\\n            temp=temp*2;    \\n        }\\n        return 1+minOperations( Math.min(n-temp/2, temp-n)   );\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029040,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLook for the closest value of power 2 to the given number n. Recursion will narrow down the n value to 0,1, or 2. If we have value 1 or 2 we know there would be 1 more operation required, and if we have 0 then we can simply return number of operations.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ops(int n,int count)\\n    {\\n        if(n <= 0)\\n            return count;\\n        if(n == 1 || n == 2)\\n            return count + 1;\\n        int i = 0, cmpVal = pow(2, i);\\n        while( n > cmpVal)\\n        {\\n            i++;\\n            cmpVal = pow(2, i);\\n        }\\n        int lwrVal = pow(2, i-1);\\n        if( n - lwrVal == 0)\\n        {\\n            return count;\\n        }\\n        else if ( cmpVal - n < n - lwrVal)\\n        {\\n            count = ops(cmpVal-n,count + 1);\\n        } else {\\n            count = ops(n-lwrVal,count + 1);\\n        }\\n        return count;\\n    }\\n    int minOperations(int n) {\\n        return ops(n,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ops(int n,int count)\\n    {\\n        if(n <= 0)\\n            return count;\\n        if(n == 1 || n == 2)\\n            return count + 1;\\n        int i = 0, cmpVal = pow(2, i);\\n        while( n > cmpVal)\\n        {\\n            i++;\\n            cmpVal = pow(2, i);\\n        }\\n        int lwrVal = pow(2, i-1);\\n        if( n - lwrVal == 0)\\n        {\\n            return count;\\n        }\\n        else if ( cmpVal - n < n - lwrVal)\\n        {\\n            count = ops(cmpVal-n,count + 1);\\n        } else {\\n            count = ops(n-lwrVal,count + 1);\\n        }\\n        return count;\\n    }\\n    int minOperations(int n) {\\n        return ops(n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018507,
                "title": "cool-java-solution-beats-100",
                "content": "# Intuition\\n* The key here is efficiently getting to a number that is a power of 2\\n* Once we get to a power of 2, we know there can only be one operation, and that is, to subtract that number by itself to get to zero, or the closest power of 2 is zero itself\\n\\n\\n# Approach\\n* recursively apply the following approach\\n    * Compute the value of $$\\\\log _{2} n$$\\n    * this will give you the number of times $$2^i$$ must be applied in order to get to n\\n    * the nearest power of 2 to n will be either $$\\\\lceil{\\\\log _{2} n}\\\\rceil$$ or $$\\\\lfloor{\\\\log _{2} n}\\\\rfloor$$\\n    * choose the nearest of the two based on whether $$\\\\log _{2} n$$\\'s first two decimal points are greater than .5 or less than .5 (ceiling if greater, floor if less)\\n    * the problem then becomes to recursively find the solution of the difference between n and $$\\\\lceil{\\\\log _{2} n}\\\\rceil$$ or $$\\\\lfloor{\\\\log _{2} n}\\\\rfloor$$\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(log _{2} n)$$ - correct me in the comments if i am wrong, but i believe this ultimately boils down to a binary search for the closest power of 2\\n\\n- Space complexity:\\n$$O(1)$$ constant space but there is stack space used due to recursion\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return(recur(n));\\n    }\\n    public int recur(int n){\\n        if(n == 0) return 1;\\n        double logBase2 = Math.log(n)/Math.log(2);\\n        double floor = Math.floor(logBase2);\\n        double diff = logBase2 - floor;\\n        if(diff == 0) return 1;\\n        if( diff > .5 ){\\n            return 1 + recur((int)Math.pow(2,Math.ceil(logBase2)) - n );\\n        }else{\\n            return 1 + recur(n - (int)Math.pow(2,Math.floor(logBase2)) );\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        return(recur(n));\\n    }\\n    public int recur(int n){\\n        if(n == 0) return 1;\\n        double logBase2 = Math.log(n)/Math.log(2);\\n        double floor = Math.floor(logBase2);\\n        double diff = logBase2 - floor;\\n        if(diff == 0) return 1;\\n        if( diff > .5 ){\\n            return 1 + recur((int)Math.pow(2,Math.ceil(logBase2)) - n );\\n        }else{\\n            return 1 + recur(n - (int)Math.pow(2,Math.floor(logBase2)) );\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922711,
                "title": "c-beats-100-recursion",
                "content": "**Simple recursive solution.**\\nCheck the number less than n which is power of 2 lets say num1 and number greater than n which is power of 2 lets say num2;\\nNow call recursion to either reach num1 or num2 in least number of steps.\\n ```\\n int minOperations(int n) {\\n        int num1=log2(n);\\n        int num2=num1+1;\\n        // if((n & (n-1))==0)return 1;\\n        if(n==pow(2,num1))return 1;\\n        return 1+min(minOperations(n-pow(2,num1)),minOperations(pow(2,num2)-n));\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n int minOperations(int n) {\\n        int num1=log2(n);\\n        int num2=num1+1;\\n        // if((n & (n-1))==0)return 1;\\n        if(n==pow(2,num1))return 1;\\n        return 1+min(minOperations(n-pow(2,num1)),minOperations(pow(2,num2)-n));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3904549,
                "title": "c-beats-100-right-most-set-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the beginning I thought no of set bits would be the answer, then I thought of the continous bits of 1s case. In this case, if we add 1 all of them becomes zero and ultimately we get single 1, then we subtract it. But what if the newly created 1 attaches to the next continous bits of 1s, then we add another 1, and ultimatly we subtract it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* we use concepts of right most set bit here to solve this problem.\\n* we add the repitions of ones and zeros in the bits array, and follow our method.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log(n))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int rsb = log2(n & -n);\\n        n >>= rsb;\\n        vector<int> bits;\\n        while(n != 0){\\n            int bf = n+1;\\n            rsb = log2(bf & -bf);\\n            bits.push_back(rsb);\\n            n>>=rsb;\\n            if (n != 0) {\\n                rsb = log2(n & -n);\\n                bits.push_back(rsb);\\n                n >>=rsb;\\n            }\\n        }\\n        int answer = 0;\\n        for(int i =0;i<bits.size();){\\n            if (bits[i] == 1) answer++;\\n            else {\\n                if (i+1 == bits.size()) answer+=2;\\n                else if (bits[i+1] == 1){\\n                    answer++;\\n                    bits[i+2]++;\\n                }\\n                else{\\n                    answer+=2;\\n                }\\n            }\\n            i+=2;\\n        }\\n        return answer;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int rsb = log2(n & -n);\\n        n >>= rsb;\\n        vector<int> bits;\\n        while(n != 0){\\n            int bf = n+1;\\n            rsb = log2(bf & -bf);\\n            bits.push_back(rsb);\\n            n>>=rsb;\\n            if (n != 0) {\\n                rsb = log2(n & -n);\\n                bits.push_back(rsb);\\n                n >>=rsb;\\n            }\\n        }\\n        int answer = 0;\\n        for(int i =0;i<bits.size();){\\n            if (bits[i] == 1) answer++;\\n            else {\\n                if (i+1 == bits.size()) answer+=2;\\n                else if (bits[i+1] == 1){\\n                    answer++;\\n                    bits[i+2]++;\\n                }\\n                else{\\n                    answer+=2;\\n                }\\n            }\\n            i+=2;\\n        }\\n        return answer;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896187,
                "title": "c-solution-bit-masking",
                "content": "# Approach\\nThe number of consecutive ones can be considered as one unit by adding 2 to the power of the least significant bit of the consecutive and after performing the same operations for all consecutive ones it will one step each to subtract the group of 1 formed by the above process.\\n\\n# Complexity\\n- Time complexity:\\n$$O($$ log$$n$$ $$)$$\\n\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int car=0;\\n        int no=0;\\n        int ans=0;\\n        while(n)\\n        {\\n                if((n&1)==1 and car)\\n                {\\n                    n>>=1;\\n                    no++;\\n                }\\n                else if((n&1)==1 and !car)\\n                {\\n                    no++;\\n                    n>>=1;\\n                    car=1;\\n                }\\n                else if((n&1)==0 and car)\\n                {\\n                    if(no>1)\\n                    {\\n                        ans++;\\n                        car=1;\\n                        n>>=1;\\n                        no=1;\\n                    }\\n                    else\\n                    {\\n                        ans++;\\n                        n>>=1;\\n                        car=0;\\n                        no=0;\\n                    }\\n                }\\n                else \\n                {\\n                    n>>=1;\\n                }\\n        }\\n\\n        if(car and no>1)ans+=2;\\n        else if(car and no<=1)ans++;\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int car=0;\\n        int no=0;\\n        int ans=0;\\n        while(n)\\n        {\\n                if((n&1)==1 and car)\\n                {\\n                    n>>=1;\\n                    no++;\\n                }\\n                else if((n&1)==1 and !car)\\n                {\\n                    no++;\\n                    n>>=1;\\n                    car=1;\\n                }\\n                else if((n&1)==0 and car)\\n                {\\n                    if(no>1)\\n                    {\\n                        ans++;\\n                        car=1;\\n                        n>>=1;\\n                        no=1;\\n                    }\\n                    else\\n                    {\\n                        ans++;\\n                        n>>=1;\\n                        car=0;\\n                        no=0;\\n                    }\\n                }\\n                else \\n                {\\n                    n>>=1;\\n                }\\n        }\\n\\n        if(car and no>1)ans+=2;\\n        else if(car and no<=1)ans++;\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894072,
                "title": "recursive-and-memoized-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&dp){\\n        int ans =0;\\n        int power = log(i)/log(2);\\n        int lo = pow(2,power);\\n        if(lo-i==0) return dp[i] = 1;\\n        if(dp[i]!=-1) return dp[i];\\n        ans = 1+solve(i-lo,dp);\\n        int hi = pow(2,power+1);\\n        ans = min(ans,1+solve(hi-i,dp));\\n        return dp[i] = ans;\\n    }\\n    int minOperations(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,vector<int>&dp){\\n        int ans =0;\\n        int power = log(i)/log(2);\\n        int lo = pow(2,power);\\n        if(lo-i==0) return dp[i] = 1;\\n        if(dp[i]!=-1) return dp[i];\\n        ans = 1+solve(i-lo,dp);\\n        int hi = pow(2,power+1);\\n        ans = min(ans,1+solve(hi-i,dp));\\n        return dp[i] = ans;\\n    }\\n    int minOperations(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889254,
                "title": "bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0;\\n        while(n){\\n            if(n & 1){\\n                ans++;\\n                n = n>>1;\\n                if((n&1) ==0){\\n                    continue;\\n                }\\n                while(n&1)\\n                    n = n>>1;\\n\\n                n = n|1;\\n            }\\n            else{\\n                n = n>>1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0;\\n        while(n){\\n            if(n & 1){\\n                ans++;\\n                n = n>>1;\\n                if((n&1) ==0){\\n                    continue;\\n                }\\n                while(n&1)\\n                    n = n>>1;\\n\\n                n = n|1;\\n            }\\n            else{\\n                n = n>>1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887946,
                "title": "c-solution-using-dp",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int> dp(n+1);\\n        for(int i=1; i<=n ; i++){\\n            int power=(int)(log(i)/log(2));\\n            int curr=(int)pow(2,power);\\n            dp[i]=1+dp[i-curr];\\n\\n            curr=(int)(pow(2,power+1));\\n            dp[i]=min(dp[i], 1+ dp[curr-i]);\\n        }\\n            return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int> dp(n+1);\\n        for(int i=1; i<=n ; i++){\\n            int power=(int)(log(i)/log(2));\\n            int curr=(int)pow(2,power);\\n            dp[i]=1+dp[i-curr];\\n\\n            curr=(int)(pow(2,power+1));\\n            dp[i]=min(dp[i], 1+ dp[curr-i]);\\n        }\\n            return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877063,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        ans = 0\\n\\n\\n        while n != 0:\\n\\n            i = 1\\n\\n            while 2 ** i < n:\\n                i += 1\\n\\n            \\n            n = min(2 ** i - n, n - 2 ** (i - 1))\\n            ans += 1\\n        \\n        \\n        \\n        return ans\\n        \\n        \\n     \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        ans = 0\\n\\n\\n        while n != 0:\\n\\n            i = 1\\n\\n            while 2 ** i < n:\\n                i += 1\\n\\n            \\n            n = min(2 ** i - n, n - 2 ** (i - 1))\\n            ans += 1\\n        \\n        \\n        \\n        return ans\\n        \\n        \\n     \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865976,
                "title": "recursion-dp-bitmask-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n    \\n     int solve(int n,vector<int>&dp)\\n     {\\n         if((n&n-1)==0)\\n             return 1;\\n         if(n==0)\\n         return 0;\\n         if(dp[n]!=-1)\\n         return dp[n];\\n         if(n==1) return 1;\\n          int msb=int(log2(n));\\n          \\n         return dp[n]= 1+min(solve(n-pow(2,msb),dp),solve(pow(2,msb+1)-n,dp));\\n     }\\n};\\n\\n// recursion //\\n\\n// class Solution {\\n// public:\\n//     int minOperations(int n) {\\n        \\n//         return solve(n);\\n//     }\\n    \\n//      int solve(int n)\\n//      {\\n//          if((n&n-1)==0)\\n//              return 1;\\n//          if(n==0)\\n//          return 0;\\n//          if(n==1) return 1;\\n//           int msb=int(log2(n));\\n          \\n//          return 1+min(solve(n-pow(2,msb)),solve(pow(2,msb+1)-n));\\n//      }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n    \\n     int solve(int n,vector<int>&dp)\\n     {\\n         if((n&n-1)==0)\\n             return 1;\\n         if(n==0)\\n         return 0;\\n         if(dp[n]!=-1)\\n         return dp[n];\\n         if(n==1) return 1;\\n          int msb=int(log2(n));\\n          \\n         return dp[n]= 1+min(solve(n-pow(2,msb),dp),solve(pow(2,msb+1)-n,dp));\\n     }\\n};\\n\\n// recursion //\\n\\n// class Solution {\\n// public:\\n//     int minOperations(int n) {\\n        \\n//         return solve(n);\\n//     }\\n    \\n//      int solve(int n)\\n//      {\\n//          if((n&n-1)==0)\\n//              return 1;\\n//          if(n==0)\\n//          return 0;\\n//          if(n==1) return 1;\\n//           int msb=int(log2(n));\\n          \\n//          return 1+min(solve(n-pow(2,msb)),solve(pow(2,msb+1)-n));\\n//      }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854468,
                "title": "golang-solution-with-comment",
                "content": "# Code\\n```go\\nfunc minOperations(n int) int {\\n\\tbase := []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072}\\n\\top := 0\\n\\tfor n != 0 {\\n\\t\\tfor i, v := range base {\\n\\t\\t\\tif n < v {\\n\\t\\t\\t\\top++\\n\\t\\t\\t\\t// n1 maybe 0\\n\\t\\t\\t\\tn1 := n - base[i-1]\\n\\t\\t\\t\\tn2 := v - n\\n\\t\\t\\t\\t// replace n by min diff, n is non-negative here\\n\\t\\t\\t\\tif n1 < n2 {\\n\\t\\t\\t\\t\\tn = n1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tn = n2\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn op\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperations(n int) int {\\n\\tbase := []int{1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072}\\n\\top := 0\\n\\tfor n != 0 {\\n\\t\\tfor i, v := range base {\\n\\t\\t\\tif n < v {\\n\\t\\t\\t\\top++\\n\\t\\t\\t\\t// n1 maybe 0\\n\\t\\t\\t\\tn1 := n - base[i-1]\\n\\t\\t\\t\\tn2 := v - n\\n\\t\\t\\t\\t// replace n by min diff, n is non-negative here\\n\\t\\t\\t\\tif n1 < n2 {\\n\\t\\t\\t\\t\\tn = n1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tn = n2\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn op\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848800,
                "title": "beats-100-recursive-memo-tabulation-just-observe-the-pattern",
                "content": "# Recursive Approach (Beats 50%)\\n- Time complexity: $$O(log(n))$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n\\n        if(n == 0) return 0;\\n        if(n == 1 || n == 2) return 1;\\n\\n       long long i=1;\\n       while(i*2 < n)\\n        i *= 2;\\n\\n      return 1 + min(minOperations(n - i),minOperations(2*i - n));\\n    }\\n};\\n```\\n.\\n# Memoization Approach (Beats 100%)\\n- Time complexity: $$O(log(n))$$ \\n\\n- Space complexity: $$O(n)$$ \\n```\\nclass Solution {\\n    unordered_map<int,int> dp; //in order to remember already processed calls\\npublic:\\n    int minOperations(int n) {\\n\\n        if(n == 0) return 0;\\n        if(n == 1 || n == 2) return 1;\\n\\n        if(dp[n] != 0) //if the result is already computed\\n         return dp[n]; //return it, without re-calculating\\n\\n       long long i=1;\\n       while(i*2 < n)\\n        i *= 2;\\n\\n      return dp[n] = 1 + min(minOperations(n - i),minOperations(2*i - n));\\n    }\\n};\\n```\\n\\n.\\n# Tabulation (Beats 13%)\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[0] = 0;\\n\\n        if(n <= 2)\\n         return 1;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        int prevPow2 = 2, nextPow2 = 4;\\n\\n        for(int num=3; num<=n; num++)\\n         {\\n             if( (num & (num-1)) == 0 ) //if \\'num\\' is a power of 2\\n              {\\n                  dp[num] = 1; //we can change it to 0 in one step\\n                  prevPow2 = num;\\n                  nextPow2 = 2*num;\\n                  continue;\\n              } //you can derive below formula by working out some testcases in the range [2,16]\\n             dp[num] = 1 + min(dp[num - prevPow2],dp[nextPow2 - num]);\\n         }  \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n\\n        if(n == 0) return 0;\\n        if(n == 1 || n == 2) return 1;\\n\\n       long long i=1;\\n       while(i*2 < n)\\n        i *= 2;\\n\\n      return 1 + min(minOperations(n - i),minOperations(2*i - n));\\n    }\\n};\\n```\n```\\nclass Solution {\\n    unordered_map<int,int> dp; //in order to remember already processed calls\\npublic:\\n    int minOperations(int n) {\\n\\n        if(n == 0) return 0;\\n        if(n == 1 || n == 2) return 1;\\n\\n        if(dp[n] != 0) //if the result is already computed\\n         return dp[n]; //return it, without re-calculating\\n\\n       long long i=1;\\n       while(i*2 < n)\\n        i *= 2;\\n\\n      return dp[n] = 1 + min(minOperations(n - i),minOperations(2*i - n));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[0] = 0;\\n\\n        if(n <= 2)\\n         return 1;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        int prevPow2 = 2, nextPow2 = 4;\\n\\n        for(int num=3; num<=n; num++)\\n         {\\n             if( (num & (num-1)) == 0 ) //if \\'num\\' is a power of 2\\n              {\\n                  dp[num] = 1; //we can change it to 0 in one step\\n                  prevPow2 = num;\\n                  nextPow2 = 2*num;\\n                  continue;\\n              } //you can derive below formula by working out some testcases in the range [2,16]\\n             dp[num] = 1 + min(dp[num - prevPow2],dp[nextPow2 - num]);\\n         }  \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842439,
                "title": "easy-solution-beats-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            int count = 0;\\n            while(n&1)\\n            {\\n                count++;\\n                n>>=1;\\n            }\\n            if(count==1)\\n            {\\n                ans+=1;\\n            }\\n            else if(count>=2)\\n            {\\n                ans+=1;\\n                n = n|1;\\n            }\\n            else\\n            {\\n                n>>=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0;\\n        while(n>0)\\n        {\\n            int count = 0;\\n            while(n&1)\\n            {\\n                count++;\\n                n>>=1;\\n            }\\n            if(count==1)\\n            {\\n                ans+=1;\\n            }\\n            else if(count>=2)\\n            {\\n                ans+=1;\\n                n = n|1;\\n            }\\n            else\\n            {\\n                n>>=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835889,
                "title": "java-easy-100",
                "content": "class Solution {\\n    public int minOperations(int n) {\\n        int cnt = 0;\\n        cnt=recur(n,cnt);\\n        return cnt;\\n    }\\n    public int recur(int n,int cnt)\\n    {\\n        int i=0;\\n        while((int)(Math.pow(2,i))<=n)\\n        {\\n            i++;\\n        }\\n        n=Math.min(Math.abs(n-(int)(Math.pow(2,i-1))), Math.abs((n-(int)Math.pow(2,i))));\\n        \\n        System.out.println(n);\\n        cnt++;\\n        System.out.println(cnt);\\n        if(n==0) return cnt;\\n        if(n==-1||n==1)\\n        return cnt+1;\\n        return recur(n,cnt);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minOperations(int n) {\\n        int cnt = 0;\\n        cnt=recur(n,cnt);\\n        return cnt;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3806267,
                "title": "pure-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n)\\n    {\\n        int ans=0;\\n        while(n>0)\\n        {\\n            cout<<n<<endl;\\n           if(n&1)\\n           {\\n               ans++;\\n               n=n/2;\\n               if(n&1)\\n               {\\n                   n++;\\n               }\\n           }\\n           else\\n           {\\n               n=n/2;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n)\\n    {\\n        int ans=0;\\n        while(n>0)\\n        {\\n            cout<<n<<endl;\\n           if(n&1)\\n           {\\n               ans++;\\n               n=n/2;\\n               if(n&1)\\n               {\\n                   n++;\\n               }\\n           }\\n           else\\n           {\\n               n=n/2;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3784317,
                "title": "beats-100-c-solution-short-code-using-while-loops",
                "content": "# Approach\\nWe run the while loop till n > 0. An inner while loop runs to find a power of 2 which is greater than \\'n\\' (the given number). Once we have found this power we compare whether the current \\'n\\' is closer to the power of 2 greater than \\'n\\' or smaller than \\'n\\'. We reset the value of n to the difference with the closer power.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int pow, cnt = 0;\\n\\n        while (n > 0) {\\n            pow = 1; // resetting value of pow to 1\\n            while (n > pow) pow *= 2; // finding closest largest power of 2\\n            n = min(n-pow/2, pow-n); // resetting n to diff with closest power\\n            cnt++; // increasing count by 1\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int pow, cnt = 0;\\n\\n        while (n > 0) {\\n            pow = 1; // resetting value of pow to 1\\n            while (n > pow) pow *= 2; // finding closest largest power of 2\\n            n = min(n-pow/2, pow-n); // resetting n to diff with closest power\\n            cnt++; // increasing count by 1\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782366,
                "title": "most-clear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the closest powers of two to n. Use the power of two closest to n as the new n. Since the previous power of 2 is used as an added/subtracted value, we count it as an operation.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (n == 0) return 0;\\n        if (n == 1) return 1;\\n\\n        int upperBound = pow(2, (int)log2(n) + 1), lowerBound = pow(2, (int)log2(n));\\n        int upperDiff = upperBound - n, lowerDiff = n - lowerBound;\\n        if (lowerDiff < upperDiff)\\n            return 1 + minOperations(lowerDiff);\\n        return 1 + minOperations(upperDiff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (n == 0) return 0;\\n        if (n == 1) return 1;\\n\\n        int upperBound = pow(2, (int)log2(n) + 1), lowerBound = pow(2, (int)log2(n));\\n        int upperDiff = upperBound - n, lowerDiff = n - lowerBound;\\n        if (lowerDiff < upperDiff)\\n            return 1 + minOperations(lowerDiff);\\n        return 1 + minOperations(upperDiff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754127,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int cnt=1;\\n        while(n!=0){\\n            int num = 1;\\n            while(num <= n){\\n                if(num == n){\\n                   return cnt; \\n                } \\n                num *= 2;\\n            }\\n            n = Math.min(num-n,n-num/2);\\n            cnt++;\\n    }\\n    return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int cnt=1;\\n        while(n!=0){\\n            int num = 1;\\n            while(num <= n){\\n                if(num == n){\\n                   return cnt; \\n                } \\n                num *= 2;\\n            }\\n            n = Math.min(num-n,n-num/2);\\n            cnt++;\\n    }\\n    return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748927,
                "title": "well-commented-code-with-implementation-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // lets suppose there is a number with binary repre as 11110 (reduced to zero in 4 op)\\n        // adding some 2^i to this will reduce the operations\\n        // 11110\\n        //+00010\\n        //100000 => total op =2 (1 addition + 1 subtraction)\\n        int ans=0;\\n        while(n>0){\\n            if(n&1){//means the least sign bit is 1\\n                // now we will check if it contains only 1 one or a series of 1 \\n                //in both cases we will need one operation\\n                //if there is only one 1 then we will perform 2^i\\n                //otherwise we will add 1 to the series of ones\\n                ans++;\\n                n/=2; // shift left\\n                if(n&1)// means there are a sequence of ones\\n                    n++;\\n            }\\n            else{// least sign bit is 0 just shift to left i.e divide number by 2;\\n                n/=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        // lets suppose there is a number with binary repre as 11110 (reduced to zero in 4 op)\\n        // adding some 2^i to this will reduce the operations\\n        // 11110\\n        //+00010\\n        //100000 => total op =2 (1 addition + 1 subtraction)\\n        int ans=0;\\n        while(n>0){\\n            if(n&1){//means the least sign bit is 1\\n                // now we will check if it contains only 1 one or a series of 1 \\n                //in both cases we will need one operation\\n                //if there is only one 1 then we will perform 2^i\\n                //otherwise we will add 1 to the series of ones\\n                ans++;\\n                n/=2; // shift left\\n                if(n&1)// means there are a sequence of ones\\n                    n++;\\n            }\\n            else{// least sign bit is 0 just shift to left i.e divide number by 2;\\n                n/=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735800,
                "title": "c-top-down-dp",
                "content": "# Complexity\\n- Time complexity:  $$O(log \\\\space n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log \\\\space n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int max_allowed;\\n    vector<vector<int>> dp;\\npublic:\\n    int solve(int n, int pos) {\\n        if(n == 0)\\n            return 0;\\n        else if(n & (n-1) == 0)\\n            return 1;\\n\\n        else if(pos > max_allowed)\\n            return 1e9;\\n\\n        if(dp[n][pos] != -1)\\n            return dp[n][pos];\\n        \\n\\n        int bit = (1 << pos) & n;\\n        int res;\\n        if(bit) {\\n            res = min(1 + solve(n + (1 << pos), pos+1), 1 + solve(n - (1 << pos), pos+1));\\n        }\\n        else {\\n            res = solve(n, pos+1);\\n        }\\n\\n        return dp[n][pos] = res;\\n    }\\n\\n    int minOperations(int n) {\\n        max_allowed = floor(log2(n)) + 1;\\n        dp.resize((1 << (max_allowed+1)), vector<int>(max_allowed + 1, -1));\\n\\n        return solve(n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int max_allowed;\\n    vector<vector<int>> dp;\\npublic:\\n    int solve(int n, int pos) {\\n        if(n == 0)\\n            return 0;\\n        else if(n & (n-1) == 0)\\n            return 1;\\n\\n        else if(pos > max_allowed)\\n            return 1e9;\\n\\n        if(dp[n][pos] != -1)\\n            return dp[n][pos];\\n        \\n\\n        int bit = (1 << pos) & n;\\n        int res;\\n        if(bit) {\\n            res = min(1 + solve(n + (1 << pos), pos+1), 1 + solve(n - (1 << pos), pos+1));\\n        }\\n        else {\\n            res = solve(n, pos+1);\\n        }\\n\\n        return dp[n][pos] = res;\\n    }\\n\\n    int minOperations(int n) {\\n        max_allowed = floor(log2(n)) + 1;\\n        dp.resize((1 << (max_allowed+1)), vector<int>(max_allowed + 1, -1));\\n\\n        return solve(n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726140,
                "title": "c-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> Whenever you encounter continuous one like \"111100111\" simply add 1 to convert it to 0 in 1 operation like \"111100111\" ->\"111101000\" else just remove single one by dividing it.[]()\\n# Complexity\\n- Time complexity:**O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        while(n>0){\\n            if(n&1){\\n                ans++;\\n                n/=2;\\n                if(n&1){\\n                    n++;\\n                }\\n            }\\n            else{\\n                n/=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        while(n>0){\\n            if(n&1){\\n                ans++;\\n                n/=2;\\n                if(n&1){\\n                    n++;\\n                }\\n            }\\n            else{\\n                n/=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701937,
                "title": "c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach number starting from $$0$$ is connected to other numbers via adding or substracting powers of $$2$$. To find the minimum distance from $$0$$ to $$n$$, simply perform the BFS algorithm over this induced graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the upper limit of $$n$$ is $$1e5$$, the powers of two used to explore the graph, should not be larger than this.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1e5 * 10)$$\\nSince the time complexity of BFS is $$O(V + E)$$, E here is calculated as the number of possible nodes times the number of neighbours each node has, divided by two. So E $$\\\\sim 1e5 * \\\\frac{17}{2}$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1e5)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0;\\n        vector<int> pts;\\n        for (int i=0; i<18; i++) {\\n            pts.push_back(pow(2,i));\\n        }\\n        queue<pair<int, int>> q;\\n        q.push({0,0});\\n        unordered_set<int> vis;\\n        vis.insert(0);\\n        while (!q.empty()) {\\n            auto x = q.front(); q.pop();\\n            if (x.first == n) {\\n                ans = x.second;\\n                break;\\n            }\\n            for (int& pt : pts) {\\n                int ne = x.first + pt;\\n                if (ne <= pts.back() + 1 && !vis.count(ne)) {\\n                    q.push({ne, x.second + 1});\\n                    vis.insert(ne);\\n                }\\n                ne = x.first - pt;\\n                if (ne >= 0 && !vis.count(ne)) {\\n                    q.push({ne, x.second + 1});\\n                    vis.insert(ne);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans = 0;\\n        vector<int> pts;\\n        for (int i=0; i<18; i++) {\\n            pts.push_back(pow(2,i));\\n        }\\n        queue<pair<int, int>> q;\\n        q.push({0,0});\\n        unordered_set<int> vis;\\n        vis.insert(0);\\n        while (!q.empty()) {\\n            auto x = q.front(); q.pop();\\n            if (x.first == n) {\\n                ans = x.second;\\n                break;\\n            }\\n            for (int& pt : pts) {\\n                int ne = x.first + pt;\\n                if (ne <= pts.back() + 1 && !vis.count(ne)) {\\n                    q.push({ne, x.second + 1});\\n                    vis.insert(ne);\\n                }\\n                ne = x.first - pt;\\n                if (ne >= 0 && !vis.count(ne)) {\\n                    q.push({ne, x.second + 1});\\n                    vis.insert(ne);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701884,
                "title": "python-easy-and-fast-time-o-log-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou need to find the nearest power of 2 to n. Then continue subtracting that from n until it becomes 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm iteratively subtracts the largest power of 2 from the given number n until n becomes zero. In each iteration, it calculates the absolute difference between n and the largest power of 2, updates n with the new value, and increments the operation count. The algorithm terminates when n becomes zero, and the final count represents the minimum number of operations needed to reach zero from the initial n.\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef minOperations(self, n: int) -> int:\\n        total_opr = 0\\n        while n:\\n            n = abs(n - (2 ** round(math.log2(n))))\\n            total_opr += 1\\n        return total_op\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, n: int) -> int:\\n        total_opr = 0\\n        while n:\\n            n = abs(n - (2 ** round(math.log2(n))))\\n            total_opr += 1\\n        return total_op\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3699396,
                "title": "python-100-quick-n-easy",
                "content": "# Intuition\\nInstead of thinking of subtracting powers of 2, lets think of a way to combine powers of 2 to make the target n.\\n\\nIntuitively our first step we want to take the \"jump\" that brings us closest to the target. If we overshoot or undershoot, since we can subtract, we can just repeat the same process with a new target.\\n\\n# Approach\\nStarting with n, we use the python log function to get the largest power of 2 less than n. Then we update n to equal the smallest difference between either the largest power of 2 less than n or the smallest power of 2 greater than n. Intuitively, these two options represent the two \"jumps\" closest to n. \\n\\nContinue this process until n is 0.\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        num = n\\n        steps = 0\\n        while n != 0:\\n            c = int(math.log(n,2))\\n            n = min(abs(n-2**c), abs(n-2**(c+1)))\\n            steps += 1\\n        return steps\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        num = n\\n        steps = 0\\n        while n != 0:\\n            c = int(math.log(n,2))\\n            n = min(abs(n-2**c), abs(n-2**(c+1)))\\n            steps += 1\\n        return steps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695223,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(k) k= minoperations\\n- Space complexity:\\n1. O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count =0;\\n        while(n>0){\\n            double x = Math.log(n)/Math.log(2);\\n            if(x%1.0 <0.5){\\n                n=Math.abs(n-(int)Math.pow(2,(int)x));\\n                count++;\\n            }else{\\n                 n=Math.abs(n-(int)Math.pow(2,(int)x+1));\\n                 count++;\\n\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int count =0;\\n        while(n>0){\\n            double x = Math.log(n)/Math.log(2);\\n            if(x%1.0 <0.5){\\n                n=Math.abs(n-(int)Math.pow(2,(int)x));\\n                count++;\\n            }else{\\n                 n=Math.abs(n-(int)Math.pow(2,(int)x+1));\\n                 count++;\\n\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681198,
                "title": "c-intuitive-solution-recursionrec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor ```num``` == *any power of 2* : output is 1\\nso we try to convert any given number to the closest power of 2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLocate the power of 2 ```power``` that is closest to the given number ```num```.\\nlet ```diff``` = |```x``` - ```power```|\\nnow,\\nno of operations need to convert ```x``` to ```power``` = no of operations needed to reduce ```diff``` to ```0```.\\n\\nno of operations need to reduce ```x``` to ```0``` = no of operations needed to convert ```diff``` to ```0``` + 1.\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nwhere ```n``` is the upperbound for ```num```.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans(int x, vector<int> powers)\\n    {\\n        if(x<2)\\n            return x;\\n        for(int i=1; i<powers.size(); i++)\\n        {\\n            if(powers[i] == x)\\n            {\\n                return 1;\\n            }\\n            if(powers[i] > x)\\n            {\\n                int diff = min(powers[i]-x, x-powers[i-1]);\\n                return ans(diff, powers)+1;\\n            }\\n        }\\n        return 0;\\n    }\\n    int minOperations(int n) {\\n        vector<int> powers;\\n        powers.push_back(1);\\n        while(powers.back() < 100000)\\n        {\\n            powers.push_back(powers.back()*2);\\n        }\\n        return ans(n,powers);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```num```\n```power```\n```num```\n```diff```\n```x```\n```power```\n```x```\n```power```\n```diff```\n```0```\n```x```\n```0```\n```diff```\n```0```\n```n```\n```num```\n```\\nclass Solution {\\npublic:\\n    int ans(int x, vector<int> powers)\\n    {\\n        if(x<2)\\n            return x;\\n        for(int i=1; i<powers.size(); i++)\\n        {\\n            if(powers[i] == x)\\n            {\\n                return 1;\\n            }\\n            if(powers[i] > x)\\n            {\\n                int diff = min(powers[i]-x, x-powers[i-1]);\\n                return ans(diff, powers)+1;\\n            }\\n        }\\n        return 0;\\n    }\\n    int minOperations(int n) {\\n        vector<int> powers;\\n        powers.push_back(1);\\n        while(powers.back() < 100000)\\n        {\\n            powers.push_back(powers.back()*2);\\n        }\\n        return ans(n,powers);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674079,
                "title": "very-easy-o-log2-n-solution-very-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWithout thinking about DP, Greey, etc, if we only look at a few examples.\\n1. 1110011\\n2. 11101\\n3. 111011\\n4. 1011\\n\\nWhen we encounter a `1...1`, we can either delete 1 or add 1.\\n\\nFor example 1, we notice that \\n- `11` with two deletion of 1, get `00`\\n- `11` with addition of 1, get `100`,\\nThus we can have \\n- `1110011` -> `1110000` -> `10000000` -> `00000000`\\n- `1110011` -> `1110100`\\n\\nFor example 2, it is obvious that if we do either one of the following:\\n- `11101` -> `11110` \\n- `11101` -> `11100`\\nthe total operation count is 3. Thus if we encounter a `xxx01(0)`, we can just delete the 1.\\n\\nFor example 3, we see that it is better if we add 1 to `11`. \\n- `11` -> `00` need two deletion\\n- `11` -> `100` -> `000` need one addition and one deletion\\nAdding 1 to `11` is better here. It does not hurt. Besides, we might come across `110110`, where adding 1 is definitely better.\\n\\n\\nIn general, we want to have as many consecutive ones as possible.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe scan n from the least significant bit. After each loop, we shift n to the right by 1 bit: n = n >> 1\\nWhen we encounter a 0, \\na) if currently there is only one 1 following 0, simply delete it\\nb) if the count of 1 >= 2, add 1 to n. It will make the current bit from 0 to 1  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log2(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nfunc minOperations(n int) int {\\n    var onec int = 0 // count of one\\n    var res int = 0 // answer\\n    if (n == 0) {return 0}\\n    for {\\n        if (n == 0) {break}\\n        f := n & 1\\n        if (f == 0) { \\n            if (onec == 1) { \\n                onec = 0 // delete it\\n                res += 1\\n            } else if (onec > 1) {\\n                onec = 0 // after adding 1, get 0, carry is 1\\n                        // here we add 1 to the 1..1 formed by \\n                        // onec count of 1\\n                res += 1 // the add 1 operation\\n                onec = 1 // the f is now 1 by, carry is 0\\n            }\\n        } else {\\n            onec ++\\n        }\\n        n = n >> 1\\n    }\\n\\n    // deal with remaining 1\\n    if (onec > 0) { \\n        if (onec > 1) {res += 2}\\n        if (onec == 1) {res += 1}\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minOperations(n int) int {\\n    var onec int = 0 // count of one\\n    var res int = 0 // answer\\n    if (n == 0) {return 0}\\n    for {\\n        if (n == 0) {break}\\n        f := n & 1\\n        if (f == 0) { \\n            if (onec == 1) { \\n                onec = 0 // delete it\\n                res += 1\\n            } else if (onec > 1) {\\n                onec = 0 // after adding 1, get 0, carry is 1\\n                        // here we add 1 to the 1..1 formed by \\n                        // onec count of 1\\n                res += 1 // the add 1 operation\\n                onec = 1 // the f is now 1 by, carry is 0\\n            }\\n        } else {\\n            onec ++\\n        }\\n        n = n >> 1\\n    }\\n\\n    // deal with remaining 1\\n    if (onec > 0) { \\n        if (onec > 1) {res += 2}\\n        if (onec == 1) {res += 1}\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657725,
                "title": "easy-c-basic-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        int count=0;\\n        while(n>0){\\n            n = n/2;\\n            count++;\\n        }\\n        return count;\\n    }\\n    int minOperations(int n) {\\n        int y=n;\\n        int count=0;\\n        while(y>0){\\n            int x = solve(y);\\n            y = min(y-pow(2,x-1),pow(2,x)-y);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n){\\n        int count=0;\\n        while(n>0){\\n            n = n/2;\\n            count++;\\n        }\\n        return count;\\n    }\\n    int minOperations(int n) {\\n        int y=n;\\n        int count=0;\\n        while(y>0){\\n            int x = solve(y);\\n            y = min(y-pow(2,x-1),pow(2,x)-y);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656787,
                "title": "simple-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        while(n)\\n        {\\n            int bit=n&1;\\n            int bit2=(n>>1)&1;\\n            if(bit==1)\\n            {\\n                ans++;\\n                if(bit2==1)\\n                n+=1;\\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int ans=0;\\n        while(n)\\n        {\\n            int bit=n&1;\\n            int bit2=(n>>1)&1;\\n            if(bit==1)\\n            {\\n                ans++;\\n                if(bit2==1)\\n                n+=1;\\n            }\\n            n=n>>1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653005,
                "title": "take-not-take-concept-basic-recursion-bit-manuplication-o-2-17",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every bit either Add 2^i or leave (similar of Take Not-take problem).\\nBase Condtion when i reaches its size of n (bit). count number of set bit that is the cost to make it ZERO by subtraction.\\n\\n# Complexity\\n- Time complexity: O(2^17)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int i,int val,int n){\\n        if(i==n){\\n           int count=0;\\n           int x=val;\\n           while(x){\\n               if(x&1) count++;\\n               x=(x>>1);\\n           }\\n           return count;\\n        }\\n        int x=val+(1<<i);\\n        int x1=1+rec(i+1,x,n);\\n        int x2=rec(i+1,val,n);\\n        return min(x1,x2);\\n    }\\n    int minOperations(int n) {\\n        int m=log2(n)+1;\\n        return rec(0,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(int i,int val,int n){\\n        if(i==n){\\n           int count=0;\\n           int x=val;\\n           while(x){\\n               if(x&1) count++;\\n               x=(x>>1);\\n           }\\n           return count;\\n        }\\n        int x=val+(1<<i);\\n        int x1=1+rec(i+1,x,n);\\n        int x2=rec(i+1,val,n);\\n        return min(x1,x2);\\n    }\\n    int minOperations(int n) {\\n        int m=log2(n)+1;\\n        return rec(0,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639767,
                "title": "java-easy-100-solution-with-basic-math",
                "content": "# Intuition\\nBasic Math\\n\\n# Approach\\nFirst find the number which is divisible by 2^n and is closest to n\\nrepeat this until n becomes 0, and everytime increase the count;\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int cnt =0;\\n        while(n>0){\\n            double p = (double)(Math.log(n)/Math.log(2));\\n            int x = (int)Math.round(p);\\n            cnt++;\\n            n= Math.abs((int)Math.pow(2,x)-n);\\n        }\\n        return cnt;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int cnt =0;\\n        while(n>0){\\n            double p = (double)(Math.log(n)/Math.log(2));\\n            int x = (int)Math.round(p);\\n            cnt++;\\n            n= Math.abs((int)Math.pow(2,x)-n);\\n        }\\n        return cnt;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626844,
                "title": "c-bits-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int c = 0;\\n        while (n > 0) {\\n            if (!(n & 1)) {\\n                n >>= 1;\\n                continue;\\n            }\\n            ++c;\\n            n >>= 1;\\n            if (n & 1) {\\n                while (n & 1)\\n                    n >>= 1;\\n                n |= 1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        int c = 0;\\n        while (n > 0) {\\n            if (!(n & 1)) {\\n                n >>= 1;\\n                continue;\\n            }\\n            ++c;\\n            n >>= 1;\\n            if (n & 1) {\\n                while (n & 1)\\n                    n >>= 1;\\n                n |= 1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608882,
                "title": "c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (1 == __builtin_popcount(n))\\n            return 1;\\n        auto a = pow(2, (int)log2(n));\\n        auto b = pow(2, (int)log2(n) + 1);\\n        auto na = minOperations(n - a);\\n        auto nb = minOperations(b - n);\\n        return min(na, nb) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n        if (1 == __builtin_popcount(n))\\n            return 1;\\n        auto a = pow(2, (int)log2(n));\\n        auto b = pow(2, (int)log2(n) + 1);\\n        auto na = minOperations(n - a);\\n        auto nb = minOperations(b - n);\\n        return min(na, nb) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601157,
                "title": "python3-recursive-with-memoization-lru-cache",
                "content": "# Intuition\\nIf we could only subtract 2^k, then we can use greedy approach to find nearest power of 2 and keep subtracting till value becomes 0.\\nWhy does that greedy work. If a number is represented in its binary form, you can see that the minimum number of steps to make it 0 is by counting the number of 1s it have. For eg. 9 -> 1001 (2 steps)\\nCan you do faster than that, by induction you can prove that only way you can do faster is by eliminating 2 ones in single go, but no 2 powers of 2 combined can become a single power of 2. Hence greedy works for the case of only subtraction.\\n\\nHere we see that addition of 2^k is possible. One thing you can think of is you will not go beyond 1 extra bit if you have to decrease the value to 0 even after addition. So you can think of breaking down each step into two case trying to reach to next significant bit or removing the current significant bit.\\nIn case of 9 -> try to reach either 8 or 16\\n\\n# Approach\\nRecursively check for the minimum steps required to reach 2^k-1 or 2^k\\nReturn 1 if n == 2^k (easy check for that is n & n-1 == 0)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(logN)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        @functools.lru_cache(None)\\n        def minToReach(n):\\n            if n & (n-1) == 0:\\n                return 1\\n            st = 1\\n            while st * 2 < n:\\n                st *= 2\\n\\n            return 1 + min(minToReach(st * 2 - n), minToReach(n - st))\\n\\n        return minToReach(n)\\n            \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        @functools.lru_cache(None)\\n        def minToReach(n):\\n            if n & (n-1) == 0:\\n                return 1\\n            st = 1\\n            while st * 2 < n:\\n                st *= 2\\n\\n            return 1 + min(minToReach(st * 2 - n), minToReach(n - st))\\n\\n        return minToReach(n)\\n            \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573312,
                "title": "find-tiebreaking-scenario",
                "content": "# Approach\\nIf there is a 0 surrounded by at least three 1s on both sides, then invert that digit is not more expensive.\\n\\nThen count groups of 1s, for 1s of length more than 1, we need to spend one more operation to make it an isolated 1. \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(lg n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        ret = 0\\n        L = list(bin(n)[2:])\\n        \\n        for i in range(1, len(L)-1):\\n            if L[i-2:i+2] == [\\'1\\', \\'1\\', \\'0\\', \\'1\\'] or L[i-1:i+3] == [\\'1\\', \\'0\\', \\'1\\', \\'1\\']:\\n                L[i] = \\'1\\'\\n                ret += 1\\n                \\n        for s in \\'\\'.join(L).split(\\'0\\'):\\n            if len(s) == 1:\\n                ret += 1\\n            elif len(s) > 1:\\n                ret += 2\\n\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, n: int) -> int:\\n        ret = 0\\n        L = list(bin(n)[2:])\\n        \\n        for i in range(1, len(L)-1):\\n            if L[i-2:i+2] == [\\'1\\', \\'1\\', \\'0\\', \\'1\\'] or L[i-1:i+3] == [\\'1\\', \\'0\\', \\'1\\', \\'1\\']:\\n                L[i] = \\'1\\'\\n                ret += 1\\n                \\n        for s in \\'\\'.join(L).split(\\'0\\'):\\n            if len(s) == 1:\\n                ret += 1\\n            elif len(s) > 1:\\n                ret += 2\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530199,
                "title": "c-memoization-dp-easy-to-understand-backtrack",
                "content": "\\n# At every continuous ones just explore two options either it remove all and add 1 to answer or remove all one by one add no of ones to answer and adjust the \\'i\\'th bit appropriately.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51];\\n    int f(vector<int> &a,int b){\\n        if(b>=40) return 0;\\n        if(!a[b]) return f(a,b+1);\\n        if(dp[b]!=-1) return dp[b];\\n        int i=b;\\n        while(a[i]) i++;\\n        int p1=1,p2=i-b;\\n        a[i]=1;\\n        p1+=f(a,i);\\n        a[i]=0;\\n        p2+=f(a,i);\\n        return dp[b]=min(p1,p2);\\n    }\\n    int minOperations(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> a(50,0);\\n        int ans=0;\\n        for(int b=0;b<22;b++) if((1<<b)&n) a[b]=1;\\n        return f(a,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51];\\n    int f(vector<int> &a,int b){\\n        if(b>=40) return 0;\\n        if(!a[b]) return f(a,b+1);\\n        if(dp[b]!=-1) return dp[b];\\n        int i=b;\\n        while(a[i]) i++;\\n        int p1=1,p2=i-b;\\n        a[i]=1;\\n        p1+=f(a,i);\\n        a[i]=0;\\n        p2+=f(a,i);\\n        return dp[b]=min(p1,p2);\\n    }\\n    int minOperations(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> a(50,0);\\n        int ans=0;\\n        for(int b=0;b<22;b++) if((1<<b)&n) a[b]=1;\\n        return f(a,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523572,
                "title": "c-recursive-memoization-tabulation-bottom-up-dp",
                "content": "Just every time calculatte the nearest power of 2 value that is less than and greater than or equal to the value of n, caluclate the difference among the two and then go with the less difference one...\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int power(int x){\\n        int res=1;\\n        for(int i=0;i<x;i++){\\n            res*=2;\\n        }\\n        return res;\\n    }\\n    int ans(int n,vector<int> &dp){\\n        if(n==0) return 0;\\n\\n        if(dp[n]!=-1)return dp[n];\\n        int pt=log2(n);\\n        int mn=power(pt);\\n        int mx=power(pt+1);\\n\\n        int diff1=n-mn;\\n        int diff2=mx-n;\\n\\n        if(diff1>diff2){\\n            return dp[n]=1+ans(diff2,dp);\\n        }\\n        else{\\n            return dp[n]=1+ans(diff1,dp);\\n        }\\n    }\\n    int minOperations(int n) {\\n        vector<int> dp(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            int pt=log2(i);\\n            int mn=power(pt);\\n            int mx=power(pt+1);\\n\\n            int diff1=i-mn;\\n            int diff2=mx-i;\\n\\n            if(diff1>diff2){\\n                dp[i]=1+dp[diff2];\\n            }\\n            else{\\n                dp[i]=1+dp[diff1];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int power(int x){\\n        int res=1;\\n        for(int i=0;i<x;i++){\\n            res*=2;\\n        }\\n        return res;\\n    }\\n    int ans(int n,vector<int> &dp){\\n        if(n==0) return 0;\\n\\n        if(dp[n]!=-1)return dp[n];\\n        int pt=log2(n);\\n        int mn=power(pt);\\n        int mx=power(pt+1);\\n\\n        int diff1=n-mn;\\n        int diff2=mx-n;\\n\\n        if(diff1>diff2){\\n            return dp[n]=1+ans(diff2,dp);\\n        }\\n        else{\\n            return dp[n]=1+ans(diff1,dp);\\n        }\\n    }\\n    int minOperations(int n) {\\n        vector<int> dp(n+1,0);\\n        for(int i=1;i<=n;i++){\\n            int pt=log2(i);\\n            int mn=power(pt);\\n            int mx=power(pt+1);\\n\\n            int diff1=i-mn;\\n            int diff2=mx-i;\\n\\n            if(diff1>diff2){\\n                dp[i]=1+dp[diff2];\\n            }\\n            else{\\n                dp[i]=1+dp[diff1];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499413,
                "title": "neat-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) \\n    {\\n         if(n==1 || n==0 )\\n         return 1 ; \\n         int z = log2(n);\\n         if(pow(2,z)==n)//if number is multiple of 2 \\n         return 1; \\n         int x = log2(n); // finding both  just greater and smaller mulitple of 2 from n \\n         int y = log2(n) + 1 ; // \\n         x = pow(2,x);\\n         y = pow(2,y);\\n         return 1 + minOperations(min(n-x,y-n)); // changing the number to the min abs diffeerence\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) \\n    {\\n         if(n==1 || n==0 )\\n         return 1 ; \\n         int z = log2(n);\\n         if(pow(2,z)==n)//if number is multiple of 2 \\n         return 1; \\n         int x = log2(n); // finding both  just greater and smaller mulitple of 2 from n \\n         int y = log2(n) + 1 ; // \\n         x = pow(2,x);\\n         y = pow(2,y);\\n         return 1 + minOperations(min(n-x,y-n)); // changing the number to the min abs diffeerence\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494159,
                "title": "minimum-operations-to-reduce-an-integer-to-0",
                "content": "---------------- Easy C++ Solution -----------------------\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n    int ans = 0;\\n    while (n > 0){\\n      if ((n & 3) == 3) {\\n        ++n;\\n        ++ans;\\n      } else if ((n & 1) == 1) {\\n        --n;\\n        ++ans;\\n      } else {\\n        n >>= 1;\\n      }\\n    }\\n     return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n    int ans = 0;\\n    while (n > 0){\\n      if ((n & 3) == 3) {\\n        ++n;\\n        ++ans;\\n      } else if ((n & 1) == 1) {\\n        --n;\\n        ++ans;\\n      } else {\\n        n >>= 1;\\n      }\\n    }\\n     return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490534,
                "title": "c-nearest-power-of-2-simplest-ever-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n\\n        int ans = 0;\\n\\n        while(n > 0) {\\n            int cnt = 0;\\n            int small = INT_MAX;\\n            while(true) {\\n                int temp = abs(n - pow(2,cnt));\\n                if(temp < small) small = temp;\\n                else break;\\n                cnt++;\\n            }\\n            n = small;\\n            ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n\\n        int ans = 0;\\n\\n        while(n > 0) {\\n            int cnt = 0;\\n            int small = INT_MAX;\\n            while(true) {\\n                int temp = abs(n - pow(2,cnt));\\n                if(temp < small) small = temp;\\n                else break;\\n                cnt++;\\n            }\\n            n = small;\\n            ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1806309,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806390,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806347,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806841,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806327,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806420,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806998,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806616,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806415,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806316,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806309,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806390,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806347,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806841,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806327,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806420,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806998,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806616,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806415,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806316,
                "content": [
                    {
                        "username": "ShubhamJaiswal",
                        "content": "How can this be easy ??"
                    },
                    {
                        "username": "brinuke",
                        "content": "This is how:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/solutions/3207208/recursive-one-liner-without-library-calls-the-only-rigorous-proof/"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Easy my a$$"
                    },
                    {
                        "username": "CODEX47",
                        "content": "They played us."
                    },
                    {
                        "username": "aDDyy",
                        "content": "At last leetcode has changed this problem tag from easy to medium\\uD83D\\uDE02..lol"
                    },
                    {
                        "username": "giibbu",
                        "content": "If this is easy, then I mind as well quit programming."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "This is not an easy question, Do you agree it\\'s **Leetcode\\'s medium(easy)** Categories \\n\\nfirst thing came to my mind was Recursive approach and that time i was F**ked up"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@XavierWantMoreMoney](/XavierWantMoreMoney) my approach also worked but took too much time.  i am beginner in dp but here is what i came up, i guess its o(Log(n))\n```\npublic class Solution \n{\n    public int MinOperations(int n) \n    {\n        if (Math.Log2(n) % 1 == 0) return 1; // Math.Log2(n) % 1 == 0 will give if it is perfect power of two or not\n        return MinOperations(n, 0)  ; \n    }\n    public int MinOperations(int n,int j)\n    { \n        if (n == 0) return j;\n        if (Math.Log2(n) % 1 == 0) return ++j; \n        int max = 0, i = -1;\n        while (max < n) max = (int)Math.Pow(2, ++i); \n        \n        if(i-1>=0 && (n-(int)Math.Pow(2, i-1))<(max-n)) \n            return MinOperations(n - (int)Math.Pow(2, i - 1), ++j); \n        return MinOperations( max%n , ++j);\n    }\n}\n```"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "actually my solution IS recursion and it worked...\n\nWell, recursion + bookkeeping (or DP in fancier term)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "people screaming its not easy. Leetcode realized and marked it as medium \\uD83D\\uDC4C\\nNow its easy to accept our defeat \\uD83D\\uDE02"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "And me having randomly solved this right after the contest was over #cry #fml #why"
                    },
                    {
                        "username": "R_aghav",
                        "content": "Logical problem ,if you get it then only easily solve it."
                    },
                    {
                        "username": "mrping_11",
                        "content": "Any Intuition solvers? This should be medium problem"
                    },
                    {
                        "username": "Venva",
                        "content": "1. check the nearest powers of 2 around that number ( like 16 and 32 are around 26)\\n2. with the most nearest number do the following operations :\\n     2.1 subtract if the nearest power is less than number\\n    2.2 add if nearest power is greater than number and when adding make sure you add in powers of 2 \\n        2.2.1 add the nearest numbers (around the different) to 2.2\\n3. if the nearest numbers are equals exit the loops and return count"
                    }
                ]
            },
            {
                "id": 1806641,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1806554,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1951233,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1852907,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1810836,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1807636,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1807296,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1807287,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1807039,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            },
            {
                "id": 1806973,
                "content": [
                    {
                        "username": "pant_harshit007",
                        "content": "they tricked us\\nmid in form of easy looking...."
                    },
                    {
                        "username": "john91002004",
                        "content": "I\\'m a rookie. First time participate in weekly contest. I never expect I can solve this problem, but I solve it accidentally. So I think it\\'s an easy problem for real. "
                    },
                    {
                        "username": "himanshu_rai",
                        "content": "I have something but am unable to implement, \\nso take any number for ex:32\\nso the bin(32)=100111, we see there are three consecutives ones so shift it which  will make it : 101000 now there are no consecutive one so count the no of set bits which is 2 and in start we shifted so that will add 1 which will give result as 3.\\n\\nExample 2: 54 (110110), Step-1 shift if consecutive one which will make 111000, now again there are consecutive one so 1000000 by here we have our count as 2 and only one set bit hence result will be 3 (no of set bits + no of times consecutive shifts are made).  "
                    },
                    {
                        "username": "Adai_is",
                        "content": "ChatGPT fails to solve the given problem. It guesses a greedy approach, which\\ncame to my mind initially of subtracting the greatest power of 2 each time. Obviously, this greedy solution is not correct and fails even on the basic test cases."
                    },
                    {
                        "username": "brinuke",
                        "content": "***Follow-up:*** can you solve the problem using regular expressions, when the number `n` is given as a **binary** string of **arbitrary** length (e.g. `01010110111000110101`) ?"
                    },
                    {
                        "username": "zechengli",
                        "content": "My first initution for this question is by using bfs (either +, or -), but there is no limit how big the number could go in order to achieve the minimum operations? Is there any hint to contrain the limit? "
                    },
                    {
                        "username": "MdoingIt",
                        "content": "Can someone explain that why is it always optimal to reach the just greater or smaller power of 2??"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Even if it\\'s not easy as most of the people are saying, tagging it as easy gives a little confidence, like yeah it\\'s easy I will do it. XD"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Finally Leetcode changed the difficulty level to medium"
                    },
                    {
                        "username": "shyam_3017",
                        "content": "tricky one..."
                    }
                ]
            }
        ]
    }
]