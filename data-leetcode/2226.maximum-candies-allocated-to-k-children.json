[
    {
        "title": "Maximum Candies Allocated to K Children",
        "question_content": "You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.\nYou are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.\nReturn the maximum number of candies each child can get.\n&nbsp;\nExample 1:\n\nInput: candies = [5,8,6], k = 3\nOutput: 5\nExplanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n\nExample 2:\n\nInput: candies = [2,5], k = 11\nOutput: 0\nExplanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= candies.length <= 105\n\t1 <= candies[i] <= 107\n\t1 <= k <= 1012",
        "solutions": [
            {
                "id": 1908888,
                "title": "java-c-python-binary-search-with-explanation",
                "content": "# **Intuition**\\nBinary search\\n<br>\\n\\n# **Explanation**\\nAssume we want give each child `m` candies, for each pile of `candies[i]`,\\nwe can divide out at most `candies[i] / m` sub piles with each pile `m` candies.\\n\\nWe can sum up all the sub piles we can divide out, then compare with the `k` children.\\n\\nIf `k > sum`, \\nwe don\\'t allocate to every child, \\nsince the pile of `m` candidies it too big,\\nso we assign `right = m - 1`.\\n\\nIf `k <= sum`, \\nwe are able to allocate to every child, \\nsince the pile of `m` candidies is small enough\\nso we assign `left = m`.\\n\\nWe repeatly do this until `left == right`, and that\\'s the maximum number of candies each child can get.\\n<br>\\n\\n# **Tips**\\nTip1.  `left < right` Vs `left <= right`\\n\\nCheck all my solution, I keep using `left < right`.\\nThe easy but important approach: \\nfollow and upvote my codes,\\ntry to do the same.\\nyou\\'ll find all binary search is similar,\\nnever bother thinking it anymore.\\n\\nTip2. `mid = (left + right + 1) / 2` Vs `mid = (left + right) / 2`\\n\\n`mid = (left + right) / 2` to find **first** element valid\\n`mid = (left + right + 1) / 2 `to find **last** element valid\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog10000000)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumCandies(int[] A, long k) {\\n        int left = 0, right = 10_000_000;\\n        while (left < right) {\\n            long sum = 0;\\n            int mid = (left + right + 1) / 2;\\n            for (int a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = 1e7;\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 2226. [Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908888/JavaC%2B%2BPython-Binary-Search-with-Explanation)\\n- 1802. [Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119801/Python-Binary-Search)\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximumCandies(int[] A, long k) {\\n        int left = 0, right = 10_000_000;\\n        while (left < right) {\\n            long sum = 0;\\n            int mid = (left + right + 1) / 2;\\n            for (int a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = 1e7;\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908695,
                "title": "binary-search",
                "content": "Say we decide to allocate `m` candies. We can check if all `k` kids can get `m` candies in O(n).\\n\\nTherefore, we can binary-search for the maximum value `m`. The overall runtime complexity will be O(n * log m), where `m` is maximum number of candies in a single pile (10000000).\\n\\nThe fact that we can split piles could be confusing. But it simply means that we can distribute `m` candies to ` candies[i] / m` children from pile `i`.\\n\\n**C++**\\n```cpp    \\nint maximumCandies(vector<int>& candies, long long k) {\\n    int l = 0, r = 10000000;\\n    while(l < r) {\\n        long long m = (l + r + 1) / 2, cnt = 0;\\n        for (int i = 0; i < candies.size() && cnt < k; ++i)\\n            cnt += candies[i] / m;\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint maximumCandies(vector<int>& candies, long long k) {\\n    int l = 0, r = 10000000;\\n    while(l < r) {\\n        long long m = (l + r + 1) / 2, cnt = 0;\\n        for (int i = 0; i < candies.size() && cnt < k; ++i)\\n            cnt += candies[i] / m;\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908738,
                "title": "c-easy-solution-with-explanation",
                "content": "Lets see about the brute force solution.\\n\\nWe can check for candies=1,2 and so,on until we find an answer.\\n\\nCan\\'t we do something better,instead of linear search ?.\\n\\nYes, we can do **binary search.**\\n \\nIf we can divide the candies into piles containing x number of candies all the numbers below x,\\nwill also be satisfied.\\n\\nIn this question we have to find the maximum number of candies.\\n\\nLets see the lowest value is 1 and highest value as the maximum element in candies.\\n\\nNow we will find the mid, and we will check weather we can divide mid amount of candies into piles \\nsuch that they will be sufficient for k children.\\n\\nFinally we return the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    bool solve(vector<int>& v, ll mid, ll k){\\n        int n = v.size();\\n        ll cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt += (v[i]/mid);\\n            if(cnt>=k) return true;\\n        }\\n        return false;\\n    }\\n    \\n    // v is the candies vector.\\n    int maximumCandies(vector<int>& v, long long k) {\\n        int n = v.size();\\n\\t\\tint mx = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tmx = max(mx,v[i]);\\n        }\\n        \\n        ll low = 1, high = mx;\\n        ll ans = 0;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(solve(v,mid,k)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity= O(nlogp)   // p is the maximum candy.\\nSpace Complexity- O(1);**\\n\\n\\nUpvote if it helps!!\\nThank you!!\\n\\nMore binary search problems:\\n\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\nhttps://leetcode.com/problems/find-the-duplicate-number/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/\\nhttps://leetcode.com/problems/most-beautiful-item-for-each-query/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\nhttps://leetcode.com/problems/heaters/\\nhttps://leetcode.com/problems/minimum-absolute-sum-difference/\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    bool solve(vector<int>& v, ll mid, ll k){\\n        int n = v.size();\\n        ll cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt += (v[i]/mid);\\n            if(cnt>=k) return true;\\n        }\\n        return false;\\n    }\\n    \\n    // v is the candies vector.\\n    int maximumCandies(vector<int>& v, long long k) {\\n        int n = v.size();\\n\\t\\tint mx = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tmx = max(mx,v[i]);\\n        }\\n        \\n        ll low = 1, high = mx;\\n        ll ans = 0;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(solve(v,mid,k)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908797,
                "title": "binary-search-solution-with-explanation-java-o-n-log-max-candies",
                "content": "Simple Binary Search Solution | Java | O(n log(max(candies)))\\n\\n**Idea**:\\nBrute force :Start with 1 candy and see if we can allocate. If yes, then check for 2 candy. \\nOptimization: Instead of checking every candy at a time, why can\\'t we directly check for a number to see if we can allocate that many candy. This way we reduce our search space. Best way to do it is binary search.\\n\\n**Approach**:\\nFirst go through each pile and store the maximum of candy of that pile.\\nNow your seach space will be `[0 - max]`. Now, we will pick `mid` from that and check if we can allocate that many candies to k children. If yes, update `lo`, if not update `hi`.\\n0 is trickey number because you can always allocate that many candies. So, at the end I do a check one more time on lo to see if I can allocate that candies. otherwise return lo-1.\\n\\n**TimeComplexity**:\\n`O(n)` to check if you can allocate x candies to k people\\ncalling above function `log(max(candies))`.\\nSo, overall time complexity `O(n log(max(candies)))`\\n\\n**Upvote if it helps. Thanks :)**\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            } else {\\n                hi = mid ;\\n            }\\n        }  \\n        return canAllocate(candies, k, lo) ? lo : lo-1;\\n    }\\n    \\n    public boolean canAllocate(int[] candies, long k, int allow) {\\n        if(allow == 0)\\n            return true;\\n        long total = 0;\\n        for(int candy : candies) {\\n            total += candy / allow;\\n            if(total >= k)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            } else {\\n                hi = mid ;\\n            }\\n        }  \\n        return canAllocate(candies, k, lo) ? lo : lo-1;\\n    }\\n    \\n    public boolean canAllocate(int[] candies, long k, int allow) {\\n        if(allow == 0)\\n            return true;\\n        long total = 0;\\n        for(int candy : candies) {\\n            total += candy / allow;\\n            if(total >= k)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908862,
                "title": "binary-search-intutive-intution-explanation",
                "content": "Intution : We Know we had  to distribute  maximum candies , whenever face Problem in which we  have   to distribute  and finding the maximum or minium, See the Time Complexity if Time Complexity isaround 10^4, and your answer require optimal ways then think of dp solution, if Time Complexity is around 10^5 either it can be done by  sorting with greedy or binary search on ans. Now with this it was clear it is binary search on ans problem. So Just checked how can I distribute \\n1. Search space can be 1 to sum(candies), Why\\n Becuase you have to give them at least one so low = 1.\\n 2. Just find the mid and check, if distributing mid candies it is possible to distribute if yes, then reduce your search space so that more optimal ans can be find.\\n\\n**Please UPVOTE Guys , If it helps, That motivates**\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        return split>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        \\n        long long start = 1, end = sum;\\n        long long ans = 0;\\n        \\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(check(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nTime Complexity : nlog(m}\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908775,
                "title": "100-faster-c-python-java-binary-search-with-logic",
                "content": "![image](https://assets.leetcode.com/users/images/82a7e416-2997-4676-929e-712206ab4b1a_1648961313.8131979.png)\\n\\n**Idea**\\n\\n* start can be taken as 1 , highest we can distribute equally is average.\\n\\n* Use Binary Search and try to distribute the candies equal to mid, if possible try to maximize it by moving on right, else if not possible try it by decreasing the value by moving on left\\n* **TC: O(NlogN) SC: O(1)**\\n\\n```\\ndef canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        long long start = 1, end = sum/k;\\n        long long ans = 0;\\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean canSplit(int[] candies, long k, long mid) {\\n        long split = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            sum += candies[i];\\n        }\\n        long start = 1, end = sum;\\n        long ans = 0;\\n        while(start <= end) {\\n            long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\ndef canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\n```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        long long start = 1, end = sum/k;\\n        long long ans = 0;\\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canSplit(int[] candies, long k, long mid) {\\n        long split = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            sum += candies[i];\\n        }\\n        long start = 1, end = sum;\\n        long ans = 0;\\n        while(start <= end) {\\n            long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908707,
                "title": "binary-search-explained",
                "content": "**Explanation :**\\nBinary search between **[1, max(candies)]** to find the result.\\n**if we can allocate currCandy candies to k children. then update start, if not update end.**\\nSimilar Question : [https://leetcode.com/problems/koko-eating-bananas/]\\n**Time O(Nlog(MaxC))\\nSpace O(1)**\\n    \\n    \\n```\\nclass Solution {\\npublic:\\n    \\n    bool doit(int currCandy, vector<int>& candies, long long k) {\\n       \\n\\t\\t// c candies can be divided into (c/currCandy) number of piles of size currCandy.\\n        for (auto& c : candies)   k -= (c/currCandy);\\n        return k <= 0;\\n    }\\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int start(1), end(INT_MIN);\\n        for (auto& candy : candies) end = max(end, candy);\\n        \\n        while (start <= end) {\\n            int currCandy = start+(end-start)/2;\\n\\t\\t\\t// If we can divide the candies into piles containing currCandy number of candies all the numbers below currCandy can be distributed too.\\n            if (doit(currCandy, candies, k))    start = currCandy+1;\\n            else    end = currCandy-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool doit(int currCandy, vector<int>& candies, long long k) {\\n       \\n\\t\\t// c candies can be divided into (c/currCandy) number of piles of size currCandy.\\n        for (auto& c : candies)   k -= (c/currCandy);\\n        return k <= 0;\\n    }\\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int start(1), end(INT_MIN);\\n        for (auto& candy : candies) end = max(end, candy);\\n        \\n        while (start <= end) {\\n            int currCandy = start+(end-start)/2;\\n\\t\\t\\t// If we can divide the candies into piles containing currCandy number of candies all the numbers below currCandy can be distributed too.\\n            if (doit(currCandy, candies, k))    start = currCandy+1;\\n            else    end = currCandy-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266489,
                "title": "easy-to-understand-optimized-binary-search-approach-beginner-friendly-detail-explained",
                "content": "\\n# Approach\\n1. minimum size of candy can be 1,less than 1 can not be possible.\\n2. maximum size of candy can be maximum element of given candies array,greater than max element can not be possible.\\n3. we chose candy size by bianry search, so that we can choose in optimised time.\\n4. function func give information about that, candies array\\'s element can be divided into mid size.\\n5. In function func,\\'cnt\\' count the nummber of \\'mid\\' size candy can be divided from candies array elements.\\n6. when count of mid size candy greater than our need(k), then we return true, *i.e.*  our answer should be mid but greater than mid can be possible.\\n# Complexity\\n- Time complexity:$$O(N*logN)$$\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool func(vector<int>&pile,long long h,int mid)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<pile.size();i++)\\n        {\\n            cnt += pile[i]/mid ;\\n            if(cnt>h)\\n            return true;\\n        }\\n        return cnt>=h;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int s = 1,e = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int mid = s+ (e-s)/2;\\n            if(func(candies,k,mid))\\n            {\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............**\\n![upvote.png](https://assets.leetcode.com/users/images/2fccf5b3-2212-4efd-afe0-0a5ca0b80d68_1678151551.9504004.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(vector<int>&pile,long long h,int mid)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<pile.size();i++)\\n        {\\n            cnt += pile[i]/mid ;\\n            if(cnt>h)\\n            return true;\\n        }\\n        return cnt>=h;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int s = 1,e = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int mid = s+ (e-s)/2;\\n            if(func(candies,k,mid))\\n            {\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909217,
                "title": "c-solution-100-faster",
                "content": "\"\"\"\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll left=1,right=*max_element(candies.begin(),candies.end());\\n        ll size=candies.size();\\n        ll maxi=0;\\n        while(left<=right){\\n            ll mid=left+(right-left)/2;\\n            ll temp=0;\\n            for(int i=0;i<size;i++){\\n                temp+=candies[i]/mid;\\n            }\\n            if(temp>=k){\\n                maxi=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\"\"\"\\n\\nPlease Upvote if you find it Helpful \\uD83D\\uDE42.",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll left=1,right=*max_element(candies.begin(),candies.end());\\n        ll size=candies.size();\\n        ll maxi=0;\\n        while(left<=right){\\n            ll mid=left+(right-left)/2;\\n            ll temp=0;\\n            for(int i=0;i<size;i++){\\n                temp+=candies[i]/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909039,
                "title": "c-binary-search-on-answer-explained-o-nlogn",
                "content": "**CONCEPT**\\n* In these type of question first we have to find search space which is the possible set of answers which this question can have. Like in this case minimum answer can be zero and maximum can be maximum of the candies not more than that. \\n* Simply apply binary search on this range [0,max] and if mid is possible answer than we will try to increase this answer by reducing our search space to [mid+1,max] else we will try to find answer in [0,mid].\\n* isPossible function tells whether is it possible to divide the candies or not. So it is implemented greedily. So i have count the maximum number of children i can distribute candies to and if it is greater than equal to k than it is possible to divide else not.\\n* Time:O(NlogN) and Space:O(1\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, long long k, long long mid){\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                cnt+=(nums[i]/mid);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(),candies.end());\\n        int n=candies.size();\\n        long long sum=0;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n            mx=max(mx,candies[i]);\\n            \\n        }\\n        \\n        long long l=1,r=mx;\\n        int res=0;\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            if(isPossible(candies,k,mid)){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, long long k, long long mid){\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                cnt+=(nums[i]/mid);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(),candies.end());\\n        int n=candies.size();\\n        long long sum=0;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n            mx=max(mx,candies[i]);\\n            \\n        }\\n        \\n        long long l=1,r=mx;\\n        int res=0;\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            if(isPossible(candies,k,mid)){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908820,
                "title": "c-binary-search",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Binary Answer\\n\\nBinary search in range `L = 1, R = max(A)`.\\n\\nFor a given `M = (L + R) / 2`, we test if we can give `M` candies to each child, which can be done by traversing the array once, taking `O(N)` time. \\n\\nIf possible/valid, we make `L = M + 1`; otherwise, we make `R = M - 1`.\\n\\nIn the end, since we are looking for the greatest valid number, we return `R`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/maximum-candies-allocated-to-k-children/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(sum(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        long L = 1, R = *max_element(begin(A), end(A)), N = A.size();\\n        auto valid = [&](long m) {\\n            long cnt = 0;\\n            for (int n : A) {\\n                cnt += n / m;\\n                if (cnt >= k) return true;\\n            }\\n            return false;\\n        };\\n        while (L <= R) {\\n            long M = L + (R - L) / 2;\\n            if (valid(M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/maximum-candies-allocated-to-k-children/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(sum(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        long L = 1, R = *max_element(begin(A), end(A)), N = A.size();\\n        auto valid = [&](long m) {\\n            long cnt = 0;\\n            for (int n : A) {\\n                cnt += n / m;\\n                if (cnt >= k) return true;\\n            }\\n            return false;\\n        };\\n        while (L <= R) {\\n            long M = L + (R - L) / 2;\\n            if (valid(M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909387,
                "title": "c-accepted-solution-binary-search-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long sum=0;\\n        \\n        int n=candies.size();\\n        \\n        //calculate sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)candies[i];\\n        }\\n        \\n        \\n        // if sum<k then we are not able to give a single one candy\\n        if(sum<k) return 0;\\n        \\n        \\n        long long h=sum/k;  // max possible ans cant exceed sum/k\\n        long long l=1;      // min possible ans will be 1\\n        long long res=1;\\n        \\n        \\n        //next part is just binary search\\n        while(h>=l)\\n        {\\n            long long m=(h+l)/2;\\n            long long count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=candies[i]/m;\\n            }\\n            \\n            if(count>=k)\\n            {\\n                res=max(res,m);\\n                l=m+1;\\n            }\\n            else\\n            {\\n                h=m-1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```\\n**upvote**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long sum=0;\\n        \\n        int n=candies.size();\\n        \\n        //calculate sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)candies[i];\\n        }\\n        \\n        \\n        // if sum<k then we are not able to give a single one candy\\n        if(sum<k) return 0;\\n        \\n        \\n        long long h=sum/k;  // max possible ans cant exceed sum/k\\n        long long l=1;      // min possible ans will be 1\\n        long long res=1;\\n        \\n        \\n        //next part is just binary search\\n        while(h>=l)\\n        {\\n            long long m=(h+l)/2;\\n            long long count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=candies[i]/m;\\n            }\\n            \\n            if(count>=k)\\n            {\\n                res=max(res,m);\\n                l=m+1;\\n            }\\n            else\\n            {\\n                h=m-1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361579,
                "title": "c-binary-search-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat comes to my mind is to check what number of candies(search space) is satisfying children.\\nSo by this intuition we can find the search space. \\n\\nMinimum candy child can  get will be 1:\\nExample: [1,2,3,4] and k=5\\nTotal 5 children and all of them should have same amount of candies\\nso for example let candy=2 now check whether we can get 2 candies from all the piles or not\\n1st pile:- candies[0]=1 and we can\\'t get 2 candies -> count=0\\n2nd pile:- candies[1]=2 we can get 2 candies -> count=1\\n3rd pile:- candies[2]=3 we can get 2 candies -> count=2\\n4th pile:- candies[3]=4 we can get total pair of 2 candy -> count=4\\n\\nAt end we can only satisfy 4 children but we need to satisfy 5 children(k=5)\\nso minimum value child can get will be 1 candy.\\n\\nMaximum candy child can get will be maximum element in candies:\\nExample candies=[1,2,3,4] and k=1\\nHere we need to satisy 1 children and it should have maximum candy we can just allocate all candy to single children \\nso maximum value of candy child can get will be 4.\\n\\nWe got our search space here\\nstart=1 and end=max_element\\n\\nNow approach is to apply binary search and check whether particular number of candies satisfies all the children or not\\nExample: candies=[5,8,6], k = 3\\nsuppose we reached mid=5 now count the number of 5 candies from each pile:\\n```\\n bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n        if(count>=k) return true;\\n        return false;\\n    }\\n```\\nWe are dividing each piles with mid value and checking how many number of 5 candies we can get.\\nFor [5,8,6]->\\n    Each child gets 1 pile of total 5 candies\\n    5/5=1 -> For first child\\n    8/5=1 -> For second child\\n    6/5=1 -> For third child\\n\\nWe can distribute max 5 candies to 3 children\\nIf count is greater or equal to children then we can distribute equal candies to all children .\\n\\n# Complexity\\n- Time complexity:\\n $$O(n(log(end)))$$ where n=candies.size() and end=max_element\\n\\n- Space complexity\\n    $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n\\n        if(count>=k) return true;\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start=1;\\n        int end=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isSatisfying(candies,mid,k)){\\n                //we need to maximize search space so storing answer and finding anther maxi\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\n bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n        if(count>=k) return true;\\n        return false;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n\\n        if(count>=k) return true;\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start=1;\\n        int end=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isSatisfying(candies,mid,k)){\\n                //we need to maximize search space so storing answer and finding anther maxi\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909559,
                "title": "easy-tricky-binary-search-approach-explained-along-with-code",
                "content": "# This problem is a kind of Upper Bond problem of Binary search.\\nHere we just simply have to make an binary search call by setting the min and max variables which is the range in which we have to be get the correct answer. Since we can give as minimum as 0 candies to k children because there are not many candies for everyone so our min = 0. and the maximum candies which we can give is the maximum pile of candie which is available with us because there is no way we can distribute more candies than what we have available.\\nTo Calculate mid we will use this formula **mid = min + (max-min)/2** this will give us the exact possible value of mid everytime.\\nAnd then we need a condtion to verify if the current **mid** is a right input so for that we have a condition that the number of candie pile can be divided such that all the **k** childeren should get same number of candy so we will make a boolean function to check the exact same thing which we  discussed.\\n\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int candie : candies){\\n            max = Math.max(candie,max);\\n        }\\n        \\n        int answer = 0;\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            if(checkIfTrue(candies,k,mid)){\\n                answer = mid;\\n                min = mid+1;\\n            }else{\\n                max = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public boolean checkIfTrue(int[] candies,long k,int divid){\\n        long cnt = 0;\\n        for(int candie : candies){\\n            cnt += (long) Math.floor(candie/divid);\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int candie : candies){\\n            max = Math.max(candie,max);\\n        }\\n        \\n        int answer = 0;\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            if(checkIfTrue(candies,k,mid)){\\n                answer = mid;\\n                min = mid+1;\\n            }else{\\n                max = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public boolean checkIfTrue(int[] candies,long k,int divid){\\n        long cnt = 0;\\n        for(int candie : candies){\\n            cnt += (long) Math.floor(candie/divid);\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182046,
                "title": "best-solution-in-c-binarysearch-on-answer",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool occurrences(int x,vector<int>& candies,long k){\\n        long ans=0;\\n        for(auto it:candies){\\n            ans+=it/x;\\n            if(ans>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int size=candies.size(),ans=-1;\\n        long sum=0;\\n        for(auto it:candies)\\n            sum+=it;\\n        if(sum<k)\\n            return 0;\\n        int ll=1,ul=sum/k,mid;\\n        while(ll<=ul){\\n            mid= (ll+ul) >> 1;\\n            if(occurrences(mid,candies,k)){\\n                ans=mid;\\n                ll=mid+1;\\n            }\\n            else\\n                ul=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool occurrences(int x,vector<int>& candies,long k){\\n        long ans=0;\\n        for(auto it:candies){\\n            ans+=it/x;\\n            if(ans>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int size=candies.size(),ans=-1;\\n        long sum=0;\\n        for(auto it:candies)\\n            sum+=it;\\n        if(sum<k)\\n            return 0;\\n        int ll=1,ul=sum/k,mid;\\n        while(ll<=ul){\\n            mid= (ll+ul) >> 1;\\n            if(occurrences(mid,candies,k)){\\n                ans=mid;\\n                ll=mid+1;\\n            }\\n            else\\n                ul=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958952,
                "title": "concise-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &c, long long k) {\\n        long long cnt = 0;\\n        for(int i : c) cnt += i / x;\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int s = 1, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, candies, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &c, long long k) {\\n        long long cnt = 0;\\n        for(int i : c) cnt += i / x;\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int s = 1, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, candies, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434695,
                "title": "java-solution-using-binary-search",
                "content": "```\\nprivate boolean isPossible(int[] candies,int max,long k){\\n        long sum = 0;\\n        for(int i = 0; i<candies.length;i++){\\n            sum += (candies[i]/max);\\n        }\\n        if(sum>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int s = 1;\\n        int e = 0;\\n        for(int i = 0; i< candies.length;i++){\\n            e = Math.max(e,candies[i]);                  // ans can\\'t be more than the height number in the array so take end, the max candie from array.\\n        }\\n        int ans = 0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isPossible(candies,mid,k)){       // if posible to distribute candies with mid then store ans and increase start to mid + 1, Becoz we need maximum possible ans according to question.\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nprivate boolean isPossible(int[] candies,int max,long k){\\n        long sum = 0;\\n        for(int i = 0; i<candies.length;i++){\\n            sum += (candies[i]/max);\\n        }\\n        if(sum>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int s = 1;\\n        int e = 0;\\n        for(int i = 0; i< candies.length;i++){\\n            e = Math.max(e,candies[i]);                  // ans can\\'t be more than the height number in the array so take end, the max candie from array.\\n        }\\n        int ans = 0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isPossible(candies,mid,k)){       // if posible to distribute candies with mid then store ans and increase start to mid + 1, Becoz we need maximum possible ans according to question.\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975986,
                "title": "python-easy-to-understand-50-faster",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    the problem can be tackled using binary search \\n    max_candies that can be allocated to children = max(candies)\\n    min_candies that can be allocated to children = 1\\n    \\n    we will apply binary search on finding the optimal values of candies that can be\\n    distributed to children. \\n    \"\"\"\\n    def check_fulfilment(self, candies, elem, k):\\n        count = 0\\n        for candy in candies:\\n            count+= candy // elem\\n        if count >= k:\\n            return True\\n        return False\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        low = 1\\n        high = max(candies)\\n        if sum(candies) < k:\\n            return 0\\n        while low <= high:\\n            mid = (low+high) // 2\\n            # check if I can fulfil that order\\n            status = self.check_fulfilment(candies, mid, k)\\n            if status:\\n                low = mid+1\\n            else:         \\n                high = mid-1\\n        # low is the maximum number of candies that can be  distributed\\n        return high\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    the problem can be tackled using binary search \\n    max_candies that can be allocated to children = max(candies)\\n    min_candies that can be allocated to children = 1\\n    \\n    we will apply binary search on finding the optimal values of candies that can be\\n    distributed to children. \\n    \"\"\"\\n    def check_fulfilment(self, candies, elem, k):\\n        count = 0\\n        for candy in candies:\\n            count+= candy // elem\\n        if count >= k:\\n            return True\\n        return False\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        low = 1\\n        high = max(candies)\\n        if sum(candies) < k:\\n            return 0\\n        while low <= high:\\n            mid = (low+high) // 2\\n            # check if I can fulfil that order\\n            status = self.check_fulfilment(candies, mid, k)\\n            if status:\\n                low = mid+1\\n            else:         \\n                high = mid-1\\n        # low is the maximum number of candies that can be  distributed\\n        return high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960155,
                "title": "c-discrete-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(long val,vector<int>&candies,long k){\\n        long sum = 0;\\n        for(auto it : candies){\\n            sum += (it/val);\\n        }\\n        return sum >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long start = 1, end = 1e9;\\n        while(start < end){\\n            long mid = (start + end) / 2;\\n            if(!check(mid,candies,k)){\\n                end = mid;\\n            }\\n            else start = mid+1;\\n        }\\n        return start-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long val,vector<int>&candies,long k){\\n        long sum = 0;\\n        for(auto it : candies){\\n            sum += (it/val);\\n        }\\n        return sum >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long start = 1, end = 1e9;\\n        while(start < end){\\n            long mid = (start + end) / 2;\\n            if(!check(mid,candies,k)){\\n                end = mid;\\n            }\\n            else start = mid+1;\\n        }\\n        return start-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912213,
                "title": "easy-to-understand-python-solution-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies, k):\\n        n = len(candies)\\n        left = 1  # the least number of candy in each stack we can give to each student is one\\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \\n               # If we don\\'t have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\\n\\n        while left <= right:  # binary search\\n            numberOfPiles = 0\\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\\n\\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\\n\\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \\n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\\n            else: \\n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies, k):\\n        n = len(candies)\\n        left = 1  # the least number of candy in each stack we can give to each student is one\\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \\n               # If we don\\'t have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\\n\\n        while left <= right:  # binary search\\n            numberOfPiles = 0\\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\\n\\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\\n\\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \\n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\\n            else: \\n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911684,
                "title": "1-liner-python-ruby",
                "content": "Binary-search the smallest allocation `a` that\\'s too large, the answer is 1 lower. Ruby still excels at this, though Python improved now that it supports a `key`.\\n\\nRuby:\\n```\\ndef maximum_candies(candies, k)\\n  (1..10**8).bsearch { |a| candies.sum { |c| c / a } < k } - 1\\nend\\n```\\nPython:\\n\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        return bisect_left(range(1, 10**8), True, key=lambda a: sum(c // a for c in candies) < k)\\n",
                "solutionTags": [
                    "Python",
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximum_candies(candies, k)\\n  (1..10**8).bsearch { |a| candies.sum { |c| c / a } < k } - 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1910012,
                "title": "c-o-n-solution-with-explanation-binary-search",
                "content": "**Code:**\\n**TC: O(N), SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& candies, int mid, long long k)\\n    {\\n        //it contains piles of candies that tells whether we can distribute or not assign to children equally \\n        long count=0;\\n        for(auto it:candies)\\n        {\\n            count += it/mid;\\n        \\n            //whenever count is greater than or equal to k it tells we can distribute mid to k children and return true;\\n            if(count>=k) return true;\\n        }\\n        //when we can\\'t distribute mid piles to k children, we return false;\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        //initialize two pointers, 1 for minimum no. of candy, 1 for maximum no. of candy\\n        int min_candy = 1;\\n        int max_candy = *max_element(begin(candies), end(candies)); //we can also use for(auto it:candies) max_candy = max(max_candy, it)\\n        \\n        //use binary search for finding candies that can get by each child\\n        while(min_candy<=max_candy)\\n        {\\n            //find mid value\\n            long mid = (min_candy+max_candy)>>1;\\n            \\n            //if we can distribute mid piles of candies to k children successfully\\n            //we check for next greater candies\\n            if(isPossible(candies, mid, k))\\n            {\\n                min_candy = mid+1;\\n            }\\n            \\n            //if we can\\'t distribute mid piles of candies to k children\\n            //we check for lesser candies\\n            else\\n            {\\n                max_candy = mid-1;\\n                \\n            }\\n        }\\n        \\n        //return maxi_candies that can assign to each child\\n        return max_candy;\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& candies, int mid, long long k)\\n    {\\n        //it contains piles of candies that tells whether we can distribute or not assign to children equally \\n        long count=0;\\n        for(auto it:candies)\\n        {\\n            count += it/mid;\\n        \\n            //whenever count is greater than or equal to k it tells we can distribute mid to k children and return true;\\n            if(count>=k) return true;\\n        }\\n        //when we can\\'t distribute mid piles to k children, we return false;\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        //initialize two pointers, 1 for minimum no. of candy, 1 for maximum no. of candy\\n        int min_candy = 1;\\n        int max_candy = *max_element(begin(candies), end(candies)); //we can also use for(auto it:candies) max_candy = max(max_candy, it)\\n        \\n        //use binary search for finding candies that can get by each child\\n        while(min_candy<=max_candy)\\n        {\\n            //find mid value\\n            long mid = (min_candy+max_candy)>>1;\\n            \\n            //if we can distribute mid piles of candies to k children successfully\\n            //we check for next greater candies\\n            if(isPossible(candies, mid, k))\\n            {\\n                min_candy = mid+1;\\n            }\\n            \\n            //if we can\\'t distribute mid piles of candies to k children\\n            //we check for lesser candies\\n            else\\n            {\\n                max_candy = mid-1;\\n                \\n            }\\n        }\\n        \\n        //return maxi_candies that can assign to each child\\n        return max_candy;\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909538,
                "title": "easy-understandable-java-accepted",
                "content": "```\\nclass Solution {\\n    public static int maximumCandies(int[] arr, long k) {\\n\\t\\tArrays.sort(arr);\\n\\t\\tint low = 1;\\n\\t\\tint right = arr[arr.length - 1];\\n\\t\\twhile (low <= right) {\\n\\t\\t\\tint mid = (right - low) / 2 + low;\\n\\t\\t\\tif (helper(arr, k, mid)) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn right;\\n\\t}\\n\\n\\tpublic static boolean helper(int[] arr, long k, int mid) {\\n\\t\\tlong curr = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0 && curr < k; i--) {\\n\\t\\t\\tcurr += arr[i] / mid;\\n\\t\\t}\\n\\t\\treturn curr >= k;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumCandies(int[] arr, long k) {\\n\\t\\tArrays.sort(arr);\\n\\t\\tint low = 1;\\n\\t\\tint right = arr[arr.length - 1];\\n\\t\\twhile (low <= right) {\\n\\t\\t\\tint mid = (right - low) / 2 + low;\\n\\t\\t\\tif (helper(arr, k, mid)) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn right;\\n\\t}\\n\\n\\tpublic static boolean helper(int[] arr, long k, int mid) {\\n\\t\\tlong curr = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0 && curr < k; i--) {\\n\\t\\t\\tcurr += arr[i] / mid;\\n\\t\\t}\\n\\t\\treturn curr >= k;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909171,
                "title": "intuition-behind-binary-search-on-answers",
                "content": "<br>\\n\\n`When there are multiple answers that are valid but we need to find the maximum possible valid answer or minimum possible valid answer then we can use binary search on answers.`\\n\\n**How does it work ?**\\n\\nin this problem we know that minimum number of candies that we can allocate is 0 and maximum is max(candies), so in all such problems we need to find the **minimum possible answer** and **maximum possible answer** and binary search between them to find **maximum / minimum valid answer** in logarithmic time.\\n\\nAnd binary search on answers can be used only in those problems in which **we can validate whether the current answer in valid or not**. In this problem we can do that by checking if we can allocate x number of candies among k children by dividing some piles, so we can do binary search here.\\n\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int left = 1, ans = 0;\\n        int right = *max_element(candies.begin(), candies.end());\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(canAllocate(candies, k, mid)) {\\n                left = mid + 1;\\n                ans = mid;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\nprivate:\\n    bool canAllocate(vector<int>& candies, long long k, int candy) {\\n        \\n        long long total = 0;\\n        \\n        for(int c: candies) {\\n            total += c / candy;\\n            if(total >= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n<br>\\n\\n**Time complexity: O(n) * log(max(candies))\\nSpace complexity: O(1)**\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int left = 1, ans = 0;\\n        int right = *max_element(candies.begin(), candies.end());\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(canAllocate(candies, k, mid)) {\\n                left = mid + 1;\\n                ans = mid;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\nprivate:\\n    bool canAllocate(vector<int>& candies, long long k, int candy) {\\n        \\n        long long total = 0;\\n        \\n        for(int c: candies) {\\n            total += c / candy;\\n            if(total >= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909087,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,h=0;\\n        for(int& t:candies)\\n            h+=t;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long val=0;\\n            for(auto t:candies)\\n                val+=(t/mid);\\n            if(val>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,h=0;\\n        for(int& t:candies)\\n            h+=t;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long val=0;\\n            for(auto t:candies)\\n                val+=(t/mid);\\n            if(val>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908890,
                "title": "javascript-2226-maximum-candies-allocated-to-k-children",
                "content": "\\n**Weekly Contest 287**\\n\\n- Q1 answer\\n  - https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/discuss/1908839/JavaScript-2224.-Minimum-Number-of-Operations-to-Convert-Time\\n- Q2 answer\\n  - https://leetcode.com/problems/find-players-with-zero-or-one-losses/discuss/1908871/JavaScript-2225.-Find-Players-With-Zero-or-One-Losses\\n- Q3 answer\\n  - https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908890/JavaScript-2226.-Maximum-Candies-Allocated-to-K-Children\\n  - **below**\\n    - Similar to some other DP problems, but this is greedy\\n    - **Less code** solution\\n    - **More code - with comments** solution\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Less code** solution\\n\\n```\\nvar maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};\\n```\\n\\n---\\n\\n**More code - with comments** solution\\n\\n```\\nvar maximumCandies = function (cand, k) {\\n    function is_good_number_of_candies(cmin) {\\n        let count = 0;\\n        for (let c of cand) {\\n            count += Math.trunc(c / cmin); // how many mins (cmin) can we give from this pile (c)\\n        }\\n        return count >= k;\\n    }\\n\\n    let sum = cand.reduce((sum, x) => sum + x, 0);\\n    if (sum < k) return 0; // not enough, to give at least 1 candy\\n\\n    let lo = 1; // 1 is possible\\n    let hi = cand.reduce((max, x) => Math.max(max, x), -Infinity); // max possible\\n\\n    // since # of candies are too large, try binary search\\n    while (lo <= hi) {\\n        let mid = lo + Math.trunc((hi - lo) / 2);\\n        if (is_good_number_of_candies(mid)) {\\n            lo = mid + 1; // mid is good (##), try next one\\n        } else {\\n            hi = mid - 1;\\n        }\\n    }\\n    return lo - 1; // last good was mid, 1 below lo (## above)\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};\\n```\n```\\nvar maximumCandies = function (cand, k) {\\n    function is_good_number_of_candies(cmin) {\\n        let count = 0;\\n        for (let c of cand) {\\n            count += Math.trunc(c / cmin); // how many mins (cmin) can we give from this pile (c)\\n        }\\n        return count >= k;\\n    }\\n\\n    let sum = cand.reduce((sum, x) => sum + x, 0);\\n    if (sum < k) return 0; // not enough, to give at least 1 candy\\n\\n    let lo = 1; // 1 is possible\\n    let hi = cand.reduce((max, x) => Math.max(max, x), -Infinity); // max possible\\n\\n    // since # of candies are too large, try binary search\\n    while (lo <= hi) {\\n        let mid = lo + Math.trunc((hi - lo) / 2);\\n        if (is_good_number_of_candies(mid)) {\\n            lo = mid + 1; // mid is good (##), try next one\\n        } else {\\n            hi = mid - 1;\\n        }\\n    }\\n    return lo - 1; // last good was mid, 1 below lo (## above)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908756,
                "title": "c-binary-search-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& c , long long mid){\\n        int n = c.size();\\n        long long cnt = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            cnt += (c[i]/mid);\\n        }\\n        return cnt;\\n    }\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long sol = 0;\\n        int n = c.size();\\n        int low = 1;\\n        int high = *max_element(c.begin(),c.end());\\n        while(low <= high){\\n            long long mid = (high+low)/2;\\n            cout<<mid<<\" \";\\n            if(solve(c,mid) >= k){\\n                sol = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return sol;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& c , long long mid){\\n        int n = c.size();\\n        long long cnt = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            cnt += (c[i]/mid);\\n        }\\n        return cnt;\\n    }\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long sol = 0;\\n        int n = c.size();\\n        int low = 1;\\n        int high = *max_element(c.begin(),c.end());\\n        while(low <= high){\\n            long long mid = (high+low)/2;\\n            cout<<mid<<\" \";\\n            if(solve(c,mid) >= k){\\n                sol = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return sol;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3925584,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& arr, long long k) {\\n          long long int result = 0 ;\\n          long long int low  = 1;\\n          auto it = max_element(arr.begin() , arr.end());\\n          long long int high = (long long int)(*it);\\n          int n = arr.size();\\n          while(low <= high){\\n              long long int mid = low + (high - low)/2;\\n              long long int count = 0;\\n              for(int i = 0 ; i < n ; i++){\\n                  count += ((long long int)arr[i] / mid);\\n                  if(count >= k)break;\\n              }\\n              if(count >= k){\\n                   result = mid;\\n                   low = mid + 1;\\n               }else{\\n                   high = mid - 1;\\n              }\\n          }\\n          return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& arr, long long k) {\\n          long long int result = 0 ;\\n          long long int low  = 1;\\n          auto it = max_element(arr.begin() , arr.end());\\n          long long int high = (long long int)(*it);\\n          int n = arr.size();\\n          while(low <= high){\\n              long long int mid = low + (high - low)/2;\\n              long long int count = 0;\\n              for(int i = 0 ; i < n ; i++){\\n                  count += ((long long int)arr[i] / mid);\\n                  if(count >= k)break;\\n              }\\n              if(count >= k){\\n                   result = mid;\\n                   low = mid + 1;\\n               }else{\\n                   high = mid - 1;\\n              }\\n          }\\n          return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601419,
                "title": "binary-search-c-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere i apply **Binary Search Algorithm** to find out Maximum Number of candies.\\n\\nMaximum Number of Candies Always Belong to range **[1 , Maximum of array]** , number of Maximum Candies can be any Element from this sorted array that satisfy the given condition-\\n**[1,2,3,4,5,6,7,8,9...........Maximum of given array]**\\n\\nFirst  = 1 \\nLast   = Maximum\\n\\nFind Index That Satisfy the Given Condition(allocate piles of candies to k children such that each child gets the same number of candies) ?\\n\\n**Note:-Here I also apply the same approach, have a look at these problems and try to solve with the same approach.**\\n\\n**Problem:-** https://leetcode.com/problems/koko-eating-bananas/description/\\n**Solution:-** https://leetcode.com/problems/koko-eating-bananas/solutions/3601174/binary-search-c-with-explanation/\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,long long k,int n)\\n    {\\n        long long count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        count+=(arr[i]/n);\\n        \\n        if(count>=k)\\n        return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        \\n           int n = arr.size(),ans = 0;\\n           int first = 1,last = INT_MIN;\\n\\n           for(int i = 0;i<n;i++)\\n           last = max(last,arr[i])+1;\\n        \\n           while(first<last)\\n           {\\n               int mid = (first+last)/2;\\n\\n               if(check(arr,k,mid))\\n               {\\n                   first = mid+1;\\n                   ans = max(ans,mid);\\n               }\\n               else\\n               last = mid;\\n           }\\n           \\n           return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/4d957791-93e7-424e-a2ba-a546017c5145_1685983637.253224.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,long long k,int n)\\n    {\\n        long long count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        count+=(arr[i]/n);\\n        \\n        if(count>=k)\\n        return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        \\n           int n = arr.size(),ans = 0;\\n           int first = 1,last = INT_MIN;\\n\\n           for(int i = 0;i<n;i++)\\n           last = max(last,arr[i])+1;\\n        \\n           while(first<last)\\n           {\\n               int mid = (first+last)/2;\\n\\n               if(check(arr,k,mid))\\n               {\\n                   first = mid+1;\\n                   ans = max(ans,mid);\\n               }\\n               else\\n               last = mid;\\n           }\\n           \\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365306,
                "title": "using-binary-search-on-answer-explanation",
                "content": "instead of applying binary search directly on array we will apply binary search on the range of the answer.\\n\\nlow = 1 because there can be minimum 1 candy in the array\\nhigh = maximum in the array because that is the maaximum amount of candies that can be present in the pile\\n\\n\\nnow we want to validate each mid that we will get \\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }\\n        int start = 1, end = max, mid = 0, res = 0;\\n        while (start <= end) {\\n            mid = start + (end - start) / 2;\\n            if (isValid(candies, k, mid)) {\\n                res = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int[] candies, long k, int mid) {\\n        long totalPiles = 0;\\n        for (int i : candies) {\\n            int toAdd = i / mid;\\n            totalPiles += toAdd;\\n        }\\n        return totalPiles >= k;\\n    }\\n\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }\\n        int start = 1, end = max, mid = 0, res = 0;\\n        while (start <= end) {\\n            mid = start + (end - start) / 2;\\n            if (isValid(candies, k, mid)) {\\n                res = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int[] candies, long k, int mid) {\\n        long totalPiles = 0;\\n        for (int i : candies) {\\n            int toAdd = i / mid;\\n            totalPiles += toAdd;\\n        }\\n        return totalPiles >= k;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272035,
                "title": "c-binary-search-on-search-space-easy-solution",
                "content": "**Time Complexity : O(n*logm)** , where m is the maximum number of candies in the single pile.\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& candies, long long k, int max_candies){\\n        long long child_cnt = 0;\\n        \\n        for(auto candies: candies)\\n            child_cnt += candies/max_candies;\\n        \\n        return child_cnt >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start = 1;\\n        int end = *max_element(candies.begin(), candies.end());\\n        int res = 0;\\n\\t\\t\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(candies, k, mid)){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nUpvote if this helps.\\nThanks!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& candies, long long k, int max_candies){\\n        long long child_cnt = 0;\\n        \\n        for(auto candies: candies)\\n            child_cnt += candies/max_candies;\\n        \\n        return child_cnt >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start = 1;\\n        int end = *max_element(candies.begin(), candies.end());\\n        int res = 0;\\n\\t\\t\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(candies, k, mid)){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269073,
                "title": "easy-java-code-beats-99",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the range of candies to be distributed then,\\nUse Binary Search to find the maximum number of candies distributed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long sum = 0;\\n        for(int i = 0 ; i < candies.length; i++){\\n            sum+= candies[i];\\n        }\\n        int left = 1;\\n        int right = (int)(sum/k);\\n        // System.out.println(sum+\" \"+right);\\n        \\n        while(left <= right){\\n            int mid = (right - left) / 2 + left;\\n            long count = 0;\\n            \\n            for(int i = 0 ; i < candies.length; i++){\\n                count+= candies[i]/mid;\\n            }\\n            if(count >= k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long sum = 0;\\n        for(int i = 0 ; i < candies.length; i++){\\n            sum+= candies[i];\\n        }\\n        int left = 1;\\n        int right = (int)(sum/k);\\n        // System.out.println(sum+\" \"+right);\\n        \\n        while(left <= right){\\n            int mid = (right - left) / 2 + left;\\n            long count = 0;\\n            \\n            for(int i = 0 ; i < candies.length; i++){\\n                count+= candies[i]/mid;\\n            }\\n            if(count >= k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157693,
                "title": "java-sol-easy-binary-search-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 1;\\n        int high = Arrays.stream(candies).max().getAsInt();\\n        int ans = 0;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            long currAns = 0;\\n            for (int i : candies) {\\n                currAns += i/mid;\\n            }\\n            if (currAns >= k) {\\n                low = mid+1;\\n                ans = Math.max(ans, mid);\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 1;\\n        int high = Arrays.stream(candies).max().getAsInt();\\n        int ans = 0;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            long currAns = 0;\\n            for (int i : candies) {\\n                currAns += i/mid;\\n            }\\n            if (currAns >= k) {\\n                low = mid+1;\\n                ans = Math.max(ans, mid);\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911441,
                "title": "binary-search-method",
                "content": "class Solution {\\npublic:\\n    bool allocation(vector<int>& candies,long long k,long long mid){\\n        if(mid==0) return true;\\n        \\n        long long q=0;\\n        long long count=0;\\n         for(int i=0;i<candies.size();i++){\\n            int q=candies[i]/mid;\\n            count+=q;\\n            if(count>=k){\\n               return true;\\n              }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int ans=0;\\n        for(int i=0;i<candies.size();i++){\\n          ans=max(ans,candies[i]);\\n        }  \\n        long long low=0,high=ans;\\n        while(low<high){\\n            long long mid=(low+high)/2;\\n            \\n            if(allocation(candies,k,mid)){\\n                low=mid+1;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n       \\n       return allocation(candies,k,low)?low:low-1;\\n        \\n       \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool allocation(vector<int>& candies,long long k,long long mid){\\n        if(mid==0) return true;\\n        \\n        long long q=0;\\n        long long count=0;\\n         for(int i=0;i<candies.size();i++){\\n            int q=candies[i]/mid;\\n            count+=q;\\n            if(count>=k){\\n               return true;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1911109,
                "title": "c-simple-binary-search-solution-o-n-log-max-candies",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int mid, long long k){\\n        long long count = 0;\\n        for(int i : arr){\\n            count += (i/mid);\\n        }\\n        \\n        return (count >= k);\\n    }\\n    \\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int lo = 1, hi = *max_element(arr.begin(),arr.end()),ans = 0;        \\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,mid,k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int mid, long long k){\\n        long long count = 0;\\n        for(int i : arr){\\n            count += (i/mid);\\n        }\\n        \\n        return (count >= k);\\n    }\\n    \\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int lo = 1, hi = *max_element(arr.begin(),arr.end()),ans = 0;        \\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,mid,k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909817,
                "title": "c-binary-search",
                "content": "```\\n  bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n  bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909667,
                "title": "c-binary-search-solution",
                "content": "**Please Upvote If It Helps**\\n```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>& candies,long long k)\\n    {\\n        // it will containg the count that will tell we can assign or not assign candies to children \\n        long sum = 0;\\n        for(auto it : candies)\\n        {\\n            sum += (it/mid);\\n            \\n            // if any time our sum is reches to k childrens it means we can assign so return true\\n            if(sum>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        // initializing two pointers onr for min one for max\\n        // our answer lies between both of them it is final\\n        long left  = 1;\\n        long right = *max_element(begin(candies), end(candies));\\n        \\n        // applyting the binary search for searching that element\\n        while(left<=right)\\n        {\\n            // deriving mid value\\n            long mid = left+(right-left)/2;\\n            \\n            // if we can assign mid candies to k childrens successfully \\n            // then can check for next bigger value\\n            if(valid(mid,candies,k))\\n            {\\n                left = mid+1;\\n            }\\n            \\n            // if we can not assign mid candies to k childrens successfully\\n            // then can check for lesser value\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>& candies,long long k)\\n    {\\n        // it will containg the count that will tell we can assign or not assign candies to children \\n        long sum = 0;\\n        for(auto it : candies)\\n        {\\n            sum += (it/mid);\\n            \\n            // if any time our sum is reches to k childrens it means we can assign so return true\\n            if(sum>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        // initializing two pointers onr for min one for max\\n        // our answer lies between both of them it is final\\n        long left  = 1;\\n        long right = *max_element(begin(candies), end(candies));\\n        \\n        // applyting the binary search for searching that element\\n        while(left<=right)\\n        {\\n            // deriving mid value\\n            long mid = left+(right-left)/2;\\n            \\n            // if we can assign mid candies to k childrens successfully \\n            // then can check for next bigger value\\n            if(valid(mid,candies,k))\\n            {\\n                left = mid+1;\\n            }\\n            \\n            // if we can not assign mid candies to k childrens successfully\\n            // then can check for lesser value\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909092,
                "title": "java-binary-search-easy-to-understand",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. First calculate **total number** of candies. Let it be `sum`.\\n2. If `sum < k`, **return 0** we have **more children than candies**.\\n3. If `sum = k`, **return 1** as we have** as many children as candies**.\\n4. Else, perform **binary search** on **number of candies** in the range where `low = 1`, and `high = max of candies`.\\n5. Check for `mid`, if we can distribute mid number of candies to each children, then we can move `low to mid + 1`, else move` high to mid - 1.`\\n6. Store the **last satisfied mid value in `ans`**.\\n7. Return `ans`.\\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        long max = 0;\\n        \\n        for(int v : candies) {\\n            sum += v;\\n            max = Math.max(v, max);\\n        }\\n        \\n        if(sum < k)\\n            return 0;\\n        \\n        if(sum == k)\\n            return 1;\\n        \\n        long x = 1, y = max, ans = 1;\\n        \\n        while(x <= y) {\\n            long mid = (x + y) >> 1;\\n            long cur = 0;\\n            \\n            for(int v : candies) {\\n                cur += v / mid;\\n            }\\n            \\n            if(cur>= k) {\\n                ans = mid;\\n                x = mid + 1;\\n            }\\n            else\\n                y = mid - 1;\\n        }\\n        \\n        return (int) (ans);\\n        \\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(n * log(max)) // n = number of candy piles, max = max value of candy pile\\nSpace Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        long max = 0;\\n        \\n        for(int v : candies) {\\n            sum += v;\\n            max = Math.max(v, max);\\n        }\\n        \\n        if(sum < k)\\n            return 0;\\n        \\n        if(sum == k)\\n            return 1;\\n        \\n        long x = 1, y = max, ans = 1;\\n        \\n        while(x <= y) {\\n            long mid = (x + y) >> 1;\\n            long cur = 0;\\n            \\n            for(int v : candies) {\\n                cur += v / mid;\\n            }\\n            \\n            if(cur>= k) {\\n                ans = mid;\\n                x = mid + 1;\\n            }\\n            else\\n                y = mid - 1;\\n        }\\n        \\n        return (int) (ans);\\n        \\n    }\\n}\\n```\n```\\nTime Complexity: O(n * log(max)) // n = number of candy piles, max = max value of candy pile\\nSpace Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909052,
                "title": "c-binary-search-easy-explaination-code",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long int maxPiles(vector<int> candies, long long int k)\\n    {\\n        long long int l = 1; // We can select an minimum 1 element\\n        long long int h = 0;\\n        for (auto i : candies)\\n        {\\n            h += i;\\n        }\\n        if (k > h)\\n        {\\n            return 0;\\n        }\\n        h /= k; // at most selection\\n                //  this ans for storing mid value\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            long long mid = (l + h) / 2;\\n            long long int count = 0;\\n            for (auto i : candies)\\n            {\\n                int tt = (i / mid);\\n                count += tt;\\n            }\\n            if (count >= k)\\n            {\\n                ans = mid; // updating mid\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k)\\n    {\\n        return maxPiles(candies, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long int maxPiles(vector<int> candies, long long int k)\\n    {\\n        long long int l = 1; // We can select an minimum 1 element\\n        long long int h = 0;\\n        for (auto i : candies)\\n        {\\n            h += i;\\n        }\\n        if (k > h)\\n        {\\n            return 0;\\n        }\\n        h /= k; // at most selection\\n                //  this ans for storing mid value\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            long long mid = (l + h) / 2;\\n            long long int count = 0;\\n            for (auto i : candies)\\n            {\\n                int tt = (i / mid);\\n                count += tt;\\n            }\\n            if (count >= k)\\n            {\\n                ans = mid; // updating mid\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k)\\n    {\\n        return maxPiles(candies, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908784,
                "title": "cpp-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    //checks if each children can get C candies\\n    bool isPossible(vector<int>& candies, long long C, long long k) {\\n        long long cnt = 0;\\n        for(auto c : candies) {\\n            cnt += (long long)(c/C);\\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    //Binary Search on ans(no. of candies each can get)\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(auto c : candies) sum += (long long)c;\\n        \\n        long long end = sum / k + 1;\\n        long long beg = 0;\\n        while(beg + 1 < end) {\\n            long long mid = (beg + end) / 2;\\n            if(isGood(candies, mid, k)) beg = mid;\\n            else end = mid;\\n        }\\n        \\n        return (int)beg;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //checks if each children can get C candies\\n    bool isPossible(vector<int>& candies, long long C, long long k) {\\n        long long cnt = 0;\\n        for(auto c : candies) {\\n            cnt += (long long)(c/C);\\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    //Binary Search on ans(no. of candies each can get)\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(auto c : candies) sum += (long long)c;\\n        \\n        long long end = sum / k + 1;\\n        long long beg = 0;\\n        while(beg + 1 < end) {\\n            long long mid = (beg + end) / 2;\\n            if(isGood(candies, mid, k)) beg = mid;\\n            else end = mid;\\n        }\\n        \\n        return (int)beg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908729,
                "title": "python-solution-with-binary-search-explained",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        # The lower bound is 1 and higher bound is maximum value from candies. \\n        lo, hi = 1, max(candies)\\n        # This higher bound is not generally possible except for cases like candies = [5,5,5,5] & k = 4\\n        res = 0 # Current maximum result\\n        if sum(candies) < k: # If true then we cannot give even 1 candy to each child thus return 0\\n            return 0\\n        \\n        def cal_num_of_piles(pile_size): # Criterion function\\n            count = 0\\n            for c in candies:\\n                count += c // pile_size\\n            return count >= k\\n        \\n        while lo <= hi: # Binary Search Algorithm \\n            mid = (lo + hi + 1) // 2 # Expected answer\\n            if cal_num_of_piles(mid): # Check if mid is a possible answer.\\n                res = mid # Update the current maximum answer\\n                lo = mid + 1 # Check ahead of mid\\n            else:\\n                hi = mid - 1 # Check below mid\\n        return res\\n```\\n\\n**Concept of Binary Search on Answer:**\\nThe best way to explain Binary Search the Answer is that we use binary search to guess the answer to the problem. By guessing we mean that we will get several \\u201CYES\\u201D or \\u201CNO\\u201D feedback or maybe \\u201Ctoo high\\u201D, \\u201Ctoo low\\u201D, or \\u201Cexactly\\u201D responses. Since we need the maximum answer Binary Search tries to converge on the largest possible answer till the possibility exists.\\n\\n**Binary Search on Answer has 3 basic requirements:**\\n1. The problem must have multiple possible answers. **[Range of possible solutions]**\\n2. The problem must be an optimization problem. **[Minimizing/Maximizing the result]**\\n3. We must develope a function/criterion to determine when to update left and right pointers. **[Criterion to update pointers]**\\n\\n**Observations:**\\n`For candies = [5,8,6] & k = 3` we have many possible answers: 1, 2, 3, 4, 5 all seem to work fine but we return 5 as it is the largest.\\n1. Thus we have a range of solutions and we are asked to maximize the final result. **Requirement 1 and 2 are fulfilled**.\\n2. One might feel that the possible answers must be smaller than the smallest value of an array. Eg: `for candies = [5,6,8] & k = 3` then the answer is 5. For say `candies = [7,9,13] & k = 4` the possible answers are 6, 5...2, 1. However this is not always correct. For Eg: `candies = [1,2,3,4,10] & k = 5` the possible answers are 1, 2, 3. Here we can neglect the 0th and 1st piles to get a better answer. This is because we are told that we may let some piles of candies go unused.\\n3. **Developing the criterion:** Since we only need to check if a given value can be possibly divided k times with the given candies array. Hence we get an easy update function. \\n\\t```\\n\\tdef cal_num_of_piles(pile_size):\\n\\t\\tcount = 0 # Number of divisions with current pile_size\\n\\t\\tfor c in candies:\\n\\t\\t\\tcount += c // pile_size # Add how many piles can be generated with ith candies with given pile_size\\n\\t\\treturn count >= k\\n\\t```\\n***So all three requirements are now fulfilled.***\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        # The lower bound is 1 and higher bound is maximum value from candies. \\n        lo, hi = 1, max(candies)\\n        # This higher bound is not generally possible except for cases like candies = [5,5,5,5] & k = 4\\n        res = 0 # Current maximum result\\n        if sum(candies) < k: # If true then we cannot give even 1 candy to each child thus return 0\\n            return 0\\n        \\n        def cal_num_of_piles(pile_size): # Criterion function\\n            count = 0\\n            for c in candies:\\n                count += c // pile_size\\n            return count >= k\\n        \\n        while lo <= hi: # Binary Search Algorithm \\n            mid = (lo + hi + 1) // 2 # Expected answer\\n            if cal_num_of_piles(mid): # Check if mid is a possible answer.\\n                res = mid # Update the current maximum answer\\n                lo = mid + 1 # Check ahead of mid\\n            else:\\n                hi = mid - 1 # Check below mid\\n        return res\\n```\n```\\n\\tdef cal_num_of_piles(pile_size):\\n\\t\\tcount = 0 # Number of divisions with current pile_size\\n\\t\\tfor c in candies:\\n\\t\\t\\tcount += c // pile_size # Add how many piles can be generated with ith candies with given pile_size\\n\\t\\treturn count >= k\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3822063,
                "title": "beats-100-binary-search-easy-approach",
                "content": "# Complexity\\n- Time complexity : $$O(NlogN + NlogM)$$ M = Range i.e. high-low = totSum/k-1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        sort(begin(candies),end(candies));\\n\\n        long long totSum = accumulate(begin(candies),end(candies),0ll);\\n        if(totSum < k) return 0;\\n\\n        long long low=1 , high=totSum/k; // can also take some bigger value like 1e8\\n        while(low <= high) {\\n            long long mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,candies,k)) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return high;\\n    }\\n\\n    bool isPossible(long long mid, vector<int> &candies, long long k) {\\n        int n = candies.size();\\n        long long cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            cnt += 1ll*(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        sort(begin(candies),end(candies));\\n\\n        long long totSum = accumulate(begin(candies),end(candies),0ll);\\n        if(totSum < k) return 0;\\n\\n        long long low=1 , high=totSum/k; // can also take some bigger value like 1e8\\n        while(low <= high) {\\n            long long mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,candies,k)) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return high;\\n    }\\n\\n    bool isPossible(long long mid, vector<int> &candies, long long k) {\\n        int n = candies.size();\\n        long long cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            cnt += 1ll*(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273752,
                "title": "beats-99-easy-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long sum=0;\\n        for(auto i:candies)sum+=i;\\n        int mn=*min_element(candies.begin(),candies.end());\\n        long long s=mn/((k+n-1)/n);\\n        long long e=sum/k;\\n        long long m;\\n        while(s<=e){\\n            m=(s+e)/2;\\n            long long ct=0;\\n            if(m==0){\\n                ct=LONG_MAX;\\n            }else{\\n            for(auto i:candies){\\n                ct+=(i/m);\\n            }\\n            }\\n            if(ct<k){\\n                e=m-1;\\n            }else{\\n                s=m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long sum=0;\\n        for(auto i:candies)sum+=i;\\n        int mn=*min_element(candies.begin(),candies.end());\\n        long long s=mn/((k+n-1)/n);\\n        long long e=sum/k;\\n        long long m;\\n        while(s<=e){\\n            m=(s+e)/2;\\n            long long ct=0;\\n            if(m==0){\\n                ct=LONG_MAX;\\n            }else{\\n            for(auto i:candies){\\n                ct+=(i/m);\\n            }\\n            }\\n            if(ct<k){\\n                e=m-1;\\n            }else{\\n                s=m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268223,
                "title": "range-bs-runtime-174-ms-beats-98-32-must-see",
                "content": "# Code\\n```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n//actual code\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        long long int maxele = *max_element(candies.begin(),candies.end());\\n        long long int start = 0;\\n        long long int end   = maxele;\\n        long long int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end-start)/2));\\n\\n            //we will try to allocate the piles to every children \\n            //having exactly mid candies\\n\\n            if(fun(candies,mid,k) == true)\\n            {\\n                if(mid > ans) ans = mid;\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,long long int &mid,long long int &k)\\n    {\\n        if(mid == 0) return true;\\n\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (arr[i]/mid);\\n            count = count + temp;\\n        }\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n//actual code\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        long long int maxele = *max_element(candies.begin(),candies.end());\\n        long long int start = 0;\\n        long long int end   = maxele;\\n        long long int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end-start)/2));\\n\\n            //we will try to allocate the piles to every children \\n            //having exactly mid candies\\n\\n            if(fun(candies,mid,k) == true)\\n            {\\n                if(mid > ans) ans = mid;\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,long long int &mid,long long int &k)\\n    {\\n        if(mid == 0) return true;\\n\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (arr[i]/mid);\\n            count = count + temp;\\n        }\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2962740,
                "title": "c-binary-search-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& candies, long long k, int mid) {\\n        long long n = candies.size(), candy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            candy = candy + candies[i]/mid;\\n        }\\n\\n        if(candy >= k) \\n            return true;\\n\\n        else return false;\\n        \\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long n = candies.size(), max = INT_MIN;\\n        long long sum = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            sum = candies[i] + sum;         //calculating sum of all candies\\n            if(candies[i] > max) {          //calculating minimum pile of candy\\n                max = candies[i];\\n            }\\n        }\\n\\n        if(sum < k) {\\n            return 0;       // bcoz no. children is more than total candy\\n        }\\n\\n        long long start = 1, end = max, ans = 0;\\n        long long mid = start + (end - start)/2;\\n\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(solve(candies, k, mid)) {\\n                start = mid + 1;\\n                ans = mid;\\n            }\\n\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n log m)\\n\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& candies, long long k, int mid) {\\n        long long n = candies.size(), candy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            candy = candy + candies[i]/mid;\\n        }\\n\\n        if(candy >= k) \\n            return true;\\n\\n        else return false;\\n        \\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long n = candies.size(), max = INT_MIN;\\n        long long sum = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            sum = candies[i] + sum;         //calculating sum of all candies\\n            if(candies[i] > max) {          //calculating minimum pile of candy\\n                max = candies[i];\\n            }\\n        }\\n\\n        if(sum < k) {\\n            return 0;       // bcoz no. children is more than total candy\\n        }\\n\\n        long long start = 1, end = max, ans = 0;\\n        long long mid = start + (end - start)/2;\\n\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(solve(candies, k, mid)) {\\n                start = mid + 1;\\n                ans = mid;\\n            }\\n\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836560,
                "title": "simple-c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool good(int x , long long k , vector<int> &arr ){\\n        long long ct = 0;\\n        for(int i=0 ; i<n ; i++){\\n            ct += (arr[i]/x);\\n        }\\n        return (ct>=k);\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int low = 1;\\n        int high = 1e9+1;\\n        n = arr.size();\\n        int ans = 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(good(mid , k , arr)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// [4,7,5]\\n// 4\\n\\n// op -> 3\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool good(int x , long long k , vector<int> &arr ){\\n        long long ct = 0;\\n        for(int i=0 ; i<n ; i++){\\n            ct += (arr[i]/x);\\n        }\\n        return (ct>=k);\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int low = 1;\\n        int high = 1e9+1;\\n        n = arr.size();\\n        int ans = 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(good(mid , k , arr)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// [4,7,5]\\n// 4\\n\\n// op -> 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565461,
                "title": "99-faster-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/8f3fb19a-40a0-4acf-9475-84ea66780864_1662967246.5710497.png)\\n\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k:return 0\\n        else:\\n            low=0 \\n            high=max(candies)\\n            while low<high:\\n                mid=math.ceil((low+high)/2)\\n                if sum(c//mid for c in candies)>=k: low=mid\\n                else: high=mid-1\\n            return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k:return 0\\n        else:\\n            low=0 \\n            high=max(candies)\\n            while low<high:\\n                mid=math.ceil((low+high)/2)\\n                if sum(c//mid for c in candies)>=k: low=mid\\n                else: high=mid-1\\n            return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503906,
                "title": "binary-search-ac-code-explained-with-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &candies, long long k, long long mid){\\n\\n        long long total = 0;\\n        \\n        for(int i=0;i<candies.size();i++){ \\n            \\n           //Here we are maintaining the count of candies that we are distributing. \\n           total += candies[i]/mid;\\n            \\n        }\\n        \\n        //Checking if the total number of candies that can be distirbuted\\n        //for the pile of value \\'mid\\' is less than or equal to total no. of children.\\n        //If the above condition is false then we cannot divide the candies into piler of size mid\\n        return (total>=k);\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        //We will do the binary search for all the elements \\n        // from \\'1\\' to the largest value in the candies.\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        for(int i=0;i<candies.size();i++){\\n            high = max(high, candies[i]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            long long mid = (low+high)/2;\\n            \\n            //Checking if the middle element can be a valid pile.\\n            //If the function returns true than we will move to the left side to\\n            //check if even a larger answer is possible.\\n            if(isValid(candies, k, mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                //If the function returns false then we will move to the left half\\n                //to find the possible valid pile value.\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &candies, long long k, long long mid){\\n\\n        long long total = 0;\\n        \\n        for(int i=0;i<candies.size();i++){ \\n            \\n           //Here we are maintaining the count of candies that we are distributing. \\n           total += candies[i]/mid;\\n            \\n        }\\n        \\n        //Checking if the total number of candies that can be distirbuted\\n        //for the pile of value \\'mid\\' is less than or equal to total no. of children.\\n        //If the above condition is false then we cannot divide the candies into piler of size mid\\n        return (total>=k);\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        //We will do the binary search for all the elements \\n        // from \\'1\\' to the largest value in the candies.\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        for(int i=0;i<candies.size();i++){\\n            high = max(high, candies[i]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            long long mid = (low+high)/2;\\n            \\n            //Checking if the middle element can be a valid pile.\\n            //If the function returns true than we will move to the left side to\\n            //check if even a larger answer is possible.\\n            if(isValid(candies, k, mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                //If the function returns false then we will move to the left half\\n                //to find the possible valid pile value.\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442477,
                "title": "c-efficient-sol-with-explanation-complexity",
                "content": "***Explanation :***\\nAccording to question we have to find the maximum size of each pile that we can get to satisfy k children.\\nWe do this using ***Binary Search : (why?)***\\n***Binary Search can be used on following type of problems :***\\n***1. Maximization problems\\n2. Minimization problems***\\nWe binary search for the maximum size of the pile . \\n***Range of binary search :*** \\n***lo=1***, (cannot be 0 sized pile) ***hi=maximum elemnt in candies array.***\\nFor every mid value , we check if it is possible to make k or more piles of size ***mid***\\n***If yes*** , we move ***lo= mid+1***, to get maximum possible size of pile .\\n***If no*** , then we move ***hi= mid-1*** , to decrease size of pile .\\n\\n***Complexity Analysis :\\nTC : O(n log x ) ( x--> maximum elment in candies array)\\nSC : O(1)***\\n\\n**UPVOTE IF YOU LIKE** \\u2705\\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    bool isPossible_to_divide(vector<int>&candies,long long size,long long k){\\n        long long ans=0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=(candies[i]/size);\\n        }\\n        return ans>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=1,hi=*max_element(candies.begin(),candies.end()),mid,ans=0;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if(isPossible_to_divide(candies, mid, k)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return  ans;\\n    }\\n};\\n// Any other queries are welcomed as well.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible_to_divide(vector<int>&candies,long long size,long long k){\\n        long long ans=0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=(candies[i]/size);\\n        }\\n        return ans>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=1,hi=*max_element(candies.begin(),candies.end()),mid,ans=0;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if(isPossible_to_divide(candies, mid, k)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return  ans;\\n    }\\n};\\n// Any other queries are welcomed as well.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402075,
                "title": "c-binary-search-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        int left = 1, right = *max_element(c.begin(), c.end());\\n        int ans = 0;\\n        while(left <= right){\\n            int Cand = (left + right) >> 1;\\n            long long sum = 0;\\n            for(auto it: c){\\n                sum += it / Cand;\\n                if(sum >= k) break;\\n            }\\n            if(sum >= k){\\n                ans = Cand;\\n                left = Cand + 1;\\n            }\\n            else{\\n                right = Cand-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        int left = 1, right = *max_element(c.begin(), c.end());\\n        int ans = 0;\\n        while(left <= right){\\n            int Cand = (left + right) >> 1;\\n            long long sum = 0;\\n            for(auto it: c){\\n                sum += it / Cand;\\n                if(sum >= k) break;\\n            }\\n            if(sum >= k){\\n                ans = Cand;\\n                left = Cand + 1;\\n            }\\n            else{\\n                right = Cand-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276939,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& c,long long k,int mid)\\n    {\\n        if(!mid)\\n            return 1;\\n      long long x=0;    \\n        for(int i=0;i<c.size();i++)\\n        {\\n            x+=(c[i]/mid);\\n        }\\n        return x>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low=0,ans=0;\\n       int high=*max_element(candies.begin(),candies.end());\\n        while(low<=high)\\n        {\\n           int mid=(high+low)>>1;\\n            if(solve(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& c,long long k,int mid)\\n    {\\n        if(!mid)\\n            return 1;\\n      long long x=0;    \\n        for(int i=0;i<c.size();i++)\\n        {\\n            x+=(c[i]/mid);\\n        }\\n        return x>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low=0,ans=0;\\n       int high=*max_element(candies.begin(),candies.end());\\n        while(low<=high)\\n        {\\n           int mid=(high+low)>>1;\\n            if(solve(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158323,
                "title": "binary-search-approach-with-detailed-explained-in-comments",
                "content": "### Please Upvote if you like this\\n\\n#### Time Complexity: Log(mx)  * O(N)\\n#### Log(mx) for binary search and O(N) for iterating through the candies array.\\n\\n#### Space Complexity: O(1) because we did use constant extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n//         get the sum and mx of all candies\\n        long long sum = 0;\\n        int mx = INT_MIN;\\n//         Iterate the loop to get the sum of all values and maximum among then\\n        for(int &i: candies){\\n            sum += i;\\n            mx = max(i, mx);\\n        }\\n        \\n//         if sum < k then return 0 because it will never fulfill the k children requirements:\\n//         \"each child gets the same number of candies\" it impossible to distribute atleast 1 candy to all so return 0\\n        \\n        if(sum < k) return 0;\\n        \\n//         start pointers for binary search\\n        int start = 1, end = mx;\\n        int ans = 0;\\n        \\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            long long cand = 0;\\n            \\n//             take floor all values or simply write (i/mid) because it won\\'t let candies to merged\\n            for(int &i: candies){\\n                cand += floor(i/mid);\\n            }\\n            \\n//             cand >= k means that no. of mid candies can be distributed among all children. If cand >= k update the answer and search for more bigger value.\\n            if(cand >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n//             if it doesn\\'t satisfy the condition then search for lower value.\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        // return the possible answer if it is otherwise return 0 as default value of ans.\\n        return ans;\\n    }\\n};\\n```\\n### Please Upvote if you like this",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n//         get the sum and mx of all candies\\n        long long sum = 0;\\n        int mx = INT_MIN;\\n//         Iterate the loop to get the sum of all values and maximum among then\\n        for(int &i: candies){\\n            sum += i;\\n            mx = max(i, mx);\\n        }\\n        \\n//         if sum < k then return 0 because it will never fulfill the k children requirements:\\n//         \"each child gets the same number of candies\" it impossible to distribute atleast 1 candy to all so return 0\\n        \\n        if(sum < k) return 0;\\n        \\n//         start pointers for binary search\\n        int start = 1, end = mx;\\n        int ans = 0;\\n        \\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            long long cand = 0;\\n            \\n//             take floor all values or simply write (i/mid) because it won\\'t let candies to merged\\n            for(int &i: candies){\\n                cand += floor(i/mid);\\n            }\\n            \\n//             cand >= k means that no. of mid candies can be distributed among all children. If cand >= k update the answer and search for more bigger value.\\n            if(cand >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n//             if it doesn\\'t satisfy the condition then search for lower value.\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        // return the possible answer if it is otherwise return 0 as default value of ans.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017213,
                "title": "c-binary-search-by-value",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        // corner case\\n        long long sum = 0;\\n        for(auto c : candies){\\n            sum += c;\\n        }\\n        if(sum < k){\\n            return 0;\\n        }\\n        // binary search\\n        long long start = 1, end = *max_element(candies.begin(), candies.end());\\n        while(start < end){\\n            long long mid = start + (end - start + 1) / 2; // since we want to get the upper bound of the answers(maximum)\\n            long long count = numKidsAllocatedWithGivenCandyNum(candies, mid);\\n            if(count < k){\\n                // the number is too large, mid cannot be the answer\\n                end = mid - 1; \\n            }\\n            else{\\n                // the number is too small, but could be the answer\\n                start = mid;\\n            }\\n        }\\n        \\n        return start;\\n    }\\n    \\n    long long numKidsAllocatedWithGivenCandyNum(vector<int>& candies, int val){\\n        long long count = 0;\\n        for(auto candy : candies){\\n            count += candy / val;\\n        }\\n        return count;\\n    }\\n \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        // corner case\\n        long long sum = 0;\\n        for(auto c : candies){\\n            sum += c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2008765,
                "title": "python-binary-search",
                "content": "\\n    def maximumCandies(self, candies, k):\\n        def dfs(c):\\n            count = 0\\n            \\n            for candy in candies:\\n                count += candy//c\\n                \\n            if count >= k:\\n                return True\\n            \\n            return False\\n            \\n        low, high = 1, max(candies)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if dfs(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return high\\n",
                "solutionTags": [],
                "code": "\\n    def maximumCandies(self, candies, k):\\n        def dfs(c):\\n            count = 0\\n            \\n            for candy in candies:\\n                count += candy//c\\n                \\n            if count >= k:\\n                return True\\n            \\n            return False\\n            \\n        low, high = 1, max(candies)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if dfs(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return high\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1988406,
                "title": "python-binary-search-99",
                "content": "\\n\\n\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        total_candies = sum(candies)\\n        max_candies = total_candies//k\\n        \\n        if max_candies<=1:\\n            return max_candies\\n        \\n\\n        i, j = 2, max_candies\\n        \\n        \\n        while i<=j:\\n            candy = (i+j)//2\\n            \\n            n_pile = sum([each//candy for each in candies])\\n            \\n            if n_pile>=k: \\n                i = candy+1\\n            else: \\n                j = candy-1\\n                \\n            \\n                \\n        return candy if n_pile >= k else candy-1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        total_candies = sum(candies)\\n        max_candies = total_candies//k\\n        \\n        if max_candies<=1:\\n            return max_candies\\n        \\n\\n        i, j = 2, max_candies\\n        \\n        \\n        while i<=j:\\n            candy = (i+j)//2\\n            \\n            n_pile = sum([each//candy for each in candies])\\n            \\n            if n_pile>=k: \\n                i = candy+1\\n            else: \\n                j = candy-1\\n                \\n            \\n                \\n        return candy if n_pile >= k else candy-1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985777,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n        }\\n        if(sum<k)return 0;\\n        if(sum==k)return 1;\\n        long ans=sum/k;\\n       // System.out.println(ans);\\n        if(ans==1)return (int)ans;\\n        long l=0;\\n        long mid=0;\\n        long h=ans;\\n\\t\\t//binary search\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n              long c=0;\\n            for(int j=0;j<n;j++){\\n                c+=(long)candies[j]/mid;\\n            }\\n            if(c>=k){\\n                ans=mid;\\n               // System.out.println(ans);\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976270,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931345,
                "title": "kotlin-binary-search-solution",
                "content": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var (min, max, sum) = Triple(1, Integer.MIN_VALUE, 0L)\\n        candies.forEach { sum += it.also { if (it > max) max = it } }\\n        if (sum < k) return 0\\n\\n        var result = min\\n        while (max > min) {\\n            if (canEachChildGetCCandies(result, candies, k)) min = result\\n            else max = result -1\\n            result = (min + max + 1) / 2\\n        }\\n        return result\\n    }\\n\\n    fun canEachChildGetCCandies(c: Int, candies: IntArray, k: Long) =\\n        candies.fold(0L) { sum, it -> sum + it / c } >= k\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var (min, max, sum) = Triple(1, Integer.MIN_VALUE, 0L)\\n        candies.forEach { sum += it.also { if (it > max) max = it } }\\n        if (sum < k) return 0\\n\\n        var result = min\\n        while (max > min) {\\n            if (canEachChildGetCCandies(result, candies, k)) min = result\\n            else max = result -1\\n            result = (min + max + 1) / 2\\n        }\\n        return result\\n    }\\n\\n    fun canEachChildGetCCandies(c: Int, candies: IntArray, k: Long) =\\n        candies.fold(0L) { sum, it -> sum + it / c } >= k\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929691,
                "title": "2-python-solutions-binary-search",
                "content": "### ***Solution 1: Time O(nlog n) / Memory O(1)***\\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        lo=0 ; hi=sum(C)//k\\n        while lo<hi:\\n            mid=(lo+hi)//2+1\\n            if sum(c//mid for c in C)>=k: lo=mid\\n            else: hi=mid-1\\n        return lo\\n```\\n-----------------\\n### ***Solution 2: One-Line Version   -->  Time O(nlog n) / Memory O(1)***\\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        return bisect_left(range(1,sum(C)//k+1), True, key=lambda x:sum(c//x for c in C)<k)\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        lo=0 ; hi=sum(C)//k\\n        while lo<hi:\\n            mid=(lo+hi)//2+1\\n            if sum(c//mid for c in C)>=k: lo=mid\\n            else: hi=mid-1\\n        return lo\\n```\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        return bisect_left(range(1,sum(C)//k+1), True, key=lambda x:sum(c//x for c in C)<k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927152,
                "title": "c-easy-to-understand-with-simple-binary-search",
                "content": "Expalnation  : \\nstep 1 : find minimum and maximum values of candies you can give to each child that gives you the range of minimum and maximum candies minimum is always 0.\\nstep 2: check for one by one each candies per child on range of minimum and maximum what maximum satisfy your condition but linearly you may get TLE so think of Binary search.\\n\\n\\t    // Binary search on minimum and maximum possible values and \\n\\t   //\\tcheck according to mid value it is possible to allocate mid candies to each child\\n\\t  //  if yess then increase low to mid because we want a maximum candies per child\\n...\\n\\n\\nint maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(long long i=0;i<candies.size();i++)\\n            sum += candies[i];\\n        if(sum < k)\\n            return 0;\\n        if(sum==k)\\n            return 1;\\n        long long low = 0;\\n        long long high = sum/k+1;\\n        \\n        long long ans=0;\\n\\t\\t// Binary search on minimum and maximum possible values and \\n\\t\\t//check according to mid value it is possible to allocate mid candies to each child\\n\\t\\t//if yess then increase low to mid because we want a maximum candies per child\\n       while(low < high)\\n       {\\n           int mid = low + (high - low)/2;\\n           if(mid == 0) return 0;\\n           long long count=0;\\n           for(int j=0;j<candies.size();j++)\\n            {\\n               long long pile = candies[j];\\n                count +=  (pile/mid);\\n            }\\n           if(count>=k)\\n           {\\n               if(mid>ans)\\n                   ans = mid;\\n               low = mid+1;\\n           }\\n           else\\n               high = mid;\\n           \\n       }\\n        return ans==0 ? 0 : ans;\\n    }\\n\\t\\n...",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "Expalnation  : \\nstep 1 : find minimum and maximum values of candies you can give to each child that gives you the range of minimum and maximum candies minimum is always 0.\\nstep 2: check for one by one each candies per child on range of minimum and maximum what maximum satisfy your condition but linearly you may get TLE so think of Binary search.\\n\\n\\t    // Binary search on minimum and maximum possible values and \\n\\t   //\\tcheck according to mid value it is possible to allocate mid candies to each child\\n\\t  //  if yess then increase low to mid because we want a maximum candies per child\\n...\\n\\n\\nint maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(long long i=0;i<candies.size();i++)\\n            sum += candies[i];\\n        if(sum < k)\\n            return 0;\\n        if(sum==k)\\n            return 1;\\n        long long low = 0;\\n        long long high = sum/k+1;\\n        \\n        long long ans=0;\\n\\t\\t// Binary search on minimum and maximum possible values and \\n\\t\\t//check according to mid value it is possible to allocate mid candies to each child\\n\\t\\t//if yess then increase low to mid because we want a maximum candies per child\\n       while(low < high)\\n       {\\n           int mid = low + (high - low)/2;\\n           if(mid == 0) return 0;\\n           long long count=0;\\n           for(int j=0;j<candies.size();j++)\\n            {\\n               long long pile = candies[j];\\n                count +=  (pile/mid);\\n            }\\n           if(count>=k)\\n           {\\n               if(mid>ans)\\n                   ans = mid;\\n               low = mid+1;\\n           }\\n           else\\n               high = mid;\\n           \\n       }\\n        return ans==0 ? 0 : ans;\\n    }\\n\\t\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 1923331,
                "title": "a-few-solutions",
                "content": "Use binary search to find the maximal `k` candy \"chunks\" we can `take` from each `A[i]`<sup>th</sup> pile of candies to satisfy threshold `T` children.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maximumCandies(A: IntArray, T: Long): Int {\\n        var i = 0\\n        var j = A.max()!!\\n        while (i < j) {\\n            var k = (i + j + 1) / 2\\n            var take = A.map{ it.toLong() / k }.sum()\\n            if (T <= take)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return i\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maximumCandies = (A, T) => {\\n    let i = 0,\\n        j = Math.max(...A);\\n    while (i < j) {\\n        let k = Math.floor((i + j + 1) / 2);\\n        let take = _.sum(A.map(x => Math.floor(x / k)));\\n        if (T <= take)\\n            i = k;\\n        else\\n            j = k - 1;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maximumCandies(self, A: List[int], T: int) -> int:\\n        i = 0\\n        j = max(A)\\n        while i < j:\\n            k = (i + j + 1) // 2\\n            take = sum(x // k for x in A)\\n            if T <= take:\\n                i = k\\n            else:\\n                j = k - 1\\n        return i\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_candies(A: VI, T: i64) -> i32 {\\n        let mut i = 0;\\n        let mut j = *A.iter().max().unwrap();\\n        while i < j {\\n            let k = (i + j + 1) / 2;\\n            let take: i64 = A.iter().map(|x| *x as i64 / k as i64).sum();\\n            if T <= take {\\n                i = k;\\n            } else {\\n                j = k - 1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maximumCandies(VI& A, LL T) {\\n        LL i = 0,\\n           j = *max_element(A.begin(), A.end());\\n        while (i < j) {\\n            auto k = (i + j + 1LL) / 2;\\n            auto take = accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto x) { return t + x / k; });\\n            if (T <= take)\\n                i = k;\\n            else\\n                j = k - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(A: IntArray, T: Long): Int {\\n        var i = 0\\n        var j = A.max()!!\\n        while (i < j) {\\n            var k = (i + j + 1) / 2\\n            var take = A.map{ it.toLong() / k }.sum()\\n            if (T <= take)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return i\\n    }\\n}\\n```\n```\\nlet maximumCandies = (A, T) => {\\n    let i = 0,\\n        j = Math.max(...A);\\n    while (i < j) {\\n        let k = Math.floor((i + j + 1) / 2);\\n        let take = _.sum(A.map(x => Math.floor(x / k)));\\n        if (T <= take)\\n            i = k;\\n        else\\n            j = k - 1;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def maximumCandies(self, A: List[int], T: int) -> int:\\n        i = 0\\n        j = max(A)\\n        while i < j:\\n            k = (i + j + 1) // 2\\n            take = sum(x // k for x in A)\\n            if T <= take:\\n                i = k\\n            else:\\n                j = k - 1\\n        return i\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_candies(A: VI, T: i64) -> i32 {\\n        let mut i = 0;\\n        let mut j = *A.iter().max().unwrap();\\n        while i < j {\\n            let k = (i + j + 1) / 2;\\n            let take: i64 = A.iter().map(|x| *x as i64 / k as i64).sum();\\n            if T <= take {\\n                i = k;\\n            } else {\\n                j = k - 1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maximumCandies(VI& A, LL T) {\\n        LL i = 0,\\n           j = *max_element(A.begin(), A.end());\\n        while (i < j) {\\n            auto k = (i + j + 1LL) / 2;\\n            auto take = accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto x) { return t + x / k; });\\n            if (T <= take)\\n                i = k;\\n            else\\n                j = k - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917758,
                "title": "binary-search-pattern-problem-nlog-max-candy",
                "content": "1. Its the common pattern for the binary search and in this case we need to find the maximum candies that can be allocated to K students where each of them get equal amount of candies.\\n2. So we can give 0 candies in minimum or we can give max(candies) to the students\\n3. Thus our search space will be 0 to max(candies)\\n4. Apply our binary search concept.\\n5. Find the middle and check if middle amount of candies can be distributed to k students, if yes, we need to find maximum, so we think there is more optimal answer to the right of our search space that will maximize our result, so update low = middle + 1 and store result = middle.\\n6. If we are not able to distribute middle amount of candies to k number of students, then any candies to the right of middle is also of no use, we need to explore the left part and move right = middle - 1;\\n7. Finally return our result.\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        if (candies == null || candies.length == 0) {\\n            return 0;\\n        }\\n        int low = 0;\\n        int high = findMax(candies);\\n        return binarySearch(candies, k, low, high);\\n    }\\n    \\n    public int binarySearch(int [] candies, long k, int low, int high) {\\n        int result = -1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (isPossibleToDivide(candies, middle, k)) {\\n                result = middle;\\n                low = middle + 1;\\n            }\\n            else {\\n                high = middle - 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isPossibleToDivide(int [] candies, int inHand, long k) {\\n        if (inHand == 0) {\\n            return true;\\n        }\\n        long total = 0;\\n        for (int num : candies) {\\n            total += (num) / inHand;\\n            if (total >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findMax(int [] candies) {\\n        int max = 0;\\n        for (int num : candies) {\\n            if (max < num) {\\n                max = num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        if (candies == null || candies.length == 0) {\\n            return 0;\\n        }\\n        int low = 0;\\n        int high = findMax(candies);\\n        return binarySearch(candies, k, low, high);\\n    }\\n    \\n    public int binarySearch(int [] candies, long k, int low, int high) {\\n        int result = -1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (isPossibleToDivide(candies, middle, k)) {\\n                result = middle;\\n                low = middle + 1;\\n            }\\n            else {\\n                high = middle - 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isPossibleToDivide(int [] candies, int inHand, long k) {\\n        if (inHand == 0) {\\n            return true;\\n        }\\n        long total = 0;\\n        for (int num : candies) {\\n            total += (num) / inHand;\\n            if (total >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findMax(int [] candies) {\\n        int max = 0;\\n        for (int num : candies) {\\n            if (max < num) {\\n                max = num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910615,
                "title": "cpp-easy-solution-binary-search",
                "content": "## **APPROACH**\\n* First check out how many number of maximum candies we can give to children if there were no constraints\\n* That would be dividing the sum in k children.\\n* So now we know our answer for number of candies we can give each child range from 1 to sum/k  and ( 0 in case of not enough candies)\\n* So find r which is sum/k and l which is 1\\n* And do binary search\\n* in this binary search we need to check that for a pile , how many parts we can create of mid number of candies.\\n* Then add all the parts we got of mid size.\\n* and if this number is more than k , it means , we can possibly give even more candies to each child , so decrease the search space and look for more number of candies that whether it could be a possible ans or not. \\n\\n\\n## **CODE**\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int>& candies, ll temp,ll k)\\n    {\\n        ll val=0;\\n        for(auto x:candies)\\n        {\\n            val+=(x/temp);\\n        }\\n        \\n        return val>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        // binary search \\n        // find range\\n        \\n        ll sum=0;\\n        for(auto x:candies)\\n        {\\n            sum+=x;\\n        }\\n        \\n        ll l=1,r=sum/k;\\n        \\n        if(r==0)\\n            return 0;\\n        \\n        // now do BS\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            \\n            bool check=isValid(candies,mid,k);\\n            \\n            if(check)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n\\n### **TIME-COMPLEXITY** :\\nO(nlogm)  where m can be 10^12 in worst case.\\n### **SPACE-COMPLEXITY**:\\nO(1)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int>& candies, ll temp,ll k)\\n    {\\n        ll val=0;\\n        for(auto x:candies)\\n        {\\n            val+=(x/temp);\\n        }\\n        \\n        return val>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        // binary search \\n        // find range\\n        \\n        ll sum=0;\\n        for(auto x:candies)\\n        {\\n            sum+=x;\\n        }\\n        \\n        ll l=1,r=sum/k;\\n        \\n        if(r==0)\\n            return 0;\\n        \\n        // now do BS\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            \\n            bool check=isValid(candies,mid,k);\\n            \\n            if(check)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910250,
                "title": "binary-search-c",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(vector<int> & candies, int num){\\n        long long ans = 0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=candies[i]/num;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int ans = 0;\\n        int high = 10000005;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            long long curr = calculate(candies,mid);\\n            if(curr>=k){\\n                low = mid+1;\\n                ans = mid;\\n            }\\n            else\\n                high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(vector<int> & candies, int num){\\n        long long ans = 0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=candies[i]/num;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int ans = 0;\\n        int high = 10000005;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            long long curr = calculate(candies,mid);\\n            if(curr>=k){\\n                low = mid+1;\\n                ans = mid;\\n            }\\n            else\\n                high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910232,
                "title": "c-solution-binary-search-faster-that-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long right = *max_element(candies.begin(), candies.end());\\n        long long left = 0;\\n        while(right > left){\\n            long long mid = (right + left + 1)/2;\\n            long long sum = 0;\\n            for(int i = 0;i < candies.size(); i++){\\n                sum += candies[i]/mid;\\n            }\\n            if (sum < k){\\n                right = mid - 1;\\n            }else if (sum >= k){\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long right = *max_element(candies.begin(), candies.end());\\n        long long left = 0;\\n        while(right > left){\\n            long long mid = (right + left + 1)/2;\\n            long long sum = 0;\\n            for(int i = 0;i < candies.size(); i++){\\n                sum += candies[i]/mid;\\n            }\\n            if (sum < k){\\n                right = mid - 1;\\n            }else if (sum >= k){\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909852,
                "title": "java-o-nlogn-solution",
                "content": "\\n\\n        \\n        long sum=0;\\n        for(int i:candies)\\n            sum+=i;\\n        long low=0,high=sum;\\n        long ans=0;\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            if(mid==0)\\n            {\\n                low=mid+1;\\n                continue;\\n            }\\n            long tmp=0;\\n            for(int i=0;i<candies.length;i++)\\n            {\\n                tmp+=candies[i]/mid;\\n            }\\n            if(tmp>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return (int)ans;\\n    \\n\\t",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\n\\n        \\n        long sum=0;\\n        for(int i:candies)\\n            sum+=i;\\n        long low=0,high=sum;\\n        long ans=0;\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            if(mid==0)\\n            {\\n                low=mid+1;\\n                continue;\\n            }\\n            long tmp=0;\\n            for(int i=0;i<candies.length;i++)\\n            {\\n                tmp+=candies[i]/mid;\\n            }\\n            if(tmp>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return (int)ans;\\n    \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1909799,
                "title": "left-right-1-2-vs-left-right-2",
                "content": "This post mainly focus on `(left+right+1)/2` and `(left+right)/2`.\\n\\n`mid = (left + right) / 2` to find *first* element valid\\n`mid = (left + right + 1) / 2` to find *last* element valid\\n\\nE.g. `[0, 1, 1, 1, 1]`\\n`mid = (left + right) / 2` would give index 1\\n`mid = (left + right + 1) / 2` would give index 5\\n\\nFor `mid = (left + right + 1) / 2`:\\n1. if `sum == k`, since we are going to find the last valid one, then move `left` till the very left: `left = mid`;\\n2. when go out of while loop, it\\'s getting to the first element NOT valid, so `right` need to decrement by one: `right = mid - 1`. So it would be:\\n\\n```\\nif (sum >= k) left = mid\\nelse right = mid -1\\n```\\nIf one wonders it\\'s `sum >= k` or `sum > k`, just take a moment think about if you want to first or last same element\\n\\nUsually we write `mid = (left + right) / 2` in\\n```\\nif (num[mid] < target) left = mid + 1\\nelse right = mid\\n```\\n\\nBtw, if using a helper `sum` function, be sure to return a `long` type not `int` otherwise you will hit error\\n\\nOriginal answer:\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        // binary search\\n        int left = 0, right = 10000000;\\n        \\n        while (left < right) {\\n            int mid = (left + right + 1) / 2;\\n\\n            // equal: go to the rightmost of these same numbers\\n            if (sum(candies, mid) >= k) \\n                left = mid;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private long sum(int[] candies, int mid) {\\n        long count = 0;\\n        for (int c : candies) {\\n            count += c / mid;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif (sum >= k) left = mid\\nelse right = mid -1\\n```\n```\\nif (num[mid] < target) left = mid + 1\\nelse right = mid\\n```\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        // binary search\\n        int left = 0, right = 10000000;\\n        \\n        while (left < right) {\\n            int mid = (left + right + 1) / 2;\\n\\n            // equal: go to the rightmost of these same numbers\\n            if (sum(candies, mid) >= k) \\n                left = mid;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private long sum(int[] candies, int mid) {\\n        long count = 0;\\n        for (int c : candies) {\\n            count += c / mid;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909786,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * log(max. element in array))***\\n* ***Space Complexity : O(1)***\\n\\n```\\n    bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n    bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909572,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        \\n        low,high = 0,sum(candies)\\n        while low < high:\\n            mid = low + (high - low)//2 + 1\\n            if sum(i//mid for i in candies) >= k:\\n                low = mid\\n            else:\\n                high = mid-1\\n                \\n        return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        \\n        low,high = 0,sum(candies)\\n        while low < high:\\n            mid = low + (high - low)//2 + 1\\n            if sum(i//mid for i in candies) >= k:\\n                low = mid\\n            else:\\n                high = mid-1\\n                \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909404,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nint maximumCandies(vector<int>& c, long long k) \\n    {\\n        // I got the intuition because it was following the pattern of breaking down the question into two parts, I had to check if a number was feasible to keep and also no way of obviously finding it anyway else. Check Koko Eating bananas and similar pattern questions\\n        \\n        int left = 1 ;\\n        int right = 1e9;\\n        int res = INT_MIN;\\n        \\n        int n = c.size();\\n        long long sum = 0;\\n        \\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            if(isfeasible(c,k,mid))\\n            {\\n                res = max(res,mid);\\n                left = mid+1;\\n            }\\n            \\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return res == INT_MIN? 0 : res; // if we didn\\'t find any feasible value and the result is the initial one we had\\n    }\\n    \\n    bool isfeasible(vector<int> &c, long long k, int candy)\\n    {\\n        // checking feasibility\\n        long long count = 0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            count+= c[i]/candy; // counting number of children that can have piles with \\'candy\\' number of candies\\n        }\\n        \\n        if(count>=k)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint maximumCandies(vector<int>& c, long long k) \\n    {\\n        // I got the intuition because it was following the pattern of breaking down the question into two parts, I had to check if a number was feasible to keep and also no way of obviously finding it anyway else. Check Koko Eating bananas and similar pattern questions\\n        \\n        int left = 1 ;\\n        int right = 1e9;\\n        int res = INT_MIN;\\n        \\n        int n = c.size();\\n        long long sum = 0;\\n        \\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            if(isfeasible(c,k,mid))\\n            {\\n                res = max(res,mid);\\n                left = mid+1;\\n            }\\n            \\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return res == INT_MIN? 0 : res; // if we didn\\'t find any feasible value and the result is the initial one we had\\n    }\\n    \\n    bool isfeasible(vector<int> &c, long long k, int candy)\\n    {\\n        // checking feasibility\\n        long long count = 0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            count+= c[i]/candy; // counting number of children that can have piles with \\'candy\\' number of candies\\n        }\\n        \\n        if(count>=k)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909394,
                "title": "java-c-greedy-binary-search-explained-easy-to-understand",
                "content": "Idea: .Minimun and maximum candies that can be given to a child form a monotonically increasing function.\\n    .Thus to find the maximum candies to a single child, binary search can be applied in the above mentioned search space\\n\\t\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& cd, long long k) {\\n        long long l = 0, r = 1E7;\\n        long long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            auto m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            auto cgc = 0LL;\\n            if(m != 0l)\\n            {\\n                for (auto x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int maximumCandies(int[] cd, long k) {\\n        long l = 0, r = 10000000;\\n        long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            var m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            var cgc = 0l;\\n            if(m != 0l)\\n            {\\n                for (var x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\nAny corrections, suggestions or optimizations to code are welcomed. :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& cd, long long k) {\\n        long long l = 0, r = 1E7;\\n        long long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            auto m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            auto cgc = 0LL;\\n            if(m != 0l)\\n            {\\n                for (auto x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maximumCandies(int[] cd, long k) {\\n        long l = 0, r = 10000000;\\n        long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            var m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            var cgc = 0l;\\n            if(m != 0l)\\n            {\\n                for (var x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909330,
                "title": "c-binary-search-on-asnwer",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    bool isPossible(vector<int>& candies, ll k , ll mid ){\\n        ll children = 0 ;\\n        for(auto &x : candies) children += x / mid ;\\n        return children >= k ;\\n        \\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll totalCandies = accumulate(begin(candies),end(candies),0LL) ;\\n        ll lo = 1 , hi = totalCandies/k ;\\n        \\n        int ans = -1 ;\\n        while(lo <= hi){\\n            ll mid = lo + (hi-lo)/2LL ;\\n            if(isPossible(candies,k,mid)){\\n               ans = mid ;\\n               lo = mid + 1 ;\\n            }\\n            else hi = mid - 1 ;\\n        }\\n        return ans==-1 ? 0 : ans  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    bool isPossible(vector<int>& candies, ll k , ll mid ){\\n        ll children = 0 ;\\n        for(auto &x : candies) children += x / mid ;\\n        return children >= k ;\\n        \\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll totalCandies = accumulate(begin(candies),end(candies),0LL) ;\\n        ll lo = 1 , hi = totalCandies/k ;\\n        \\n        int ans = -1 ;\\n        while(lo <= hi){\\n            ll mid = lo + (hi-lo)/2LL ;\\n            if(isPossible(candies,k,mid)){\\n               ans = mid ;\\n               lo = mid + 1 ;\\n            }\\n            else hi = mid - 1 ;\\n        }\\n        return ans==-1 ? 0 : ans  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909268,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int ans = 0;\\n        int l = 0,h = INT_MAX,m;\\n        while(l <= h) {\\n            m = l + (h -l )/2;\\n            if(isPossible(candies, m, k)) {\\n                ans = max(ans, m);\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& candies, int amount, long long k) {\\n        long long sum = 0;\\n        long long int cnt = 0;\\n        for(int candie : candies) {\\n            if(candie >= amount && amount != 0) cnt += candie/amount;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int ans = 0;\\n        int l = 0,h = INT_MAX,m;\\n        while(l <= h) {\\n            m = l + (h -l )/2;\\n            if(isPossible(candies, m, k)) {\\n                ans = max(ans, m);\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& candies, int amount, long long k) {\\n        long long sum = 0;\\n        long long int cnt = 0;\\n        for(int candie : candies) {\\n            if(candie >= amount && amount != 0) cnt += candie/amount;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909224,
                "title": "c-binary-search",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint help(ll mid,vector<int>&nums,ll k){\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++) res+=(nums[i]/mid);\\n\\t\\t\\treturn res>=k;\\n\\t\\t}\\n\\n\\t\\tint maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tll i = 1, j = 1e9;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tll mid = (i+j)/2;\\n\\t\\t\\t\\tif(help(mid,candies,k)) i = mid+1;\\n\\t\\t\\t\\telse j = mid-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn i-1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint help(ll mid,vector<int>&nums,ll k){\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++) res+=(nums[i]/mid);\\n\\t\\t\\treturn res>=k;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1909207,
                "title": "java-efficient-binary-search-approach-explained",
                "content": "**Find total candies**\\n\\tif `total < k,` then we cannot give candy to all child, so `return 0`.\\n\\tif `total == k`, then each child can get only `1 candy`.\\n\\nOtherwise,\\n\\tUse binary search to find possible candies.\\n\\tHere, `high = total / k` as this is maximum we can assign to each child.\\n\\tFor each mid, find **how many piles can be created** `(candy / mid)`. If numbers of piles i.e. `sum >= k` then we can assign atleast `mid` candies.\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long total = 0;\\n        for (int candy : candies) {\\n            total += candy;\\n        }\\n        if (total < k) {\\n            return 0;\\n        }\\n        if (total == k) {\\n            return 1;\\n        }\\n        long low = 1;\\n        long high = total / k;\\n        int ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / 2;\\n            long sum = 0;\\n            for (int candy: candies) {\\n                sum += (candy / mid);\\n            }\\n            if (sum >= k) {\\n                ans = (int) mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long total = 0;\\n        for (int candy : candies) {\\n            total += candy;\\n        }\\n        if (total < k) {\\n            return 0;\\n        }\\n        if (total == k) {\\n            return 1;\\n        }\\n        long low = 1;\\n        long high = total / k;\\n        int ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / 2;\\n            long sum = 0;\\n            for (int candy: candies) {\\n                sum += (candy / mid);\\n            }\\n            if (sum >= k) {\\n                ans = (int) mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909168,
                "title": "binary-search-similar-approach-as-book-allocation-problem-in-cpp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& can, long long k) {\\n        int l=1,h=*max_element(can.begin(),can.end());  //here l initialised by 1 for the case when h=1\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            long long cnt=0;\\n            if(mid==0)\\n                break;\\n            for(int i=0;i<can.size();i++)\\n            {\\n                cnt+=1ll*can[i]/mid;\\n            }\\n            if(cnt>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& can, long long k) {\\n        int l=1,h=*max_element(can.begin(),can.end());  //here l initialised by 1 for the case when h=1\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            long long cnt=0;\\n            if(mid==0)\\n                break;\\n            for(int i=0;i<can.size();i++)\\n            {\\n                cnt+=1ll*can[i]/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909006,
                "title": "c-binary-search-faster-than-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]);\\n        }\\n        if(k==1)return mx;\\n        long long l=0,h=mx;\\n        long long ans=0;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            if(solve(nums,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int solve(vector<int> nums,long long val,long long k){\\n        if(val==0)return true;\\n        long long c=0;\\n        for(int i=0;i<nums.size();i++){\\n            c+=nums[i]/val;\\n        }\\n        if(c>=k)return true;\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908944,
                "title": "binary-search-time-o-nlogn-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,long long k, vector<int>&candies)\\n    {\\n        long long temp=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            temp+=candies[i]/mid;\\n            if(temp>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            sum+=candies[i];\\n        }\\n        long long l=1,h=sum;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            \\n            if(check(mid,k,candies))\\n            {\\n                ans=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,long long k, vector<int>&candies)\\n    {\\n        long long temp=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            temp+=candies[i]/mid;\\n            if(temp>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            sum+=candies[i];\\n        }\\n        long long l=1,h=sum;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            \\n            if(check(mid,k,candies))\\n            {\\n                ans=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908896,
                "title": "c-binary-search-clean-and-concise",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        \\n        ll sum=0;\\n        for(auto i:candies)\\n            sum+=i;\\n        if(sum<k)\\n            return 0;\\n        ll low=1;\\n        ll high=1e15;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n           ll st=0;\\n            for(auto i:candies)\\n            {\\n                if(mid!=0)\\n                st+=(i/mid);\\n            }\\n            if(st>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        \\n        ll sum=0;\\n        for(auto i:candies)\\n            sum+=i;\\n        if(sum<k)\\n            return 0;\\n        ll low=1;\\n        ll high=1e15;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n           ll st=0;\\n            for(auto i:candies)\\n            {\\n                if(mid!=0)\\n                st+=(i/mid);\\n            }\\n            if(st>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908845,
                "title": "easy-python-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 1, max(candies)\\n        while l <= r:\\n            m = (l + r)//2\\n            if self.countPile(candies, m) >= k:\\n                if self.countPile(candies, m + 1) < k: return m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return 0\\n                \\n    def countPile(self, candies, pileSize):\\n        return sum(candy//pileSize for candy in candies)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 1, max(candies)\\n        while l <= r:\\n            m = (l + r)//2\\n            if self.countPile(candies, m) >= k:\\n                if self.countPile(candies, m + 1) < k: return m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return 0\\n                \\n    def countPile(self, candies, pileSize):\\n        return sum(candy//pileSize for candy in candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908844,
                "title": "java-simple-binarysearch-tc-o-n-log-max",
                "content": "Solution:\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```\\n\\n**TimeComplexity:** O(N * log(Max)) where N is the number of candies.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908830,
                "title": "c-easy-binary-search",
                "content": "Approach:\\n* Firstly we will take given range and apply binary search.\\n* low will be 1 as min 1 candy shoud be given and high is upper limit of candy group in given constraint i.e 10^7.\\n* Firstly we will calculate mid and check if candy pile of k forms k groups or not if it is forming more than or equal to k groups then  we can take it as a possible answer and take low=mid+1 because we have to find max answer and there might exist any number more than mid that may satisfy given condition. if groups of mid are less than k then we have to search in left part fo high=mid-1.\\n    \\nComplexity:\\n* \\tTime: O(n log (10^7)) we are using binary search from 1 to 10^7 so log (10^7) and at each step we have to traverse array so it is multiplied by n.\\n* \\tSpace: O(1)\\n```\\t\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll low=1,high=10000001;\\n        int answer=0;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll groups=getGroups(candies,mid);\\n            if(groups>=k){\\n\\t\\t\\t\\t//probable any might be mid.\\n                answer=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    ll getGroups(vector<int> &candies,ll mid){\\n        ll groups=0;\\n        for(auto can:candies){\\n            groups+=(can/mid);\\n        }\\n        return groups;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\t\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll low=1,high=10000001;\\n        int answer=0;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll groups=getGroups(candies,mid);\\n            if(groups>=k){\\n\\t\\t\\t\\t//probable any might be mid.\\n                answer=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    ll getGroups(vector<int> &candies,ll mid){\\n        ll groups=0;\\n        for(auto can:candies){\\n            groups+=(can/mid);\\n        }\\n        return groups;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908821,
                "title": "c-binary-search-concise",
                "content": "```\\nclass Solution{\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0, n = candies.size();\\n        for(int i =0;i<n;i++){\\n            sum+= candies[i];\\n        }\\n        if(k>sum) return 0;\\n        long long lower = 1;\\n        long long upper = sum/k;\\n        \\n        long long ans = 0;\\n        \\n        while(lower<=upper){ \\n             long long mid = lower + (upper-lower)/2;\\n             long long count = 0;\\n             for(int i =0;i<n;i++){\\n                count+= candies[i]/mid;\\n             }\\n             if(count>=k){\\n                ans = max(ans,mid);\\n                lower = mid+1;\\n             }\\n             else{\\n                upper = mid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0, n = candies.size();\\n        for(int i =0;i<n;i++){\\n            sum+= candies[i];\\n        }\\n        if(k>sum) return 0;\\n        long long lower = 1;\\n        long long upper = sum/k;\\n        \\n        long long ans = 0;\\n        \\n        while(lower<=upper){ \\n             long long mid = lower + (upper-lower)/2;\\n             long long count = 0;\\n             for(int i =0;i<n;i++){\\n                count+= candies[i]/mid;\\n             }\\n             if(count>=k){\\n                ans = max(ans,mid);\\n                lower = mid+1;\\n             }\\n             else{\\n                upper = mid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908813,
                "title": "binary-search-same-as-koko-eating-bananas-python3",
                "content": "This problem is the very similar to the [Koko Eating bananas](https://leetcode.com/problems/koko-eating-bananas/). In fact, the only thing that changes in the condition and boundaries.\\n\\n\\n```\\ndef maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def can_take(target):\\n            count = 0\\n            for candy in candies:\\n                if candy >= target:\\n                    count += (candy // target) # Find out how many children this pile can feed :) \\n            return count >= k   # Make sure that we have enough to feed all the children\\n        \\n        l, r = 1, max(candies)\\n        res = 0\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can_take(m):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def can_take(target):\\n            count = 0\\n            for candy in candies:\\n                if candy >= target:\\n                    count += (candy // target) # Find out how many children this pile can feed :) \\n            return count >= k   # Make sure that we have enough to feed all the children\\n        \\n        l, r = 1, max(candies)\\n        res = 0\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can_take(m):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1908805,
                "title": "python-java-binary-search",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = sum(candies)\\n\\t\\t\\tif r < k:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdef allocate(m):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor candy in candies:\\n\\t\\t\\t\\t\\tcnt += candy // m\\n\\t\\t\\t\\treturn cnt\\n\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif allocate(m) < k:\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = m\\n\\t\\t\\tif allocate(r) >= k:\\n\\t\\t\\t\\treturn r\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn l\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumCandies(int[] candies, long k) {\\n\\t\\t\\tlong l = 1;\\n\\t\\t\\tlong r = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tr += candy;\\n\\t\\t\\t}\\n\\t\\t\\tif (r < k) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\twhile (l + 1 < r) {\\n\\t\\t\\t\\tlong m = (r - l) / 2 + l;\\n\\t\\t\\t\\tif (allocate(candies, m) < k) {\\n\\t\\t\\t\\t\\tr = m - 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tl = m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (allocate(candies, r) >= k) {\\n\\t\\t\\t\\treturn (int)r;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn (int)l;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate long allocate(int[] candies, long m) {\\n\\t\\t\\tlong cnt = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tcnt += candy / m;\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t} \\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = sum(candies)\\n\\t\\t\\tif r < k:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdef allocate(m):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor candy in candies:\\n\\t\\t\\t\\t\\tcnt += candy // m\\n\\t\\t\\t\\treturn cnt\\n\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif allocate(m) < k:\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = m\\n\\t\\t\\tif allocate(r) >= k:\\n\\t\\t\\t\\treturn r\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn l\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumCandies(int[] candies, long k) {\\n\\t\\t\\tlong l = 1;\\n\\t\\t\\tlong r = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tr += candy;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1908799,
                "title": "python-binary-search-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python] \\uD83C\\uDF1F Binary Search Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\nWe can greedy test every potential target from 1~ total//k.\\nSo we use binary Search to find our maximum target.\\n* canDivide: Simply use res += candy // target. To check whether a candy pile could split into how many piles to fit the target.\\n\\n## Complexity Analysis\\n* Time: O(NlogN)\\n* Space: O(1)\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        total = sum(candies)\\n        if total < k:\\n            return 0\\n        \\n        # We can test our current target is valid\\n        def canDivide(target):\\n            res = 0\\n            for candy in candies:\\n                res += candy // target\\n            return res >= k\\n        \\n        # Greedy high would be total // k\\n        low, high = 1, total // k\\n        res = 0\\n        # Binary Search\\n        while low <= high:\\n            target = low + (high - low) // 2\\n            if canDivide(target):\\n                res = target\\n                low = target + 1\\n            else:\\n                high = target - 1\\n        return res\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        total = sum(candies)\\n        if total < k:\\n            return 0\\n        \\n        # We can test our current target is valid\\n        def canDivide(target):\\n            res = 0\\n            for candy in candies:\\n                res += candy // target\\n            return res >= k\\n        \\n        # Greedy high would be total // k\\n        low, high = 1, total // k\\n        res = 0\\n        # Binary Search\\n        while low <= high:\\n            target = low + (high - low) // 2\\n            if canDivide(target):\\n                res = target\\n                low = target + 1\\n            else:\\n                high = target - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908787,
                "title": "c-binary-search-o-nlogn-intiution-comments",
                "content": "intiution : our search space(no of candies we can allocate) will be 1  to max number in array . if we can allocate a particular number of candy then search for next higher number else search number lower than that particular number.\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int maxCand = INT_MIN;\\n        long long s = 0;\\n        for(int i = 0;i < candies.size();i++){\\n            if(candies[i] > maxCand)\\n                maxCand = candies[i];\\n            s += candies[i];\\n        }\\n\\t\\t// if total number of candies are less than the no of children then we can never allocate same number of candies to children hence return 0\\n        if(k > s)\\n            return 0;\\n        int l = 1;\\n        int h = maxCand;\\n        while(l <= h){\\n            int mid = l + (h - l) / 2;\\n            long long sum = 0;\\n            for(int i =a 0;i < candies.size();i++){\\n\\t\\t\\t// mid means the number that we check if we can allocate that number of candy to children.\\n\\t\\t\\t// [ 5 8 6] and if mid = 2 then we can get 2 piles of 2 candies from 5 and 2 piles from 8 and 3 piles from 6.\\n                sum += candies[i] / mid;\\n            }\\n\\t\\t\\t// if total no of piles of mid number candy is >= k then we can allocate mid number candy to children hence check for next higher possible number.\\n            if(sum >= k)\\n                l = mid + 1;\\n\\t\\t\\t\\t// else check for lower number than mid.\\n            else\\n                h = mid - 1;\\n        }\\n\\t\\t// at end h points to a maximum number that we can allocate to children.\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int maxCand = INT_MIN;\\n        long long s = 0;\\n        for(int i = 0;i < candies.size();i++){\\n            if(candies[i] > maxCand)\\n                maxCand = candies[i];\\n            s += candies[i];\\n        }\\n\\t\\t// if total number of candies are less than the no of children then we can never allocate same number of candies to children hence return 0\\n        if(k > s)\\n            return 0;\\n        int l = 1;\\n        int h = maxCand;\\n        while(l <= h){\\n            int mid = l + (h - l) / 2;\\n            long long sum = 0;\\n            for(int i =a 0;i < candies.size();i++){\\n\\t\\t\\t// mid means the number that we check if we can allocate that number of candy to children.\\n\\t\\t\\t// [ 5 8 6] and if mid = 2 then we can get 2 piles of 2 candies from 5 and 2 piles from 8 and 3 piles from 6.\\n                sum += candies[i] / mid;\\n            }\\n\\t\\t\\t// if total no of piles of mid number candy is >= k then we can allocate mid number candy to children hence check for next higher possible number.\\n            if(sum >= k)\\n                l = mid + 1;\\n\\t\\t\\t\\t// else check for lower number than mid.\\n            else\\n                h = mid - 1;\\n        }\\n\\t\\t// at end h points to a maximum number that we can allocate to children.\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908745,
                "title": "binary-search-clean-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean valid(int mid, int candies[], long k){\\n      \\n        long c=0;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            int val=candies[i];\\n            c+=val/mid;\\n            if(c>=k){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            max=Math.max(candies[i],max);\\n        }\\n        \\n        int low=1;\\n        int high=max;\\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low +(high-low) / 2;\\n            \\n            if(valid(mid,candies,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean valid(int mid, int candies[], long k){\\n      \\n        long c=0;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            int val=candies[i];\\n            c+=val/mid;\\n            if(c>=k){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            max=Math.max(candies[i],max);\\n        }\\n        \\n        int low=1;\\n        int high=max;\\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low +(high-low) / 2;\\n            \\n            if(valid(mid,candies,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908742,
                "title": "python-binary-search",
                "content": "\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\n        n = len(candies)\\n        \\n        if k > sum(candies):\\n            return 0\\n        \\n        def check(m):\\n            cnt = 0\\n            for c in candies:\\n                cnt += c//m\\n            \\n            if cnt >= k:\\n                return True\\n            else:\\n                return False\\n        \\n        l = 1\\n        r = max(candies)\\n        \\n        while l < r:\\n            m = l + (r-l+1)//2\\n            \\n            if check(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n        \\n",
                "solutionTags": [],
                "code": "\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\n        n = len(candies)\\n        \\n        if k > sum(candies):\\n            return 0\\n        \\n        def check(m):\\n            cnt = 0\\n            for c in candies:\\n                cnt += c//m\\n            \\n            if cnt >= k:\\n                return True\\n            else:\\n                return False\\n        \\n        l = 1\\n        r = max(candies)\\n        \\n        while l < r:\\n            m = l + (r-l+1)//2\\n            \\n            if check(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1908739,
                "title": "easy-concept-using-binary-search",
                "content": "\\nSimply do binary search, \\'guess\\' the max number of candies each child can get\\nsearching range: left = 0, right = (sum(candies)//k)+1\\nin each guess, we go through the whole candies array and check whether this guess is valid\\n\\ntime complexity: O(logS)*O(N), where S is the span of searching range\\nspace complexity: O(1)\\n\\n```\\nfrom typing import List\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        def is_valid(x):\\n            if x == 0: return True\\n            cnt = 0\\n            for p in candies:\\n                if p >= x:              # we can divide pile into any number of sub-piles\\n                    cnt += p//x\\n                if cnt >= k:\\n                    return True\\n            return False\\n        \\n        l, r = 0, (sum(candies)//k)+1\\n        while l < r:\\n            m = (l+r+1)//2\\n            if is_valid(m):             # everyone can get m candies, but could get more: try bigger m\\n                l = m\\n            else:\\n                r = m-1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nfrom typing import List\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        def is_valid(x):\\n            if x == 0: return True\\n            cnt = 0\\n            for p in candies:\\n                if p >= x:              # we can divide pile into any number of sub-piles\\n                    cnt += p//x\\n                if cnt >= k:\\n                    return True\\n            return False\\n        \\n        l, r = 0, (sum(candies)//k)+1\\n        while l < r:\\n            m = (l+r+1)//2\\n            if is_valid(m):             # everyone can get m candies, but could get more: try bigger m\\n                l = m\\n            else:\\n                r = m-1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908704,
                "title": "binary-search-c-o-nlogk",
                "content": "```\\n// use binary search to get optimum valuse\\n// O(n)\\n\\nclass Solution {\\npublic:\\n    bool check( long long mid, vector<int> &candies, long long k){\\n        long long cnt=0;\\n        for(auto c : candies){\\n            cnt += 1ll*c/mid;\\n        }\\n        return cnt >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=0, hi = 1e12+1;  // check for highest possible (although it will be max(candies))\\n        while(lo < hi){\\n            long long mid = lo+(hi-lo+1)/2;  \\n            if(mid == 0)\\n                return 0;\\n            if(check(mid, candies, k))\\n                lo = mid;\\n            else\\n                hi = mid-1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n// use binary search to get optimum valuse\\n// O(n)\\n\\nclass Solution {\\npublic:\\n    bool check( long long mid, vector<int> &candies, long long k){\\n        long long cnt=0;\\n        for(auto c : candies){\\n            cnt += 1ll*c/mid;\\n        }\\n        return cnt >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=0, hi = 1e12+1;  // check for highest possible (although it will be max(candies))\\n        while(lo < hi){\\n            long long mid = lo+(hi-lo+1)/2;  \\n            if(mid == 0)\\n                return 0;\\n            if(check(mid, candies, k))\\n                lo = mid;\\n            else\\n                hi = mid-1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908700,
                "title": "easy-to-understand-with-detailed-explanation-and-java-code-binary-search",
                "content": "***Please upvote if you find this helpful :)***\\n\\nA typical binary search implemetation. \\n\\nWe need to find the maximum candies every child can get. We take a lower and an upper bound and try to find if the current candy count can be given to every child or not. In case it can be given, then we try to find the same thing for a higher candy count and hence update our low to mid+1. In case, the current count is not valid, then we decrease the count to high = mid-1\\n\\nEdge case - If the sum of candies is less than no of students then the candies can\\'t be distributed and the ans will be 0.\\n\\n```\\nclass Solution {\\n    \\n    private boolean isValid(int[] candies, long k, int target){\\n        long ans = 0;\\n        for(int candy: candies){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += (long)(candy/target);\\n        }\\n        return (ans>=k);\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 0;\\n        int high = 10000000;\\n        int ans = 0;\\n        long sum = 0;\\n        for(int candy: candies){\\n            sum += candy;\\n        }\\n        if(sum<k){\\n            return 0;\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isValid(candies,k,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isValid(int[] candies, long k, int target){\\n        long ans = 0;\\n        for(int candy: candies){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += (long)(candy/target);\\n        }\\n        return (ans>=k);\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 0;\\n        int high = 10000000;\\n        int ans = 0;\\n        long sum = 0;\\n        for(int candy: candies){\\n            sum += candy;\\n        }\\n        if(sum<k){\\n            return 0;\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isValid(candies,k,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908698,
                "title": "c-binary-search-on-search-space-o-n-log-m-time-o-1-space",
                "content": "\\n**Binary search on Search space**\\nWe can atleast give 1 candy  and atmost max(candies) to each child. So, we binary search between 1 to max(candies).\\n\\n**How do we check, if we can give X candies to K children?**\\nIf we divide candy heaps into K or more sub heapes of size X. So, we try to divide each candy heap and see how many candy sub heaps of size X we can form. Sum of all X candy heaps in the array >= K children. Then we can say, we can divide X candies to K children.\\n\\n**Time complexity:** O(n log m), where n = size of array & m = max element in array\\n**Space complexity:** O(1)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, long long k, int val) {\\n        long long count = 0;\\n        for(int candy: candies) {\\n            count += candy / val;\\n        }\\n        \\n        return count >= k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int left = 1;\\n        int right = INT_MIN;\\n        long long sum = 0;\\n        for(int candy: candies) { \\n            right = max(right, candy);\\n            sum += candy;\\n        }\\n        \\n        if(sum < k) { return 0; }\\n        \\n        long long result = 0;\\n        while(left <= right) {\\n            long long mid = left + (right - left) / 2;\\n            if(isPossible(candies, k, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, long long k, int val) {\\n        long long count = 0;\\n        for(int candy: candies) {\\n            count += candy / val;\\n        }\\n        \\n        return count >= k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int left = 1;\\n        int right = INT_MIN;\\n        long long sum = 0;\\n        for(int candy: candies) { \\n            right = max(right, candy);\\n            sum += candy;\\n        }\\n        \\n        if(sum < k) { return 0; }\\n        \\n        long long result = 0;\\n        while(left <= right) {\\n            long long mid = left + (right - left) / 2;\\n            if(isPossible(candies, k, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052744,
                "title": "c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search approach similar to koko eating bananas\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool noOfCandies(vector<int> candies,int n,long long candiesPerChild,long long totalNoOfKids){\\n        long long noOfKidsWithCandies=0;\\n        for(int i=0;i<n;i++){\\n            noOfKidsWithCandies+=candies[i]/candiesPerChild;\\n            if(noOfKidsWithCandies>=totalNoOfKids){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long low=1;\\n        long long high=0;\\n        for(int i=0;i<n;i++){\\n            high+=candies[i];\\n        }\\n        if(k>high){\\n            return 0;\\n        }\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;\\n            if(noOfCandies(candies,n,mid,k)){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool noOfCandies(vector<int> candies,int n,long long candiesPerChild,long long totalNoOfKids){\\n        long long noOfKidsWithCandies=0;\\n        for(int i=0;i<n;i++){\\n            noOfKidsWithCandies+=candies[i]/candiesPerChild;\\n            if(noOfKidsWithCandies>=totalNoOfKids){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long low=1;\\n        long long high=0;\\n        for(int i=0;i<n;i++){\\n            high+=candies[i];\\n        }\\n        if(k>high){\\n            return 0;\\n        }\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;\\n            if(noOfCandies(candies,n,mid,k)){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024376,
                "title": "exactly-the-same-as-koko-eat-banana",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        for (int candy : candies) max = Math.max(max, candy);\\n        int l = 0, r = max;\\n        while (l < r) {\\n            System.out.println(l + \" \" + r);\\n            int mid = r - (r - l ) / 2; // mid as unit\\n            if (canDivide(candies, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n\\n    private boolean canDivide(int[] candies, long k, int unit) {\\n        if (unit == 0) return true; // This is different from koko question\\n        long cnt = 0;\\n        for (int candy : candies) {\\n            cnt += (long) candy / unit;\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        for (int candy : candies) max = Math.max(max, candy);\\n        int l = 0, r = max;\\n        while (l < r) {\\n            System.out.println(l + \" \" + r);\\n            int mid = r - (r - l ) / 2; // mid as unit\\n            if (canDivide(candies, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n\\n    private boolean canDivide(int[] candies, long k, int unit) {\\n        if (unit == 0) return true; // This is different from koko question\\n        long cnt = 0;\\n        for (int candy : candies) {\\n            cnt += (long) candy / unit;\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023068,
                "title": "c-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long x=*max_element(candies.begin(),candies.end());\\n        long long low=1,high=x;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long cnt=0;\\n            for(int i=0;i<candies.size();i++){\\n                cnt=cnt+candies[i]/mid;\\n            }\\n            if(cnt>=k){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long x=*max_element(candies.begin(),candies.end());\\n        long long low=1,high=x;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long cnt=0;\\n            for(int i=0;i<candies.size();i++){\\n                cnt=cnt+candies[i]/mid;\\n            }\\n            if(cnt>=k){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988243,
                "title": "9-o-n-solution-using-binary-search",
                "content": "# Intuition\\nbecause equal no. of candies have to be distributed among k children, so we will have to check the feasibility of the number of candies that can be distributed.\\n\\nex: for cadies [ 5, 6, 8] and k = 3,\\nwe have to distriburte among k = 3 children, so we will find the largest number that can be extracted from any of the indexes k (3) times.\\nIt can be in different indexes or the same indexes.\\nfor the above example, it can be sub-divided into\\n[5, [5, 1], [5, 3]], so we can have 5 as the largest number of candies that can be distributed.\\n\\nif we had candies: [2, 20], k = 3;\\nhere we simply have to divide 20 into 3 equal numbers\\n[2, [6, 6, 6, 2]]\\nin the above we have 6 as an answer.\\n\\ntry solving problem number : 875\\n# Approach\\nfor every feasible number T from 1 -> totalSumOfCandies / n candies, we will check for each of them if its feasible or not to divide the array on that number T.\\nwe will use BS for this\\n\\n\\n# Complexity\\n- Time complexity:\\nN*O(N)\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tint n = candies.size();\\n\\n\\t\\t\\tlong long totalCandies = accumulate(begin(candies),end(candies),0ll);\\n\\n\\t\\t\\tif(totalCandies < k)\\treturn 0;\\n\\n\\t\\t\\tlong long s = 1, e = totalCandies/k;\\n\\t\\t\\tlong long mid = -1;\\n\\n\\t\\t\\twhile(s <= e) {\\n\\t\\t\\t\\tmid = s + (e-s)/2;\\n\\n\\t\\t\\t\\tlong int cnt = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif(candies[i] >= mid)\\n\\t\\t\\t\\t\\t\\tcnt += 1ll*(candies[i]/mid);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt >= k)\\ts = mid+1;\\n\\t\\t\\t\\telse\\t\\t\\te = mid-1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\t\\t}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tint n = candies.size();\\n\\n\\t\\t\\tlong long totalCandies = accumulate(begin(candies),end(candies),0ll);\\n\\n\\t\\t\\tif(totalCandies < k)\\treturn 0;\\n\\n\\t\\t\\tlong long s = 1, e = totalCandies/k;\\n\\t\\t\\tlong long mid = -1;\\n\\n\\t\\t\\twhile(s <= e) {\\n\\t\\t\\t\\tmid = s + (e-s)/2;\\n\\n\\t\\t\\t\\tlong int cnt = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif(candies[i] >= mid)\\n\\t\\t\\t\\t\\t\\tcnt += 1ll*(candies[i]/mid);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt >= k)\\ts = mid+1;\\n\\t\\t\\t\\telse\\t\\t\\te = mid-1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\t\\t}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963858,
                "title": "simple-python-solution",
                "content": "# Intuition\\nThis is similar to minimizing the result but now we have to find the maximum that satisfies some condition. If you remember firstBadVersion problem, you know we didn\\'t stop until we found the result, the only difference is minimum lies on the left side of our inputs, and maximum on the right side. \\n\\n# Approach\\nBinary Search and narrow down till we have our result.\\n\\n# Code\\n```\\ndef success(number, candies, children):    \\n    count = 0\\n    for candy in candies:\\n        if number > 0:\\n            count += math.floor(candy/number)\\n        \\n        if count >= children:\\n            return True\\n    \\n    return False\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n\\n        left = 1\\n        right = max(set(candies))\\n\\n        result = 0\\n        while left <= right:\\n            mid  = (left + right)//2\\n            if success(mid, candies, k):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef success(number, candies, children):    \\n    count = 0\\n    for candy in candies:\\n        if number > 0:\\n            count += math.floor(candy/number)\\n        \\n        if count >= children:\\n            return True\\n    \\n    return False\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n\\n        left = 1\\n        right = max(set(candies))\\n\\n        result = 0\\n        while left <= right:\\n            mid  = (left + right)//2\\n            if success(mid, candies, k):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947592,
                "title": "c-solution-faster-than-95",
                "content": "# Intuition\\nImplementation of Book Allocation problem using Binary Search\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> arr, long long k, int mid) {\\n        long long int children = 0;\\n        for (int i : arr) {\\n            children += i / mid;\\n            if (children >= k) return true;\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int start = 1;\\n        long long int end = *max_element(candies.begin(), candies.end());;\\n        long long int mid = start + (end - start) / 2;\\n        long long int ans = 0;\\n\\n        while(start <= end) {\\n            if(isPossible(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n            mid = start + (end - start) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach\\nI\\'ll try to explain using a testcase and dry run:\\n\\n### Input:\\ncandies = [5, 8, 6]\\nk = 3\\n\\n\\n\\n### Dry Run:\\n\\n1. Initialize start as 1, end as the maximum element in candies, which is 8, and mid as (1 + 8) / 2 = 4. ans is initialized as 0.\\n\\n\\n2. Enter the binary search loop:\\n- Check if it\\'s possible to distribute candies with mid = 4 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 4, which is 1.\\n        - For the second pile of 8 candies, children += 8 / 4, which is 3.\\n        - For the third pile of 6 candies, children += 6 / 4, which is 4.\\n    - Check if children (4) is greater than or equal to k (3). It\\'s true.\\n    - Set ans to 4 and update start to mid + 1, which is 5.\\n    - Update mid to (5 + 8) / 2 = 6.\\n\\n\\n3. Loop again:\\n- Check if it\\'s possible to distribute candies with mid = 6 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 6, which is 0.\\n        - For the second pile of 8 candies, children += 8 / 6, which is 1.\\n        - For the third pile of 6 candies, children += 6 / 6, which is 1.\\n    - Check if children (1) is greater than or equal to k (3). It\\'s false.\\n    - Update end to mid - 1, which is 5.\\n    - Update mid to (5 + 5) / 2 = 5.\\n\\n\\n4. Loop again:\\n- Check if it\\'s possible to distribute candies with mid = 5 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 5, which is 1.\\n        - For the second pile of 8 candies, children += 8 / 5, which is 2.\\n        - For the third pile of 6 candies, children += 6 / 5, which is 3.\\n    - Check if children (3) is greater than or equal to k (3). It\\'s true.\\n    - Set ans to 5 and update start to mid + 1, which is 6.\\n    - Update mid to (6 + 5) / 2 = 5.\\n\\n5. Since start is not less than or equal to end, the loop ends.\\n\\n\\n### Output:\\nThe function returns ans, which is 5. This means each child can receive at most 5 candies.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n * log(max_element))\\n\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> arr, long long k, int mid) {\\n        long long int children = 0;\\n        for (int i : arr) {\\n            children += i / mid;\\n            if (children >= k) return true;\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int start = 1;\\n        long long int end = *max_element(candies.begin(), candies.end());;\\n        long long int mid = start + (end - start) / 2;\\n        long long int ans = 0;\\n\\n        while(start <= end) {\\n            if(isPossible(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n            mid = start + (end - start) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936994,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n     public int MaximumCandies(int[] candies, long k)\\n    {\\n        long left = 1;\\n        long right = 0;\\n\\n        long sum = 0;\\n        foreach (var candy in candies)\\n        {\\n            sum += candy;\\n        }\\n\\n        right = sum / k;\\n        var answer = 0;\\n        \\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var count = CalculateCandies(mid, candies);\\n            \\n            if (count < k)\\n            {\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                answer = (int)mid;\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    long CalculateCandies(long mid, int[] candies)\\n    {\\n        long count = 0;\\n        \\n        foreach (var candy in candies)\\n        {\\n            if (candy >= mid)\\n            {\\n                count += candy / mid;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n     public int MaximumCandies(int[] candies, long k)\\n    {\\n        long left = 1;\\n        long right = 0;\\n\\n        long sum = 0;\\n        foreach (var candy in candies)\\n        {\\n            sum += candy;\\n        }\\n\\n        right = sum / k;\\n        var answer = 0;\\n        \\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var count = CalculateCandies(mid, candies);\\n            \\n            if (count < k)\\n            {\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                answer = (int)mid;\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    long CalculateCandies(long mid, int[] candies)\\n    {\\n        long count = 0;\\n        \\n        foreach (var candy in candies)\\n        {\\n            if (candy >= mid)\\n            {\\n                count += candy / mid;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931339,
                "title": "easy-binary-search-solution",
                "content": "Using Binary search optimized approach\\n\\n```\\nclass Solution {\\npublic:\\n    bool func(long long n,vector<int>& arr,long long k)\\n    {\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++)\\n            res+=(long long)arr[i]/n;\\n        return res>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,n=candies.size();\\n        long long h=1;\\n        for(int i=0;i<n;i++)\\n            h=max(h,(long long)candies[i]);\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=(l+h)/2;\\n            if(func(mid,candies,k))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(long long n,vector<int>& arr,long long k)\\n    {\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++)\\n            res+=(long long)arr[i]/n;\\n        return res>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,n=candies.size();\\n        long long h=1;\\n        for(int i=0;i<n;i++)\\n            h=max(h,(long long)candies[i]);\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=(l+h)/2;\\n            if(func(mid,candies,k))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927055,
                "title": "easy-java-solution-for-beginners",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] nums, long k) {\\n        int n=nums.length;\\n        int max=0;\\n        for(int x:nums){\\n            max=Math.max(x,max);\\n        }\\n        int st=1;\\n        int end=max;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(solve(nums,mid)>=k){\\n                ans=Math.max(ans,mid);\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double solve(int[] nums,int t){\\n        double count=0;\\n        if(t==0) return 0;\\n        for(int x:nums){\\n            count+=x/t;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] nums, long k) {\\n        int n=nums.length;\\n        int max=0;\\n        for(int x:nums){\\n            max=Math.max(x,max);\\n        }\\n        int st=1;\\n        int end=max;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(solve(nums,mid)>=k){\\n                ans=Math.max(ans,mid);\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double solve(int[] nums,int t){\\n        double count=0;\\n        if(t==0) return 0;\\n        for(int x:nums){\\n            count+=x/t;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924412,
                "title": "go-binary-search-100-runtime-90-memory",
                "content": "```\\nfunc maximumCandies(candies []int, k int64) int {\\n    sum := 0\\n    for _, c := range candies {\\n        sum+=c\\n    }\\n    if k > int64(sum) {\\n        return 0\\n    }\\n\\n    l, r, res := 1, sum/int(k), 0\\n\\n    for l <= r {\\n        m := (l+r)/2\\n        numOfCandies := 0\\n        \\n        for _, c := range candies {\\n            numOfCandies += (c / m)\\n        }\\n        if int64(numOfCandies) < k {\\n            r = m - 1\\n        } else {\\n            res = m\\n            l = m + 1\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumCandies(candies []int, k int64) int {\\n    sum := 0\\n    for _, c := range candies {\\n        sum+=c\\n    }\\n    if k > int64(sum) {\\n        return 0\\n    }\\n\\n    l, r, res := 1, sum/int(k), 0\\n\\n    for l <= r {\\n        m := (l+r)/2\\n        numOfCandies := 0\\n        \\n        for _, c := range candies {\\n            numOfCandies += (c / m)\\n        }\\n        if int64(numOfCandies) < k {\\n            r = m - 1\\n        } else {\\n            res = m\\n            l = m + 1\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902866,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\log{max(candies)})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(), candies.end());\\n        int lo = 1, hi = 0, mid, res = 0, n = candies.size();\\n        hi = candies.back();\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            long long tmp = k;\\n            for (int i = n - 1; i >= 0; -- i) {\\n                tmp -= 1LL * candies[i] / mid;\\n                if (tmp <= 0) break;\\n            }\\n            if (tmp <= 0) {\\n                res = mid;\\n                lo = mid + 1;\\n            } else hi = mid - 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(), candies.end());\\n        int lo = 1, hi = 0, mid, res = 0, n = candies.size();\\n        hi = candies.back();\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            long long tmp = k;\\n            for (int i = n - 1; i >= 0; -- i) {\\n                tmp -= 1LL * candies[i] / mid;\\n                if (tmp <= 0) break;\\n            }\\n            if (tmp <= 0) {\\n                res = mid;\\n                lo = mid + 1;\\n            } else hi = mid - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901111,
                "title": "binary-search-on-solution-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of piles, given the number of candies per child, can be calculated in linear time and is monotonic. So we can binary search on the solution space.\\n\\n# Complexity\\n- Time complexity: $$O(N*log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n        let count_piles = |n| {\\n            candies.iter().map(|&c| (c / n) as i64).sum::<i64>()\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *candies.iter().max().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_piles(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n        let count_piles = |n| {\\n            candies.iter().map(|&c| (c / n) as i64).sum::<i64>()\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *candies.iter().max().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_piles(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900497,
                "title": "c-solution-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(nlong(n))$$\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int high = INT_MIN;\\n        for(auto it : candies){\\n            high = max(high,it);\\n        }\\n        int low =1;\\n        while(low <= high){\\n            long long candiesget=0;\\n            int mid = (low+high)/2;\\n            for(auto it : candies){\\n                candiesget += (it)/mid;\\n\\n            }\\n            if(candiesget >= k){\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int high = INT_MIN;\\n        for(auto it : candies){\\n            high = max(high,it);\\n        }\\n        int low =1;\\n        while(low <= high){\\n            long long candiesget=0;\\n            int mid = (low+high)/2;\\n            for(auto it : candies){\\n                candiesget += (it)/mid;\\n\\n            }\\n            if(candiesget >= k){\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893424,
                "title": "easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 0, max(candies)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (m+1, r) if not m or sum(candy // m for candy in candies) >= k else (l, m-1)\\n        return r\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 0, max(candies)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (m+1, r) if not m or sum(candy // m for candy in candies) >= k else (l, m-1)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891171,
                "title": "best-approach-v-easy-to-understand-beats-90",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool morePossible(vector<int>& candies, long long k, int amount){\\n        long long count = 0;\\n        for(int i = 0; i<candies.size(); i++){\\n            count += (candies[i]/amount);\\n        }\\n        if(count >= k)return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int right = *max_element(candies.begin(), candies.end());\\n        int left = 1;\\n        int res = 0;\\n       \\n        while(left <= right){\\n            int mid = (left +right)/2;\\n            if(morePossible(candies, k, mid)){\\n                res = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool morePossible(vector<int>& candies, long long k, int amount){\\n        long long count = 0;\\n        for(int i = 0; i<candies.size(); i++){\\n            count += (candies[i]/amount);\\n        }\\n        if(count >= k)return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int right = *max_element(candies.begin(), candies.end());\\n        int left = 1;\\n        int res = 0;\\n       \\n        while(left <= right){\\n            int mid = (left +right)/2;\\n            if(morePossible(candies, k, mid)){\\n                res = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890228,
                "title": "kotlin-solution",
                "content": "# Binary search\\n```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var left = 0\\n        var right = 10_000_000\\n\\n        while (left < right) {\\n            val m = (left + right + 1) / 2\\n            var childWithCandies: Long = 0\\n\\n            candies.forEach {\\n                childWithCandies += it / m\\n            }\\n\\n            if (childWithCandies >= k) left = m\\n            else right = m - 1\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var left = 0\\n        var right = 10_000_000\\n\\n        while (left < right) {\\n            val m = (left + right + 1) / 2\\n            var childWithCandies: Long = 0\\n\\n            candies.forEach {\\n                childWithCandies += it / m\\n            }\\n\\n            if (childWithCandies >= k) left = m\\n            else right = m - 1\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887281,
                "title": "java-solution-binary-search-on-answer-beats-95",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity: O(N*logM) M is range of max element.. \\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n       int low =1;\\n       int high = findMax(candies); \\n       while(low <= high){\\n           int mid = low + (high-low)/2;\\n           if(isValid(candies,mid,k)){\\n               low = mid+1;\\n           }else {\\n               high = mid-1;\\n           }\\n       }\\n       return high;\\n    }\\n    public int findMax(int [] candies){\\n        int max = 0;\\n        for(int i:candies){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n\\n    public boolean isValid(int [] candies, int mid,long k){\\n        long piles = 0;\\n        for(int i: candies){\\n            int add = i/mid;\\n            piles += add;\\n        }\\n        return piles >=k;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n       int low =1;\\n       int high = findMax(candies); \\n       while(low <= high){\\n           int mid = low + (high-low)/2;\\n           if(isValid(candies,mid,k)){\\n               low = mid+1;\\n           }else {\\n               high = mid-1;\\n           }\\n       }\\n       return high;\\n    }\\n    public int findMax(int [] candies){\\n        int max = 0;\\n        for(int i:candies){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n\\n    public boolean isValid(int [] candies, int mid,long k){\\n        long piles = 0;\\n        for(int i: candies){\\n            int add = i/mid;\\n            piles += add;\\n        }\\n        return piles >=k;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880468,
                "title": "simple-binary-search-beginers",
                "content": "# Intuition\\nThe very simple binary search with simple and easy checker function \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst just put a binary search on the possible values of the answer in the vector simple and easy approch \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(  log(n) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checker(int target,long long int k ,vector <int > & candies)\\n    {\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            k-=candies[i]/target;\\n        }\\n        if(k>0) return false;\\n        else return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int low=1,mid,high=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,k,candies))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checker(int target,long long int k ,vector <int > & candies)\\n    {\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            k-=candies[i]/target;\\n        }\\n        if(k>0) return false;\\n        else return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int low=1,mid,high=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,k,candies))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879864,
                "title": "easy-c-sol",
                "content": "# Intuition\\njust use binary search to find mid and check that mid is possible or not..\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&candies,int mid,long long k)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            cnt+=(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n         int high=*max_element(candies.begin(),candies.end());\\n         int low=1;\\n         int ans=0;\\n         while(low<=high)\\n         {\\n              int mid=(low+high)/2;\\n              if(check(candies,mid,k))\\n              {\\n                  ans=max(ans,mid);\\n                  low=mid+1;\\n              }\\n              else high=mid-1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&candies,int mid,long long k)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            cnt+=(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n         int high=*max_element(candies.begin(),candies.end());\\n         int low=1;\\n         int ans=0;\\n         while(low<=high)\\n         {\\n              int mid=(low+high)/2;\\n              if(check(candies,mid,k))\\n              {\\n                  ans=max(ans,mid);\\n                  low=mid+1;\\n              }\\n              else high=mid-1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872085,
                "title": "detailed-thought-process-start-with-linear-search-and-convert-your-thought-to-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search: \\nHere this is the problem of maximisation over sorted search space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# **First think of searching maximum candy linearly :**\\n\\nWhat will be sorted search space for this problem:\\n    Here candies = {5,8,6}; k = 3\\n   here total candies = (5+8+6) = 19 and these 19 candies we have to distribute on k children.\\n\\nso one just intuitive way comes to our mind that just devide 19 by 3 i.e 19/3 = 6 candy.  so distribute 6 candy to each children 6*3 = 18 candy will be distributed. so here one possible ans could be 6,\\nsay ans = 6, now check if this ans is valid or not\\n\\nhere we are distributing 6 candy to each children, then one thing we have to make sure that each of the piles must contains candy greater than or equal to 6 candy then only we will be able to distribute 6 candy to each children. as in problem statement it is clearly mentioned that you can\\'t merge two piles of candies.  but we can distribute two children from one pile. but candy from two pile can\\'t be distributed to single child.\\n\\nHere candies[0] = 5 < ans =6, so here it is not possible to distribute 6 candy to each children.\\nas to distribute 6 candy, we have to 2 extra candy to pile candies[1] = 8, so if we are using these 2 extra candy in candies[0] = 5 to distribute 6, then it is a king of merging candy from two piles that is conflicting the problem statement. so this is not possible.\\n\\n\\nNow lets reduce the amount of candy from 6 to 5, say ans = 5, lets check if we can distribute , so clearly we can see that each of the piles has greater than or equal to 5 candy. so this is our feasible ans.\\n\\nso we will not go below 5 as we need maximum candy to distribute.\\n\\n# Binary Search thought:\\n\\nSo above idea to search the maximum candy linearley. \\n\\nbut here search space is sorted we can apply binary search on the search space low = 1 and high = 10^7 or (sum of all candy)/ k\\n\\nhere low = 1 as we can distribute 1 candy for sure as 1<=candies[i]<= 10^7\\nand high = (sum of all candy)/ k or we can take directly 10^7 as it is the max possible value of candy in a pile. any thing greater than 10^7 is not possible. \\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 0; int max = 0;\\n        long sum = 0;\\n        for(int candy : candies){\\n            sum += candy;\\n        }\\n\\n        if(sum < k) return 0;\\n        long s = 1;\\n        long e = (long)1e7;//sum/k;\\n        long ans = s;\\n        while(s <= e){\\n            long mid = s + (e-s)/2;\\n            if(canDistribute(candies,mid, k)){\\n                ans = mid;\\n                s = mid + 1;\\n            } else {\\n                e = mid -1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n\\n    private boolean canDistribute(int [] candies, long mid, long k){\\n        long count = 0;\\n        for(int candy : candies){\\n           count += candy/mid;\\n        }\\n        return count >= k;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: O(nlog(Max{candies[i]})) as a for loop is running at starting to find the sum. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 0; int max = 0;\\n        long sum = 0;\\n        for(int candy : candies){\\n            sum += candy;\\n        }\\n\\n        if(sum < k) return 0;\\n        long s = 1;\\n        long e = (long)1e7;//sum/k;\\n        long ans = s;\\n        while(s <= e){\\n            long mid = s + (e-s)/2;\\n            if(canDistribute(candies,mid, k)){\\n                ans = mid;\\n                s = mid + 1;\\n            } else {\\n                e = mid -1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n\\n    private boolean canDistribute(int [] candies, long mid, long k){\\n        long count = 0;\\n        for(int candy : candies){\\n           count += candy/mid;\\n        }\\n        return count >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862887,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findNumberOfPeople(vector<int>& candies, long long mid) {\\n        long long total = 0;\\n        for(int i=0; i<candies.size(); i++) {\\n            total += candies[i] / mid;\\n        }\\n        return total;\\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        if(accumulate(candies.begin(),candies.end(),0ll)<k)\\n        return 0;\\n        long long s = 1;\\n        long long h = *max_element(candies.begin(), candies.end());\\n        while (s < h) {\\n            long long m = s + (h - s + 1) / 2;\\n            if (findNumberOfPeople(candies, m) >= k) {\\n                s = m;\\n            }\\n            else {\\n                h = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findNumberOfPeople(vector<int>& candies, long long mid) {\\n        long long total = 0;\\n        for(int i=0; i<candies.size(); i++) {\\n            total += candies[i] / mid;\\n        }\\n        return total;\\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        if(accumulate(candies.begin(),candies.end(),0ll)<k)\\n        return 0;\\n        long long s = 1;\\n        long long h = *max_element(candies.begin(), candies.end());\\n        while (s < h) {\\n            long long m = s + (h - s + 1) / 2;\\n            if (findNumberOfPeople(candies, m) >= k) {\\n                s = m;\\n            }\\n            else {\\n                h = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849983,
                "title": "binary-search-13-ms-beats-99-7-runtime-98-77-memory",
                "content": "# Complexity\\n- Time complexity:\\nO(k * log(sum(candies)/k))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  public int maximumCandies(int[] candies, long k) {\\n    long countCandies = 0;\\n    for (int i = 0; i < candies.length; i++) {\\n      countCandies += candies[i];\\n    }\\n\\n    long left = 1, right = countCandies / k;\\n    long maxCandies = 0;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      long countAlloted = 0;\\n      for (int i = 0; i < candies.length; i++) {\\n        countAlloted += candies[i] / mid;\\n        if (countAlloted >= k) {\\n          break;\\n        }\\n      }\\n\\n      if (countAlloted >= k) {\\n        maxCandies = mid;\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return (int) maxCandies;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumCandies(int[] candies, long k) {\\n    long countCandies = 0;\\n    for (int i = 0; i < candies.length; i++) {\\n      countCandies += candies[i];\\n    }\\n\\n    long left = 1, right = countCandies / k;\\n    long maxCandies = 0;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      long countAlloted = 0;\\n      for (int i = 0; i < candies.length; i++) {\\n        countAlloted += candies[i] / mid;\\n        if (countAlloted >= k) {\\n          break;\\n        }\\n      }\\n\\n      if (countAlloted >= k) {\\n        maxCandies = mid;\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return (int) maxCandies;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848305,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    bool isPossible(vector<int>&candies,long long k,long long mid){\\n        long long count = 0;\\n        long long sum = 0;\\n        for(auto i:candies)\\n            count += i/mid;\\n        return count >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        long long high = 0;\\n        for(auto i:candies)\\n            high += i;\\n        long long ans = 0;\\n        long long mid = 0;\\n        if(high < k)\\n            return 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(candies,k,mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isPossible(vector<int>&candies,long long k,long long mid){\\n        long long count = 0;\\n        long long sum = 0;\\n        for(auto i:candies)\\n            count += i/mid;\\n        return count >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        long long high = 0;\\n        for(auto i:candies)\\n            high += i;\\n        long long ans = 0;\\n        long long mid = 0;\\n        if(high < k)\\n            return 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(candies,k,mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829075,
                "title": "faster-than-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(right))\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k : \\n            return 0 \\n        \\n        def helper (val): \\n            crr = 0 \\n            for ele in candies : \\n                crr += (ele//val)\\n            if crr >= k : \\n                return True \\n            return False \\n        \\n        left =1\\n        right = sum(candies)//k \\n\\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left if helper(left) else left-1 \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k : \\n            return 0 \\n        \\n        def helper (val): \\n            crr = 0 \\n            for ele in candies : \\n                crr += (ele//val)\\n            if crr >= k : \\n                return True \\n            return False \\n        \\n        left =1\\n        right = sum(candies)//k \\n\\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left if helper(left) else left-1 \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824964,
                "title": "python-binary-search-solution",
                "content": "# Intuition \\nBinary Search, where the max amount is the number of available candies we have. We want to maximize this so we update our result.\\n# Approach\\nThe only addition to binary search is to consider when a valid amount is foundm updating the max when an amount can be satisfied using integer division.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log(m)), where m = sum(candies), the number of candies we can distribute, and n is the length of candies. \\n\\n- Space complexity:\\nO(1), we are only storing integer variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        res = 0\\n        def can(amt, kids):\\n            for val in candies:\\n                if val >= amt:\\n                    kids -= (val // amt)\\n                    if kids <= 0:\\n                        return True\\n            return kids <= 0\\n        l, r = 1, sum(candies)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can(m, k):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        res = 0\\n        def can(amt, kids):\\n            for val in candies:\\n                if val >= amt:\\n                    kids -= (val // amt)\\n                    if kids <= 0:\\n                        return True\\n            return kids <= 0\\n        l, r = 1, sum(candies)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can(m, k):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821954,
                "title": "o-nlogn-solution-c-java-solution",
                "content": "\\n# Code\\n**Java**\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        int l=1,r=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++) r=Math.max(r,candies[i]);\\n        // System.out.println(r);\\n        int ans=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(bs(candies,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean bs(int[] candies, int candy,long k){\\n        long total=0;\\n        for(int c:candies){\\n            total+=(c/candy);\\n        }\\n        return k<=total;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(std::vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        int l = 1, r = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            r = std::max(r, candies[i]);\\n        }\\n\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (bs(candies, mid, k)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool bs(std::vector<int>& candies, int candy, long long k) {\\n        long long total = 0;\\n        for (int c : candies) {\\n            total += (c / candy);\\n        }\\n        return k <= total;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        int l=1,r=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++) r=Math.max(r,candies[i]);\\n        // System.out.println(r);\\n        int ans=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(bs(candies,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean bs(int[] candies, int candy,long k){\\n        long total=0;\\n        for(int c:candies){\\n            total+=(c/candy);\\n        }\\n        return k<=total;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(std::vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        int l = 1, r = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            r = std::max(r, candies[i]);\\n        }\\n\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (bs(candies, mid, k)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool bs(std::vector<int>& candies, int candy, long long k) {\\n        long long total = 0;\\n        for (int c : candies) {\\n            total += (c / candy);\\n        }\\n        return k <= total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820911,
                "title": "java-general-approach-to-handle-these-king-of-question-binary-search",
                "content": "\\tIn This question we know that we will have at least 1 candy in pile and maximum it can 10^7 and each pile can be divded  and we have to find our answer in that range \\n\\t\\n\\tNow there can be cases such that 1 pile is so big that it itself generate the answer from itself and here we check it through our valid \"MOSTLY THIS PART CHANGES IN THIS TYPE OF QUESTION\" .\\n\\tand there is simpy shifting left pointer to maximize the result ; \\n\\t\\n\\t\\n```\\nclass Solution {\\n    boolean valid(int[] arr, long k , int mid ){\\n        long piles = 0; \\n        for(int i = 0 ; i< arr.length ; ++i){\\n            piles += arr[i]/mid;\\n            if(piles >= k) return true;\\n        }\\n        return false;\\n                \\n        \\n    };\\n    public int maximumCandies(int[] candies, long k) {\\n        int l = 1 ,r = 10000000 ; \\n        \\n        int ans = 0; \\n        \\n        while( l <= r ){\\n            int mid = l + (r - l )/2;\\n            \\n            if(valid(candies,k,mid)){\\n                ans = mid; \\n                l = mid + 1; \\n            }\\n            else{\\n                r = mid -1; \\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    boolean valid(int[] arr, long k , int mid ){\\n        long piles = 0; \\n        for(int i = 0 ; i< arr.length ; ++i){\\n            piles += arr[i]/mid;\\n            if(piles >= k) return true;\\n        }\\n        return false;\\n                \\n        \\n    };\\n    public int maximumCandies(int[] candies, long k) {\\n        int l = 1 ,r = 10000000 ; \\n        \\n        int ans = 0; \\n        \\n        while( l <= r ){\\n            int mid = l + (r - l )/2;\\n            \\n            if(valid(candies,k,mid)){\\n                ans = mid; \\n                l = mid + 1; \\n            }\\n            else{\\n                r = mid -1; \\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820402,
                "title": "simple-binary-search",
                "content": "# Intuition\\ncheck how much we can give\\n\\n# Approach\\nBinary Search\\n\\n# Complexity**Bold**\\n- Time complexity:\\nnlog(1e7)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k,long long mid)\\n    {\\n        long long t=0;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t+=(long long)candies[i]/mid;\\n        }\\n        return t>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long low=1,high=1e7;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(check(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k,long long mid)\\n    {\\n        long long t=0;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t+=(long long)candies[i]/mid;\\n        }\\n        return t>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long low=1,high=1e7;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(check(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819137,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    bool check(vector<int> &candies, long long k, int mid){\\n        long long numofPiles = 0;\\n        for(int it:candies){\\n            numofPiles += it/mid;\\n        }\\n        return numofPiles >= k;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k) {\\n        int l=1, r=1e7, ans = 0;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(check(candies, k, mid) == true){\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(vector<int> &candies, long long k, int mid){\\n        long long numofPiles = 0;\\n        for(int it:candies){\\n            numofPiles += it/mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810289,
                "title": "similar-to-book-allocations",
                "content": "# Intuition\\nWe have to find how much we can divide so that it is distributed equally.\\n**Naive**\\n- we can start looking form 1 to infinity and once it fails we know previous one is the correct distribution eg:- the max distribution we can do.\\nNow we can optimize it for binary search\\n\\n\\n\\n\\n# Approach\\n**Binary search**\\n- we can find the range how can we distribute as in question (there can be piles that will be unused) therefore as we dont have to include every pile then **MAX pile is the upper bound**\\n- Lower bound will be 1 as we can distribute 1 to each kid\\n\\nSo as we are looking for MAX ,where distribution is doable then we have to look into the right half (upper bound) and vice versa.\\n\\n# Complexity\\n- Time complexity:\\nO(log(max-1+1).N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long low=1,high= getMaxPile(candies);\\n\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n\\n            if(canDivide(candies,k,mid))\\n            {\\n                low=mid+1;      \\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return (int)high;\\n    }\\n\\n    public boolean canDivide(int[] candies, long k, long amount)\\n    {\\n        long count=0;\\n\\n        for(int candy : candies)\\n        {\\n            count+=(candy/amount);\\n        } \\n      //  System.out.println((k<=amount));\\n        return count>=k;  \\n    }\\n\\n    public long getMaxPile(int[] candies)\\n    {\\n        long max=candies[0];\\n\\n        for(int candy : candies)\\n        {\\n            if(candy>max)\\n            {\\n                max=candy;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long low=1,high= getMaxPile(candies);\\n\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n\\n            if(canDivide(candies,k,mid))\\n            {\\n                low=mid+1;      \\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return (int)high;\\n    }\\n\\n    public boolean canDivide(int[] candies, long k, long amount)\\n    {\\n        long count=0;\\n\\n        for(int candy : candies)\\n        {\\n            count+=(candy/amount);\\n        } \\n      //  System.out.println((k<=amount));\\n        return count>=k;  \\n    }\\n\\n    public long getMaxPile(int[] candies)\\n    {\\n        long max=candies[0];\\n\\n        for(int candy : candies)\\n        {\\n            if(candy>max)\\n            {\\n                max=candy;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807049,
                "title": "bs",
                "content": "**time: `O(KlogN)`; space: `O(1)`**\\n```\\nint maximumCandies(vector<int>& c, long long K)\\n{\\n\\tint l{}, h{10000001};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tint m = (l+h)/2;\\n\\t\\t(accumulate(begin(c), end(c), 0ll, [&](auto s, auto & c){ return s+1ll*c/m; })>=K ? l : h) = m;\\n\\t}\\n\\treturn l;\\n}\\n```\\n**Similar problems:**\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/2053517/bs?currentPage=1&orderBy=most_relevant&query=android)\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2963593/bs)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/2127417/binary-search)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1676227/binary-search)\\n[1300. Sum of Mutated Array Closest to Target](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/2969866/bs)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok)\\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/discuss/3251393/ok)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/3253585/bs)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/3254564/bs)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/3807049/bs)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3808940/bs)\\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/discuss/3945204/range-bs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumCandies(vector<int>& c, long long K)\\n{\\n\\tint l{}, h{10000001};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tint m = (l+h)/2;\\n\\t\\t(accumulate(begin(c), end(c), 0ll, [&](auto s, auto & c){ return s+1ll*c/m; })>=K ? l : h) = m;\\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805686,
                "title": "python-bs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def ispossible(n):\\n            if n==0:\\n                return True\\n            count = 0\\n            for e in candies:\\n                if e < n:\\n                    continue\\n                elif e == n:\\n                    count+=1\\n                else:\\n                    count+=e//n\\n            return count >= k\\n\\n        l = 0\\n        u = 10000000\\n        while l<=u:\\n            mid = (l+u)//2\\n            if ispossible(mid):\\n                l = mid+1\\n            else:\\n                u = mid-1\\n\\n        return l-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def ispossible(n):\\n            if n==0:\\n                return True\\n            count = 0\\n            for e in candies:\\n                if e < n:\\n                    continue\\n                elif e == n:\\n                    count+=1\\n                else:\\n                    count+=e//n\\n            return count >= k\\n\\n        l = 0\\n        u = 10000000\\n        while l<=u:\\n            mid = (l+u)//2\\n            if ispossible(mid):\\n                l = mid+1\\n            else:\\n                u = mid-1\\n\\n        return l-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797209,
                "title": "easy-c-solution-using-bs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = * max_element ( A.begin() , A.end());\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = * max_element ( A.begin() , A.end());\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759528,
                "title": "easy-to-understand-clean-code-commented-binary-search-in-the-possible-answer",
                "content": "# Approach\\nLet\\'s say you can give maximum `X` candies. How do you find if it\\'s true or not?\\nTry to spit the piles keeping at least `X` candies on that and calculate how many piles you can build. If the number of piles is greater than number of kids then answer is true otherwise false.\\n\\nNow try to find a suitable `X` using binary search.\\n\\n# Complexity\\n- Time complexity:\\n`O(n log N)`\\n\\n- Space complexity:\\n`O(1)` - No extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long min_possible = 1;\\n        long long max_possible = *max_element(candies.begin(), candies.end());\\n        long long ans = 0;\\n\\n        // Find the number of pile you can build keeping at least\\n        // `value` candies in it */\\n        auto check = [&] (int value) {\\n            long long piles = 0;\\n            for (const auto &candy : candies) {\\n                piles += (candy / value);\\n            }\\n\\n            return piles >= k;\\n        };\\n\\n        // find a suitalbe answer using binary search\\n        while (min_possible <= max_possible) {\\n            long long trial = (min_possible + max_possible) / 2;\\n            if (check(trial)) {\\n                ans = max(ans, trial);\\n                min_possible = trial + 1;\\n            } else {\\n                max_possible = trial - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long min_possible = 1;\\n        long long max_possible = *max_element(candies.begin(), candies.end());\\n        long long ans = 0;\\n\\n        // Find the number of pile you can build keeping at least\\n        // `value` candies in it */\\n        auto check = [&] (int value) {\\n            long long piles = 0;\\n            for (const auto &candy : candies) {\\n                piles += (candy / value);\\n            }\\n\\n            return piles >= k;\\n        };\\n\\n        // find a suitalbe answer using binary search\\n        while (min_possible <= max_possible) {\\n            long long trial = (min_possible + max_possible) / 2;\\n            if (check(trial)) {\\n                ans = max(ans, trial);\\n                min_possible = trial + 1;\\n            } else {\\n                max_possible = trial - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759367,
                "title": "maximum-candies-allocated-to-k-children",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, a: List[int], k: int) -> int:\\n        ##Method 1\\n        def chq(a,v,k):\\n            c=0\\n            for i in a:\\n                c+=i//v\\n            return c>=k\\n            mx=float(\"-inf\")\\n        ans=0\\n        l=1\\n        h=max(a)\\n        while l<=h:\\n            m=(l+h)//2\\n            if chq(a,m,k):\\n                ans=m\\n                l=m+1\\n            else:\\n                h=m-1\\n        return(ans)\\n        ### Method 2 (Brute Force)\\n            # d={}\\n            # for i in range(len(a)):\\n            #     n=a[i]\\n            #     if n<v:\\n            #         if n in d:\\n            #             d[n]+=1\\n            #         else:\\n            #             d[n]=1\\n            #         continue\\n            #     while n:\\n            #         if n==0:\\n            #             break\\n            #         elif n<v:\\n            #             if n not in d:\\n            #                 d[n]=1\\n            #             else:\\n            #                 d[n]+=1\\n            #             break\\n            #         else:\\n            #             if v not in d:\\n            #                 d[v]=1\\n            #             else:\\n            #                 d[v]+=1\\n            #             n-=v\\n            # mx=float(\"-inf\")\\n            # for i in d:\\n            #     if d[i]>=k:\\n            #         mx=max(mx,i)\\n            # return mx\\n        # print(chq(a,8,k))\\n        \\n        # for i in range(1,max(a)+1):\\n        #     if chq(a,i,k)!=float(\"-inf\"):\\n        #         mx=max(mx,i)\\n        # if mx==float(\"-inf\"):return 0\\n        # return mx\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, a: List[int], k: int) -> int:\\n        ##Method 1\\n        def chq(a,v,k):\\n            c=0\\n            for i in a:\\n                c+=i//v\\n            return c>=k\\n            mx=float(\"-inf\")\\n        ans=0\\n        l=1\\n        h=max(a)\\n        while l<=h:\\n            m=(l+h)//2\\n            if chq(a,m,k):\\n                ans=m\\n                l=m+1\\n            else:\\n                h=m-1\\n        return(ans)\\n        ### Method 2 (Brute Force)\\n            # d={}\\n            # for i in range(len(a)):\\n            #     n=a[i]\\n            #     if n<v:\\n            #         if n in d:\\n            #             d[n]+=1\\n            #         else:\\n            #             d[n]=1\\n            #         continue\\n            #     while n:\\n            #         if n==0:\\n            #             break\\n            #         elif n<v:\\n            #             if n not in d:\\n            #                 d[n]=1\\n            #             else:\\n            #                 d[n]+=1\\n            #             break\\n            #         else:\\n            #             if v not in d:\\n            #                 d[v]=1\\n            #             else:\\n            #                 d[v]+=1\\n            #             n-=v\\n            # mx=float(\"-inf\")\\n            # for i in d:\\n            #     if d[i]>=k:\\n            #         mx=max(mx,i)\\n            # return mx\\n        # print(chq(a,8,k))\\n        \\n        # for i in range(1,max(a)+1):\\n        #     if chq(a,i,k)!=float(\"-inf\"):\\n        #         mx=max(mx,i)\\n        # if mx==float(\"-inf\"):return 0\\n        # return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757149,
                "title": "binary-search-with-intuition",
                "content": "# Code\\n```\\nclass Solution {\\n    // Intuition: Doing binary search as possible range of ans is available\\n    // TC: O(logr * candies.length)\\n    // SC: O(1)\\n    public int maximumCandies(int[] candies, long totalChildren) {\\n        long l = 1;\\n        long r = candies[0];\\n        for(int c:candies){\\n            r+=c;\\n        }\\n        if(r<totalChildren){\\n            return 0;\\n        }\\n        long ans = 0;\\n        long mid = 0;\\n        // TC: O(logr)\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            // TC: O(candies.length)\\n            if(canDistributeEqually(candies,totalChildren,mid)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n    private boolean canDistributeEqually(int[] candies, long totalChildren, long eachMustHave){\\n        long count = 0;\\n        for(int c:candies){\\n            count+= c/eachMustHave;\\n        }\\n        return count>=totalChildren;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // Intuition: Doing binary search as possible range of ans is available\\n    // TC: O(logr * candies.length)\\n    // SC: O(1)\\n    public int maximumCandies(int[] candies, long totalChildren) {\\n        long l = 1;\\n        long r = candies[0];\\n        for(int c:candies){\\n            r+=c;\\n        }\\n        if(r<totalChildren){\\n            return 0;\\n        }\\n        long ans = 0;\\n        long mid = 0;\\n        // TC: O(logr)\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            // TC: O(candies.length)\\n            if(canDistributeEqually(candies,totalChildren,mid)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n    private boolean canDistributeEqually(int[] candies, long totalChildren, long eachMustHave){\\n        long count = 0;\\n        for(int c:candies){\\n            count+= c/eachMustHave;\\n        }\\n        return count>=totalChildren;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710929,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first notice that the maximum amount of candies in a pile can range from 0 to the max of candies, max(candies). We binary search over this range, utilizing a helper function to check if the chosen number for every pile is okay to allocate with. If we are successful in choosing the number for the maximum of this pile, we can find the max of this key value with our previous maximum. If we are not successful, then we decrease the size of our pile and binary search to the left. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        candies.sort()\\n        \\n        maximumNumCandies = 0\\n        \\n        #each child can take at most one pile of candies (some may go unused)\\n        #allocate piles of candies to k children such that each child gets the same number of candies\\n\\n        def canAllocatePiles(value):\\n            if value == 0:\\n                return True\\n            allocatedPiles = 0\\n            for pile in candies:\\n                allocatedPiles += (pile // value)\\n            return allocatedPiles >= k\\n\\n\\n        #the lower bound of candies a child can receive is 0. an upper bound is max(candies)\\n        lower, upper = 0, max(candies)\\n        #binary search through\\n        \\n        while lower <= upper:\\n            middle = (lower + upper) // 2\\n            \\n            if canAllocatePiles(middle):\\n                maximumNumCandies = max(maximumNumCandies, middle)\\n                lower = middle + 1\\n            else:\\n                upper = middle - 1\\n        \\n\\n        return maximumNumCandies\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        candies.sort()\\n        \\n        maximumNumCandies = 0\\n        \\n        #each child can take at most one pile of candies (some may go unused)\\n        #allocate piles of candies to k children such that each child gets the same number of candies\\n\\n        def canAllocatePiles(value):\\n            if value == 0:\\n                return True\\n            allocatedPiles = 0\\n            for pile in candies:\\n                allocatedPiles += (pile // value)\\n            return allocatedPiles >= k\\n\\n\\n        #the lower bound of candies a child can receive is 0. an upper bound is max(candies)\\n        lower, upper = 0, max(candies)\\n        #binary search through\\n        \\n        while lower <= upper:\\n            middle = (lower + upper) // 2\\n            \\n            if canAllocatePiles(middle):\\n                maximumNumCandies = max(maximumNumCandies, middle)\\n                lower = middle + 1\\n            else:\\n                upper = middle - 1\\n        \\n\\n        return maximumNumCandies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704735,
                "title": "c-easy-solution-striver-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, int mid, long long k){\\n        long long cntOfsplit = 0;\\n        for(int i = 0; i < candies.size(); i++){\\n            cntOfsplit += candies[i]/mid;\\n        }\\n        return cntOfsplit >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int high = *max_element(candies.begin(), candies.end());\\n        while(low <= high){\\n            int mid = low+ (high- low)/2;\\n            if(isPossible(candies, mid, k)){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, int mid, long long k){\\n        long long cntOfsplit = 0;\\n        for(int i = 0; i < candies.size(); i++){\\n            cntOfsplit += candies[i]/mid;\\n        }\\n        return cntOfsplit >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int high = *max_element(candies.begin(), candies.end());\\n        while(low <= high){\\n            int mid = low+ (high- low)/2;\\n            if(isPossible(candies, mid, k)){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703155,
                "title": "binary-search-intuition-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClearly answer will be in between 0 and the max element of the vector.\\nWhen k is too high, answer have to b 0\\nWhen k is very low, (e.g. = 1) answer have to be maximum element\\n\\nSo Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply apply Binary search from with  l =0 and h = max_element. And for every mid element we will calculate in how many kids we can distribue the canides or subpiles. For that we just have to do $candies[i]/mid$. SO,,,,,,,,\\n\\n# Edge Case\\nJust keep in mind that we have low as 0. And when we will divide by mid, in cases mid can be 0 too. So, make a seprate case of that.\\n\\n# Complexity\\n- Time complexity:$O(nlogm)$ \\n- $n$ = Length of candies vector\\n- $m$ = max element of vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int i =0;\\n        long long j = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            long long temp=0;\\n            if(mid==0) temp=k;\\n            else\\n            {\\n                for(int a=0;a<candies.size();a++)\\n                {\\n                    temp = temp + floor((double)candies[a]/(double)mid);\\n                }\\n            }   \\n            if(temp>=k)\\n            {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else\\n            {\\n                j=mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int i =0;\\n        long long j = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            long long temp=0;\\n            if(mid==0) temp=k;\\n            else\\n            {\\n                for(int a=0;a<candies.size();a++)\\n                {\\n                    temp = temp + floor((double)candies[a]/(double)mid);\\n                }\\n            }   \\n            if(temp>=k)\\n            {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else\\n            {\\n                j=mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683524,
                "title": "swift-binary-search-solution-space",
                "content": "# Intuition\\n Define a solution space to perform a binary search to find the max # of candies per pile\\n \\n # Approach\\n Define a solution space of possible values.\\n The minimum pile count has to be 1 since a pile cannot contain 0 candies.\\n The maximum pile count is `max(candies)` since piles cannot be merged.\\n Use a binary search to find the max pile count that satisfies `checkPiles`.\\n \\n # Complexity\\n - Time complexity:\\n O(n log n) where `n` is `candies.count`.\\n O(n)(find max) * O(log n)(binary search) * O(n)(checkPiles)\\n \\n - Space complexity:\\n O(1) only a few integers are stored.\\n \\n This problem is similar to to [875. Koko eating bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n\\n```\\nclass Solution {\\n\\n    func checkPiles(_ candies: [Int], _ k: Int, _ size: Int) -> Bool {\\n        var piles = 0\\n        for c in candies {\\n            piles += c / size\\n        }\\n\\n        return piles >= k\\n    }\\n\\n    func maximumCandies(_ candies: [Int], _ k: Int) -> Int {\\n        // Define the solution space\\n        var l = 1, r = Int.min, sum = 0 \\n        for c in candies {\\n            r = max(r, c)\\n            sum += c\\n        }\\n\\n        // The sum of all the piles has to be at least greater than the number of kids.\\n        guard sum >= k else { return 0 }\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            if checkPiles(candies, k, mid) {\\n                // Max number of candies satisfies the condition.\\n                // Try a bigger pile.\\n                l = mid + 1\\n            } else {\\n                // Num of candies per pile did not satisfy the condition.\\n                // Try a smaller pile.\\n                r = mid - 1\\n            }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    func checkPiles(_ candies: [Int], _ k: Int, _ size: Int) -> Bool {\\n        var piles = 0\\n        for c in candies {\\n            piles += c / size\\n        }\\n\\n        return piles >= k\\n    }\\n\\n    func maximumCandies(_ candies: [Int], _ k: Int) -> Int {\\n        // Define the solution space\\n        var l = 1, r = Int.min, sum = 0 \\n        for c in candies {\\n            r = max(r, c)\\n            sum += c\\n        }\\n\\n        // The sum of all the piles has to be at least greater than the number of kids.\\n        guard sum >= k else { return 0 }\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            if checkPiles(candies, k, mid) {\\n                // Max number of candies satisfies the condition.\\n                // Try a bigger pile.\\n                l = mid + 1\\n            } else {\\n                // Num of candies per pile did not satisfy the condition.\\n                // Try a smaller pile.\\n                r = mid - 1\\n            }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639923,
                "title": "java-solution-binary-search-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int p : candies){\\n            sum += p;\\n            max = Math.max(p, max);\\n        }\\n\\n        if(sum < k){\\n            return 0;\\n        }\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            long value = 0;\\n            int mid = lo + (hi - lo)/2;\\n            for(int i = 0;i<candies.length;i++){\\n                value += (candies[i]/mid);\\n            }\\n            if(value < k){\\n                \\n                hi = mid - 1;\\n            }\\n            else{\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int p : candies){\\n            sum += p;\\n            max = Math.max(p, max);\\n        }\\n\\n        if(sum < k){\\n            return 0;\\n        }\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            long value = 0;\\n            int mid = lo + (hi - lo)/2;\\n            for(int i = 0;i<candies.length;i++){\\n                value += (candies[i]/mid);\\n            }\\n            if(value < k){\\n                \\n                hi = mid - 1;\\n            }\\n            else{\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630709,
                "title": "java-beats-92-very-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(nlog(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start=1,end=Integer.MIN_VALUE,ansv=0;\\n        for(int i:candies){\\n            end=Math.max(end,i);\\n        }\\n        while(start<=end){\\n            long sum=0;\\n            int mid=start+((end-start)>>1);\\n            for(int i:candies){\\n                sum+=i/mid;\\n            }\\n            if(sum>=k){\\n                    ansv=mid;\\n                    start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n        return ansv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start=1,end=Integer.MIN_VALUE,ansv=0;\\n        for(int i:candies){\\n            end=Math.max(end,i);\\n        }\\n        while(start<=end){\\n            long sum=0;\\n            int mid=start+((end-start)>>1);\\n            for(int i:candies){\\n                sum+=i/mid;\\n            }\\n            if(sum>=k){\\n                    ansv=mid;\\n                    start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n        return ansv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612438,
                "title": "c-easy-to-understand-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool flag(vector<int>&v,long long int mid,int n,long long int k){\\n    long long int kk=0;\\n    for(int i=0;i<n;i++){\\n        kk=kk+(v[i]/mid);\\n        if(kk>=k)return 1;\\n    }\\n    \\n    return 0;\\n\\n}\\n    int maximumCandies(vector<int>&candies, long long k) {\\n        int n=candies.size();\\n       long long int b=0;\\n       long long int a=1;\\n       int mx=0;\\n       for(int i=0;i<n;i++){\\n           mx=max(mx,candies[i]);\\n       }\\n       long long int ans=0;\\n       b=mx;\\n       while(a<=b){\\n           long long int mid=a+(b-a)/2;\\n           if(flag(candies,mid,n,k)){\\n               ans=mid;\\n               a=mid+1;\\n           }\\n           else{\\n               b=mid-1;\\n           }\\n\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool flag(vector<int>&v,long long int mid,int n,long long int k){\\n    long long int kk=0;\\n    for(int i=0;i<n;i++){\\n        kk=kk+(v[i]/mid);\\n        if(kk>=k)return 1;\\n    }\\n    \\n    return 0;\\n\\n}\\n    int maximumCandies(vector<int>&candies, long long k) {\\n        int n=candies.size();\\n       long long int b=0;\\n       long long int a=1;\\n       int mx=0;\\n       for(int i=0;i<n;i++){\\n           mx=max(mx,candies[i]);\\n       }\\n       long long int ans=0;\\n       b=mx;\\n       while(a<=b){\\n           long long int mid=a+(b-a)/2;\\n           if(flag(candies,mid,n,k)){\\n               ans=mid;\\n               a=mid+1;\\n           }\\n           else{\\n               b=mid-1;\\n           }\\n\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611752,
                "title": "detailed-explanation-intuition-ranged-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We a given search space in which our answer occurs minimum answer can be 1  maximum answer can be maximum of array.\\n- Suppose a number 5 satisfies so all numbers less than 5 will also satisfy the problem we have to search for elements greater than 5, same is the case if 5 doesnot satisfy we have to search answers less then 5.\\n- All this indicate the use of **Binary Search**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Apply Binary Search\\n- If any element satisfy update the answer.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long l=1L,h=(long)-1e8,ans=0L;\\n        for(int i:candies)\\n            h = Math.max(h,i);\\n\\n        while(l<=h){\\n            long m = (h-l)/2+l;\\n            if(isPossible(candies,k,m)){\\n                ans = m;\\n                l=m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n\\n        return (int)ans;\\n\\n        \\n    }\\n\\n    public boolean isPossible(int[] candies, long k,long m){\\n\\n        long c = 0L;\\n        for(int i:candies){\\n            if(i<m)\\n                continue;\\n\\n            c += (long)i/m;\\n            if(c>=k)\\n                return true;\\n        }\\n\\n        return c>=k;\\n\\n    }\\n}\\n```\\n\\n\\n**IF YOU LIKE IT PLS UPVOTE**\\n\\n\\n- thanks\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long l=1L,h=(long)-1e8,ans=0L;\\n        for(int i:candies)\\n            h = Math.max(h,i);\\n\\n        while(l<=h){\\n            long m = (h-l)/2+l;\\n            if(isPossible(candies,k,m)){\\n                ans = m;\\n                l=m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n\\n        return (int)ans;\\n\\n        \\n    }\\n\\n    public boolean isPossible(int[] candies, long k,long m){\\n\\n        long c = 0L;\\n        for(int i:candies){\\n            if(i<m)\\n                continue;\\n\\n            c += (long)i/m;\\n            if(c>=k)\\n                return true;\\n        }\\n\\n        return c>=k;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610302,
                "title": "easy-c-sol",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n=candies.size();\\n        ll sum=0;\\n        for(auto i:candies)sum+=i;\\n        if(sum<k)return 0;\\n        ll low=1;\\n        ll high=sum;\\n        ll ans=1;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll temp=0;\\n            for(int i=0;i<n;i++){\\n                temp+=floor(candies[i]*1.0/mid);\\n            }\\n            if(temp>=k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n=candies.size();\\n        ll sum=0;\\n        for(auto i:candies)sum+=i;\\n        if(sum<k)return 0;\\n        ll low=1;\\n        ll high=sum;\\n        ll ans=1;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll temp=0;\\n            for(int i=0;i<n;i++){\\n                temp+=floor(candies[i]*1.0/mid);\\n            }\\n            if(temp>=k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581078,
                "title": "candies-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n= candies.size();\\n        ll lo=1,hi=1e15,ans=0;\\n        while(lo<=hi){\\n            ll mid= (lo+hi)/2;\\n            ll totalkitnipilesbnsktihjismecandiesho=0;\\n            for(auto itr:candies){\\n                totalkitnipilesbnsktihjismecandiesho+=(itr/mid);\\n            }\\n            if(totalkitnipilesbnsktihjismecandiesho>=k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n= candies.size();\\n        ll lo=1,hi=1e15,ans=0;\\n        while(lo<=hi){\\n            ll mid= (lo+hi)/2;\\n            ll totalkitnipilesbnsktihjismecandiesho=0;\\n            for(auto itr:candies){\\n                totalkitnipilesbnsktihjismecandiesho+=(itr/mid);\\n            }\\n            if(totalkitnipilesbnsktihjismecandiesho>=k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581042,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long lo = 1, hi = Integer.MAX_VALUE;\\n        long ans=0;\\n        while(lo <= hi){\\n            long mid = (lo+hi)/2;\\n            long maxCandies=0;\\n            for(int i:candies){\\n                maxCandies += i/mid;\\n            }\\n            if(maxCandies >= k){\\n                ans = mid;\\n                lo = mid+1;\\n            } else{\\n                hi = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long lo = 1, hi = Integer.MAX_VALUE;\\n        long ans=0;\\n        while(lo <= hi){\\n            long mid = (lo+hi)/2;\\n            long maxCandies=0;\\n            for(int i:candies){\\n                maxCandies += i/mid;\\n            }\\n            if(maxCandies >= k){\\n                ans = mid;\\n                lo = mid+1;\\n            } else{\\n                hi = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568094,
                "title": "possible-and-impossible-bound",
                "content": "# Approach\\nLet l be the lower bound of return value and r be the upper bound of lowest impossible value.\\nWhen l and r differ by 1, then l is what we want.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int: \\n        l = 0 #True\\n        r = sum(candies) // k + 1 #False\\n\\n        while r - l > 1:\\n            m = (l + r) // 2\\n\\n            if sum(x // m for x in candies) >= k:\\n                l = m\\n            else:\\n                r = m\\n        \\n        return l\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int: \\n        l = 0 #True\\n        r = sum(candies) // k + 1 #False\\n\\n        while r - l > 1:\\n            m = (l + r) // 2\\n\\n            if sum(x // m for x in candies) >= k:\\n                l = m\\n            else:\\n                r = m\\n        \\n        return l\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567696,
                "title": "easy-approach-to-solve-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    long long satisfiedchildren(int candiesperperson,vector<int>& candies ){\\n        long long  ans=0;\\n        int n=candies.size();\\n        for(int i=0; i<n; i++){\\n            ans += (candies[i]/candiesperperson);\\n\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int max_ele=INT_MIN;\\n        long long sum=0 , n=candies.size();\\n        for(int i=0; i<n; i++){\\n            max_ele= max(max_ele,candies[i]);\\n            sum+=candies[i];\\n        }\\n        if(sum<k) return 0;\\n\\n        int s=1, e=max_ele;\\n        int ans;\\n        while(s<=e)\\n        {\\n            int candiesperperson = s + (e-s)/2;\\n            long long sc = satisfiedchildren(candiesperperson, candies);\\n            if(sc>=k){\\n                ans=candiesperperson;\\n                s=candiesperperson+1;\\n            }\\n            else{\\n                e=candiesperperson-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    long long satisfiedchildren(int candiesperperson,vector<int>& candies ){\\n        long long  ans=0;\\n        int n=candies.size();\\n        for(int i=0; i<n; i++){\\n            ans += (candies[i]/candiesperperson);\\n\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int max_ele=INT_MIN;\\n        long long sum=0 , n=candies.size();\\n        for(int i=0; i<n; i++){\\n            max_ele= max(max_ele,candies[i]);\\n            sum+=candies[i];\\n        }\\n        if(sum<k) return 0;\\n\\n        int s=1, e=max_ele;\\n        int ans;\\n        while(s<=e)\\n        {\\n            int candiesperperson = s + (e-s)/2;\\n            long long sc = satisfiedchildren(candiesperperson, candies);\\n            if(sc>=k){\\n                ans=candiesperperson;\\n                s=candiesperperson+1;\\n            }\\n            else{\\n                e=candiesperperson-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517862,
                "title": "rust-solution-using-binary-search",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n    let k = k as usize;\\n    let mut count = 0;\\n    let candies = candies.into_iter().map(|v| {\\n      count += v as usize;\\n      v as usize\\n    }).collect::<Vec<usize>>();\\n    if count < k {\\n      return 0\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10usize.pow(15);\\n    while left + 1 < right {\\n      let mid = (left+right)/2;\\n      let mut temp = 0;\\n      for &v in &candies {\\n        temp += v / mid;\\n      }\\n\\n      if temp < k {\\n        right = mid;\\n      } else {\\n        left = mid;\\n      }\\n    }\\n    left as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n    let k = k as usize;\\n    let mut count = 0;\\n    let candies = candies.into_iter().map(|v| {\\n      count += v as usize;\\n      v as usize\\n    }).collect::<Vec<usize>>();\\n    if count < k {\\n      return 0\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10usize.pow(15);\\n    while left + 1 < right {\\n      let mid = (left+right)/2;\\n      let mut temp = 0;\\n      for &v in &candies {\\n        temp += v / mid;\\n      }\\n\\n      if temp < k {\\n        right = mid;\\n      } else {\\n        left = mid;\\n      }\\n    }\\n    left as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495761,
                "title": "easy-to-understand-javascript-solution-binary-search",
                "content": "```\\nvar maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };\\n\\n    while (min < max) {\\n        const mid = Math.floor((min + max) / 2);\\n\\n        isEnough(mid) ? min = mid + 1 : max = mid;\\n    }\\n    return min - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };\\n\\n    while (min < max) {\\n        const mid = Math.floor((min + max) / 2);\\n\\n        isEnough(mid) ? min = mid + 1 : max = mid;\\n    }\\n    return min - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462275,
                "title": "python-binary-search-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        ans,low, high = 0,1, max(candies)\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=0\\n            c=0\\n            while i < len(candies):\\n                c+=candies[i]//mid \\n# integer division to to get number of children consuming mid from each pile \\n                i+=1\\n            if c>=k: \\n# if more than k children can consume candies from piles, it is possible that k children can receive more candies instead\\n                ans=mid\\n                low = mid + 1\\n            else:\\n                high = mid-1\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        ans,low, high = 0,1, max(candies)\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=0\\n            c=0\\n            while i < len(candies):\\n                c+=candies[i]//mid \\n# integer division to to get number of children consuming mid from each pile \\n                i+=1\\n            if c>=k: \\n# if more than k children can consume candies from piles, it is possible that k children can receive more candies instead\\n                ans=mid\\n                low = mid + 1\\n            else:\\n                high = mid-1\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387141,
                "title": "java-easy-solution-aasheesh-111th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start = 0, end = 0 , ans = 0;\\n        for(int can:candies)    end = Math.max(end , can);\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) /2;\\n            boolean flag = check(candies, k , mid);\\n            if(flag)    end = mid - 1;\\n            else{\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int[] candies, long k, int mid) {\\n        if(mid == 0)    return false;\\n        long sum = 0;\\n        for(int can: candies){\\n            int num = can/mid;\\n            sum +=num;\\n        }\\n        if(sum >= k)   return false;\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start = 0, end = 0 , ans = 0;\\n        for(int can:candies)    end = Math.max(end , can);\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) /2;\\n            boolean flag = check(candies, k , mid);\\n            if(flag)    end = mid - 1;\\n            else{\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int[] candies, long k, int mid) {\\n        if(mid == 0)    return false;\\n        long sum = 0;\\n        for(int can: candies){\\n            int num = can/mid;\\n            sum +=num;\\n        }\\n        if(sum >= k)   return false;\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385996,
                "title": "simple-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long total =0;\\n        for(auto x:candies){\\n            total += x;\\n        }\\n\\n        if(total < k ){\\n            return 0;\\n        }\\n\\n        if(total == k){\\n            return 1;\\n        }\\n\\n        long long l = 1, r = total;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            long long piles = 0;\\n            for(auto x:candies){\\n                piles += x / mid;\\n            }\\n\\n            if(piles >= k){\\n                ans = max(ans, mid);\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long total =0;\\n        for(auto x:candies){\\n            total += x;\\n        }\\n\\n        if(total < k ){\\n            return 0;\\n        }\\n\\n        if(total == k){\\n            return 1;\\n        }\\n\\n        long long l = 1, r = total;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            long long piles = 0;\\n            for(auto x:candies){\\n                piles += x / mid;\\n            }\\n\\n            if(piles >= k){\\n                ans = max(ans, mid);\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384561,
                "title": "easy-to-understand-solution-using-binary-search-in-c",
                "content": "# Approach\\n  => Try to distrubute with large value of chocolates\\n  => Inside binary search, try to see if the chocolates can be distributed among n no. of childrens.\\n  => If it can be distributed then set your  start = mid + 1 and answer = mid value\\n  => Otherwise set end = mid - 1 \\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumCandies(int[] candies, long k) {\\n        int ans = 0;\\n        int start = 1;\\n        int end =  (int) 1e9;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long count = 0;\\n            for(int i=0;i<candies.Length;i++){\\n                if(candies[i] >= mid){\\n                    count +=  candies[i] / mid;\\n                }\\n            }\\n            if(count < k){\\n                end = mid -1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumCandies(int[] candies, long k) {\\n        int ans = 0;\\n        int start = 1;\\n        int end =  (int) 1e9;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long count = 0;\\n            for(int i=0;i<candies.Length;i++){\\n                if(candies[i] >= mid){\\n                    count +=  candies[i] / mid;\\n                }\\n            }\\n            if(count < k){\\n                end = mid -1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384435,
                "title": "c-binary-search-o-nlog-max-nums-i",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,long long num,long long k){\\n        \\n        long long students=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<num){\\n                continue;\\n            }\\n            else{\\n                int x=nums[i]/num;\\n                students=students+x;\\n                if(students>=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        if(students<k){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long start=1;\\n        int maxi=-1e9;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,candies[i]);\\n        }\\n        long long end=maxi;\\n        long long ans=0;\\n        while(start<=end){\\n            \\n            long long mid=(start+end)/2;\\n            if(ispossible(candies,mid,k)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,long long num,long long k){\\n        \\n        long long students=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<num){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3383004,
                "title": "c-easy-solution-binary-search-for-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long int sum=0;\\n        for(auto x:c) sum+=x;\\n        if(sum<k) return 0; // if total candies is less than the sum then we can not allote atleast one to everyone , So ans is 0\\n        \\n       long long int s=1;\\n        long long int e=sum/k;   //this is the max candies that a child can get,\\n        long long int ans;\\n        while(s<=e){\\n            long long int mid=s+(e-s)/2;\\n            if(isPossible(mid,k,c)){         //this function will tell us, is it possible to allot mid no. of candies to allot a child\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    private: bool isPossible(long long int mid,long long int k,vector<int>&c){\\n        for(auto x:c){\\n            k-=(x/mid);\\n        }\\n        return k<=0?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long int sum=0;\\n        for(auto x:c) sum+=x;\\n        if(sum<k) return 0; // if total candies is less than the sum then we can not allote atleast one to everyone , So ans is 0\\n        \\n       long long int s=1;\\n        long long int e=sum/k;   //this is the max candies that a child can get,\\n        long long int ans;\\n        while(s<=e){\\n            long long int mid=s+(e-s)/2;\\n            if(isPossible(mid,k,c)){         //this function will tell us, is it possible to allot mid no. of candies to allot a child\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    private: bool isPossible(long long int mid,long long int k,vector<int>&c){\\n        for(auto x:c){\\n            k-=(x/mid);\\n        }\\n        return k<=0?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1688215,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 1570836,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 1926229,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 2006201,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            }
        ]
    }
]