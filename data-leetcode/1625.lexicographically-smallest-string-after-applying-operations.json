[
    {
        "title": "Largest Substring Between Two Equal Characters",
        "question_content": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.\nExample 2:\n\nInput: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".\n\nExample 3:\n\nInput: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 300\n\ts contains only lowercase English letters.",
        "solutions": [
            {
                "id": 899464,
                "title": "java-python-3-one-pass-o-n-11-4-liners-w-brief-explanation-and-analysis",
                "content": "Loop through the input string `s`\\n1. Store the first index of the substring between same characters;\\n2. If current character seen before, compute the length of the sustring between them and update the max length; \\n```java\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] indices = new int[26];\\n        int maxLen = -1;\\n        for (int i = 0; i < s.length(); ++i) {\\n            int idx = s.charAt(i) - \\'a\\';\\n            if (indices[idx] > 0) {\\n                maxLen = Math.max(maxLen, i - indices[idx]);\\n            }else {\\n                indices[idx] = i + 1;\\n            }\\n        }\\n        return maxLen;\\n    }\\n```\\n```python\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        maxLen, indices = -1, {}\\n        for i, c in enumerate(s):\\n            maxLen = max(maxLen, i - indices.setdefault(c, i + 1))\\n        return maxLen        \\n```\\n@StefanPochmann\\'s solution:\\n```python\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        return max(map(sub, count(), map({}.setdefault, s, count(1))))\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = s.length()`.",
                "solutionTags": [],
                "code": "```java\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] indices = new int[26];\\n        int maxLen = -1;\\n        for (int i = 0; i < s.length(); ++i) {\\n            int idx = s.charAt(i) - \\'a\\';\\n            if (indices[idx] > 0) {\\n                maxLen = Math.max(maxLen, i - indices[idx]);\\n            }else {\\n                indices[idx] = i + 1;\\n            }\\n        }\\n        return maxLen;\\n    }\\n```\n```python\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        maxLen, indices = -1, {}\\n        for i, c in enumerate(s):\\n            maxLen = max(maxLen, i - indices.setdefault(c, i + 1))\\n        return maxLen        \\n```\n```python\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        return max(map(sub, count(), map({}.setdefault, s, count(1))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 899779,
                "title": "c-minimalizm",
                "content": "```cpp\\nint maxLengthBetweenEqualCharacters(string s) {\\n    int idx[26] = {}, res = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        if (idx[s[i] - \\'a\\'] == 0)\\n            idx[s[i] - \\'a\\'] = i + 1;\\n        res = max(res, i - idx[s[i] - \\'a\\']);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxLengthBetweenEqualCharacters(string s) {\\n    int idx[26] = {}, res = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        if (idx[s[i] - \\'a\\'] == 0)\\n            idx[s[i] - \\'a\\'] = i + 1;\\n        res = max(res, i - idx[s[i] - \\'a\\']);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905287,
                "title": "1624-python-3-fast-functional-one-liner-explained",
                "content": "For each character `ch` that occurs in `s` one or more times the length of the longest contained substring equals to `s.rfind(ch) - s.find(ch) -1`. If a character occurs only once at position `x` this expression equals to ` x - x - 1 = -1`. The solution is largest of all longest contained substring lengths for the elements of `set(s)`:\\n```\\nclass SolutionI:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        return max(s.rfind(ch) - s.find(ch) - 1 for ch in set(s))\\n```\\n\\nTime complexity: **O(n)**; Space complexity: **O(1)**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SolutionI:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        return max(s.rfind(ch) - s.find(ch) - 1 for ch in set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899573,
                "title": "c-one-pass-map-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        std::unordered_map<char, int> mp; // key: character, value: least index of character in s\\n        int len = -1;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(mp.count(s[i])) len = max(len, i - mp[s[i]] - 1);\\n            else mp[s[i]] = i;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        std::unordered_map<char, int> mp; // key: character, value: least index of character in s\\n        int len = -1;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(mp.count(s[i])) len = max(len, i - mp[s[i]] - 1);\\n            else mp[s[i]] = i;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899540,
                "title": "python3-via-dictionary",
                "content": "Memoize the first occurrence of a character. \\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ans = -1\\n        seen = {}\\n        for i, c in enumerate(s): \\n            if c in seen: ans = max(ans, i - seen[c] - 1)\\n            seen.setdefault(c, i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ans = -1\\n        seen = {}\\n        for i, c in enumerate(s): \\n            if c in seen: ans = max(ans, i - seen[c] - 1)\\n            seen.setdefault(c, i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123638,
                "title": "simple-java-solution-hashmap-o-n-time-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Store each char along with their position in a HashMap.\\n- If a char occurs again, calc their index diffrences.\\n- return the max difference.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(min(n, k))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res=-1;\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(hm.containsKey(c))\\n                res=Math.max(res,i-hm.get(c)-1);\\n            else\\n                hm.put(c,i);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res=-1;\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(hm.containsKey(c))\\n                res=Math.max(res,i-hm.get(c)-1);\\n            else\\n                hm.put(c,i);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899503,
                "title": "one-pass-hashmap-solution-and-o-1-space-solution",
                "content": "We can use a HashMap (or an array, but it is the same idea behind) to store the **first time** occurence index. \\nIf we meet the same character again, we can calculate the length and compare to the final result. That is it! :)\\n\\n**Solution 1: *O(n)* time and *O(n)* space complexity**\\n```\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res = -1;\\n        char[] ch = s.toCharArray();\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for (int i=0 ; i<s.length(); i++) {\\n            if (map.containsKey(ch[i])) {\\n                res = Math.max(res, i - 1 - map.get(ch[i]));\\n            } else {\\n                map.put(ch[i], i);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Solution 2 (inspired by pgmreddy): O(n^2) time and *O(1)* space complexity**\\n```\\n    public int maxLengthBetweenEqualCharacters(String s) {        \\n        int res = -1;   \\n        int len = s.length();\\n        for (int i=0; i<len; i++){\\n            char c = s.charAt(i);\\n            int firstPos = s.indexOf(c); // The time complexity of indexOf() is O(n)!\\n            int lastPos = s.lastIndexOf(c); // The time complexity of lastIndexOf() is O(n)!\\n            res = Math.max(res, lastPos - firstPos - 1);\\n        }   \\n        return res; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res = -1;\\n        char[] ch = s.toCharArray();\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for (int i=0 ; i<s.length(); i++) {\\n            if (map.containsKey(ch[i])) {\\n                res = Math.max(res, i - 1 - map.get(ch[i]));\\n            } else {\\n                map.put(ch[i], i);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int maxLengthBetweenEqualCharacters(String s) {        \\n        int res = -1;   \\n        int len = s.length();\\n        for (int i=0; i<len; i++){\\n            char c = s.charAt(i);\\n            int firstPos = s.indexOf(c); // The time complexity of indexOf() is O(n)!\\n            int lastPos = s.lastIndexOf(c); // The time complexity of lastIndexOf() is O(n)!\\n            res = Math.max(res, lastPos - firstPos - 1);\\n        }   \\n        return res; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1173173,
                "title": "python3-simple-and-readable-solution",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ans = [-1]\\n        \\n        for i in set(s):\\n            if(s.count(i) >= 2):\\n                ans.append(s.rindex(i) - s.index(i) - 1 )\\n        \\n        return max(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ans = [-1]\\n        \\n        for i in set(s):\\n            if(s.count(i) >= 2):\\n                ans.append(s.rindex(i) - s.index(i) - 1 )\\n        \\n        return max(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954851,
                "title": "java-faster-solution-0m-100-using-lastindexof",
                "content": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n\\t\\tint max = -1;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tint lastIndex= s.lastIndexOf(s.charAt(i));\\n\\t\\t\\tif(lastIndex != i) \\n\\t\\t\\t\\tmax = Math.max(max, lastIndex - (i+1));\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n\\t\\tint max = -1;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tint lastIndex= s.lastIndexOf(s.charAt(i));\\n\\t\\t\\tif(lastIndex != i) \\n\\t\\t\\t\\tmax = Math.max(max, lastIndex - (i+1));\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899732,
                "title": "python3-one-pass-o-n-solution-large-substring-between-two-equal-characters",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        last, ans = {}, -1 \\n        for i, c in enumerate(s):\\n            if c not in last:\\n                last[c] = i\\n            else:\\n                ans = max(ans, i - last[c] - 1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        last, ans = {}, -1 \\n        for i, c in enumerate(s):\\n            if c not in last:\\n                last[c] = i\\n            else:\\n                ans = max(ans, i - last[c] - 1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 899484,
                "title": "java-map-solution",
                "content": "```java\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int ans = -1;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch  = s.charAt(i);\\n            if (map.containsKey(ch)) {\\n                ans = Math.max(ans, i - 1 - map.get(ch));\\n            }\\n            else {\\n                map.put(ch, i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int ans = -1;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch  = s.charAt(i);\\n            if (map.containsKey(ch)) {\\n                ans = Math.max(ans, i - 1 - map.get(ch));\\n            }\\n            else {\\n                map.put(ch, i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899458,
                "title": "python-easy",
                "content": "```\\nclass Solution(object):\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        lastSeen = dict()\\n        maxDist = -1\\n        for index, char in enumerate(s):\\n            if char not in lastSeen:\\n                lastSeen[char] = index\\n            else:\\n                maxDist = max(index - lastSeen[char], maxDist)\\n                \\n        return maxDist - 1 if maxDist > -1 else -1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        lastSeen = dict()\\n        maxDist = -1\\n        for index, char in enumerate(s):\\n            if char not in lastSeen:\\n                lastSeen[char] = index\\n            else:\\n                maxDist = max(index - lastSeen[char], maxDist)\\n                \\n        return maxDist - 1 if maxDist > -1 else -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424643,
                "title": "yet-another-python-solution-o-n",
                "content": "1. Create a map to keep the first occurrence of the character in the string ```s```.\\n2. If the next character is already on the map - we update the max distance.\\n\\nComplexity O(N) - one loop\\nMemory: at first sight, it is also O(N). But if the number of characters is limited by the English alphabet, then to store the map we need only O(26) which is O(1).\\n\\n*Please upvote if you like for motivation and karma :)*\\n\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        \\n        charToID = dict()\\n        maxDist = -1\\n        \\n        for i, ch in enumerate(s):\\n            if ch not in charToID:\\n                charToID[ch] = i\\n            else:\\n                maxDist = max(maxDist, i - charToID[ch] -1)\\n        \\n        return maxDist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```s```\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        \\n        charToID = dict()\\n        maxDist = -1\\n        \\n        for i, ch in enumerate(s):\\n            if ch not in charToID:\\n                charToID[ch] = i\\n            else:\\n                maxDist = max(maxDist, i - charToID[ch] -1)\\n        \\n        return maxDist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389937,
                "title": "c-simple-and-short-one-pass-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<int> v(26, -1);\\n        int maxi = -1;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (v[s[i] - \\'a\\'] == -1) v[s[i] - \\'a\\'] = i;\\n            else maxi = max(maxi, abs(v[s[i] - \\'a\\'] - i) - 1);      \\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<int> v(26, -1);\\n        int maxi = -1;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (v[s[i] - \\'a\\'] == -1) v[s[i] - \\'a\\'] = i;\\n            else maxi = max(maxi, abs(v[s[i] - \\'a\\'] - i) - 1);      \\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389939,
                "title": "python-solutiun-via-dictionary-faster-than-100",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        dict = {}\\n        result = -1\\n        for i, c in enumerate(s):\\n            if c in dict:\\n                result = max(result, i - dict[c] - 1)\\n            else:\\n                dict[c] = i\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        dict = {}\\n        result = -1\\n        for i, c in enumerate(s):\\n            if c in dict:\\n                result = max(result, i - dict[c] - 1)\\n            else:\\n                dict[c] = i\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144788,
                "title": "c-clean-solutions-and-comparison-between-o-26-n-time-o-1-space-vs-o-n-time-o-26-space",
                "content": "Hey, well the goal is to go by the letter and find it\\'s end points. We can do that using two pointers: O(26*N) time || O(1) space \\n\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int ret = -1, l, r;\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            l = 0, r = s.size() - 1;\\n            while (l < r && s[l] != i) l++;\\n            while (l < r && s[r] != i) r--;\\n            ret = max(ret, r - l - 1);\\n        }\\n        return ret;\\n    }\\n};\\n```\\nThe solution above is good for memory, but time is probably more important (most of the time) than extra 26 memory.\\n\\nThe best solution (timewise) is to remember first encounter of a letter and use it to calculate our answer: O(N) time || O(26) space\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int m[26] = {};\\n        int ret = -1;\\n        for (int i = 0; i < s.size(); i++) {\\n            int j = m[s[i] - \\'a\\'];\\n            if (j != 0)\\n                ret = max(ret, i - j);\\n            else \\n                m[s[i] - \\'a\\'] = i + 1;\\n        }\\n        return ret;\\n    }\\n};\\n```\\nOr the same but more unreadable: O(N) time || O(123) space\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int m[123] = {}, ret = -1;\\n        for (int i = 0; i < s.size(); ret = max(ret, i - m[s[i++]])) \\n            if (m[s[i]] == 0)\\n                m[s[i]] = i + 1;\\n        return ret;\\n    }\\n};\\n```\\nNote: m[123] is such a nice array, it is easy to type 123 and you don\\'t have to substact anything from letters as it includes letters up to \\'z\\' (Also includes uppercase letters, of course, but useless for this problem).",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int ret = -1, l, r;\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            l = 0, r = s.size() - 1;\\n            while (l < r && s[l] != i) l++;\\n            while (l < r && s[r] != i) r--;\\n            ret = max(ret, r - l - 1);\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int m[26] = {};\\n        int ret = -1;\\n        for (int i = 0; i < s.size(); i++) {\\n            int j = m[s[i] - \\'a\\'];\\n            if (j != 0)\\n                ret = max(ret, i - j);\\n            else \\n                m[s[i] - \\'a\\'] = i + 1;\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int m[123] = {}, ret = -1;\\n        for (int i = 0; i < s.size(); ret = max(ret, i - m[s[i++]])) \\n            if (m[s[i]] == 0)\\n                m[s[i]] = i + 1;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900314,
                "title": "java-easy-3-lines-just-one-loop-using-indexof-lastindexof-100",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) { \\n    int max_len = -1;          \\n    for ( char ch : s.toCharArray()){\\n        max_len = Math.max(max_len, s.lastIndexOf(ch) - s.indexOf(ch)-1); // to exclude the 2 chars .   \\n    }   \\n    return(max_len); \\n }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) { \\n    int max_len = -1;          \\n    for ( char ch : s.toCharArray()){\\n        max_len = Math.max(max_len, s.lastIndexOf(ch) - s.indexOf(ch)-1); // to exclude the 2 chars .   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 899501,
                "title": "java-brute-force-solution",
                "content": "Java Easy Solution\\n``` \\npublic int maxLengthBetweenEqualCharacters(String s) {\\n        int count = 0;\\n    \\t int ans = -1;\\n    \\t for (int i = 0; i < s.length()-1; i++) {\\n\\t\\t\\tfor (int j = i+1; j < s.length(); j++) {\\n\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j)) {\\n\\t\\t\\t\\t\\tcount = j-i-1;\\n\\t\\t\\t\\t\\tif(ans<count) {\\n\\t\\t\\t\\t\\t\\tans = count;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n\\t```\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\npublic int maxLengthBetweenEqualCharacters(String s) {\\n        int count = 0;\\n    \\t int ans = -1;\\n    \\t for (int i = 0; i < s.length()-1; i++) {\\n\\t\\t\\tfor (int j = i+1; j < s.length(); j++) {\\n\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j)) {\\n\\t\\t\\t\\t\\tcount = j-i-1;\\n\\t\\t\\t\\t\\tif(ans<count) {\\n\\t\\t\\t\\t\\t\\tans = count;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3033179,
                "title": "naive-brute-force-c-approach",
                "content": "# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int ans=-1,x;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i+1;j<s.length();j++){\\n                if(s[i]==s[j])\\n                    x=j-i-1;\\n                    ans=max(ans,x);\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int ans=-1,x;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=i+1;j<s.length();j++){\\n                if(s[i]==s[j])\\n                    x=j-i-1;\\n                    ans=max(ans,x);\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776961,
                "title": "simple-python-string-matching-easy",
                "content": "Keep track of the indices of the characters in hashmap and do a difference of the maximum\\n\\n* PLEASE UPVOTE IF THIS METHOD IS USEFUL !\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dic = dict()\\n        maxer=-1\\n        for i,val in enumerate(s):\\n            if val in dic:\\n                diff=i-dic[val]-1\\n                maxer = max(maxer,diff)\\n            else:\\n                dic[val]=i\\n        return maxer\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dic = dict()\\n        maxer=-1\\n        for i,val in enumerate(s):\\n            if val in dic:\\n                diff=i-dic[val]-1\\n                maxer = max(maxer,diff)\\n            else:\\n                dic[val]=i\\n        return maxer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893535,
                "title": "100-faster-hashing-unordered-map",
                "content": "100% FASTER || O(N) SOLUTION\\nSimply storing index of first occrance and then maintining a vector containig all substring ending with that char. At last we find max length substring\\n\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        unordered_map<char,pair<int,int>>mp;    // idx, count\\n        int i, j=0 , n=s.size();\\n        vector<string> ans;       // substrings\\n        for(i=0 ; i<n ; i++ ){\\n            if(mp.find(s[i])==mp.end()){\\n                mp[s[i]]={i,1};\\n            }\\n            else {\\n                j=mp[s[i]].first;\\n                ans.push_back(s.substr(j+1,i-j-1));\\n            }\\n        }\\n        if(ans.size()==0) return -1;\\n        int sz=INT_MIN;\\n        for( auto ss: ans){\\n            int t= ss.size();\\n            sz=max(sz,t);\\n        }\\n        return sz;\\n    }",
                "solutionTags": [],
                "code": "100% FASTER || O(N) SOLUTION\\nSimply storing index of first occrance and then maintining a vector containig all substring ending with that char. At last we find max length substring\\n\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        unordered_map<char,pair<int,int>>mp;    // idx, count\\n        int i, j=0 , n=s.size();\\n        vector<string> ans;       // substrings\\n        for(i=0 ; i<n ; i++ ){\\n            if(mp.find(s[i])==mp.end()){\\n                mp[s[i]]={i,1};\\n            }\\n            else {\\n                j=mp[s[i]].first;\\n                ans.push_back(s.substr(j+1,i-j-1));\\n            }\\n        }\\n        if(ans.size()==0) return -1;\\n        int sz=INT_MIN;\\n        for( auto ss: ans){\\n            int t= ss.size();\\n            sz=max(sz,t);\\n        }\\n        return sz;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1263585,
                "title": "java-o-n-time-and-o-1-space",
                "content": "```class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int maxLength = -1;\\n        int[] indexStore = new int[26]; // Array with constant length of 26\\n        Arrays.fill(indexStore, -1); //fill array with -1 for all not found chars\\n        \\n        for(int i = 0; i < s.length(); i++ ) {\\n            if(indexStore[s.charAt(i) - \\'a\\'] != -1) { // check if char was previously found\\n                int length = i - indexStore[s.charAt(i) - \\'a\\'] - 1;\\n                maxLength = Math.max(maxLength, length);\\n            } else {\\n                indexStore[s.charAt(i) - \\'a\\'] = i; //put index of char replacing -1\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int maxLength = -1;\\n        int[] indexStore = new int[26]; // Array with constant length of 26\\n        Arrays.fill(indexStore, -1); //fill array with -1 for all not found chars\\n        \\n        for(int i = 0; i < s.length(); i++ ) {\\n            if(indexStore[s.charAt(i) - \\'a\\'] != -1) { // check if char was previously found\\n                int length = i - indexStore[s.charAt(i) - \\'a\\'] - 1;\\n                maxLength = Math.max(maxLength, length);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1185385,
                "title": "js-easy-to-understand-for-beginners-as-well",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    \\n    const map = new Map();\\n    let max=-1;\\n    for(let i=0;i<s.length;i++){\\n\\n        if(map.has(s[i])){\\n            max=Math.max(max,i-(map.get(s[i])+1))\\n        }else{\\n            map.set(s[i],i)    \\n        }\\n        \\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    \\n    const map = new Map();\\n    let max=-1;\\n    for(let i=0;i<s.length;i++){\\n\\n        if(map.has(s[i])){\\n            max=Math.max(max,i-(map.get(s[i])+1))\\n        }else{\\n            map.set(s[i],i)    \\n        }\\n        \\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902667,
                "title": "php-one-pass-solution-o-n-0ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function maxLengthBetweenEqualCharacters($s) {\\n        $map = [];\\n        $max = -1;\\n\\n        foreach (str_split($s) as $i => $ch)\\n            if (!isset($map[$ch])) {\\n                $map[$ch] = $i;\\n            } elseif ($i - $map[$ch] - 1 > $max) {\\n                $max = $i - $map[$ch] - 1;\\n            }\\n\\n        return $max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function maxLengthBetweenEqualCharacters($s) {\\n        $map = [];\\n        $max = -1;\\n\\n        foreach (str_split($s) as $i => $ch)\\n            if (!isset($map[$ch])) {\\n                $map[$ch] = $i;\\n            } elseif ($i - $map[$ch] - 1 > $max) {\\n                $max = $i - $map[$ch] - 1;\\n            }\\n\\n        return $max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899492,
                "title": "javascript-hashmap",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let map = new Map();//map {char: index}\\n    let maxDist = -1;\\n    for (let i = 0; i < s.length; i++){\\n        let ch = s.charAt(i);\\n        if (!map.has(ch)){\\n            map.set(ch, i);\\n        } else {\\n            let lastIdx = map.get(ch);\\n            let dist = i-lastIdx-1 // excluding duplicate letters\\n            maxDist = Math.max(maxDist, dist);\\n        }\\n    }\\n    return maxDist;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let map = new Map();//map {char: index}\\n    let maxDist = -1;\\n    for (let i = 0; i < s.length; i++){\\n        let ch = s.charAt(i);\\n        if (!map.has(ch)){\\n            map.set(ch, i);\\n        } else {\\n            let lastIdx = map.get(ch);\\n            let dist = i-lastIdx-1 // excluding duplicate letters\\n            maxDist = Math.max(maxDist, dist);\\n        }\\n    }\\n    return maxDist;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968801,
                "title": "easy-to-understand-100-beats-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        \\n        unordered_map<char,int>mp;\\n        int ans = -1;\\n\\n        for(int i =0;i<s.size();i++){\\n\\n            if(mp.find(s[i])!=mp.end()){\\n                ans = max(ans,i-mp[s[i]]-1);\\n            }\\n            else{\\n                mp[s[i]]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        \\n        unordered_map<char,int>mp;\\n        int ans = -1;\\n\\n        for(int i =0;i<s.size();i++){\\n\\n            if(mp.find(s[i])!=mp.end()){\\n                ans = max(ans,i-mp[s[i]]-1);\\n            }\\n            else{\\n                mp[s[i]]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775215,
                "title": "best-java-solution-in-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the string can contain only lower case alphabets make an Array of length 26 \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Run a loop to read char of the string and store index of each alphabet at their first occurance in the Array.\\n2. On second occurance of any char subtract it\\'s index by first index of the same.\\n3. Compare the value with max which has default value -1.\\n4. if the value is greator than max update max value with the same.\\n5. Return max.\\n6. Do Upvote if you got it. Thanks\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n\\n        int n = s.length();\\n\\n        int arr[] = new int [26];\\n        int max = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            int idx = s.charAt(i) - \\'a\\';\\n            if( arr[idx] > 0){\\n                max = Math.max(max, i - arr[idx]);\\n            }else{\\n                arr[idx] = i + 1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n\\n        int n = s.length();\\n\\n        int arr[] = new int [26];\\n        int max = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            int idx = s.charAt(i) - \\'a\\';\\n            if( arr[idx] > 0){\\n                max = Math.max(max, i - arr[idx]);\\n            }else{\\n                arr[idx] = i + 1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871327,
                "title": "59ms-runtime-beats-98-direct-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let max = -Infinity\\n    for (let i = 0; i < s.length; i++) {\\n        for (let j = s.length - 1; j > i; j--) {\\n            if (s[i] == s[j]) {\\n                max = Math.max(max, j - i - 1)\\n                break;\\n            }\\n        }\\n    }\\n    if (max == -Infinity) return -1\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let max = -Infinity\\n    for (let i = 0; i < s.length; i++) {\\n        for (let j = s.length - 1; j > i; j--) {\\n            if (s[i] == s[j]) {\\n                max = Math.max(max, j - i - 1)\\n                break;\\n            }\\n        }\\n    }\\n    if (max == -Infinity) return -1\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2747693,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int maxLengthBetweenEqualCharacters(string s) {\\n    int idx[26] = {}, res = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        if (idx[s[i] - \\'a\\'] == 0)\\n            idx[s[i] - \\'a\\'] = i + 1;\\n        res = max(res, i - idx[s[i] - \\'a\\']);\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int maxLengthBetweenEqualCharacters(string s) {\\n    int idx[26] = {}, res = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        if (idx[s[i] - \\'a\\'] == 0)\\n            idx[s[i] - \\'a\\'] = i + 1;\\n        res = max(res, i - idx[s[i] - \\'a\\']);\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505756,
                "title": "o-n-just-by-one-pointer-and-indexof",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int end = s.length()-1;\\n        int res=-1;\\n        while(end>=0){\\n            int a = s.indexOf(s.charAt(end));\\n            if(a!=end)\\n                res = Math.max(res, end-a-1);\\n            end--;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int end = s.length()-1;\\n        int res=-1;\\n        while(end>=0){\\n            int a = s.indexOf(s.charAt(end));\\n            if(a!=end)\\n                res = Math.max(res, end-a-1);\\n            end--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2462880,
                "title": "simple-approach",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n       int largest= -1;\\n        for(int i=0; i<s.length(); i++){\\n            char current_ch= s.charAt(i);\\n            int lastIndex = s.lastIndexOf(current_ch); // give last index of current_index;\\n            if(lastIndex!=i){\\n                largest=Math.max(largest,lastIndex-i-1);\\n            }\\n        }\\n            \\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n       int largest= -1;\\n        for(int i=0; i<s.length(); i++){\\n            char current_ch= s.charAt(i);\\n            int lastIndex = s.lastIndexOf(current_ch); // give last index of current_index;\\n            if(lastIndex!=i){\\n                largest=Math.max(largest,lastIndex-i-1);\\n            }\\n        }\\n            \\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854792,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max = -1;\\n        for(int i=97;i<123;i++)\\n        {\\n            max= Math.max(s.lastIndexOf((char)i)-s.indexOf((char)i)-1,max);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max = -1;\\n        for(int i=97;i<123;i++)\\n        {\\n            max= Math.max(s.lastIndexOf((char)i)-s.indexOf((char)i)-1,max);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1803578,
                "title": "c-0ms-short-concise-solution-constant-space",
                "content": "**Please do upvote if you liked my approach. It is a great motivation to write more such solutions :)**\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) \\n    {\\n        int hash[26] = {0};\\n        int ans = -1;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(hash[s[i]-\\'a\\'] == 0)\\n                hash[s[i]-\\'a\\'] = i+1;\\n            else\\n                ans = max(ans, i-hash[s[i]-\\'a\\']);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) \\n    {\\n        int hash[26] = {0};\\n        int ans = -1;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(hash[s[i]-\\'a\\'] == 0)\\n                hash[s[i]-\\'a\\'] = i+1;\\n            else\\n                ans = max(ans, i-hash[s[i]-\\'a\\']);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685279,
                "title": "stressful",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n\\t\\tint mx = -1;\\n\\t\\tchar[] arr = s.toCharArray() ;\\n\\t\\tfor(int i=0 ;i<arr.length ;i++) {\\n\\t\\t\\tString str = s.substring(i+1) ;\\n\\t\\t\\tint temp = str.lastIndexOf(s.charAt(i)) ;\\n\\t\\t\\t\\tmx = Math.max(mx ,  temp) ;\\n\\t\\t}\\n\\t\\treturn mx ;\\n    }\\n    \\n}\\n\\n```\\n\\n/*\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n\\t\\tint max = -1;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tint lastIndex= s.lastIndexOf(s.charAt(i));\\n\\t\\t\\tif(lastIndex != i) \\n\\t\\t\\t\\tmax = Math.max(max, lastIndex - (i+1));\\n\\t\\t}\\n\\t\\treturn max;\\n   }\\n\\n*/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n\\t\\tint mx = -1;\\n\\t\\tchar[] arr = s.toCharArray() ;\\n\\t\\tfor(int i=0 ;i<arr.length ;i++) {\\n\\t\\t\\tString str = s.substring(i+1) ;\\n\\t\\t\\tint temp = str.lastIndexOf(s.charAt(i)) ;\\n\\t\\t\\t\\tmx = Math.max(mx ,  temp) ;\\n\\t\\t}\\n\\t\\treturn mx ;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633649,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int min[]=new int[26];\\n        int max[]=new int[26];\\n        for(int i=0;i<s.length();i++) max[s.charAt(i)-97]=i;\\n        for(int i=s.length()-1;i>=0;i--) min[s.charAt(i)-97]=i;\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<26;i++) ans=Math.max(ans,max[i]-min[i]-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int min[]=new int[26];\\n        int max[]=new int[26];\\n        for(int i=0;i<s.length();i++) max[s.charAt(i)-97]=i;\\n        for(int i=s.length()-1;i>=0;i--) min[s.charAt(i)-97]=i;\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<26;i++) ans=Math.max(ans,max[i]-min[i]-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319447,
                "title": "c-beginner-friendly-highly-readable-code",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        unordered_map<char,int> umap;\\n        int ans=-1;\\n        \\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(umap.find(c)!=umap.end())\\n\\t\\t\\t   ans=max(ans,i-umap[c]-1);\\n            else \\n\\t\\t\\t   umap[c]=i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        unordered_map<char,int> umap;\\n        int ans=-1;\\n        \\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(umap.find(c)!=umap.end())\\n\\t\\t\\t   ans=max(ans,i-umap[c]-1);\\n            else \\n\\t\\t\\t   umap[c]=i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232083,
                "title": "java-2-solution-brute-force-optimized",
                "content": "**Brute Force**\\n```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n        int max = 0;\\n        boolean flag = false; \\n        for(int i = 0;i<s.length();i++){\\n            int cm = 0;\\n          for(int j = i+1;j<s.length();j++){\\n            if(s.charAt(i)==s.charAt(j)){\\n                 cm = j - i - 1;\\n                 flag = true;\\n            }\\n          }\\n          max = Math.max(max,cm);\\n        }\\n      if(flag == false) return -1;\\n      return max;\\n    }\\n```\\n**Optimized**\\n```\\nclass Solution {\\n    static class Pair{\\n          int fo;  //first occurrence\\n          int lo;  //last occurrence\\n      \\n        public Pair(int fo, int lo){\\n              this.fo = fo;\\n              this.lo = lo;\\n        }\\n    }\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        Pair freq[] = new Pair[26];\\n        int max = 0;\\n        boolean flag = false;\\n        for(int i = 0;i<s.length();i++){\\n           char c = s.charAt(i);\\n           if(freq[c-\\'a\\'] != null){\\n             freq[c-\\'a\\'] = new Pair(freq[c-\\'a\\'].fo,i);\\n             flag = true;\\n             int size = freq[c-\\'a\\'].lo - freq[c-\\'a\\'].fo - 1;\\n             max = Math.max(max,size);\\n           }\\n          else{\\n             freq[c-\\'a\\'] = new Pair(i,i);\\n          }\\n          \\n        }\\n      if(flag == false) return -1;\\n      return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n        int max = 0;\\n        boolean flag = false; \\n        for(int i = 0;i<s.length();i++){\\n            int cm = 0;\\n          for(int j = i+1;j<s.length();j++){\\n            if(s.charAt(i)==s.charAt(j)){\\n                 cm = j - i - 1;\\n                 flag = true;\\n            }\\n          }\\n          max = Math.max(max,cm);\\n        }\\n      if(flag == false) return -1;\\n      return max;\\n    }\\n```\n```\\nclass Solution {\\n    static class Pair{\\n          int fo;  //first occurrence\\n          int lo;  //last occurrence\\n      \\n        public Pair(int fo, int lo){\\n              this.fo = fo;\\n              this.lo = lo;\\n        }\\n    }\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        Pair freq[] = new Pair[26];\\n        int max = 0;\\n        boolean flag = false;\\n        for(int i = 0;i<s.length();i++){\\n           char c = s.charAt(i);\\n           if(freq[c-\\'a\\'] != null){\\n             freq[c-\\'a\\'] = new Pair(freq[c-\\'a\\'].fo,i);\\n             flag = true;\\n             int size = freq[c-\\'a\\'].lo - freq[c-\\'a\\'].fo - 1;\\n             max = Math.max(max,size);\\n           }\\n          else{\\n             freq[c-\\'a\\'] = new Pair(i,i);\\n          }\\n          \\n        }\\n      if(flag == false) return -1;\\n      return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205094,
                "title": "java-solution-using-indexof-lastindexof-storing-spaces-in-arraylist-and-return-max-from-list",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        if(s.length()==0){\\n            return -1;\\n        }\\n        ArrayList<Integer> space=new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n        char a=s.charAt(i);\\n        int ind=s.indexOf(a,0);\\n        int last=s.lastIndexOf(a);\\n            if(ind==-1)\\n            space.add(ind);\\n        else\\n            space.add(last-(i+1));\\n        }\\n        return Collections.max(space);\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        if(s.length()==0){\\n            return -1;\\n        }\\n        ArrayList<Integer> space=new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n        char a=s.charAt(i);\\n        int ind=s.indexOf(a,0);\\n        int last=s.lastIndexOf(a);\\n            if(ind==-1)\\n            space.add(ind);\\n        else\\n            space.add(last-(i+1));\\n        }\\n        return Collections.max(space);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144948,
                "title": "python-solution-easy",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        \\n        d = defaultdict(list)\\n\\n        for i,char in enumerate(s):\\n            d[char].append(i)\\n\\n        temp = -1\\n        for indices in d.values():\\n            diff = indices[-1] - indices[0] - 1\\n            if diff > temp:\\n                temp = diff\\n                \\n        return temp\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        \\n        d = defaultdict(list)\\n\\n        for i,char in enumerate(s):\\n            d[char].append(i)\\n\\n        temp = -1\\n        for indices in d.values():\\n            diff = indices[-1] - indices[0] - 1\\n            if diff > temp:\\n                temp = diff\\n                \\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110836,
                "title": "js-two-pointer",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let max = -1\\n    for(var i =0 ; i <s.length; i++){\\n        for(var j = s.length-1; j>i ;j--){\\n            if(s[j]===s[i]){\\n                max = Math.max(max, j-i-1)\\n                break\\n            }\\n        }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let max = -1\\n    for(var i =0 ; i <s.length; i++){\\n        for(var j = s.length-1; j>i ;j--){\\n            if(s[j]===s[i]){\\n                max = Math.max(max, j-i-1)\\n                break\\n            }\\n        }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1046821,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        for i, k in enumerate(s):\\n            if k not in d:\\n                d[k] = [i,i]\\n            else:\\n                d[k][1] = i\\n                \\n        return max([i[1] - i[0] - 1 for i in d.values()])\\n                \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        for i, k in enumerate(s):\\n            if k not in d:\\n                d[k] = [i,i]\\n            else:\\n                d[k][1] = i\\n                \\n        return max([i[1] - i[0] - 1 for i in d.values()])\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 981856,
                "title": "java-5-lines-of-cade-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Largest Substring Between Two Equal Characters.\\nMemory Usage: 36.8 MB, less than 67.32% of Java online submissions for Largest Substring Between Two Equal Characters.\\n\\n```\\n\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n\\tint[] arr = new int[26];\\n\\tint max = -1;\\n\\tfor(int i = 0 ; i < s.length() ; i++) arr[s.charAt(i) - \\'a\\'] = i; \\n\\tfor(int i = 0 ; i < s.length() ; i++) max = Math.max((arr[s.charAt(i) -\\'a\\'] - i - 1),max);\\n\\treturn max;\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n\\tint[] arr = new int[26];\\n\\tint max = -1;\\n\\tfor(int i = 0 ; i < s.length() ; i++) arr[s.charAt(i) - \\'a\\'] = i; \\n\\tfor(int i = 0 ; i < s.length() ; i++) max = Math.max((arr[s.charAt(i) -\\'a\\'] - i - 1),max);\\n\\treturn max;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934860,
                "title": "python-3-dict-24-ms-explained",
                "content": "Use a dict to store the array index;\\nIterate the dict values, find the max difference among the chars that appear more than once.\\n~~~\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        mydict = collections.defaultdict(list)\\n        result = -1\\n        for index, char in enumerate(s):\\n            mydict[char].append(index)\\n        for key, value in mydict.items():\\n            if len(value) > 1:\\n                tmp = value[-1] - value[0] - 1\\n                result = max(tmp, result)\\n        return result\\n~~~",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Use a dict to store the array index;\\nIterate the dict values, find the max difference among the chars that appear more than once.\\n~~~\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        mydict = collections.defaultdict(list)\\n        result = -1\\n        for index, char in enumerate(s):\\n            mydict[char].append(index)\\n        for key, value in mydict.items():\\n            if len(value) > 1:\\n                tmp = value[-1] - value[0] - 1\\n                result = max(tmp, result)\\n        return result\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 915445,
                "title": "java-o-n-time-and-o-1-space",
                "content": "**Approach** - \\n\\n1. Store the first occurrence of each character\\n2. On every next occurrence of the character, compute the length of the substring and update the max.\\n\\n**Space** - O(1)\\n\\n**Time** - O(n)\\n\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] first = new int[26];\\n        Arrays.fill(first, -1);\\n        int max = -1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (first[ch - \\'a\\'] != -1)\\n                max = Math.max(i - first[ch - \\'a\\'] - 1, max);\\n            else\\n                first[ch - \\'a\\'] = i;\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] first = new int[26];\\n        Arrays.fill(first, -1);\\n        int max = -1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (first[ch - \\'a\\'] != -1)\\n                max = Math.max(i - first[ch - \\'a\\'] - 1, max);\\n            else\\n                first[ch - \\'a\\'] = i;\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911933,
                "title": "python-three-liner-solution-beats-98-in-time-using-dictionary",
                "content": "![image](https://assets.leetcode.com/users/images/6bfa6ff4-f4c7-47e5-9895-78a5aa19729c_1603773123.650697.png)\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        letter,res  = defaultdict(list),[]\\n        for i in range(len(s)):letter[s[i]].append(i)\\n        for j in letter.values():res.append(j[-1]-j[0]-1)\\n        return max(res)\\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        letter,res  = defaultdict(list),[]\\n        for i in range(len(s)):letter[s[i]].append(i)\\n        for j in letter.values():res.append(j[-1]-j[0]-1)\\n        return max(res)\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 903369,
                "title": "c-faster-than-100-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<int> mp(26,0);\\n        int maxi=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(mp[s[i]-\\'a\\']) \\n\\t\\t\\t     maxi=max(maxi,(i-mp[s[i]-\\'a\\']));\\n            else \\n\\t\\t\\t     mp[s[i]-\\'a\\']=i+1; \\n        }\\n        return maxi;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<int> mp(26,0);\\n        int maxi=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(mp[s[i]-\\'a\\']) \\n\\t\\t\\t     maxi=max(maxi,(i-mp[s[i]-\\'a\\']));\\n            else \\n\\t\\t\\t     mp[s[i]-\\'a\\']=i+1; \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900399,
                "title": "go-one-pass-map-0ms-2mb",
                "content": "```\\nfunc maxLengthBetweenEqualCharacters(s string) int {\\n    seen := make(map[rune]int)\\n    maxlen := -1\\n    \\n    for i,r := range s {\\n        if j,ok := seen[r]; ok {\\n            d := i - j - 1\\n            if d > maxlen {\\n                maxlen = d\\n            }\\n        } else {\\n            seen[r] = i\\n        }\\n    }\\n    return maxlen    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxLengthBetweenEqualCharacters(s string) int {\\n    seen := make(map[rune]int)\\n    maxlen := -1\\n    \\n    for i,r := range s {\\n        if j,ok := seen[r]; ok {\\n            d := i - j - 1\\n            if d > maxlen {\\n                maxlen = d\\n            }\\n        } else {\\n            seen[r] = i\\n        }\\n    }\\n    return maxlen    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 900287,
                "title": "kt-js-py3-cpp-map-concise-verbose-solutions",
                "content": "**Synopsis:**\\n\\nUse a `\\uD83D\\uDDFA` map `m` to store the index `i` of each character `c` in the input string `s`.\\n\\nAn astute observer will notice the concise solutions use the map `m` to track the right-most index `i` of each character `c` in `s` while the verbose solutions use the map `m` to track the left-most index `i` of each character `c` in `s`.\\n\\n**`\\uD83D\\uDCDD` Notes:**\\n* The solutions below are in reverse chronological order, ie. I dervied the concise solutions from the verbose solutions.\\n* The \"concise\" C++ solution showcases how C++ poorly expresses \"concise\" functional programming syntax via mutable lambdas\\n\\n---\\n\\n**`\\u2B50\\uFE0F` Concise Solutions:** (multi-pass)\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxLengthBetweenEqualCharacters(s: String): Int {\\n        var m = mutableMapOf<Char, Int>()\\n        s.forEachIndexed { i, c -> m[c] = i }\\n        return s.mapIndexed{ i, c -> m[c]!! - i - 1 }.max()!!  // -1 for (i..j) non-inclusive\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxLengthBetweenEqualCharacters = (s, m = new Map()) => {\\n    s.split(\\'\\').forEach((c, i) => m.set(c, i));\\n    return Math.max(...s.split(\\'\\').map((c, i) => m.get(c) - i - 1));  // -1 for (i..j) non-inclusive\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str, best = -1) -> int:\\n        m = {c: i for i, c in enumerate(s)}\\n        return max([m[c] - i - 1 for i, c in enumerate(s)])  # -1 for (i..j) non-inclusive\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<char, int>;\\n    int maxLengthBetweenEqualCharacters(string s, Map m = {}, VI cand = {}) {\\n        for_each(s.begin(), s.end(), [i = -1, &m](auto c) mutable { m[c] = ++i; });\\n        transform(s.begin(), s.end(), back_inserter(cand), [i = -1, &m](auto c) mutable { return m[c] - ++i - 1; });  // -1 for (i..j) non-inclusive\\n        return *max_element(cand.begin(), cand.end());\\n    }\\n};\\n```\\n\\n\\n---\\n\\n**`\\u2B50\\uFE0F` Verbose Solutions:** (single-pass)\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxLengthBetweenEqualCharacters(s: String): Int {\\n        var best = -1\\n        var m = mutableMapOf<Char, Int>()\\n        s.forEachIndexed { i, c ->\\n            if (m.contains(c))\\n                best = maxOf(best, i - m[c]!! - 1)  // -1 for (i..j) non-inclusive\\n            else\\n                m[c] = i\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxLengthBetweenEqualCharacters = (s, m = new Map(), best = -1) => {\\n    s.split(\\'\\').forEach((c, i) => {\\n        if (m.has(c))\\n            best = Math.max(best, i - m.get(c) - 1);  // -1 for (i..j) non-inclusive\\n        else\\n            m.set(c, i);\\n    });\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str, best = -1) -> int:\\n        m = {}\\n        for i, c in enumerate(s):\\n            if c in m:\\n                best = max(best, i - m[c] - 1)  # -1 for (i..j) non-inclusive\\n            else:\\n                m[c] = i\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int maxLengthBetweenEqualCharacters(string s, Map m = {}, int best = -1) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (m.find(s[i]) != m.end())\\n                best = max(best, i - m[s[i]] - 1);  // -1 for (i..j) non-inclusive\\n            else\\n                m[s[i]] = i;\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxLengthBetweenEqualCharacters(s: String): Int {\\n        var m = mutableMapOf<Char, Int>()\\n        s.forEachIndexed { i, c -> m[c] = i }\\n        return s.mapIndexed{ i, c -> m[c]!! - i - 1 }.max()!!  // -1 for (i..j) non-inclusive\\n    }\\n}\\n```\n```\\nlet maxLengthBetweenEqualCharacters = (s, m = new Map()) => {\\n    s.split(\\'\\').forEach((c, i) => m.set(c, i));\\n    return Math.max(...s.split(\\'\\').map((c, i) => m.get(c) - i - 1));  // -1 for (i..j) non-inclusive\\n};\\n```\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str, best = -1) -> int:\\n        m = {c: i for i, c in enumerate(s)}\\n        return max([m[c] - i - 1 for i, c in enumerate(s)])  # -1 for (i..j) non-inclusive\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<char, int>;\\n    int maxLengthBetweenEqualCharacters(string s, Map m = {}, VI cand = {}) {\\n        for_each(s.begin(), s.end(), [i = -1, &m](auto c) mutable { m[c] = ++i; });\\n        transform(s.begin(), s.end(), back_inserter(cand), [i = -1, &m](auto c) mutable { return m[c] - ++i - 1; });  // -1 for (i..j) non-inclusive\\n        return *max_element(cand.begin(), cand.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun maxLengthBetweenEqualCharacters(s: String): Int {\\n        var best = -1\\n        var m = mutableMapOf<Char, Int>()\\n        s.forEachIndexed { i, c ->\\n            if (m.contains(c))\\n                best = maxOf(best, i - m[c]!! - 1)  // -1 for (i..j) non-inclusive\\n            else\\n                m[c] = i\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet maxLengthBetweenEqualCharacters = (s, m = new Map(), best = -1) => {\\n    s.split(\\'\\').forEach((c, i) => {\\n        if (m.has(c))\\n            best = Math.max(best, i - m.get(c) - 1);  // -1 for (i..j) non-inclusive\\n        else\\n            m.set(c, i);\\n    });\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str, best = -1) -> int:\\n        m = {}\\n        for i, c in enumerate(s):\\n            if c in m:\\n                best = max(best, i - m[c] - 1)  # -1 for (i..j) non-inclusive\\n            else:\\n                m[c] = i\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int maxLengthBetweenEqualCharacters(string s, Map m = {}, int best = -1) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (m.find(s[i]) != m.end())\\n                best = max(best, i - m[s[i]] - 1);  // -1 for (i..j) non-inclusive\\n            else\\n                m[s[i]] = i;\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899474,
                "title": "basic-traversal-of-the-string",
                "content": "Strore the largest result in the answer after every iteration.\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int size = s.length(),ans=-1,diff=-1;\\n        for(int i=0;i<size-1;i++){\\n            for(int j=size-1;j>i;j--){\\n                if(s[i]==s[j]){\\n                    diff = j-i-1;  \\n                    ans = max(diff,ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int size = s.length(),ans=-1,diff=-1;\\n        for(int i=0;i<size-1;i++){\\n            for(int j=size-1;j>i;j--){\\n                if(s[i]==s[j]){\\n                    diff = j-i-1;  \\n                    ans = max(diff,ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996295,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        a=[]\\n        for i in range(0,len(s)-1) :\\n            b=0\\n            for j in range(i+1,len(s)) :\\n                if s[j]==s[i] :\\n                    b=j-i-1\\n                    a.append(b)\\n        return max(a) if len(a)>0 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        a=[]\\n        for i in range(0,len(s)-1) :\\n            b=0\\n            for j in range(i+1,len(s)) :\\n                if s[j]==s[i] :\\n                    b=j-i-1\\n                    a.append(b)\\n        return max(a) if len(a)>0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381775,
                "title": "java-fastest-solution-with-hash-table-implementation",
                "content": "# Complexity\\n- Time complexity:O(n) -> n is length of input string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[][] table = new int[26][2];\\n        int max = 0;\\n\\n        for(int i = 0; i < s.length(); i++){\\n            int ind = i+1;\\n            int c = s.charAt(i)-\\'a\\';\\n\\n            if(table[c][0] == 0) table[c][0] = ind;\\n            else table[c][1] = ind;\\n        }\\n\\n        for(int i = 0; i < 26; i++)\\n            if(table[i][0] * table[i][1] != 0)\\n              max = Math.max(max, table[i][1] - table[i][0]);\\n        \\n        return max-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[][] table = new int[26][2];\\n        int max = 0;\\n\\n        for(int i = 0; i < s.length(); i++){\\n            int ind = i+1;\\n            int c = s.charAt(i)-\\'a\\';\\n\\n            if(table[c][0] == 0) table[c][0] = ind;\\n            else table[c][1] = ind;\\n        }\\n\\n        for(int i = 0; i < 26; i++)\\n            if(table[i][0] * table[i][1] != 0)\\n              max = Math.max(max, table[i][1] - table[i][0]);\\n        \\n        return max-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376010,
                "title": "python-solution-with-explanation-beats-94-49",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        # setup to keep necessary vars in memory\\n        set_s, len_s = set(s), len(s)\\n\\n        # checking if there is no such substring\\n        if len(set_s) == len_s:\\n            return -1\\n\\n        # final check for largest substing between two equal characters\\n        le = 0\\n        for i in set_s:\\n            if s.count(i) > 1:\\n\\n                # checking a lenght of a substring\\n                cou = len_s - s[::-1].index(i) - s.index(i) - 2\\n                if cou > le:\\n                    le = cou\\n                    \\n        # yay we made it\\n        return le\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        # setup to keep necessary vars in memory\\n        set_s, len_s = set(s), len(s)\\n\\n        # checking if there is no such substring\\n        if len(set_s) == len_s:\\n            return -1\\n\\n        # final check for largest substing between two equal characters\\n        le = 0\\n        for i in set_s:\\n            if s.count(i) > 1:\\n\\n                # checking a lenght of a substring\\n                cou = len_s - s[::-1].index(i) - s.index(i) - 2\\n                if cou > le:\\n                    le = cou\\n                    \\n        # yay we made it\\n        return le\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339646,
                "title": "basic-and-easy-java-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max=-1;\\n      for(int i=0;i<s.length();i++){\\n          for(int j=s.length()-1;j>i;j--){\\n              if(s.charAt(i)==s.charAt(j)){\\n              max=Math.max(max,((j-i)-1));\\n              }\\n          }\\n      }\\n       return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max=-1;\\n      for(int i=0;i<s.length();i++){\\n          for(int j=s.length()-1;j>i;j--){\\n              if(s.charAt(i)==s.charAt(j)){\\n              max=Math.max(max,((j-i)-1));\\n              }\\n          }\\n      }\\n       return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095011,
                "title": "python-c-simple-solution-o-n-both-beats-90",
                "content": "# C# Code\\n```\\npublic class Solution {\\n    public int MaxLengthBetweenEqualCharacters(string s) {\\n        Dictionary<char, int> Map = new Dictionary<char, int>();\\n        int res = -1;\\n        for(int i= 0;i<s.Length;i++)\\n        {\\n            if(Map.ContainsKey(s[i]))\\n            {\\n                if (i - Map[s[i]] > res)\\n                {\\n                    res = i - Map[s[i]];\\n                }\\n            }\\n            else\\n            {\\n                Map.Add(s[i], i+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n\\n# Python Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        Map = {}\\n        res = -1\\n        for i in range(len(s)):\\n            if s[i] in Map:\\n                res = max(i - Map[s[i]],res)\\n            else:\\n                Map[s[i]] = i + 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxLengthBetweenEqualCharacters(string s) {\\n        Dictionary<char, int> Map = new Dictionary<char, int>();\\n        int res = -1;\\n        for(int i= 0;i<s.Length;i++)\\n        {\\n            if(Map.ContainsKey(s[i]))\\n            {\\n                if (i - Map[s[i]] > res)\\n                {\\n                    res = i - Map[s[i]];\\n                }\\n            }\\n            else\\n            {\\n                Map.Add(s[i], i+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        Map = {}\\n        res = -1\\n        for i in range(len(s)):\\n            if s[i] in Map:\\n                res = max(i - Map[s[i]],res)\\n            else:\\n                Map[s[i]] = i + 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070816,
                "title": "java-onepass-hashmap-solution-easy-to-understand",
                "content": "# HashTable\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res=-1;\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(map.containsKey(c)){\\n                res=Math.max(res,i-map.get(c)-1);\\n            }\\n            else{\\n                map.put(c,i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n# Slightly Improve Running Time (Beats 100%)\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res=-1;\\n        int[] map=new int[26];\\n        Arrays.fill(map,-1);\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(map[c-\\'a\\']==-1){\\n                map[c-\\'a\\']=i;\\n            }\\n            else{\\n                res=Math.max(res,i-map[c-\\'a\\']-1);\\n            }\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res=-1;\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(map.containsKey(c)){\\n                res=Math.max(res,i-map.get(c)-1);\\n            }\\n            else{\\n                map.put(c,i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res=-1;\\n        int[] map=new int[26];\\n        Arrays.fill(map,-1);\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(map[c-\\'a\\']==-1){\\n                map[c-\\'a\\']=i;\\n            }\\n            else{\\n                res=Math.max(res,i-map[c-\\'a\\']-1);\\n            }\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033199,
                "title": "hashing-solution-c",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751968,
                "title": "c-very-easy-0-ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int n=s.length();\\n        int len=0;\\n        unordered_map<char,int>mp;\\n        int maxlen=-1;\\n        for(int i=0;i<n;i++)\\n            mp[s[i]]++;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(mp[s[i]]!=1)\\n            {\\n                for(int j=n-1;j>i;j--)\\n                {\\n                    if(s[j]==s[i])\\n                    {\\n                        maxlen=max(maxlen,j-i-1);\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int n=s.length();\\n        int len=0;\\n        unordered_map<char,int>mp;\\n        int maxlen=-1;\\n        for(int i=0;i<n;i++)\\n            mp[s[i]]++;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(mp[s[i]]!=1)\\n            {\\n                for(int j=n-1;j>i;j--)\\n                {\\n                    if(s[j]==s[i])\\n                    {\\n                        maxlen=max(maxlen,j-i-1);\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728479,
                "title": "solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int a[26] = {0}, b[26] = {0}, ans = -1;\\n        for(int i = 0; i < 26; i++) {\\n            a[i] = 1000;\\n            b[i] = -1;\\n        }\\n        for(int i = 0; i < s.size(); i++) {\\n            a[s[i] - \\'a\\'] = min(a[s[i] - \\'a\\'], i);\\n            b[s[i] - \\'a\\'] = max(b[s[i] - \\'a\\'], i);\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            ans = max(ans, b[i] - a[i] - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int a[26] = {0}, b[26] = {0}, ans = -1;\\n        for(int i = 0; i < 26; i++) {\\n            a[i] = 1000;\\n            b[i] = -1;\\n        }\\n        for(int i = 0; i < s.size(); i++) {\\n            a[s[i] - \\'a\\'] = min(a[s[i] - \\'a\\'], i);\\n            b[s[i] - \\'a\\'] = max(b[s[i] - \\'a\\'], i);\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            ans = max(ans, b[i] - a[i] - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705307,
                "title": "simple-approach-using-hashing-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) \\n    {\\n       unordered_map<char,int>mp;\\n       int ans=-1;\\n       for(int i=0;i<s.length();i++)\\n       {\\n          char ch = s[i];\\n          if(mp.find(ch)!=mp.end())    //also found previously\\n          {\\n             ans=max(ans,i-mp[ch]-1);\\n          }\\n          else\\n          {\\n             mp[ch]=i;\\t\\n          }\\t\\n       }         \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) \\n    {\\n       unordered_map<char,int>mp;\\n       int ans=-1;\\n       for(int i=0;i<s.length();i++)\\n       {\\n          char ch = s[i];\\n          if(mp.find(ch)!=mp.end())    //also found previously\\n          {\\n             ans=max(ans,i-mp[ch]-1);\\n          }\\n          else\\n          {\\n             mp[ch]=i;\\t\\n          }\\t\\n       }         \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698026,
                "title": "c-easy-understanding-o-n-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        map<char , vector<int>>g;\\n        for(int i = 0 ; i  <s.size() ; i ++){\\n             g[s[i]].push_back(i);\\n        }\\n        int d =-1;\\n        for(auto i  :g){\\n            vector<int>v = i.second;\\n           int n = v.size();\\n            \\n            if(n > 1){\\n                d = max(d , v[n-1]-v[0] - 1);\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        map<char , vector<int>>g;\\n        for(int i = 0 ; i  <s.size() ; i ++){\\n             g[s[i]].push_back(i);\\n        }\\n        int d =-1;\\n        for(auto i  :g){\\n            vector<int>v = i.second;\\n           int n = v.size();\\n            \\n            if(n > 1){\\n                d = max(d , v[n-1]-v[0] - 1);\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675565,
                "title": "simple-approach-using-hashing-o-n-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<vector<int>>v(26,vector<int>(2,-1));\\n        for(int i=0;i<s.length();i++){\\n            if(v[s[i]-97][0]==-1){\\n                v[s[i]-97][0]=i;\\n            }else{\\n                v[s[i]-97][1]=i;\\n            }\\n        }\\n        int res=INT_MIN;\\n        for(int i=0;i<26;i++){\\n            int curr=(v[i][1]-v[i][0]+1)-2;\\n            res=max(res,curr);\\n\\n        }\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<vector<int>>v(26,vector<int>(2,-1));\\n        for(int i=0;i<s.length();i++){\\n            if(v[s[i]-97][0]==-1){\\n                v[s[i]-97][0]=i;\\n            }else{\\n                v[s[i]-97][1]=i;\\n            }\\n        }\\n        int res=INT_MIN;\\n        for(int i=0;i<26;i++){\\n            int curr=(v[i][1]-v[i][0]+1)-2;\\n            res=max(res,curr);\\n\\n        }\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618472,
                "title": "0-ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int sz=-1;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch=s[i];int j=i+1;\\n            for( j=i+1;j<s.length();j++){\\n                if(s[j]==ch){\\n                   sz=max(sz,(j-i-1));\\n                }\\n            }\\n                \\n        }\\n        \\n        return sz;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int sz=-1;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch=s[i];int j=i+1;\\n            for( j=i+1;j<s.length();j++){\\n                if(s[j]==ch){\\n                   sz=max(sz,(j-i-1));\\n                }\\n            }\\n                \\n        }\\n        \\n        return sz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269658,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        int res=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(hmap.containsKey(ch))\\n                res=Math.max(res,i-1-hmap.get(ch));\\n            else\\n                hmap.put(ch,i);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        int res=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(hmap.containsKey(ch))\\n                res=Math.max(res,i-1-hmap.get(ch));\\n            else\\n                hmap.put(ch,i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2218649,
                "title": "js-solution-with-set",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {    \\n    let set = new Set();\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let letter = s[i];\\n        for(let j = i+1; j < s.length; j++) {\\n            if( s[j] == s[i] ) {\\n                set.add(((j-1) - (i+1)) + 1); //calculate the length and add to our set\\n            }\\n        }\\n    }\\n    \\n    if( set.size > 0 ) {\\n        return Math.max(...set);\\n    }\\n    \\n    return -1;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {    \\n    let set = new Set();\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let letter = s[i];\\n        for(let j = i+1; j < s.length; j++) {\\n            if( s[j] == s[i] ) {\\n                set.add(((j-1) - (i+1)) + 1); //calculate the length and add to our set\\n            }\\n        }\\n    }\\n    \\n    if( set.size > 0 ) {\\n        return Math.max(...set);\\n    }\\n    \\n    return -1;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2210080,
                "title": "very-intuitive-simplest-logic",
                "content": "**The logic is simple, whenever you encounter a character first time, store the character and its index in hashMap. When you encounter it second time, obviously its an answer. So just update the answer values. \\nUltimately if all the characters have just one occurence, it means map size equates the string size, so return -1 else return answer\\n\\n**Now you don\\'t need to store index of second or any further occurence, because you need largest substring, and largest can be obtained just by first occurence . **\\n**\\n\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        \\n        int ans = 0;\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(hm.containsKey(s.charAt(i)))\\n             ans = Math.max(ans, i-(int)hm.get(s.charAt(i))-1);\\n            else \\n             hm.put(s.charAt(i),i);\\n        }\\n        if(hm.size()==s.length())\\n            return -1;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        \\n        int ans = 0;\\n        HashMap<Character,Integer> hm = new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(hm.containsKey(s.charAt(i)))\\n             ans = Math.max(ans, i-(int)hm.get(s.charAt(i))-1);\\n            else \\n             hm.put(s.charAt(i),i);\\n        }\\n        if(hm.size()==s.length())\\n            return -1;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064085,
                "title": "java-easy-solution-count-first-character-and-compare",
                "content": "```java\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] freq = new int[26];\\n        Arrays.fill(freq,-1);\\n        int maxLength = -1;\\n        for(int i = 0; i < s.length(); i++){\\n            if(freq[s.charAt(i) - \\'a\\']  == -1){\\n                freq[s.charAt(i) - \\'a\\'] = i;\\n            }else{\\n                int val = i - freq[s.charAt(i) - \\'a\\'] -1;\\n                maxLength = Math.max(maxLength,val);\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] freq = new int[26];\\n        Arrays.fill(freq,-1);\\n        int maxLength = -1;\\n        for(int i = 0; i < s.length(); i++){\\n            if(freq[s.charAt(i) - \\'a\\']  == -1){\\n                freq[s.charAt(i) - \\'a\\'] = i;\\n            }else{\\n                int val = i - freq[s.charAt(i) - \\'a\\'] -1;\\n                maxLength = Math.max(maxLength,val);\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728347,
                "title": "simple-solution-with-map-60-ms-faster-than-100-00-of-javascript-online-submissions",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let result = -1;\\n    const map = new Map();\\n    for (let i = 0; i < s.length; i++) {\\n        if (map.has(s.charAt(i))) {\\n            result = Math.max(result, i - map.get(s.charAt(i)))\\n        } else {\\n            map.set(s.charAt(i), i + 1);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let result = -1;\\n    const map = new Map();\\n    for (let i = 0; i < s.length; i++) {\\n        if (map.has(s.charAt(i))) {\\n            result = Math.max(result, i - map.get(s.charAt(i)))\\n        } else {\\n            map.set(s.charAt(i), i + 1);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1695948,
                "title": "3-lines-simple-c-solution-with-o-1-space-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        if(s.size()==0)return -1;\\n        int ans = -1;\\n        for(int i = 0;i<s.size();i++) {\\n            char ch = s[i];\\n            int pos = s.find_last_of(ch,s.size());  //This function is used to find the last position of the char in the string\\n            if(pos != string::npos){\\n                int diff = pos-i-1;\\n                ans = max(ans,diff);\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        if(s.size()==0)return -1;\\n        int ans = -1;\\n        for(int i = 0;i<s.size();i++) {\\n            char ch = s[i];\\n            int pos = s.find_last_of(ch,s.size());  //This function is used to find the last position of the char in the string\\n            if(pos != string::npos){\\n                int diff = pos-i-1;\\n                ans = max(ans,diff);\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689384,
                "title": "java-1ms-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Parse s and for each character, store its first appearance index in an array[] firstPositions \\n        2. If firstPos[char - \\'a\\'] of current char already exists, determine the length i - firstPos, matching it against the maxLength known so far.\\n        3. Return maxLength -1, to compensate for the length deduction of the 2 characters\\n    */\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] firstPositions = new int[26];\\n        int maxLength = 0;\\n        // fill the array with -1 to flag that the first position has not been filled yet\\n        Arrays.fill(firstPositions, -1);\\n        int codePoint;\\n        for (int i = 0; i < s.length(); i++) {\\n            codePoint = s.charAt(i) - \\'a\\';\\n            // if first position has not been filled, fill it\\n            if (firstPositions[codePoint] < 0) {\\n                firstPositions[codePoint] = i;\\n            } else { // else, if firstPos already exists, determine the langth and compare with maxLength\\n                maxLength = Math.max(maxLength, i - firstPositions[codePoint]);\\n            }\\n        }\\n        return maxLength - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Parse s and for each character, store its first appearance index in an array[] firstPositions \\n        2. If firstPos[char - \\'a\\'] of current char already exists, determine the length i - firstPos, matching it against the maxLength known so far.\\n        3. Return maxLength -1, to compensate for the length deduction of the 2 characters\\n    */\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] firstPositions = new int[26];\\n        int maxLength = 0;\\n        // fill the array with -1 to flag that the first position has not been filled yet\\n        Arrays.fill(firstPositions, -1);\\n        int codePoint;\\n        for (int i = 0; i < s.length(); i++) {\\n            codePoint = s.charAt(i) - \\'a\\';\\n            // if first position has not been filled, fill it\\n            if (firstPositions[codePoint] < 0) {\\n                firstPositions[codePoint] = i;\\n            } else { // else, if firstPos already exists, determine the langth and compare with maxLength\\n                maxLength = Math.max(maxLength, i - firstPositions[codePoint]);\\n            }\\n        }\\n        return maxLength - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685287,
                "title": "c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        \\n        int max_len = -1 , current_len = -1  ;\\n       \\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            for(int j=0 ; j<s.length() ; j++ )\\n            {\\n                if(s[i]==s[j])\\n                {\\n                    current_len = i-j-1 ;    \\n                    max_len = max(current_len , max_len); \\n                }\\n            }\\n        }\\n        return max_len ;  \\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        \\n        int max_len = -1 , current_len = -1  ;\\n       \\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            for(int j=0 ; j<s.length() ; j++ )\\n            {\\n                if(s[i]==s[j])\\n                {\\n                    current_len = i-j-1 ;    \\n                    max_len = max(current_len , max_len); \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1685069,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n       int arr[26]={0},m=-1;\\n        for(int i=0;i<s.size();i++){\\n         if(arr[s[i]-\\'a\\']==0)\\n           arr[s[i]-\\'a\\']=i+1;\\n        else  m= max(m,i-arr[s[i]-\\'a\\']);}\\n        return m;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n       int arr[26]={0},m=-1;\\n        for(int i=0;i<s.size();i++){\\n         if(arr[s[i]-\\'a\\']==0)\\n           arr[s[i]-\\'a\\']=i+1;\\n        else  m= max(m,i-arr[s[i]-\\'a\\']);}\\n        return m;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1600735,
                "title": "easy-c-map-hashmap-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        map<char, vector<int>> god;\\n        int pos = 0;\\n        for(auto it: s) {\\n            god[it].push_back(pos++);\\n        }\\n        \\n        int ans = -1;\\n        for (auto it: god) {\\n            auto vec = it.second;\\n            if (vec.size() > 1) {\\n                ans = max(ans, vec[vec.size()-1] - vec[0] - 1); \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        map<char, vector<int>> god;\\n        int pos = 0;\\n        for(auto it: s) {\\n            god[it].push_back(pos++);\\n        }\\n        \\n        int ans = -1;\\n        for (auto it: god) {\\n            auto vec = it.second;\\n            if (vec.size() > 1) {\\n                ans = max(ans, vec[vec.size()-1] - vec[0] - 1); \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413886,
                "title": "c-solution-i-taught-myself-how-to-do-the-sliding-window-thing-d",
                "content": "I legit have no idea how to make one optimally, I just went with whatever made the most sense to me after trying out a couple of things on notepad. My notes:\\n\\n```\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n^                           ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n^                          ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n ^                          ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n ^                         ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n^                         ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n  ^                         ^ ANSWER=25\\n```\\n\\nAs it turns out, it was much more efficient than I thought it would be!\\n\\nRuntime: 0ms (100% faster)\\nMemory: 6.2 MB (98.86% smaller)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string inputString) {\\n        size_t left(0), right(inputString.length() - 1), mode(0), distance(0), journey(0);\\n\\n        while (left != right) {\\n            if (inputString[left] == inputString[right]) {\\n                return (right - 1) - left;\\n            }\\n\\n            switch (mode) {\\n                case 0: // Shrink window\\n                    right--;\\n                    distance++;\\n\\n                    mode++;\\n                    break;\\n                case 1: // Shift window right\\n                    if (journey == distance) {\\n                        journey = 0;\\n\\n                        mode++;\\n                    } else {\\n                        right++;\\n                        left++;\\n\\n                        journey++;\\n                    }\\n                    break;\\n                case 2: // Shift window left\\n                    if (journey == distance) {\\n                        journey = 0;\\n\\n                        mode = 0;\\n                    } else {\\n                        right--;\\n                        left--;\\n\\n                        journey++;\\n                    }\\n                    break;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n^                           ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n^                          ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n ^                          ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n ^                         ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n^                         ^\\n\\nakjshdkjhfkjhsdkjhsdkjfhlkjhj\\n  ^                         ^ ANSWER=25\\n```\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string inputString) {\\n        size_t left(0), right(inputString.length() - 1), mode(0), distance(0), journey(0);\\n\\n        while (left != right) {\\n            if (inputString[left] == inputString[right]) {\\n                return (right - 1) - left;\\n            }\\n\\n            switch (mode) {\\n                case 0: // Shrink window\\n                    right--;\\n                    distance++;\\n\\n                    mode++;\\n                    break;\\n                case 1: // Shift window right\\n                    if (journey == distance) {\\n                        journey = 0;\\n\\n                        mode++;\\n                    } else {\\n                        right++;\\n                        left++;\\n\\n                        journey++;\\n                    }\\n                    break;\\n                case 2: // Shift window left\\n                    if (journey == distance) {\\n                        journey = 0;\\n\\n                        mode = 0;\\n                    } else {\\n                        right--;\\n                        left--;\\n\\n                        journey++;\\n                    }\\n                    break;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412608,
                "title": "java-solution-with-logic",
                "content": "```\\n/* \\nTo get the maximum length we need to store the first occurance of the character in the array initial position with 0.\\nFor the first character of s, the position becomes 0,  So we need to represent differntly. Thus i used i + 1.\\n*/\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max = -1;\\n        int[] pos = new int[26]; //Stores the first occurance of the character.\\n        int index;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            index = s.charAt(i) - \\'a\\';\\n            if (pos[index] > 0)\\n            {\\n                max = Math.max(max, i - pos[index]);\\n            } \\n            else \\n            {\\n                pos[index] = i + 1;\\n            }\\n            \\n        }\\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max = -1;\\n        int[] pos = new int[26]; //Stores the first occurance of the character.\\n        int index;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            index = s.charAt(i) - \\'a\\';\\n            if (pos[index] > 0)\\n            {\\n                max = Math.max(max, i - pos[index]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1355311,
                "title": "python-reverse-string",
                "content": "```python\\ndef maxLengthBetweenEqualCharacters(self, s):\\n\\n\\t# Edge case - All characters are unique\\n\\tif len(s) == len(set(s)): return -1\\n\\n\\tcounts, s_prime, result = collections.Counter(s), s[::-1], 0\\n\\n\\tfor k, v in [i for i in counts.items() if i[1] >= 2]:\\n\\t\\ti, j = s.index(k), len(s) - s_prime.index(k) - 1\\n\\t\\tresult = max(result, j-i-1)\\n\\n\\treturn result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```python\\ndef maxLengthBetweenEqualCharacters(self, s):\\n\\n\\t# Edge case - All characters are unique\\n\\tif len(s) == len(set(s)): return -1\\n\\n\\tcounts, s_prime, result = collections.Counter(s), s[::-1], 0\\n\\n\\tfor k, v in [i for i in counts.items() if i[1] >= 2]:\\n\\t\\ti, j = s.index(k), len(s) - s_prime.index(k) - 1\\n\\t\\tresult = max(result, j-i-1)\\n\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1236005,
                "title": "simple-java-solution-o-n-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n     if(s.length()==1)\\n       return -1;\\n     if(s.length()==2 && s.charAt(0)==s.charAt(1))\\n       return 0;\\n      int max=-1;\\n      for(int i=0;i<s.length();i++)\\n      {\\n        int last=s.lastIndexOf(s.charAt(i));\\n        if(i!=last)\\n          max=Math.max((last-i-1),max);\\n      }\\n      return max;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n     if(s.length()==1)\\n       return -1;\\n     if(s.length()==2 && s.charAt(0)==s.charAt(1))\\n       return 0;\\n      int max=-1;\\n      for(int i=0;i<s.length();i++)\\n      {\\n        int last=s.lastIndexOf(s.charAt(i));\\n        if(i!=last)\\n          max=Math.max((last-i-1),max);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1220886,
                "title": "100-pass-results-and-very-easy",
                "content": "class Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n       int mx=-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=s.size()-1;j>=0;j--)\\n            {\\n               if(s[i]==s[j])\\n               {\\n                    mx=max(mx,j-i-1);\\n                   break;\\n               }\\n            }\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n       int mx=-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=s.size()-1;j>=0;j--)\\n            {\\n               if(s[i]==s[j])\\n               {\\n                    mx=max(mx,j-i-1);\\n                   break;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1220092,
                "title": "simple-c-sol-0ms-and-100-faster-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<vector<int>> v(26,vector<int>(2,-1));\\n        //v[i][0] stores the first occurance of a letter\\n        //v[i][1] stores the second occurance of a letter\\n        int res=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(v[s[i]-\\'a\\'][0]==-1)\\n            {\\n                //first occurance\\n                v[s[i]-\\'a\\'][0]=i;\\n            }\\n            else{\\n                //second occurance\\n                v[s[i]-\\'a\\'][1]=i;\\n                res=max(v[s[i]-\\'a\\'][1]-v[s[i]-\\'a\\'][0]-1,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<vector<int>> v(26,vector<int>(2,-1));\\n        //v[i][0] stores the first occurance of a letter\\n        //v[i][1] stores the second occurance of a letter\\n        int res=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(v[s[i]-\\'a\\'][0]==-1)\\n            {\\n                //first occurance\\n                v[s[i]-\\'a\\'][0]=i;\\n            }\\n            else{\\n                //second occurance\\n                v[s[i]-\\'a\\'][1]=i;\\n                res=max(v[s[i]-\\'a\\'][1]-v[s[i]-\\'a\\'][0]-1,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211682,
                "title": "simple-c-solution-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s)\\n    {\\n        int maxi=-1;\\n        vector<int>vec(26,-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(vec[s[i]-\\'a\\']!=-1)\\n            {\\n              maxi=max(maxi,i-vec[s[i]-\\'a\\']-1);  \\n            }\\n            else\\n            {\\n               vec[s[i]-\\'a\\']=i;   \\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s)\\n    {\\n        int maxi=-1;\\n        vector<int>vec(26,-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(vec[s[i]-\\'a\\']!=-1)\\n            {\\n              maxi=max(maxi,i-vec[s[i]-\\'a\\']-1);  \\n            }\\n            else\\n            {\\n               vec[s[i]-\\'a\\']=i;   \\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206755,
                "title": "javascript-simple-solution",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    \\n     // 2. brute force\\n    // get the difference between the starting index stored in map\\n    // Time complexity O(N)\\n    // Space complexity O(N) - We can have space complexity O(1) , if we use the fixed Array of size 26\\n\\t// let arr = new Array(26).fill(0) this will be constant time.\\n\\t\\n\\t\\n    let map = new Map();\\n    \\n    let max = -1;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        // check if it exists in the map.\\n        if (map.has(s[i])) {\\n            \\n            // if its present, get the latest index from map value.\\n            // and calculate max\\n            let val = map.get(s[i]);\\n            max = Math.max(max, i - val - 1);\\n            \\n        } else {\\n            // else update the latest index of element.\\n            map.set(s[i], i);\\n        }\\n    }\\n    \\n    return max;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    \\n     // 2. brute force\\n    // get the difference between the starting index stored in map\\n    // Time complexity O(N)\\n    // Space complexity O(N) - We can have space complexity O(1) , if we use the fixed Array of size 26\\n\\t// let arr = new Array(26).fill(0) this will be constant time.\\n\\t\\n\\t\\n    let map = new Map();\\n    \\n    let max = -1;\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        // check if it exists in the map.\\n        if (map.has(s[i])) {\\n            \\n            // if its present, get the latest index from map value.\\n            // and calculate max\\n            let val = map.get(s[i]);\\n            max = Math.max(max, i - val - 1);\\n            \\n        } else {\\n            // else update the latest index of element.\\n            map.set(s[i], i);\\n        }\\n    }\\n    \\n    return max;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196270,
                "title": "solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        //To find the first occurance(index)\\n        int[] index=new int[26];\\n        int res=-1;\\n        \\n        for(int idx=0;idx<s.length();idx++){\\n            //find the diff of first occurance & current occurance\\n            if(index[s.charAt(idx)-\\'a\\']>0)\\n                res=Math.max(res,idx-index[s.charAt(idx)-\\'a\\']);\\n            else\\n                index[s.charAt(idx)-\\'a\\']=idx+1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        //To find the first occurance(index)\\n        int[] index=new int[26];\\n        int res=-1;\\n        \\n        for(int idx=0;idx<s.length();idx++){\\n            //find the diff of first occurance & current occurance\\n            if(index[s.charAt(idx)-\\'a\\']>0)\\n                res=Math.max(res,idx-index[s.charAt(idx)-\\'a\\']);\\n            else\\n                index[s.charAt(idx)-\\'a\\']=idx+1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171574,
                "title": "c-o-n-time-complexity-o-26-space-complexity-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {     \\n        vector<int> v(26,-1);\\n        int max = -1;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            int val = s[i] -\\'a\\';\\n            if(v[val] != -1)\\n            {\\n                if(i - v[val] - 1 > max)\\n                    max = i - v[val] -1;\\n                \\n            }\\n            else\\n            {\\n                v[val] = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {     \\n        vector<int> v(26,-1);\\n        int max = -1;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            int val = s[i] -\\'a\\';\\n            if(v[val] != -1)\\n            {\\n                if(i - v[val] - 1 > max)\\n                    max = i - v[val] -1;\\n                \\n            }\\n            else\\n            {\\n                v[val] = i;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142168,
                "title": "rust-0ms-o-n-short-hash-map-iterator-solutions",
                "content": "Using a hash map:\\n\\n```\\nimpl Solution {\\n    pub fn max_length_between_equal_characters(s: String) -> i32 {\\n        let mut map = std::collections::HashMap::new();\\n        s.chars().enumerate().for_each(|(i, c)| {\\n            map.entry(c).or_insert((i as i32 + 1, 0)).1 = i as i32 - 1;\\n        });\\n        map.into_iter()\\n            .map(|(_, (i, j))| j - i + 1)\\n            .max()\\n            .unwrap_or(-1)\\n    }\\n}\\n```\\n\\nTime complexity: `O(n)`.\\nExtra-space complexity: `O(26) == O(1)`.\\n\\n---\\n\\nUsing Rust\\'s iterators:\\n\\n```\\nimpl Solution {\\n    pub fn max_length_between_equal_characters(s: String) -> i32 {\\n        let s = s.as_bytes();\\n        (b\\'a\\'..=b\\'z\\')\\n            .map(|c| {\\n                let i = (0..s.len()).find(|&i| s[i] == c).unwrap_or(0) + 1;\\n                let j = (0..s.len()).rev().find(|&i| s[i] == c).unwrap_or(0) - 1;\\n                j as i32 - i as i32 + 1\\n            })\\n            .max()\\n            .unwrap()\\n    }\\n}\\n```\\n\\nTime complexity: `O(26 * 2 * n) == O(n)`.\\nExtra-space complexity: `O(1)`.",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_length_between_equal_characters(s: String) -> i32 {\\n        let mut map = std::collections::HashMap::new();\\n        s.chars().enumerate().for_each(|(i, c)| {\\n            map.entry(c).or_insert((i as i32 + 1, 0)).1 = i as i32 - 1;\\n        });\\n        map.into_iter()\\n            .map(|(_, (i, j))| j - i + 1)\\n            .max()\\n            .unwrap_or(-1)\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn max_length_between_equal_characters(s: String) -> i32 {\\n        let s = s.as_bytes();\\n        (b\\'a\\'..=b\\'z\\')\\n            .map(|c| {\\n                let i = (0..s.len()).find(|&i| s[i] == c).unwrap_or(0) + 1;\\n                let j = (0..s.len()).rev().find(|&i| s[i] == c).unwrap_or(0) - 1;\\n                j as i32 - i as i32 + 1\\n            })\\n            .max()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135535,
                "title": "easily-readable-solution-in-python",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        maxd = -1\\n        for i in s:\\n            maxd = max(maxd,len(s)-s[::-1].index(i)-s.index(i)-2)\\n        return(maxd)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        maxd = -1\\n        for i in s:\\n            maxd = max(maxd,len(s)-s[::-1].index(i)-s.index(i)-2)\\n        return(maxd)",
                "codeTag": "Java"
            },
            {
                "id": 1085268,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] arr = new int[26]; // create an array of 26 length\\n        Arrays.fill(arr, -1); // fill the array with -1;\\n        \\n        int ans = -1;\\n        for(int i=0; i<s.length(); i++){\\n            if(arr[s.charAt(i) - \\'a\\'] == -1){  // if the character comes first time, save first occurance of that character\\n                arr[s.charAt(i) - \\'a\\'] = i;\\n            }else{\\n                int temp = i-arr[s.charAt(i) - \\'a\\']-1; // if it comes again then calculate the length of substring in between\\n                if(temp > ans) ans = temp;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] arr = new int[26]; // create an array of 26 length\\n        Arrays.fill(arr, -1); // fill the array with -1;\\n        \\n        int ans = -1;\\n        for(int i=0; i<s.length(); i++){\\n            if(arr[s.charAt(i) - \\'a\\'] == -1){  // if the character comes first time, save first occurance of that character\\n                arr[s.charAt(i) - \\'a\\'] = i;\\n            }else{\\n                int temp = i-arr[s.charAt(i) - \\'a\\']-1; // if it comes again then calculate the length of substring in between\\n                if(temp > ans) ans = temp;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077914,
                "title": "c-solution-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<int> fre(26);\\n        for(auto ch :s)\\n            fre[ch-\\'a\\']++;\\n        int ans =-1;\\n        for(int i=0;i<26;i++){\\n            if(fre[i]>=2){ // if frequency is greater than or equal to 2 then search the first position from start and end of that char ... that will be substring that starting and ending with same char\\n                int l=0;\\n                int h = s.size()-1;\\n                while(s[l]!= char(i+\\'a\\'))\\n                    l++;\\n                while(s[h]!=char(i+\\'a\\'))\\n                    h--;\\n                // cout<<l<<\" \"<<h<<endl;\\n                ans = max(ans , h-l-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**happy coding**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<int> fre(26);\\n        for(auto ch :s)\\n            fre[ch-\\'a\\']++;\\n        int ans =-1;\\n        for(int i=0;i<26;i++){\\n            if(fre[i]>=2){ // if frequency is greater than or equal to 2 then search the first position from start and end of that char ... that will be substring that starting and ending with same char\\n                int l=0;\\n                int h = s.size()-1;\\n                while(s[l]!= char(i+\\'a\\'))\\n                    l++;\\n                while(s[h]!=char(i+\\'a\\'))\\n                    h--;\\n                // cout<<l<<\" \"<<h<<endl;\\n                ans = max(ans , h-l-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1043598,
                "title": "js-clean-solution-76ms-with-lastindexof",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let max = 0;\\n\\n    for(let i = 0;i < s.length;i++){\\n        let last = s.lastIndexOf(s[i]);\\n\\t\\t\\n        if(i !== last) max = Math.max(max,last - i);\\n    }\\n\\n    return max - 1\\n};\\n```\\n\\nTime: 76ms\\nSpace: 37.8MB\\nPlease let me know if you have any suggestions!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let max = 0;\\n\\n    for(let i = 0;i < s.length;i++){\\n        let last = s.lastIndexOf(s[i]);\\n\\t\\t\\n        if(i !== last) max = Math.max(max,last - i);\\n    }\\n\\n    return max - 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1028984,
                "title": "faster-than-97-09-of-javascript-online-submissions",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n\\tlet diffArr=[]\\n\\ts=s.split(\\'\\')\\n    for(let i=0;i<s.length;i++){\\n\\t\\t\\n\\t\\tlet curpos=s.indexOf(s[i])\\n\\t\\tlet tmp=s[i]\\n\\t\\ts[i]=0\\n\\t\\tif(s.lastIndexOf(tmp)>0 && curpos!=s.lastIndexOf(tmp)) \\n\\t\\t\\tdiffArr.push(s.lastIndexOf(tmp)-curpos-1)\\n\\t\\tconsole.log(s.indexOf(tmp),curpos)\\n\\t}\\n\\tconsole.log(diffArr)\\n\\tif(diffArr.length)\\n\\t\\treturn Math.max(...diffArr)\\n\\telse\\n\\t\\treturn -1\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n\\tlet diffArr=[]\\n\\ts=s.split(\\'\\')\\n    for(let i=0;i<s.length;i++){\\n\\t\\t\\n\\t\\tlet curpos=s.indexOf(s[i])\\n\\t\\tlet tmp=s[i]\\n\\t\\ts[i]=0\\n\\t\\tif(s.lastIndexOf(tmp)>0 && curpos!=s.lastIndexOf(tmp)) \\n\\t\\t\\tdiffArr.push(s.lastIndexOf(tmp)-curpos-1)\\n\\t\\tconsole.log(s.indexOf(tmp),curpos)\\n\\t}\\n\\tconsole.log(diffArr)\\n\\tif(diffArr.length)\\n\\t\\treturn Math.max(...diffArr)\\n\\telse\\n\\t\\treturn -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027924,
                "title": "c-speed-mem-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int letter[26] = {};\\n        int max_cnt = -1;\\n        \\n        for(int i=0; i< s.size(); i++){\\n            \\n            int idx = s[i]-\\'a\\';\\n            \\n            // letter appears for the first time in s\\n            if(letter[idx] == 0)\\n                letter[idx] = i+1;\\n            \\n            else\\n                max_cnt = max(max_cnt, i-letter[idx]); \\n        }\\n        \\n        return max_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int letter[26] = {};\\n        int max_cnt = -1;\\n        \\n        for(int i=0; i< s.size(); i++){\\n            \\n            int idx = s[i]-\\'a\\';\\n            \\n            // letter appears for the first time in s\\n            if(letter[idx] == 0)\\n                letter[idx] = i+1;\\n            \\n            else\\n                max_cnt = max(max_cnt, i-letter[idx]); \\n        }\\n        \\n        return max_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016623,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        occ=dict()\\n        mx=-1\\n        for i in range(0,len(s)):\\n            if s[i] in occ.keys():\\n                if i-occ[s[i]]-1>mx:\\n                    mx=i-occ[s[i]]-1\\n            else:\\n                occ.update({s[i]:i})\\n        return mx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        occ=dict()\\n        mx=-1\\n        for i in range(0,len(s)):\\n            if s[i] in occ.keys():\\n                if i-occ[s[i]]-1>mx:\\n                    mx=i-occ[s[i]]-1\\n            else:\\n                occ.update({s[i]:i})\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959944,
                "title": "pyhton3-one-pass-beat-99-94",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ans=-1\\n        seen={}\\n        for i,j in enumerate(s):\\n            if j in seen:\\n                ans=max(ans,i-seen[j]-1)\\n            else:\\n                seen[j]=i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ans=-1\\n        seen={}\\n        for i,j in enumerate(s):\\n            if j in seen:\\n                ans=max(ans,i-seen[j]-1)\\n            else:\\n                seen[j]=i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950346,
                "title": "javascript-solution",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    const n = s.length;\\n    const start = new Array(26).fill(-1);\\n    let max = -1;\\n    \\n    for (let i = 0; i < n; i++) {\\n        const index = s.charAt(i).charCodeAt(0) - 97;\\n        \\n        if (start[index] === -1) start[index] = i;\\n        else max = Math.max(max, i - start[index] - 1);        \\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    const n = s.length;\\n    const start = new Array(26).fill(-1);\\n    let max = -1;\\n    \\n    for (let i = 0; i < n; i++) {\\n        const index = s.charAt(i).charCodeAt(0) - 97;\\n        \\n        if (start[index] === -1) start[index] = i;\\n        else max = Math.max(max, i - start[index] - 1);        \\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946685,
                "title": "java-solution-o-n",
                "content": "```\\nclass Solution {\\n\\t\\tpublic int maxLengthBetweenEqualCharacters(String s) {\\n\\t\\t\\tint[] lastIndex = new int[26];\\n\\t\\t\\tboolean visited[] = new boolean[26];    \\n\\t\\t\\tfor(int i = 0; i < s.length(); i++) {\\n\\t\\t\\t\\tlastIndex[s.charAt(i) - \\'a\\'] = i;\\n\\t\\t\\t\\tif(!visited[s.charAt(i) - \\'a\\']){\\n\\t\\t\\t\\t\\tvisited[s.charAt(i) - \\'a\\'] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint max = Integer.MIN_VALUE;    \\n\\t\\t\\tfor(int i = 0; i < s.length(); i++){\\n\\t\\t\\t\\tif(visited[s.charAt(i) - \\'a\\']){\\n\\t\\t\\t\\t\\tmax = Math.max(max, lastIndex[s.charAt(i) - \\'a\\'] - i);\\n\\t\\t\\t\\t\\tvisited[s.charAt(i) - \\'a\\'] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\treturn max == Integer.MIN_VALUE ? -1 : max-1;\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\tpublic int maxLengthBetweenEqualCharacters(String s) {\\n\\t\\t\\tint[] lastIndex = new int[26];\\n\\t\\t\\tboolean visited[] = new boolean[26];    \\n\\t\\t\\tfor(int i = 0; i < s.length(); i++) {\\n\\t\\t\\t\\tlastIndex[s.charAt(i) - \\'a\\'] = i;\\n\\t\\t\\t\\tif(!visited[s.charAt(i) - \\'a\\']){\\n\\t\\t\\t\\t\\tvisited[s.charAt(i) - \\'a\\'] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint max = Integer.MIN_VALUE;    \\n\\t\\t\\tfor(int i = 0; i < s.length(); i++){\\n\\t\\t\\t\\tif(visited[s.charAt(i) - \\'a\\']){\\n\\t\\t\\t\\t\\tmax = Math.max(max, lastIndex[s.charAt(i) - \\'a\\'] - i);\\n\\t\\t\\t\\t\\tvisited[s.charAt(i) - \\'a\\'] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t\\treturn max == Integer.MIN_VALUE ? -1 : max-1;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942229,
                "title": "python3-clean-solution-using-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        n = len(s) - 1\\n        max_sub = 0\\n        found = False\\n        for i in range(n):\\n            left = i\\n            right = n\\n            \\n            while left < right:\\n                if s[left] != s[right]:\\n                    right -=1\\n                elif s[left] == s[right]:\\n                    found = True\\n                    max_sub = max(max_sub,(right-left)-1)\\n                    break\\n        if not found:\\n            return -1\\n        return max_sub\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        n = len(s) - 1\\n        max_sub = 0\\n        found = False\\n        for i in range(n):\\n            left = i\\n            right = n\\n            \\n            while left < right:\\n                if s[left] != s[right]:\\n                    right -=1\\n                elif s[left] == s[right]:\\n                    found = True\\n                    max_sub = max(max_sub,(right-left)-1)\\n                    break\\n        if not found:\\n            return -1\\n        return max_sub\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940979,
                "title": "java-2-for-loop-0ms",
                "content": "```\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int len = s.length();\\n        int largest = -1;        \\n        for (int i = 0; i < len; i++) {            \\n            for (int j = len-1; j > i+largest+1; j--) {                \\n                if (s.charAt(i) == s.charAt(j)) {\\n                    largest = j-i-1;\\n                    break;\\n                }\\n            }\\n        }\\n        return largest;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int len = s.length();\\n        int largest = -1;        \\n        for (int i = 0; i < len; i++) {            \\n            for (int j = len-1; j > i+largest+1; j--) {                \\n                if (s.charAt(i) == s.charAt(j)) {\\n                    largest = j-i-1;\\n                    break;\\n                }\\n            }\\n        }\\n        return largest;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 932279,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) space O(n)\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    const map = {}\\n    let maxDiff = 0\\n    let firstIndex = 0\\n    let lastIndex = 0\\n    \\n    for(let i=0; i<s.length; i++) {\\n        const letter = s[i]\\n        \\n        if(map[letter]) {\\n            map[letter] = {\\n                value: map[letter].value + 1,\\n                indices: [...map[letter].indices, i]\\n            }\\n        } else {\\n            map[letter] = {\\n                value: 1,\\n                indices: [i]\\n            }\\n        }\\n    }\\n\\n    for(const key in map) {\\n        if(map[key].value >= 2) {\\n            const firstIdx = map[key].indices[0]\\n            const lastIdx = map[key].indices[map[key].indices.length - 1]\\n            const diff = lastIdx - firstIdx\\n            maxDiff = Math.max(maxDiff, diff)  \\n        }\\n    }\\n    \\n    return maxDiff - 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) space O(n)\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    const map = {}\\n    let maxDiff = 0\\n    let firstIndex = 0\\n    let lastIndex = 0\\n    \\n    for(let i=0; i<s.length; i++) {\\n        const letter = s[i]\\n        \\n        if(map[letter]) {\\n            map[letter] = {\\n                value: map[letter].value + 1,\\n                indices: [...map[letter].indices, i]\\n            }\\n        } else {\\n            map[letter] = {\\n                value: 1,\\n                indices: [i]\\n            }\\n        }\\n    }\\n\\n    for(const key in map) {\\n        if(map[key].value >= 2) {\\n            const firstIdx = map[key].indices[0]\\n            const lastIdx = map[key].indices[map[key].indices.length - 1]\\n            const diff = lastIdx - firstIdx\\n            maxDiff = Math.max(maxDiff, diff)  \\n        }\\n    }\\n    \\n    return maxDiff - 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 928482,
                "title": "java-faster-then-100-linear-easy-with-dictionary",
                "content": "```\\nclass Solution {\\n    \\n    private static final int VAL_A = (int) \\'a\\';\\n    private static final int VAL_Z = (int) \\'z\\';\\n    private static final int NOT_FOUND = -1;\\n    \\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        var alphabet = new int[VAL_Z - VAL_A + 1];\\n        Arrays.fill(alphabet, NOT_FOUND);\\n        \\n        var result = NOT_FOUND;\\n        for (int i = 0; i < s.length(); i++) {\\n            var alphabetIdx = s.charAt(i) - VAL_A;\\n            if (alphabet[alphabetIdx] == NOT_FOUND) {\\n                alphabet[alphabetIdx] = i;\\n                continue;\\n            }\\n            \\n            var distance = i - (alphabet[alphabetIdx] + 1);\\n            if (distance > result) {\\n                result = distance;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private static final int VAL_A = (int) \\'a\\';\\n    private static final int VAL_Z = (int) \\'z\\';\\n    private static final int NOT_FOUND = -1;\\n    \\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        var alphabet = new int[VAL_Z - VAL_A + 1];\\n        Arrays.fill(alphabet, NOT_FOUND);\\n        \\n        var result = NOT_FOUND;\\n        for (int i = 0; i < s.length(); i++) {\\n            var alphabetIdx = s.charAt(i) - VAL_A;\\n            if (alphabet[alphabetIdx] == NOT_FOUND) {\\n                alphabet[alphabetIdx] = i;\\n                continue;\\n            }\\n            \\n            var distance = i - (alphabet[alphabetIdx] + 1);\\n            if (distance > result) {\\n                result = distance;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924382,
                "title": "c-easy-code-with-explanation-o-n-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxLengthBetweenEqualCharacters(string s) {\\n\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tunordered_map<char,int> m; // used to store the end position of different character\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tchar ch = s[i];\\n\\n\\t\\t\\t\\tif(m.count(ch))  // if current char is already present, then update the last position\\n\\t\\t\\t\\t\\tm[ch] = i;\\n\\t\\t\\t\\telse             //if not present, then add in hash-map\\n\\t\\t\\t\\t\\tm[ch] = i;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxAns = INT_MIN;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tchar curr_char = s[i]; \\n\\n\\t\\t\\t\\tint end_position_of_curr_char = m[curr_char];\\n\\n\\t\\t\\t\\tint len = end_position_of_curr_char - i - 1;\\n\\n\\t\\t\\t\\tmaxAns = max(maxAns,len);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxAns;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxLengthBetweenEqualCharacters(string s) {\\n\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tunordered_map<char,int> m; // used to store the end position of different character\\n\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tchar ch = s[i];\\n\\n\\t\\t\\t\\tif(m.count(ch))  // if current char is already present, then update the last position\\n\\t\\t\\t\\t\\tm[ch] = i;\\n\\t\\t\\t\\telse             //if not present, then add in hash-map\\n\\t\\t\\t\\t\\tm[ch] = i;\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 921826,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int mx = INT_MIN;\\n        bool flag = false;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            for(int j = i + 1; j < s.length(); j++)\\n            {\\n                int dis = 0;\\n                if(s[j] == s[i])\\n                {\\n                    dis = j - i - 1;\\n                    flag = true;\\n                }\\n                mx = max(mx, dis);\\n            }\\n        }\\n        if(flag)\\n            return mx;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int mx = INT_MIN;\\n        bool flag = false;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            for(int j = i + 1; j < s.length(); j++)\\n            {\\n                int dis = 0;\\n                if(s[j] == s[i])\\n                {\\n                    dis = j - i - 1;\\n                    flag = true;\\n                }\\n                mx = max(mx, dis);\\n            }\\n        }\\n        if(flag)\\n            return mx;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901761,
                "title": "o-n-time-o-1-space-java-100",
                "content": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n        int[] firstOccurrence = new int[26];\\n        Arrays.fill(firstOccurrence,-1);\\n        int max = 0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if(firstOccurrence[c - \\'a\\'] == -1)\\n            {\\n                firstOccurrence[c - \\'a\\'] = i;\\n            }\\n            else\\n            {\\n                max = Math.max(max, i-firstOccurrence[c - \\'a\\']);\\n            }\\n        }\\n        \\n        return max-1;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n        int[] firstOccurrence = new int[26];\\n        Arrays.fill(firstOccurrence,-1);\\n        int max = 0;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if(firstOccurrence[c - \\'a\\'] == -1)\\n            {\\n                firstOccurrence[c - \\'a\\'] = i;\\n            }\\n            else\\n            {\\n                max = Math.max(max, i-firstOccurrence[c - \\'a\\']);\\n            }\\n        }\\n        \\n        return max-1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 901746,
                "title": "python-28ms-14mb",
                "content": "IDEA: iterate over the string and save the first and last appearances of each relevant letter in dictionary\\nat the same time save the the greatest distance and update if relevant.\\n\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        first = dict()\\n        second = dict()\\n        ans = -1\\n        for i in range(len(s)):\\n            if s[i] in first:\\n                second[s[i]] = i\\n                if i - first[s[i]] - 1 > ans:\\n                    ans = i - first[s[i]] - 1\\n            else:\\n                first[s[i]] = i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        first = dict()\\n        second = dict()\\n        ans = -1\\n        for i in range(len(s)):\\n            if s[i] in first:\\n                second[s[i]] = i\\n                if i - first[s[i]] - 1 > ans:\\n                    ans = i - first[s[i]] - 1\\n            else:\\n                first[s[i]] = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900934,
                "title": "rust-0ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_length_between_equal_characters(s: String) -> i32 {\\n        use std::collections::HashMap;\\n\\n        let mut ans = -1;\\n        let mut map = HashMap::<char, i32>::new();\\n        for (i, ch) in s.chars().enumerate() {\\n            let entry = map.entry(ch).or_insert(-1);\\n            if *entry == -1 {\\n                *entry = i as i32;\\n            } else {\\n                ans = std::cmp::max(ans, i as i32 - *entry - 1);\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_max_length_between_equal_characters() {\\n        assert_eq!(\\n            Solution::max_length_between_equal_characters(\"aa\".to_owned()),\\n            0\\n        );\\n    }\\n\\n    #[test]\\n    fn test_max_length_between_equal_characters_02() {\\n        assert_eq!(\\n            Solution::max_length_between_equal_characters(\"abca\".to_owned()),\\n            2\\n        );\\n    }\\n\\n    #[test]\\n    fn test_max_length_between_equal_characters_03() {\\n        assert_eq!(\\n            Solution::max_length_between_equal_characters(\"cbzxy\".to_owned()),\\n            -1\\n        );\\n    }\\n\\n    #[test]\\n    fn test_max_length_between_equal_characters_04() {\\n        assert_eq!(\\n            Solution::max_length_between_equal_characters(\"cabbac\".to_owned()),\\n            4\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_length_between_equal_characters(s: String) -> i32 {\\n        use std::collections::HashMap;\\n\\n        let mut ans = -1;\\n        let mut map = HashMap::<char, i32>::new();\\n        for (i, ch) in s.chars().enumerate() {\\n            let entry = map.entry(ch).or_insert(-1);\\n            if *entry == -1 {\\n                *entry = i as i32;\\n            } else {\\n                ans = std::cmp::max(ans, i as i32 - *entry - 1);\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_max_length_between_equal_characters() {\\n        assert_eq!(\\n            Solution::max_length_between_equal_characters(\"aa\".to_owned()),\\n            0\\n        );\\n    }\\n\\n    #[test]\\n    fn test_max_length_between_equal_characters_02() {\\n        assert_eq!(\\n            Solution::max_length_between_equal_characters(\"abca\".to_owned()),\\n            2\\n        );\\n    }\\n\\n    #[test]\\n    fn test_max_length_between_equal_characters_03() {\\n        assert_eq!(\\n            Solution::max_length_between_equal_characters(\"cbzxy\".to_owned()),\\n            -1\\n        );\\n    }\\n\\n    #[test]\\n    fn test_max_length_between_equal_characters_04() {\\n        assert_eq!(\\n            Solution::max_length_between_equal_characters(\"cabbac\".to_owned()),\\n            4\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 900643,
                "title": "c-java-faster-than-100-and-100-memory-easy-to-understand",
                "content": "if you like it please up vote\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int res = -1;\\n        map<char,int> map;\\n        \\n        for(int i =0;i<s.length();i++){\\n            if(map.count(s[i])){\\n                res = max(res,i-1-map[s[i]]);\\n            }\\n            else map[s[i]] = i;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res = -1;\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i =0;i<s.length();i++){\\n            if(map.containsKey(s.charAt(i))){\\n                res = Math.max(res,i-1-map.get(s.charAt(i)));\\n            }\\n            else map.put(s.charAt(i),i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int res = -1;\\n        map<char,int> map;\\n        \\n        for(int i =0;i<s.length();i++){\\n            if(map.count(s[i])){\\n                res = max(res,i-1-map[s[i]]);\\n            }\\n            else map[s[i]] = i;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res = -1;\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i =0;i<s.length();i++){\\n            if(map.containsKey(s.charAt(i))){\\n                res = Math.max(res,i-1-map.get(s.charAt(i)));\\n            }\\n            else map.put(s.charAt(i),i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900526,
                "title": "java-c-python-clean-concise-code-hashmap-approach",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        int length = s.length(), max = -1;\\n        for(int i = 0; i < length; i += 1) {\\n            char ch = s.charAt(i);\\n            if(hm.containsKey(ch)) {\\n                max = Math.max(max, (i - hm.get(ch)));\\n            }else {\\n                hm.put(ch, i + 1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        unordered_map<char, int> umap;\\n        int length = s.length(), maxLen = -1;\\n        for(int i = 0; i < length; i += 1) {\\n            char ch = s[i];\\n            if(umap.count(ch) == 1) {\\n                maxLen = max(maxLen, (i - umap[ch]));\\n            }else {\\n                umap[ch] = i + 1;\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        max_length = -1\\n        hm = {}\\n        for i in range(len(s)):\\n            if s[i] in hm:\\n                max_length = max(max_length, (i  - hm[s[i]]))\\n            else:\\n                hm[s[i]] = i + 1\\n        return max_length;\\n```\\n**If you like it then please upvote my post**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        int length = s.length(), max = -1;\\n        for(int i = 0; i < length; i += 1) {\\n            char ch = s.charAt(i);\\n            if(hm.containsKey(ch)) {\\n                max = Math.max(max, (i - hm.get(ch)));\\n            }else {\\n                hm.put(ch, i + 1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        unordered_map<char, int> umap;\\n        int length = s.length(), maxLen = -1;\\n        for(int i = 0; i < length; i += 1) {\\n            char ch = s[i];\\n            if(umap.count(ch) == 1) {\\n                maxLen = max(maxLen, (i - umap[ch]));\\n            }else {\\n                umap[ch] = i + 1;\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        max_length = -1\\n        hm = {}\\n        for i in range(len(s)):\\n            if s[i] in hm:\\n                max_length = max(max_length, (i  - hm[s[i]]))\\n            else:\\n                hm[s[i]] = i + 1\\n        return max_length;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900313,
                "title": "java-simple-solution-using-array-o-n-with-explanation",
                "content": "Create a bucket to store the first occurance of every unique character in the string. While traversing the string, calculate the max distance between every occurance and first occurance of the characters.\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] bucket = new int[26];\\n        Arrays.fill(bucket, -1);\\n        int res = -1;\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(bucket[c - \\'a\\'] == -1) \\n                bucket[c - \\'a\\'] = i;\\n            else \\n                res = Math.max(res, (i - bucket[c - \\'a\\']) - 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int[] bucket = new int[26];\\n        Arrays.fill(bucket, -1);\\n        int res = -1;\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(bucket[c - \\'a\\'] == -1) \\n                bucket[c - \\'a\\'] = i;\\n            else \\n                res = Math.max(res, (i - bucket[c - \\'a\\']) - 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899763,
                "title": "c-simple-o-n-using-hashmap",
                "content": "int maxLengthBetweenEqualCharacters(string s)   {\\n\\n        unordered_map<char,int> uMap;\\n        int max = -1;\\n        for(int i=0; i < s.size(); i++)\\n        {\\n            if (uMap.count(s[i])) {\\n                if(i-uMap[s[i]]-1 > max)\\n                    max = i-uMap[s[i]]-1;\\n            } else {\\n                uMap[s[i]]=i;\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "int maxLengthBetweenEqualCharacters(string s)   {\\n\\n        unordered_map<char,int> uMap;\\n        int max = -1;\\n        for(int i=0; i < s.size(); i++)\\n        {\\n            if (uMap.count(s[i])) {\\n                if(i-uMap[s[i]]-1 > max)\\n                    max = i-uMap[s[i]]-1;\\n            } else {\\n                uMap[s[i]]=i;\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 899755,
                "title": "java-simple-o-n-loop",
                "content": "```\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int ml = -1, l = s.length();  // ml, maxlen\\n        int[] left = new int[26];\\n        Arrays.fill(left, -1);\\n        for (int i = 0; i < l; i++) {\\n            int d = s.charAt(i) - \\'a\\';\\n            if (left[d] == -1)  left[d] = i;\\n            else ml = Math.max(ml, i - left[d] - 1);\\n        }\\n        return ml;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int ml = -1, l = s.length();  // ml, maxlen\\n        int[] left = new int[26];\\n        Arrays.fill(left, -1);\\n        for (int i = 0; i < l; i++) {\\n            int d = s.charAt(i) - \\'a\\';\\n            if (left[d] == -1)  left[d] = i;\\n            else ml = Math.max(ml, i - left[d] - 1);\\n        }\\n        return ml;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899726,
                "title": "java-store-the-first-index",
                "content": "```\\n\\tpublic int maxLengthBetweenEqualCharacters(String s) {\\n        int[] chars = new int[26];\\n        int ans = -1, i = 0;\\n        Arrays.fill(chars, -1);\\n        for(int c : s.toCharArray()){\\n            int index = (int)(c - \\'a\\');\\n            if(chars[index] == -1){\\n                chars[index] = i;\\n            } else {\\n                ans = Math.max(ans, i - chars[index] - 1);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int maxLengthBetweenEqualCharacters(String s) {\\n        int[] chars = new int[26];\\n        int ans = -1, i = 0;\\n        Arrays.fill(chars, -1);\\n        for(int c : s.toCharArray()){\\n            int index = (int)(c - \\'a\\');\\n            if(chars[index] == -1){\\n                chars[index] = i;\\n            } else {\\n                ans = Math.max(ans, i - chars[index] - 1);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899639,
                "title": "1624-largest-substring-between-two-equal-characters-javascript-solution",
                "content": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {      \\n    let res = -1;\\n    let map = {};\\n    \\n    for (let i = 0; i < s.length; i++) {    \\n        map[s[i]] = i;\\n    }\\n    \\n    for (let i = 0; i < s.length; i++)  {\\n        res = Math.max(res, map[s[i]] - i - 1);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxLengthBetweenEqualCharacters = function(s) {      \\n    let res = -1;\\n    let map = {};\\n    \\n    for (let i = 0; i < s.length; i++) {    \\n        map[s[i]] = i;\\n    }\\n    \\n    for (let i = 0; i < s.length; i++)  {\\n        res = Math.max(res, map[s[i]] - i - 1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899636,
                "title": "python-hashmap-solution",
                "content": "```python\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        res, seen = -1, {}\\n        \\n        for i, l in enumerate(s):\\n            if l in seen:\\n                res = max(res, i - seen[l] - 1)\\n            if l not in seen:\\n                seen[l] = i\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        res, seen = -1, {}\\n        \\n        for i, l in enumerate(s):\\n            if l in seen:\\n                res = max(res, i - seen[l] - 1)\\n            if l not in seen:\\n                seen[l] = i\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899622,
                "title": "java-o-n-easy-to-understand",
                "content": "1 use HashMap to record the index list of each char\\n2 for each char key of HashMap, calculate the first and last index of current char to update ans\\n\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            map.putIfAbsent(ch, new ArrayList<>());\\n            map.get(ch).add(i);\\n        }\\n        \\n        int maxLen = -1;\\n        for (char key: map.keySet()) {\\n            if (map.get(key).size() >= 2) {\\n                List<Integer> index = map.get(key);\\n                maxLen = Math.max(maxLen, index.get(index.size() - 1) - index.get(0) - 1);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        Map<Character, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            map.putIfAbsent(ch, new ArrayList<>());\\n            map.get(ch).add(i);\\n        }\\n        \\n        int maxLen = -1;\\n        for (char key: map.keySet()) {\\n            if (map.get(key).size() >= 2) {\\n                List<Integer> index = map.get(key);\\n                maxLen = Math.max(maxLen, index.get(index.size() - 1) - index.get(0) - 1);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899619,
                "title": "java-solution",
                "content": "\\tpublic int maxLengthBetweenEqualCharacters(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int res = -1;\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            if(map.containsKey(c)){\\n                res = Math.max(res, i - map.get(c) - 1);\\n            }\\n            map.putIfAbsent(c, i);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int maxLengthBetweenEqualCharacters(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int res = -1;\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            if(map.containsKey(c)){\\n                res = Math.max(res, i - map.get(c) - 1);\\n            }\\n            map.putIfAbsent(c, i);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 899616,
                "title": "c-o-n-time-and-o-1-space-one-pass",
                "content": "We will use `unordered_map` but since we will at max store only 26 keys, technically the space complexity is O(1). You can also use vector of length 26\\n\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int maxLen = -1;\\n        int n = s.size();\\n        unordered_map<char, int> seen;\\n        \\n        for(int i = 0; i < n; ++i) {\\n            char curr = s[i];\\n            \\n            if(seen.find(curr) != seen.end()) \\n                maxLen = max(maxLen, i - seen[curr] - 1);\\n            else \\n                seen[curr] = i;\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int maxLen = -1;\\n        int n = s.size();\\n        unordered_map<char, int> seen;\\n        \\n        for(int i = 0; i < n; ++i) {\\n            char curr = s[i];\\n            \\n            if(seen.find(curr) != seen.end()) \\n                maxLen = max(maxLen, i - seen[curr] - 1);\\n            else \\n                seen[curr] = i;\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899601,
                "title": "python-java-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n\\t\\t\\td = {}\\n\\t\\t\\tres = -1\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] not in d:\\n\\t\\t\\t\\t\\td[s[i]] = i\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres = max(res, i - d[s[i]] - 1)\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int maxLengthBetweenEqualCharacters(String s) {\\n\\t\\t\\tHashMap <Character, Integer> idx = new HashMap<>();\\n\\t\\t\\tint res = -1;\\n\\t\\t\\tfor (int i = 0; i < s.length(); i ++){\\n\\t\\t\\t\\tif (!idx.containsKey(s.charAt(i))){\\n\\t\\t\\t\\t\\tidx.put(s.charAt(i), i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tres = Math.max(res, i - idx.get(s.charAt(i)) - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n\\t\\t\\td = {}",
                "codeTag": "Java"
            },
            {
                "id": 899587,
                "title": "java-no-map-solution",
                "content": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n       int n = s.length(); \\n        int res = -1; \\n          \\n        for (int i = 0; i < n - 1; i++) \\n            for (int j = i + 1; j < n; j++) \\n                if (s.charAt(i) == s.charAt(j)) \\n                    res = Math.max(res,  Math.abs(j - i - 1)); \\n                           \\n        return res; \\n    }",
                "solutionTags": [],
                "code": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n       int n = s.length(); \\n        int res = -1; \\n          \\n        for (int i = 0; i < n - 1; i++) \\n            for (int j = i + 1; j < n; j++) \\n                if (s.charAt(i) == s.charAt(j)) \\n                    res = Math.max(res,  Math.abs(j - i - 1)); \\n                           \\n        return res; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 899576,
                "title": "c-o-n-time-o-1-space",
                "content": "idea: Record the minimum index of that letter\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxLengthBetweenEqualCharacters(string s) {\\n\\t\\t\\tint l = -1;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> ind(26, n);\\n\\t\\t\\tfor(int i = 0; i < n; ++i){\\n\\t\\t\\t\\tind[s[i]-\\'a\\'] = min(i, ind[s[i]-\\'a\\']);\\n\\t\\t\\t\\tl = max(l, i-ind[s[i]-\\'a\\']-1);\\n\\t\\t\\t}\\n\\t\\t\\treturn l;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxLengthBetweenEqualCharacters(string s) {\\n\\t\\t\\tint l = -1;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> ind(26, n);\\n\\t\\t\\tfor(int i = 0; i < n; ++i){\\n\\t\\t\\t\\tind[s[i]-\\'a\\'] = min(i, ind[s[i]-\\'a\\']);\\n\\t\\t\\t\\tl = max(l, i-ind[s[i]-\\'a\\']-1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 899559,
                "title": "java-simple",
                "content": "```\\nint ch1[]=new int[26];\\n           int max=-1;\\n        for(int i=0;i<s.length();i++){\\n            if(ch1[s.charAt(i)-\\'a\\']>0){\\n                max=Math.max(max,i-ch1[s.charAt(i)-\\'a\\']);\\n                }\\n             else \\n               ch1[s.charAt(i)-\\'a\\']=i+1;\\n        }\\n      \\n        return max;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint ch1[]=new int[26];\\n           int max=-1;\\n        for(int i=0;i<s.length();i++){\\n            if(ch1[s.charAt(i)-\\'a\\']>0){\\n                max=Math.max(max,i-ch1[s.charAt(i)-\\'a\\']);\\n                }\\n             else \\n               ch1[s.charAt(i)-\\'a\\']=i+1;\\n        }\\n      \\n        return max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899525,
                "title": "c-o-n-time-o-1-space-solution-beats-100",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int maxLengthBetweenEqualCharacters(string s) \\n    {\\n        int result=-1;\\n        int a[26][2];\\n        for(int i=0;i<26;i++) a[i][0]=-1,a[i][1]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(a[s[i]-\\'a\\'][0]==-1) a[s[i]-\\'a\\'][0]=i;\\n            a[s[i]-\\'a\\'][1]=i;\\n        }\\n        for(int i=0;i<26;i++) result=max(result,a[i][1]-a[i][0]-1);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int maxLengthBetweenEqualCharacters(string s) \\n    {\\n        int result=-1;\\n        int a[26][2];\\n        for(int i=0;i<26;i++) a[i][0]=-1,a[i][1]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(a[s[i]-\\'a\\'][0]==-1) a[s[i]-\\'a\\'][0]=i;\\n            a[s[i]-\\'a\\'][1]=i;\\n        }\\n        for(int i=0;i<26;i++) result=max(result,a[i][1]-a[i][0]-1);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899523,
                "title": "python-6-lines-solution",
                "content": "```python\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ans, d = -1, {}\\n        for end, c in enumerate(s):\\n            if c in d:\\n                ans = max(ans, end-d[c]-1)\\n            d.setdefault(c, end)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        ans, d = -1, {}\\n        for end, c in enumerate(s):\\n            if c in d:\\n                ans = max(ans, end-d[c]-1)\\n            d.setdefault(c, end)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 899504,
                "title": "python-map",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maxLengthBetweenEqualCharacters(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmaps = {}\\n\\t\\t\\tres = -1\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] not in maps:\\n\\t\\t\\t\\t\\tmaps[s[i]] = i\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres = max(res, i - maps[s[i]] - 1)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\t\\tdef maxLengthBetweenEqualCharacters(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmaps = {}",
                "codeTag": "Java"
            },
            {
                "id": 899500,
                "title": "easy-to-understand-python3-solution",
                "content": "```\\ndef maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        charSet = []\\n        res = float(\\'-inf\\')\\n\\t\\t\\n        for r in range(len(s)):\\n            l = 0\\n            for i in charSet:\\n                l += 1\\n                if i == s[r]:\\n                    res = max(res, r - l)\\n    \\n            charSet.append(s[r])\\n        \\n        if res != float(\\'-inf\\'):\\n            return res\\n        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        charSet = []\\n        res = float(\\'-inf\\')\\n\\t\\t\\n        for r in range(len(s)):\\n            l = 0\\n            for i in charSet:\\n                l += 1\\n                if i == s[r]:\\n                    res = max(res, r - l)\\n    \\n            charSet.append(s[r])\\n        \\n        if res != float(\\'-inf\\'):\\n            return res\\n        \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 899497,
                "title": "c-easy",
                "content": "````\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<int>v(26,-1);\\n        int maxi=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1)\\n                v[s[i]-\\'a\\']=i;\\n            else{\\n                maxi=max(i-v[s[i]-\\'a\\']-1,maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        vector<int>v(26,-1);\\n        int maxi=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1)\\n                v[s[i]-\\'a\\']=i;\\n            else{\\n                maxi=max(i-v[s[i]-\\'a\\']-1,maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899483,
                "title": "c-simple-brute-force",
                "content": "Simple, straight forward solution. \\n```\\nclass Solution\\n{\\npublic:\\n  int maxLengthBetweenEqualCharacters(string s)\\n  {\\n    int size = s.length();\\n    int answer = -1;\\n    for (int i = 0; i < size - 1; i++)\\n    {\\n      for (int j = i + 1; j < size; j++)\\n      {\\n        if (s[i] == s[j])\\n        {\\n          answer = max(answer, j - i - 1);\\n        }\\n      }\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int maxLengthBetweenEqualCharacters(string s)\\n  {\\n    int size = s.length();\\n    int answer = -1;\\n    for (int i = 0; i < size - 1; i++)\\n    {\\n      for (int j = i + 1; j < size; j++)\\n      {\\n        if (s[i] == s[j])\\n        {\\n          answer = max(answer, j - i - 1);\\n        }\\n      }\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899481,
                "title": "java-o-n-2",
                "content": "```\\n\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        \\n        int longest = -1;\\n        \\n        for(int i = 0; i < s.length() - 1; i++)\\n        {\\n            for(int j = i + 1; j < s.length(); j++)\\n            {\\n                if(s.charAt(i) == s.charAt(j))\\n                {\\n                    int dist = j - i - 1;\\n                    longest = Math.max(longest, dist);\\n                }\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        \\n        int longest = -1;\\n        \\n        for(int i = 0; i < s.length() - 1; i++)\\n        {\\n            for(int j = i + 1; j < s.length(); j++)\\n            {\\n                if(s.charAt(i) == s.charAt(j))\\n                {\\n                    int dist = j - i - 1;\\n                    longest = Math.max(longest, dist);\\n                }\\n            }\\n        }\\n        \\n        return longest;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 899478,
                "title": "javascirpt-map-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let map = new Map();\\n    let max = -1;\\n    for(let i=0; i<s.length; i++){\\n        if(map.has(s.charAt(i))){\\n            max = Math.max(max, i - map.get(s.charAt(i)) - 1);\\n        }else{\\n            map.set(s.charAt(i), i);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxLengthBetweenEqualCharacters = function(s) {\\n    let map = new Map();\\n    let max = -1;\\n    for(let i=0; i<s.length; i++){\\n        if(map.has(s.charAt(i))){\\n            max = Math.max(max, i - map.get(s.charAt(i)) - 1);\\n        }else{\\n            map.set(s.charAt(i), i);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899469,
                "title": "java-easy-o-n-solution",
                "content": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n        int[] arr=new int[26];\\n        Arrays.fill(arr,-1);\\n        int ans=-1;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(arr[s.charAt(i)-\\'a\\']>=0){\\n                ans=Math.max(ans,i-arr[s.charAt(i)-\\'a\\']-1);\\n            }else{\\n                arr[s.charAt(i)-\\'a\\']=i;\\n            }\\n        }\\n        \\n       return ans; \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int maxLengthBetweenEqualCharacters(String s) {\\n        int[] arr=new int[26];\\n        Arrays.fill(arr,-1);\\n        int ans=-1;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(arr[s.charAt(i)-\\'a\\']>=0){\\n                ans=Math.max(ans,i-arr[s.charAt(i)-\\'a\\']-1);\\n            }else{\\n                arr[s.charAt(i)-\\'a\\']=i;\\n            }\\n        }\\n        \\n       return ans; \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 899453,
                "title": "c-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int ans = -1;\\n        map<char, int> mp;\\n        if(s.length() == 1){\\n            return -1;\\n        }\\n        \\n        for(int i=0; i<s.length(); i++) {\\n            if(mp.find(s[i]) != mp.end()){\\n\\t\\t\\t\\t// Char occurred before, find difference between current occurence and first occurence.\\n\\t\\t\\t\\t// Is the difference greater than previous differences?\\n                ans = max(ans, (i-mp[s[i]]-1));\\n            } else {\\n\\t\\t\\t\\t// First occurence of char. Store \\'char\\'->index_of_first_occurrence.\\n                mp[s[i]] = i;\\n            }\\n        }        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int ans = -1;\\n        map<char, int> mp;\\n        if(s.length() == 1){\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 899449,
                "title": "java-on-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max = 0;\\n        boolean found = false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (map.containsKey(c)) {\\n                found = true;\\n                max = Math.max(max, i - map.get(c) - 1);\\n            } else {\\n                map.put(c, i);\\n            }\\n        }\\n        return found ? max : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max = 0;\\n        boolean found = false;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (map.containsKey(c)) {\\n                found = true;\\n                max = Math.max(max, i - map.get(c) - 1);\\n            } else {\\n                map.put(c, i);\\n            }\\n        }\\n        return found ? max : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899445,
                "title": "swift-12ms",
                "content": "```\\nclass Solution {\\n    func maxLengthBetweenEqualCharacters(_ s: String) -> Int {\\n        var maxLength = -1\\n        var lastSeenIndex = [Character:Int]()\\n        \\n        for (i,s) in s.enumerated(){\\n            if let lastIndex = lastSeenIndex[s]{\\n                maxLength = max(maxLength, i - lastIndex - 1)\\n            }else{\\n                lastSeenIndex[s] = i\\n            }\\n        }\\n        \\n        return maxLength\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxLengthBetweenEqualCharacters(_ s: String) -> Int {\\n        var maxLength = -1\\n        var lastSeenIndex = [Character:Int]()\\n        \\n        for (i,s) in s.enumerated(){\\n            if let lastIndex = lastSeenIndex[s]{\\n                maxLength = max(maxLength, i - lastIndex - 1)\\n            }else{\\n                lastSeenIndex[s] = i\\n            }\\n        }\\n        \\n        return maxLength\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078955,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/998a1866-85bc-4079-a042-9d60e73b2ca4_1695443349.404541.png)\\n\\n# Intution\\n- To reduce the search space, we have used map to process only those char which are appearing more than once in the string.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        map<char, int> mp;\\n        for(auto i : s) mp[i]++;\\n        int sz = s.length();\\n        int ans = -1;\\n        for(auto i : mp){\\n            if(i.second > 1){\\n                int st=0, j=sz-1;\\n                while(st<sz && s[st] != i.first) st++;\\n                while(j > st && s[j] != i.first) j--;\\n                ans = max(ans, (j-st-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        map<char, int> mp;\\n        for(auto i : s) mp[i]++;\\n        int sz = s.length();\\n        int ans = -1;\\n        for(auto i : mp){\\n            if(i.second > 1){\\n                int st=0, j=sz-1;\\n                while(st<sz && s[st] != i.first) st++;\\n                while(j > st && s[j] != i.first) j--;\\n                ans = max(ans, (j-st-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063111,
                "title": "very-simple-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        x=set(s)\\n        x=list(x)\\n        b=[]\\n        for i in range(len(x)):\\n            a=[]\\n            for j in range(len(s)):\\n                if x[i]==s[j]:\\n                    a.append(j)\\n            if len(a)>=2:\\n                b.append(max(a)-min(a))\\n        if len(b)==0:\\n            return -1\\n        else:\\n            return max(b)-1\\n\\n        \\n        \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        x=set(s)\\n        x=list(x)\\n        b=[]\\n        for i in range(len(x)):\\n            a=[]\\n            for j in range(len(s)):\\n                if x[i]==s[j]:\\n                    a.append(j)\\n            if len(a)>=2:\\n                b.append(max(a)-min(a))\\n        if len(b)==0:\\n            return -1\\n        else:\\n            return max(b)-1\\n\\n        \\n        \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062571,
                "title": "easy-understandable-solution-100-beats",
                "content": "\\n# Code\\n```\\nclass Solution {\\n//TC:- O(2*n)\\n//SC:- O(26*2)\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int [][] cnt = new int[26][2];\\n\\n        for(int i=0; i<s.length(); i++){\\n            int ascii = s.charAt(i)-\\'a\\';\\n\\n            if(cnt[ascii][0] == 0) {\\n                cnt[ascii][0] = i+1;\\n            }\\n            else {\\n                cnt[ascii][1] = i+1;\\n            }\\n        }\\n\\n        int res = 0;\\n        for(int i=0; i<26; i++){\\n            if(cnt[i][0]*cnt[i][1] != 0)\\n                res = Math.max(res, cnt[i][1]-cnt[i][0]);\\n        }\\n\\n        return res-1;\\n\\n/*\\n\\n//TC:- O(n2)\\n//SC:- O(1)\\n        int res=Integer.MIN_VALUE;\\n        for(int i=0; i<s.length(); i++){\\n            for(int j=s.length()-1; j>=0; j--){\\n                if(s.charAt(i)==s.charAt(j)){\\n                    res= Math.max(res, j-i-1);\\n                }\\n            }\\n        }\\n        return res==Integer.MIN_VALUE?-1:res;\\n\\n*/\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n//TC:- O(2*n)\\n//SC:- O(26*2)\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int [][] cnt = new int[26][2];\\n\\n        for(int i=0; i<s.length(); i++){\\n            int ascii = s.charAt(i)-\\'a\\';\\n\\n            if(cnt[ascii][0] == 0) {\\n                cnt[ascii][0] = i+1;\\n            }\\n            else {\\n                cnt[ascii][1] = i+1;\\n            }\\n        }\\n\\n        int res = 0;\\n        for(int i=0; i<26; i++){\\n            if(cnt[i][0]*cnt[i][1] != 0)\\n                res = Math.max(res, cnt[i][1]-cnt[i][0]);\\n        }\\n\\n        return res-1;\\n\\n/*\\n\\n//TC:- O(n2)\\n//SC:- O(1)\\n        int res=Integer.MIN_VALUE;\\n        for(int i=0; i<s.length(); i++){\\n            for(int j=s.length()-1; j>=0; j--){\\n                if(s.charAt(i)==s.charAt(j)){\\n                    res= Math.max(res, j-i-1);\\n                }\\n            }\\n        }\\n        return res==Integer.MIN_VALUE?-1:res;\\n\\n*/\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056257,
                "title": "cpp-using-hashmap-100-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        \\n        map<char,int>mp;\\n        map<char, int>mp1;\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(mp[s[i]]==0 && mp1[s[i]]==0)\\n            {\\n                mp1[s[i]]++;\\n                mp[s[i]]=i;\\n            }\\n            else\\n            {\\n                \\n                ans=max(i-mp[s[i]]-1, ans);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        \\n        map<char,int>mp;\\n        map<char, int>mp1;\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(mp[s[i]]==0 && mp1[s[i]]==0)\\n            {\\n                mp1[s[i]]++;\\n                mp[s[i]]=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4053313,
                "title": "88-runtime-94-memory-using-dicrionary-simple-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/0fbceba9-91bb-4ab5-ac6a-c759db5e859b_1694899657.6070325.png)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        d, result = {}, -1\\n\\n        for idx, chr in enumerate(s):\\n            if chr in d: d[chr] = d[chr][0], idx\\n            else: d[chr] = idx, 0\\n\\n        for idx, val in d.values():\\n            if val: result = max(result, val - idx - 1)\\n\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        d, result = {}, -1\\n\\n        for idx, chr in enumerate(s):\\n            if chr in d: d[chr] = d[chr][0], idx\\n            else: d[chr] = idx, 0\\n\\n        for idx, val in d.values():\\n            if val: result = max(result, val - idx - 1)\\n\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036923,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        if len(set(s)) == len(s):\\n            return -1\\n        \\n        m = 0\\n        s = list(s)\\n        \\n        for i in range(len(s)):\\n            if s[i+1:].count(s[i]) >= 1:\\n                idx = s[::-1].index(s[i])\\n                m = max(m, ((len(s)-1)-idx)-i-1)\\n        \\n        return m\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        if len(set(s)) == len(s):\\n            return -1\\n        \\n        m = 0\\n        s = list(s)\\n        \\n        for i in range(len(s)):\\n            if s[i+1:].count(s[i]) >= 1:\\n                idx = s[::-1].index(s[i])\\n                m = max(m, ((len(s)-1)-idx)-i-1)\\n        \\n        return m\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033240,
                "title": "simple-and-clear-solution",
                "content": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        dic = {}\\n        return max(i-dic.setdefault(ch, i)-1 for i, ch in enumerate(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        dic = {}\\n        return max(i-dic.setdefault(ch, i)-1 for i, ch in enumerate(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019666,
                "title": "kotlin-simple-one-liner",
                "content": "```\\nfun maxLengthBetweenEqualCharacters(s: String) = (\\'a\\'..\\'z\\').maxOf { s.lastIndexOf(it) - s.indexOf(it) - 1 }\\n```",
                "solutionTags": [],
                "code": "```\\nfun maxLengthBetweenEqualCharacters(s: String) = (\\'a\\'..\\'z\\').maxOf { s.lastIndexOf(it) - s.indexOf(it) - 1 }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018475,
                "title": "essay-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max = -1;\\n        for(int i=0; i<s.length(); i++){\\n            for(int j=s.length()-1; j>=0; j--){\\n                if(s.charAt(i) == s.charAt(j)){\\n                    max  = Math.max(max, j-i-1);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int max = -1;\\n        for(int i=0; i<s.length(); i++){\\n            for(int j=s.length()-1; j>=0; j--){\\n                if(s.charAt(i) == s.charAt(j)){\\n                    max  = Math.max(max, j-i-1);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008286,
                "title": "easy-solution-using-map-in-java-beats-80-47",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if(map.containsKey(c))\\n            {\\n                max = Math.max(max, i-map.get(c)-1);\\n            }\\n            else map.put(c, i);\\n        }\\n        return max == Integer.MIN_VALUE ? -1 : max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        Map<Character,Integer> map = new HashMap<>();\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if(map.containsKey(c))\\n            {\\n                max = Math.max(max, i-map.get(c)-1);\\n            }\\n            else map.put(c, i);\\n        }\\n        return max == Integer.MIN_VALUE ? -1 : max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007755,
                "title": "a-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxLengthBetweenEqualCharacters(s: string): number {\\n        let l = -1;\\n        s.split(\\'\\').forEach(c => l = Math.max(l, s.lastIndexOf(c) - s.indexOf(c) - 1));\\n        return l;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxLengthBetweenEqualCharacters(s: string): number {\\n        let l = -1;\\n        s.split(\\'\\').forEach(c => l = Math.max(l, s.lastIndexOf(c) - s.indexOf(c) - 1));\\n        return l;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007746,
                "title": "simple-c-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxLengthBetweenEqualCharacters(string s) {\\n        int l = -1;\\n        s.ToList().ForEach(c => l = Math.Max(l, s.LastIndexOf(c) - s.IndexOf(c) - 1));\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxLengthBetweenEqualCharacters(string s) {\\n        int l = -1;\\n        s.ToList().ForEach(c => l = Math.Max(l, s.LastIndexOf(c) - s.IndexOf(c) - 1));\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007696,
                "title": "using-split-beats-98-17-of-users-with-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        l=-1\\n        for x in set(s):\\n            _s = s.split(x)\\n            if len(_s) > 2:\\n                l = max(l, len(s) - len(_s[0]) -len(_s[-1]) -2)\\n        return l\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        l=-1\\n        for x in set(s):\\n            _s = s.split(x)\\n            if len(_s) > 2:\\n                l = max(l, len(s) - len(_s[0]) -len(_s[-1]) -2)\\n        return l\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984765,
                "title": "solved-using-bruteforce-and-optimal-way",
                "content": "# Intuition\\nThe problem asks to find longest substring between two equal chars. Hence, we need to find the index of first and last char and calculate len of substring. \\n\\n# Approach\\nThis problem can be solved using two ways. First one is very simple brute force where I use two pointers to iterate on strings and find the longest substring however it is not optimal way.\\n\\nMost of the cases, you can reduce one loop by using auxiliary space so in second approach I tried to use the arrays to store index for each char and if char found again,  use the previous and new index to update length. This way we will find the max Length.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n     return usingAuxilarySpace(s);\\n    }\\n\\n    public int usingAuxilarySpace(String s) {\\n        int maxLen = -1;\\n        int[] store = new int[26]; // Array with constant length of 26\\n        Arrays.fill(store, -1); //fill array with -1 for all not found chars\\n        \\n        for(int i = 0; i < s.length(); i++ ) {\\n            if(store[s.charAt(i) - \\'a\\'] != -1) { // check if char was previously found\\n                int len = i - store[s.charAt(i) - \\'a\\'] - 1;\\n                maxLen = Math.max(maxLen, len);\\n            } else {\\n                store[s.charAt(i) - \\'a\\'] = i; //put index of char replacing -1\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n\\n    public int usingBruteForce(String s) {\\n        int maxLen = -1;\\n\\n        for (int i = 0; i < s.length() - 1 ; i++) {\\n            for (int j = i+1; j < s.length(); j++) {\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    int len = j - i - 1; \\n                    maxLen = Math.max(maxLen, len);\\n                }\\n            }\\n        }\\n        return maxLen; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n     return usingAuxilarySpace(s);\\n    }\\n\\n    public int usingAuxilarySpace(String s) {\\n        int maxLen = -1;\\n        int[] store = new int[26]; // Array with constant length of 26\\n        Arrays.fill(store, -1); //fill array with -1 for all not found chars\\n        \\n        for(int i = 0; i < s.length(); i++ ) {\\n            if(store[s.charAt(i) - \\'a\\'] != -1) { // check if char was previously found\\n                int len = i - store[s.charAt(i) - \\'a\\'] - 1;\\n                maxLen = Math.max(maxLen, len);\\n            } else {\\n                store[s.charAt(i) - \\'a\\'] = i; //put index of char replacing -1\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n\\n    public int usingBruteForce(String s) {\\n        int maxLen = -1;\\n\\n        for (int i = 0; i < s.length() - 1 ; i++) {\\n            for (int j = i+1; j < s.length(); j++) {\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    int len = j - i - 1; \\n                    maxLen = Math.max(maxLen, len);\\n                }\\n            }\\n        }\\n        return maxLen; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983001,
                "title": "python-solution",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        maximum_diff=-1\\n        \\n        for first in range(len(s)):\\n            for second in range(len(s)-1,first,-1):\\n                if s[first]== s[second]:\\n                    maximum_diff=max(maximum_diff,second-first-1)\\n        return(maximum_diff)\\n   \\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        maximum_diff=-1\\n        \\n        for first in range(len(s)):\\n            for second in range(len(s)-1,first,-1):\\n                if s[first]== s[second]:\\n                    maximum_diff=max(maximum_diff,second-first-1)\\n        return(maximum_diff)\\n   \\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 3980255,
                "title": "simple-c-solution-utilizing-a-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question asks for the length of the longest substring between two equal characters, excluding the two characters themselves. The longest substring between two characters would be determined by the greatest distance between their occurrences within the string. Find the first occurrence and last occurrence of each and every character and determine the largest value among those.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChoose an appropriate data structure or container, such as a map or vector, based on your requirements. Utilize a map to achieve a search complexity of $O(1)$. In this container (let\\'s call it mp), store the last position of each character (i.e., ***mp[s[i]] = i***). Subsequently, iterate through the string once more. For each encountered character, retrieve its last recorded position from the mp container, calculate the difference between the current character\\'s index and its last occurrence\\'s index, and then compare this difference with the value stored in max_count. Update max_count with the larger of the two values (i.e., max_count = max(difference, max_count)). The final result will be the maximum value stored in max_count after this process.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe dominant factors contributing to the time complexity are the two loops.\\nThe other constant time operations are insignificant compared to the loops.\\nThus, the overall time complexity of the given code is $O(n)$, where \\'n\\' is the length of the input string.\\nTo summarize, the time complexity of the provided code is $O(n)$, where \\'n\\' is the length of the input string.\\n\\n- Space complexity: $ O(n) $\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity due to the integer variables (max_count and loop variables) is $O(1)$.\\nThe space complexity due to the unordered map mp is $O(n)$ in the worst case, where n is the length of the input string.\\nTherefore, the final space complexity of the code is $O(n)$ in the worst case, considering the space required for the unordered map.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int max_count = INT_MIN;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<size(s);i++) {\\n            mp[s[i]] = i;\\n        }\\n        for(int i=0;i<size(s);i++) {\\n            max_count = max(max_count, mp[s[i]]-i-1);\\n        }\\n        return max_count==INT_MIN?-1:max_count;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int max_count = INT_MIN;\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<size(s);i++) {\\n            mp[s[i]] = i;\\n        }\\n        for(int i=0;i<size(s);i++) {\\n            max_count = max(max_count, mp[s[i]]-i-1);\\n        }\\n        return max_count==INT_MIN?-1:max_count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969185,
                "title": "python-2-approaches-general-one-line-beats-90-hashmap",
                "content": "# General approach:\\n\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        d = {}\\n        maxim = -1\\n        for i, char in enumerate(s):\\n            if char in d:\\n                if i-d[char]-1 > maxim:\\n                    maxim = i-d[char]-1\\n            else:\\n                d[char] = i\\n        return maxim\\n\\n```\\n\\n# One line overcomplicated code (just for fun). Trying to update a hashmap in just one line is real hell:\\n\\n\\n```\\nreturn max(filter(lambda x: isinstance(x, int),  {i-d[char]-1 if char in d else (d.update({char:i})) for i, char in enumerate(s)}|{-1})) if (d:={0:0}) else None\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n        d = {}\\n        maxim = -1\\n        for i, char in enumerate(s):\\n            if char in d:\\n                if i-d[char]-1 > maxim:\\n                    maxim = i-d[char]-1\\n            else:\\n                d[char] = i\\n        return maxim\\n\\n```\n```\\nreturn max(filter(lambda x: isinstance(x, int),  {i-d[char]-1 if char in d else (d.update({char:i})) for i, char in enumerate(s)}|{-1})) if (d:={0:0}) else None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942587,
                "title": "chebrolu-s-short-and-clean-c-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRephrase the question. It can be told as if \" which two simliar characters are farthest apart in the string \".\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Take a map and add the entries of new characters into it\\n- If an entry exists, then we have a possible substring between them so find out the number of characters between them and update the maxSubStringLength.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        \\n        unordered_map <char,int> characterOccurance;\\n\\n        int maxSubstringLength = -1;\\n\\n        for( int i=0; i<s.size() ; i++) {\\n            if ( characterOccurance.find(s[i]) == characterOccurance.end() ) {\\n                characterOccurance[s[i]] = i;\\n            } \\n            else {\\n                maxSubstringLength = max(maxSubstringLength,i - characterOccurance[s[i]] -1);\\n            }\\n        }\\n\\n        return maxSubstringLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        \\n        unordered_map <char,int> characterOccurance;\\n\\n        int maxSubstringLength = -1;\\n\\n        for( int i=0; i<s.size() ; i++) {\\n            if ( characterOccurance.find(s[i]) == characterOccurance.end() ) {\\n                characterOccurance[s[i]] = i;\\n            } \\n            else {\\n                maxSubstringLength = max(maxSubstringLength,i - characterOccurance[s[i]] -1);\\n            }\\n        }\\n\\n        return maxSubstringLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928827,
                "title": "beats-96-with-a-linear-tm-and-constant-memory-complexity-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n\\n        temp_size=0\\n        final_size=-1\\n        \\n        my_dict={}\\n        for i , nm in enumerate(s):\\n            if nm in my_dict:\\n                temp_size=i-my_dict[nm] -1\\n                final_size=max(temp_size, final_size)\\n            else:\\n                my_dict[nm]=i\\n\\n        return final_size\\n\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\\n\\n        temp_size=0\\n        final_size=-1\\n        \\n        my_dict={}\\n        for i , nm in enumerate(s):\\n            if nm in my_dict:\\n                temp_size=i-my_dict[nm] -1\\n                final_size=max(temp_size, final_size)\\n            else:\\n                my_dict[nm]=i\\n\\n        return final_size\\n\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927597,
                "title": "simple-intuitive-o-n-python-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\nJust save the letter index. That\\'s all\\n\\n# Code\\n```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        dic = {}\\n        for i in range(len(s)):\\n            if s[i] not in dic: dic[s[i]] = []\\n            dic[s[i]].append(i)\\n        \\n        answer = -1\\n        for letter in dic:\\n            if len(dic[letter]) > 1:\\n                start, end = dic[letter][0], dic[letter][-1]\\n                count = end - start - 1\\n                answer = max(answer, count)\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxLengthBetweenEqualCharacters(self, s):\\n        dic = {}\\n        for i in range(len(s)):\\n            if s[i] not in dic: dic[s[i]] = []\\n            dic[s[i]].append(i)\\n        \\n        answer = -1\\n        for letter in dic:\\n            if len(dic[letter]) > 1:\\n                start, end = dic[letter][0], dic[letter][-1]\\n                count = end - start - 1\\n                answer = max(answer, count)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927372,
                "title": "java-solution-simple-100-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        \\n        int [] arr = new int[26];\\n\\n    for(int i=0; i<arr.length; i++){\\n        int i1=s.indexOf(i+\\'a\\');\\n        int i2=s.lastIndexOf(i+\\'a\\');\\n        if(i1 != -1 && i1 != i2)\\n            arr[i]=i2-i1;\\n        } \\n\\n        int a=0;\\n        for(int i=0; i<26; i++)\\n          a=Math.max(a,arr[i]);\\n    \\n         \\n\\n\\n         return a-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        \\n        int [] arr = new int[26];\\n\\n    for(int i=0; i<arr.length; i++){\\n        int i1=s.indexOf(i+\\'a\\');\\n        int i2=s.lastIndexOf(i+\\'a\\');\\n        if(i1 != -1 && i1 != i2)\\n            arr[i]=i2-i1;\\n        } \\n\\n        int a=0;\\n        for(int i=0; i<26; i++)\\n          a=Math.max(a,arr[i]);\\n    \\n         \\n\\n\\n         return a-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574689,
                "content": [
                    {
                        "username": "mchen2",
                        "content": "Can we? --Seriously asking\\nIf can\\'t, why not?"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Find a way to store the indexes of the same characters and you\\'re good to go"
                    }
                ]
            },
            {
                "id": 2050632,
                "content": [
                    {
                        "username": "mchen2",
                        "content": "Can we? --Seriously asking\\nIf can\\'t, why not?"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Find a way to store the indexes of the same characters and you\\'re good to go"
                    }
                ]
            }
        ]
    },
    {
        "title": "Lexicographically Smallest String After Applying Operations",
        "question_content": "<p>You are given a string <code>s</code> of <strong>even length</strong> consisting of digits from <code>0</code> to <code>9</code>, and two integers <code>a</code> and <code>b</code>.</p>\n\n<p>You can apply either of the following two operations any number of times and in any order on <code>s</code>:</p>\n\n<ul>\n\t<li>Add <code>a</code> to all odd indices of <code>s</code> <strong>(0-indexed)</strong>. Digits post <code>9</code> are cycled back to <code>0</code>. For example, if <code>s = &quot;3456&quot;</code> and <code>a = 5</code>, <code>s</code> becomes <code>&quot;3951&quot;</code>.</li>\n\t<li>Rotate <code>s</code> to the right by <code>b</code> positions. For example, if <code>s = &quot;3456&quot;</code> and <code>b = 1</code>, <code>s</code> becomes <code>&quot;6345&quot;</code>.</li>\n</ul>\n\n<p>Return <em>the <strong>lexicographically smallest</strong> string you can obtain by applying the above operations any number of times on</em> <code>s</code>.</p>\n\n<p>A string <code>a</code> is lexicographically smaller than a string <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, string <code>a</code> has a letter that appears earlier in the alphabet than the corresponding letter in <code>b</code>. For example, <code>&quot;0158&quot;</code> is lexicographically smaller than <code>&quot;0190&quot;</code> because the first position they differ is at the third letter, and <code>&#39;5&#39;</code> comes before <code>&#39;9&#39;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;5525&quot;, a = 9, b = 2\n<strong>Output:</strong> &quot;2050&quot;\n<strong>Explanation:</strong> We can apply the following operations:\nStart:  &quot;5525&quot;\nRotate: &quot;2555&quot;\nAdd:    &quot;2454&quot;\nAdd:    &quot;2353&quot;\nRotate: &quot;5323&quot;\nAdd:    &quot;5222&quot;\nAdd:    &quot;5121&quot;\nRotate: &quot;2151&quot;\nAdd:    &quot;2050&quot;\nThere is no way to obtain a string that is lexicographically smaller than &quot;2050&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;74&quot;, a = 5, b = 1\n<strong>Output:</strong> &quot;24&quot;\n<strong>Explanation:</strong> We can apply the following operations:\nStart:  &quot;74&quot;\nRotate: &quot;47&quot;\nAdd:    &quot;42&quot;\nRotate: &quot;24&quot;\nThere is no way to obtain a string that is lexicographically smaller than &quot;24&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0011&quot;, a = 4, b = 2\n<strong>Output:</strong> &quot;0011&quot;\n<strong>Explanation:</strong> There are no sequence of operations that will give us a lexicographically smaller string than &quot;0011&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s.length</code> is even.</li>\n\t<li><code>s</code> consists of digits from <code>0</code> to <code>9</code> only.</li>\n\t<li><code>1 &lt;= a &lt;= 9</code></li>\n\t<li><code>1 &lt;= b &lt;= s.length - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 899489,
                "title": "basic-dfs-brute-force-this-kind-of-questions-dfs",
                "content": "Basic DFS - Brute force\\n\\nFor each string, just try rotate as well as add operations. It is possible that you had thoght that the brute force approach wouldn\\'t work, doing some calculations really help in this case to prove whether it will work or not.\\n\\n**Thanks!**\\nPlease upvote if the code helps! It encourages a lot...\\n\\n```\\n\\nclass Solution {\\n    unordered_set<string> visited;\\n    string ans;\\n    int a, b;\\n    int n;\\n    \\n    bool isVisited(string s) {\\n        return visited.find(s) != visited.end();\\n    }\\n    \\n    void visit(string s) {\\n        ans = min(ans, s);\\n        visited.insert(s);\\n    }\\n    \\n    string rotate(string s, int x) {\\n        reverse(s.begin(), s.end());\\n        reverse(s.begin(), s.begin()+x);\\n        reverse(s.begin()+x, s.end());\\n        return s;\\n    }\\n    \\n    string add(string s, int x) {\\n        for (int i=1; i<n; i += 2) {\\n            char &c = s[i];\\n            c = \\'0\\' + (c-\\'0\\'+x)%10;\\n        }\\n        return s;\\n    }\\n    \\n\\npublic:\\n    \\n    void dfs(string s) {\\n        if (isVisited(s)) {\\n            return ;\\n        }\\n        visit(s);\\n        dfs(rotate(s, b));\\n        dfs(add(s, a));\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        ans = s;\\n        this->a = a;\\n        this->b = b;\\n        n = s.size();\\n        dfs(s);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Some of my other posts**\\n1. Leetcode 1627: https://leetcode.com/problems/graph-connectivity-with-threshold/discuss/899462\\n2. Leetcode 1626: https://leetcode.com/problems/best-team-with-no-conflicts/discuss/899475\\n3. Leetcode 1625: https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/discuss/899489\\n4. Leetcode 1600: https://leetcode.com/problems/throne-inheritance/discuss/866400\\n5. Leetcode 1599: https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/discuss/866375\\n6. Leetcode 1584: https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/844270\\n7. Leetcode 1583: https://leetcode.com/problems/count-unhappy-friends/discuss/843928\\n8. Leetcode 1579: https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/discuss/831506\\n9. Leetcode 1578: https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/discuss/831533\\n10. Leetcode 1577: https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831548\\n11. Leetcode 1553: https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794075\\n12. Leetcode 1545: https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/781105\\n13. Leetcode 1536: https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/768076\\n14. Leetcode 1535: https://leetcode.com/problems/find-the-winner-of-an-array-game/discuss/767958\\n15. Leetcode 1534: https://leetcode.com/problems/count-good-triplets/discuss/768170\\n16. Leetcode 1529: https://leetcode.com/problems/bulb-switcher-iv/discuss/755939\\n17. Leetcode 1503: https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/discuss/720313\\n18. Leetcode 1488: https://leetcode.com/problems/avoid-flood-in-the-city/discuss/697687\\n19. Leetcode 1487: https://leetcode.com/problems/making-file-names-unique/discuss/719962\\n20. Leetcode 1472: https://leetcode.com/problems/design-browser-history/discuss/674486\\n21. Leetcode 1471: https://leetcode.com/problems/the-k-strongest-values-in-an-array/discuss/674346\\n22. Leetcode 1466: https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/discuss/661710\\n23. Leetcode 1465: https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/discuss/661995\\n24. Leetcode 1458: https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/648528\\n25. Leetcode 1443: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/623673\\n26. Leetcode 1436: https://leetcode.com/problems/destination-city/discuss/609874\\n27. Leetcode 1424: https://leetcode.com/problems/diagonal-traverse-ii/discuss/597741\\n28. Leetcode 1423: https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/discuss/597825\\n29. Leetcode 1419: https://leetcode.com/problems/minimum-number-of-frogs-croaking/discuss/586653",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    unordered_set<string> visited;\\n    string ans;\\n    int a, b;\\n    int n;\\n    \\n    bool isVisited(string s) {\\n        return visited.find(s) != visited.end();\\n    }\\n    \\n    void visit(string s) {\\n        ans = min(ans, s);\\n        visited.insert(s);\\n    }\\n    \\n    string rotate(string s, int x) {\\n        reverse(s.begin(), s.end());\\n        reverse(s.begin(), s.begin()+x);\\n        reverse(s.begin()+x, s.end());\\n        return s;\\n    }\\n    \\n    string add(string s, int x) {\\n        for (int i=1; i<n; i += 2) {\\n            char &c = s[i];\\n            c = \\'0\\' + (c-\\'0\\'+x)%10;\\n        }\\n        return s;\\n    }\\n    \\n\\npublic:\\n    \\n    void dfs(string s) {\\n        if (isVisited(s)) {\\n            return ;\\n        }\\n        visit(s);\\n        dfs(rotate(s, b));\\n        dfs(add(s, a));\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        ans = s;\\n        this->a = a;\\n        this->b = b;\\n        n = s.size();\\n        dfs(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899511,
                "title": "java-python-3-bfs-and-dfs-w-brief-explanation-and-analysis",
                "content": "**Method 1: BFS**\\n\\n**Q & A:**\\n\\nQ1: When does the queue becomes empty? I mean, how can we be sure that the BFS dosen\\'t go into infinite loop?\\nA1: When all possible strings that created after operations have already been in the set `seen`, no string can be put into queue any more; After that, the queue will deplete sooner or later.\\nSince the input string `s` has limited size and each digit has at most 10 options, there are finite strings created during the whole BFS.\\n\\nQ2:  Why this solution works?\\nA2: BFS traverse all possible strings and update the smallest string whenever polling out a string from the Queue. Therefore, the algorithm guarantees to output correct solution.\\n\\n**End of Q & A**\\n\\n\\n----\\n\\n\\n1. Use a `Queue` / `deque` to hold the strings after applying operations;\\n2. Use a `Set` to avoid duplication;\\n3. During BFS, for each polled out string, compare it to the currently smallest string and update the smallest  if necessary; apply the 2 operations and put the resulted 2 strings into the `Queue` / `deque` if never seen them before;\\n4. The smallest string found after BFS is the solution.\\n\\n```java\\n    public String findLexSmallestString(String s, int a, int b) {\\n        int n = s.length();\\n        String smallest = s;\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(s);\\n        Set<String> seen = new HashSet<>(q);\\n        while (!q.isEmpty()) {\\n            String cur = q.poll();\\n            if (smallest.compareTo(cur) > 0)\\n                smallest = cur;\\n            char[] ca = cur.toCharArray();\\n            for (int i = 1; i < ca.length; i += 2) // add operation.\\n                ca[i] = (char)((ca[i] - \\'0\\' + a) % 10 + \\'0\\');\\n            String addA = String.valueOf(ca);\\n            if (seen.add(addA))\\n                q.offer(addA);\\n            String rotate = cur.substring(n - b) + cur.substring(0, n - b); // rotation.\\n            if (seen.add(rotate))\\n                q.offer(rotate);\\n        }\\n        return smallest;\\n    }\\n```\\n```python\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        dq, seen, smallest = deque([s]), {s}, s\\n        while dq:\\n            cur = dq.popleft()\\n            if smallest > cur:\\n                smallest = cur\\n            addA = list(cur)    \\n            for i, c in enumerate(addA):\\n                if i % 2 == 1:\\n                    addA[i] = str((int(c) + a) % 10)\\n            addA = \\'\\'.join(addA)        \\n            if addA not in seen:\\n                seen.add(addA);\\n                dq.append(addA)\\n            rotate = cur[-b :] + cur[: -b]\\n            if rotate not in seen:\\n                seen.add(rotate)\\n                dq.append(rotate)\\n        return smallest\\n```\\nIn case you you prefer `list` to `deque`, here  is the `list` version:\\n```python\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        q, seen, smallest = [s], {s}, s\\n        while q:\\n            new_q = []\\n            for cur in q:\\n                if smallest > cur:\\n                    smallest = cur\\n                addA = list(cur)    \\n                for i, c in enumerate(addA):\\n                    if i % 2 == 1:\\n                        addA[i] = str((int(c) + a) % 10)\\n                addA = \\'\\'.join(addA)        \\n                if addA not in seen:\\n                    seen.add(addA);\\n                    new_q.append(addA)\\n                rotate = cur[-b :] + cur[: -b]\\n                if rotate not in seen:\\n                    seen.add(rotate)\\n                    new_q.append(rotate)\\n            q = new_q    \\n        return smallest\\n```\\n----\\n\\n**Method 2: DFS**\\n\\nThe follows are two variants of DFS, use whichever you are comfortable with.\\n\\nThe ideas behind the codes are similar: \\n1. Use a set to avoid duplications, and \\n2. Starting from input string, apply the two operations; for each created string, compare it with the previous string to update the smallest string; recurse and repeat the procedure till all possible created strings have been visited.\\n\\n\\n\\nvoid/None return type of `dfs()` method\\n\\n```java\\n    private String smallest;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        smallest = s;\\n        dfs(s, a, b, new HashSet<>());\\n        return smallest;\\n    }\\n    private void dfs(String s, int a, int b, Set<String> seen) {\\n        if (seen.add(s)) {\\n            if (smallest.compareTo(s) > 0) {\\n                smallest = s;\\n            }\\n            char[] ca = s.toCharArray();\\n            for (int i = 1; i < ca.length; i += 2) {\\n                ca[i] = (char)((ca[i] - \\'0\\' + a) % 10 + \\'0\\');\\n            }\\n            dfs(String.valueOf(ca), a, b, seen);\\n            dfs(s.substring(b) + s.substring(0, b), a, b, seen);\\n        }\\n    }\\n```\\n```python\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        \\n        def dfs(s: str) -> None:\\n            if s not in seen:\\n                seen.add(s)\\n                self.smallest = min(s, self.smallest)\\n                addA = list(s)\\n                for i, c in enumerate(addA):\\n                    if i % 2 == 1:\\n                        addA[i] = str((int(c) + a) % 10)\\n                dfs(\\'\\'.join(addA))\\n                dfs(s[b :] + s[: b])\\n                \\n        self.smallest = s\\n        seen = set()\\n        dfs(s)\\n        return self.smallest\\n```\\nString return type of `dfs()` method:\\n\\n```java\\n    public String findLexSmallestString(String s, int a, int b) {\\n        return dfs(s, a, b, new HashSet<>());\\n    }\\n    private String dfs(String s, int a, int b, Set<String> seen) {\\n        String smallest = s;\\n        if (seen.add(s)) {\\n            char[] ca = s.toCharArray();\\n            for (int i = 1; i < ca.length; i += 2) {\\n                ca[i] = (char)((ca[i] - \\'0\\' + a) % 10 + \\'0\\');\\n            }\\n            String addA = dfs(String.valueOf(ca), a, b, seen);\\n            String rotate = dfs(s.substring(b) + s.substring(0, b), a, b, seen);\\n            for (String candidate : new String[]{addA, rotate}) {\\n                if (smallest.compareTo(candidate) > 0) {\\n                    smallest = candidate;\\n                }\\n            }\\n        }\\n        return smallest;\\n    }\\n```\\n```python\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        \\n        def dfs(s: str) -> str:\\n            if s not in seen:\\n                seen.add(s)\\n                addA = list(s)\\n                for i, c in enumerate(addA):\\n                    if i % 2 == 1:\\n                        addA[i] = str((int(c) + a) % 10)\\n                return min(s, dfs(\\'\\'.join(addA)), dfs(s[b :] + s[: b]))\\n            return s    \\n                \\n        seen = set()\\n        return dfs(s)\\n```\\n\\n----\\n\\n\\n**Analysis:**\\n\\n1. Without rotation, in worst case we have 10 strings due to \"add a\" operation;\\n2. With rotations, for each string in step 1, in worst case we can have `n` new strings, where `n = s.length()`;\\n3. For each string in step 2, if `b` is odd, in worst case we can create 10 strings due to \"add a\" operation; (Note: if `b` is even, then no new strings can be created during this step.)\\n\\nCombine the above 3 steps, the time and space cost `10 * n * 10`; Therefore, the complexities are as follows:-\\n\\nTime & space: `O(n * base ^ 2)`, where `n = s.length()`, base = 10.",
                "solutionTags": [],
                "code": "```java\\n    public String findLexSmallestString(String s, int a, int b) {\\n        int n = s.length();\\n        String smallest = s;\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(s);\\n        Set<String> seen = new HashSet<>(q);\\n        while (!q.isEmpty()) {\\n            String cur = q.poll();\\n            if (smallest.compareTo(cur) > 0)\\n                smallest = cur;\\n            char[] ca = cur.toCharArray();\\n            for (int i = 1; i < ca.length; i += 2) // add operation.\\n                ca[i] = (char)((ca[i] - \\'0\\' + a) % 10 + \\'0\\');\\n            String addA = String.valueOf(ca);\\n            if (seen.add(addA))\\n                q.offer(addA);\\n            String rotate = cur.substring(n - b) + cur.substring(0, n - b); // rotation.\\n            if (seen.add(rotate))\\n                q.offer(rotate);\\n        }\\n        return smallest;\\n    }\\n```\n```python\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        dq, seen, smallest = deque([s]), {s}, s\\n        while dq:\\n            cur = dq.popleft()\\n            if smallest > cur:\\n                smallest = cur\\n            addA = list(cur)    \\n            for i, c in enumerate(addA):\\n                if i % 2 == 1:\\n                    addA[i] = str((int(c) + a) % 10)\\n            addA = \\'\\'.join(addA)        \\n            if addA not in seen:\\n                seen.add(addA);\\n                dq.append(addA)\\n            rotate = cur[-b :] + cur[: -b]\\n            if rotate not in seen:\\n                seen.add(rotate)\\n                dq.append(rotate)\\n        return smallest\\n```\n```python\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        q, seen, smallest = [s], {s}, s\\n        while q:\\n            new_q = []\\n            for cur in q:\\n                if smallest > cur:\\n                    smallest = cur\\n                addA = list(cur)    \\n                for i, c in enumerate(addA):\\n                    if i % 2 == 1:\\n                        addA[i] = str((int(c) + a) % 10)\\n                addA = \\'\\'.join(addA)        \\n                if addA not in seen:\\n                    seen.add(addA);\\n                    new_q.append(addA)\\n                rotate = cur[-b :] + cur[: -b]\\n                if rotate not in seen:\\n                    seen.add(rotate)\\n                    new_q.append(rotate)\\n            q = new_q    \\n        return smallest\\n```\n```java\\n    private String smallest;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        smallest = s;\\n        dfs(s, a, b, new HashSet<>());\\n        return smallest;\\n    }\\n    private void dfs(String s, int a, int b, Set<String> seen) {\\n        if (seen.add(s)) {\\n            if (smallest.compareTo(s) > 0) {\\n                smallest = s;\\n            }\\n            char[] ca = s.toCharArray();\\n            for (int i = 1; i < ca.length; i += 2) {\\n                ca[i] = (char)((ca[i] - \\'0\\' + a) % 10 + \\'0\\');\\n            }\\n            dfs(String.valueOf(ca), a, b, seen);\\n            dfs(s.substring(b) + s.substring(0, b), a, b, seen);\\n        }\\n    }\\n```\n```python\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        \\n        def dfs(s: str) -> None:\\n            if s not in seen:\\n                seen.add(s)\\n                self.smallest = min(s, self.smallest)\\n                addA = list(s)\\n                for i, c in enumerate(addA):\\n                    if i % 2 == 1:\\n                        addA[i] = str((int(c) + a) % 10)\\n                dfs(\\'\\'.join(addA))\\n                dfs(s[b :] + s[: b])\\n                \\n        self.smallest = s\\n        seen = set()\\n        dfs(s)\\n        return self.smallest\\n```\n```java\\n    public String findLexSmallestString(String s, int a, int b) {\\n        return dfs(s, a, b, new HashSet<>());\\n    }\\n    private String dfs(String s, int a, int b, Set<String> seen) {\\n        String smallest = s;\\n        if (seen.add(s)) {\\n            char[] ca = s.toCharArray();\\n            for (int i = 1; i < ca.length; i += 2) {\\n                ca[i] = (char)((ca[i] - \\'0\\' + a) % 10 + \\'0\\');\\n            }\\n            String addA = dfs(String.valueOf(ca), a, b, seen);\\n            String rotate = dfs(s.substring(b) + s.substring(0, b), a, b, seen);\\n            for (String candidate : new String[]{addA, rotate}) {\\n                if (smallest.compareTo(candidate) > 0) {\\n                    smallest = candidate;\\n                }\\n            }\\n        }\\n        return smallest;\\n    }\\n```\n```python\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        \\n        def dfs(s: str) -> str:\\n            if s not in seen:\\n                seen.add(s)\\n                addA = list(s)\\n                for i, c in enumerate(addA):\\n                    if i % 2 == 1:\\n                        addA[i] = str((int(c) + a) % 10)\\n                return min(s, dfs(\\'\\'.join(addA)), dfs(s[b :] + s[: b]))\\n            return s    \\n                \\n        seen = set()\\n        return dfs(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 899471,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        # add and rotate function\\n        def add(s,a):\\n            new = \"\"\\n            for i in range(len(s)):\\n                if i % 2 != 0:\\n                    new += str(int(s[i])+a)[-1]\\n                else:\\n                    new += s[i]\\n            return new\\n        \\n        def rotate(s,b):\\n            return s[len(s)-b:]+s[:len(s)-b] \\n        \\n        # Perform search         \\n        seen = set()\\n        need = list()\\n        need.append(s)\\n\\n        while need:\\n            curr = need.pop()\\n            if curr not in seen:\\n                # add current string to seen                 \\n                seen.add(curr)\\n                # add next two cases into waiting queue\\n                need.extend([add(curr,a),rotate(curr,b)])\\n                \\n        # select smallest string from all possible cases        \\n        return min(seen)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        # add and rotate function\\n        def add(s,a):\\n            new = \"\"\\n            for i in range(len(s)):\\n                if i % 2 != 0:\\n                    new += str(int(s[i])+a)[-1]\\n                else:\\n                    new += s[i]\\n            return new\\n        \\n        def rotate(s,b):\\n            return s[len(s)-b:]+s[:len(s)-b] \\n        \\n        # Perform search         \\n        seen = set()\\n        need = list()\\n        need.append(s)\\n\\n        while need:\\n            curr = need.pop()\\n            if curr not in seen:\\n                # add current string to seen                 \\n                seen.add(curr)\\n                # add next two cases into waiting queue\\n                need.extend([add(curr,a),rotate(curr,b)])\\n                \\n        # select smallest string from all possible cases        \\n        return min(seen)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 899708,
                "title": "proof-group-theory-java-14ms-100-optimal-o-n-2-time-o-n-space",
                "content": "The idea is simply to find all possibilities and compare them one by one. However, the difficulty of tracking all possibilities is that (1) and (2) operations occur randomly, so we want to group the same operations together to fix their order, and hence easily loop over the number of each kind of operations.\\n\\nOperations:\\n(1) Add `a` to all *odd* indices of `s` (0-indexed, even length).\\n(2) Rotate `s` to the right by `b` positions.\\n\\nAny possibility can be written as a composition of (1) and/or (2). For example, say `s = \"1234\"`, `a = 3`, `b = 1`. Then (1)(1) is `\"1830\"`, (2)(1)(2) is `\"6442\"`, etc., and `s` itself is just 0 time of either operation.\\n\\nFirstly, please note that both (1) and (2) are cyclic. That is, doing 10 times of (1) goes back to the original `s`; and so is doing `s.length` times of (2).\\n\\nMathematically, (1) and (2) form a group. In fact, the periods can be further optimized by considering the order of (1) and (2):\\n|(1)| = 10 / gcd(10, a), and\\n|(2)| = s.length / gcd(s.length, b).\\n\\n-----\\n\\n**If `b` is even**, then the two operations are commutative (abelian), i.e. (1)(2) = (2)(1).\\n\\nWe move all (2) to the end, so every possibility can be written as (1)...(1)(2)...(2).\\n\\nTherefore, we are able to loop the number of (1) then loop the number of (2), to iterate all possibilities.\\n\\nTime complexity: O(|(1)|\\\\*|(2)|) \\\\* O(`s.length`) \\u2264 O(10\\\\*`s.length`^2).\\nThe second term O(`s.length`) is the cost of comparison.\\n\\n-----\\n\\n**If `b` is odd**, (1)(2) \\u2260 (2)(1). We introduce a helper operation:\\n\\n(3) Add `a` to all *even* indices of `s`.\\n\\n(3) is already in the group because (3) = (2)^(-1)\\xB7(1)\\xB7(2), where (2)^(-1) denotes the inverse of (2). With transposition, we have (2)(1) = (3)(2) and (2)(3) = (1)(2). Besides, note that (1) and (3) are commutative, i.e. (1)(3) = (3)(1), and |(3)| = |(1)| as well.\\n\\nSuch being the case, any possibility can be expressed as (1)...(1)(3)...(3)(2)...(2).\\n\\nLikewise, we nest 3 loops to iterate all possibilities.\\n\\nTime complexity: O(|(1)|\\\\*|(3)|\\\\*|(2)|) \\\\* O(`s.length`) \\u2264 O(100\\\\*`s.length`^2).\\n\\n-----\\n\\n##### Java Solution\\n\\nSpace complexity: O(s.length)\\n\\n```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        String ans = s;\\n        int aCycle = 10 / gcd(10, a);\\n        int bCycle = s.length() / gcd(s.length(), b);\\n        \\n        String curS = s;\\n        if (b % 2 == 0) {  // b is even\\n            for (int i = 1; i <= aCycle; i++) {\\n                curS = oddAddA(curS, a);\\n                for (int j = 1; j <= bCycle; j++) {\\n                    curS = rotateB(curS, b);\\n                    if (curS.compareTo(ans) < 0) {\\n                        ans = curS;\\n                    }\\n                }\\n            }\\n        } else {  // b is odd\\n            for (int i = 1; i <= aCycle; i++) {\\n                curS = oddAddA(curS, a);\\n                for (int k = 1; k <= aCycle; k++) {\\n                    curS = evenAddA(curS, a);\\n                    for (int j = 1; j <= bCycle; j++) {\\n                        curS = rotateB(curS, b);\\n                        if (curS.compareTo(ans) < 0) {\\n                            ans = curS;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t/** Operation (1) */\\n    private String oddAddA(String s, int a) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for (int i = 1; i < s.length(); i += 2) {\\n            sb.replace(i, i + 1, Integer.toString((s.charAt(i) - \\'0\\' + a) % 10));\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n\\t/** Operation (3) */\\n    private String evenAddA(String s, int a) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for (int i = 0; i < s.length(); i += 2) {\\n            sb.replace(i, i + 1, Integer.toString((s.charAt(i) - \\'0\\' + a) % 10));\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\t/** Operation (2) */\\n    private String rotateB(String s, int b) {\\n        return s.substring(b, s.length()) + s.substring(0, b);\\n    }\\n\\n    private int gcd(int x, int y) {\\n        if (x % y == 0) {\\n            return y;\\n        } else {\\n            return gcd(y, x % y);\\n        }\\n    }\\n}\\n```\\n\\n<img alt=\"Java Solution Submission Details\" width=450 src=https://assets.leetcode.com/users/images/aabaa50a-2d58-4b4a-b7b5-687e2172cbe9_1603004066.405815.png>\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        String ans = s;\\n        int aCycle = 10 / gcd(10, a);\\n        int bCycle = s.length() / gcd(s.length(), b);\\n        \\n        String curS = s;\\n        if (b % 2 == 0) {  // b is even\\n            for (int i = 1; i <= aCycle; i++) {\\n                curS = oddAddA(curS, a);\\n                for (int j = 1; j <= bCycle; j++) {\\n                    curS = rotateB(curS, b);\\n                    if (curS.compareTo(ans) < 0) {\\n                        ans = curS;\\n                    }\\n                }\\n            }\\n        } else {  // b is odd\\n            for (int i = 1; i <= aCycle; i++) {\\n                curS = oddAddA(curS, a);\\n                for (int k = 1; k <= aCycle; k++) {\\n                    curS = evenAddA(curS, a);\\n                    for (int j = 1; j <= bCycle; j++) {\\n                        curS = rotateB(curS, b);\\n                        if (curS.compareTo(ans) < 0) {\\n                            ans = curS;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t/** Operation (1) */\\n    private String oddAddA(String s, int a) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for (int i = 1; i < s.length(); i += 2) {\\n            sb.replace(i, i + 1, Integer.toString((s.charAt(i) - \\'0\\' + a) % 10));\\n        }\\n        return sb.toString();\\n    }\\n\\t\\n\\t/** Operation (3) */\\n    private String evenAddA(String s, int a) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for (int i = 0; i < s.length(); i += 2) {\\n            sb.replace(i, i + 1, Integer.toString((s.charAt(i) - \\'0\\' + a) % 10));\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\t/** Operation (2) */\\n    private String rotateB(String s, int b) {\\n        return s.substring(b, s.length()) + s.substring(0, b);\\n    }\\n\\n    private int gcd(int x, int y) {\\n        if (x % y == 0) {\\n            return y;\\n        } else {\\n            return gcd(y, x % y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899520,
                "title": "java-simple-solution-100",
                "content": "```\\nclass Solution {\\n    Set<String> set;\\n    String smallest;\\n    \\n    public String findLexSmallestString(String s, int a, int b) {\\n        set = new HashSet<>();    \\n        smallest = s;\\n        \\n        helper(s, a, b);\\n        \\n        return smallest;\\n    }\\n    \\n    void helper(String s, int a, int b) {\\n        if(set.contains(s)) {\\n            return;\\n        }\\n        \\n        if(s.compareTo(smallest) < 0) {\\n            smallest = s;\\n        }\\n        \\n        set.add(s);\\n        \\n        helper(rotate(s, b), a, b);\\n        helper(add(s, a), a, b);\\n    }\\n    \\n    String rotate(String s, int pos) {\\n        int len = s.length() - pos;\\n        return s.substring(len) + s.substring(0, len);\\n    }\\n    \\n    String add(String s, int a) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(i % 2 == 1) {\\n                int sum = ((c-\\'0\\') + a) % 10;\\n                c = (char) (sum + 48);\\n            }\\n            sb.append(c);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<String> set;\\n    String smallest;\\n    \\n    public String findLexSmallestString(String s, int a, int b) {\\n        set = new HashSet<>();    \\n        smallest = s;\\n        \\n        helper(s, a, b);\\n        \\n        return smallest;\\n    }\\n    \\n    void helper(String s, int a, int b) {\\n        if(set.contains(s)) {\\n            return;\\n        }\\n        \\n        if(s.compareTo(smallest) < 0) {\\n            smallest = s;\\n        }\\n        \\n        set.add(s);\\n        \\n        helper(rotate(s, b), a, b);\\n        helper(add(s, a), a, b);\\n    }\\n    \\n    String rotate(String s, int pos) {\\n        int len = s.length() - pos;\\n        return s.substring(len) + s.substring(0, len);\\n    }\\n    \\n    String add(String s, int a) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(i % 2 == 1) {\\n                int sum = ((c-\\'0\\') + a) % 10;\\n                c = (char) (sum + 48);\\n            }\\n            sb.append(c);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899735,
                "title": "c-o-n-2",
                "content": "This one is such a grim problem... I felt it\\'s the most complicated problem in the contest.\\n\\n> I am wondering if O(n) could be possible, e.g. with Booth\\'s algorithm. \\n\\nIf `b` is even, we only can modify digits in the even positions (odd will remain odd after the shift). So, we need to inspect up to `10` variations of our string, each shifted up to `n` times, where `n` is the size of the string. For each shift, we compare up to `n` elements.\\n\\nIf `b` is odd, we need to check up to `100` variations: 10 odd * 10 even, each shifted up to `n` times.\\n\\nFor the complexity analysis, both `10` and `100`are constant, leaving us with checking up to `n` rotations - O(n ^ 2).\\n\\n```cpp\\nbool less(string &s, int i, int j) {\\n    for (auto k = 0; k < s.size(); ++k) {\\n        if (s[(k + i) % s.size()] != s[(k + j) % s.size()])\\n            return s[(k + i) % s.size()] < s[(k + j) % s.size()];\\n    }\\n    return false;\\n}\\nstring findLexSmallestString(string s, int a, int b) {\\n    string res = s;\\n    bool odd[10] = {};\\n    while (odd[s[0] - \\'0\\'] == false) {\\n        odd[s[0] - \\'0\\'] = true;\\n        bool even[10] = {};\\n        while (even[s[1] - \\'0\\'] == false) {\\n            even[s[1] - \\'0\\'] = true;\\n            int best_r = 0;\\n            vector<bool> rotate(s.size());\\n            for (int r = b; !rotate[r]; r = (r + b) % s.size()) {\\n                rotate[r] = true;\\n                if (less(s, r, best_r))\\n                    best_r = r;\\n            }\\n            res = min(res, s.substr(best_r) + s.substr(0, best_r));                \\n            for (int k = 1; k < s.size(); k += 2)\\n                s[k] = \\'0\\' + (s[k] - \\'0\\' + a) % 10;\\n        }\\n        if (b % 2) {\\n            for (int k = 0; k < s.size(); k += 2)\\n                s[k] = \\'0\\' + (s[k] - \\'0\\' + a) % 10;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool less(string &s, int i, int j) {\\n    for (auto k = 0; k < s.size(); ++k) {\\n        if (s[(k + i) % s.size()] != s[(k + j) % s.size()])\\n            return s[(k + i) % s.size()] < s[(k + j) % s.size()];\\n    }\\n    return false;\\n}\\nstring findLexSmallestString(string s, int a, int b) {\\n    string res = s;\\n    bool odd[10] = {};\\n    while (odd[s[0] - \\'0\\'] == false) {\\n        odd[s[0] - \\'0\\'] = true;\\n        bool even[10] = {};\\n        while (even[s[1] - \\'0\\'] == false) {\\n            even[s[1] - \\'0\\'] = true;\\n            int best_r = 0;\\n            vector<bool> rotate(s.size());\\n            for (int r = b; !rotate[r]; r = (r + b) % s.size()) {\\n                rotate[r] = true;\\n                if (less(s, r, best_r))\\n                    best_r = r;\\n            }\\n            res = min(res, s.substr(best_r) + s.substr(0, best_r));                \\n            for (int k = 1; k < s.size(); k += 2)\\n                s[k] = \\'0\\' + (s[k] - \\'0\\' + a) % 10;\\n        }\\n        if (b % 2) {\\n            for (int k = 0; k < s.size(); k += 2)\\n                s[k] = \\'0\\' + (s[k] - \\'0\\' + a) % 10;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899635,
                "title": "python-solution",
                "content": "DFS:\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        rec = set()\\n        \\n        def dfs(s):\\n            if s in rec:\\n                return           \\n            rec.add(s)\\n            dfs(s[-b:] + s[:-b])\\n            dfs(\"\".join([str((int(c) + a * (i % 2)) % 10) for i, c in enumerate(s)]))\\n            \\n        dfs(s)\\n        return min(rec)\\n```\\n\\nBFS:\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        q = collections.deque([s])\\n        rec = set([s])\\n        while q:\\n            s = q.popleft()\\n            s1 = s[-b:] + s[:-b]\\n            s2 = \"\".join([str((int(c) + a * (i % 2)) % 10) for i, c in enumerate(s)])\\n            if s1 not in rec:\\n                rec.add(s1)\\n                q.append(s1)\\n            if s2 not in rec:\\n                rec.add(s2)\\n                q.append(s2)\\n        return min(rec)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        rec = set()\\n        \\n        def dfs(s):\\n            if s in rec:\\n                return           \\n            rec.add(s)\\n            dfs(s[-b:] + s[:-b])\\n            dfs(\"\".join([str((int(c) + a * (i % 2)) % 10) for i, c in enumerate(s)]))\\n            \\n        dfs(s)\\n        return min(rec)\\n```\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        q = collections.deque([s])\\n        rec = set([s])\\n        while q:\\n            s = q.popleft()\\n            s1 = s[-b:] + s[:-b]\\n            s2 = \"\".join([str((int(c) + a * (i % 2)) % 10) for i, c in enumerate(s)])\\n            if s1 not in rec:\\n                rec.add(s1)\\n                q.append(s1)\\n            if s2 not in rec:\\n                rec.add(s2)\\n                q.append(s2)\\n        return min(rec)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901168,
                "title": "no-brute-force-o-n-2-gcd-b-n-time-o-n-space",
                "content": "Note: in the title `N = s.length`.\\n\\n# **First Thought**\\n---\\nWe need efficiently to answer these two questions:\\n* How many times to rotate the string?\\n* How many times of `a` to add on for each rotation position?\\n\\n# **TL; DR**\\n---\\nIn short, we need to rotate the string for only `s.length / gcd(b, s.length)` times.\\n\\nFor each rotation position, there are only two possible ways to add `a` to possibly get the minimum:\\n* If `b` is even, then only numbers at odd indices (0-based) can be modified by adding a multiple of `a`\\n* If `b` is odd, then numbers at odd indicies can be modified by adding a multiple of `a`, and the numbers at even indicies can also be modified by adding a multiple of `a`.\\n\\nTo determine the multiple of `a`, we only need to look at how to minimize the number at index 0 and 1.\\n\\nIf the above explanation makes sense to you, you can jump to the code at the end. Otherwise, let me explain in details:\\n\\n# **How many times to rotate the string?**\\n---\\nIt is obvious that rotating the string for `s.length` times will cover all possible rotation positionos. But is it necessary? It is possible that **sometimes we don\\'t have to rotate that many times**. For example, when `b == s.length`, there is only one rotation position. Rotating the string `s` for any arbitrary times won\\'t actually change `s`. How to get the minimum number of times needed to rotate?\\n\\nTo simulate the rotation, image you repeat the string `s` infinite times and get an infinite long string `S = sssssssss......`. And you have a pointer initially pointing at the head of `S`. The pointer each time moves right by `b` steps (this is corresponding to rotating the string by `b`). The next time when the pointer points to the head of certain `s` (let\\'s denote it as `S[i]`), we know we would see the same pattern of moves if we continue to move rightwards. **This is exactly the point we do not need to rotate the string further**.\\n\\nWe know `i` is a multiple of `b`, because we move the pointer by `b` steps each time. We also know it is a multiple of `s.length` because it is the head of certain `s`. So `i` is the Least Common Multiple (LCM) of `b` and `s.length`. At this point, **how many times have we moved the pointer? `i / b` times!**\\n\\nSo the minimum required times of rotations is\\n```\\n  i / b\\n= LCM(b, s.length) / b\\n= (b * s.length / GCD(b, s.length)) / b\\n= s.length / GCD(b, s.length)\\n```\\n\\n\\n# **Which numbers can be modified?**\\n---\\nNote that `s.length % 2 == 0`.\\n\\nIf `b` is even, even if you rotate the string later, it will still **always and only the numbers that currently at the odd indices that can be modified**. You will never be able to modify those even-indices number\\n\\nIf `b` is odd, then the if you rotate the string by `b`, the current odd-indexed numbers will go to even indices, and vice versa. You will have the chance to modify the numbers that are currently at even indices. Then you can rotate the string a few times to let it come back to the origional rotation position. So **when `b % 2 == 1`, you can add odd-index numbers all by a multiple of `a`, and add all even-index numbers by another (can be equal) multiple of `a`**.\\n\\n\\n# **For each given rotation position, how to determine the lexicographically smallest?**\\n---\\n\\nWhen `b` is even, we want to minimize the number at `s[1]`. That let us know what multiple of `a` do we want to add on all the odd-index numbers.\\n\\nWhen `b` is odd, we want to minimize both the numers at `s[0]` and `s[1]`. That let us know what multiple of `a` to add on all the odd-index numbers, and what to add on all the even-index numbers.\\n\\nSo **we do not have to try all 10 possible multiples of `a`**.\\n\\n# **Python Code**\\n---\\nhttps://github.com/kaiwensun/leetcode/blob/master/1501-2000/1625.Lexicographically%20Smallest%20String%20After%20Applying%20Operations.py\\n\\n```\\nfrom fractions import gcd\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n\\n        def get_smallest_head(head, a):\\n            if a == 5:\\n                return min(head, (head + 5) % 10)\\n            return 0 if a % 2 else head % 2\\n            \\n        def add_a(lst, diff_odd, diff_even):\\n            for i in xrange(1, len(lst), 2):\\n                lst[i] += diff_odd\\n                lst[i] %= 10\\n            if diff_even:\\n                for i in xrange(0, len(lst), 2):\\n                    lst[i] += diff_even\\n                    lst[i] %= 10\\n            return lst\\n            \\n        res = list(map(int, s))\\n        cur = list(map(int, s))\\n        rotate_times = len(s) // gcd(b, len(s))\\n        for _ in xrange(rotate_times):\\n            diff_odd = get_smallest_head(cur[1], a) - cur[1]\\n            diff_even = b % 2 and get_smallest_head(cur[0], a) - cur[0]\\n            if res > add_a(cur, diff_odd, diff_even):\\n                res = list(cur)\\n            cur = cur[b:] + cur[:b]\\n        return \"\".join(map(str, res))\\n```\\n\\n# **Complexity**\\n---\\n## Time complexity:\\n```\\n  T \\n= (times of rotations) * T(reconstruct the smallest string at the rotation position)\\n= (LCM(b, s.length) / b) * s.length\\n= s.length ^ 2 / GCD(b, s.length)\\n```\\n## Space complexity: \\n`O(s.length)` for the space of `cur` and `res`.\\n",
                "solutionTags": [],
                "code": "```\\n  i / b\\n= LCM(b, s.length) / b\\n= (b * s.length / GCD(b, s.length)) / b\\n= s.length / GCD(b, s.length)\\n```\n```\\nfrom fractions import gcd\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n\\n        def get_smallest_head(head, a):\\n            if a == 5:\\n                return min(head, (head + 5) % 10)\\n            return 0 if a % 2 else head % 2\\n            \\n        def add_a(lst, diff_odd, diff_even):\\n            for i in xrange(1, len(lst), 2):\\n                lst[i] += diff_odd\\n                lst[i] %= 10\\n            if diff_even:\\n                for i in xrange(0, len(lst), 2):\\n                    lst[i] += diff_even\\n                    lst[i] %= 10\\n            return lst\\n            \\n        res = list(map(int, s))\\n        cur = list(map(int, s))\\n        rotate_times = len(s) // gcd(b, len(s))\\n        for _ in xrange(rotate_times):\\n            diff_odd = get_smallest_head(cur[1], a) - cur[1]\\n            diff_even = b % 2 and get_smallest_head(cur[0], a) - cur[0]\\n            if res > add_a(cur, diff_odd, diff_even):\\n                res = list(cur)\\n            cur = cur[b:] + cur[:b]\\n        return \"\".join(map(str, res))\\n```\n```\\n  T \\n= (times of rotations) * T(reconstruct the smallest string at the rotation position)\\n= (LCM(b, s.length) / b) * s.length\\n= s.length ^ 2 / GCD(b, s.length)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899443,
                "title": "straightforward-easy-bfs-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string get1(string curr,int a)\\n    {\\n        for(int i=0;i<curr.size();i++)\\n        {\\n            if(i%2)\\n            {\\n             int num  = curr[i]-\\'0\\';\\n             num = (num+a)%10;\\n             curr[i]= num+\\'0\\';\\n            }\\n        }\\n        return curr;\\n    }\\n    string get2(string curr,int k)\\n    {\\n         k  = k%curr.size();\\n        reverse(curr.begin(),curr.end());\\n        reverse(curr.begin(),curr.begin()+k);\\n        reverse(curr.begin()+k,curr.end());\\n        return curr;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string>q;\\n        vector<string>st;\\n        vector<string>vect;\\n        set<string>visited;\\n        visited.insert(s);\\n        q.push(s);\\n        while(!q.empty())\\n        {\\n          string curr = q.front();\\n            q.pop();\\n            vect.push_back(curr);\\n            string one = get1(curr,a);\\n            if(visited.find(one)==visited.end())\\n            {\\n                q.push(one);\\n                visited.insert(one);\\n            }  \\n            string two = get2(curr,b);\\n            if(visited.find(two)==visited.end())\\n            {\\n                q.push(two);\\n                visited.insert(two);\\n            }  \\n        }\\n        sort(vect.begin(),vect.end());\\n      \\n        return vect[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string get1(string curr,int a)\\n    {\\n        for(int i=0;i<curr.size();i++)\\n        {\\n            if(i%2)\\n            {\\n             int num  = curr[i]-\\'0\\';\\n             num = (num+a)%10;\\n             curr[i]= num+\\'0\\';\\n            }\\n        }\\n        return curr;\\n    }\\n    string get2(string curr,int k)\\n    {\\n         k  = k%curr.size();\\n        reverse(curr.begin(),curr.end());\\n        reverse(curr.begin(),curr.begin()+k);\\n        reverse(curr.begin()+k,curr.end());\\n        return curr;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string>q;\\n        vector<string>st;\\n        vector<string>vect;\\n        set<string>visited;\\n        visited.insert(s);\\n        q.push(s);\\n        while(!q.empty())\\n        {\\n          string curr = q.front();\\n            q.pop();\\n            vect.push_back(curr);\\n            string one = get1(curr,a);\\n            if(visited.find(one)==visited.end())\\n            {\\n                q.push(one);\\n                visited.insert(one);\\n            }  \\n            string two = get2(curr,b);\\n            if(visited.find(two)==visited.end())\\n            {\\n                q.push(two);\\n                visited.insert(two);\\n            }  \\n        }\\n        sort(vect.begin(),vect.end());\\n      \\n        return vect[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899547,
                "title": "python3-dfs",
                "content": "Traverse the whole graph via the two operations, and return the minimum string. \\n\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        op1 = lambda s: \"\".join(str((int(c)+a)%10) if i&1 else c for i, c in enumerate(s))\\n        op2 = lambda s: s[-b:] + s[:-b]\\n        \\n        seen = set()\\n        stack = [s]\\n        while stack: \\n            s = stack.pop()\\n            seen.add(s)\\n            if (ss := op1(s)) not in seen: stack.append(ss)\\n            if (ss := op2(s)) not in seen: stack.append(ss)\\n        return min(seen)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        op1 = lambda s: \"\".join(str((int(c)+a)%10) if i&1 else c for i, c in enumerate(s))\\n        op2 = lambda s: s[-b:] + s[:-b]\\n        \\n        seen = set()\\n        stack = [s]\\n        while stack: \\n            s = stack.pop()\\n            seen.add(s)\\n            if (ss := op1(s)) not in seen: stack.append(ss)\\n            if (ss := op2(s)) not in seen: stack.append(ss)\\n        return min(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457839,
                "title": "c-explained-easy-to-understand-beginner-bfs",
                "content": "# ***Approach***\\n```\\nThis is a quite easy to implement kind of problem!!!\\n\\nThere is nothing special or hidden in the problem statement , do what is mentioned...\\n\\nWe are required to find the lexiographically smallest string that can be formed from string s\\n\\nWhat we will do is create all possible strings and return the lexiographically smallest one we encountered!!!\\n    \\nFor a string s : we can have 2 childs\\n                    first_child : formed by applying operation 1 on parent string\\n                    second_child : formed by applying operation 2 on parent string\\n                    we only push those strings to queue that are not seen yet!!![to avoid infinite loop]\\nNOTE : I have used BFS , u can also use DFS , it will work fine!!!\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string str, int a, int b) {\\n        unordered_set<string> seen; // to keep track of seen strings\\n        queue<string> q;\\n        q.push(str);\\n        \\n        string lex_smallest_string = str;\\n        \\n        while(q.empty() == false) //simple-bfs\\n        {\\n            string s = q.front();\\n            q.pop();\\n\\n            lex_smallest_string = min(lex_smallest_string , s);\\n\\n            // Pushing all those childs which are not seen yet!!!\\n            // 1st child is formed by applying operation 1 on string\\n            // 2nd child is formed by applying operation 2 on string\\n\\n            string first_child = apply_operation_1(s , a);\\n            if(seen.find(first_child) == seen.end())\\n                q.push(first_child) , seen.insert(first_child);\\n\\n            string second_child = apply_operation_2(s , b);\\n            if(seen.find(second_child) == seen.end())\\n                q.push(second_child) , seen.insert(second_child);\\n        }\\n        return lex_smallest_string;\\n    }\\n    \\n    string apply_operation_1(string s , int a)\\n    {\\n    // Operation 1 : states that increasing all odd indices of string a times!!!!\\n        for(int i = 1 ; i < s.size() ; i += 2)\\n            s[i] = (s[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        return s;\\n    }\\n    \\n    string apply_operation_2(string s , int b)\\n    {\\n    // Operation 2 : states that we have to rotate string to right b times!!!!!\\n        string res(s.size() , \\' \\');\\n        for(int i = 0 ; i < s.size() ; ++i)\\n            res[(i + b) % s.size()] = s[i];\\n        return res;\\n    }\\n};\\n```\\n# ***If you liked the solution, Please Upvote!!!***",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nThis is a quite easy to implement kind of problem!!!\\n\\nThere is nothing special or hidden in the problem statement , do what is mentioned...\\n\\nWe are required to find the lexiographically smallest string that can be formed from string s\\n\\nWhat we will do is create all possible strings and return the lexiographically smallest one we encountered!!!\\n    \\nFor a string s : we can have 2 childs\\n                    first_child : formed by applying operation 1 on parent string\\n                    second_child : formed by applying operation 2 on parent string\\n                    we only push those strings to queue that are not seen yet!!![to avoid infinite loop]\\nNOTE : I have used BFS , u can also use DFS , it will work fine!!!\\n```\n```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string str, int a, int b) {\\n        unordered_set<string> seen; // to keep track of seen strings\\n        queue<string> q;\\n        q.push(str);\\n        \\n        string lex_smallest_string = str;\\n        \\n        while(q.empty() == false) //simple-bfs\\n        {\\n            string s = q.front();\\n            q.pop();\\n\\n            lex_smallest_string = min(lex_smallest_string , s);\\n\\n            // Pushing all those childs which are not seen yet!!!\\n            // 1st child is formed by applying operation 1 on string\\n            // 2nd child is formed by applying operation 2 on string\\n\\n            string first_child = apply_operation_1(s , a);\\n            if(seen.find(first_child) == seen.end())\\n                q.push(first_child) , seen.insert(first_child);\\n\\n            string second_child = apply_operation_2(s , b);\\n            if(seen.find(second_child) == seen.end())\\n                q.push(second_child) , seen.insert(second_child);\\n        }\\n        return lex_smallest_string;\\n    }\\n    \\n    string apply_operation_1(string s , int a)\\n    {\\n    // Operation 1 : states that increasing all odd indices of string a times!!!!\\n        for(int i = 1 ; i < s.size() ; i += 2)\\n            s[i] = (s[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        return s;\\n    }\\n    \\n    string apply_operation_2(string s , int b)\\n    {\\n    // Operation 2 : states that we have to rotate string to right b times!!!!!\\n        string res(s.size() , \\' \\');\\n        for(int i = 0 ; i < s.size() ; ++i)\\n            res[(i + b) % s.size()] = s[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194012,
                "title": "java-dfs-simulation",
                "content": "Do upvote if you like the solution, and comment if optimizations of the approach are possible.\\n\\n```\\nclass Solution {\\n    private String result;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        result = \"z\";\\n        HashSet<String> set = new HashSet<>();\\n        dfs(s, a, b, set);\\n        return result;\\n    }\\n    private void dfs(String s, int a, int b, HashSet<String> set) {\\n        if(set.contains(s))\\n            return;\\n        set.add(s);\\n        String s1, s2;\\n        s1 = addA(s, a);\\n        s2 = rotateB(s, b);\\n        dfs(s1, a , b, set);\\n        dfs(s2, a , b, set);\\n    }\\n    private String addA(String s, int a) {\\n        char c[] = s.toCharArray();\\n        int i, temp;\\n        for(i=1;i<s.length();i+=2) {\\n            temp = c[i] - \\'0\\';\\n            temp += a;\\n            temp = temp % 10;\\n            c[i] = (char)(temp + \\'0\\');\\n        } \\n        s = new String(c);\\n        if(result.compareTo(s) > 0)\\n            result = s;\\n        return s;\\n    }\\n    private String rotateB(String s, int b) {\\n        if(b < 0)\\n            b += s.length();\\n        b = b % s.length();\\n        b = s.length() - b;\\n        s = s.substring(b) + s.substring(0, b);\\n        if(result.compareTo(s) > 0)\\n            result = s;\\n        return s;\\n    }\\n}\\n```\\n\\nThank You!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    private String result;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        result = \"z\";\\n        HashSet<String> set = new HashSet<>();\\n        dfs(s, a, b, set);\\n        return result;\\n    }\\n    private void dfs(String s, int a, int b, HashSet<String> set) {\\n        if(set.contains(s))\\n            return;\\n        set.add(s);\\n        String s1, s2;\\n        s1 = addA(s, a);\\n        s2 = rotateB(s, b);\\n        dfs(s1, a , b, set);\\n        dfs(s2, a , b, set);\\n    }\\n    private String addA(String s, int a) {\\n        char c[] = s.toCharArray();\\n        int i, temp;\\n        for(i=1;i<s.length();i+=2) {\\n            temp = c[i] - \\'0\\';\\n            temp += a;\\n            temp = temp % 10;\\n            c[i] = (char)(temp + \\'0\\');\\n        } \\n        s = new String(c);\\n        if(result.compareTo(s) > 0)\\n            result = s;\\n        return s;\\n    }\\n    private String rotateB(String s, int b) {\\n        if(b < 0)\\n            b += s.length();\\n        b = b % s.length();\\n        b = s.length() - b;\\n        s = s.substring(b) + s.substring(0, b);\\n        if(result.compareTo(s) > 0)\\n            result = s;\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948659,
                "title": "c-simple-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> visited;\\n        queue<string> q;\\n        q.push(s);\\n        string ans = s;\\n        visited.insert(s);\\n        while(!q.empty())\\n        {\\n             string front = q.front();\\n             q.pop();\\n             ans=min(ans,front);\\n             string addstr = add(front,a), rotatestr = rotate(front,b) ;\\n             if(visited.find(addstr)==visited.end()) \\n             {\\n                visited.insert(addstr);\\n                q.push(addstr);\\n             }\\n             if(visited.find(rotatestr)==visited.end())\\n             {\\n                visited.insert(rotatestr);\\n                q.push(rotatestr);\\n             }\\n        }\\n        return ans;\\n    }\\n    \\n    string add(string s, int a)\\n    {\\n        for(int i=1;i<s.size();i=i+2)\\n        {\\n            int x = (s[i]-\\'0\\'+a)%10;\\n            s[i]=\\'0\\'+x;\\n        }\\n        return s;\\n    }\\n    \\n    string rotate(string s, int b)\\n    {\\n        for(int i=0;i<b;i++)\\n        {\\n            char p = s[s.length()-1];\\n            s.pop_back();\\n            s.insert(s.begin(), p); \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> visited;\\n        queue<string> q;\\n        q.push(s);\\n        string ans = s;\\n        visited.insert(s);\\n        while(!q.empty())\\n        {\\n             string front = q.front();\\n             q.pop();\\n             ans=min(ans,front);\\n             string addstr = add(front,a), rotatestr = rotate(front,b) ;\\n             if(visited.find(addstr)==visited.end()) \\n             {\\n                visited.insert(addstr);\\n                q.push(addstr);\\n             }\\n             if(visited.find(rotatestr)==visited.end())\\n             {\\n                visited.insert(rotatestr);\\n                q.push(rotatestr);\\n             }\\n        }\\n        return ans;\\n    }\\n    \\n    string add(string s, int a)\\n    {\\n        for(int i=1;i<s.size();i=i+2)\\n        {\\n            int x = (s[i]-\\'0\\'+a)%10;\\n            s[i]=\\'0\\'+x;\\n        }\\n        return s;\\n    }\\n    \\n    string rotate(string s, int b)\\n    {\\n        for(int i=0;i<b;i++)\\n        {\\n            char p = s[s.length()-1];\\n            s.pop_back();\\n            s.insert(s.begin(), p); \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900028,
                "title": "cpp-concise-solution-memoization",
                "content": "intuition: on each step we either rotate or add *a* to the string then recompute the lowest string.\\n\\nSo let\\'s do both independently and keep tracking the lowest string. As you can see there are subproblems. so let\\'s save it for later.\\n```\\nclass Solution {\\npublic:\\n    void dfs(string &s, string &small, int a, int b, unordered_map<string, string> &memo) {\\n        if (memo.count(s)) return;\\n        string res = s, str = res;\\n        memo[s] = res;\\n        rotate(str.begin(), str.begin() + b, str.end()); // rotate current string\\n        dfs(str, small, a, b, memo);\\n        if (memo[str] < res) res = memo[str];\\n        \\n        for (int i = 0; i < 9; i++) { // or add it\\n            for (int j = 1; j < s.length(); j+=2)\\n                s[j] = \\'0\\' + ((s[j] - \\'0\\') + a) % 10;\\n            if (s < res) res = s;\\n            dfs(s, small, a, b, memo);\\n        }\\n        if (small > res) small = res;\\n        memo[s] = res;\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_map<string, string> memo;\\n        string res = s;\\n        dfs(s, res, a, b, memo);\\n        return  res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(string &s, string &small, int a, int b, unordered_map<string, string> &memo) {\\n        if (memo.count(s)) return;\\n        string res = s, str = res;\\n        memo[s] = res;\\n        rotate(str.begin(), str.begin() + b, str.end()); // rotate current string\\n        dfs(str, small, a, b, memo);\\n        if (memo[str] < res) res = memo[str];\\n        \\n        for (int i = 0; i < 9; i++) { // or add it\\n            for (int j = 1; j < s.length(); j+=2)\\n                s[j] = \\'0\\' + ((s[j] - \\'0\\') + a) % 10;\\n            if (s < res) res = s;\\n            dfs(s, small, a, b, memo);\\n        }\\n        if (small > res) small = res;\\n        memo[s] = res;\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_map<string, string> memo;\\n        string res = s;\\n        dfs(s, res, a, b, memo);\\n        return  res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899486,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Set<String> hs = new HashSet();\\n        rec(s, a, b, hs);\\n        List<String> al = new ArrayList(hs);\\n        Collections.sort(al);\\n        return al.get(0);\\n    }\\n    \\n    private void rec(String s, int a, int b, Set<String> hs){\\n        if(hs.contains(s)){\\n            return ;\\n        }\\n        hs.add(s);\\n        rec(s.substring(s.length()-b) + s.substring(0, s.length()-b), a, b, hs);\\n        char []c = s.toCharArray();\\n        for(int i=1;i<s.length();i+=2){\\n            int val = c[i]-48;\\n            val = (val+a)%10;\\n            c[i] = (char)(val+48);\\n        }\\n        rec(new String(c), a, b, hs);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Set<String> hs = new HashSet();\\n        rec(s, a, b, hs);\\n        List<String> al = new ArrayList(hs);\\n        Collections.sort(al);\\n        return al.get(0);\\n    }\\n    \\n    private void rec(String s, int a, int b, Set<String> hs){\\n        if(hs.contains(s)){\\n            return ;\\n        }\\n        hs.add(s);\\n        rec(s.substring(s.length()-b) + s.substring(0, s.length()-b), a, b, hs);\\n        char []c = s.toCharArray();\\n        for(int i=1;i<s.length();i+=2){\\n            int val = c[i]-48;\\n            val = (val+a)%10;\\n            c[i] = (char)(val+48);\\n        }\\n        rec(new String(c), a, b, hs);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436071,
                "title": "python-3-12-lines-recursion-dfs-t-m-80-12",
                "content": "\\nThe plan here is to determine the set of all possible states of`s`under the two transformations, then return the lexicographic minimum of that set.\\n```\\nclass Solution:\\n       def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\n        def dfs(s: str) -> str:\\n\\n            if s in seen: return\\n\\n            seen.add(s)\\n            res, odd =\\'\\', True\\n\\n            for ch in s:\\n                odd^= True\\n                res+= d[ch] if odd else ch\\n    \\n            dfs(res)\\n            dfs(s[b: ] + s[ :b])\\n\\n\\n        d, seen = {ch:str((int(ch) + a) % 10\\n                    ) for ch in digits}, set()\\n\\n        dfs(s)\\n\\n        return min(seen)\\n```\\n[https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/submissions/936536316/](http://)\\n\\nPython 3   ||   12 lines,  dfs   ||   T/M: 80% / 12%\\n\\nI definitely could be wrong about this, but I think that time and space complexities are both *O*(10^*N*), where *N* = `len(s)`. Both worst-case, which is`gcd(10, a) == 1`and`gcd(len(s), b) == 1`\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n       def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\n        def dfs(s: str) -> str:\\n\\n            if s in seen: return\\n\\n            seen.add(s)\\n            res, odd =\\'\\', True\\n\\n            for ch in s:\\n                odd^= True\\n                res+= d[ch] if odd else ch\\n    \\n            dfs(res)\\n            dfs(s[b: ] + s[ :b])\\n\\n\\n        d, seen = {ch:str((int(ch) + a) % 10\\n                    ) for ch in digits}, set()\\n\\n        dfs(s)\\n\\n        return min(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903526,
                "title": "kt-js-py3-cpp-brute-force-via-dfs-bfs",
                "content": "**Synopsis:**\\n\\nBrute-force check all possibilities via the following two mutations:\\n\\n**Case 1:** let `a` be the `amount` we will `increment` each odd indexed character `c` of the input string `s`\\n**Case 2:** let `b` be the `pivot` index at which we `rotate` the input string `s`\\n\\nReturn the lexicographical minimum string as the `best` answer.\\n\\n---\\n\\n**`\\uD83D\\uDE80` DFS Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findLexSmallestString(s: String, amount: Int, pivot: Int): String {\\n        var ord: (Char) -> Int = { c: Char -> c.toInt() }\\n        var best = s\\n        var seen = mutableSetOf<String>()\\n        fun go(s: String): Unit {\\n            if (best > s)\\n                best = s\\n            var increment = s.mapIndexed{ i, c -> if (i % 2 == 1) (ord(\\'0\\') + (ord(c) - ord(\\'0\\') + amount) % 10).toChar() else c }.joinToString(\"\")\\n            if (!seen.contains(increment)) {\\n                seen.add(increment); go(increment)\\n            }\\n            var rotate = s.substring(pivot) + s.substring(0, pivot)\\n            if (!seen.contains(rotate)) {\\n                seen.add(rotate); go(rotate)\\n            }\\n        }\\n        go(s)\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findLexSmallestString = (s, amount, pivot, best = s, seen = new Set([ s ])) => {\\n    let ord = c => c.charCodeAt(0);\\n    let go = s => {\\n        if (0 < best.localeCompare(s))\\n            best = s;\\n        let increment = s.split(\\'\\').map((c, i) => i & 1 ? String.fromCharCode(ord(\\'0\\') + (ord(c) - ord(\\'0\\') + amount) % 10) : c).join(\\'\\');\\n        if (!seen.has(increment))\\n            seen.add(increment), go(increment);\\n        let rotate = s.substring(pivot) + s.substring(0, pivot);\\n        if (!seen.has(rotate))\\n            seen.add(rotate), go(rotate);\\n    };\\n    go(s);\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, amount: int, pivot: int) -> str:\\n        best = s\\n        seen = set([ s ])\\n        def go(s):\\n            nonlocal best\\n            if best > s:\\n                best = s\\n            increment = \\'\\'.join([str((int(c) + amount) % 10) if i & 1 else c for i, c in enumerate(s)])\\n            if increment not in seen:\\n                seen.add(increment); go(increment)\\n            rotate = s[pivot:] + s[:pivot]\\n            if rotate not in seen:\\n                seen.add(rotate); go(rotate)\\n        go(s)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<string>;\\n    using fun = function<void(string)>;\\n    string findLexSmallestString(string s, int amount, int pivot) {\\n        auto best{ s };\\n        Set seen{ s };\\n        fun go = [&](auto s) {\\n            if (best > s)\\n                best = s;\\n            string increment;\\n            transform(s.begin(), s.end(), back_inserter(increment), [i = -1, amount](auto c) mutable {\\n                return ++i & 1 ? (((c - \\'0\\') + amount) % 10) + \\'0\\' : c;\\n            });\\n            if (seen.insert(increment).second)\\n                go(increment);\\n            auto rotate = s.substr(pivot) + s.substr(0, pivot);\\n            if (seen.insert(rotate).second)\\n                go(rotate);\\n        };\\n        go(s);\\n        return best;\\n    }\\n};\\n```\\n\\n---\\n\\n**`\\uD83D\\uDE8C` BFS Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findLexSmallestString(s: String, amount: Int, pivot: Int): String {\\n        var ord: (Char) -> Int = { c: Char -> c.toInt() }\\n        var best = s\\n        var seen = mutableSetOf<String>()\\n        var q: Queue<String> = LinkedList<String>(mutableListOf(s))\\n        while (q.peek() != null) {\\n            var cur = q.poll()\\n            if (best > cur)\\n                best = cur\\n            var increment = cur.mapIndexed{ i, c -> if (i % 2 == 1) (ord(\\'0\\') + (ord(c) - ord(\\'0\\') + amount) % 10).toChar() else c }.joinToString(\"\")\\n            if (!seen.contains(increment)) {\\n                seen.add(increment); q.add(increment)\\n            }\\n            var rotate = cur.substring(pivot) + cur.substring(0, pivot)\\n            if (!seen.contains(rotate)) {\\n                seen.add(rotate); q.add(rotate)\\n            }\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findLexSmallestString = (s, amount, pivot, best = s, seen = new Set([ s ])) => {\\n    let ord = c => c.charCodeAt(0);\\n    let q = [ s ];\\n    while (q.length) {\\n        let cur = q.pop();\\n        if (0 < best.localeCompare(cur))\\n            best = cur;\\n        let increment = cur.split(\\'\\').map((c, i) => i & 1 ? String.fromCharCode(ord(\\'0\\') + (ord(c) - ord(\\'0\\') + amount) % 10) : c).join(\\'\\');\\n        if (!seen.has(increment))\\n            seen.add(increment), q.push(increment);\\n        let rotate = cur.substring(pivot) + cur.substring(0, pivot);\\n        if (!seen.has(rotate))\\n            seen.add(rotate), q.push(rotate);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, amount: int, pivot: int) -> str:\\n        best = s\\n        seen = set([ s ])\\n        q = deque([ s ])\\n        while q:\\n            cur = q.popleft()\\n            if best > cur:\\n                best = cur\\n            increment = \\'\\'.join([str((int(c) + amount) % 10) if i & 1 else c for i, c in enumerate(cur)])\\n            if increment not in seen:\\n                seen.add(increment); q.append(increment)\\n            rotate = cur[pivot:] + cur[:pivot]\\n            if rotate not in seen:\\n                seen.add(rotate); q.append(rotate)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Queue = queue<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<void(string)>;\\n    string findLexSmallestString(string s, int amount, int pivot) {\\n        auto best{ s };\\n        Queue q{{{ s }}};\\n        Set seen{ s };\\n        while (q.size()) {\\n            auto cur = q.front(); q.pop();\\n            if (best > cur)\\n                best = cur;\\n            string increment;\\n            transform(cur.begin(), cur.end(), back_inserter(increment), [i = -1, amount](auto c) mutable {\\n                return ++i & 1 ? (((c - \\'0\\') + amount) % 10) + \\'0\\' : c;\\n            });\\n            if (seen.insert(increment).second)\\n                q.push(increment);\\n            auto rotate = cur.substr(pivot) + cur.substr(0, pivot);\\n            if (seen.insert(rotate).second)\\n                q.push(rotate);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findLexSmallestString(s: String, amount: Int, pivot: Int): String {\\n        var ord: (Char) -> Int = { c: Char -> c.toInt() }\\n        var best = s\\n        var seen = mutableSetOf<String>()\\n        fun go(s: String): Unit {\\n            if (best > s)\\n                best = s\\n            var increment = s.mapIndexed{ i, c -> if (i % 2 == 1) (ord(\\'0\\') + (ord(c) - ord(\\'0\\') + amount) % 10).toChar() else c }.joinToString(\"\")\\n            if (!seen.contains(increment)) {\\n                seen.add(increment); go(increment)\\n            }\\n            var rotate = s.substring(pivot) + s.substring(0, pivot)\\n            if (!seen.contains(rotate)) {\\n                seen.add(rotate); go(rotate)\\n            }\\n        }\\n        go(s)\\n        return best\\n    }\\n}\\n```\n```\\nlet findLexSmallestString = (s, amount, pivot, best = s, seen = new Set([ s ])) => {\\n    let ord = c => c.charCodeAt(0);\\n    let go = s => {\\n        if (0 < best.localeCompare(s))\\n            best = s;\\n        let increment = s.split(\\'\\').map((c, i) => i & 1 ? String.fromCharCode(ord(\\'0\\') + (ord(c) - ord(\\'0\\') + amount) % 10) : c).join(\\'\\');\\n        if (!seen.has(increment))\\n            seen.add(increment), go(increment);\\n        let rotate = s.substring(pivot) + s.substring(0, pivot);\\n        if (!seen.has(rotate))\\n            seen.add(rotate), go(rotate);\\n    };\\n    go(s);\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, amount: int, pivot: int) -> str:\\n        best = s\\n        seen = set([ s ])\\n        def go(s):\\n            nonlocal best\\n            if best > s:\\n                best = s\\n            increment = \\'\\'.join([str((int(c) + amount) % 10) if i & 1 else c for i, c in enumerate(s)])\\n            if increment not in seen:\\n                seen.add(increment); go(increment)\\n            rotate = s[pivot:] + s[:pivot]\\n            if rotate not in seen:\\n                seen.add(rotate); go(rotate)\\n        go(s)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<string>;\\n    using fun = function<void(string)>;\\n    string findLexSmallestString(string s, int amount, int pivot) {\\n        auto best{ s };\\n        Set seen{ s };\\n        fun go = [&](auto s) {\\n            if (best > s)\\n                best = s;\\n            string increment;\\n            transform(s.begin(), s.end(), back_inserter(increment), [i = -1, amount](auto c) mutable {\\n                return ++i & 1 ? (((c - \\'0\\') + amount) % 10) + \\'0\\' : c;\\n            });\\n            if (seen.insert(increment).second)\\n                go(increment);\\n            auto rotate = s.substr(pivot) + s.substr(0, pivot);\\n            if (seen.insert(rotate).second)\\n                go(rotate);\\n        };\\n        go(s);\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun findLexSmallestString(s: String, amount: Int, pivot: Int): String {\\n        var ord: (Char) -> Int = { c: Char -> c.toInt() }\\n        var best = s\\n        var seen = mutableSetOf<String>()\\n        var q: Queue<String> = LinkedList<String>(mutableListOf(s))\\n        while (q.peek() != null) {\\n            var cur = q.poll()\\n            if (best > cur)\\n                best = cur\\n            var increment = cur.mapIndexed{ i, c -> if (i % 2 == 1) (ord(\\'0\\') + (ord(c) - ord(\\'0\\') + amount) % 10).toChar() else c }.joinToString(\"\")\\n            if (!seen.contains(increment)) {\\n                seen.add(increment); q.add(increment)\\n            }\\n            var rotate = cur.substring(pivot) + cur.substring(0, pivot)\\n            if (!seen.contains(rotate)) {\\n                seen.add(rotate); q.add(rotate)\\n            }\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet findLexSmallestString = (s, amount, pivot, best = s, seen = new Set([ s ])) => {\\n    let ord = c => c.charCodeAt(0);\\n    let q = [ s ];\\n    while (q.length) {\\n        let cur = q.pop();\\n        if (0 < best.localeCompare(cur))\\n            best = cur;\\n        let increment = cur.split(\\'\\').map((c, i) => i & 1 ? String.fromCharCode(ord(\\'0\\') + (ord(c) - ord(\\'0\\') + amount) % 10) : c).join(\\'\\');\\n        if (!seen.has(increment))\\n            seen.add(increment), q.push(increment);\\n        let rotate = cur.substring(pivot) + cur.substring(0, pivot);\\n        if (!seen.has(rotate))\\n            seen.add(rotate), q.push(rotate);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, amount: int, pivot: int) -> str:\\n        best = s\\n        seen = set([ s ])\\n        q = deque([ s ])\\n        while q:\\n            cur = q.popleft()\\n            if best > cur:\\n                best = cur\\n            increment = \\'\\'.join([str((int(c) + amount) % 10) if i & 1 else c for i, c in enumerate(cur)])\\n            if increment not in seen:\\n                seen.add(increment); q.append(increment)\\n            rotate = cur[pivot:] + cur[:pivot]\\n            if rotate not in seen:\\n                seen.add(rotate); q.append(rotate)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using Queue = queue<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<void(string)>;\\n    string findLexSmallestString(string s, int amount, int pivot) {\\n        auto best{ s };\\n        Queue q{{{ s }}};\\n        Set seen{ s };\\n        while (q.size()) {\\n            auto cur = q.front(); q.pop();\\n            if (best > cur)\\n                best = cur;\\n            string increment;\\n            transform(cur.begin(), cur.end(), back_inserter(increment), [i = -1, amount](auto c) mutable {\\n                return ++i & 1 ? (((c - \\'0\\') + amount) % 10) + \\'0\\' : c;\\n            });\\n            if (seen.insert(increment).second)\\n                q.push(increment);\\n            auto rotate = cur.substr(pivot) + cur.substr(0, pivot);\\n            if (seen.insert(rotate).second)\\n                q.push(rotate);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900193,
                "title": "c-bfs-solution",
                "content": "Runtime: 272 ms, faster than 80.00% of C++ online submissions for Lexicographically Smallest String After Applying Operations.\\nMemory Usage: 104.7 MB, less than 60.00% of C++ online submissions for Lexicographically Smallest String After Applying Operations.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // return string after add operation\\n    string AddOperation(string s, int a)\\n    {\\n        for(int i=1;i<s.length();i+=2)\\n            s[i] = (s[i]-\\'0\\'+a)%10 + \\'0\\';\\n        \\n        return s;\\n    }\\n    \\n    // return string after rotate operation\\n    string RotateOperation(string s, int b)\\n    {\\n        int left = s.length()-b;\\n        \\n        string str = s.substr(left,b) + s.substr(0,left);\\n        \\n        return str;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        // track processed strings\\n        unordered_map<string,bool>visited;\\n        \\n        queue<string>Q;\\n        \\n        string result = \"\";\\n        \\n        Q.push(s);\\n        visited[s] = true;\\n        \\n        string curr;\\n        \\n        while(!Q.empty())\\n        {\\n            curr = Q.front();\\n            Q.pop();\\n            \\n            // get lexical small string\\n            if(result.empty() || lexicographical_compare(curr.begin(),curr.end(),result.begin(),result.end()))\\n                result = curr;\\n            \\n            // get strings after add and rotate operations\\n            string addString = AddOperation(curr,a);\\n            string rotateString = RotateOperation(curr,b);\\n            \\n            // push addString if not already processed\\n            if(visited.count(addString)==0)\\n            {\\n                visited[addString] = true;\\n                Q.push(addString);\\n            }\\n            \\n            // push rotateString if not already processed\\n            if(visited.count(rotateString)==0)\\n            {\\n                visited[rotateString] = true;\\n                Q.push(rotateString);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // return string after add operation\\n    string AddOperation(string s, int a)\\n    {\\n        for(int i=1;i<s.length();i+=2)\\n            s[i] = (s[i]-\\'0\\'+a)%10 + \\'0\\';\\n        \\n        return s;\\n    }\\n    \\n    // return string after rotate operation\\n    string RotateOperation(string s, int b)\\n    {\\n        int left = s.length()-b;\\n        \\n        string str = s.substr(left,b) + s.substr(0,left);\\n        \\n        return str;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        // track processed strings\\n        unordered_map<string,bool>visited;\\n        \\n        queue<string>Q;\\n        \\n        string result = \"\";\\n        \\n        Q.push(s);\\n        visited[s] = true;\\n        \\n        string curr;\\n        \\n        while(!Q.empty())\\n        {\\n            curr = Q.front();\\n            Q.pop();\\n            \\n            // get lexical small string\\n            if(result.empty() || lexicographical_compare(curr.begin(),curr.end(),result.begin(),result.end()))\\n                result = curr;\\n            \\n            // get strings after add and rotate operations\\n            string addString = AddOperation(curr,a);\\n            string rotateString = RotateOperation(curr,b);\\n            \\n            // push addString if not already processed\\n            if(visited.count(addString)==0)\\n            {\\n                visited[addString] = true;\\n                Q.push(addString);\\n            }\\n            \\n            // push rotateString if not already processed\\n            if(visited.count(rotateString)==0)\\n            {\\n                visited[rotateString] = true;\\n                Q.push(rotateString);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747697,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string str, int a, int b) {\\n        unordered_set<string> seen; \\n        queue<string> q;\\n        q.push(str);\\n        \\n        string lex_smallest_string = str;\\n        \\n        while(q.empty() == false) \\n        {\\n            string s = q.front();\\n            q.pop();\\n\\n            lex_smallest_string = min(lex_smallest_string , s);\\n\\n\\n            string first_child = apply_operation_1(s , a);\\n            if(seen.find(first_child) == seen.end())\\n                q.push(first_child) , seen.insert(first_child);\\n\\n            string second_child = apply_operation_2(s , b);\\n            if(seen.find(second_child) == seen.end())\\n                q.push(second_child) , seen.insert(second_child);\\n        }\\n        return lex_smallest_string;\\n    }\\n    \\n    string apply_operation_1(string s , int a)\\n    {\\n        for(int i = 1 ; i < s.size() ; i += 2)\\n            s[i] = (s[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        return s;\\n    }\\n    \\n    string apply_operation_2(string s , int b)\\n    {\\n        string res(s.size() , \\' \\');\\n        for(int i = 0 ; i < s.size() ; ++i)\\n            res[(i + b) % s.size()] = s[i];\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string str, int a, int b) {\\n        unordered_set<string> seen; \\n        queue<string> q;\\n        q.push(str);\\n        \\n        string lex_smallest_string = str;\\n        \\n        while(q.empty() == false) \\n        {\\n            string s = q.front();\\n            q.pop();\\n\\n            lex_smallest_string = min(lex_smallest_string , s);\\n\\n\\n            string first_child = apply_operation_1(s , a);\\n            if(seen.find(first_child) == seen.end())\\n                q.push(first_child) , seen.insert(first_child);\\n\\n            string second_child = apply_operation_2(s , b);\\n            if(seen.find(second_child) == seen.end())\\n                q.push(second_child) , seen.insert(second_child);\\n        }\\n        return lex_smallest_string;\\n    }\\n    \\n    string apply_operation_1(string s , int a)\\n    {\\n        for(int i = 1 ; i < s.size() ; i += 2)\\n            s[i] = (s[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        return s;\\n    }\\n    \\n    string apply_operation_2(string s , int b)\\n    {\\n        string res(s.size() , \\' \\');\\n        for(int i = 0 ; i < s.size() ; ++i)\\n            res[(i + b) % s.size()] = s[i];\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136068,
                "title": "simple-bfs-c",
                "content": "```\\n    string findLexSmallestString(string str, int a, int b) {\\n        queue<string> q;\\n        unordered_set<string> s;\\n        q.push(str);    \\n        int n=str.length();\\n        string ans=str;\\n        while(!q.empty()){\\n            string cur=q.front();\\n            q.pop();\\n            if(s.count(cur))\\n                continue;\\n            ans=min(ans, cur);\\n            s.insert(cur);\\n            string as=cur;\\n            for(int i=1; i<n; i+=2)\\n                as[i]=\\'0\\'+(as[i]-\\'0\\'+a)%10;\\n            q.push(as);\\n            q.push(cur.substr(n-b,b)+cur.substr(0,n-b));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n    string findLexSmallestString(string str, int a, int b) {\\n        queue<string> q;\\n        unordered_set<string> s;\\n        q.push(str);    \\n        int n=str.length();\\n        string ans=str;\\n        while(!q.empty()){\\n            string cur=q.front();\\n            q.pop();\\n            if(s.count(cur))\\n                continue;\\n            ans=min(ans, cur);\\n            s.insert(cur);\\n            string as=cur;\\n            for(int i=1; i<n; i+=2)\\n                as[i]=\\'0\\'+(as[i]-\\'0\\'+a)%10;\\n            q.push(as);\\n            q.push(cur.substr(n-b,b)+cur.substr(0,n-b));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925101,
                "title": "golang-0ms-solution",
                "content": "```go\\nfunc findLexSmallestString(s string, a int, b int) string {\\n\\tif a == 3 || a == 7 || a == 9 {\\n\\t\\ta = 1\\n\\t}\\n\\tif a == 4 || a == 6 || a == 8 {\\n\\t\\ta = 2\\n\\t}\\n\\t// a in [1,2,5] now\\n\\n\\tsmallest := s\\n\\tprocessed := make([]bool, len(s))\\n\\tfor i := 0; processed[i%len(s)] == false; i += b {\\n\\t\\tindex := i % len(s)\\n\\t\\tprocessed[index] = true\\n\\t\\tif cur := minimizing(s[len(s)-index:]+s[:len(s)-index], a, b%2 == 1); cur < smallest {\\n\\t\\t\\tsmallest = cur\\n\\t\\t}\\n\\t}\\n\\treturn smallest\\n}\\n\\nfunc minimizing(original string, step int, changePrev bool) string {\\n\\tinRune := []rune(original)\\n\\tminus := rune(0)\\n\\tminusPrev := rune(0)\\n\\tswitch step {\\n\\tcase 1:\\n\\t\\tminus = inRune[1] - \\'0\\'\\n\\t\\tminusPrev = inRune[0] - \\'0\\'\\n\\tcase 2:\\n\\t\\tminus = inRune[1] - \\'0\\'\\n\\t\\tminusPrev = inRune[0] - \\'0\\'\\n\\t\\tif minus%2 == 1 {\\n\\t\\t\\tminus--\\n\\t\\t}\\n\\t\\tif minusPrev%2 == 1 {\\n\\t\\t\\tminusPrev--\\n\\t\\t}\\n\\tcase 5:\\n\\t\\tif inRune[1] >= \\'5\\' {\\n\\t\\t\\tminus = 5\\n\\t\\t}\\n\\t\\tif inRune[0] >= \\'5\\' {\\n\\t\\t\\tminusPrev = 5\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(inRune); i += 2 {\\n\\t\\tinRune[i] -= minus\\n\\t\\tif inRune[i] < \\'0\\' {\\n\\t\\t\\tinRune[i] += 10\\n\\t\\t}\\n\\t\\tif changePrev {\\n\\t\\t\\tinRune[i-1] -= minusPrev\\n\\t\\t\\tif inRune[i-1] < \\'0\\' {\\n\\t\\t\\t\\tinRune[i-1] += 10\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn string(inRune)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findLexSmallestString(s string, a int, b int) string {\\n\\tif a == 3 || a == 7 || a == 9 {\\n\\t\\ta = 1\\n\\t}\\n\\tif a == 4 || a == 6 || a == 8 {\\n\\t\\ta = 2\\n\\t}\\n\\t// a in [1,2,5] now\\n\\n\\tsmallest := s\\n\\tprocessed := make([]bool, len(s))\\n\\tfor i := 0; processed[i%len(s)] == false; i += b {\\n\\t\\tindex := i % len(s)\\n\\t\\tprocessed[index] = true\\n\\t\\tif cur := minimizing(s[len(s)-index:]+s[:len(s)-index], a, b%2 == 1); cur < smallest {\\n\\t\\t\\tsmallest = cur\\n\\t\\t}\\n\\t}\\n\\treturn smallest\\n}\\n\\nfunc minimizing(original string, step int, changePrev bool) string {\\n\\tinRune := []rune(original)\\n\\tminus := rune(0)\\n\\tminusPrev := rune(0)\\n\\tswitch step {\\n\\tcase 1:\\n\\t\\tminus = inRune[1] - \\'0\\'\\n\\t\\tminusPrev = inRune[0] - \\'0\\'\\n\\tcase 2:\\n\\t\\tminus = inRune[1] - \\'0\\'\\n\\t\\tminusPrev = inRune[0] - \\'0\\'\\n\\t\\tif minus%2 == 1 {\\n\\t\\t\\tminus--\\n\\t\\t}\\n\\t\\tif minusPrev%2 == 1 {\\n\\t\\t\\tminusPrev--\\n\\t\\t}\\n\\tcase 5:\\n\\t\\tif inRune[1] >= \\'5\\' {\\n\\t\\t\\tminus = 5\\n\\t\\t}\\n\\t\\tif inRune[0] >= \\'5\\' {\\n\\t\\t\\tminusPrev = 5\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(inRune); i += 2 {\\n\\t\\tinRune[i] -= minus\\n\\t\\tif inRune[i] < \\'0\\' {\\n\\t\\t\\tinRune[i] += 10\\n\\t\\t}\\n\\t\\tif changePrev {\\n\\t\\t\\tinRune[i-1] -= minusPrev\\n\\t\\t\\tif inRune[i-1] < \\'0\\' {\\n\\t\\t\\t\\tinRune[i-1] += 10\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn string(inRune)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 901826,
                "title": "java-4ms-100-o-n-2-gcd-n-b-time-with-full-comments",
                "content": "```\\nclass Solution {\\n    public String findLexSmallestString(String ss, int a, int b) {\\n        \\n        StringBuilder temp = new StringBuilder(ss);\\n        StringBuilder ans = temp;\\n        int n = ss.length();\\n        \\n        do{\\n            \\n            StringBuilder s = new StringBuilder(temp);\\n\\t\\t\\t\\n            // extract the int value from index 1\\n            int x = (int)(s.charAt(1)-\\'0\\');\\n            int whichMultiple = 0;\\n            int zz = x;\\n\\t\\t\\t\\n            // find out which multiple of \\'a\\' should be added to the index1 so that it becomes minimum\\n\\t\\t\\t// here \\'whichMultiple\\' variable represent that value (i\\'th multiple of  \\'a\\')\\n            for(int i=0;i<10;i++){\\n                int z = ((i*a)+x)%10;\\n                if(z<zz){\\n                    zz = z;\\n                    whichMultiple = i;\\n                }\\n            }\\n            \\n\\t\\t\\t// then add that multiple of \\'a\\' to all odd index values and take the last digit as we have to cycle back to 0 after crossing 9\\n            for(int i=0;i<n;i++){\\n                if(i%2==1){\\n                    s.setCharAt(i,(char)((((whichMultiple*a)+(s.charAt(i)-\\'0\\'))%10)+\\'0\\'));\\n                }\\n            }\\n            \\n\\t\\t\\t// Repeat the above process for even index values if b is odd\\n            if(b%2==1){\\n                int y = s.charAt(0)-\\'0\\';\\n                int whichMultiple2 = 0;\\n                int ww = y;\\n                for(int i=0;i<10;i++){\\n                    int z = ((i*a)+y)%10;\\n                    if(z<ww){\\n                        ww = z;\\n                        whichMultiple2 = i;\\n                    }\\n                }\\n                for(int i=0;i<n;i++){\\n                    if(i%2==0){\\n                        s.setCharAt(i,(char)((((whichMultiple2*a)+(s.charAt(i)-\\'0\\'))%10)+\\'0\\'));\\n                    }\\n                } \\n            }\\n            \\n\\t\\t\\t// finally compare the modified string( variable \\'s\\') to the \\'ans\\' string which stores smallest string found till now\\n\\t\\t\\t// update the \\'ans\\' if currently modified string( variable \\'s\\') is smaller than it.\\n            if(ans.compareTo(s)>0){\\n                ans = s;\\n            }\\n            \\n\\t\\t\\t\\n\\t\\t\\t// rotate the original string \\'b\\' times to the right\\n            temp.insert(0,temp.substring(n-b,n)); // take last \\'b\\' characters and append them to the head(starting od string)\\n            temp.delete(n,n+b); // delete those last \\'b\\' characters\\n            \\n        }while(!temp.toString().equals(ss)); // continue this process until the the \\'temp\\' string becomes equal to the input string( variable \\'ss\\') \\n\\t\\t// which indicates that we have iterated through all possible different strings (which will be n/gcd(n,b), here n is size of input string)\\n        \\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String ss, int a, int b) {\\n        \\n        StringBuilder temp = new StringBuilder(ss);\\n        StringBuilder ans = temp;\\n        int n = ss.length();\\n        \\n        do{\\n            \\n            StringBuilder s = new StringBuilder(temp);\\n\\t\\t\\t\\n            // extract the int value from index 1\\n            int x = (int)(s.charAt(1)-\\'0\\');\\n            int whichMultiple = 0;\\n            int zz = x;\\n\\t\\t\\t\\n            // find out which multiple of \\'a\\' should be added to the index1 so that it becomes minimum\\n\\t\\t\\t// here \\'whichMultiple\\' variable represent that value (i\\'th multiple of  \\'a\\')\\n            for(int i=0;i<10;i++){\\n                int z = ((i*a)+x)%10;\\n                if(z<zz){\\n                    zz = z;\\n                    whichMultiple = i;\\n                }\\n            }\\n            \\n\\t\\t\\t// then add that multiple of \\'a\\' to all odd index values and take the last digit as we have to cycle back to 0 after crossing 9\\n            for(int i=0;i<n;i++){\\n                if(i%2==1){\\n                    s.setCharAt(i,(char)((((whichMultiple*a)+(s.charAt(i)-\\'0\\'))%10)+\\'0\\'));\\n                }\\n            }\\n            \\n\\t\\t\\t// Repeat the above process for even index values if b is odd\\n            if(b%2==1){\\n                int y = s.charAt(0)-\\'0\\';\\n                int whichMultiple2 = 0;\\n                int ww = y;\\n                for(int i=0;i<10;i++){\\n                    int z = ((i*a)+y)%10;\\n                    if(z<ww){\\n                        ww = z;\\n                        whichMultiple2 = i;\\n                    }\\n                }\\n                for(int i=0;i<n;i++){\\n                    if(i%2==0){\\n                        s.setCharAt(i,(char)((((whichMultiple2*a)+(s.charAt(i)-\\'0\\'))%10)+\\'0\\'));\\n                    }\\n                } \\n            }\\n            \\n\\t\\t\\t// finally compare the modified string( variable \\'s\\') to the \\'ans\\' string which stores smallest string found till now\\n\\t\\t\\t// update the \\'ans\\' if currently modified string( variable \\'s\\') is smaller than it.\\n            if(ans.compareTo(s)>0){\\n                ans = s;\\n            }\\n            \\n\\t\\t\\t\\n\\t\\t\\t// rotate the original string \\'b\\' times to the right\\n            temp.insert(0,temp.substring(n-b,n)); // take last \\'b\\' characters and append them to the head(starting od string)\\n            temp.delete(n,n+b); // delete those last \\'b\\' characters\\n            \\n        }while(!temp.toString().equals(ss)); // continue this process until the the \\'temp\\' string becomes equal to the input string( variable \\'ss\\') \\n\\t\\t// which indicates that we have iterated through all possible different strings (which will be n/gcd(n,b), here n is size of input string)\\n        \\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899703,
                "title": "simple-bfs-solution-complete-search",
                "content": "Visualize this problem in like a graph.\\n1. Each node\\'s value will be a possible string\\n2. Each edge is an operation (\\'add a\\' or \\'rotate by b\\')\\n3. Every node will have only two children (\\'add a\\' or \\'rotate by b\\')\\n\\nNow we have to traverse this whole directed graph and find the minimum node, that means the lexicographically smallest string.\\n\\nSince there are directed edges and two children only, I thought at first that it\\'ll be a binary tree. But nope. Since we have modulus in add a, hence doing add a operation can bring us back to some already seen string. Hence there may be directed cycles. Hence it is a graph. (Also rotate by b will obviously cause cycles to exist.)\\n\\nFinally,\\nTo find minimum node in a graph we use BFS/DFS. C++ code below - \\n\\n```\\nclass Solution {\\npublic:\\n    string add(string s, int a){\\n        for(int i=1; i<s.size(); i+=2){\\n            s[i] = \\'0\\'+(s[i]-\\'0\\'+a)%10;\\n        }\\n        return s;\\n    }\\n    string rot(string s, int b){\\n        rotate(s.begin(), s.end()-b, s.end());\\n        return s;\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        set<string> visited;\\n        string ans = s;\\n        queue<string> q;\\n        \\n        q.push(s);\\n        while(!q.empty()){\\n            string curr = q.front();\\n            q.pop();\\n            \\n            if(visited.count(curr)>0) continue;\\n            else visited.insert(curr);\\n            \\n            //work on curr\\n            ans = min(ans,curr);\\n            \\n            //child node 1\\n            q.push(add(curr,a));\\n            \\n            //child node 2\\n            q.push(rot(curr,b));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nNote : C++ automatically compares strings lexicographically when I use min() function.\\n\\nP.S : Please suggest if any changes/improvements/corrections are required.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string add(string s, int a){\\n        for(int i=1; i<s.size(); i+=2){\\n            s[i] = \\'0\\'+(s[i]-\\'0\\'+a)%10;\\n        }\\n        return s;\\n    }\\n    string rot(string s, int b){\\n        rotate(s.begin(), s.end()-b, s.end());\\n        return s;\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        set<string> visited;\\n        string ans = s;\\n        queue<string> q;\\n        \\n        q.push(s);\\n        while(!q.empty()){\\n            string curr = q.front();\\n            q.pop();\\n            \\n            if(visited.count(curr)>0) continue;\\n            else visited.insert(curr);\\n            \\n            //work on curr\\n            ans = min(ans,curr);\\n            \\n            //child node 1\\n            q.push(add(curr,a));\\n            \\n            //child node 2\\n            q.push(rot(curr,b));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899698,
                "title": "c-easy-to-understand-brute-force-with-helper-functions-with-comments",
                "content": "1. Keep a map to check if a pattern has been visited.\\n2. Apply add and rotate on each string.\\n3. Keep track of lexicographically shortest string encountered until now between original string, added string and rotated string.\\n4. Resursively add and rotate, until any of the patterns repeat themselves.\\n\\n```\\nclass Solution {\\npublic:\\n    string add(string s, int a){\\n        int i;\\n        string r;\\n        for(i = 0; i < s.size(); i++) {\\n            if(i % 2 == 0) {\\n                r += s[i];\\n            }else{\\n                r += \\'0\\' +  ( ( (s[i] - \\'0\\') + a ) % 10);\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    string rotate(string s, int b){\\n        return s.substr(b, s.size() - b) + s.substr(0, b);\\n    }\\n    \\n    string F(string s, int a, int b, string m, map <string, bool> &M)\\n    {\\n        if(M.find(s) != M.end()) {\\n            return m;\\n        }\\n        M[s] = true;\\n\\n        string ad = add(s, a);\\n        string ro = rotate(s, b);\\n         \\n        if (ro < ad && ro < s) {\\n            m = ro;\\n        }\\n        else if (ad < s && ad < ro) {\\n            m = ad;\\n        }else {\\n            m = s;\\n        }\\n        \\n        string retr = F(ro, a, b, m, M);\\n        string reta = F(ad, a, b , m , M);\\n       \\n        return min(retr, reta);\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        string mx; // minimum string encountered until now\\n        map <string, bool> M; // a map of any string that has been visited until now\\n        return F(s, a, b, mx, M);\\n    }\\n};\\n```\\n\\n**If you liked the solution, Kindly upvote, thank you**!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string add(string s, int a){\\n        int i;\\n        string r;\\n        for(i = 0; i < s.size(); i++) {\\n            if(i % 2 == 0) {\\n                r += s[i];\\n            }else{\\n                r += \\'0\\' +  ( ( (s[i] - \\'0\\') + a ) % 10);\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    string rotate(string s, int b){\\n        return s.substr(b, s.size() - b) + s.substr(0, b);\\n    }\\n    \\n    string F(string s, int a, int b, string m, map <string, bool> &M)\\n    {\\n        if(M.find(s) != M.end()) {\\n            return m;\\n        }\\n        M[s] = true;\\n\\n        string ad = add(s, a);\\n        string ro = rotate(s, b);\\n         \\n        if (ro < ad && ro < s) {\\n            m = ro;\\n        }\\n        else if (ad < s && ad < ro) {\\n            m = ad;\\n        }else {\\n            m = s;\\n        }\\n        \\n        string retr = F(ro, a, b, m, M);\\n        string reta = F(ad, a, b , m , M);\\n       \\n        return min(retr, reta);\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        string mx; // minimum string encountered until now\\n        map <string, bool> M; // a map of any string that has been visited until now\\n        return F(s, a, b, mx, M);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899606,
                "title": "simple-bfs-solution-with-explanation-in-java",
                "content": "Intuition:\\n- There are limited number of transformations.\\n- Using BFS to iterate through all possible transformations.\\n- Record the lexicographically smallest.\\n\\n```java\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Queue<String> queue = new ArrayDeque<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.offer(s);\\n        visited.add(s);\\n        \\n        String rst = s;\\n        while (!queue.isEmpty()) {\\n            String curr = queue.poll();\\n            if (curr.compareTo(rst) < 0) {\\n                rst = curr;\\n            }\\n            \\n            String opA = performA(curr, a);\\n            if (visited.add(opA)) {\\n                queue.offer(opA);\\n            }\\n            \\n            String opB = performB(curr, b);\\n            if (visited.add(opB)) {\\n                queue.offer(opB);\\n            }\\n        }\\n        \\n        return rst;\\n    }\\n    \\n    private String performA(String s, int a) {\\n        int n = s.length();\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 1) {\\n                chars[i] = (char)((chars[i] - \\'0\\' + a) % 10 + \\'0\\');\\n            }\\n        }\\n        \\n        return new String(chars);\\n    }\\n    \\n    private String performB(String s, int b) {\\n        int n = s.length();\\n        return s.substring(n - b) + s.substring(0, n - b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Queue<String> queue = new ArrayDeque<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.offer(s);\\n        visited.add(s);\\n        \\n        String rst = s;\\n        while (!queue.isEmpty()) {\\n            String curr = queue.poll();\\n            if (curr.compareTo(rst) < 0) {\\n                rst = curr;\\n            }\\n            \\n            String opA = performA(curr, a);\\n            if (visited.add(opA)) {\\n                queue.offer(opA);\\n            }\\n            \\n            String opB = performB(curr, b);\\n            if (visited.add(opB)) {\\n                queue.offer(opB);\\n            }\\n        }\\n        \\n        return rst;\\n    }\\n    \\n    private String performA(String s, int a) {\\n        int n = s.length();\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 1) {\\n                chars[i] = (char)((chars[i] - \\'0\\' + a) % 10 + \\'0\\');\\n            }\\n        }\\n        \\n        return new String(chars);\\n    }\\n    \\n    private String performB(String s, int b) {\\n        int n = s.length();\\n        return s.substring(n - b) + s.substring(0, n - b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899580,
                "title": "java-dfs-beats-100-in-at-least-half-the-submissions-and-bfs-beats-33",
                "content": "DFS -\\n```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Set<String> seen = new HashSet<>();\\n        seen.add(s);\\n        \\n        return dfs(s, a, b, seen);\\n    }\\n    \\n    private String dfs(String s, int a, int b, Set<String> seen) {\\n        String ans = s;\\n        String s1 = op1(s, a);\\n        if (!seen.contains(s1)) {\\n            seen.add(s1);\\n            s1 = dfs(s1, a, b, seen);\\n            if (ans.compareTo(s1) > 0) {\\n                ans = s1;\\n            }\\n        }\\n        \\n        s1 = op2(s, b);\\n        if (!seen.contains(s1)) {\\n            seen.add(s1);\\n            s1 = dfs(s1, a, b, seen);\\n            if (ans.compareTo(s1) > 0) {\\n                ans = s1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private String op1(String s, int a) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        while(i < s.length()) {\\n            if (i%2 == 0) {\\n                sb.append(s.charAt(i));\\n                i++;\\n                continue;\\n            }\\n            int ch = (s.charAt(i)-\\'0\\')+a;\\n            ch = ch%10;\\n            sb.append(\"\"+ch);\\n            i++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private String op2(String s, int b) {\\n        String s1 = reverse(s.substring(0, b));\\n        String s2 = reverse(s.substring(b));\\n        StringBuilder sb = new StringBuilder(s1+s2);\\n        \\n        return sb.reverse().toString();\\n    }\\n    \\n    private String reverse(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\nBFS -\\n```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Set<String> seen = new HashSet<>();\\n        seen.add(s);\\n        \\n        String ans = s;\\n        Queue<String> q = new LinkedList<>();\\n        q.add(s);\\n        while(!q.isEmpty()) {\\n            String next = q.remove();\\n            \\n            String s1 = op1(next, a);\\n            if (!seen.contains(s1)) {\\n                if (ans.compareTo(s1) > 0) {\\n                    ans = s1;\\n                }\\n                q.add(s1);\\n                seen.add(s1);\\n            }\\n            \\n            s1 = op2(next, b);\\n            if (!seen.contains(s1)) {\\n                if (ans.compareTo(s1) > 0) {\\n                    ans = s1;\\n                }\\n                q.add(s1);\\n                seen.add(s1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private String op1(String s, int a) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        while(i < s.length()) {\\n            if (i%2 == 0) {\\n                sb.append(s.charAt(i));\\n                i++;\\n                continue;\\n            }\\n            int ch = (s.charAt(i)-\\'0\\')+a;\\n            ch = ch%10;\\n            sb.append(\"\"+ch);\\n            i++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private String op2(String s, int b) {\\n        String s1 = reverse(s.substring(0, b));\\n        String s2 = reverse(s.substring(b));\\n        StringBuilder sb = new StringBuilder(s1+s2);\\n        \\n        return sb.reverse().toString();\\n    }\\n    \\n    private String reverse(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Set<String> seen = new HashSet<>();\\n        seen.add(s);\\n        \\n        return dfs(s, a, b, seen);\\n    }\\n    \\n    private String dfs(String s, int a, int b, Set<String> seen) {\\n        String ans = s;\\n        String s1 = op1(s, a);\\n        if (!seen.contains(s1)) {\\n            seen.add(s1);\\n            s1 = dfs(s1, a, b, seen);\\n            if (ans.compareTo(s1) > 0) {\\n                ans = s1;\\n            }\\n        }\\n        \\n        s1 = op2(s, b);\\n        if (!seen.contains(s1)) {\\n            seen.add(s1);\\n            s1 = dfs(s1, a, b, seen);\\n            if (ans.compareTo(s1) > 0) {\\n                ans = s1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private String op1(String s, int a) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        while(i < s.length()) {\\n            if (i%2 == 0) {\\n                sb.append(s.charAt(i));\\n                i++;\\n                continue;\\n            }\\n            int ch = (s.charAt(i)-\\'0\\')+a;\\n            ch = ch%10;\\n            sb.append(\"\"+ch);\\n            i++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private String op2(String s, int b) {\\n        String s1 = reverse(s.substring(0, b));\\n        String s2 = reverse(s.substring(b));\\n        StringBuilder sb = new StringBuilder(s1+s2);\\n        \\n        return sb.reverse().toString();\\n    }\\n    \\n    private String reverse(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Set<String> seen = new HashSet<>();\\n        seen.add(s);\\n        \\n        String ans = s;\\n        Queue<String> q = new LinkedList<>();\\n        q.add(s);\\n        while(!q.isEmpty()) {\\n            String next = q.remove();\\n            \\n            String s1 = op1(next, a);\\n            if (!seen.contains(s1)) {\\n                if (ans.compareTo(s1) > 0) {\\n                    ans = s1;\\n                }\\n                q.add(s1);\\n                seen.add(s1);\\n            }\\n            \\n            s1 = op2(next, b);\\n            if (!seen.contains(s1)) {\\n                if (ans.compareTo(s1) > 0) {\\n                    ans = s1;\\n                }\\n                q.add(s1);\\n                seen.add(s1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private String op1(String s, int a) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        while(i < s.length()) {\\n            if (i%2 == 0) {\\n                sb.append(s.charAt(i));\\n                i++;\\n                continue;\\n            }\\n            int ch = (s.charAt(i)-\\'0\\')+a;\\n            ch = ch%10;\\n            sb.append(\"\"+ch);\\n            i++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private String op2(String s, int b) {\\n        String s1 = reverse(s.substring(0, b));\\n        String s2 = reverse(s.substring(b));\\n        StringBuilder sb = new StringBuilder(s1+s2);\\n        \\n        return sb.reverse().toString();\\n    }\\n    \\n    private String reverse(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899561,
                "title": "easy-backtracking-c",
                "content": "* Try all the combinations by adding `a` one time and rotating by `b` another time, on the same string.\\n* Since we need to take mod (`%`) after adding `b`, we will not get infinite number of combinations, the search space will exhaust at a time.\\n*  We just have to keep track of all the strings searched till that point of time.\\n*  We keep the minimum string in the `res`.\\n\\n```\\nclass Solution {\\n    int n;\\n    unordered_set<string> set;\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        n = s.length();\\n        string res(n, \\'9\\');\\n\\t\\t//just to create a string with maximum possible number\\n        backtrack(s, a, b, res);\\n        return res;\\n    }\\n    void backtrack(string& s, int a, int b, string& res) {\\n        if(set.count(s)) return;\\n        set.emplace(s);\\n        if(s < res) {\\n            res = s;\\n        }\\n        string s1 = s;\\n\\t\\t//this string is for addition with a\\n        for(int i = 1; i < n; i+=2) {\\n            int c = s1[i] - \\'0\\';\\n            s1[i] = ((c+a)%10) + \\'0\\';\\n        }\\n        string s2 = s.substr(n-b, b) + s.substr(0, n-b);\\n\\t\\t//this string is for rotation by b\\n        backtrack(s1, a, b, res);\\n        backtrack(s2, a, b, res);\\n    }\\n};\\n```\\n**Please upvote if you found it helpful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    unordered_set<string> set;\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        n = s.length();\\n        string res(n, \\'9\\');\\n\\t\\t//just to create a string with maximum possible number\\n        backtrack(s, a, b, res);\\n        return res;\\n    }\\n    void backtrack(string& s, int a, int b, string& res) {\\n        if(set.count(s)) return;\\n        set.emplace(s);\\n        if(s < res) {\\n            res = s;\\n        }\\n        string s1 = s;\\n\\t\\t//this string is for addition with a\\n        for(int i = 1; i < n; i+=2) {\\n            int c = s1[i] - \\'0\\';\\n            s1[i] = ((c+a)%10) + \\'0\\';\\n        }\\n        string s2 = s.substr(n-b, b) + s.substr(0, n-b);\\n\\t\\t//this string is for rotation by b\\n        backtrack(s1, a, b, res);\\n        backtrack(s2, a, b, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899488,
                "title": "c-straightforward-bfs-solution",
                "content": "```\\npublic class Solution\\n    {\\n\\n        private string Add(ref string s, int a)\\n        {\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 1; i < s.Length; i += 2)\\n            {\\n                var curr = sb[i] - \\'0\\';\\n                curr += a;\\n                curr %= 10;\\n                sb[i] = (char) (\\'0\\' + curr);\\n\\n            }\\n\\n            return sb.ToString();\\n        }\\n\\n\\n\\n        public string FindLexSmallestString(string s, int a, int b)\\n        {\\n            string res = s;\\n            ISet<string> visited = new HashSet<string>();\\n            visited.Add(s);\\n            Queue<string> bfs = new Queue<string>();\\n            bfs.Enqueue(s);\\n\\n            while (bfs.Count != 0)\\n            {\\n                var curr = bfs.Dequeue();\\n                if (string.CompareOrdinal(curr, res) < 0)\\n                {\\n                    res = curr;\\n                }\\n                var cand1 = curr.Substring(s.Length - b, b) + curr.Substring(0, s.Length - b);\\n                var cand2 = Add(ref curr, a);\\n\\n                if (visited.Add(cand1))\\n                {\\n                    bfs.Enqueue(cand1);\\n                }\\n\\n                if (visited.Add(cand2))\\n                {\\n                    bfs.Enqueue(cand2);\\n                }\\n            }\\n\\n\\n            return res;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution\\n    {\\n\\n        private string Add(ref string s, int a)\\n        {\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 1; i < s.Length; i += 2)\\n            {\\n                var curr = sb[i] - \\'0\\';\\n                curr += a;\\n                curr %= 10;\\n                sb[i] = (char) (\\'0\\' + curr);\\n\\n            }\\n\\n            return sb.ToString();\\n        }\\n\\n\\n\\n        public string FindLexSmallestString(string s, int a, int b)\\n        {\\n            string res = s;\\n            ISet<string> visited = new HashSet<string>();\\n            visited.Add(s);\\n            Queue<string> bfs = new Queue<string>();\\n            bfs.Enqueue(s);\\n\\n            while (bfs.Count != 0)\\n            {\\n                var curr = bfs.Dequeue();\\n                if (string.CompareOrdinal(curr, res) < 0)\\n                {\\n                    res = curr;\\n                }\\n                var cand1 = curr.Substring(s.Length - b, b) + curr.Substring(0, s.Length - b);\\n                var cand2 = Add(ref curr, a);\\n\\n                if (visited.Add(cand1))\\n                {\\n                    bfs.Enqueue(cand1);\\n                }\\n\\n                if (visited.Add(cand2))\\n                {\\n                    bfs.Enqueue(cand2);\\n                }\\n            }\\n\\n\\n            return res;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549214,
                "title": "simplest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        unordered_set<string> st;\\n        b = b%s.size();\\n        \\n        queue<string> q;\\n        q.push(s);\\n        st.insert(s);\\n        while(q.size())\\n        {\\n            string curr = q.front();\\n            q.pop();\\n            string rot = curr; \\n            for(int i = 1; i<curr.size();i=i+2)\\n            {\\n                int z = (curr[i] -\\'0\\'+ a)%10 ; \\n                curr[i] = char(z+48);\\n            }\\n            reverse(rot.begin(), rot.end());\\n            reverse(rot.begin(), rot.begin() + b);\\n            reverse(rot.begin() + b, rot.end());\\n            if(st.find(rot)==st.end())\\n            {\\n                q.push(rot);\\n                st.insert(rot);\\n            }\\n            if(st.find(curr)==st.end())\\n            {\\n                q.push(curr);\\n                st.insert(curr);\\n            }\\n                 \\n        }\\n       vector<string> v(st.begin(),st.end());\\n       sort(v.begin(),v.end());\\n       return v[0];\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        unordered_set<string> st;\\n        b = b%s.size();\\n        \\n        queue<string> q;\\n        q.push(s);\\n        st.insert(s);\\n        while(q.size())\\n        {\\n            string curr = q.front();\\n            q.pop();\\n            string rot = curr; \\n            for(int i = 1; i<curr.size();i=i+2)\\n            {\\n                int z = (curr[i] -\\'0\\'+ a)%10 ; \\n                curr[i] = char(z+48);\\n            }\\n            reverse(rot.begin(), rot.end());\\n            reverse(rot.begin(), rot.begin() + b);\\n            reverse(rot.begin() + b, rot.end());\\n            if(st.find(rot)==st.end())\\n            {\\n                q.push(rot);\\n                st.insert(rot);\\n            }\\n            if(st.find(curr)==st.end())\\n            {\\n                q.push(curr);\\n                st.insert(curr);\\n            }\\n                 \\n        }\\n       vector<string> v(st.begin(),st.end());\\n       sort(v.begin(),v.end());\\n       return v[0];\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035549,
                "title": "c-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string> q;\\n        q.push(s);\\n        set<string> st;\\n        string res = q.front();\\n        while(!q.empty()){\\n            string temp = q.front();\\n            res = min(res,temp);\\n            q.pop();\\n            string add=temp;\\n            for(int i=1;i<add.size();i+=2){\\n                int x = add[i]-\\'0\\';\\n                x = (x+a)%10;\\n                add[i] = x+\\'0\\';\\n            }\\n            if(st.find(add)==st.end()){\\n                st.insert(add);\\n                q.push(add);\\n            }\\n            string str2 = temp.substr(0,temp.size()-b);\\n            string str1 = temp.substr(temp.size()-b);\\n            string rotate = str1+str2;\\n            if(st.find(rotate)==st.end()){\\n                st.insert(rotate);\\n                q.push(rotate);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string> q;\\n        q.push(s);\\n        set<string> st;\\n        string res = q.front();\\n        while(!q.empty()){\\n            string temp = q.front();\\n            res = min(res,temp);\\n            q.pop();\\n            string add=temp;\\n            for(int i=1;i<add.size();i+=2){\\n                int x = add[i]-\\'0\\';\\n                x = (x+a)%10;\\n                add[i] = x+\\'0\\';\\n            }\\n            if(st.find(add)==st.end()){\\n                st.insert(add);\\n                q.push(add);\\n            }\\n            string str2 = temp.substr(0,temp.size()-b);\\n            string str1 = temp.substr(temp.size()-b);\\n            string rotate = str1+str2;\\n            if(st.find(rotate)==st.end()){\\n                st.insert(rotate);\\n                q.push(rotate);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104786,
                "title": "easy-c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string ans = s;\\n        int len = s.size();\\n        queue<string> q;\\n        q.push(s);\\n        set<string> vis;\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            for(int i = 0; i < n; i++)\\n            {\\n                string t = q.front();\\n                ans = min(ans, t);\\n                q.pop();\\n                \\n                if(vis.count(t))\\n                    continue;\\n                vis.insert(t);\\n                \\n                // 1st operation\\n                string tt = t;\\n                for(int j = 0; j < len; j++)\\n                {\\n                    if(j & 1)\\n                    {\\n                        int num = ((tt[j] - \\'0\\') + a) % 10;\\n                        tt[j] = (num + \\'0\\');\\n                    }\\n                }\\n                q.push(tt);\\n                \\n                // 2nd operation\\n                tt = t;\\n                for(int j = 0; j < b; j++)\\n                {\\n                    char c = tt.back();\\n                    tt.pop_back();\\n                    tt = c + tt;\\n                }\\n                q.push(tt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string ans = s;\\n        int len = s.size();\\n        queue<string> q;\\n        q.push(s);\\n        set<string> vis;\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            for(int i = 0; i < n; i++)\\n            {\\n                string t = q.front();\\n                ans = min(ans, t);\\n                q.pop();\\n                \\n                if(vis.count(t))\\n                    continue;\\n                vis.insert(t);\\n                \\n                // 1st operation\\n                string tt = t;\\n                for(int j = 0; j < len; j++)\\n                {\\n                    if(j & 1)\\n                    {\\n                        int num = ((tt[j] - \\'0\\') + a) % 10;\\n                        tt[j] = (num + \\'0\\');\\n                    }\\n                }\\n                q.push(tt);\\n                \\n                // 2nd operation\\n                tt = t;\\n                for(int j = 0; j < b; j++)\\n                {\\n                    char c = tt.back();\\n                    tt.pop_back();\\n                    tt = c + tt;\\n                }\\n                q.push(tt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968273,
                "title": "c-bfs-commented",
                "content": "`!!!Please Upvote if you really find useful....`\\n.1.Genrate two function add and rotate as per question asked to add every odd pos, and rotate b times\\n2.BFS all possiblity along with inserting in set to check element created must be unique in term to finding\\n3.Inseting in set is impotant as it help  from infnite loop in queue and give smallest lexo element in O(log n) time\\n\\n\\n```\\nclass Solution {\\npublic:\\n    //Adding every odd pos\\n    string add(string str,int a)\\n    {\\n        int n=str.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==1)\\n            {\\n                int x=((str[i]-\\'0\\')+a)%10;\\n                str[i]=x+\\'0\\';\\n                \\n            }\\n        }\\n        return str;\\n    }\\n    //Rotate by swapping metod \\n    string rotate(string str,int b)\\n    {\\n        int n=str.length();\\n        for(int i=1;i<=b;i++)\\n        {\\n            for(int j=0;j<n-1;j++)\\n            {\\n                swap(str[j],str[n-1]);\\n            }\\n        }\\n        return str;\\n    }\\n    \\n    //BFS code\\n    string findLexSmallestString(string str, int a, int b) {\\n        //Set for uniquely store element\\n        set<string>s;\\n        queue<string>q;\\n        q.push(str);\\n        while(q.size())\\n        {\\n            string str1=q.front();\\n            q.pop();\\n            string str2=add(str1,a);\\n            string str3=rotate(str1,b);\\n            if(s.count(str2)==0)\\n            {\\n               s.insert(str2);\\n                q.push(str2);\\n            }\\n            if(s.count(str3)==0)\\n            {\\n                s.insert(str3);\\n                q.push(str3);\\n            }\\n            \\n        }\\n        \\n        return *(s.begin());\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Adding every odd pos\\n    string add(string str,int a)\\n    {\\n        int n=str.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==1)\\n            {\\n                int x=((str[i]-\\'0\\')+a)%10;\\n                str[i]=x+\\'0\\';\\n                \\n            }\\n        }\\n        return str;\\n    }\\n    //Rotate by swapping metod \\n    string rotate(string str,int b)\\n    {\\n        int n=str.length();\\n        for(int i=1;i<=b;i++)\\n        {\\n            for(int j=0;j<n-1;j++)\\n            {\\n                swap(str[j],str[n-1]);\\n            }\\n        }\\n        return str;\\n    }\\n    \\n    //BFS code\\n    string findLexSmallestString(string str, int a, int b) {\\n        //Set for uniquely store element\\n        set<string>s;\\n        queue<string>q;\\n        q.push(str);\\n        while(q.size())\\n        {\\n            string str1=q.front();\\n            q.pop();\\n            string str2=add(str1,a);\\n            string str3=rotate(str1,b);\\n            if(s.count(str2)==0)\\n            {\\n               s.insert(str2);\\n                q.push(str2);\\n            }\\n            if(s.count(str3)==0)\\n            {\\n                s.insert(str3);\\n                q.push(str3);\\n            }\\n            \\n        }\\n        \\n        return *(s.begin());\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630271,
                "title": "c-string-bfs",
                "content": "**PLEASE UPVOTE IF U LIKE THE SOLUTION.**\\n\\n```\\nclass Solution {\\n    \\n    //create the add function //operation:1\\n    string add(string s,int a)\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i&1)\\n            {\\n                s[i]=(s[i]-\\'0\\'+a)%10+\\'0\\';\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    //create the rotate function //operation:2\\n    string rotate(string s,int b)\\n    {\\n        string res=s.substr(s.length()-b)+s.substr(0,s.length()-b);\\n       return res;\\n    }\\n    \\npublic:\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        //we perform a simple BFS and check from\\n        //all possible conversions from string s\\n        //the lexicographically smallest string possible using any permutations \\n        //of operation 1 and 2\\n        unordered_set<string>vis;\\n        queue<string>q;\\n        vis.insert(s);\\n        q.push(s);\\n        string res=s;\\n        \\n        while(q.size())\\n        {\\n            string curr=q.front();\\n            q.pop();\\n            \\n            string s1=add(curr,a);\\n            string s2=rotate(curr,b);\\n            \\n            //we do the minimum check here\\n            res=min(res,curr);\\n            \\n            if(!vis.count(s1))\\n            {\\n                vis.insert(s1);\\n                q.push(s1);\\n            }\\n            \\n            if(!vis.count(s2))\\n            {\\n                vis.insert(s2);\\n                q.push(s2);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //create the add function //operation:1\\n    string add(string s,int a)\\n    {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i&1)\\n            {\\n                s[i]=(s[i]-\\'0\\'+a)%10+\\'0\\';\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    //create the rotate function //operation:2\\n    string rotate(string s,int b)\\n    {\\n        string res=s.substr(s.length()-b)+s.substr(0,s.length()-b);\\n       return res;\\n    }\\n    \\npublic:\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        //we perform a simple BFS and check from\\n        //all possible conversions from string s\\n        //the lexicographically smallest string possible using any permutations \\n        //of operation 1 and 2\\n        unordered_set<string>vis;\\n        queue<string>q;\\n        vis.insert(s);\\n        q.push(s);\\n        string res=s;\\n        \\n        while(q.size())\\n        {\\n            string curr=q.front();\\n            q.pop();\\n            \\n            string s1=add(curr,a);\\n            string s2=rotate(curr,b);\\n            \\n            //we do the minimum check here\\n            res=min(res,curr);\\n            \\n            if(!vis.count(s1))\\n            {\\n                vis.insert(s1);\\n                q.push(s1);\\n            }\\n            \\n            if(!vis.count(s2))\\n            {\\n                vis.insert(s2);\\n                q.push(s2);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585770,
                "title": "easy-java-solution-bfs",
                "content": "The idea is to generate all possible strings and keep a record of the smallest string found so far.\\nThis can be done like this: for a parent string, there can be 2 child strings by applying operation 1 and operation 2.  So here we can use either BFS or DFS to iterate all strings found and while iterating keep a record of previously found strings to prevent going into an infinite loop.\\n```\\n\\tstatic String op1(String str, int a){\\n        char[] arr = str.toCharArray();\\n        for(int i=1;i<arr.length;i+=2){\\n            arr[i] = (char)((arr[i] -\\'0\\'+a)%10 +\\'0\\');\\n        }\\n        return String.valueOf(arr);\\n    }\\n    \\n    static String op2(String str, int b){\\n        return str.substring(str.length()-b) + str.substring(0,str.length()-b);\\n    }\\n    \\n    public String findLexSmallestString(String s, int a, int b) {\\n        \\n        Queue<String> q = new LinkedList<String>();\\n        HashSet<String> hs = new HashSet<String>();\\n        q.add(s);\\n        String min_str = s;\\n        while(!q.isEmpty()){\\n            String str = q.remove();\\n            if(str.compareTo(min_str)<0) min_str = str;\\n            String s1 = op1(str,a);\\n            if(!hs.contains(s1)){\\n                q.add(s1);\\n                hs.add(s1);\\n            }\\n            String s2 = op2(str,b);\\n            if(!hs.contains(s2)){\\n                q.add(s2);\\n                hs.add(s2);\\n            }\\n        }\\n        return min_str;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tstatic String op1(String str, int a){\\n        char[] arr = str.toCharArray();\\n        for(int i=1;i<arr.length;i+=2){\\n            arr[i] = (char)((arr[i] -\\'0\\'+a)%10 +\\'0\\');\\n        }\\n        return String.valueOf(arr);\\n    }\\n    \\n    static String op2(String str, int b){\\n        return str.substring(str.length()-b) + str.substring(0,str.length()-b);\\n    }\\n    \\n    public String findLexSmallestString(String s, int a, int b) {\\n        \\n        Queue<String> q = new LinkedList<String>();\\n        HashSet<String> hs = new HashSet<String>();\\n        q.add(s);\\n        String min_str = s;\\n        while(!q.isEmpty()){\\n            String str = q.remove();\\n            if(str.compareTo(min_str)<0) min_str = str;\\n            String s1 = op1(str,a);\\n            if(!hs.contains(s1)){\\n                q.add(s1);\\n                hs.add(s1);\\n            }\\n            String s2 = op2(str,b);\\n            if(!hs.contains(s2)){\\n                q.add(s2);\\n                hs.add(s2);\\n            }\\n        }\\n        return min_str;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556642,
                "title": "java-easy-bfs",
                "content": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        //BFS\\n        Queue<String> q = new LinkedList<>();\\n        q.add(s);\\n        Set<String> visited = new HashSet<>();\\n        String ans = s;\\n        while(q.size() > 0){\\n            int count = q.size();\\n            \\n            while(count-- > 0){\\n                String rem = q.remove();\\n                //Compare strings lexicographically\\n                if(ans.compareTo(rem) > 0){\\n                    ans = rem;\\n                }\\n                //First operation\\n                String ns = \"\"; //New String\\n                for(int i = 0; i < rem.length();i++){\\n                    if(i % 2 != 0){\\n                        int d1 = rem.charAt(i) - \\'0\\';\\n                        int d = d1 + a;\\n                        d = d % 10;\\n                        ns = ns + String.valueOf(d);                        \\n                    }\\n                    else{\\n                        ns = ns + \"\"+rem.charAt(i);\\n                    }\\n                }\\n                if(!visited.contains(ns)){\\n                    q.add(ns);\\n                    visited.add(ns);\\n                }\\n                //Second operation\\n                ns = rightrotate(rem,b);\\n                if(!visited.contains(ns)){\\n                    q.add(ns);\\n                    visited.add(ns);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n     String rightrotate(String str, int d){       \\n            d = str.length() - d;\\n            String ans = str.substring(d) + str.substring(0, d);\\n            return ans;\\n    }\\n \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        //BFS\\n        Queue<String> q = new LinkedList<>();\\n        q.add(s);\\n        Set<String> visited = new HashSet<>();\\n        String ans = s;\\n        while(q.size() > 0){\\n            int count = q.size();\\n            \\n            while(count-- > 0){\\n                String rem = q.remove();\\n                //Compare strings lexicographically\\n                if(ans.compareTo(rem) > 0){\\n                    ans = rem;\\n                }\\n                //First operation\\n                String ns = \"\"; //New String\\n                for(int i = 0; i < rem.length();i++){\\n                    if(i % 2 != 0){\\n                        int d1 = rem.charAt(i) - \\'0\\';\\n                        int d = d1 + a;\\n                        d = d % 10;\\n                        ns = ns + String.valueOf(d);                        \\n                    }\\n                    else{\\n                        ns = ns + \"\"+rem.charAt(i);\\n                    }\\n                }\\n                if(!visited.contains(ns)){\\n                    q.add(ns);\\n                    visited.add(ns);\\n                }\\n                //Second operation\\n                ns = rightrotate(rem,b);\\n                if(!visited.contains(ns)){\\n                    q.add(ns);\\n                    visited.add(ns);\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n     String rightrotate(String str, int d){       \\n            d = str.length() - d;\\n            String ans = str.substring(d) + str.substring(0, d);\\n            return ans;\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324353,
                "title": "c-easy-simple-clean-solution-bfs-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string ans = s;\\n        bfs(ans, a, b);\\n        // unordered_set<string> st;\\n        // dfs(s, a, b, st, ans);\\n        return ans;\\n    }\\n    void bfs(string &ans, int a, int b){\\n        queue<string> Q;\\n        unordered_set<string> st;\\n        \\n        Q.push(ans);\\n        while(!Q.empty()){\\n            int sz = Q.size();\\n            for(int i = 0; i < sz; i++){\\n                string s = Q.front();\\n                Q.pop();\\n                if(st.find(s) != st.end())\\n                    continue;\\n                st.insert(s);\\n                Q.push(add(s,a));\\n                Q.push(rotate(s,b));\\n                ans = min(ans, s);\\n            }\\n        }\\n    }\\n    void dfs(string s, int a, int b, unordered_set<string> &st, string &ans){\\n        if(st.find(s) != st.end())\\n            return;\\n        st.insert(s);\\n        ans = min(ans, s);\\n        dfs(add(s, a), a, b, st, ans);\\n        dfs(rotate(s, b), a, b, st, ans);\\n    }\\n    string add(string s, int a){\\n        string ans = s;\\n        for(int i = 0; i < s.size(); i++){\\n            if(i % 2)\\n                ans[i] = (s[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        }\\n        return ans;\\n    }\\n    string rotate(string s, int b){\\n        int n = s.size();\\n        string ans = \"\";\\n        ans += s.substr(n - b);\\n        ans += s.substr(0, n - b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string ans = s;\\n        bfs(ans, a, b);\\n        // unordered_set<string> st;\\n        // dfs(s, a, b, st, ans);\\n        return ans;\\n    }\\n    void bfs(string &ans, int a, int b){\\n        queue<string> Q;\\n        unordered_set<string> st;\\n        \\n        Q.push(ans);\\n        while(!Q.empty()){\\n            int sz = Q.size();\\n            for(int i = 0; i < sz; i++){\\n                string s = Q.front();\\n                Q.pop();\\n                if(st.find(s) != st.end())\\n                    continue;\\n                st.insert(s);\\n                Q.push(add(s,a));\\n                Q.push(rotate(s,b));\\n                ans = min(ans, s);\\n            }\\n        }\\n    }\\n    void dfs(string s, int a, int b, unordered_set<string> &st, string &ans){\\n        if(st.find(s) != st.end())\\n            return;\\n        st.insert(s);\\n        ans = min(ans, s);\\n        dfs(add(s, a), a, b, st, ans);\\n        dfs(rotate(s, b), a, b, st, ans);\\n    }\\n    string add(string s, int a){\\n        string ans = s;\\n        for(int i = 0; i < s.size(); i++){\\n            if(i % 2)\\n                ans[i] = (s[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        }\\n        return ans;\\n    }\\n    string rotate(string s, int b){\\n        int n = s.size();\\n        string ans = \"\";\\n        ans += s.substr(n - b);\\n        ans += s.substr(0, n - b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268313,
                "title": "dfs-java-solution",
                "content": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        ans = s;\\n        HashSet<String> vis = new HashSet<>();\\n        helper(s, a, b, vis);\\n        return ans;\\n    }\\n    \\n    String ans;\\n    public void helper(String s, int a, int b, HashSet<String> vis){\\n        if(vis.contains(s)) return;\\n        if(s.compareTo(ans)<0) ans = s;\\n        vis.add(s);\\n        helper(perform_a(s, a), a, b, vis);\\n        helper(perform_b(s, b), a, b, vis);\\n    }\\n    \\n    public String perform_a(String s, int a){\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int i = 0;\\n        for(char ch:s.toCharArray()){\\n            int x = ch - \\'0\\';\\n            if(i%2!=0) x = (x + a)%10;\\n            sb.append(x+\"\");\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public String perform_b(String str, int b){\\n        String f = str.substring(str.length()-b);\\n        String s = str.substring(0, str.length()-b);\\n        return f + s;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        ans = s;\\n        HashSet<String> vis = new HashSet<>();\\n        helper(s, a, b, vis);\\n        return ans;\\n    }\\n    \\n    String ans;\\n    public void helper(String s, int a, int b, HashSet<String> vis){\\n        if(vis.contains(s)) return;\\n        if(s.compareTo(ans)<0) ans = s;\\n        vis.add(s);\\n        helper(perform_a(s, a), a, b, vis);\\n        helper(perform_b(s, b), a, b, vis);\\n    }\\n    \\n    public String perform_a(String s, int a){\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int i = 0;\\n        for(char ch:s.toCharArray()){\\n            int x = ch - \\'0\\';\\n            if(i%2!=0) x = (x + a)%10;\\n            sb.append(x+\"\");\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public String perform_b(String str, int b){\\n        String f = str.substring(str.length()-b);\\n        String s = str.substring(0, str.length()-b);\\n        return f + s;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178112,
                "title": "java-dfs",
                "content": "class Solution {\\n \\n    String ans=\"z\";\\n        public void dfs(String s,int a,int b,HashSet<String> set)\\n        {\\n            if(set.contains(s))\\n                return;\\n            set.add(s);\\n            String one=add(s,a);\\n            String two=rotate(s,b);\\n           \\n            dfs(one,a,b,set);\\n            dfs(two,a,b,set);\\n        }\\n    \\n    public String add(String s,int a)\\n    {\\n        char temp[]=s.toCharArray();\\n        for(int i=1;i<temp.length;i=i+2)\\n        {\\n            int val=temp[i]-\\'0\\';\\n            val=(val+a)%10;\\n            temp[i]=(char) (val+\\'0\\');\\n        }\\n        \\n        s=new String(temp);\\n      if(ans.compareTo(s)>0)\\n            ans=s;\\n        \\n        return s;\\n    }\\n    public String rotate(String s,int b)\\n    {\\n        if(b<0)\\n            b=b+s.length();\\n        b=b%s.length();\\n        b=s.length()-b;\\n        s=s.substring(b)+s.substring(0,b);\\n        if(ans.compareTo(s)>0)\\n            ans=s;\\n        return s;\\n    }\\n \\n    public String findLexSmallestString(String s, int a, int b) {\\n        \\n        HashSet<String> set=new HashSet<>();\\n        dfs(s,a,b,set);\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n \\n    String ans=\"z\";\\n        public void dfs(String s,int a,int b,HashSet<String> set)\\n        {\\n            if(set.contains(s))\\n                return;\\n            set.add(s);\\n            String one=add(s,a);\\n            String two=rotate(s,b);\\n           \\n            dfs(one,a,b,set);\\n            dfs(two,a,b,set);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1152837,
                "title": "c-using-dfs-both",
                "content": "```\\nclass Solution {\\npublic:\\n    string res;\\n    string add(string s, int a)\\n    {\\n        for(int i=0;i<s.size();i++)\\n            if(i%2) s[i] = ((s[i]-\\'0\\'+a)%10) + \\'0\\';\\n        return s;\\n    }\\n    string rotate(string s, int b)\\n    {\\n        int n = s.size();\\n        string temp = s.substr(n-b);\\n        temp += s.substr(0, n-b);\\n        return temp;\\n    }\\n    void dfs(string s, int a, int b, set<string> &v)\\n    {\\n        if(v.find(s) != v.end()) return;\\n        v.insert(s);\\n        res = min(res, s);\\n        dfs(add(s, a), a, b, v);\\n        dfs(rotate(s, b), a, b, v);\\n    }\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        res = s;\\n        set<string> v;\\n        /*queue<string> q; //BFS CODE START\\n        q.push(s);\\n        while(!q.empty()) \\n        {\\n            string temp = q.front(); q.pop();\\n            if(v.find(temp) != v.end()) continue;\\n            v.insert(temp);\\n            res = min(res, temp);\\n            q.push(add(temp, a));\\n            q.push(rotate(temp, b));\\n        }*/ //BFS CODE END\\n        dfs(s, a, b, v);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string res;\\n    string add(string s, int a)\\n    {\\n        for(int i=0;i<s.size();i++)\\n            if(i%2) s[i] = ((s[i]-\\'0\\'+a)%10) + \\'0\\';\\n        return s;\\n    }\\n    string rotate(string s, int b)\\n    {\\n        int n = s.size();\\n        string temp = s.substr(n-b);\\n        temp += s.substr(0, n-b);\\n        return temp;\\n    }\\n    void dfs(string s, int a, int b, set<string> &v)\\n    {\\n        if(v.find(s) != v.end()) return;\\n        v.insert(s);\\n        res = min(res, s);\\n        dfs(add(s, a), a, b, v);\\n        dfs(rotate(s, b), a, b, v);\\n    }\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        res = s;\\n        set<string> v;\\n        /*queue<string> q; //BFS CODE START\\n        q.push(s);\\n        while(!q.empty()) \\n        {\\n            string temp = q.front(); q.pop();\\n            if(v.find(temp) != v.end()) continue;\\n            v.insert(temp);\\n            res = min(res, temp);\\n            q.push(add(temp, a));\\n            q.push(rotate(temp, b));\\n        }*/ //BFS CODE END\\n        dfs(s, a, b, v);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146918,
                "title": "java-easy-to-understand-concise-beginner-bfs",
                "content": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Map<String, Boolean> map = new TreeMap<String, Boolean>();\\n        int n=s.length();\\n        Queue<String> q = new LinkedList<String>();\\n        q.add(s);\\n        \\n        while(!q.isEmpty()){\\n            String front = q.poll();\\n        \\n            if(!map.containsKey(front)){\\n                 map.put(front, true);\\n                 q.add(front);\\n            }\\n               \\n            \\n            //op-a\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<n;++i){\\n                if(i%2==1){\\n                    sb.append((front.charAt(i)-\\'0\\'+a)%10);\\n                } else \\n                    sb.append(front.charAt(i));\\n            }\\n            String curr = sb.toString();\\n            \\n            if(!map.containsKey(curr)){\\n                map.put(curr, true);\\n                q.add(curr);\\n            }\\n            \\n            //op-b\\n            sb.setLength(0);\\n            for(int i=n-b;i<n;++i){\\n                    sb.append(front.charAt(i));\\n            }\\n            for(int i=0;i<n-b;++i){\\n                    sb.append(front.charAt(i));\\n            }\\n            curr = sb.toString();\\n\\n            if(!map.containsKey(curr)){\\n                map.put(curr, true);\\n                q.add(curr);\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return map.entrySet().stream().findFirst().get().getKey();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Map<String, Boolean> map = new TreeMap<String, Boolean>();\\n        int n=s.length();\\n        Queue<String> q = new LinkedList<String>();\\n        q.add(s);\\n        \\n        while(!q.isEmpty()){\\n            String front = q.poll();\\n        \\n            if(!map.containsKey(front)){\\n                 map.put(front, true);\\n                 q.add(front);\\n            }\\n               \\n            \\n            //op-a\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<n;++i){\\n                if(i%2==1){\\n                    sb.append((front.charAt(i)-\\'0\\'+a)%10);\\n                } else \\n                    sb.append(front.charAt(i));\\n            }\\n            String curr = sb.toString();\\n            \\n            if(!map.containsKey(curr)){\\n                map.put(curr, true);\\n                q.add(curr);\\n            }\\n            \\n            //op-b\\n            sb.setLength(0);\\n            for(int i=n-b;i<n;++i){\\n                    sb.append(front.charAt(i));\\n            }\\n            for(int i=0;i<n-b;++i){\\n                    sb.append(front.charAt(i));\\n            }\\n            curr = sb.toString();\\n\\n            if(!map.containsKey(curr)){\\n                map.put(curr, true);\\n                q.add(curr);\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return map.entrySet().stream().findFirst().get().getKey();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090291,
                "title": "intuitive-function-surprised-it-passed-the-tests-python",
                "content": "class Solution:\\n\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        #create the dict that keeps track of all words used\\n        counts = defaultdict(int)\\n        \\n        n = len(s)\\n        \\n        def helper(s):\\n            # add word to keep track\\n            if counts[s]:\\n                return\\n            counts[s] = 1\\n            \\n            #Rotate\\n            to_try = s[-b:] + s[:-b]\\n            helper(to_try)\\n            \\n            #Add\\n            to_try = \"\".join([str(int(s[i])+a)[-1] if i%2 else s[i] for i in range(0,n)])\\n            helper(to_try)\\n\\n        #execute function\\n        helper(s)\\n\\n        #check all words covered\\n        return sorted(list(counts))[0]\\n  \\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        #create the dict that keeps track of all words used\\n        counts = defaultdict(int)\\n        \\n        n = len(s)\\n        \\n        def helper(s):\\n            # add word to keep track\\n            if counts[s]:\\n                return\\n            counts[s] = 1\\n            \\n            #Rotate\\n            to_try = s[-b:] + s[:-b]\\n            helper(to_try)\\n            \\n            #Add\\n            to_try = \"\".join([str(int(s[i])+a)[-1] if i%2 else s[i] for i in range(0,n)])\\n            helper(to_try)\\n\\n        #execute function\\n        helper(s)\\n\\n        #check all words covered\\n        return sorted(list(counts))[0]\\n  \\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1048682,
                "title": "python-bfs-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: BFS\\nh: for each possible number (node), we have two possible operations (add, rotate)\\n    it seems to be a 2^100 possible number, however, note:\\n    1) add a to number of odd index, we will get to the same number after 10 rounds of add\\n    2) s has even length, if b is odd, we can get the same number after n round\\n    3) for each shift, we would get different number at even index in 10 rounds\\n    \\n    so we would have 10 * n * 10 number at most, then we can use BFS + memo\\n\\'\\'\\'\\nimport collections\\n\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        seen = set()\\n        deque = collections.deque([s])\\n\\n        while deque:\\n            #print(deque)\\n            curr = deque.popleft()\\n            seen.add(curr)\\n            \\n            #1.add\\n            ad = self.add_(curr, a)\\n            if ad not in seen:\\n                deque.append(ad)\\n                seen.add(ad)\\n\\n            \\n            #2. rotate:\\n            ro = self.rotate_(curr, b)\\n            if ro not in seen:\\n                deque.append(ro)\\n                seen.add(ro)\\n\\n        return min(seen)\\n        \\n        \\n    def add_(self,s,a):\\n        res = \\'\\'\\n        for idx, i in enumerate(s):\\n            if idx % 2 == 1:\\n                num = (int(i) + a) % 10\\n                res += str(num)\\n            else:\\n                res += i\\n                \\n        return res\\n    \\n    \\n    def rotate_(self, s, b):\\n        idx = len(s)-b\\n        res = s[idx:] + s[0:idx]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: BFS\\nh: for each possible number (node), we have two possible operations (add, rotate)\\n    it seems to be a 2^100 possible number, however, note:\\n    1) add a to number of odd index, we will get to the same number after 10 rounds of add\\n    2) s has even length, if b is odd, we can get the same number after n round\\n    3) for each shift, we would get different number at even index in 10 rounds\\n    \\n    so we would have 10 * n * 10 number at most, then we can use BFS + memo\\n\\'\\'\\'\\nimport collections\\n\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        seen = set()\\n        deque = collections.deque([s])\\n\\n        while deque:\\n            #print(deque)\\n            curr = deque.popleft()\\n            seen.add(curr)\\n            \\n            #1.add\\n            ad = self.add_(curr, a)\\n            if ad not in seen:\\n                deque.append(ad)\\n                seen.add(ad)\\n\\n            \\n            #2. rotate:\\n            ro = self.rotate_(curr, b)\\n            if ro not in seen:\\n                deque.append(ro)\\n                seen.add(ro)\\n\\n        return min(seen)\\n        \\n        \\n    def add_(self,s,a):\\n        res = \\'\\'\\n        for idx, i in enumerate(s):\\n            if idx % 2 == 1:\\n                num = (int(i) + a) % 10\\n                res += str(num)\\n            else:\\n                res += i\\n                \\n        return res\\n    \\n    \\n    def rotate_(self, s, b):\\n        idx = len(s)-b\\n        res = s[idx:] + s[0:idx]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026538,
                "title": "easy-bfs-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string add(string s,int a)\\n    {\\n        for(int i=1;i<s.length();i+=2)\\n        {\\n            s[i]=(((s[i]-\\'0\\')+a)%10)+\\'0\\';\\n        }\\n        return s;\\n    }\\n    string rotate(string s,int b)\\n    {\\n        string aux=s;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            s[(i+b)%s.length()]=aux[i];\\n        }\\n        return s;\\n    }\\n    string findLexSmallestString(string s, int a, int b)\\n    {\\n        queue<string>q;\\n        q.push(s);\\n        unordered_set<string>st;\\n        st.insert(s);\\n        string ans=s;\\n        while(!q.empty())\\n        {\\n            string node=q.front();\\n            q.pop();\\n            ans=min(ans,node);\\n            string added=add(node,a);\\n            string rotated=rotate(node,b);\\n            if(st.find(added)==st.end())\\n            {\\n                st.insert(added);\\n                q.push(added);\\n            }\\n            if(st.find(rotated)==st.end())\\n            {\\n                st.insert(rotated);\\n                q.push(rotated);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string add(string s,int a)\\n    {\\n        for(int i=1;i<s.length();i+=2)\\n        {\\n            s[i]=(((s[i]-\\'0\\')+a)%10)+\\'0\\';\\n        }\\n        return s;\\n    }\\n    string rotate(string s,int b)\\n    {\\n        string aux=s;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            s[(i+b)%s.length()]=aux[i];\\n        }\\n        return s;\\n    }\\n    string findLexSmallestString(string s, int a, int b)\\n    {\\n        queue<string>q;\\n        q.push(s);\\n        unordered_set<string>st;\\n        st.insert(s);\\n        string ans=s;\\n        while(!q.empty())\\n        {\\n            string node=q.front();\\n            q.pop();\\n            ans=min(ans,node);\\n            string added=add(node,a);\\n            string rotated=rotate(node,b);\\n            if(st.find(added)==st.end())\\n            {\\n                st.insert(added);\\n                q.push(added);\\n            }\\n            if(st.find(rotated)==st.end())\\n            {\\n                st.insert(rotated);\\n                q.push(rotated);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992056,
                "title": "simple-bfs-in-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    string addString(string s, int a)\\n    {\\n        for(int i=1; i<s.length(); i += 2)\\n        {\\n            int x = s[i] - \\'0\\';\\n            x = (x + a) % 10;\\n            s[i] = x + \\'0\\';\\n        }\\n        return s;\\n    }\\n    \\n    string rotateString(string s, int b)\\n    {\\n        for(int i=0; i<b; i++)\\n        {\\n            char c = s[s.length()-1];\\n            s.pop_back();\\n            s.insert(s.begin(), c);\\n        }\\n        return s;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> stringSet;        //to store visited strings\\n        queue<string> q;\\n        q.push(s);\\n        stringSet.insert(s);\\n        string ans = s;\\n        while(!q.empty())\\n        {\\n            string temp = q.front();\\n            q.pop();\\n            ans = min(ans, temp);\\n            string rotate = rotateString(temp, b);\\n            string add = addString(temp, a);\\n            if(stringSet.find(rotate) == stringSet.end())\\n            {\\n                q.push(rotate);\\n                stringSet.insert(rotate);\\n            }\\n            if(stringSet.find(add) == stringSet.end())\\n            {\\n                q.push(add);\\n                stringSet.insert(add);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    string addString(string s, int a)\\n    {\\n        for(int i=1; i<s.length(); i += 2)\\n        {\\n            int x = s[i] - \\'0\\';\\n            x = (x + a) % 10;\\n            s[i] = x + \\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 972536,
                "title": "clean-recursive-python-solution-easy-to-understand",
                "content": "```python\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n        s = [int(x) for x in s]\\n        \\n        allVals = set()\\n        \\n        def rotateValue(values, index):\\n            values = list(values)\\n            r = []\\n            for i in range(index):\\n                r.append(values.pop(-1))\\n            return list(r[::-1] + values)\\n        \\n        def addValue(values, amt):\\n            values = list(values)\\n            for i in range(len(values)):\\n                if i % 2 != 0:\\n                    values[i] += amt\\n                    values[i] = values[i] % 10\\n            return values\\n        \\n        def convert_to_string(values):\\n            return \\'\\'.join([str(x) for x in values])\\n            \\n        def check(value):\\n            # Takes in a [int, int, int...]\\n            value_as_string = convert_to_string(value)\\n            if value_as_string not in allVals:\\n                self.minValue = min(self.minValue, value_as_string)\\n                allVals.add(value_as_string)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcheck(rotateValue(value, b))\\n\\t\\t\\t\\tcheck(addValue(value, a))\\n\\t\\t\\t\\t\\n            return self.minValue\\n        \\n        self.minValue = convert_to_string(s)\\n        \\n        return check(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n        s = [int(x) for x in s]\\n        \\n        allVals = set()\\n        \\n        def rotateValue(values, index):\\n            values = list(values)\\n            r = []\\n            for i in range(index):\\n                r.append(values.pop(-1))\\n            return list(r[::-1] + values)\\n        \\n        def addValue(values, amt):\\n            values = list(values)\\n            for i in range(len(values)):\\n                if i % 2 != 0:\\n                    values[i] += amt\\n                    values[i] = values[i] % 10\\n            return values\\n        \\n        def convert_to_string(values):\\n            return \\'\\'.join([str(x) for x in values])\\n            \\n        def check(value):\\n            # Takes in a [int, int, int...]\\n            value_as_string = convert_to_string(value)\\n            if value_as_string not in allVals:\\n                self.minValue = min(self.minValue, value_as_string)\\n                allVals.add(value_as_string)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcheck(rotateValue(value, b))\\n\\t\\t\\t\\tcheck(addValue(value, a))\\n\\t\\t\\t\\t\\n            return self.minValue\\n        \\n        self.minValue = convert_to_string(s)\\n        \\n        return check(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937639,
                "title": "my-simple-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string add(string s, int a)\\n    {\\n        for(int i=1;i<s.size();i=i+2)\\n        {\\n           int x = s[i]-\\'0\\';\\n            x=x+a;\\n            x=x%10;\\n            char y = \\'0\\'+x;\\n            s[i]=y;\\n        }\\n        return s;\\n    }\\n    string rotate(string s, int b)\\n    {\\n        for(int i=0;i<b;i++)\\n        {\\n            char p = s[s.length()-1];\\n                s.pop_back();\\n            s.insert(s.begin(), p); \\n            \\n        }\\n        return s;\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_map<string,bool> visited;\\n        queue<string> q;\\n        q.push(s);\\n        string m = s ;\\n        visited[s] =1 ;\\n        while(!q.empty()){\\n             string front = q.front();\\n             q.pop();\\n             m=min(m,front);\\n            string addstr = add(front,a) , rotatestr = rotate(front,b) ;\\n             if(visited[addstr]==0) { visited[addstr]=1  ; q.push(addstr);}\\n             if(visited[rotatestr]==0){visited[rotatestr]=1  ; q.push(rotatestr);}\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string add(string s, int a)\\n    {\\n        for(int i=1;i<s.size();i=i+2)\\n        {\\n           int x = s[i]-\\'0\\';\\n            x=x+a;\\n            x=x%10;\\n            char y = \\'0\\'+x;\\n            s[i]=y;\\n        }\\n        return s;\\n    }\\n    string rotate(string s, int b)\\n    {\\n        for(int i=0;i<b;i++)\\n        {\\n            char p = s[s.length()-1];\\n                s.pop_back();\\n            s.insert(s.begin(), p); \\n            \\n        }\\n        return s;\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_map<string,bool> visited;\\n        queue<string> q;\\n        q.push(s);\\n        string m = s ;\\n        visited[s] =1 ;\\n        while(!q.empty()){\\n             string front = q.front();\\n             q.pop();\\n             m=min(m,front);\\n            string addstr = add(front,a) , rotatestr = rotate(front,b) ;\\n             if(visited[addstr]==0) { visited[addstr]=1  ; q.push(addstr);}\\n             if(visited[rotatestr]==0){visited[rotatestr]=1  ; q.push(rotatestr);}\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936353,
                "title": "c-depth-for-search",
                "content": "```\\nclass Solution {\\npublic:\\n    string add(string s, int a) {\\n        int n = s.size();\\n        bool flag = true;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(flag) {\\n                int val = a + (s[i] - \\'0\\');\\n                val = val % 10;\\n                s[i] = val + \\'0\\';\\n                flag = false;\\n            }\\n            else\\n                flag = true;\\n        }\\n        return s;\\n    }\\n    void dfs(string s, int a, int b, string& ans, unordered_set<string>& mark) {\\n        if(mark.find(s) != mark.end())\\n            return;\\n        mark.insert(s);\\n        ans = min(ans, s);\\n        dfs(s.substr(b) + s.substr(0, b), a, b, ans, mark);\\n        dfs(add(s, a), a, b, ans, mark);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n         unordered_set<string> mark;\\n         string ans = s;\\n         dfs(s, a, b, ans, mark);\\n         return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string add(string s, int a) {\\n        int n = s.size();\\n        bool flag = true;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(flag) {\\n                int val = a + (s[i] - \\'0\\');\\n                val = val % 10;\\n                s[i] = val + \\'0\\';\\n                flag = false;\\n            }\\n            else\\n                flag = true;\\n        }\\n        return s;\\n    }\\n    void dfs(string s, int a, int b, string& ans, unordered_set<string>& mark) {\\n        if(mark.find(s) != mark.end())\\n            return;\\n        mark.insert(s);\\n        ans = min(ans, s);\\n        dfs(s.substr(b) + s.substr(0, b), a, b, ans, mark);\\n        dfs(add(s, a), a, b, ans, mark);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n         unordered_set<string> mark;\\n         string ans = s;\\n         dfs(s, a, b, ans, mark);\\n         return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904902,
                "title": "bfs-unordered-set-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> visited;\\n        queue <string> que;\\n        que.push(s);\\n        string ans = s;\\n        visited.insert(s);\\n        while(!que.empty()){\\n            string frt = que.front();\\n            if(ans> frt) ans = frt;\\n            que.pop();\\n            vector <string> tmp = both(frt,a,b);\\n            if(visited.find(tmp[0]) == visited.end()){\\n                visited.insert(tmp[0]);\\n                que.push(tmp[0]);\\n            }\\n            if(visited.find(tmp[1]) == visited.end()){\\n                visited.insert(tmp[1]);\\n                que.push(tmp[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n    vector <string> both(string s,int &a,int &b){\\n        vector <string> res (2,s);\\n        for(int i =1; i < s.length(); i+=2){\\n            int num = res[0][i]-\\'0\\';\\n            num += a;\\n            num %= 10;\\n            res[0][i] = \\'0\\'+num;\\n        }\\n        res[1] = s.substr(s.length()-b,s.length())+s.substr(0,s.length()-b);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> visited;\\n        queue <string> que;\\n        que.push(s);\\n        string ans = s;\\n        visited.insert(s);\\n        while(!que.empty()){\\n            string frt = que.front();\\n            if(ans> frt) ans = frt;\\n            que.pop();\\n            vector <string> tmp = both(frt,a,b);\\n            if(visited.find(tmp[0]) == visited.end()){\\n                visited.insert(tmp[0]);\\n                que.push(tmp[0]);\\n            }\\n            if(visited.find(tmp[1]) == visited.end()){\\n                visited.insert(tmp[1]);\\n                que.push(tmp[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n    vector <string> both(string s,int &a,int &b){\\n        vector <string> res (2,s);\\n        for(int i =1; i < s.length(); i+=2){\\n            int num = res[0][i]-\\'0\\';\\n            num += a;\\n            num %= 10;\\n            res[0][i] = \\'0\\'+num;\\n        }\\n        res[1] = s.substr(s.length()-b,s.length())+s.substr(0,s.length()-b);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902175,
                "title": "c-very-simple-bfs",
                "content": "**Explaination:**\\n\\tthe question asks to find the smallest string given an original string, and two type of operation that we can perform\\n\\twe can perform the operations on the string unlimited amount of time, so it is hard to simulate that process(when do we stop applying the operation?)\\n\\tBut after some observation we can see that if we apply operation A or B continously on the string, it will end up like a loop\\n\\n----\\t\\n>   let\\'s say s = 5252, a = 5\\n>\\tif we apply A (Add a to all odd indices of s (0-indexed)): \\n>\\t5252 -> 5**7**5**7** -> 5**2**5**2** -> 5**7**5**7**\\n>\\t--- loop1---    ----loop2---\\n>\\tif a = 3\\n>\\t**5252** -> 5555 -> 5858 ->5151 -> 5454 -> 5757 -> 5050 -> 5353 -> 5656 -> 5959 -> **5252** (we are back!)\\n----\\nThe chain will no exceed 10, **it will eventually loops back to the original string**\\nso does the operation B (Rotate s to the right by b positions), if u keep applying the same operation it will goes like a loop as well , and it will not exceed N( N is the length of s the worst case is when b is 1, and u can shift N - 1 times)\\nafter these thought process , we can tell that the states are not infinite, we just need to find out a way to enumerate all possibilities, what I did in the following code is to perform a  BFS and enumerate all possible sequences\\n\\n\\n\\n```\\n    string findLexSmallestString(string s, int a, int b) {\\n        string smallest = s;\\n        const int N = s.size();\\n        queue<string> q;\\n        unordered_set<string> seen;\\n\\n        q.push(s);\\n        seen.insert(s);\\n        while (!q.empty()) {\\n            string cur = q.front(); q.pop();\\n            if (cur < smallest) smallest = cur; // we found a new state, lets check if it\\'s the smallest \\n            for (int i = 1; i < N; i += 2)  // operation A\\n                cur[i] = ((cur[i] - \\'0\\') + a) % 10 + \\'0\\';\\n            if (seen.insert(cur).second) q.push(cur); // only insert if this is a new state (otherwise we will stuck in the loop)\\n            cur = (cur.substr(N - b) + cur.substr(0, N - b)); // operation B\\n            if (seen.insert(cur).second) q.push(cur); // same \\n        }\\n        return smallest;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string findLexSmallestString(string s, int a, int b) {\\n        string smallest = s;\\n        const int N = s.size();\\n        queue<string> q;\\n        unordered_set<string> seen;\\n\\n        q.push(s);\\n        seen.insert(s);\\n        while (!q.empty()) {\\n            string cur = q.front(); q.pop();\\n            if (cur < smallest) smallest = cur; // we found a new state, lets check if it\\'s the smallest \\n            for (int i = 1; i < N; i += 2)  // operation A\\n                cur[i] = ((cur[i] - \\'0\\') + a) % 10 + \\'0\\';\\n            if (seen.insert(cur).second) q.push(cur); // only insert if this is a new state (otherwise we will stuck in the loop)\\n            cur = (cur.substr(N - b) + cur.substr(0, N - b)); // operation B\\n            if (seen.insert(cur).second) q.push(cur); // same \\n        }\\n        return smallest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 900995,
                "title": "c-100-faster-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string minn;\\n    int a, b, n;\\n    string gen(int i, string &res) { // new string after b-rightshift at i\\n        return res.substr(i, n - i) + res.substr(0, i);\\n    }\\n    int getStride(string &res, int start) { // get best stride\\n        int x = res[start] - \\'0\\', d = 10, stride = 0, cur;\\n        do{\\n            x = (x + a)%10;\\n            stride++;\\n            if(x < d)\\n                d = x, cur = stride;\\n        } while( x != res[start] - \\'0\\');\\n        return cur;\\n    }\\n    void tfrm(string &res, int start) { // add \\'a\\' stride times\\n        int x, stride = getStride(res, start);\\n        for(int i = start; i < n; i+=2) \\n            res[i] = (res[i] - \\'0\\' + a*stride)%10 + \\'0\\';\\n    }\\n    void shift(int ind, string res) { // shifted string beginning at i\\n        res = gen(ind, res);\\n        tfrm(res, 1);\\n        minn = min(minn, res);\\n        if(b%2 == 0) \\n            return;\\n        tfrm(res, 0);\\n        minn = min(minn, res);\\n        tfrm(res, 1);\\n        minn = min(minn, res);\\n        \\n    }\\n    string findLexSmallestString(string s, int A, int B) {\\n        a = A, b = B, n = s.size(), minn = s;\\n        int x = 0;\\n        do{\\n            shift(x, s);\\n            x = (x + n - b)%n;\\n        }while(x != 0);\\n        return minn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minn;\\n    int a, b, n;\\n    string gen(int i, string &res) { // new string after b-rightshift at i\\n        return res.substr(i, n - i) + res.substr(0, i);\\n    }\\n    int getStride(string &res, int start) { // get best stride\\n        int x = res[start] - \\'0\\', d = 10, stride = 0, cur;\\n        do{\\n            x = (x + a)%10;\\n            stride++;\\n            if(x < d)\\n                d = x, cur = stride;\\n        } while( x != res[start] - \\'0\\');\\n        return cur;\\n    }\\n    void tfrm(string &res, int start) { // add \\'a\\' stride times\\n        int x, stride = getStride(res, start);\\n        for(int i = start; i < n; i+=2) \\n            res[i] = (res[i] - \\'0\\' + a*stride)%10 + \\'0\\';\\n    }\\n    void shift(int ind, string res) { // shifted string beginning at i\\n        res = gen(ind, res);\\n        tfrm(res, 1);\\n        minn = min(minn, res);\\n        if(b%2 == 0) \\n            return;\\n        tfrm(res, 0);\\n        minn = min(minn, res);\\n        tfrm(res, 1);\\n        minn = min(minn, res);\\n        \\n    }\\n    string findLexSmallestString(string s, int A, int B) {\\n        a = A, b = B, n = s.size(), minn = s;\\n        int x = 0;\\n        do{\\n            shift(x, s);\\n            x = (x + n - b)%n;\\n        }while(x != 0);\\n        return minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900752,
                "title": "python-3-dfs",
                "content": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        b = b % len(s)\\n\\n        def dfs(s: str) -> None:\\n            if s in seen:\\n                return\\n            seen.add(s)\\n\\n            add: str = \\'\\'.join([c if i % 2 == 0 else str((int(c) + a) % 10) for i, c in enumerate(s)])\\n            dfs(add)\\n\\n            rotate: str = s[-b:] + s[:-b]\\n            dfs(rotate)\\n\\n        seen: Set[str] = set()\\n        dfs(s)\\n        return min(seen)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        b = b % len(s)\\n\\n        def dfs(s: str) -> None:\\n            if s in seen:\\n                return\\n            seen.add(s)\\n\\n            add: str = \\'\\'.join([c if i % 2 == 0 else str((int(c) + a) % 10) for i, c in enumerate(s)])\\n            dfs(add)\\n\\n            rotate: str = s[-b:] + s[:-b]\\n            dfs(rotate)\\n\\n        seen: Set[str] = set()\\n        dfs(s)\\n        return min(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900731,
                "title": "c-code-using-dfs-backtracking",
                "content": "Try out all possible strings that can be formed and return the minimum of them. \\nHave a map so to break the recursion if we encounter the same string (because it will be leading to the same possibilities). \\nNotice the rotate function, visualise it. It\\'s a real treat!.\\nThank You\\n```\\nclass Solution {\\npublic:\\n    #define min(a,b) (a>b?b:a)\\n    string ans;\\n    unordered_map<string,bool> visited;\\n    string add(string s, int &a){\\n        for(int i=1;i<s.size();i+=2){\\n            int x = s[i]-\\'0\\';\\n            x = (x+a)%10;\\n            s[i]  = (char)(x+\\'0\\');\\n        }\\n        return s;\\n    }\\n    string rotate(string s, int &b){\\n        reverse(s.begin(),s.end());\\n        reverse(s.begin(),s.begin()+b);\\n        reverse(s.begin()+b,s.end());\\n        return s;\\n    }\\n    void dfs(string s, int &a, int &b){\\n        if(visited[s]) return;\\n        visited[s] =1;\\n        ans=min(ans,s);\\n        dfs(rotate(s,b),a,b);\\n        dfs(add(s,a),a,b);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        ans = s;\\n        dfs(s,a,b);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define min(a,b) (a>b?b:a)\\n    string ans;\\n    unordered_map<string,bool> visited;\\n    string add(string s, int &a){\\n        for(int i=1;i<s.size();i+=2){\\n            int x = s[i]-\\'0\\';\\n            x = (x+a)%10;\\n            s[i]  = (char)(x+\\'0\\');\\n        }\\n        return s;\\n    }\\n    string rotate(string s, int &b){\\n        reverse(s.begin(),s.end());\\n        reverse(s.begin(),s.begin()+b);\\n        reverse(s.begin()+b,s.end());\\n        return s;\\n    }\\n    void dfs(string s, int &a, int &b){\\n        if(visited[s]) return;\\n        visited[s] =1;\\n        ans=min(ans,s);\\n        dfs(rotate(s,b),a,b);\\n        dfs(add(s,a),a,b);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        ans = s;\\n        dfs(s,a,b);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899643,
                "title": "python-clean-dfs-dp",
                "content": "Clean DFS+DP\\n```python\\ndef add(s, a):\\n    return \\'\\'.join([str((int(x) + a)%10) if i%2==1 else x for i, x in enumerate(s)])\\n\\ndef move(s, b):\\n    return \\'\\'.join([s[i - b] for i in range(len(s))])\\n\\nclass Solution:\\n    def dp(self, s):\\n        if s in self.visited:\\n            return\\n        if int(self.min_s) > int(s):\\n            self.min_s = s\\n        self.visited.add(s)        \\n        self.dp(add(s, self.a))        \\n        self.dp(move(s, self.b))              \\n        \\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        self.visited = set()\\n        self.min_s = s\\n        self.a = a\\n        self.b = b\\n        self.dp(s)\\n        return self.min_s\\n```\\n\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef add(s, a):\\n    return \\'\\'.join([str((int(x) + a)%10) if i%2==1 else x for i, x in enumerate(s)])\\n\\ndef move(s, b):\\n    return \\'\\'.join([s[i - b] for i in range(len(s))])\\n\\nclass Solution:\\n    def dp(self, s):\\n        if s in self.visited:\\n            return\\n        if int(self.min_s) > int(s):\\n            self.min_s = s\\n        self.visited.add(s)        \\n        self.dp(add(s, self.a))        \\n        self.dp(move(s, self.b))              \\n        \\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        self.visited = set()\\n        self.min_s = s\\n        self.a = a\\n        self.b = b\\n        self.dp(s)\\n        return self.min_s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899577,
                "title": "python-dfs-with-high-level-explanation",
                "content": "The key insight for me was that you cant easily confirm any one step will lead to a smaller number, nor if given the smallest result that it is indeed the smallest possible. So you have to search the whole space of possible values \"s\" can take using some search algorithm. Think of each possible value string \"s\" can take as a unique vertex in a graph and the two functions (`add` and `rotate`) as two edges leading out of each vertex. The nature of the functions then don\\'t matter and should conceptually just be thought of as black boxes leading you to another vertex.\\n\\nSo, you\\'re really just seaching a graph for the smallest element. To prevent loops just make sure you don\\'t continue searching if you have already seen a number (i.e. already visited a vertex).\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.smallest = float(\"inf\")\\n        self.seen = {}\\n    \\n    def rotate(self, s, b):\\n        s = [char for char in s]\\n        def reverse_segment(start, end):\\n            end -= 1\\n            while start < end:\\n                s[start], s[end] = s[end], s[start]\\n                start += 1\\n                end -= 1\\n        rotations = b % len(s)\\n        reverse_segment(0, len(s))\\n        reverse_segment(0, rotations)\\n        reverse_segment(rotations, len(s))\\n        return \"\".join(s) \\n    \\n    def add_one(self, char, a):\\n        return str((int(char)+a) % 10)\\n    \\n    def add(self, s, a):\\n        s = [char for char in s]\\n        for idx in range(len(s)):\\n            if idx % 2 != 0:\\n                s[idx] = self.add_one(s[idx], a)\\n        return \"\".join(s)\\n    \\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        if self.smallest == float(\"inf\"):\\n            self.smallest = s        \\n        if int(s) < int(self.smallest):\\n            self.smallest = s\\n        if s in self.seen:\\n            return\\n        self.seen[s] = True\\n        self.findLexSmallestString(self.rotate(s,b), a, b)\\n        self.findLexSmallestString(self.add(s,a), a, b)\\n        return self.smallest\\n````",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.smallest = float(\"inf\")\\n        self.seen = {}\\n    \\n    def rotate(self, s, b):\\n        s = [char for char in s]\\n        def reverse_segment(start, end):\\n            end -= 1\\n            while start < end:\\n                s[start], s[end] = s[end], s[start]\\n                start += 1\\n                end -= 1\\n        rotations = b % len(s)\\n        reverse_segment(0, len(s))\\n        reverse_segment(0, rotations)\\n        reverse_segment(rotations, len(s))\\n        return \"\".join(s) \\n    \\n    def add_one(self, char, a):\\n        return str((int(char)+a) % 10)\\n    \\n    def add(self, s, a):\\n        s = [char for char in s]\\n        for idx in range(len(s)):\\n            if idx % 2 != 0:\\n                s[idx] = self.add_one(s[idx], a)\\n        return \"\".join(s)\\n    \\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        if self.smallest == float(\"inf\"):\\n            self.smallest = s        \\n        if int(s) < int(self.smallest):\\n            self.smallest = s\\n        if s in self.seen:\\n            return\\n        self.seen[s] = True\\n        self.findLexSmallestString(self.rotate(s,b), a, b)\\n        self.findLexSmallestString(self.add(s,a), a, b)\\n        return self.smallest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899572,
                "title": "c-clean-with-explanation",
                "content": "- We need to consider all possible combinations - rotation by b and addition by a\\n- The constraints are sufficient to use recursion\\n- For each string, perform operation (1), then recurse, then perform operation (2)\\n- Remember seen values in a mem map, so as to not process them again (memoization)\\n\\n```\\nclass Solution {\\npublic:\\n    int a, b;\\n    string ret;\\n    map<string, bool> mem;\\n    void go(string s) {\\n        if(mem.count(s)) return;\\n        mem[s] = true;\\n        ret = min(ret, s);\\n        int i, n = s.size();\\n        for(i=1; i<n; i+=2) {\\n            int nw = ((s[i] - \\'0\\') + a) % 10;\\n            s[i] = (char)(\\'0\\' + nw);\\n        }\\n        go(s);\\n        rotate(s.rbegin(), s.rbegin() + b, s.rend());\\n        go(s);\\n    }\\n    string findLexSmallestString(string s, int _a, int _b) {\\n        a = _a;\\n        b = _b;\\n        ret = s;\\n        go(s);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int a, b;\\n    string ret;\\n    map<string, bool> mem;\\n    void go(string s) {\\n        if(mem.count(s)) return;\\n        mem[s] = true;\\n        ret = min(ret, s);\\n        int i, n = s.size();\\n        for(i=1; i<n; i+=2) {\\n            int nw = ((s[i] - \\'0\\') + a) % 10;\\n            s[i] = (char)(\\'0\\' + nw);\\n        }\\n        go(s);\\n        rotate(s.rbegin(), s.rbegin() + b, s.rend());\\n        go(s);\\n    }\\n    string findLexSmallestString(string s, int _a, int _b) {\\n        a = _a;\\n        b = _b;\\n        ret = s;\\n        go(s);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899567,
                "title": "python-dfs",
                "content": "```\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n        \"\"\"\\n        :type s: str\\n        :type a: int\\n        :type b: int\\n        :rtype: str\\n        \"\"\"\\n        seen = set()\\n\\n        def cmp(str1, str2):\\n            return int(str1)<int(str2)\\n        \\n        def add_str(s_in):\\n            res = \"\"\\n            for i in range(len(s_in)):\\n                if i%2:\\n                    res += str((int(s_in[i])+int(a))%10)\\n                else:\\n                    res += s_in[i]\\n            return res\\n        \\n        def rotate_str(s_in):\\n            res = s_in[-b:]+s_in[:-b]\\n            return res\\n        \\n        def search(s_in, res_min):\\n            if s_in == res_min or s_in in seen:\\n                return res_min\\n            seen.add(s_in)\\n            res_min = res_min if cmp(res_min, s_in) else s_in\\n            res_min = search(add_str(s_in), res_min)\\n            res_min = search(rotate_str(s_in), res_min)\\n            return res_min\\n            \\n        return search(s, \\'9\\'*len(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n        \"\"\"\\n        :type s: str\\n        :type a: int\\n        :type b: int\\n        :rtype: str\\n        \"\"\"\\n        seen = set()\\n\\n        def cmp(str1, str2):\\n            return int(str1)<int(str2)\\n        \\n        def add_str(s_in):\\n            res = \"\"\\n            for i in range(len(s_in)):\\n                if i%2:\\n                    res += str((int(s_in[i])+int(a))%10)\\n                else:\\n                    res += s_in[i]\\n            return res\\n        \\n        def rotate_str(s_in):\\n            res = s_in[-b:]+s_in[:-b]\\n            return res\\n        \\n        def search(s_in, res_min):\\n            if s_in == res_min or s_in in seen:\\n                return res_min\\n            seen.add(s_in)\\n            res_min = res_min if cmp(res_min, s_in) else s_in\\n            res_min = search(add_str(s_in), res_min)\\n            res_min = search(rotate_str(s_in), res_min)\\n            return res_min\\n            \\n        return search(s, \\'9\\'*len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899556,
                "title": "java-30-lines-3ms-greedy-beat-100",
                "content": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        String res = s;\\n        int i=0, n=s.length();\\n        Set<String> seen = new HashSet<>();\\n        while (seen.add(s)){\\n            i=(i+b)%n;\\n            char[] ca = s.toCharArray();\\n            if (b%2==1) update(ca, a, 0);\\n            update(ca, a, 1);\\n            String temp = new String(ca);\\n            if (res.compareTo(temp)>0) res = temp;\\n            s = s.substring(b)+s.substring(0,b);\\n        }\\n        return res;\\n    }\\n    \\n    void update(char[] ca, int a, int o){\\n        int times = 0, cur = ca[o]-\\'0\\', min = ca[o], t=0;\\n        Set<Integer> seen = new HashSet<>();\\n        while (seen.add(cur)){\\n            if (cur<min){\\n                min=cur;\\n                times = t; \\n            }\\n            cur=(cur+a)%10;\\n            t++;\\n        }\\n        for (int i=o; i<ca.length; i+=2){\\n            ca[i]=(char)((ca[i]-\\'0\\'+times*a)%10+\\'0\\');\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        String res = s;\\n        int i=0, n=s.length();\\n        Set<String> seen = new HashSet<>();\\n        while (seen.add(s)){\\n            i=(i+b)%n;\\n            char[] ca = s.toCharArray();\\n            if (b%2==1) update(ca, a, 0);\\n            update(ca, a, 1);\\n            String temp = new String(ca);\\n            if (res.compareTo(temp)>0) res = temp;\\n            s = s.substring(b)+s.substring(0,b);\\n        }\\n        return res;\\n    }\\n    \\n    void update(char[] ca, int a, int o){\\n        int times = 0, cur = ca[o]-\\'0\\', min = ca[o], t=0;\\n        Set<Integer> seen = new HashSet<>();\\n        while (seen.add(cur)){\\n            if (cur<min){\\n                min=cur;\\n                times = t; \\n            }\\n            cur=(cur+a)%10;\\n            t++;\\n        }\\n        for (int i=o; i<ca.length; i+=2){\\n            ca[i]=(char)((ca[i]-\\'0\\'+times*a)%10+\\'0\\');\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899461,
                "title": "i-am-really-tired-of-these-kind-of-questions-can-anyone-take-a-look-where-it-goes-wrong",
                "content": "Is there any fancy algorithm? What the hell of this question. BEEP.\\n```\\n    public String findLexSmallestString(String s, int a, int b) {\\n        char[] ch = s.toCharArray();\\n        while (true) {\\n            char[] c1 = rotate(ch, b);\\n            char[] c2 = add(ch, a);\\n            if (lessThan(c1, ch)) {\\n                for (int i=0; i<ch.length; i++) {\\n                    ch[i] = c1[i];\\n                    \\n                }                                     \\n            } \\n            else if (lessThan(c2, ch)) {\\n                for (int i=0; i<ch.length; i++) {\\n                    ch[i] = c2[i];\\n                }\\n            }\\n                               \\n\\n            else if (!lessThan(c1, ch) && !lessThan(c2, ch)) break;\\n        }  \\n        return String.valueOf(ch);\\n\\n    }\\n    \\n    public char[] rotate(char[] ch, int b) {\\n        reverse(ch, 0, b-1);\\n        reverse(ch, b, ch.length - 1);\\n        reverse(ch, 0, ch.length - 1);\\n        \\n        char[] res =  new char[ch.length];\\n        for (int i=0; i<ch.length; i++) {\\n            res[i] = ch[i];\\n        }\\n        System.out.println(String.valueOf(res));\\n        return res;\\n    }\\n    \\n    public char[] add(char[] ch, int a) {\\n        for (int i= 0; i<ch.length; i++) {\\n            if (i % 2 != 0) {\\n                int temp = ch[i] - \\'0\\' + a;\\n                //System.out.println(temp);\\n                if (temp > 9) temp -= 10;\\n                ch[i] = (char)(temp + \\'0\\');\\n            }\\n        }\\n        //System.out.println(String.valueOf(ch));\\n        char[] res =  new char[ch.length];\\n        for (int i=0; i<ch.length; i++) {\\n            res[i] = ch[i];\\n        }\\n        return res;\\n    }\\n    \\n    public void reverse(char[] ch, int s, int e) {\\n        while (s < e) {\\n            char temp = ch[s];\\n            ch[s] = ch[e];\\n            ch[e] = temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    public boolean lessThan(char[] c1, char[] c2) {\\n        for (int i=0; i<c1.length; i++) {\\n            if (c1[i] - c2[i] < 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String findLexSmallestString(String s, int a, int b) {\\n        char[] ch = s.toCharArray();\\n        while (true) {\\n            char[] c1 = rotate(ch, b);\\n            char[] c2 = add(ch, a);\\n            if (lessThan(c1, ch)) {\\n                for (int i=0; i<ch.length; i++) {\\n                    ch[i] = c1[i];\\n                    \\n                }                                     \\n            } \\n            else if (lessThan(c2, ch)) {\\n                for (int i=0; i<ch.length; i++) {\\n                    ch[i] = c2[i];\\n                }\\n            }\\n                               \\n\\n            else if (!lessThan(c1, ch) && !lessThan(c2, ch)) break;\\n        }  \\n        return String.valueOf(ch);\\n\\n    }\\n    \\n    public char[] rotate(char[] ch, int b) {\\n        reverse(ch, 0, b-1);\\n        reverse(ch, b, ch.length - 1);\\n        reverse(ch, 0, ch.length - 1);\\n        \\n        char[] res =  new char[ch.length];\\n        for (int i=0; i<ch.length; i++) {\\n            res[i] = ch[i];\\n        }\\n        System.out.println(String.valueOf(res));\\n        return res;\\n    }\\n    \\n    public char[] add(char[] ch, int a) {\\n        for (int i= 0; i<ch.length; i++) {\\n            if (i % 2 != 0) {\\n                int temp = ch[i] - \\'0\\' + a;\\n                //System.out.println(temp);\\n                if (temp > 9) temp -= 10;\\n                ch[i] = (char)(temp + \\'0\\');\\n            }\\n        }\\n        //System.out.println(String.valueOf(ch));\\n        char[] res =  new char[ch.length];\\n        for (int i=0; i<ch.length; i++) {\\n            res[i] = ch[i];\\n        }\\n        return res;\\n    }\\n    \\n    public void reverse(char[] ch, int s, int e) {\\n        while (s < e) {\\n            char temp = ch[s];\\n            ch[s] = ch[e];\\n            ch[e] = temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    public boolean lessThan(char[] c1, char[] c2) {\\n        for (int i=0; i<c1.length; i++) {\\n            if (c1[i] - c2[i] < 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899459,
                "title": "java-backtrack-easy-to-understand",
                "content": "```\\nclass Solution {\\n    char[] min;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        if (s == null || s.length() == 0) {\\n            return s;\\n        }\\n        int length = s.length();\\n        min = new char[length];\\n        Arrays.fill(min, \\'9\\');\\n        b = b % length;\\n        helper(s.toCharArray(), a, b, new HashSet<>());\\n        return new String(min);\\n    }\\n    private void helper(char[] array, int a, int b, Set<String> set) {\\n        if (!set.add(new String(array))) {\\n            return;\\n        }\\n        // compare\\n        if (smaller(array, min) && allDigit(array)) {\\n            min = Arrays.copyOf(array, array.length);\\n        }\\n        // rotate\\n        char[] copy = Arrays.copyOf(array, array.length);\\n        rotate(array, 0, array.length - b - 1);\\n        rotate(array, array.length - b, array.length - 1);\\n        rotate(array, 0, array.length - 1);\\n        helper(array, a, b, set);\\n        array = Arrays.copyOf(copy, copy.length);\\n        \\n        // add\\n        add(array, a);\\n        helper(array, a, b, set);\\n        array = Arrays.copyOf(copy, copy.length);\\n    }\\n    private boolean smaller(char[] array1, char[] array2) {\\n        for (int i = 0; i < array1.length; i++) {\\n            if (array1[i] == array2[i]) {\\n                continue;\\n            } else if (array1[i] < array2[i]) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    boolean allDigit(char[] array) {\\n        for (char c : array) {\\n            if (!Character.isDigit(c)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private void add(char[] array, int a) {\\n        boolean found = false;\\n        if (array[0] == \\'7\\' && array[1] == \\'9\\') {\\n            found = true;\\n        }\\n\\n        for (int i = 1; i < array.length; i += 2) {\\n            int temp = array[i] - \\'0\\';\\n            temp = (temp + a) % 10;\\n            array[i] = (char)(\\'0\\' + temp);\\n        }\\n\\n    }\\n    private void rotate(char[] array, int start, int end) {\\n        while (start < end) {\\n            char c = array[start];\\n            array[start] = array[end];\\n            array[end] = c;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] min;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        if (s == null || s.length() == 0) {\\n            return s;\\n        }\\n        int length = s.length();\\n        min = new char[length];\\n        Arrays.fill(min, \\'9\\');\\n        b = b % length;\\n        helper(s.toCharArray(), a, b, new HashSet<>());\\n        return new String(min);\\n    }\\n    private void helper(char[] array, int a, int b, Set<String> set) {\\n        if (!set.add(new String(array))) {\\n            return;\\n        }\\n        // compare\\n        if (smaller(array, min) && allDigit(array)) {\\n            min = Arrays.copyOf(array, array.length);\\n        }\\n        // rotate\\n        char[] copy = Arrays.copyOf(array, array.length);\\n        rotate(array, 0, array.length - b - 1);\\n        rotate(array, array.length - b, array.length - 1);\\n        rotate(array, 0, array.length - 1);\\n        helper(array, a, b, set);\\n        array = Arrays.copyOf(copy, copy.length);\\n        \\n        // add\\n        add(array, a);\\n        helper(array, a, b, set);\\n        array = Arrays.copyOf(copy, copy.length);\\n    }\\n    private boolean smaller(char[] array1, char[] array2) {\\n        for (int i = 0; i < array1.length; i++) {\\n            if (array1[i] == array2[i]) {\\n                continue;\\n            } else if (array1[i] < array2[i]) {\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    boolean allDigit(char[] array) {\\n        for (char c : array) {\\n            if (!Character.isDigit(c)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private void add(char[] array, int a) {\\n        boolean found = false;\\n        if (array[0] == \\'7\\' && array[1] == \\'9\\') {\\n            found = true;\\n        }\\n\\n        for (int i = 1; i < array.length; i += 2) {\\n            int temp = array[i] - \\'0\\';\\n            temp = (temp + a) % 10;\\n            array[i] = (char)(\\'0\\' + temp);\\n        }\\n\\n    }\\n    private void rotate(char[] array, int start, int end) {\\n        while (start < end) {\\n            char c = array[start];\\n            array[start] = array[end];\\n            array[end] = c;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025878,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "# Complexity\\n$$O(n^2)$$\\n\\n# Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar findLexSmallestString = function(s, a, b) {\\n    const visited = new Set();\\n    let result = s;\\n    const add = (value) => {\\n        let result = \\'\\';\\n\\n        for (let index = 0; index < value.length; index++) {\\n            const current = +value[index];\\n\\n            result += index % 2 ? (current + a) % 10 : current;\\n        }\\n        return result;\\n    };\\n    const rotate = (value) => value.slice(b) + value.slice(0, b);\\n    const applyOperation = (value) => {\\n        if (visited.has(value)) return;\\n        visited.add(value);\\n        if (result > value) result = value;\\n        applyOperation(add(value));\\n        applyOperation(rotate(value));\\n    };\\n\\n    applyOperation(s);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLexSmallestString = function(s, a, b) {\\n    const visited = new Set();\\n    let result = s;\\n    const add = (value) => {\\n        let result = \\'\\';\\n\\n        for (let index = 0; index < value.length; index++) {\\n            const current = +value[index];\\n\\n            result += index % 2 ? (current + a) % 10 : current;\\n        }\\n        return result;\\n    };\\n    const rotate = (value) => value.slice(b) + value.slice(0, b);\\n    const applyOperation = (value) => {\\n        if (visited.has(value)) return;\\n        visited.add(value);\\n        if (result > value) result = value;\\n        applyOperation(add(value));\\n        applyOperation(rotate(value));\\n    };\\n\\n    applyOperation(s);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964656,
                "title": "typescript-brute-force-dfs",
                "content": "# Code\\n```\\nfunction findLexSmallestString(s: string, a: number, b: number): string {\\n    let best = s;\\n\\n    function add(s: number[]): number[] {\\n        const res = s.slice();\\n        for (let i = 1; i < s.length; i += 2) res[i] = (res[i] + a) % 10;\\n        return res;\\n    }\\n\\n    function rotate(s: number[]): number[] {\\n        const res = s.slice();\\n        res.splice(0, 0, ...res.splice(res.length - b, b));\\n        return res;\\n    }\\n\\n    const seen = new Set();\\n    function dfs(s: number[]) {\\n        const sn = s.join(\\'\\');\\n        if (seen.has(sn)) return;\\n        seen.add(sn);\\n        if (sn < best) best = sn;\\n        dfs(add(s));\\n        dfs(rotate(s));\\n    }\\n\\n    dfs(s.split(\\'\\').map(s => parseInt(s, 10)));\\n    return best;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findLexSmallestString(s: string, a: number, b: number): string {\\n    let best = s;\\n\\n    function add(s: number[]): number[] {\\n        const res = s.slice();\\n        for (let i = 1; i < s.length; i += 2) res[i] = (res[i] + a) % 10;\\n        return res;\\n    }\\n\\n    function rotate(s: number[]): number[] {\\n        const res = s.slice();\\n        res.splice(0, 0, ...res.splice(res.length - b, b));\\n        return res;\\n    }\\n\\n    const seen = new Set();\\n    function dfs(s: number[]) {\\n        const sn = s.join(\\'\\');\\n        if (seen.has(sn)) return;\\n        seen.add(sn);\\n        if (sn < best) best = sn;\\n        dfs(add(s));\\n        dfs(rotate(s));\\n    }\\n\\n    dfs(s.split(\\'\\').map(s => parseInt(s, 10)));\\n    return best;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845084,
                "title": "76-ms-python-solution",
                "content": "# Intuition\\nJust try all the possible combinations of operations.\\n\\nIf b is odd: you can do addition operation to all indices.\\nIf b is even: you can do addition operation to odd indices.\\n\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n        \"\"\"\\n        :type s: str\\n        :type a: int\\n        :type b: int\\n        :rtype: str\\n        \"\"\"\\n\\n        lens = len(s)\\n        cmin = s\\n        ls = list([int(c) for c in s])\\n\\n        if b % 2 == 0:\\n            for add in range(0, 10*a, a):\\n                ls0 = [n if i % 2 == 0 else (n + add) % 10 for i,n in enumerate(ls)]\\n\\n                str0 = \\'\\'.join([str(n) for n in ls0])\\n                cmin = min(cmin, str0)\\n                for _ in range(lens):\\n                    str0 = str0[-b:] + str0[:-b]\\n                    cmin = min(cmin, str0)\\n\\n        else:\\n            for add in range(100):\\n                add1 = add / 10 * a\\n                add2 = add % 10 * a\\n                ls0 = [(n + add1) % 10 if i % 2 == 0 else (n + add2) % 10 for i,n in enumerate(ls)]\\n\\n                str0 = \\'\\'.join([str(n) for n in ls0])\\n                cmin = min(cmin, str0)\\n                for _ in range(lens):\\n                    str0 = str0[-b:] + str0[:-b]\\n                    cmin = min(cmin, str0)\\n\\n            \\n        return cmin\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n        \"\"\"\\n        :type s: str\\n        :type a: int\\n        :type b: int\\n        :rtype: str\\n        \"\"\"\\n\\n        lens = len(s)\\n        cmin = s\\n        ls = list([int(c) for c in s])\\n\\n        if b % 2 == 0:\\n            for add in range(0, 10*a, a):\\n                ls0 = [n if i % 2 == 0 else (n + add) % 10 for i,n in enumerate(ls)]\\n\\n                str0 = \\'\\'.join([str(n) for n in ls0])\\n                cmin = min(cmin, str0)\\n                for _ in range(lens):\\n                    str0 = str0[-b:] + str0[:-b]\\n                    cmin = min(cmin, str0)\\n\\n        else:\\n            for add in range(100):\\n                add1 = add / 10 * a\\n                add2 = add % 10 * a\\n                ls0 = [(n + add1) % 10 if i % 2 == 0 else (n + add2) % 10 for i,n in enumerate(ls)]\\n\\n                str0 = \\'\\'.join([str(n) for n in ls0])\\n                cmin = min(cmin, str0)\\n                for _ in range(lens):\\n                    str0 = str0[-b:] + str0[:-b]\\n                    cmin = min(cmin, str0)\\n\\n            \\n        return cmin\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826048,
                "title": "python-simple-dfs",
                "content": "Since size of s and the variations that can happen on s are both limited, we can do a DFS on each string and keep track of the minimum\\n# Code\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        self.vis = set()\\n        self.min = s\\n        self.a = a\\n        self.b = b\\n        self.dfs(s)\\n        return self.min\\n\\n    \\n    def dfs(self, s):\\n        if not(s in self.vis):\\n            self.vis.add(s)\\n            if int(s)< int(self.min):\\n                self.min = s\\n            sa = \\'\\'\\n            for i in range(len(s)):\\n                if i%2==0:\\n                    sa += s[i]\\n                else:\\n                    sa += str( (int(s[i]) + self.a)%10)\\n            sb = s[-self.b:] + s[:-self.b]\\n            self.dfs(sa)\\n            self.dfs(sb)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        self.vis = set()\\n        self.min = s\\n        self.a = a\\n        self.b = b\\n        self.dfs(s)\\n        return self.min\\n\\n    \\n    def dfs(self, s):\\n        if not(s in self.vis):\\n            self.vis.add(s)\\n            if int(s)< int(self.min):\\n                self.min = s\\n            sa = \\'\\'\\n            for i in range(len(s)):\\n                if i%2==0:\\n                    sa += s[i]\\n                else:\\n                    sa += str( (int(s[i]) + self.a)%10)\\n            sb = s[-self.b:] + s[:-self.b]\\n            self.dfs(sa)\\n            self.dfs(sb)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712190,
                "title": "python3-both-dfs-and-bfs-solutions-simple-and-beginner-friendly",
                "content": "DFS :\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        def add(s):\\n            ans=[]\\n            for i,ch in enumerate(s):\\n                if i&1:\\n                    temp=(int(ch)+a)%10\\n                    ans.append(str(temp))\\n                else:\\n                    ans.append(ch)\\n            return \\'\\'.join(ans)\\n        def rotate(s):\\n            return s[len(s)-b:]+s[:len(s)-b]\\n        ans=s\\n        visit=set()\\n        def dfs(curString):\\n            if curString in visit:\\n                return \\n            visit.add(curString)\\n            nonlocal ans\\n            ans=min(ans,curString)\\n            dfs(add(curString))\\n            dfs(rotate(curString))\\n        dfs(s)\\n        return ans\\n```\\nBFS :\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        def add(s):\\n            ans=[]\\n            for i,ch in enumerate(s):\\n                if i&1:\\n                    temp=(int(ch)+a)%10\\n                    ans.append(str(temp))\\n                else:\\n                    ans.append(ch)\\n            return \\'\\'.join(ans)\\n        def rotate(s):\\n            return s[len(s)-b:]+s[:len(s)-b]\\n        q=deque([s])\\n        ans=s\\n        visit=set()\\n        while q:\\n            curStr=q.popleft()\\n            ans=min(ans,curStr)\\n            if curStr not in visit:\\n                q.append(add(curStr))\\n                q.append(rotate(curStr))\\n                visit.add(curStr)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        def add(s):\\n            ans=[]\\n            for i,ch in enumerate(s):\\n                if i&1:\\n                    temp=(int(ch)+a)%10\\n                    ans.append(str(temp))\\n                else:\\n                    ans.append(ch)\\n            return \\'\\'.join(ans)\\n        def rotate(s):\\n            return s[len(s)-b:]+s[:len(s)-b]\\n        ans=s\\n        visit=set()\\n        def dfs(curString):\\n            if curString in visit:\\n                return \\n            visit.add(curString)\\n            nonlocal ans\\n            ans=min(ans,curString)\\n            dfs(add(curString))\\n            dfs(rotate(curString))\\n        dfs(s)\\n        return ans\\n```\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        def add(s):\\n            ans=[]\\n            for i,ch in enumerate(s):\\n                if i&1:\\n                    temp=(int(ch)+a)%10\\n                    ans.append(str(temp))\\n                else:\\n                    ans.append(ch)\\n            return \\'\\'.join(ans)\\n        def rotate(s):\\n            return s[len(s)-b:]+s[:len(s)-b]\\n        q=deque([s])\\n        ans=s\\n        visit=set()\\n        while q:\\n            curStr=q.popleft()\\n            ans=min(ans,curStr)\\n            if curStr not in visit:\\n                q.append(add(curStr))\\n                q.append(rotate(curStr))\\n                visit.add(curStr)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707644,
                "title": "dfs-backtrack-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    void f(string s,int a,int b,unordered_set<string>& st){\\n        if(st.count(s)) return;\\n        st.emplace(s);\\n        if(ans == \"\") ans = s;\\n        ans = min(ans,s);\\n        string temp = s.substr(s.length() - b,b);\\n        s.erase(s.length()-b);\\n        s = temp + s;\\n        f(s,a,b,st);\\n        s.erase(0,b);\\n        s = s + temp;\\n        for(int i=1;i<s.length();i+=2){\\n            s[i] = (((s[i] - \\'0\\') + (a))%10) + \\'0\\';\\n        }\\n        f(s,a,b,st);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> st;\\n        f(s,a,b,st);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    void f(string s,int a,int b,unordered_set<string>& st){\\n        if(st.count(s)) return;\\n        st.emplace(s);\\n        if(ans == \"\") ans = s;\\n        ans = min(ans,s);\\n        string temp = s.substr(s.length() - b,b);\\n        s.erase(s.length()-b);\\n        s = temp + s;\\n        f(s,a,b,st);\\n        s.erase(0,b);\\n        s = s + temp;\\n        for(int i=1;i<s.length();i+=2){\\n            s[i] = (((s[i] - \\'0\\') + (a))%10) + \\'0\\';\\n        }\\n        f(s,a,b,st);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> st;\\n        f(s,a,b,st);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702958,
                "title": "c-bfs",
                "content": "# Approach\\n- Generate all possible strings using breadth-first-search.\\n- Take care of already visited strings, using a visited map.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        map<string,int> vis;\\n        queue<string> q;\\n        q.push(s);\\n        vis[s] = 1;\\n        string ans = s;\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                string node = q.front();\\n                q.pop();\\n                if(node<ans)\\n                ans = node;\\n                string tmp1 = \"\";\\n                int ptr = node.size()-b;\\n                while(ptr<node.size())\\n                {\\n                    tmp1+=node[ptr++];\\n                }\\n                for(int j=0;j<node.size()-b;j++)\\n                tmp1+=node[j];\\n                if(vis.find(tmp1)==vis.end())\\n                {\\n                    vis[tmp1] = 1;\\n                    q.push(tmp1);\\n                }\\n                string tmp2 = \"\";\\n                for(int j=0;j<node.size();j++)\\n                {\\n                    if(j%2!=0)\\n                    {\\n                        int f = ((node[j]-\\'0\\')+a)%10;\\n                        tmp2+=(f+\\'0\\');\\n                    }\\n                    else\\n                    tmp2+=node[j];\\n                }\\n                if(vis.find(tmp2)==vis.end())\\n                {\\n                    vis[tmp2] = 1;\\n                    q.push(tmp2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        map<string,int> vis;\\n        queue<string> q;\\n        q.push(s);\\n        vis[s] = 1;\\n        string ans = s;\\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i=0;i<siz;i++)\\n            {\\n                string node = q.front();\\n                q.pop();\\n                if(node<ans)\\n                ans = node;\\n                string tmp1 = \"\";\\n                int ptr = node.size()-b;\\n                while(ptr<node.size())\\n                {\\n                    tmp1+=node[ptr++];\\n                }\\n                for(int j=0;j<node.size()-b;j++)\\n                tmp1+=node[j];\\n                if(vis.find(tmp1)==vis.end())\\n                {\\n                    vis[tmp1] = 1;\\n                    q.push(tmp1);\\n                }\\n                string tmp2 = \"\";\\n                for(int j=0;j<node.size();j++)\\n                {\\n                    if(j%2!=0)\\n                    {\\n                        int f = ((node[j]-\\'0\\')+a)%10;\\n                        tmp2+=(f+\\'0\\');\\n                    }\\n                    else\\n                    tmp2+=node[j];\\n                }\\n                if(vis.find(tmp2)==vis.end())\\n                {\\n                    vis[tmp2] = 1;\\n                    q.push(tmp2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656534,
                "title": "c-bfs-set-very-easy-sol",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> st;\\n        queue<string> q;\\n        q.push(s);\\n        string ans = s;\\n\\n        while(!q.empty()){\\n            string str = q.front();\\n            q.pop();\\n            ans = min(ans, str);\\n            \\n            string temp = str, s1=\"\", s2=\"\";\\n\\n            for(int i=0 ;i<temp.length() ;i++){\\n                if(i%2){\\n                    int val = ((temp[i]-\\'0\\')+a)%10;\\n                    temp[i] = \\'0\\'+val;\\n                }\\n                if(i<b)\\n                s1.push_back(str[i]);\\n                if(i>=b)\\n                s2.push_back(str[i]);\\n            }\\n\\n            if(st.find(temp)==st.end()){\\n                st.insert(temp);\\n                q.push(temp);\\n            }\\n            \\n            string rotated = s2+s1;\\n            if(st.find(rotated)==st.end()){\\n                st.insert(rotated);\\n                q.push(rotated);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> st;\\n        queue<string> q;\\n        q.push(s);\\n        string ans = s;\\n\\n        while(!q.empty()){\\n            string str = q.front();\\n            q.pop();\\n            ans = min(ans, str);\\n            \\n            string temp = str, s1=\"\", s2=\"\";\\n\\n            for(int i=0 ;i<temp.length() ;i++){\\n                if(i%2){\\n                    int val = ((temp[i]-\\'0\\')+a)%10;\\n                    temp[i] = \\'0\\'+val;\\n                }\\n                if(i<b)\\n                s1.push_back(str[i]);\\n                if(i>=b)\\n                s2.push_back(str[i]);\\n            }\\n\\n            if(st.find(temp)==st.end()){\\n                st.insert(temp);\\n                q.push(temp);\\n            }\\n            \\n            string rotated = s2+s1;\\n            if(st.find(rotated)==st.end()){\\n                st.insert(rotated);\\n                q.push(rotated);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602244,
                "title": "simple-solution-in-c-using-bfs",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string FindLexSmallestString(string s, int a, int b) {\\n            HashSet<string> map = new HashSet<string>();\\n            Queue<string> q = new Queue<string>();\\n            q.Enqueue(s);\\n            string min = s;\\n            Queue<char> rot = new Queue<char>();\\n\\n            while (q.Count > 0)\\n            {\\n                string rem = q.Dequeue();\\n                if (map.Contains(rem)) continue;\\n                map.Add(rem);\\n                for (int i = s.Length - 1; i >= 0; i--)\\n                {\\n                    rot.Enqueue(rem[i]);\\n                }\\n                string s1 = \"\";\\n                string s2 = \"\";\\n                for (int i = 0; i < s.Length; i++)\\n                {\\n                    if (i % 2 != 0)\\n                    { // odd indices\\n                        char c = rem[i];\\n                        int num = c - \\'0\\';\\n                        int sum = num + a;\\n                        int rmo = sum % 10;\\n                        s1 = s1 + rmo;\\n                    }\\n                    else\\n                    {\\n                        s1 = s1 + rem[i];\\n                    }\\n                }\\n                int x = 0;\\n                while (x < b)\\n                {\\n                    char rm = rot.Dequeue();\\n                    rot.Enqueue(rm);\\n                    x++;\\n                }\\n                while (rot.Count > 0)\\n                {\\n                    s2 = rot.Dequeue() + s2;\\n                }\\n                int c1 = string.CompareOrdinal(min, s1);\\n                if (c1 > 0)\\n                {\\n\\n                    min = s1;\\n                }\\n                c1 = string.CompareOrdinal(min, s2);\\n                if (c1 > 0)\\n                {\\n                    min = s2;\\n                }\\n                q.Enqueue(s1);\\n                q.Enqueue(s2);\\n            }\\n            return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public string FindLexSmallestString(string s, int a, int b) {\\n            HashSet<string> map = new HashSet<string>();\\n            Queue<string> q = new Queue<string>();\\n            q.Enqueue(s);\\n            string min = s;\\n            Queue<char> rot = new Queue<char>();\\n\\n            while (q.Count > 0)\\n            {\\n                string rem = q.Dequeue();\\n                if (map.Contains(rem)) continue;\\n                map.Add(rem);\\n                for (int i = s.Length - 1; i >= 0; i--)\\n                {\\n                    rot.Enqueue(rem[i]);\\n                }\\n                string s1 = \"\";\\n                string s2 = \"\";\\n                for (int i = 0; i < s.Length; i++)\\n                {\\n                    if (i % 2 != 0)\\n                    { // odd indices\\n                        char c = rem[i];\\n                        int num = c - \\'0\\';\\n                        int sum = num + a;\\n                        int rmo = sum % 10;\\n                        s1 = s1 + rmo;\\n                    }\\n                    else\\n                    {\\n                        s1 = s1 + rem[i];\\n                    }\\n                }\\n                int x = 0;\\n                while (x < b)\\n                {\\n                    char rm = rot.Dequeue();\\n                    rot.Enqueue(rm);\\n                    x++;\\n                }\\n                while (rot.Count > 0)\\n                {\\n                    s2 = rot.Dequeue() + s2;\\n                }\\n                int c1 = string.CompareOrdinal(min, s1);\\n                if (c1 > 0)\\n                {\\n\\n                    min = s1;\\n                }\\n                c1 = string.CompareOrdinal(min, s2);\\n                if (c1 > 0)\\n                {\\n                    min = s2;\\n                }\\n                q.Enqueue(s1);\\n                q.Enqueue(s2);\\n            }\\n            return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490839,
                "title": "c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string> Queue;\\n        Queue.push(s);\\n        unordered_map<string, bool> visited;\\n        string ans = s;\\n        int n = s.length();\\n        while(!Queue.empty()) {\\n            int sz = Queue.size();\\n            for(int i = 0; i < sz; i++) {\\n                string curr = Queue.front();\\n                Queue.pop();\\n                ans = min(ans, curr);\\n                string A = curr.substr(n - b) + curr.substr(0, n - b);\\n                string B = curr;\\n                for(int j = 1; j < n; j += 2) {\\n                    B[j] = (B[j] - \\'0\\' + a) % 10 + \\'0\\';\\n                }\\n                if(!visited[A]) {\\n                    Queue.push(A);\\n                    visited[A] = true;\\n                }\\n                if(!visited[B]) {\\n                    Queue.push(B);\\n                    visited[B] = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string> Queue;\\n        Queue.push(s);\\n        unordered_map<string, bool> visited;\\n        string ans = s;\\n        int n = s.length();\\n        while(!Queue.empty()) {\\n            int sz = Queue.size();\\n            for(int i = 0; i < sz; i++) {\\n                string curr = Queue.front();\\n                Queue.pop();\\n                ans = min(ans, curr);\\n                string A = curr.substr(n - b) + curr.substr(0, n - b);\\n                string B = curr;\\n                for(int j = 1; j < n; j += 2) {\\n                    B[j] = (B[j] - \\'0\\' + a) % 10 + \\'0\\';\\n                }\\n                if(!visited[A]) {\\n                    Queue.push(A);\\n                    visited[A] = true;\\n                }\\n                if(!visited[B]) {\\n                    Queue.push(B);\\n                    visited[B] = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449677,
                "title": "simple-bfs-solution-c",
                "content": "class Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n\\t\\n        int n= s.size();\\n        \\n        string ans= s;\\n        unordered_set<string> visited;\\n        \\n        queue<string> q;\\n        q.push(s);\\n        \\n        while(!q.empty())\\n        {\\n            string str= q.front();\\n            q.pop();\\n            \\n            ans= min(ans,str);\\n            \\n            auto cpy= str;\\n            \\n            for(int i=1;i<str.size();i+=2)\\n                str[i]= (str[i]-\\'0\\' +a)%10 +\\'0\\' ;\\n            \\n            if(visited.count(str)==0)\\n            {\\n                visited.insert(str);\\n                q.push(str);\\n            }\\n            \\n            str=cpy;\\n            \\n            string left= str.substr(0,n-b);\\n            string right= str.substr(n-b,b);\\n            \\n            string topush= right+left;\\n            \\n            if(visited.count(topush)==0)\\n            {\\n                visited.insert(topush);\\n                q.push(topush);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n\\t\\n        int n= s.size();\\n        \\n        string ans= s;\\n        unordered_set<string> visited;\\n        \\n        queue<string> q;\\n        q.push(s);\\n        \\n        while(!q.empty())\\n        {\\n            string str= q.front();\\n            q.pop();\\n            \\n            ans= min(ans,str);\\n            \\n            auto cpy= str;\\n            \\n            for(int i=1;i<str.size();i+=2)\\n                str[i]= (str[i]-\\'0\\' +a)%10 +\\'0\\' ;\\n            \\n            if(visited.count(str)==0)\\n            {\\n                visited.insert(str);\\n                q.push(str);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3393040,
                "title": "hash-table-simple-bfs-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String rotateRight(String s, int b) {\\n    int len = s.length();\\n    if (len <= 1) {\\n        return s;\\n    }\\n    int k = b % len;\\n    if (k == 0) {\\n        return s;\\n    }\\n    String suffix = s.substring(len - k);\\n    String prefix = s.substring(0, len - k);\\n    return suffix + prefix;\\n}\\n    public String addOddIndices(String s, int a) {\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (i % 2 == 1) {\\n            int digit = (c - \\'0\\' + a) % 10;\\n            c = (char) (\\'0\\' + digit);\\n        }\\n        sb.append(c);\\n    }\\n    return sb.toString();\\n}\\n\\n    public String findLexSmallestString(String s, int a, int b) {\\n        int n = s.length();\\n        Queue<String> q = new LinkedList<>();\\n        TreeSet<String> set = new TreeSet<>();\\n        q.add(s);\\n        set.add(s);\\n        while(!q.isEmpty()){\\n           String t = q.peek();\\n           q.remove();\\n           String t1 = rotateRight(t,b);\\n           String t2 = addOddIndices(t,a);\\n            if(!set.contains(t1)){\\n               q.add(t1);\\n               set.add(t1);\\n           }\\n            if(!set.contains(t2)){\\n               q.add(t2);\\n               set.add(t2);\\n           }\\n        }\\n        return set.first();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public String rotateRight(String s, int b) {\\n    int len = s.length();\\n    if (len <= 1) {\\n        return s;\\n    }\\n    int k = b % len;\\n    if (k == 0) {\\n        return s;\\n    }\\n    String suffix = s.substring(len - k);\\n    String prefix = s.substring(0, len - k);\\n    return suffix + prefix;\\n}\\n    public String addOddIndices(String s, int a) {\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (i % 2 == 1) {\\n            int digit = (c - \\'0\\' + a) % 10;\\n            c = (char) (\\'0\\' + digit);\\n        }\\n        sb.append(c);\\n    }\\n    return sb.toString();\\n}\\n\\n    public String findLexSmallestString(String s, int a, int b) {\\n        int n = s.length();\\n        Queue<String> q = new LinkedList<>();\\n        TreeSet<String> set = new TreeSet<>();\\n        q.add(s);\\n        set.add(s);\\n        while(!q.isEmpty()){\\n           String t = q.peek();\\n           q.remove();\\n           String t1 = rotateRight(t,b);\\n           String t2 = addOddIndices(t,a);\\n            if(!set.contains(t1)){\\n               q.add(t1);\\n               set.add(t1);\\n           }\\n            if(!set.contains(t2)){\\n               q.add(t2);\\n               set.add(t2);\\n           }\\n        }\\n        return set.first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265163,
                "title": "c-bfs-approach",
                "content": "```\\n    string f1(string s,int a){\\n        for(int i = 0;i<s.size();i++){\\n            if(i%2!=0){\\n                int num = s[i]-\\'0\\';\\n                num+=a;\\n                num%=10;\\n                s[i] = num + \\'0\\';\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    string f2(string s,int b){\\n        b = b%s.size();\\n        reverse(s.begin(),s.end());\\n        reverse(s.begin(),s.begin()+b);\\n        reverse(s.begin()+b,s.end());\\n        return s;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        set <string> set;\\n        queue <string> q;\\n        q.push({s,0});\\n        \\n        while(!q.empty()){\\n            string str = q.front();\\n            q.pop();\\n            \\n            string str1 = f1(str,a);\\n            string str2 = f2(str,b);\\n            if(set.find(str1)==set.end()){\\n                set.insert(str1);\\n                q.push(str1);\\n            }\\n            if(set.find(str2)==set.end()){\\n                set.insert(str2);\\n                q.push(str2);\\n            }\\n            \\n        }\\n        \\n        return *set.begin();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n    string f1(string s,int a){\\n        for(int i = 0;i<s.size();i++){\\n            if(i%2!=0){\\n                int num = s[i]-\\'0\\';\\n                num+=a;\\n                num%=10;\\n                s[i] = num + \\'0\\';\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    string f2(string s,int b){\\n        b = b%s.size();\\n        reverse(s.begin(),s.end());\\n        reverse(s.begin(),s.begin()+b);\\n        reverse(s.begin()+b,s.end());\\n        return s;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        set <string> set;\\n        queue <string> q;\\n        q.push({s,0});\\n        \\n        while(!q.empty()){\\n            string str = q.front();\\n            q.pop();\\n            \\n            string str1 = f1(str,a);\\n            string str2 = f2(str,b);\\n            if(set.find(str1)==set.end()){\\n                set.insert(str1);\\n                q.push(str1);\\n            }\\n            if(set.find(str2)==set.end()){\\n                set.insert(str2);\\n                q.push(str2);\\n            }\\n            \\n        }\\n        \\n        return *set.begin();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3261651,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func findLexSmallestString(_ s: String, _ a: Int, _ b: Int) -> String {\\n\\n        var hist = Set<[Int]>()        \\n        var res = s\\n\\n        func go(_ s: [Int] = s.map({ Int(String($0))! })) {\\n\\n            guard !hist.contains(s) else { return }\\n            hist.insert(s)\\n\\n            var nc = s\\n            var ns = [[Int]]()\\n\\n            repeat {\\n                res = min(res, nc.map({ \"\\\\($0)\"}).joined())\\n                ns.append(nc.suffix(b) + nc.prefix(s.count - b))\\n                if hist.contains(ns.last!) { break }\\n                for i in stride(from: 1, to: nc.count, by: 2) { nc[i] = (nc[i] + a) % 10 }\\n            } while nc != s\\n\\n            for n in ns { go(n) }\\n        }\\n\\n        go()\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findLexSmallestString(_ s: String, _ a: Int, _ b: Int) -> String {\\n\\n        var hist = Set<[Int]>()        \\n        var res = s\\n\\n        func go(_ s: [Int] = s.map({ Int(String($0))! })) {\\n\\n            guard !hist.contains(s) else { return }\\n            hist.insert(s)\\n\\n            var nc = s\\n            var ns = [[Int]]()\\n\\n            repeat {\\n                res = min(res, nc.map({ \"\\\\($0)\"}).joined())\\n                ns.append(nc.suffix(b) + nc.prefix(s.count - b))\\n                if hist.contains(ns.last!) { break }\\n                for i in stride(from: 1, to: nc.count, by: 2) { nc[i] = (nc[i] + a) % 10 }\\n            } while nc != s\\n\\n            for n in ns { go(n) }\\n        }\\n\\n        go()\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255449,
                "title": "java-dfs-soln",
                "content": "```\\nclass Solution {\\n    Set<String>set=new HashSet<>();\\n    String ans;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        ans=s;\\n        dfs(s,a,b);\\n        return ans;\\n    }\\n    public void dfs(String s,int a,int b){\\n        if(set.contains(s))return;\\n        set.add(s);\\n        if(ans.compareTo(s)>0)ans=s;\\n        dfs(rot(s,b),a,b);\\n        dfs(add(s,a),a,b);\\n    }\\n    public String rot(String s,int b){\\n        int l=s.length();\\n        String a=s.substring(0,b);\\n        String c=s.substring(b);\\n        return c+a;\\n    }\\n    public String add(String s,int a){\\n        StringBuilder sb=new StringBuilder(s);\\n        for(int i=0;i<s.length();i++){\\n            if(i%2==1){\\n                int aa=Integer.parseInt(Character.toString(sb.charAt(i)));\\n                aa=(aa+a)%10;\\n                char x=Integer.toString(aa).charAt(0);\\n                sb.setCharAt(i,x);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Set<String>set=new HashSet<>();\\n    String ans;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        ans=s;\\n        dfs(s,a,b);\\n        return ans;\\n    }\\n    public void dfs(String s,int a,int b){\\n        if(set.contains(s))return;\\n        set.add(s);\\n        if(ans.compareTo(s)>0)ans=s;\\n        dfs(rot(s,b),a,b);\\n        dfs(add(s,a),a,b);\\n    }\\n    public String rot(String s,int b){\\n        int l=s.length();\\n        String a=s.substring(0,b);\\n        String c=s.substring(b);\\n        return c+a;\\n    }\\n    public String add(String s,int a){\\n        StringBuilder sb=new StringBuilder(s);\\n        for(int i=0;i<s.length();i++){\\n            if(i%2==1){\\n                int aa=Integer.parseInt(Character.toString(sb.charAt(i)));\\n                aa=(aa+a)%10;\\n                char x=Integer.toString(aa).charAt(0);\\n                sb.setCharAt(i,x);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3245511,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int n ;\\n    string add(string cur, int a){\\n        for(int i = 1; i < n; i+= 2)\\n            cur[i] = (cur[i] - \\'0\\' + a)%10 + \\'0\\' ;\\n        return cur ;\\n    }    \\n    \\n    string roate(string cur, int b){\\n        string front = cur.substr(0, n-b) ;\\n        string back = cur.substr(n-b) ;\\n        return back + front ;\\n    }\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        this->n = s.size() ;\\n        string ret = s ;\\n        unordered_set<string>used ;\\n        queue<string>q{{s}} ;\\n        used.insert(s) ;\\n        while(!q.empty())\\n        {\\n            auto cur = q.front() ;\\n            q.pop() ;\\n            ret = min(ret, cur) ;\\n            string adds = add(cur, a) ;\\n            while(used.count(adds) == 0){\\n                used.insert(adds) ;\\n                q.push(adds) ;\\n                adds = add(adds, a) ;\\n            }\\n            string roas = roate(cur, b) ;\\n            while(used.count(roas) == 0){\\n                used.insert(roas) ;\\n                q.push(roas) ;\\n                roas = roate(roas, b) ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n ;\\n    string add(string cur, int a){\\n        for(int i = 1; i < n; i+= 2)\\n            cur[i] = (cur[i] - \\'0\\' + a)%10 + \\'0\\' ;\\n        return cur ;\\n    }    \\n    \\n    string roate(string cur, int b){\\n        string front = cur.substr(0, n-b) ;\\n        string back = cur.substr(n-b) ;\\n        return back + front ;\\n    }\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        this->n = s.size() ;\\n        string ret = s ;\\n        unordered_set<string>used ;\\n        queue<string>q{{s}} ;\\n        used.insert(s) ;\\n        while(!q.empty())\\n        {\\n            auto cur = q.front() ;\\n            q.pop() ;\\n            ret = min(ret, cur) ;\\n            string adds = add(cur, a) ;\\n            while(used.count(adds) == 0){\\n                used.insert(adds) ;\\n                q.push(adds) ;\\n                adds = add(adds, a) ;\\n            }\\n            string roas = roate(cur, b) ;\\n            while(used.count(roas) == 0){\\n                used.insert(roas) ;\\n                q.push(roas) ;\\n                roas = roate(roas, b) ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218826,
                "title": "python-simple-brute-force-solution",
                "content": "# Intuition\\nAdditions can make at most 10 different states per odd positions, this is 10 * N different states. Rotations can make at most N different states, those 2 mutiplied get 10$$N^2$$ which is asymptotically O($$N^2$$). Constraint N <= 100 allows us to brute force through all possible states and get best one as solution.\\n\\n\\n# Approach\\nGenerate all possible solutions by applying both operations on previously generated states, use hash map to avoid repeating work and getting into infinite loop.\\n\\n# Complexity\\n- Time complexity:\\nO($$N^2$$)\\n\\n- Space complexity:\\nO($$N^2$$)\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:        \\n        seen, qu = set(), deque([s])\\n        while qu:\\n            ss = qu.popleft()\\n            if ss not in seen:\\n                seen.add(ss)\\n                qu.append(\\'\\'.join([str((int(c) + a) % 10) if i % 2 else c for i, c in enumerate(ss)]))\\n                qu.append(ss[-b:] + ss[:-b])\\n        return min(seen)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:        \\n        seen, qu = set(), deque([s])\\n        while qu:\\n            ss = qu.popleft()\\n            if ss not in seen:\\n                seen.add(ss)\\n                qu.append(\\'\\'.join([str((int(c) + a) % 10) if i % 2 else c for i, c in enumerate(ss)]))\\n                qu.append(ss[-b:] + ss[:-b])\\n        return min(seen)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198287,
                "title": "python-3-bfs",
                "content": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        q = deque( [s] )\\n        res = set( [s] )\\n        \\n        while q:\\n            cur = q.popleft()\\n            \\n            t1 = list(cur)\\n            for i in range(len(t1)):\\n                if i & 1:\\n                    t1[i] = str( (int(t1[i]) + a) % 10 )\\n            \\n            t1 = \\'\\'.join(t1)\\n            if t1 not in res:\\n                q.append(t1)\\n                res.add(t1)\\n            \\n            t2 = cur[b : ] + cur[ : b]\\n            if t2 not in res:\\n                q.append(t2)\\n                res.add(t2)\\n        \\n        return min(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        q = deque( [s] )\\n        res = set( [s] )\\n        \\n        while q:\\n            cur = q.popleft()\\n            \\n            t1 = list(cur)\\n            for i in range(len(t1)):\\n                if i & 1:\\n                    t1[i] = str( (int(t1[i]) + a) % 10 )\\n            \\n            t1 = \\'\\'.join(t1)\\n            if t1 not in res:\\n                q.append(t1)\\n                res.add(t1)\\n            \\n            t2 = cur[b : ] + cur[ : b]\\n            if t2 not in res:\\n                q.append(t2)\\n                res.add(t2)\\n        \\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095853,
                "title": "rust-brute-force-dfs",
                "content": "```\\nuse std::{collections::HashSet, cmp::min};\\n\\nimpl Solution {\\n    fn rotate(s: &str, b: i32) -> String {\\n        let mut res = String::new();\\n        let i: usize = s.len() - b as usize;\\n        res += &s[i..];\\n        res += &s[..i];\\n        res\\n    }\\n\\n    fn add(s: &str, a: i32) -> String {\\n        let mut res = String::new();\\n        for (i, c) in s.chars().enumerate() {\\n            if i % 2 == 0 { res.push(c); }\\n            else { res.push((b\\'0\\' + (c as u8 - b\\'0\\' + a as u8) % 10) as char); }\\n        }\\n        res\\n    }\\n\\n    fn dfs(s: &str, a: i32, b: i32, seen: &mut HashSet<String>) -> Option<String> {\\n        if !seen.contains(s) {\\n            let mut res = s.to_string();\\n            seen.insert(s.to_string());\\n            if let Some(ss) = Self::dfs(&Self::rotate(s, b), a, b, seen) {\\n                res = min(res, ss);\\n            }\\n            if let Some(ss) = Self::dfs(&Self::add(s, a), a, b, seen) {\\n                res = min(res, ss);\\n            }\\n            Some(res)\\n        } else {\\n            None\\n        }\\n    }\\n\\n    pub fn find_lex_smallest_string(s: String, a: i32, b: i32) -> String {\\n        let mut seen = HashSet::new();\\n        Self::dfs(&s, a, b, &mut seen).unwrap()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::{collections::HashSet, cmp::min};\\n\\nimpl Solution {\\n    fn rotate(s: &str, b: i32) -> String {\\n        let mut res = String::new();\\n        let i: usize = s.len() - b as usize;\\n        res += &s[i..];\\n        res += &s[..i];\\n        res\\n    }\\n\\n    fn add(s: &str, a: i32) -> String {\\n        let mut res = String::new();\\n        for (i, c) in s.chars().enumerate() {\\n            if i % 2 == 0 { res.push(c); }\\n            else { res.push((b\\'0\\' + (c as u8 - b\\'0\\' + a as u8) % 10) as char); }\\n        }\\n        res\\n    }\\n\\n    fn dfs(s: &str, a: i32, b: i32, seen: &mut HashSet<String>) -> Option<String> {\\n        if !seen.contains(s) {\\n            let mut res = s.to_string();\\n            seen.insert(s.to_string());\\n            if let Some(ss) = Self::dfs(&Self::rotate(s, b), a, b, seen) {\\n                res = min(res, ss);\\n            }\\n            if let Some(ss) = Self::dfs(&Self::add(s, a), a, b, seen) {\\n                res = min(res, ss);\\n            }\\n            Some(res)\\n        } else {\\n            None\\n        }\\n    }\\n\\n    pub fn find_lex_smallest_string(s: String, a: i32, b: i32) -> String {\\n        let mut seen = HashSet::new();\\n        Self::dfs(&s, a, b, &mut seen).unwrap()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3091416,
                "title": "java-simple-solution-using-bfs",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    public String addByA(String s, int a) {\\n        int n = s.length();\\n        char[] arr = s.toCharArray();\\n        for(int i=1;i<n;i+=2) {\\n            int x = (arr[i]-\\'0\\')+a;\\n            x = x%10;\\n            arr[i] = (char)(x+\\'0\\');\\n        }\\n        return new String(arr);\\n    }\\n\\n    public String rotateByB(String s, int b) {\\n        int n = s.length();\\n        return s.substring(n-b, n) + s.substring(0, n-b);\\n    }\\n\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Deque<String> queue = new ArrayDeque<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.addLast(s);\\n        visited.add(s);\\n        String ans = s;\\n        while(!queue.isEmpty()) {\\n            String str = queue.pollFirst();\\n            String opA = addByA(str, a);\\n            if(!visited.contains(opA)) {\\n                if(ans.compareTo(opA) > 0)\\n                    ans = opA;\\n                queue.addLast(opA);\\n                visited.add(opA);\\n            }\\n            String opB = rotateByB(str, b);\\n            if(!visited.contains(opB)) {\\n                if(ans.compareTo(opB) > 0)\\n                    ans = opB;\\n                queue.addLast(opB);\\n                visited.add(opB);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String addByA(String s, int a) {\\n        int n = s.length();\\n        char[] arr = s.toCharArray();\\n        for(int i=1;i<n;i+=2) {\\n            int x = (arr[i]-\\'0\\')+a;\\n            x = x%10;\\n            arr[i] = (char)(x+\\'0\\');\\n        }\\n        return new String(arr);\\n    }\\n\\n    public String rotateByB(String s, int b) {\\n        int n = s.length();\\n        return s.substring(n-b, n) + s.substring(0, n-b);\\n    }\\n\\n    public String findLexSmallestString(String s, int a, int b) {\\n        Deque<String> queue = new ArrayDeque<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.addLast(s);\\n        visited.add(s);\\n        String ans = s;\\n        while(!queue.isEmpty()) {\\n            String str = queue.pollFirst();\\n            String opA = addByA(str, a);\\n            if(!visited.contains(opA)) {\\n                if(ans.compareTo(opA) > 0)\\n                    ans = opA;\\n                queue.addLast(opA);\\n                visited.add(opA);\\n            }\\n            String opB = rotateByB(str, b);\\n            if(!visited.contains(opB)) {\\n                if(ans.compareTo(opB) > 0)\\n                    ans = opB;\\n                queue.addLast(opB);\\n                visited.add(opB);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917992,
                "title": "python-bfs",
                "content": "\\tclass Solution:\\n\\t\\tdef findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t\\tque = deque([s])\\n\\t\\t\\tans = s\\n\\t\\t\\tvisited = set([s])\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\ts = que.popleft()\\n\\t\\t\\t\\tans = min(ans, s)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsumm = \"\"\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\t\\tsumm += str((int(s[i])+a)%10)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsumm += s[i]  \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif summ not in visited:\\n\\t\\t\\t\\t\\tque.append(summ)\\n\\t\\t\\t\\t\\tvisited.add(summ)\\n\\t\\t\\t\\tif s[-b:]+s[:-b] not in visited:\\n\\t\\t\\t\\t\\tque.append(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\tvisited.add(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\treturn ans \\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t\\tque = deque([s])\\n\\t\\t\\tans = s\\n\\t\\t\\tvisited = set([s])\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\ts = que.popleft()\\n\\t\\t\\t\\tans = min(ans, s)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsumm = \"\"\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\t\\tsumm += str((int(s[i])+a)%10)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsumm += s[i]  \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif summ not in visited:\\n\\t\\t\\t\\t\\tque.append(summ)\\n\\t\\t\\t\\t\\tvisited.add(summ)\\n\\t\\t\\t\\tif s[-b:]+s[:-b] not in visited:\\n\\t\\t\\t\\t\\tque.append(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\tvisited.add(s[-b:]+s[:-b])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\treturn ans \\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2878449,
                "title": "python-traverse-a-binary-tree-and-pick-min",
                "content": "Build a binary tree where children are: added, rotated. Repeat till you exhaust the search space.\\n\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        N = len(s)\\n        seen = set()\\n        queue = deque([s])\\n\\n        ans = s\\n        while queue:\\n            cur = queue.popleft()\\n            \\n            rotated = cur[-b:] + cur[:-b]\\n            added = \\'\\'.join(str((int(cur[i]) + a) % 10) if i % 2 else cur[i] for i in range(N))\\n            \\n            for nxt in rotated, added:\\n                if nxt not in seen:\\n                    queue.append(nxt)\\n                    seen.add(nxt)\\n                    ans = min(ans, nxt)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        N = len(s)\\n        seen = set()\\n        queue = deque([s])\\n\\n        ans = s\\n        while queue:\\n            cur = queue.popleft()\\n            \\n            rotated = cur[-b:] + cur[:-b]\\n            added = \\'\\'.join(str((int(cur[i]) + a) % 10) if i % 2 else cur[i] for i in range(N))\\n            \\n            for nxt in rotated, added:\\n                if nxt not in seen:\\n                    queue.append(nxt)\\n                    seen.add(nxt)\\n                    ans = min(ans, nxt)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844093,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> seen;\\n        queue<string> q;\\n        q.push(s), seen.insert(s);\\n        \\n        function<string(string, int)> rotate = [](string s, int r)->string {\\n            return s.substr(r) + s.substr(0, r);\\n        };\\n        function<string(string, int)> add = [](string s, int a)->string {\\n            for(int i = 1; i < s.size(); i += 2) s[i] = (s[i]-\\'0\\'+a)%10 + \\'0\\';\\n            return s;\\n        };\\n\\n        string res = s;\\n        while(!q.empty()) {\\n            string t = q.front(); q.pop();\\n            res = min(res, t);\\n\\n            string rr = rotate(t, b), aa = add(t, a);\\n            if(seen.find(rr) == seen.end()) q.push(rr), seen.insert(rr);\\n            if(seen.find(aa) == seen.end()) q.push(aa), seen.insert(aa);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> seen;\\n        queue<string> q;\\n        q.push(s), seen.insert(s);\\n        \\n        function<string(string, int)> rotate = [](string s, int r)->string {\\n            return s.substr(r) + s.substr(0, r);\\n        };\\n        function<string(string, int)> add = [](string s, int a)->string {\\n            for(int i = 1; i < s.size(); i += 2) s[i] = (s[i]-\\'0\\'+a)%10 + \\'0\\';\\n            return s;\\n        };\\n\\n        string res = s;\\n        while(!q.empty()) {\\n            string t = q.front(); q.pop();\\n            res = min(res, t);\\n\\n            string rr = rotate(t, b), aa = add(t, a);\\n            if(seen.find(rr) == seen.end()) q.push(rr), seen.insert(rr);\\n            if(seen.find(aa) == seen.end()) q.push(aa), seen.insert(aa);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792510,
                "title": "easy-approach-using-dfs",
                "content": "```\\nclass Solution {\\n     HashSet<String> set=new HashSet<>();  // storing all the unique possible string .\\n    int a,b;\\n    String ans;\\n    private void dfs(String str){\\n        if(set.contains(str))return;\\n        if(ans.compareTo(str)>0)ans=str;  // After each operation comparing our new string to the last string and updating accordingly.\\n        set.add(str);\\n        dfs(add(str));\\n        dfs(rotate(str));\\n    }\\n\\t// Adding a to all the odd place of the string\\n        private String add(String str){\\n            StringBuilder s=new StringBuilder();\\n            for(int i=00; i<str.length(); i++){\\n                if(i%2==0){\\n                    s.append(str.charAt(i));\\n                }\\n                else{\\n                    s.append((str.charAt(i)-\\'0\\'+a)%10);\\n                }\\n            }\\n                            return s.toString();\\n        }\\n\\t\\t// Rotating the string from b\\n        private String rotate(String s){\\n            int n=s.length();\\n            return s.substring(n-b,n)+s.substring(0,n-b);\\n        }\\n    public String findLexSmallestString(String s, int a, int b) {\\n        ans=s;\\n        this.a=a;\\n        this.b=b;\\n        dfs(s);\\n        return ans;\\n    }\\n}\\n// If any help or query , just post in comment box \\n// upvote if it was useful for you.\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     HashSet<String> set=new HashSet<>();  // storing all the unique possible string .\\n    int a,b;\\n    String ans;\\n    private void dfs(String str){\\n        if(set.contains(str))return;\\n        if(ans.compareTo(str)>0)ans=str;  // After each operation comparing our new string to the last string and updating accordingly.\\n        set.add(str);\\n        dfs(add(str));\\n        dfs(rotate(str));\\n    }\\n\\t// Adding a to all the odd place of the string\\n        private String add(String str){\\n            StringBuilder s=new StringBuilder();\\n            for(int i=00; i<str.length(); i++){\\n                if(i%2==0){\\n                    s.append(str.charAt(i));\\n                }\\n                else{\\n                    s.append((str.charAt(i)-\\'0\\'+a)%10);\\n                }\\n            }\\n                            return s.toString();\\n        }\\n\\t\\t// Rotating the string from b\\n        private String rotate(String s){\\n            int n=s.length();\\n            return s.substring(n-b,n)+s.substring(0,n-b);\\n        }\\n    public String findLexSmallestString(String s, int a, int b) {\\n        ans=s;\\n        this.a=a;\\n        this.b=b;\\n        dfs(s);\\n        return ans;\\n    }\\n}\\n// If any help or query , just post in comment box \\n// upvote if it was useful for you.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762440,
                "title": "c-easy-short",
                "content": "checking all the posibility of the string with the given operations...\\n```\\nclass Solution {\\npublic:\\n    string ans=\"\";\\nunordered_set<string>vis;\\nstring findLexSmallestString(string s, int a, int b) \\n{\\n\\tqueue<string>q;\\n\\tq.push(s);\\n\\tvis.insert(s);\\n\\t\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tstring str = q.front();\\n\\t\\tq.pop();\\n\\t\\t\\n\\t\\tif(ans.length()==0)\\n\\t\\t{\\n\\t\\t\\tans=str;\\n\\t\\t}\\n\\t\\telse if(ans.length()>0 and str < ans)\\n\\t\\t{\\n\\t\\t\\tans=str;\\n\\t\\t}\\n\\t\\t//for the curr string we have the choise for adding a to all odd indices\\n\\t\\tstring temp=\"\";\\n\\t\\tfor(int i=0;i<str.length();i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = str[i];\\n\\t\\t\\tif((i%2)==0)   //it is even idex\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.push_back(ch);\\n\\t\\t\\t}\\n\\t\\t\\telse if((i%2)!=0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint digit1 = str[i]-\\'0\\';\\n\\t\\t\\t\\tint digit2 = a;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint result = (digit1+digit2)%10;\\n\\t\\t\\t\\tchar c = result + \\'0\\';\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ttemp.push_back(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(vis.find(temp)==vis.end())\\n\\t\\t{\\n\\t\\t\\tq.push(temp);\\n\\t\\t\\tvis.insert(temp);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//for the curr string we have options to rotate it with b postions\\n\\t\\ttemp=str;\\n\\t\\trotate(temp.begin(), temp.begin()+temp.length()-b, temp.end());\\n\\t\\tif(vis.find(temp)==vis.end())\\n\\t\\t{\\n\\t\\t\\tq.push(temp);\\n\\t\\t\\tvis.insert(temp);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans=\"\";\\nunordered_set<string>vis;\\nstring findLexSmallestString(string s, int a, int b) \\n{\\n\\tqueue<string>q;\\n\\tq.push(s);\\n\\tvis.insert(s);\\n\\t\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tstring str = q.front();\\n\\t\\tq.pop();\\n\\t\\t\\n\\t\\tif(ans.length()==0)\\n\\t\\t{\\n\\t\\t\\tans=str;\\n\\t\\t}\\n\\t\\telse if(ans.length()>0 and str < ans)\\n\\t\\t{\\n\\t\\t\\tans=str;\\n\\t\\t}\\n\\t\\t//for the curr string we have the choise for adding a to all odd indices\\n\\t\\tstring temp=\"\";\\n\\t\\tfor(int i=0;i<str.length();i++)\\n\\t\\t{\\n\\t\\t\\tchar ch = str[i];\\n\\t\\t\\tif((i%2)==0)   //it is even idex\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.push_back(ch);\\n\\t\\t\\t}\\n\\t\\t\\telse if((i%2)!=0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint digit1 = str[i]-\\'0\\';\\n\\t\\t\\t\\tint digit2 = a;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint result = (digit1+digit2)%10;\\n\\t\\t\\t\\tchar c = result + \\'0\\';\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ttemp.push_back(c);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(vis.find(temp)==vis.end())\\n\\t\\t{\\n\\t\\t\\tq.push(temp);\\n\\t\\t\\tvis.insert(temp);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//for the curr string we have options to rotate it with b postions\\n\\t\\ttemp=str;\\n\\t\\trotate(temp.begin(), temp.begin()+temp.length()-b, temp.end());\\n\\t\\tif(vis.find(temp)==vis.end())\\n\\t\\t{\\n\\t\\t\\tq.push(temp);\\n\\t\\t\\tvis.insert(temp);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762198,
                "title": "c-bfs-solution-using-stl-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        // add a to odd indices\\n        // rotate s to right by b position \\n        queue<string>q;\\n        unordered_set<string>st;\\n        st.insert(s);\\n        q.push(s);\\n        string ans=s;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                string temp=q.front();\\n                string temp1=temp;\\n                string temp2=temp;\\n                q.pop();\\n                if(temp<ans)\\n                {\\n                    ans=temp;\\n                }\\n                //add a to odd indices\\n                for(int j=1;j<temp.length();j+=2)\\n                {\\n                    int num=temp[j]-\\'0\\'+a;\\n                    char ch=(num%10)+\\'0\\';\\n                    temp1[j]=ch;\\n                }\\n                if(st.find(temp1)==st.end())\\n                {\\n                    st.insert(temp1);\\n                    q.push(temp1);\\n                }\\n                //rotate s to right by b position \\n                rotate(temp2.begin(), temp2.begin()+temp2.size()-b, temp2.end());\\n                if(st.find(temp2)==st.end())\\n                {\\n                    st.insert(temp2);\\n                    q.push(temp2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        // add a to odd indices\\n        // rotate s to right by b position \\n        queue<string>q;\\n        unordered_set<string>st;\\n        st.insert(s);\\n        q.push(s);\\n        string ans=s;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                string temp=q.front();\\n                string temp1=temp;\\n                string temp2=temp;\\n                q.pop();\\n                if(temp<ans)\\n                {\\n                    ans=temp;\\n                }\\n                //add a to odd indices\\n                for(int j=1;j<temp.length();j+=2)\\n                {\\n                    int num=temp[j]-\\'0\\'+a;\\n                    char ch=(num%10)+\\'0\\';\\n                    temp1[j]=ch;\\n                }\\n                if(st.find(temp1)==st.end())\\n                {\\n                    st.insert(temp1);\\n                    q.push(temp1);\\n                }\\n                //rotate s to right by b position \\n                rotate(temp2.begin(), temp2.begin()+temp2.size()-b, temp2.end());\\n                if(st.find(temp2)==st.end())\\n                {\\n                    st.insert(temp2);\\n                    q.push(temp2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755670,
                "title": "c-bfs-and-dfs-solutions",
                "content": "**BFS Solution**\\n```\\nclass Solution {\\npublic:\\n    string rotate(string s, int b) {\\n        \\n        reverse(s.begin(), s.end());\\n        reverse(s.begin(), s.begin()+b);\\n        reverse(s.begin()+b, s.end());\\n        \\n        return s;\\n        \\n    }\\n    \\n    string add(string s, int a) {\\n        \\n        for(int i=1;i<s.size();i+=2) {\\n            \\n            s[i] = \\'0\\' + (s[i]-\\'0\\'+a)%10;\\n            \\n        }\\n        \\n        return s;\\n        \\n    }\\n    \\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        unordered_set<string> seen;\\n        \\n        queue<string> q;\\n        q.push(s);\\n        \\n        string ans = s;\\n        seen.insert(s);\\n        \\n        while(!q.empty()) {\\n            \\n            string st = q.front();\\n            q.pop();\\n            \\n            ans = min(ans, st);\\n            \\n            string x = rotate(st, b);\\n            string b = add(st, a);\\n            \\n            if(seen.find(x)==seen.end()) {\\n                q.push(x);\\n                seen.insert(x);\\n            }\\n            \\n            if(seen.find(b)==seen.end()) {\\n                q.push(b);\\n                seen.insert(b);\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**DFS Solution**\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_set<string> visited; // to keep track of the strings visited\\n    \\n    bool already_visited(string s){\\n        \\n        return !(visited.find(s)==visited.end());\\n    }\\n    \\n    string add(string s, int a) {\\n        \\n        for(int i=1;i<s.size();i+=2) {\\n            \\n            s[i] = \\'0\\' + (s[i] -\\'0\\'+ a)%10;\\n            \\n        }\\n        return s;\\n        \\n    }\\n    \\n    string rotate(string s, int b) {\\n        \\n        reverse(s.begin(), s.end());\\n        \\n        reverse(s.begin(), s.begin()+b);\\n        reverse(s.begin()+b, s.end());\\n        \\n        return s;\\n        \\n    }\\n    \\n    void dfs(string s, string& ans, int a, int b) {\\n        \\n        if(already_visited(s)) {\\n            return;\\n        }\\n        visited.insert(s);\\n        ans = min(ans, s);\\n        \\n        dfs(add(s,a), ans, a, b);\\n        dfs(rotate(s,b), ans, a, b);\\n        \\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        string ans = s;\\n        \\n        dfs(s, ans, a, b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string rotate(string s, int b) {\\n        \\n        reverse(s.begin(), s.end());\\n        reverse(s.begin(), s.begin()+b);\\n        reverse(s.begin()+b, s.end());\\n        \\n        return s;\\n        \\n    }\\n    \\n    string add(string s, int a) {\\n        \\n        for(int i=1;i<s.size();i+=2) {\\n            \\n            s[i] = \\'0\\' + (s[i]-\\'0\\'+a)%10;\\n            \\n        }\\n        \\n        return s;\\n        \\n    }\\n    \\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        unordered_set<string> seen;\\n        \\n        queue<string> q;\\n        q.push(s);\\n        \\n        string ans = s;\\n        seen.insert(s);\\n        \\n        while(!q.empty()) {\\n            \\n            string st = q.front();\\n            q.pop();\\n            \\n            ans = min(ans, st);\\n            \\n            string x = rotate(st, b);\\n            string b = add(st, a);\\n            \\n            if(seen.find(x)==seen.end()) {\\n                q.push(x);\\n                seen.insert(x);\\n            }\\n            \\n            if(seen.find(b)==seen.end()) {\\n                q.push(b);\\n                seen.insert(b);\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_set<string> visited; // to keep track of the strings visited\\n    \\n    bool already_visited(string s){\\n        \\n        return !(visited.find(s)==visited.end());\\n    }\\n    \\n    string add(string s, int a) {\\n        \\n        for(int i=1;i<s.size();i+=2) {\\n            \\n            s[i] = \\'0\\' + (s[i] -\\'0\\'+ a)%10;\\n            \\n        }\\n        return s;\\n        \\n    }\\n    \\n    string rotate(string s, int b) {\\n        \\n        reverse(s.begin(), s.end());\\n        \\n        reverse(s.begin(), s.begin()+b);\\n        reverse(s.begin()+b, s.end());\\n        \\n        return s;\\n        \\n    }\\n    \\n    void dfs(string s, string& ans, int a, int b) {\\n        \\n        if(already_visited(s)) {\\n            return;\\n        }\\n        visited.insert(s);\\n        ans = min(ans, s);\\n        \\n        dfs(add(s,a), ans, a, b);\\n        dfs(rotate(s,b), ans, a, b);\\n        \\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        string ans = s;\\n        \\n        dfs(s, ans, a, b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753444,
                "title": "python-recursive-approach-trying-all-possibilites",
                "content": "```\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n        \"\"\"\\n        :type s: str\\n        :type a: int\\n        :type b: int\\n        :rtype: str\\n        \"\"\"\\n        \\n        ans = [s]\\n\\n        def rotate(s):\\n            first_half = s[:b]\\n            second_half = s[b:]\\n\\n            currString_rotated = second_half + first_half\\n            return currString_rotated\\n        \\n        def add(s):\\n            s = list(s)\\n            for idx,val in enumerate(s):\\n                if idx & 1:\\n                    val = (int(val) + a)\\n                    if val > 9:\\n                        val = (val % 10)\\n                    s[idx] = str(val)\\n                    \\n            return \"\".join(s)\\n            \\n        \\n        lexo_strings = set()\\n        \\n        def helper(prevString):\\n            \\n            if prevString in lexo_strings:\\n                return\\n            \\n            ans[0] = min(ans[0],prevString)\\n            lexo_strings.add(prevString)\\n            \\n            currString_rotated = rotate(prevString)\\n            helper(currString_rotated)\\n                \\n            currString_added = add(prevString)\\n            helper(currString_added)\\n                \\n            \\n        helper(s)\\n        return ans[0]\\n            \\n```",
                "solutionTags": [
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def findLexSmallestString(self, s, a, b):\\n        \"\"\"\\n        :type s: str\\n        :type a: int\\n        :type b: int\\n        :rtype: str\\n        \"\"\"\\n        \\n        ans = [s]\\n\\n        def rotate(s):\\n            first_half = s[:b]\\n            second_half = s[b:]\\n\\n            currString_rotated = second_half + first_half\\n            return currString_rotated\\n        \\n        def add(s):\\n            s = list(s)\\n            for idx,val in enumerate(s):\\n                if idx & 1:\\n                    val = (int(val) + a)\\n                    if val > 9:\\n                        val = (val % 10)\\n                    s[idx] = str(val)\\n                    \\n            return \"\".join(s)\\n            \\n        \\n        lexo_strings = set()\\n        \\n        def helper(prevString):\\n            \\n            if prevString in lexo_strings:\\n                return\\n            \\n            ans[0] = min(ans[0],prevString)\\n            lexo_strings.add(prevString)\\n            \\n            currString_rotated = rotate(prevString)\\n            helper(currString_rotated)\\n                \\n            currString_added = add(prevString)\\n            helper(currString_added)\\n                \\n            \\n        helper(s)\\n        return ans[0]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705527,
                "title": "brute-force-bfs-hashset-c-code-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tvoid rotate(string &temp2,int b)\\n\\t\\t{\\n\\t\\t\\tstring x;\\n\\t\\t\\tint i;\\n\\t\\t\\tfor(i=temp2.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tx+=temp2[i];\\n\\t\\t\\t\\t\\tb--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\treverse(x.begin(),x.end());\\n\\t\\t\\tstring y = temp2.substr(0,i+1);\\n\\t\\t\\ttemp2 = x+y;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tstring findLexSmallestString(string str, int a, int b) \\n\\t\\t{\\n\\t\\t\\tset<string>s;\\n\\t\\t\\tqueue<string>q;\\n\\t\\t\\tq.push(str);\\n\\t\\t\\tstring mini = str;\\n\\t\\t\\ts.insert(str);\\n\\t\\t\\tint n = str.size();\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring x = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tstring temp1 = x;\\n\\t\\t\\t\\tfor(int i=1;i<n;i+=2)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint number = temp1[i]-\\'0\\';\\n\\t\\t\\t\\t\\tnumber = (number+a)%10;\\n\\t\\t\\t\\t\\ttemp1[i] = number+\\'0\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s.find(temp1)==s.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmini = min(mini,temp1);\\n\\t\\t\\t\\t\\ts.insert(temp1);\\n\\t\\t\\t\\t\\tq.push(temp1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstring temp2 = x;\\n\\t\\t\\t\\tb%=x.size();\\n\\t\\t\\t\\trotate(temp2,b);\\n\\t\\t\\t\\tif(s.find(temp2)==s.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmini = min(mini,temp2);\\n\\t\\t\\t\\t\\ts.insert(temp2);\\n\\t\\t\\t\\t\\tq.push(temp2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn mini;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tvoid rotate(string &temp2,int b)\\n\\t\\t{\\n\\t\\t\\tstring x;\\n\\t\\t\\tint i;\\n\\t\\t\\tfor(i=temp2.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tx+=temp2[i];\\n\\t\\t\\t\\t\\tb--;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2702743,
                "title": "python-dfs-solution-faster-than-80",
                "content": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        visited, sz = set(), len(s)\\n        \\n        def rotate(s: str, b: int) -> str:\\n            return s[b:] + s[:b]\\n        \\n        def add(s: str, a: int) -> str:\\n            s = list(s)\\n            for idx in range(1, sz, 2):\\n                s[idx] = chr(ord(\\'0\\') + ((ord(s[idx]) - ord(\\'0\\') + a) % 10))\\n            return \\'\\'.join(s)\\n        \\n        def dfs(s: str) -> None:\\n            nonlocal ans\\n            if s in visited:\\n                return\\n            ans = min(ans, s)\\n            visited.add(s)\\n            dfs(rotate(s, b))\\n            dfs(add(s, a))\\n            \\n        ans = s\\n        dfs(s)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        visited, sz = set(), len(s)\\n        \\n        def rotate(s: str, b: int) -> str:\\n            return s[b:] + s[:b]\\n        \\n        def add(s: str, a: int) -> str:\\n            s = list(s)\\n            for idx in range(1, sz, 2):\\n                s[idx] = chr(ord(\\'0\\') + ((ord(s[idx]) - ord(\\'0\\') + a) % 10))\\n            return \\'\\'.join(s)\\n        \\n        def dfs(s: str) -> None:\\n            nonlocal ans\\n            if s in visited:\\n                return\\n            ans = min(ans, s)\\n            visited.add(s)\\n            dfs(rotate(s, b))\\n            dfs(add(s, a))\\n            \\n        ans = s\\n        dfs(s)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595258,
                "title": "python-bfs-solution",
                "content": "```\\ndef findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\tq = deque([s])\\n\\tvisited = set([s])\\n\\twhile(q):\\n\\t\\ts = q.popleft()\\n\\t\\tnxt = \\'\\'.join([str((int(s[i])+a)%10) if i%2 else s[i] for i in range(len(s))])\\n\\t\\tif nxt not in visited:\\n\\t\\t\\tq.append(nxt)\\n\\t\\t\\tvisited.add(nxt)\\n\\t\\tnxt = s[-b:]+s[:-b]\\n\\t\\tif nxt not in visited:\\n\\t\\t\\tq.append(nxt)\\n\\t\\t\\tvisited.add(nxt)\\n\\treturn min(visited)\\n```",
                "solutionTags": [],
                "code": "```\\ndef findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\tq = deque([s])\\n\\tvisited = set([s])\\n\\twhile(q):\\n\\t\\ts = q.popleft()\\n\\t\\tnxt = \\'\\'.join([str((int(s[i])+a)%10) if i%2 else s[i] for i in range(len(s))])\\n\\t\\tif nxt not in visited:\\n\\t\\t\\tq.append(nxt)\\n\\t\\t\\tvisited.add(nxt)\\n\\t\\tnxt = s[-b:]+s[:-b]\\n\\t\\tif nxt not in visited:\\n\\t\\t\\tq.append(nxt)\\n\\t\\t\\tvisited.add(nxt)\\n\\treturn min(visited)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2461468,
                "title": "python-clean-dfs-solution",
                "content": "```\\nclass Solution:\\n  def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n    N = \\'0123456789\\'\\n    d = dict(zip(N,zip(N,N[-a]+N)))\\n    se = set()\\n    def dfs(s):\\n      if s not in se:\\n        se.add(s)\\n        dfs(\\'\\'.join(d[c][i&1] for i,c in enumerate(s)))\\n        dfs(s[-b:] + s[:-b])\\n    dfs(s)\\n    return min(se)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n    N = \\'0123456789\\'\\n    d = dict(zip(N,zip(N,N[-a]+N)))\\n    se = set()\\n    def dfs(s):\\n      if s not in se:\\n        se.add(s)\\n        dfs(\\'\\'.join(d[c][i&1] for i,c in enumerate(s)))\\n        dfs(s[-b:] + s[:-b])\\n    dfs(s)\\n    return min(se)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461088,
                "title": "bfs-priorityqueue-java-400ms",
                "content": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        \\n      Queue<String> res = new PriorityQueue<>((letterA,letterB)->letterA.compareTo(letterB));\\n      Set<String> visited=new HashSet<>();\\n      Queue<String> queue=new LinkedList<>();\\n      queue.add(s);\\n      res.add(s);\\n      while(!queue.isEmpty())\\n      {\\n        int size=queue.size();\\n        for(int i=0;i<size;i++)\\n        {\\n          String current=queue.poll(); \\n          current=rotate(current,b);\\n          \\n          if(!visited.contains(current)) \\n          {\\n            visited.add(current);\\n            queue.add(current);\\n            res.add(current);\\n          } \\n          \\n          current=add(current,a);   \\n          \\n          if(!visited.contains(current))\\n          {\\n            visited.add(current);\\n            queue.add(current);\\n            res.add(current);\\n          }  \\n          \\n        }\\n      } \\n      return res.poll();\\n    }\\n  \\n  private String rotate(String str, int b)\\n  {\\n    StringBuilder sb=new StringBuilder(str);  \\n    for(int i=0;i<b;i++)\\n    {\\n      Character last=sb.charAt(sb.length()-1); \\n      sb.deleteCharAt(sb.length()-1); \\n      sb.insert(0,last);\\n    }  \\n    return sb.toString();\\n  }\\n  \\n  private String add(String str,int a)\\n  {\\n    StringBuilder sb=new StringBuilder(str); \\n    for(int i=0;i<sb.length();i++)\\n    {\\n      if(i%2!=0)\\n      {\\n        int result=Character.getNumericValue(sb.charAt(i))+a;\\n        result=result>=10?result%10:result;\\n        sb.setCharAt(i,Character.forDigit(result,10));\\n      }\\n    }  \\n    return sb.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        \\n      Queue<String> res = new PriorityQueue<>((letterA,letterB)->letterA.compareTo(letterB));\\n      Set<String> visited=new HashSet<>();\\n      Queue<String> queue=new LinkedList<>();\\n      queue.add(s);\\n      res.add(s);\\n      while(!queue.isEmpty())\\n      {\\n        int size=queue.size();\\n        for(int i=0;i<size;i++)\\n        {\\n          String current=queue.poll(); \\n          current=rotate(current,b);\\n          \\n          if(!visited.contains(current)) \\n          {\\n            visited.add(current);\\n            queue.add(current);\\n            res.add(current);\\n          } \\n          \\n          current=add(current,a);   \\n          \\n          if(!visited.contains(current))\\n          {\\n            visited.add(current);\\n            queue.add(current);\\n            res.add(current);\\n          }  \\n          \\n        }\\n      } \\n      return res.poll();\\n    }\\n  \\n  private String rotate(String str, int b)\\n  {\\n    StringBuilder sb=new StringBuilder(str);  \\n    for(int i=0;i<b;i++)\\n    {\\n      Character last=sb.charAt(sb.length()-1); \\n      sb.deleteCharAt(sb.length()-1); \\n      sb.insert(0,last);\\n    }  \\n    return sb.toString();\\n  }\\n  \\n  private String add(String str,int a)\\n  {\\n    StringBuilder sb=new StringBuilder(str); \\n    for(int i=0;i<sb.length();i++)\\n    {\\n      if(i%2!=0)\\n      {\\n        int result=Character.getNumericValue(sb.charAt(i))+a;\\n        result=result>=10?result%10:result;\\n        sb.setCharAt(i,Character.forDigit(result,10));\\n      }\\n    }  \\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412057,
                "title": "c-recursion",
                "content": "![image](https://assets.leetcode.com/users/images/d475e545-caa8-4fee-ac33-436c639df442_1660235906.9542036.jpeg)\\n\\n\\n\\n\\n\\n\\n\\n```\\n\\n\\nclass Solution {\\n    string rotate(string s,int i){\\n        reverse(s.begin(),s.begin()+i);\\n        reverse(s.begin()+i,s.end());\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    string add(string s,int i){\\n        int k=0;\\n        while(k<s.length()){\\n            int temp=((s[k]-\\'0\\')+i)%10+\\'0\\';\\n            if(k%2!=0){\\n                s[k]=char(temp);\\n            }\\n            k++;\\n        }\\n        return s;\\n    }\\n    map<string,bool>m;\\n    void solve(string s,int a,int b){\\n        if(m[s]){\\n            return;\\n        }\\n        m[s]=true;\\n        string s1=rotate(s,b);\\n        solve(s1,a,b);\\n        string s2=add(s,a);\\n        solve(s2,a,b);\\n    }\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        solve(s,a,b);  \\n        return m.begin()->first;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    string rotate(string s,int i){\\n        reverse(s.begin(),s.begin()+i);\\n        reverse(s.begin()+i,s.end());\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    string add(string s,int i){\\n        int k=0;\\n        while(k<s.length()){\\n            int temp=((s[k]-\\'0\\')+i)%10+\\'0\\';\\n            if(k%2!=0){\\n                s[k]=char(temp);\\n            }\\n            k++;\\n        }\\n        return s;\\n    }\\n    map<string,bool>m;\\n    void solve(string s,int a,int b){\\n        if(m[s]){\\n            return;\\n        }\\n        m[s]=true;\\n        string s1=rotate(s,b);\\n        solve(s1,a,b);\\n        string s2=add(s,a);\\n        solve(s2,a,b);\\n    }\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        solve(s,a,b);  \\n        return m.begin()->first;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383197,
                "title": "c-time-complexity-o-n-2-space-complexity-o-n-considering-dof-2",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {            \\n        int len = s.size();\\n        \\n        // find the offset, such that each digit becomes the smallest\\n        vector<int> V_offset(10,0);\\n        for(int i = 1; i < 10; i++){\\n            int min = i;\\n            int offset = 0;\\n            int j = 9;\\n            while(j--){\\n                offset += a;\\n                int num = (i+offset)%10;\\n                if(min > num){\\n                    min = num;\\n                    V_offset[i] = offset%10;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < len; i++){\\n            s[i] -= \\'0\\';\\n        }\\n        \\n        //Only two dimension of freedom, namely odd indices (i) & even indices (i+1)\\n        string s_min = s;\\n        vector<int> visited(len,0);\\n        for(int i = 0; visited[i] != 1; i=(i+b)%len){\\n            visited[i] = 1;\\n            // MSB of the odd indices\\n            int dig1 = s[i], off1 = 0;\\n            if(b % 2 == 1){ // only when b is odd number can the odd indices be influenced by the 1st operation\\n                off1 = V_offset[dig1];\\n                dig1 = (dig1+off1)%10;\\n            }\\n            if(dig1 > s_min[i]){continue;}\\n            \\n            // MSB of the even indices\\n            int dig2 = s[(i+1)%len];\\n            vector<int> visited_num(10,0);\\n            int off2 = V_offset[dig2];\\n            int new_dig2 = (dig2+off2)%10;\\n\\n            if(dig1 == s_min[i] &&  new_dig2 > dig2 ){continue;}\\n\\n            //do the 1st operation\\n            string tmp = s.substr(i,len-i) + s.substr(0,i);\\n            if(off1){\\n                for(int k = 0; k < len; k+=2){\\n                    tmp[k] = (tmp[k]+off1)%10;\\n                }\\n            }\\n            for(int k = 1; k < len; k+=2){\\n                tmp[k] = (tmp[k]+off2)%10;\\n            }\\n\\n            if(tmp < s_min){s_min = tmp;}\\n        }\\n        \\n        for(int i = 0 ; i < len; i++){\\n            s_min[i] += \\'0\\';\\n        }\\n        \\n        return s_min;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {            \\n        int len = s.size();\\n        \\n        // find the offset, such that each digit becomes the smallest\\n        vector<int> V_offset(10,0);\\n        for(int i = 1; i < 10; i++){\\n            int min = i;\\n            int offset = 0;\\n            int j = 9;\\n            while(j--){\\n                offset += a;\\n                int num = (i+offset)%10;\\n                if(min > num){\\n                    min = num;\\n                    V_offset[i] = offset%10;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < len; i++){\\n            s[i] -= \\'0\\';\\n        }\\n        \\n        //Only two dimension of freedom, namely odd indices (i) & even indices (i+1)\\n        string s_min = s;\\n        vector<int> visited(len,0);\\n        for(int i = 0; visited[i] != 1; i=(i+b)%len){\\n            visited[i] = 1;\\n            // MSB of the odd indices\\n            int dig1 = s[i], off1 = 0;\\n            if(b % 2 == 1){ // only when b is odd number can the odd indices be influenced by the 1st operation\\n                off1 = V_offset[dig1];\\n                dig1 = (dig1+off1)%10;\\n            }\\n            if(dig1 > s_min[i]){continue;}\\n            \\n            // MSB of the even indices\\n            int dig2 = s[(i+1)%len];\\n            vector<int> visited_num(10,0);\\n            int off2 = V_offset[dig2];\\n            int new_dig2 = (dig2+off2)%10;\\n\\n            if(dig1 == s_min[i] &&  new_dig2 > dig2 ){continue;}\\n\\n            //do the 1st operation\\n            string tmp = s.substr(i,len-i) + s.substr(0,i);\\n            if(off1){\\n                for(int k = 0; k < len; k+=2){\\n                    tmp[k] = (tmp[k]+off1)%10;\\n                }\\n            }\\n            for(int k = 1; k < len; k+=2){\\n                tmp[k] = (tmp[k]+off2)%10;\\n            }\\n\\n            if(tmp < s_min){s_min = tmp;}\\n        }\\n        \\n        for(int i = 0 ; i < len; i++){\\n            s_min[i] += \\'0\\';\\n        }\\n        \\n        return s_min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379508,
                "title": "easy-dfs-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    //as max string length is given as 100\\n    string ans=\"999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\";\\n    unordered_set<string> st;\\n    \\n    \\n    void f(string s, int a, int b)\\n    {\\n        ans=min(ans,s);\\n        if(st.count(s)) return;\\n        st.insert(s);\\n\\t\\t\\n\\t\\t\\n\\t\\t//addition part\\n        string s1 = s;\\n        for(int i=1;i<s1.length();i+=2)\\n        {\\n            s1[i] = (((s1[i]-\\'0\\')+a) % 10) + \\'0\\';\\n        }\\n        f(s1,a,b);\\n        \\n        \\n\\t\\t//reverse part\\n        reverse(s.begin()+s.length()-b, s.end());\\n        reverse(s.begin(), s.begin()+s.length()-b);\\n        reverse(s.begin(), s.end());\\n        f(s,a,b);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        f(s,a,b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //as max string length is given as 100\\n    string ans=\"999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\";\\n    unordered_set<string> st;\\n    \\n    \\n    void f(string s, int a, int b)\\n    {\\n        ans=min(ans,s);\\n        if(st.count(s)) return;\\n        st.insert(s);\\n\\t\\t\\n\\t\\t\\n\\t\\t//addition part\\n        string s1 = s;\\n        for(int i=1;i<s1.length();i+=2)\\n        {\\n            s1[i] = (((s1[i]-\\'0\\')+a) % 10) + \\'0\\';\\n        }\\n        f(s1,a,b);\\n        \\n        \\n\\t\\t//reverse part\\n        reverse(s.begin()+s.length()-b, s.end());\\n        reverse(s.begin(), s.begin()+s.length()-b);\\n        reverse(s.begin(), s.end());\\n        f(s,a,b);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        f(s,a,b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317856,
                "title": "intuitive-do-as-hints-say",
                "content": "```\\nclass Solution {\\n    \\n    string rotate(const string& s, int b) {\\n        return s.substr(s.size() - b) + s.substr(0, s.size() - b);\\n    }\\n    \\n    string add(const string& str, int a) {\\n        string s = str;\\n        for (int i = 1, len = s.size(); i < len; i += 2) {\\n            s[i] = (s[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        }\\n        return s;\\n    }\\n    \\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string res = s;\\n        unordered_set<string> cache_{s};\\n        queue<string> q;\\n        q.push(s);\\n        int idx = 0;\\n        int total = 10 * 10 * s.size();\\n        while (idx++ < total) {\\n            while (!q.empty()) {\\n                auto s = q.front();\\n                q.pop();\\n                auto adds = add(s, a);\\n                auto rot = rotate(s, b);\\n                if (cache_.find(adds) == cache_.end()) {\\n                    q.push(adds);\\n                    cache_.insert(adds);\\n                    res = min(res, adds);\\n                }\\n\\n                if (cache_.find(rot) == cache_.end()) {\\n                    q.push(rot);\\n                    cache_.insert(rot);\\n                    res = min(res, rot);\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    string rotate(const string& s, int b) {\\n        return s.substr(s.size() - b) + s.substr(0, s.size() - b);\\n    }\\n    \\n    string add(const string& str, int a) {\\n        string s = str;\\n        for (int i = 1, len = s.size(); i < len; i += 2) {\\n            s[i] = (s[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        }\\n        return s;\\n    }\\n    \\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string res = s;\\n        unordered_set<string> cache_{s};\\n        queue<string> q;\\n        q.push(s);\\n        int idx = 0;\\n        int total = 10 * 10 * s.size();\\n        while (idx++ < total) {\\n            while (!q.empty()) {\\n                auto s = q.front();\\n                q.pop();\\n                auto adds = add(s, a);\\n                auto rot = rotate(s, b);\\n                if (cache_.find(adds) == cache_.end()) {\\n                    q.push(adds);\\n                    cache_.insert(adds);\\n                    res = min(res, adds);\\n                }\\n\\n                if (cache_.find(rot) == cache_.end()) {\\n                    q.push(rot);\\n                    cache_.insert(rot);\\n                    res = min(res, rot);\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276164,
                "title": "python-no-bfs-dfs-straight-to-the-answer",
                "content": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:        \\n        \\n        def get_smallest_possible(d, a):\\n            if a == 5:\\n                return min(d, (d + 5) % 10)\\n\\t\\t\\t# if a is an odd number, then we can always add a for certain times and get 0.\\n\\t\\t\\t# otherwise, we can only loop in \"d + [0, 2, 4, 6, 8]\", and get the minimum.\\n            return 0 if a % 2 else d % 2\\n        \\n        s = list(s)\\n        \\n\\t\\t# four cases here:\\n\\t\\t# 1. b is an odd number ==> we are able to tweak every digit if we want.\\n\\t\\t#     1.1. len(s) is a multiple of b ==> only digits at index that\\'s multiple of b can be the start.\\n\\t\\t#     1.2. len(s) isn\\'t a multiple of b ==> every digit can be the start.\\n\\t\\t#\\n\\t\\t# 2. b is an even number ==> we are only able to tweak digits at odd index.\\n\\t\\t#     2.1. len(s) is a multiple of b ==> only digits at index that\\'s multiple of b can be the start.\\n\\t\\t#     2.2. len(s) isn\\'t a multiple of b ==> every digit at even index can be the start.\\n        change_any_digit = b & 1\\n        turns = len(s) // b if len(s) % b == 0 else (len(s) if change_any_digit else len(s) // 2)\\n        \\n        ans = \"ans\"\\n        for _ in range(turns):\\n            diff_for_odd = get_smallest_possible(int(s[1]), a) - int(s[1])\\n            diff_for_even = change_any_digit and get_smallest_possible(int(s[0]), a) - int(s[0])\\n            \\n            temp = []\\n            for scan in range(len(s)):\\n                diff = diff_for_odd if scan & 1 else diff_for_even\\n                temp.append(str((int(s[scan]) + diff) % 10))\\n                \\n            ans = min(ans, \\'\\'.join(temp)) \\n            s = s[-b:] + s[:-b]\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:        \\n        \\n        def get_smallest_possible(d, a):\\n            if a == 5:\\n                return min(d, (d + 5) % 10)\\n\\t\\t\\t# if a is an odd number, then we can always add a for certain times and get 0.\\n\\t\\t\\t# otherwise, we can only loop in \"d + [0, 2, 4, 6, 8]\", and get the minimum.\\n            return 0 if a % 2 else d % 2\\n        \\n        s = list(s)\\n        \\n\\t\\t# four cases here:\\n\\t\\t# 1. b is an odd number ==> we are able to tweak every digit if we want.\\n\\t\\t#     1.1. len(s) is a multiple of b ==> only digits at index that\\'s multiple of b can be the start.\\n\\t\\t#     1.2. len(s) isn\\'t a multiple of b ==> every digit can be the start.\\n\\t\\t#\\n\\t\\t# 2. b is an even number ==> we are only able to tweak digits at odd index.\\n\\t\\t#     2.1. len(s) is a multiple of b ==> only digits at index that\\'s multiple of b can be the start.\\n\\t\\t#     2.2. len(s) isn\\'t a multiple of b ==> every digit at even index can be the start.\\n        change_any_digit = b & 1\\n        turns = len(s) // b if len(s) % b == 0 else (len(s) if change_any_digit else len(s) // 2)\\n        \\n        ans = \"ans\"\\n        for _ in range(turns):\\n            diff_for_odd = get_smallest_possible(int(s[1]), a) - int(s[1])\\n            diff_for_even = change_any_digit and get_smallest_possible(int(s[0]), a) - int(s[0])\\n            \\n            temp = []\\n            for scan in range(len(s)):\\n                diff = diff_for_odd if scan & 1 else diff_for_even\\n                temp.append(str((int(s[scan]) + diff) % 10))\\n                \\n            ans = min(ans, \\'\\'.join(temp)) \\n            s = s[-b:] + s[:-b]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266030,
                "title": "python-3-brute-force-bfs",
                "content": "\\tclass Solution:\\n\\t\\tdef findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t\\tvis=set()\\n\\t\\t\\tvis.add(s)\\n\\t\\t\\tq=deque([s])\\n\\t\\t\\tres=\"9\"*len(s)\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\ts=q.pop()\\n\\t\\t\\t\\tres=min(res,s)\\n\\t\\t\\t\\tv=list(s)\\n\\t\\t\\t\\tfor i in range(1,len(v),2):\\n\\t\\t\\t\\t\\tv[i]=str((int(v[i])+a)%10)\\n\\t\\t\\t\\tk=\\'\\'.join(v)\\n\\t\\t\\t\\tif k not in vis:\\n\\t\\t\\t\\t\\tvis.add(k)\\n\\t\\t\\t\\t\\tq.appendleft(k)\\n\\t\\t\\t\\tif s[b:]+s[:b] not in vis:\\n\\t\\t\\t\\t\\tvis.add(s[b:]+s[:b])\\n\\t\\t\\t\\t\\tq.appendleft(s[b:]+s[:b])\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t\\tvis=set()\\n\\t\\t\\tvis.add(s)\\n\\t\\t\\tq=deque([s])\\n\\t\\t\\tres=\"9\"*len(s)\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\ts=q.pop()\\n\\t\\t\\t\\tres=min(res,s)\\n\\t\\t\\t\\tv=list(s)\\n\\t\\t\\t\\tfor i in range(1,len(v),2):\\n\\t\\t\\t\\t\\tv[i]=str((int(v[i])+a)%10)\\n\\t\\t\\t\\tk=\\'\\'.join(v)\\n\\t\\t\\t\\tif k not in vis:\\n\\t\\t\\t\\t\\tvis.add(k)\\n\\t\\t\\t\\t\\tq.appendleft(k)\\n\\t\\t\\t\\tif s[b:]+s[:b] not in vis:\\n\\t\\t\\t\\t\\tvis.add(s[b:]+s[:b])\\n\\t\\t\\t\\t\\tq.appendleft(s[b:]+s[:b])\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2217930,
                "title": "c-bfs-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans = \"\" ;\\n    string op1(string s , int a){\\n        for(int i = 1 ;  i < s.size() ; i += 2 ) s[i] = \\'0\\' + ((s[i]-\\'0\\' + a) % 10) ;\\n        return s ; \\n    }\\n    string op2(string s , int b){\\n        rotate(begin(s),begin(s) + b , end(s)) ;\\n        return s ;\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        ans = s ; \\n        unordered_set<string> visited ;\\n        queue<string> q ;\\n        q.push(s) ;\\n        \\n        while(q.size()){\\n            auto str = q.front() ; q.pop() ; \\n            ans = min(ans,str) ;\\n            \\n            if(visited.find(str) != end(visited)) continue ;\\n            visited.insert(str) ;\\n            \\n            string _1 = op1(str,a) , _2 = op2(str,b) ;\\n            q.push(_1) ; q.push(_2) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans = \"\" ;\\n    string op1(string s , int a){\\n        for(int i = 1 ;  i < s.size() ; i += 2 ) s[i] = \\'0\\' + ((s[i]-\\'0\\' + a) % 10) ;\\n        return s ; \\n    }\\n    string op2(string s , int b){\\n        rotate(begin(s),begin(s) + b , end(s)) ;\\n        return s ;\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        ans = s ; \\n        unordered_set<string> visited ;\\n        queue<string> q ;\\n        q.push(s) ;\\n        \\n        while(q.size()){\\n            auto str = q.front() ; q.pop() ; \\n            ans = min(ans,str) ;\\n            \\n            if(visited.find(str) != end(visited)) continue ;\\n            visited.insert(str) ;\\n            \\n            string _1 = op1(str,a) , _2 = op2(str,b) ;\\n            q.push(_1) ; q.push(_2) ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215366,
                "title": "easy-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans=\"zzzzzzz\";\\n    unordered_set<string> vis;\\n    \\n    //add\\n    \\n    string work(string& s,int a)\\n    {\\n        for(int i=1;i<s.length();i+=2)\\n        {\\n            int temp=s[i]-\\'0\\';\\n            int nn=(temp+a)%10;\\n            s[i]=nn+\\'0\\';\\n        }\\n        return s;\\n    }\\n    \\n    //rotate\\n    \\n    string work2(string& s,int a)\\n    {\\n        int n=s.length();\\n        a=a%n;\\n        string temp=s;\\n        for(int i=0;i<n;++i)\\n        {\\n            temp[(i+a)%n]=s[i];\\n        }\\n        return temp;\\n    }\\n    \\n    \\n    void solve(string& s,int a,int b)\\n    {\\n        ans=min(ans,s);\\n        if(vis.find(s)!=vis.end())\\n        {\\n            return;\\n        }\\n        vis.insert(s);\\n        string temp=s; //storing original string\\n        string op1=work(s,a);\\n        solve(op1,a,b,count);\\n        string op2=work2(temp,b);\\n        solve(op2,a,b,count);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        solve(s,a,b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans=\"zzzzzzz\";\\n    unordered_set<string> vis;\\n    \\n    //add\\n    \\n    string work(string& s,int a)\\n    {\\n        for(int i=1;i<s.length();i+=2)\\n        {\\n            int temp=s[i]-\\'0\\';\\n            int nn=(temp+a)%10;\\n            s[i]=nn+\\'0\\';\\n        }\\n        return s;\\n    }\\n    \\n    //rotate\\n    \\n    string work2(string& s,int a)\\n    {\\n        int n=s.length();\\n        a=a%n;\\n        string temp=s;\\n        for(int i=0;i<n;++i)\\n        {\\n            temp[(i+a)%n]=s[i];\\n        }\\n        return temp;\\n    }\\n    \\n    \\n    void solve(string& s,int a,int b)\\n    {\\n        ans=min(ans,s);\\n        if(vis.find(s)!=vis.end())\\n        {\\n            return;\\n        }\\n        vis.insert(s);\\n        string temp=s; //storing original string\\n        string op1=work(s,a);\\n        solve(op1,a,b,count);\\n        string op2=work2(temp,b);\\n        solve(op2,a,b,count);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        solve(s,a,b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175974,
                "title": "easy-bfs-solution",
                "content": "class Solution {\\n    String res=\"\";\\n    \\n    public String findLexSmallestString(String s, int a, int b)\\n    {\\n        res=s;\\n        Stack<String> stack=new Stack<>();\\n        Set<String> set=new HashSet<>();\\n        \\n        set.add(s);\\n        stack.add(s);\\n        \\n        while(!stack.isEmpty())\\n        {\\n            s=stack.pop();\\n            if(s.compareTo(res)<0)\\n            {\\n                res=s;\\n            }\\n            \\n            String ss=operationA(s,a);\\n            if(!set.contains(ss))\\n            {\\n                stack.push(ss);\\n                set.add(ss);\\n            }\\n            \\n            ss=operationB(s,b);\\n            if(!set.contains(ss))\\n            {\\n                stack.push(ss);\\n                set.add(ss);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n    \\n    public String operationA(String s, int a)\\n    {\\n        String sb=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i%2!=0)\\n            {\\n                int ch=s.charAt(i)-\\'0\\';\\n                ch=(ch+a)%10;\\n                sb+=(ch+\"\");\\n            }\\n            else\\n            {\\n                sb+=s.charAt(i);\\n            }\\n        }\\n        return sb;\\n    }\\n    \\n    public String operationB(String s, int b)\\n    {\\n     \\n        return s.substring(s.length()-b,s.length())+s.substring(0,s.length()-b);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    String res=\"\";\\n    \\n    public String findLexSmallestString(String s, int a, int b)\\n    {\\n        res=s;\\n        Stack<String> stack=new Stack<>();\\n        Set<String> set=new HashSet<>();\\n        \\n        set.add(s);\\n        stack.add(s);\\n        \\n        while(!stack.isEmpty())\\n        {\\n            s=stack.pop();\\n            if(s.compareTo(res)<0)\\n            {\\n                res=s;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2076082,
                "title": "c-dfs-mem-limit",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int time = 0;\\n    void bt(string s, string& res, int a, int b, unordered_set<string> & visited){\\n        if(visited.find(s)!=visited.end() || time++>4000) return;\\n        visited.insert(s);\\n        string ori = s;\\n        for(int j = 0;j<s.size();j++){\\n                if(j%2==1){\\n                    auto &ch = s[j];\\n                    if(ch+a>\\'9\\') ch = ch+a-10;\\n                    else ch += a;\\n            }\\n        }\\n        res = min(res, s);\\n        bt(s, res, a, b, visited);\\n        s = ori;\\n        rotate(s.rbegin(), s.rbegin()+b, s.rend());\\n        res = min(res, s);\\n        bt(s, res, a, b, visited);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        string ans = s;\\n        unordered_set<string> visited;\\n        bt(s, ans, a, b, visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int time = 0;\\n    void bt(string s, string& res, int a, int b, unordered_set<string> & visited){\\n        if(visited.find(s)!=visited.end() || time++>4000) return;\\n        visited.insert(s);\\n        string ori = s;\\n        for(int j = 0;j<s.size();j++){\\n                if(j%2==1){\\n                    auto &ch = s[j];\\n                    if(ch+a>\\'9\\') ch = ch+a-10;\\n                    else ch += a;\\n            }\\n        }\\n        res = min(res, s);\\n        bt(s, res, a, b, visited);\\n        s = ori;\\n        rotate(s.rbegin(), s.rbegin()+b, s.rend());\\n        res = min(res, s);\\n        bt(s, res, a, b, visited);\\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        string ans = s;\\n        unordered_set<string> visited;\\n        bt(s, ans, a, b, visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015428,
                "title": "java-recursive",
                "content": "```\\nclass Solution {\\n    private String answer;\\n    private int a, b;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n        this.answer = s;\\n        helper(s, new HashSet<String>());\\n        return answer;\\n    }\\n    \\n    private void helper(String s, Set<String> seen) {\\n        if(seen.contains(s)) {\\n            return;\\n        }\\n        seen.add(s);\\n        if (answer.compareTo(s) > 0) {\\n            answer = s;\\n        }\\n        helper(add(s), seen);\\n        helper(rotate(s), seen);\\n    }\\n    \\n    private String add(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i=1;i<sb.length();i += 2) {\\n            sb.setCharAt(i, (char) (\\'0\\' + (s.charAt(i) - \\'0\\' + a) % 10));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private String rotate(String s) {\\n        int n = s.length();\\n        return s.substring(n - b, n) + s.substring(0, n - b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private String answer;\\n    private int a, b;\\n    public String findLexSmallestString(String s, int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n        this.answer = s;\\n        helper(s, new HashSet<String>());\\n        return answer;\\n    }\\n    \\n    private void helper(String s, Set<String> seen) {\\n        if(seen.contains(s)) {\\n            return;\\n        }\\n        seen.add(s);\\n        if (answer.compareTo(s) > 0) {\\n            answer = s;\\n        }\\n        helper(add(s), seen);\\n        helper(rotate(s), seen);\\n    }\\n    \\n    private String add(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i=1;i<sb.length();i += 2) {\\n            sb.setCharAt(i, (char) (\\'0\\' + (s.charAt(i) - \\'0\\' + a) % 10));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private String rotate(String s) {\\n        int n = s.length();\\n        return s.substring(n - b, n) + s.substring(0, n - b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985264,
                "title": "python3",
                "content": "class Solution:\\n\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        length = len(s)\\n        n = length-b\\n        result = s\\n        visited = set()\\n        queue = deque([s])\\n        \\n        def add(ele):\\n            res=[]\\n            for i,char in enumerate(ele):\\n                if i%2:\\n                    res.append(str((int(char)+a)%10))\\n                else:\\n                    res.append(char)\\n            return \"\".join(res)\\n        \\n        while queue:\\n            curr = queue.popleft()\\n            if curr in visited:\\n                continue\\n            visited.add(curr)\\n            result = min(result,curr)\\n            queue.append(add(curr))\\n            queue.append(curr[n:]+curr[:n])\\n            \\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        length = len(s)\\n        n = length-b\\n        result = s\\n        visited = set()\\n        queue = deque([s])\\n        \\n        def add(ele):\\n            res=[]\\n            for i,char in enumerate(ele):\\n                if i%2:\\n                    res.append(str((int(char)+a)%10))\\n                else:\\n                    res.append(char)\\n            return \"\".join(res)\\n        \\n        while queue:\\n            curr = queue.popleft()\\n            if curr in visited:\\n                continue\\n            visited.add(curr)\\n            result = min(result,curr)\\n            queue.append(add(curr))\\n            queue.append(curr[n:]+curr[:n])\\n            \\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1976341,
                "title": "c-bfs",
                "content": "```\\n//Try to make every possible sequence by performing both add and rotate functions\\n//but insert it into queue only when it is not occurring again\\n\\nclass Solution {\\npublic:\\n    string add(string s, int a)\\n    {\\n        for(int i=1; i<s.size(); i+=2)\\n        {\\n            s[i] = \\'0\\' + (((s[i] - \\'0\\') + a)%10);\\n        }\\n        return s;\\n    }\\n    \\n    string rotate(string s, int b)\\n    {   \\n        int n = s.size();\\n        reverse(s.begin() + n - b, s.end());\\n        reverse(s.begin(), s.begin() + n - b);\\n        reverse(s.begin(), s.end());\\n        \\n        return s;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        set<string> ans;\\n        queue<string> q;\\n        q.push(s);\\n        ans.insert(s);\\n        \\n        while(!q.empty())\\n        {\\n            string temp = q.front();\\n            q.pop();\\n            \\n            string temp1 = add(temp, a);\\n            string temp2 = rotate(temp, b);\\n            \\n            if(ans.find(temp1) == ans.end()){\\n                q.push(temp1);\\n                ans.insert(temp1);\\n            }\\n            \\n            if(ans.find(temp2) == ans.end()){\\n                q.push(temp2);\\n                ans.insert(temp2);\\n            }\\n        }\\n        \\n        return *ans.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n//Try to make every possible sequence by performing both add and rotate functions\\n//but insert it into queue only when it is not occurring again\\n\\nclass Solution {\\npublic:\\n    string add(string s, int a)\\n    {\\n        for(int i=1; i<s.size(); i+=2)\\n        {\\n            s[i] = \\'0\\' + (((s[i] - \\'0\\') + a)%10);\\n        }\\n        return s;\\n    }\\n    \\n    string rotate(string s, int b)\\n    {   \\n        int n = s.size();\\n        reverse(s.begin() + n - b, s.end());\\n        reverse(s.begin(), s.begin() + n - b);\\n        reverse(s.begin(), s.end());\\n        \\n        return s;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        set<string> ans;\\n        queue<string> q;\\n        q.push(s);\\n        ans.insert(s);\\n        \\n        while(!q.empty())\\n        {\\n            string temp = q.front();\\n            q.pop();\\n            \\n            string temp1 = add(temp, a);\\n            string temp2 = rotate(temp, b);\\n            \\n            if(ans.find(temp1) == ans.end()){\\n                q.push(temp1);\\n                ans.insert(temp1);\\n            }\\n            \\n            if(ans.find(temp2) == ans.end()){\\n                q.push(temp2);\\n                ans.insert(temp2);\\n            }\\n        }\\n        \\n        return *ans.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960769,
                "title": "cpp-solution-iterative",
                "content": "just iterate all the possible sequence of string\\n```\\nclass Solution {\\npublic:\\n    \\n    bool less(string &str,int i,int j){\\n        for(int k=0;k<str.length();k++){\\n            if(str[(k+i)%str.length()]!=str[(k+j)%str.length()])\\n                return str[(k+i)%str.length()]<str[(k+j)%str.length()];\\n        }\\n        return false;\\n    }\\n    \\n    string findLexSmallestString(string str, int a, int b){\\n        \\n        string res=str;\\n        bool odd[10]={};\\n        \\n        while(odd[str[0]-\\'0\\']==false){\\n            \\n            odd[str[0]-\\'0\\']=true;\\n            bool even[10]={};\\n            while(even[str[1]-\\'0\\']==false){\\n                even[str[1]-\\'0\\']=true;\\n                int best_r=0;\\n                vector<bool> rotate(str.length());\\n                for(int r=b;!rotate[r];r=(r+b)%str.length()){\\n                    rotate[r]=true;\\n                    if(less(str,r,best_r)){\\n                        best_r=r;\\n                    }\\n                }\\n                res=min(res,str.substr(best_r)+str.substr(0,best_r));\\n                 for (int k = 1; k < str.size(); k += 2)\\n                     str[k] = \\'0\\' + (str[k] - \\'0\\' + a) % 10;\\n            }\\n            if(b%2){\\n                for (int k = 0; k < str.size(); k += 2)\\n                    str[k] = \\'0\\' + (str[k] - \\'0\\' + a) % 10;\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool less(string &str,int i,int j){\\n        for(int k=0;k<str.length();k++){\\n            if(str[(k+i)%str.length()]!=str[(k+j)%str.length()])\\n                return str[(k+i)%str.length()]<str[(k+j)%str.length()];\\n        }\\n        return false;\\n    }\\n    \\n    string findLexSmallestString(string str, int a, int b){\\n        \\n        string res=str;\\n        bool odd[10]={};\\n        \\n        while(odd[str[0]-\\'0\\']==false){\\n            \\n            odd[str[0]-\\'0\\']=true;\\n            bool even[10]={};\\n            while(even[str[1]-\\'0\\']==false){\\n                even[str[1]-\\'0\\']=true;\\n                int best_r=0;\\n                vector<bool> rotate(str.length());\\n                for(int r=b;!rotate[r];r=(r+b)%str.length()){\\n                    rotate[r]=true;\\n                    if(less(str,r,best_r)){\\n                        best_r=r;\\n                    }\\n                }\\n                res=min(res,str.substr(best_r)+str.substr(0,best_r));\\n                 for (int k = 1; k < str.size(); k += 2)\\n                     str[k] = \\'0\\' + (str[k] - \\'0\\' + a) % 10;\\n            }\\n            if(b%2){\\n                for (int k = 0; k < str.size(); k += 2)\\n                    str[k] = \\'0\\' + (str[k] - \\'0\\' + a) % 10;\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941133,
                "title": "c-brute-force-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>st;\\n    int a,b,n;\\n    string ans;\\n    string rot(string s){\\n        reverse(s.begin(),s.end());\\n        reverse(s.begin(),s.begin()+b);\\n        reverse(s.begin()+b,s.end());\\n        return s;\\n    }\\n    string add(string s){\\n        for (int i=1; i<n; i += 2) {\\n            char &c = s[i];\\n            c = \\'0\\' + (c-\\'0\\'+a)%10;\\n        }\\n        return s;\\n    }\\n    void dfs(string s){\\n        if(st.count(s)) return;\\n        st.insert(s);\\n        ans=min(ans,s);\\n        dfs(rot(s));\\n        dfs(add(s));\\n    }\\n    string findLexSmallestString(string s, int a1, int b1) {\\n        a=a1,b=b1,n=s.size();\\n        ans=s;\\n        dfs(s);        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string>st;\\n    int a,b,n;\\n    string ans;\\n    string rot(string s){\\n        reverse(s.begin(),s.end());\\n        reverse(s.begin(),s.begin()+b);\\n        reverse(s.begin()+b,s.end());\\n        return s;\\n    }\\n    string add(string s){\\n        for (int i=1; i<n; i += 2) {\\n            char &c = s[i];\\n            c = \\'0\\' + (c-\\'0\\'+a)%10;\\n        }\\n        return s;\\n    }\\n    void dfs(string s){\\n        if(st.count(s)) return;\\n        st.insert(s);\\n        ans=min(ans,s);\\n        dfs(rot(s));\\n        dfs(add(s));\\n    }\\n    string findLexSmallestString(string s, int a1, int b1) {\\n        a=a1,b=b1,n=s.size();\\n        ans=s;\\n        dfs(s);        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866508,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution\\n\\t{\\n\\t\\tstring res;\\n\\t\\tHashSet<string> set;\\n\\n\\t\\tpublic string FindLexSmallestString(string s, int a, int b)\\n\\t\\t{\\n\\t\\t\\tres = s;\\n\\t\\t\\tset = new HashSet<string>();\\n\\t\\t\\tSolve(s, a, b);\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic void Solve(string s, int a, int b)\\n\\t\\t{\\n\\t\\t\\tif (set.Contains(s))\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif(string.Compare(s, res) < 0)\\n\\t\\t\\t\\tres = s;\\n\\n\\t\\t\\tset.Add(s);\\n\\t\\t\\tstring add = AddNumber(s, a);\\n\\t\\t\\tstring rotate = RotateNumber(s, b);\\n\\n\\t\\t\\tSolve(add, a, b);\\n\\t\\t\\tSolve(rotate, a, b);\\n\\t\\t}\\n\\n\\t\\tpublic string AddNumber(string s, int a)\\n\\t\\t{\\n\\t\\t\\tchar[] chars = s.ToCharArray();\\n\\t\\t\\tfor (int i = 1; i < s.Length; i = i + 2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = (chars[i] - \\'0\\');\\n\\t\\t\\t\\tchars[i] = (char)(((x + a) % 10) + \\'0\\');\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new string(chars);\\n\\t\\t}\\n\\n\\t\\tpublic string RotateNumber(string str, int b)\\n\\t\\t{\\n\\t\\t\\tint i = str.Length - b;\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.Append(str[i++]);\\n\\t\\t\\t\\ti %= str.Length;\\n\\t\\t\\t}while(i != str.Length - b);\\n\\n\\t\\t\\treturn sb.ToString();\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution\\n\\t{\\n\\t\\tstring res;\\n\\t\\tHashSet<string> set;\\n\\n\\t\\tpublic string FindLexSmallestString(string s, int a, int b)\\n\\t\\t{\\n\\t\\t\\tres = s;\\n\\t\\t\\tset = new HashSet<string>();\\n\\t\\t\\tSolve(s, a, b);\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1789778,
                "title": "javascript-solution-brute-force-bfs-approach",
                "content": "```\\nvar findLexSmallestString = function(s, a, b) {\\n    const n = s.length;\\n    const visited = new Set();\\n    const queue = []; \\n   \\n    visited.add(s);\\n    queue.push(s);\\n    \\n    let minNum = s;\\n    \\n    while (queue.length > 0) {\\n        const currNum = queue.shift();\\n\\n        if (currNum < minNum) minNum = currNum;\\n        \\n        const justRotate = rotate(currNum);\\n        const justAdd = add(currNum);\\n\\n        if (!visited.has(justRotate)) {\\n            visited.add(justRotate);\\n            queue.push(justRotate);\\n        }\\n        \\n        if (!visited.has(justAdd)) {\\n            visited.add(justAdd);\\n            queue.push(justAdd);\\n        }\\n    }\\n    \\n    return minNum;\\n    \\n    function rotate(num) {\\n        let rotatedNum = \"\";\\n        const start = n - b;\\n        \\n        for (let i = 0; i < b; i++) {\\n            rotatedNum += num.charAt(start + i);\\n        }\\n        \\n        const restDigs = num.substring(0, n - b);\\n        rotatedNum += restDigs;\\n        \\n        return rotatedNum;\\n    }\\n    \\n    \\n    function add(num) {\\n        let nextNum = \"\";        \\n\\n        for (let i = 0; i < n; i++) {\\n            let currDig = num.charAt(i);\\n            \\n            if (i % 2 == 0) {\\n                nextNum += currDig;\\n            }\\n            else {\\n                let newDig = (parseInt(currDig) + a) % 10;\\n                nextNum += newDig;\\n            }\\n        }\\n        \\n        return nextNum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar findLexSmallestString = function(s, a, b) {\\n    const n = s.length;\\n    const visited = new Set();\\n    const queue = []; \\n   \\n    visited.add(s);\\n    queue.push(s);\\n    \\n    let minNum = s;\\n    \\n    while (queue.length > 0) {\\n        const currNum = queue.shift();\\n\\n        if (currNum < minNum) minNum = currNum;\\n        \\n        const justRotate = rotate(currNum);\\n        const justAdd = add(currNum);\\n\\n        if (!visited.has(justRotate)) {\\n            visited.add(justRotate);\\n            queue.push(justRotate);\\n        }\\n        \\n        if (!visited.has(justAdd)) {\\n            visited.add(justAdd);\\n            queue.push(justAdd);\\n        }\\n    }\\n    \\n    return minNum;\\n    \\n    function rotate(num) {\\n        let rotatedNum = \"\";\\n        const start = n - b;\\n        \\n        for (let i = 0; i < b; i++) {\\n            rotatedNum += num.charAt(start + i);\\n        }\\n        \\n        const restDigs = num.substring(0, n - b);\\n        rotatedNum += restDigs;\\n        \\n        return rotatedNum;\\n    }\\n    \\n    \\n    function add(num) {\\n        let nextNum = \"\";        \\n\\n        for (let i = 0; i < n; i++) {\\n            let currDig = num.charAt(i);\\n            \\n            if (i % 2 == 0) {\\n                nextNum += currDig;\\n            }\\n            else {\\n                let newDig = (parseInt(currDig) + a) % 10;\\n                nextNum += newDig;\\n            }\\n        }\\n        \\n        return nextNum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1718941,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string add(string s,int a)\\n    {\\n        for(int i=1;i<s.size();i+=2)\\n        {\\n            s[i]=(s[i]-\\'0\\'+a)%10+\\'0\\';\\n        }\\n        return s;\\n    }\\n    string rotate(string s,int k)\\n    {\\n        int n=s.size();\\n        k=k%n;\\n        return s.substr(n-k)+s.substr(0,n-k);\\n    }\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        string ans=s;\\n        queue<string>q;\\n        unordered_set<string>vis;\\n        q.push(s);\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            ans=min(ans,temp);\\n            q.pop();\\n            string first=add(temp,a);\\n            string second=rotate(temp,b);\\n            if(vis.find(first)==vis.end())\\n            {\\n                q.push(first);\\n                vis.insert(first);\\n            }\\n            if(vis.find(second)==vis.end())\\n            {\\n                q.push(second);\\n                vis.insert(second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string add(string s,int a)\\n    {\\n        for(int i=1;i<s.size();i+=2)\\n        {\\n            s[i]=(s[i]-\\'0\\'+a)%10+\\'0\\';\\n        }\\n        return s;\\n    }\\n    string rotate(string s,int k)\\n    {\\n        int n=s.size();\\n        k=k%n;\\n        return s.substr(n-k)+s.substr(0,n-k);\\n    }\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        string ans=s;\\n        queue<string>q;\\n        unordered_set<string>vis;\\n        q.push(s);\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            ans=min(ans,temp);\\n            q.pop();\\n            string first=add(temp,a);\\n            string second=rotate(temp,b);\\n            if(vis.find(first)==vis.end())\\n            {\\n                q.push(first);\\n                vis.insert(first);\\n            }\\n            if(vis.find(second)==vis.end())\\n            {\\n                q.push(second);\\n                vis.insert(second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656108,
                "title": "dfs-traversal-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string ans;\\n    \\n    //Add a to all odd indices of s\\n    string add(int a , string s){\\n        string ans;\\n        for(int i=0 ;i<s.size();i++){\\n            if(i%2) ans+=((s[i]-\\'0\\'+a)%10 + \\'0\\');\\n            else\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n    \\n    //Rotate s to the right by b positions.\\n    string rotate(int b , string s){\\n        string ans;\\n        int n=s.size();\\n        //adding substring that starts from n-b index of s till end\\n        ans+=s.substr(n-b);\\n        //adding substring that starts from 0 \\n        ans+=s.substr(0,n-b);\\n        return ans;\\n    }\\n    \\n    //dfs traversal\\n    void dfs(string s , int a , int b , set<string>&visited){\\n        if(visited.find(s) != visited.end())\\n            return;\\n        visited.insert(s);\\n        ans=min(ans,s);\\n        dfs(add(a,s),a,b,visited);\\n        dfs(rotate(b,s),a,b,visited);\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        ans=s;\\n        set<string>visited;\\n        dfs(s,a,b,visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string ans;\\n    \\n    //Add a to all odd indices of s\\n    string add(int a , string s){\\n        string ans;\\n        for(int i=0 ;i<s.size();i++){\\n            if(i%2) ans+=((s[i]-\\'0\\'+a)%10 + \\'0\\');\\n            else\\n                ans+=s[i];\\n        }\\n        return ans;\\n    }\\n    \\n    //Rotate s to the right by b positions.\\n    string rotate(int b , string s){\\n        string ans;\\n        int n=s.size();\\n        //adding substring that starts from n-b index of s till end\\n        ans+=s.substr(n-b);\\n        //adding substring that starts from 0 \\n        ans+=s.substr(0,n-b);\\n        return ans;\\n    }\\n    \\n    //dfs traversal\\n    void dfs(string s , int a , int b , set<string>&visited){\\n        if(visited.find(s) != visited.end())\\n            return;\\n        visited.insert(s);\\n        ans=min(ans,s);\\n        dfs(add(a,s),a,b,visited);\\n        dfs(rotate(b,s),a,b,visited);\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        ans=s;\\n        set<string>visited;\\n        dfs(s,a,b,visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626077,
                "title": "python3-greatest-common-divisor-72-ms-solution",
                "content": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        def gcd(x, y):\\n            if x > y: y, x = x, y\\n            while x > 0: x, y = y % x, x\\n            return y\\n        def find_inc(x, a):\\n            res = int(x)\\n            while res < 10: res += a\\n            inc = res - int(x)\\n            return inc\\n        a, b, res = gcd(10, a), gcd(len(s), b), \"9\"*len(s)\\n        for i in range(0, len(s), b):\\n            curr = s[i:] + s[:i]\\n            if b % 2 == 0: inc = [0, find_inc(curr[1], a)]\\n            else: inc = [find_inc(curr[0], a), find_inc(curr[1], a)]\\n            new_curr = \"\"\\n            curr = \"\".join(str((int(c) + inc[i % 2]) % 10) for i, c in enumerate(curr))\\n            if curr < res: res = curr\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        def gcd(x, y):\\n            if x > y: y, x = x, y\\n            while x > 0: x, y = y % x, x\\n            return y\\n        def find_inc(x, a):\\n            res = int(x)\\n            while res < 10: res += a\\n            inc = res - int(x)\\n            return inc\\n        a, b, res = gcd(10, a), gcd(len(s), b), \"9\"*len(s)\\n        for i in range(0, len(s), b):\\n            curr = s[i:] + s[:i]\\n            if b % 2 == 0: inc = [0, find_inc(curr[1], a)]\\n            else: inc = [find_inc(curr[0], a), find_inc(curr[1], a)]\\n            new_curr = \"\"\\n            curr = \"\".join(str((int(c) + inc[i % 2]) % 10) for i, c in enumerate(curr))\\n            if curr < res: res = curr\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588103,
                "title": "go-golang-brute",
                "content": "```\\nfunc findLexSmallestString(s string, a int, b int) string {\\n    l := len(s)\\n    res := \"\"\\n    for i := 0; i < l; i++ {\\n        res += \"9\"\\n    }\\n    \\n    for cnt := 0; cnt < 10; cnt++ {\\n        s1 := add(s, a * cnt, 1)\\n        i := 0\\n        for {\\n            s2 := s1[i:] + s1[:i]\\n            res = min(res, s2)\\n            i = (i + b) % l\\n            if i == 0 {\\n                break\\n            }\\n        }\\n        \\n        if b % 2 != 0 {\\n            for cnt2 := 0; cnt2 < 10; cnt2++ {\\n                s2 := add(s1, a * cnt2, 0)\\n                i = 0\\n                for {\\n                    s3 := s2[i:] + s2[:i]\\n                    res = min(res, s3)\\n                    i = (i + b) % l\\n                    if i == 0 {\\n                        break\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\nfunc min(a string, b string) string {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc add(s string, a int, start int) string {\\n    list := []byte(s)\\n    for i := start; i < len(s); i += 2 {\\n        list[i] = byte(\\'0\\' + (int(list[i] - \\'0\\') + a) % 10)\\n    }\\n    return string(list)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findLexSmallestString(s string, a int, b int) string {\\n    l := len(s)\\n    res := \"\"\\n    for i := 0; i < l; i++ {\\n        res += \"9\"\\n    }\\n    \\n    for cnt := 0; cnt < 10; cnt++ {\\n        s1 := add(s, a * cnt, 1)\\n        i := 0\\n        for {\\n            s2 := s1[i:] + s1[:i]\\n            res = min(res, s2)\\n            i = (i + b) % l\\n            if i == 0 {\\n                break\\n            }\\n        }\\n        \\n        if b % 2 != 0 {\\n            for cnt2 := 0; cnt2 < 10; cnt2++ {\\n                s2 := add(s1, a * cnt2, 0)\\n                i = 0\\n                for {\\n                    s3 := s2[i:] + s2[:i]\\n                    res = min(res, s3)\\n                    i = (i + b) % l\\n                    if i == 0 {\\n                        break\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return res\\n}\\n\\nfunc min(a string, b string) string {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc add(s string, a int, start int) string {\\n    list := []byte(s)\\n    for i := start; i < len(s); i += 2 {\\n        list[i] = byte(\\'0\\' + (int(list[i] - \\'0\\') + a) % 10)\\n    }\\n    return string(list)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505180,
                "title": "javascript-100-faster-100-space-efficient",
                "content": "**Time O(100 * n * n), Space O(n)**\\n```\\nvar findLexSmallestString = function(s, a, b) {\\n    let min = \"9\".repeat(100), num = s.split(\"\").map((each) => Number(each));\\n\\n    const gcd = (x, y) => {\\n        if (x === 0)\\n            return y;\\n        return gcd(y % x, x)\\n    };\\n\\n    const increment = gcd(s.length, b);\\n\\n    const compute =(maxTimes) => {\\n        let ans = [];\\n        for (let i = 0; i <= maxTimes; i++) {\\n            for (let j = 0; j <= 9; j++) {\\n                for (let k = 0; k < num.length; k++) {\\n                    ans[k] = (num[k] + (k % 2 ? j * a : i * a)) % 10;\\n                }\\n                for (let k = 0; k < num.length; k += increment) {\\n                    ans = ans.slice(increment).concat(ans.slice(0, increment));\\n                    const temp = ans.join(\"\");\\n                    if (min > temp)\\n                        min = temp;\\n                }\\n            }\\n        }\\n    }\\n\\n    compute(b % 2 ? 9 : 0);\\n\\n    return min.toString();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findLexSmallestString = function(s, a, b) {\\n    let min = \"9\".repeat(100), num = s.split(\"\").map((each) => Number(each));\\n\\n    const gcd = (x, y) => {\\n        if (x === 0)\\n            return y;\\n        return gcd(y % x, x)\\n    };\\n\\n    const increment = gcd(s.length, b);\\n\\n    const compute =(maxTimes) => {\\n        let ans = [];\\n        for (let i = 0; i <= maxTimes; i++) {\\n            for (let j = 0; j <= 9; j++) {\\n                for (let k = 0; k < num.length; k++) {\\n                    ans[k] = (num[k] + (k % 2 ? j * a : i * a)) % 10;\\n                }\\n                for (let k = 0; k < num.length; k += increment) {\\n                    ans = ans.slice(increment).concat(ans.slice(0, increment));\\n                    const temp = ans.join(\"\");\\n                    if (min > temp)\\n                        min = temp;\\n                }\\n            }\\n        }\\n    }\\n\\n    compute(b % 2 ? 9 : 0);\\n\\n    return min.toString();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504575,
                "title": "python-bfs",
                "content": "```\\ndef rotate(x, b):\\n    return \"\".join(x[b:] + x[:b])\\n    \\nclass Solution:\\n    def findLexSmallestString(self, string: str, a: int, b: int) -> str:\\n        visited = set()\\n        \\n        q = [string]\\n        ans = string\\n        \\n        while q:\\n            rot = None\\n            add = None\\n            \\n            s = q.pop(0)\\n            ans = min(ans, s)\\n            s = list(s)\\n            \\n            # rotate\\n            temp = rotate(s, b)\\n            rot = \"\".join(temp)\\n            \\n            # add \\n            temp = s.copy()\\n            for i in range(len(s)):\\n                if i % 2:\\n                    temp[i] = str((int(s[i]) + a) % 10)\\n            add = \"\".join(temp)\\n            \\n            if rot not in visited:\\n                visited.add(rot)\\n                q.append(rot)\\n            if add not in visited:\\n                visited.add(add)\\n                q.append(add)\\n            \\n        return ans      \\n                            \\n                        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef rotate(x, b):\\n    return \"\".join(x[b:] + x[:b])\\n    \\nclass Solution:\\n    def findLexSmallestString(self, string: str, a: int, b: int) -> str:\\n        visited = set()\\n        \\n        q = [string]\\n        ans = string\\n        \\n        while q:\\n            rot = None\\n            add = None\\n            \\n            s = q.pop(0)\\n            ans = min(ans, s)\\n            s = list(s)\\n            \\n            # rotate\\n            temp = rotate(s, b)\\n            rot = \"\".join(temp)\\n            \\n            # add \\n            temp = s.copy()\\n            for i in range(len(s)):\\n                if i % 2:\\n                    temp[i] = str((int(s[i]) + a) % 10)\\n            add = \"\".join(temp)\\n            \\n            if rot not in visited:\\n                visited.add(rot)\\n                q.append(rot)\\n            if add not in visited:\\n                visited.add(add)\\n                q.append(add)\\n            \\n        return ans      \\n                            \\n                        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498613,
                "title": "slow-dp-dfs-approach",
                "content": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\n    int a,b,n;\\n    unordered_map<string,string> dp;\\npublic:\\n    string solver(string st){\\n        if(dp.find(st)!=dp.end())\\n            return dp[st];\\n\\t\\t// if this string itself is lexicographically smallest\\n        dp[st]=st;\\n\\t\\t\\n\\t\\t// increment every odd indexed digit value\\n        string t=st;\\n        for(int i=1;i<n;i+=2){\\n            int d=t[i]-\\'0\\';\\n            d=(d+a)%10;\\n            t[i]=\\'0\\'+d;\\n        }\\n        dp[st]=min(dp[st],solver(t));\\n\\t\\t\\n\\t\\t// shifting the original string\\n        t=st.substr(n-b)+st.substr(0,n-b);\\n        return dp[st]=min(dp[st],solver(t));\\n    }\\n    \\n    string findLexSmallestString(string s, int A, int B) {\\n        IOS;\\n        a=A,b=B;\\n        n=s.length();\\n        return solver(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\n    int a,b,n;\\n    unordered_map<string,string> dp;\\npublic:\\n    string solver(string st){\\n        if(dp.find(st)!=dp.end())\\n            return dp[st];\\n\\t\\t// if this string itself is lexicographically smallest\\n        dp[st]=st;\\n\\t\\t\\n\\t\\t// increment every odd indexed digit value\\n        string t=st;\\n        for(int i=1;i<n;i+=2){\\n            int d=t[i]-\\'0\\';\\n            d=(d+a)%10;\\n            t[i]=\\'0\\'+d;\\n        }\\n        dp[st]=min(dp[st],solver(t));\\n\\t\\t\\n\\t\\t// shifting the original string\\n        t=st.substr(n-b)+st.substr(0,n-b);\\n        return dp[st]=min(dp[st],solver(t));\\n    }\\n    \\n    string findLexSmallestString(string s, int A, int B) {\\n        IOS;\\n        a=A,b=B;\\n        n=s.length();\\n        return solver(s);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1473993,
                "title": "python-3-bfs-explanation",
                "content": "### Explanation\\n- Try all possible variations and find the smallest one\\n### Implementation\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        dq, visited = collections.deque([s]), set([s])\\n        ans, n = s, len(s)\\n        while dq:\\n            cur = dq.popleft()\\n            ans = min(ans, cur)\\n            cur_a = \\'\\'.join([\\n                str((int(cur[i]) + a) % 10) if i % 2 else cur[i] \\n                for i in range(n)\\n            ])\\n            cur_b = cur[b:] + cur[:b]\\n            if cur_a not in visited: \\n                dq.append(cur_a)\\n                visited.add(cur_a)\\n            if cur_b not in visited: \\n                dq.append(cur_b)\\n                visited.add(cur_b)\\n        return ans            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        dq, visited = collections.deque([s]), set([s])\\n        ans, n = s, len(s)\\n        while dq:\\n            cur = dq.popleft()\\n            ans = min(ans, cur)\\n            cur_a = \\'\\'.join([\\n                str((int(cur[i]) + a) % 10) if i % 2 else cur[i] \\n                for i in range(n)\\n            ])\\n            cur_b = cur[b:] + cur[:b]\\n            if cur_a not in visited: \\n                dq.append(cur_a)\\n                visited.add(cur_a)\\n            if cur_b not in visited: \\n                dq.append(cur_b)\\n                visited.add(cur_b)\\n        return ans            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415005,
                "title": "js-clean-code",
                "content": "```\\nvar findLexSmallestString = function(s, a, b) {\\n    const set=new Set();\\n    let result=s;\\n    dfs(s,a,b)\\n    return result;\\n    \\n    function add(s){\\n        let res=\\'\\'\\n        for(let i=0;i<s.length;i++){\\n            if(i%2){\\n                res+=((+s[i]+a)%10).toString()\\n            }else{\\n                res+=s[i]\\n            }\\n        }\\n        return res\\n    }\\n    \\n    function rotate(s){\\n        let res=\"\"\\n        res += s.substring(s.length-b) + s.substring(0,s.length-b);\\n        return res;\\n    }\\n    \\n    function dfs(str,a,b){\\n        if(set.has(str)) return;\\n        set.add(str);\\n        if(result>str){\\n            result=str\\n        }\\n        dfs(add(str),a,b)\\n        dfs(rotate(str),a,b)\\n    }\\n};\\n```\\nRuntime: 344 ms, faster than 45.71% of JavaScript online submissions for Lexicographically Smallest String After Applying Operations.\\nMemory Usage: 55.2 MB, less than 62.86% of JavaScript online submissions for Lexicographically Smallest String After Applying Operations.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findLexSmallestString = function(s, a, b) {\\n    const set=new Set();\\n    let result=s;\\n    dfs(s,a,b)\\n    return result;\\n    \\n    function add(s){\\n        let res=\\'\\'\\n        for(let i=0;i<s.length;i++){\\n            if(i%2){\\n                res+=((+s[i]+a)%10).toString()\\n            }else{\\n                res+=s[i]\\n            }\\n        }\\n        return res\\n    }\\n    \\n    function rotate(s){\\n        let res=\"\"\\n        res += s.substring(s.length-b) + s.substring(0,s.length-b);\\n        return res;\\n    }\\n    \\n    function dfs(str,a,b){\\n        if(set.has(str)) return;\\n        set.add(str);\\n        if(result>str){\\n            result=str\\n        }\\n        dfs(add(str),a,b)\\n        dfs(rotate(str),a,b)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392597,
                "title": "golang-self-implement-queue-and-bfs",
                "content": "\\ttype Queue struct {\\n\\t\\tarr []string\\n\\t}\\n\\n\\tfunc (q *Queue)Pop() (string, error){\\n\\t\\tif q.IsEmpty() {\\n\\t\\t\\treturn \"\", fmt.Errorf(\"The queue is empty!\")\\n\\t\\t}\\n\\t\\tvalue := q.arr[q.getSize() - 1]\\n\\t\\tq.arr = q.arr[:q.getSize()-1]\\n\\t\\treturn value, nil\\n\\t}\\n\\n\\tfunc (q *Queue)IsEmpty() bool {\\n\\t\\treturn len(q.arr) == 0\\n\\t}\\n\\n\\tfunc (q *Queue) getSize() int {\\n\\t\\treturn len(q.arr)\\n\\t}\\n\\n\\tfunc (q *Queue) Offer(val string) {\\n\\t\\tq.arr = append(q.arr, val)\\n\\t\\treturn\\n\\t}\\n\\n\\n\\tfunc findLexSmallestString(s string, a int, b int) string {\\n\\t\\t// calculate the smallest number per digit can get after adding a to it\\n\\n\\t\\tq := Queue{arr: make([]string, 0)}\\n\\n\\t\\tans := s\\n\\n\\t\\tma := make(map[string]bool)\\n\\n\\t\\tq.Offer(s)\\n\\t\\tma[s] = true\\n\\n\\t\\tfor !q.IsEmpty() {\\n\\t\\t\\tlast, ok := q.Pop()\\n\\t\\t\\tif ok == nil {\\n\\n\\t\\t\\t\\tresult := strings.Compare(ans, last)\\n\\n\\t\\t\\t\\tif result > 0 {\\n\\t\\t\\t\\t\\tans = last\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\taStr := transfromDigit(last, a)\\n\\t\\t\\t\\tbStr := rotate(last, b)\\n\\n\\t\\t\\t\\tif _, found := ma[aStr]; !found {\\n\\t\\t\\t\\t\\tq.Offer(aStr)\\n\\t\\t\\t\\t\\tma[aStr] = true\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif _, found := ma[bStr]; !found {\\n\\t\\t\\t\\t\\tq.Offer(bStr)\\n\\t\\t\\t\\t\\tma[bStr] = true\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpanic(\"do something\")\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans\\n\\t}\\n\\n\\tfunc transfromDigit(last string, a int) string {\\n\\t\\tres := \"\"\\n\\t\\tfor i := range last {\\n\\t\\t\\tif i % 2 == 1 {\\n\\t\\t\\t\\tcurDigit, _ := strconv.Atoi(string(last[i]))\\n\\t\\t\\t\\tcurDigit = (curDigit + a) % 10\\n\\t\\t\\t\\tres += strconv.Itoa(curDigit)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres += string(last[i])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tfunc rotate(last string, b int) string {\\n\\t\\tl := len(last)\\n\\t\\treturn last[l - b:] + last[:l-b]\\n\\t}",
                "solutionTags": [],
                "code": "\\ttype Queue struct {\\n\\t\\tarr []string\\n\\t}\\n\\n\\tfunc (q *Queue)Pop() (string, error){\\n\\t\\tif q.IsEmpty() {\\n\\t\\t\\treturn \"\", fmt.Errorf(\"The queue is empty!\")\\n\\t\\t}\\n\\t\\tvalue := q.arr[q.getSize() - 1]\\n\\t\\tq.arr = q.arr[:q.getSize()-1]\\n\\t\\treturn value, nil\\n\\t}\\n\\n\\tfunc (q *Queue)IsEmpty() bool {\\n\\t\\treturn len(q.arr) == 0\\n\\t}\\n\\n\\tfunc (q *Queue) getSize() int {\\n\\t\\treturn len(q.arr)\\n\\t}\\n\\n\\tfunc (q *Queue) Offer(val string) {\\n\\t\\tq.arr = append(q.arr, val)\\n\\t\\treturn\\n\\t}\\n\\n\\n\\tfunc findLexSmallestString(s string, a int, b int) string {\\n\\t\\t// calculate the smallest number per digit can get after adding a to it\\n\\n\\t\\tq := Queue{arr: make([]string, 0)}\\n\\n\\t\\tans := s\\n\\n\\t\\tma := make(map[string]bool)\\n\\n\\t\\tq.Offer(s)\\n\\t\\tma[s] = true\\n\\n\\t\\tfor !q.IsEmpty() {\\n\\t\\t\\tlast, ok := q.Pop()\\n\\t\\t\\tif ok == nil {\\n\\n\\t\\t\\t\\tresult := strings.Compare(ans, last)\\n\\n\\t\\t\\t\\tif result > 0 {\\n\\t\\t\\t\\t\\tans = last\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\taStr := transfromDigit(last, a)\\n\\t\\t\\t\\tbStr := rotate(last, b)\\n\\n\\t\\t\\t\\tif _, found := ma[aStr]; !found {\\n\\t\\t\\t\\t\\tq.Offer(aStr)\\n\\t\\t\\t\\t\\tma[aStr] = true\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif _, found := ma[bStr]; !found {\\n\\t\\t\\t\\t\\tq.Offer(bStr)\\n\\t\\t\\t\\t\\tma[bStr] = true\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpanic(\"do something\")\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans\\n\\t}\\n\\n\\tfunc transfromDigit(last string, a int) string {\\n\\t\\tres := \"\"\\n\\t\\tfor i := range last {\\n\\t\\t\\tif i % 2 == 1 {\\n\\t\\t\\t\\tcurDigit, _ := strconv.Atoi(string(last[i]))\\n\\t\\t\\t\\tcurDigit = (curDigit + a) % 10\\n\\t\\t\\t\\tres += strconv.Itoa(curDigit)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres += string(last[i])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tfunc rotate(last string, b int) string {\\n\\t\\tl := len(last)\\n\\t\\treturn last[l - b:] + last[:l-b]\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1388049,
                "title": "pyhon-3-without-dfs-bfs",
                "content": "Note that no matter what combination of operations, it eventually boils down to:\\n* How many times `a` is added to the odd posistions? Note that `s` returns to itself after `a` is added `gcd(a,10)` times.\\n* How many times `a` is added to the even positions? Note that `a` can be added to even positions if and only if the even positions can become odd positions after rotations, which is only possible if either `b` or `len(s)` is odd.\\n* How many times `s` is rotated? Note that `s` returns to itself after `gcd(b, len(s))` rotations.\\n\\nLet `n=len(s)`. The time complexity is `O(gcd(a,10)*gcd(a,10)*gcd(b, n)*n) = O(gcd(b,n)*n)`.\\n\\n```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        n = len(s)\\n        num_a = 10 // math.gcd(a, 10)\\n        num_b = n // math.gcd(n, b)\\n\\n        if (b%2==1) or (n%2==1):\\n            num_aa = num_a\\n        else:\\n            num_aa = 1\\n        \\n        def to_string(ds):\\n            return \\'\\'.join([str(d) for d in ds])\\n\\n        def find_min(digits: List[int]) -> List[int]:\\n            digits_b = list(digits)\\n            min_digits = digits_b\\n            for j in range(num_b):\\n                if digits_b < min_digits:\\n                    min_digits = digits_b\\n                digits_b = digits_b[b:] + digits_b[:b]\\n            return min_digits\\n                \\n        digits = [int(c) for c in s]\\n        min_digits = list(digits)\\n        digits_a = digits\\n        for i in range(num_a):\\n            digits_aa = list(digits_a)\\n            for j in range(num_aa):\\n                min_digits_aab = find_min(digits_aa)\\n                if min_digits_aab < min_digits:\\n                    min_digits = min_digits_aab\\n                digits_aa[::2] = [(d+a)%10 for d in digits_aa[::2]]            \\n            digits_a[1::2] = [(d+a)%10 for d in digits_a[1::2]]            \\n            \\n        return to_string(min_digits)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        n = len(s)\\n        num_a = 10 // math.gcd(a, 10)\\n        num_b = n // math.gcd(n, b)\\n\\n        if (b%2==1) or (n%2==1):\\n            num_aa = num_a\\n        else:\\n            num_aa = 1\\n        \\n        def to_string(ds):\\n            return \\'\\'.join([str(d) for d in ds])\\n\\n        def find_min(digits: List[int]) -> List[int]:\\n            digits_b = list(digits)\\n            min_digits = digits_b\\n            for j in range(num_b):\\n                if digits_b < min_digits:\\n                    min_digits = digits_b\\n                digits_b = digits_b[b:] + digits_b[:b]\\n            return min_digits\\n                \\n        digits = [int(c) for c in s]\\n        min_digits = list(digits)\\n        digits_a = digits\\n        for i in range(num_a):\\n            digits_aa = list(digits_a)\\n            for j in range(num_aa):\\n                min_digits_aab = find_min(digits_aa)\\n                if min_digits_aab < min_digits:\\n                    min_digits = min_digits_aab\\n                digits_aa[::2] = [(d+a)%10 for d in digits_aa[::2]]            \\n            digits_a[1::2] = [(d+a)%10 for d in digits_a[1::2]]            \\n            \\n        return to_string(min_digits)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382187,
                "title": "easy-c-code-using-bfs",
                "content": "\\n\\n```\\nclass Solution {\\n    string add1(string str1,int a)\\n{\\n    int len = str1.length();\\n    for(int i=0;i<len;i++)\\n    {\\n        if(i%2 == 1){\\n        int x = (str1[i]-\\'0\\');\\n        x = x+a;\\n        x = x%10;\\n        str1[i] = x+\\'0\\';\\n        }\\n    }\\n    return str1;\\n}\\nstring rotate(string str1,int b)\\n{\\n    int n = str1.length();\\nstring x=str1.substr(n-b,b);\\n            for(int i=0;i<n-b;i++)\\n                x+=str1[i];\\n    return x;\\n}\\n\\n\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string>q;\\n        q.push(s);\\n        unordered_set<string>st;\\n        st.insert(s);\\n        string ans = s; \\n        while(!q.empty())\\n        {\\n            string str = q.front();\\n            q.pop();\\n            ans = min(ans,str);\\n            string str1 = add1(str,a);\\n            string str2 = rotate(str,b);\\n            if( st.find(str1) == st.end())\\n            {\\n                q.push(str1);\\n                st.insert(str1);\\n            }\\n            if(st.find(str2) == st.end())\\n            {\\n                q.push(str2);\\n                st.insert(str2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    string add1(string str1,int a)\\n{\\n    int len = str1.length();\\n    for(int i=0;i<len;i++)\\n    {\\n        if(i%2 == 1){\\n        int x = (str1[i]-\\'0\\');\\n        x = x+a;\\n        x = x%10;\\n        str1[i] = x+\\'0\\';\\n        }\\n    }\\n    return str1;\\n}\\nstring rotate(string str1,int b)\\n{\\n    int n = str1.length();\\nstring x=str1.substr(n-b,b);\\n            for(int i=0;i<n-b;i++)\\n                x+=str1[i];\\n    return x;\\n}\\n\\n\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string>q;\\n        q.push(s);\\n        unordered_set<string>st;\\n        st.insert(s);\\n        string ans = s; \\n        while(!q.empty())\\n        {\\n            string str = q.front();\\n            q.pop();\\n            ans = min(ans,str);\\n            string str1 = add1(str,a);\\n            string str2 = rotate(str,b);\\n            if( st.find(str1) == st.end())\\n            {\\n                q.push(str1);\\n                st.insert(str1);\\n            }\\n            if(st.find(str2) == st.end())\\n            {\\n                q.push(str2);\\n                st.insert(str2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379059,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        int n=s.size();\\n        string res=s;\\n        queue<string>q;\\n        q.push(s);\\n        unordered_set<string>vis;\\n        vis.insert(s);\\n        while(!q.empty())\\n        {\\n            s=q.front();q.pop();\\n            if(s<res)\\n                res=s;\\n            //operation 1;\\n            string x=s;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2)\\n                {\\n                    int c=((s[i]-\\'0\\')+a)%10;\\n                    x[i]=(c+\\'0\\');\\n                }\\n            }\\n            if(vis.find(x)==vis.end())\\n            {\\n                vis.insert(x);\\n                q.push(x);\\n            }\\n            //operation 2;\\n            x=s.substr(n-b,b);\\n            for(int i=0;i<n-b;i++)\\n                x+=s[i];\\n            if(vis.find(x)==vis.end())\\n            {\\n                vis.insert(x);\\n                q.push(x);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        int n=s.size();\\n        string res=s;\\n        queue<string>q;\\n        q.push(s);\\n        unordered_set<string>vis;\\n        vis.insert(s);\\n        while(!q.empty())\\n        {\\n            s=q.front();q.pop();\\n            if(s<res)\\n                res=s;\\n            //operation 1;\\n            string x=s;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2)\\n                {\\n                    int c=((s[i]-\\'0\\')+a)%10;\\n                    x[i]=(c+\\'0\\');\\n                }\\n            }\\n            if(vis.find(x)==vis.end())\\n            {\\n                vis.insert(x);\\n                q.push(x);\\n            }\\n            //operation 2;\\n            x=s.substr(n-b,b);\\n            for(int i=0;i<n-b;i++)\\n                x+=s[i];\\n            if(vis.find(x)==vis.end())\\n            {\\n                vis.insert(x);\\n                q.push(x);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369962,
                "title": "basic-bfs",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    void leftrotate(string &s, int d)\\n{\\n    reverse(s.begin(), s.begin()+d);\\n    reverse(s.begin()+d, s.end());\\n    reverse(s.begin(), s.end());\\n}\\n \\n// In-place rotates s towards right by d\\nstring  rightrotate(string &s, int d)\\n{\\n   leftrotate(s, s.length()-d);\\n    return s;\\n}\\n    string findLexSmallestString(string s, int a, int b) {\\n          map<string,int>visited;\\n        \\n        queue<string>q;\\n        q.push(s);\\n        string ans=s;\\n        visited[s]=1;\\n      \\n        while(!q.empty())\\n        {\\n            string temp=q.front();\\n            q.pop();\\n            string bal=temp;\\n           \\n            ans=min(ans,temp);\\n            \\n           \\n            \\n            \\n            for(int i=0;i<temp.size();i++)\\n            {\\n                if(i%2==1)\\n                {\\n                    int an=temp[i]-\\'0\\';\\n                    int sum=an+a;\\n                    temp[i]= (sum%10 )+\\'0\\';\\n                }\\n            }\\n           \\n           \\n            string ch= rightrotate(bal,b);\\n           \\n            if(visited[temp]==0)\\n            {\\n                q.push(temp);\\n                visited[temp]=1;\\n                \\n            }\\n            if(visited[ch]==0 )\\n            {\\n                visited[ch]=1;\\n                q.push(ch);\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void leftrotate(string &s, int d)\\n{\\n    reverse(s.begin(), s.begin()+d);\\n    reverse(s.begin()+d, s.end());\\n    reverse(s.begin(), s.end());\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1343775,
                "title": "javascript-faster-than-100",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} a\\n * @param {number} b\\n * @return {string}\\n */\\nvar findLexSmallestString = function(s, a, b) {\\n    const len = s.length\\n    const halfLen = len >> 1\\n    const isOdd = Boolean(b & 1)\\n    \\n    function gcd(m, n) {\\n        if (m < n)  return gcd(n, m)\\n        if (n === 0)    return m\\n        \\n        const r = m % n\\n        return gcd(n, r)\\n    }\\n    const delta = gcd(len, b)\\n    \\n    let digits = [...s].map(Number)\\n    let digitsEven = [], digitsOdd = []\\n    for (const [i, digit] of digits.entries()) {\\n        if (i & 1)  digitsOdd.push(digit)\\n        else digitsEven.push(digit)\\n    }\\n    \\n    \\n    const setEven = new Set(), setOdd = new Set()\\n    function applyA(digits) {\\n        return digits.map(digit => (digit + a) % 10)\\n    }\\n    \\n    setEven.add(digitsEven)\\n    setOdd.add(digitsOdd)\\n    for (let i = 0; i < 10; i++) {\\n        digitsOdd = applyA(digitsOdd)\\n        setOdd.add(digitsOdd)\\n    }\\n\\n    if (isOdd) {\\n        for (let i = 0; i < 10; i++) {\\n            digitsEven = applyA(digitsEven)\\n            setEven.add(digitsEven)\\n        }\\n    }\\n    \\n\\n    const set = new Set()\\n    for (const digitsEven of setEven.values()) {\\n        for (const digitsOdd of setOdd.values()) {\\n            let outcome = []\\n            for (let i = 0; i < halfLen; i++) {\\n                outcome.push(digitsEven[i], digitsOdd[i])\\n            }\\n            \\n            set.add(outcome)\\n        }\\n    }\\n    \\n    \\n    function getBestSubstring(str) {\\n        let result = str.slice(0, len)\\n        const startIndex = delta\\n        for (let i = startIndex; i < len; i += delta) {\\n            let outcome = str.slice(i, i + len)\\n            if (outcome < result)\\n                result = outcome\\n        }\\n        \\n        return result\\n    }\\n    const list = [...set].map(digits => digits.join(\\'\\').repeat(2))\\n    let result = getBestSubstring(list[0])\\n    \\n    \\n    for (let i = 1; i < list.length; i++) {\\n        const str = getBestSubstring(list[i])\\n        if (str < result)\\n            result = str\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} a\\n * @param {number} b\\n * @return {string}\\n */\\nvar findLexSmallestString = function(s, a, b) {\\n    const len = s.length\\n    const halfLen = len >> 1\\n    const isOdd = Boolean(b & 1)\\n    \\n    function gcd(m, n) {\\n        if (m < n)  return gcd(n, m)\\n        if (n === 0)    return m\\n        \\n        const r = m % n\\n        return gcd(n, r)\\n    }\\n    const delta = gcd(len, b)\\n    \\n    let digits = [...s].map(Number)\\n    let digitsEven = [], digitsOdd = []\\n    for (const [i, digit] of digits.entries()) {\\n        if (i & 1)  digitsOdd.push(digit)\\n        else digitsEven.push(digit)\\n    }\\n    \\n    \\n    const setEven = new Set(), setOdd = new Set()\\n    function applyA(digits) {\\n        return digits.map(digit => (digit + a) % 10)\\n    }\\n    \\n    setEven.add(digitsEven)\\n    setOdd.add(digitsOdd)\\n    for (let i = 0; i < 10; i++) {\\n        digitsOdd = applyA(digitsOdd)\\n        setOdd.add(digitsOdd)\\n    }\\n\\n    if (isOdd) {\\n        for (let i = 0; i < 10; i++) {\\n            digitsEven = applyA(digitsEven)\\n            setEven.add(digitsEven)\\n        }\\n    }\\n    \\n\\n    const set = new Set()\\n    for (const digitsEven of setEven.values()) {\\n        for (const digitsOdd of setOdd.values()) {\\n            let outcome = []\\n            for (let i = 0; i < halfLen; i++) {\\n                outcome.push(digitsEven[i], digitsOdd[i])\\n            }\\n            \\n            set.add(outcome)\\n        }\\n    }\\n    \\n    \\n    function getBestSubstring(str) {\\n        let result = str.slice(0, len)\\n        const startIndex = delta\\n        for (let i = startIndex; i < len; i += delta) {\\n            let outcome = str.slice(i, i + len)\\n            if (outcome < result)\\n                result = outcome\\n        }\\n        \\n        return result\\n    }\\n    const list = [...set].map(digits => digits.join(\\'\\').repeat(2))\\n    let result = getBestSubstring(list[0])\\n    \\n    \\n    for (let i = 1; i < list.length; i++) {\\n        const str = getBestSubstring(list[i])\\n        if (str < result)\\n            result = str\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1288650,
                "title": "golang-dfs-solution",
                "content": "```\\nvar ans string\\nfunc findLexSmallestString(s string, a int, b int) string {\\n    seen := make(map[string]bool)\\n    ans = s\\n    dfs(s, a, b, seen)\\n    return ans\\n}\\nfunc dfs(s string, a, b int, seen map[string]bool) {\\n    if seen[s] { return }\\n    ans = min(ans, s)\\n    seen[s]=true\\n    dfs(add(s, a), a,b, seen)\\n    dfs(rot(s, b), a,b, seen)\\n}\\n\\nfunc min(a,b string) string {\\n    if a<b {\\n        return a\\n    }\\n    return b\\n}\\nfunc add(s string, a int) string {\\n    b := []byte(s)\\n    for i:=1;i<len(s);i+=2 {\\n\\t\\tval:=(int(b[i]-\\'0\\')+a)%10+\\'0\\'\\n\\t\\tb[i] = byte(val)\\n\\t}\\n    return string(b)\\n}\\nfunc rot(s string, b int) string {\\n    st := []byte(s)\\n    for i:=0;i<b;i++ {\\n        st = append(st[len(st)-1:len(st)],st[:len(st)-1]...)\\n    }\\n    return string(st)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar ans string\\nfunc findLexSmallestString(s string, a int, b int) string {\\n    seen := make(map[string]bool)\\n    ans = s\\n    dfs(s, a, b, seen)\\n    return ans\\n}\\nfunc dfs(s string, a, b int, seen map[string]bool) {\\n    if seen[s] { return }\\n    ans = min(ans, s)\\n    seen[s]=true\\n    dfs(add(s, a), a,b, seen)\\n    dfs(rot(s, b), a,b, seen)\\n}\\n\\nfunc min(a,b string) string {\\n    if a<b {\\n        return a\\n    }\\n    return b\\n}\\nfunc add(s string, a int) string {\\n    b := []byte(s)\\n    for i:=1;i<len(s);i+=2 {\\n\\t\\tval:=(int(b[i]-\\'0\\')+a)%10+\\'0\\'\\n\\t\\tb[i] = byte(val)\\n\\t}\\n    return string(b)\\n}\\nfunc rot(s string, b int) string {\\n    st := []byte(s)\\n    for i:=0;i<b;i++ {\\n        st = append(st[len(st)-1:len(st)],st[:len(st)-1]...)\\n    }\\n    return string(st)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270964,
                "title": "just-a-brutal-force-for-such-boring-and-uninteresting-question",
                "content": "```scala\\n def findLexSmallestString(s: String, a: Int, b: Int): String = {\\n    type st = String\\n    type in = Int\\n    var min = s\\n    val len = s.length\\n    import scala.collection.mutable.{HashSet, Queue}\\n    val q               = new Queue[st]\\n    val isv             = new HashSet[st]\\n    def f(x: st, i: in) = x charAt i\\n    def g(x: st, i: in) = x.substring(i) + x.substring(0, i)\\n\\n    q enqueue s\\n    while (!q.isEmpty) {\\n      val cur = q.dequeue\\n      if (min.compareTo(cur) > 0) min = cur\\n      if (!isv.contains(cur)) {\\n        isv add cur\\n        val xx =\\n          (0 until len)\\n            .map(i => {\\n\\n              (i % 2 == 0) match {\\n                case true => { f(cur, i) }\\n                case _ => {\\n                  val x = f(cur, i) - \\'0\\'\\n                  (\\'0\\' + { if (x + a <= 9) x + a else (x + a) % 10 }).toChar\\n\\n                }\\n\\n              }\\n            })\\n            .mkString\\n\\n        if (!isv.contains(xx)) q enqueue xx.toString\\n\\n        val x = g(cur, len - b)\\n        if (!isv.contains(x)) q enqueue x\\n\\n      }\\n    }\\n\\n    min\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n def findLexSmallestString(s: String, a: Int, b: Int): String = {\\n    type st = String\\n    type in = Int\\n    var min = s\\n    val len = s.length\\n    import scala.collection.mutable.{HashSet, Queue}\\n    val q               = new Queue[st]\\n    val isv             = new HashSet[st]\\n    def f(x: st, i: in) = x charAt i\\n    def g(x: st, i: in) = x.substring(i) + x.substring(0, i)\\n\\n    q enqueue s\\n    while (!q.isEmpty) {\\n      val cur = q.dequeue\\n      if (min.compareTo(cur) > 0) min = cur\\n      if (!isv.contains(cur)) {\\n        isv add cur\\n        val xx =\\n          (0 until len)\\n            .map(i => {\\n\\n              (i % 2 == 0) match {\\n                case true => { f(cur, i) }\\n                case _ => {\\n                  val x = f(cur, i) - \\'0\\'\\n                  (\\'0\\' + { if (x + a <= 9) x + a else (x + a) % 10 }).toChar\\n\\n                }\\n\\n              }\\n            })\\n            .mkString\\n\\n        if (!isv.contains(xx)) q enqueue xx.toString\\n\\n        val x = g(cur, len - b)\\n        if (!isv.contains(x)) q enqueue x\\n\\n      }\\n    }\\n\\n    min\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1237826,
                "title": "c-solution-using-bfs",
                "content": "class Solution {\\npublic:\\n    unordered_set<string> processedSet;\\n    \\n    string addToString(string& s,int& a){\\n        string s_aux=s;\\n        for(int i=1;i<s.size();i+=2){\\n            s_aux[i]=\\'0\\'+((s[i]-\\'0\\')+a)%10;\\n        }\\n        return s_aux;\\n    }\\n    \\n    string rotateString(string& s,int& b){\\n        string s_aux=s;\\n        for(int i=s.size()-b,j=0;i<s.size();i+=1,j++){\\n            s_aux[j]=s[i];\\n        }\\n        for(int i=0,j=b;i<s.size()-b;i++,j++){\\n            s_aux[j]=s[i];\\n        }\\n        return s_aux;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string> stringQueue;\\n        stringQueue.push(s);\\n        string smallestString=s;\\n        while(!stringQueue.empty()){\\n            string string_aux=stringQueue.front();\\n            stringQueue.pop();\\n            if(string_aux<smallestString){\\n                smallestString=string_aux;\\n            }\\n            if(processedSet.find(string_aux)==processedSet.end()){\\n                    processedSet.insert(string_aux);\\n                    stringQueue.push(rotateString(string_aux,b));\\n                    stringQueue.push(addToString(string_aux,a));\\n            }\\n        }\\n        return smallestString;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_set<string> processedSet;\\n    \\n    string addToString(string& s,int& a){\\n        string s_aux=s;\\n        for(int i=1;i<s.size();i+=2){\\n            s_aux[i]=\\'0\\'+((s[i]-\\'0\\')+a)%10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237786,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int A,B;\\n    \\n    unordered_map<string,string> added;\\n    unordered_map<string,string> rotated;\\n    \\n    string addToString(string& s){\\n        string s_aux=s;\\n        for(int i=1;i<s.size();i+=2){\\n            s_aux[i]=\\'0\\'+((s[i]-\\'0\\')+A)%10;\\n        }\\n        return s_aux;\\n    }\\n    \\n    string rotateString(string& s){\\n        string s_aux=s;\\n        for(int i=s.size()-B,j=0;i<s.size();i+=1,j++){\\n            s_aux[j]=s[i];\\n        }\\n        for(int i=0,j=B;i<s.size()-B;i++,j++){\\n            s_aux[j]=s[i];\\n        }\\n        return s_aux;\\n    }\\n    \\n    string generateAllStrings(string& s){\\n        string addedString=addToString(s);\\n        string rotatedString=rotateString(s);\\n        if(added.find(s)==added.end()){\\n            added[s]=addedString;\\n            addedString=generateAllStrings(addedString);\\n        }\\n        if(rotated.find(s)==rotated.end()){\\n            rotated[s]=rotatedString;\\n            rotatedString=generateAllStrings(rotatedString);\\n        }\\n        \\n        if(addedString>rotatedString){\\n            return rotatedString;\\n        }\\n        else{\\n            return addedString;\\n        }\\n        \\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        A=a;\\n        B=b;\\n        return generateAllStrings(s);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int A,B;\\n    \\n    unordered_map<string,string> added;\\n    unordered_map<string,string> rotated;\\n    \\n    string addToString(string& s){\\n        string s_aux=s;\\n        for(int i=1;i<s.size();i+=2){\\n            s_aux[i]=\\'0\\'+((s[i]-\\'0\\')+A)%10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1230645,
                "title": "python3-dfs-simple-solution",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.mn = \\'z\\' * 100\\n        self.vis = set()\\n    \\n    def solve(self, st):\\n        if \\'\\'.join(st) in self.vis:\\n            return\\n        self.vis.add(\\'\\'.join(st))\\n        new = st\\n        for i in range(1, len(st), 2):\\n            st[i] = str((int(st[i]) + self.a) % 10)\\n        self.mn = min(\\'\\'.join(st), self.mn)\\n        \\n        lp = new[-self.b:]\\n        fp = new[:self.l - self.b]\\n        new = lp + fp\\n        self.mn = min(self.mn, \\'\\'.join(new))\\n        \\n        self.solve(st)\\n        self.solve(new)\\n    \\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        self.a = a ; self.b = b\\n        self.l = len(s)\\n        self.b = self.b % self.l\\n        s = list(s)\\n        self.solve(s)\\n        return self.mn\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.mn = \\'z\\' * 100\\n        self.vis = set()\\n    \\n    def solve(self, st):\\n        if \\'\\'.join(st) in self.vis:\\n            return\\n        self.vis.add(\\'\\'.join(st))\\n        new = st\\n        for i in range(1, len(st), 2):\\n            st[i] = str((int(st[i]) + self.a) % 10)\\n        self.mn = min(\\'\\'.join(st), self.mn)\\n        \\n        lp = new[-self.b:]\\n        fp = new[:self.l - self.b]\\n        new = lp + fp\\n        self.mn = min(self.mn, \\'\\'.join(new))\\n        \\n        self.solve(st)\\n        self.solve(new)\\n    \\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        self.a = a ; self.b = b\\n        self.l = len(s)\\n        self.b = self.b % self.l\\n        s = list(s)\\n        self.solve(s)\\n        return self.mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208338,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string lexSmallestString = s;\\n        unordered_set<string> seen = { s };\\n        queue<string> todo;\\n        todo.push(lexSmallestString);\\n        while (!todo.empty()) {\\n            string cur = todo.front();\\n            todo.pop();\\n            if (cur < lexSmallestString) {\\n                lexSmallestString = cur;\\n            }\\n            string rotated = shiftBtimes(cur, b);\\n            if (seen.find(rotated) == seen.end()) {\\n                todo.push(rotated);\\n                seen.insert(rotated);\\n            }\\n            addAToOdds(cur, a);\\n            if (seen.find(cur) == seen.end()) {\\n                todo.push(cur);\\n                seen.insert(cur);\\n            }\\n        }\\n        return lexSmallestString;\\n    }\\n    \\n    string shiftBtimes(string s, int b) {\\n        vector<char> moveToFront;\\n        while (b > 0) {\\n            moveToFront.push_back(s.back());\\n            s.pop_back();\\n            b--;\\n        }\\n        string shifted = \"\";\\n        for (int i = moveToFront.size() - 1; i >= 0; i--) {\\n            shifted += moveToFront[i];\\n        }\\n        for (char c : s) {\\n            shifted += c;\\n        }\\n        return shifted;\\n    }\\n    \\n    void addAToOdds(string &s, int a) {\\n        for (int i = 1; i < s.size(); i += 2) {\\n            int n = s[i] - \\'0\\';\\n            n = (a + n) % 10;\\n            s[i] = n + \\'0\\';\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string lexSmallestString = s;\\n        unordered_set<string> seen = { s };\\n        queue<string> todo;\\n        todo.push(lexSmallestString);\\n        while (!todo.empty()) {\\n            string cur = todo.front();\\n            todo.pop();\\n            if (cur < lexSmallestString) {\\n                lexSmallestString = cur;\\n            }\\n            string rotated = shiftBtimes(cur, b);\\n            if (seen.find(rotated) == seen.end()) {\\n                todo.push(rotated);\\n                seen.insert(rotated);\\n            }\\n            addAToOdds(cur, a);\\n            if (seen.find(cur) == seen.end()) {\\n                todo.push(cur);\\n                seen.insert(cur);\\n            }\\n        }\\n        return lexSmallestString;\\n    }\\n    \\n    string shiftBtimes(string s, int b) {\\n        vector<char> moveToFront;\\n        while (b > 0) {\\n            moveToFront.push_back(s.back());\\n            s.pop_back();\\n            b--;\\n        }\\n        string shifted = \"\";\\n        for (int i = moveToFront.size() - 1; i >= 0; i--) {\\n            shifted += moveToFront[i];\\n        }\\n        for (char c : s) {\\n            shifted += c;\\n        }\\n        return shifted;\\n    }\\n    \\n    void addAToOdds(string &s, int a) {\\n        for (int i = 1; i < s.size(); i += 2) {\\n            int n = s[i] - \\'0\\';\\n            n = (a + n) % 10;\\n            s[i] = n + \\'0\\';\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203447,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func findLexSmallestString(_ s: String, _ a: Int, _ b: Int) -> String {\\n        let s = s.map({ Int($0.asciiValue ?? 48) - 48 }), digits = 10, c = s.count\\n        var numShift = Set<Int>(), lenShift = numShift, remainder = 0, oddShift = false, result = s\\n        while true { // get all unique \"vertical\" shifts\\n            if numShift.contains(remainder) {\\n                break\\n            } else {\\n                numShift.insert(remainder)\\n            }\\n            remainder = (remainder + a) % digits\\n        }\\n        remainder = 0\\n        while true { // get all unique \"horizontal\" shifts\\n            if lenShift.contains(remainder) {\\n                break\\n            } else {\\n                if remainder % 2 == 1 { // if we can rotate to the right by odd positions, then we also can apply \"vertical\" shifts to all even indicies in source\\n                    oddShift = true\\n                }\\n                lenShift.insert(remainder)\\n            }\\n            remainder = (remainder + b) % c\\n        }\\n        func tryNums(_ nums: [Int], _ k: Int) { // rotate nums to the right by k positions, then compare with result\\n            var candidate = [Int]()\\n            for i in (c - k)..<(2 * c - k) { // candidate = nums rotated\\n                candidate.append(nums[i % c])\\n            }\\n            for i in 0..<c { // compate candidate with result\\n                if result[i] < candidate[i] {\\n                    return\\n                } else if result[i] > candidate[i] {\\n                    break\\n                }\\n            }\\n            result = candidate\\n        }\\n        for ls in lenShift { // \"horizontal\" shifts\\n            for nsOdd in numShift { // \"vertical\" shifts to all odd indicies\\n                var candidateOdd = s\\n                for i in stride(from: 1, to: c, by: 2) {\\n                    candidateOdd[i] = (candidateOdd[i] + nsOdd) % digits\\n                }\\n                if oddShift {\\n                    for nsEven in numShift { // \"vertical\" shifts to all even indicies\\n                        var candidateEven = candidateOdd\\n                        for i in stride(from: 0, to: c, by: 2) {\\n                            candidateEven[i] = (candidateEven[i] + nsEven) % digits\\n                        }\\n                        tryNums(candidateEven, ls)\\n                    }\\n                } else {\\n                    tryNums(candidateOdd, ls)\\n                }\\n            }\\n        }\\n        return String(result.map({ Character(UnicodeScalar(UInt8($0 + 48))) }))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findLexSmallestString(_ s: String, _ a: Int, _ b: Int) -> String {\\n        let s = s.map({ Int($0.asciiValue ?? 48) - 48 }), digits = 10, c = s.count\\n        var numShift = Set<Int>(), lenShift = numShift, remainder = 0, oddShift = false, result = s\\n        while true { // get all unique \"vertical\" shifts\\n            if numShift.contains(remainder) {\\n                break\\n            } else {\\n                numShift.insert(remainder)\\n            }\\n            remainder = (remainder + a) % digits\\n        }\\n        remainder = 0\\n        while true { // get all unique \"horizontal\" shifts\\n            if lenShift.contains(remainder) {\\n                break\\n            } else {\\n                if remainder % 2 == 1 { // if we can rotate to the right by odd positions, then we also can apply \"vertical\" shifts to all even indicies in source\\n                    oddShift = true\\n                }\\n                lenShift.insert(remainder)\\n            }\\n            remainder = (remainder + b) % c\\n        }\\n        func tryNums(_ nums: [Int], _ k: Int) { // rotate nums to the right by k positions, then compare with result\\n            var candidate = [Int]()\\n            for i in (c - k)..<(2 * c - k) { // candidate = nums rotated\\n                candidate.append(nums[i % c])\\n            }\\n            for i in 0..<c { // compate candidate with result\\n                if result[i] < candidate[i] {\\n                    return\\n                } else if result[i] > candidate[i] {\\n                    break\\n                }\\n            }\\n            result = candidate\\n        }\\n        for ls in lenShift { // \"horizontal\" shifts\\n            for nsOdd in numShift { // \"vertical\" shifts to all odd indicies\\n                var candidateOdd = s\\n                for i in stride(from: 1, to: c, by: 2) {\\n                    candidateOdd[i] = (candidateOdd[i] + nsOdd) % digits\\n                }\\n                if oddShift {\\n                    for nsEven in numShift { // \"vertical\" shifts to all even indicies\\n                        var candidateEven = candidateOdd\\n                        for i in stride(from: 0, to: c, by: 2) {\\n                            candidateEven[i] = (candidateEven[i] + nsEven) % digits\\n                        }\\n                        tryNums(candidateEven, ls)\\n                    }\\n                } else {\\n                    tryNums(candidateOdd, ls)\\n                }\\n            }\\n        }\\n        return String(result.map({ Character(UnicodeScalar(UInt8($0 + 48))) }))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193078,
                "title": "generate-all-possibilities-with-two-loops",
                "content": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        t = tuple(map(int, list(s)))\\n        seqs = {t}\\n        tuples = {t}\\n        while tuples:\\n            new_tuples = set()\\n            for t in tuples:\\n                t_add = tuple((v + a) % 10 if i % 2 else v\\n                              for i, v in enumerate(t))\\n                if t_add not in seqs:\\n                    seqs.add(t_add)\\n                    new_tuples.add(t_add)\\n                t_rot = tuple([t[i] for i in range(b, len(t))] +\\n                              [t[i] for i in range(b)])\\n                if t_rot not in seqs:\\n                    seqs.add(t_rot)\\n                    new_tuples.add(t_rot)\\n            tuples = new_tuples\\n        return \"\".join(map(str, min(seqs)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        t = tuple(map(int, list(s)))\\n        seqs = {t}\\n        tuples = {t}\\n        while tuples:\\n            new_tuples = set()\\n            for t in tuples:\\n                t_add = tuple((v + a) % 10 if i % 2 else v\\n                              for i, v in enumerate(t))\\n                if t_add not in seqs:\\n                    seqs.add(t_add)\\n                    new_tuples.add(t_add)\\n                t_rot = tuple([t[i] for i in range(b, len(t))] +\\n                              [t[i] for i in range(b)])\\n                if t_rot not in seqs:\\n                    seqs.add(t_rot)\\n                    new_tuples.add(t_rot)\\n            tuples = new_tuples\\n        return \"\".join(map(str, min(seqs)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181394,
                "title": "bruteforce-till-previously-seen",
                "content": "```\\n\\npublic String findLexSmallestString(String s, int a, int b) {\\n        \\n        Set<String>  set = new HashSet<>();\\n        \\n        find(s,set,a,b);\\n        \\n        List<String> list = new ArrayList<>(set);\\n        Collections.sort(list,(x,y)->x.compareTo(y));\\n        return list.get(0);\\n    }\\n    \\n    private void find(String s,Set<String> set,int a,int b){\\n        if(!set.add(s))\\n            return;\\n        \\n        find(op1(s,a),set,a,b);\\n        find(op2(s,b),set,a,b);\\n    }\\n    \\n    private String op2(String s,int b){\\n        char[] cs=s.toCharArray();\\n        int n=cs.length;\\n        char[] tmp =new char[n];\\n        for(int i=0;i<n;i++){\\n            tmp[(i+b)%n]=cs[i];\\n        }\\n        return new String(tmp);\\n    }\\n    \\n    private String op1(String s,int a){\\n        char[] cs=s.toCharArray();\\n        int n=cs.length;\\n        for(int i=0;i<n;i++){\\n            if(i%2==1){\\n                int c=Character.getNumericValue(cs[i]);\\n                c= (c+a)%10;\\n                cs[i]= (char)(c+\\'0\\');\\n            }\\n        }\\n        return new String(cs);\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic String findLexSmallestString(String s, int a, int b) {\\n        \\n        Set<String>  set = new HashSet<>();\\n        \\n        find(s,set,a,b);\\n        \\n        List<String> list = new ArrayList<>(set);\\n        Collections.sort(list,(x,y)->x.compareTo(y));\\n        return list.get(0);\\n    }\\n    \\n    private void find(String s,Set<String> set,int a,int b){\\n        if(!set.add(s))\\n            return;\\n        \\n        find(op1(s,a),set,a,b);\\n        find(op2(s,b),set,a,b);\\n    }\\n    \\n    private String op2(String s,int b){\\n        char[] cs=s.toCharArray();\\n        int n=cs.length;\\n        char[] tmp =new char[n];\\n        for(int i=0;i<n;i++){\\n            tmp[(i+b)%n]=cs[i];\\n        }\\n        return new String(tmp);\\n    }\\n    \\n    private String op1(String s,int a){\\n        char[] cs=s.toCharArray();\\n        int n=cs.length;\\n        for(int i=0;i<n;i++){\\n            if(i%2==1){\\n                int c=Character.getNumericValue(cs[i]);\\n                c= (c+a)%10;\\n                cs[i]= (char)(c+\\'0\\');\\n            }\\n        }\\n        return new String(cs);\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1159590,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    String ans;\\n    HashSet<String> hs;\\n    \\n    public String findLexSmallestString(String s, int a, int b) {\\n        ans=s;\\n        hs=new HashSet<>();\\n        helper(s,a,b);\\n        return ans;\\n    }\\n    public void helper(String s,int a,int b){\\n        if(hs.contains(s))\\n            return ;\\n        if(s.compareTo(ans)<0){\\n            ans=s;\\n        }\\n        hs.add(s);\\n        helper(rotate(s,b),a,b);\\n        helper(add(s,a),a,b);\\n    }\\n    public String rotate(String s,int b){\\n        int pos=s.length()-b;\\n        return s.substring(pos)+s.substring(0,pos);\\n    }\\n    public String add(String s,int b){\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if((i%2)==1){\\n                int val=((c-\\'0\\')+b)%10;\\n                c=(char)(\\'0\\'+val);\\n            }\\n           temp+=c;               \\n        }\\n         return temp;                 \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    String ans;\\n    HashSet<String> hs;\\n    \\n    public String findLexSmallestString(String s, int a, int b) {\\n        ans=s;\\n        hs=new HashSet<>();\\n        helper(s,a,b);\\n        return ans;\\n    }\\n    public void helper(String s,int a,int b){\\n        if(hs.contains(s))\\n            return ;\\n        if(s.compareTo(ans)<0){\\n            ans=s;\\n        }\\n        hs.add(s);\\n        helper(rotate(s,b),a,b);\\n        helper(add(s,a),a,b);\\n    }\\n    public String rotate(String s,int b){\\n        int pos=s.length()-b;\\n        return s.substring(pos)+s.substring(0,pos);\\n    }\\n    public String add(String s,int b){\\n        String temp=\"\";\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if((i%2)==1){\\n                int val=((c-\\'0\\')+b)%10;\\n                c=(char)(\\'0\\'+val);\\n            }\\n           temp+=c;               \\n        }\\n         return temp;                 \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140193,
                "title": "c-bfs-and-dfs-implementation",
                "content": "**DFS**\\n```\\nclass Solution {\\npublic:\\n    string ans;\\nunordered_set<string>s;\\nvoid dfs(string str, int a, int b) {\\n\\tif (!s.insert(str).second)return ;\\n\\tans = min(ans, str);\\n\\tstring t (str);\\n\\tfor (int i = 1; i < str.size(); i += 2) {\\n\\t\\tt[i] = (str[i] - \\'0\\' + a) % 10 + \\'0\\';\\n\\t}\\n\\tdfs(t, a, b);\\n\\tdfs(str.substr(b) + str.substr(0, b), a, b);\\n\\treturn ;\\n}\\n    string findLexSmallestString(string str, int a, int b) {\\n                ans =str ;\\n\\n        dfs(str, a, b);\\n\\treturn ans ;\\n    }\\n};\\n\\n```\\n**BFS**\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string , bool>m;\\n    string findLexSmallestString(string str, int a, int b) {\\n      queue<string >q;\\n        string ans =str;\\n\\tq.push(str);\\n\\tm.insert({str, true});\\n\\twhile (!q.empty()) {\\n\\t\\tstring check = q.front();\\n\\t\\tq.pop();\\n\\t\\tans = min(ans, check);\\n\\t\\tstring t(check);\\n\\t\\tfor (int i = 1; i < check.size(); i += 2) {\\n\\t\\t\\tt[i] = (t[i] - \\'0\\' + a) % 10 + \\'0\\';\\n\\t\\t}\\n\\t\\tif (m.find(t) == m.end()) {\\n\\t\\t\\tm.insert({t, true});\\n\\t\\t\\tq.push(t);\\n\\t\\t}\\n\\t\\tif (m.find(check.substr(b) + check.substr(0, b)) == m.end()) {\\n\\t\\t\\tm.insert({check.substr(b) + check.substr(0, b), true});\\n\\t\\t\\tq.push(check.substr(b) + check.substr(0, b));\\n\\t\\t}\\n\\t}\\n\\treturn ans ;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\nunordered_set<string>s;\\nvoid dfs(string str, int a, int b) {\\n\\tif (!s.insert(str).second)return ;\\n\\tans = min(ans, str);\\n\\tstring t (str);\\n\\tfor (int i = 1; i < str.size(); i += 2) {\\n\\t\\tt[i] = (str[i] - \\'0\\' + a) % 10 + \\'0\\';\\n\\t}\\n\\tdfs(t, a, b);\\n\\tdfs(str.substr(b) + str.substr(0, b), a, b);\\n\\treturn ;\\n}\\n    string findLexSmallestString(string str, int a, int b) {\\n                ans =str ;\\n\\n        dfs(str, a, b);\\n\\treturn ans ;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string , bool>m;\\n    string findLexSmallestString(string str, int a, int b) {\\n      queue<string >q;\\n        string ans =str;\\n\\tq.push(str);\\n\\tm.insert({str, true});\\n\\twhile (!q.empty()) {\\n\\t\\tstring check = q.front();\\n\\t\\tq.pop();\\n\\t\\tans = min(ans, check);\\n\\t\\tstring t(check);\\n\\t\\tfor (int i = 1; i < check.size(); i += 2) {\\n\\t\\t\\tt[i] = (t[i] - \\'0\\' + a) % 10 + \\'0\\';\\n\\t\\t}\\n\\t\\tif (m.find(t) == m.end()) {\\n\\t\\t\\tm.insert({t, true});\\n\\t\\t\\tq.push(t);\\n\\t\\t}\\n\\t\\tif (m.find(check.substr(b) + check.substr(0, b)) == m.end()) {\\n\\t\\t\\tm.insert({check.substr(b) + check.substr(0, b), true});\\n\\t\\t\\tq.push(check.substr(b) + check.substr(0, b));\\n\\t\\t}\\n\\t}\\n\\treturn ans ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132946,
                "title": "bfs-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string add(string s,int a)\\n    {\\n        for(int i=1;i<s.length();i+=2)\\n        {\\n             s[i] = \\'0\\' + ((s[i]-\\'0\\' + a)%10);\\n        }\\n        return s;\\n    }\\n    \\n    string rotate(string s,int b)\\n    {\\n        int n = s.length();\\n        string s1 = s.substr(n - b, b);\\n        string s2 = s.substr(0, n - b);\\n        return s1+s2;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string> q;\\n        q.emplace(s);\\n        unordered_set<string> us;\\n        us.emplace(s);\\n        string ans = s;\\n        \\n        while(!q.empty())\\n        {\\n            string x = q.front();\\n            q.pop();\\n            string y = add(x,a);\\n            string z = rotate(x,b);\\n            ans = min(ans,x);\\n            \\n            if(us.find(y)==us.end())\\n            {\\n                q.emplace(y);\\n                us.emplace(y);\\n            }\\n            if(us.find(z)==us.end())\\n            {\\n                q.emplace(z);\\n                us.emplace(z);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string add(string s,int a)\\n    {\\n        for(int i=1;i<s.length();i+=2)\\n        {\\n             s[i] = \\'0\\' + ((s[i]-\\'0\\' + a)%10);\\n        }\\n        return s;\\n    }\\n    \\n    string rotate(string s,int b)\\n    {\\n        int n = s.length();\\n        string s1 = s.substr(n - b, b);\\n        string s2 = s.substr(0, n - b);\\n        return s1+s2;\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        queue<string> q;\\n        q.emplace(s);\\n        unordered_set<string> us;\\n        us.emplace(s);\\n        string ans = s;\\n        \\n        while(!q.empty())\\n        {\\n            string x = q.front();\\n            q.pop();\\n            string y = add(x,a);\\n            string z = rotate(x,b);\\n            ans = min(ans,x);\\n            \\n            if(us.find(y)==us.end())\\n            {\\n                q.emplace(y);\\n                us.emplace(y);\\n            }\\n            if(us.find(z)==us.end())\\n            {\\n                q.emplace(z);\\n                us.emplace(z);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127453,
                "title": "python-intuition-and-how-to-bruteforce-fast",
                "content": "There is one thing we notice that: Adding 10 `a` is the same as adding 0 `a`. In fact, some `a` like `5` cycles even sooner. Thus, no matter what `a` is, just have 10 loops and add them.\\n\\nWe also know that `len(s)` is even. If `b` is odd, that means we can add `a` to even digits just by shifting by `b` once. If `b` is even, we cannot add `a` to even digits. Therefore, we can simply has another 10 loops when `b` is odd\\n\\nThe complexity of the above is: `O(10*10) = O(1)`\\nFinally, the last part is shifting string `s` by `b`  `len(s)` times and we can find min\\n\\n```python\\n    # 136 ms, 92.93%. Time: O(N^2). Space: O(N)\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t# Try all shifting positions and compare\\n        def get_smaller(ans, s):\\n            for _ in range(len(s)):\\n                s = s[b:] + s[:b]\\n                ans = min(ans, s)\\n            return ans\\n        \\n\\t\\t# Add number to just odd or even digits.\\n        def add_a(temp, odd = True):\\n            rv = [str((int(c) + a) % 10) if i % 2 == odd else c for i, c in enumerate(temp)]\\n            return \"\".join(rv)\\n        \\n        ans = \"9\" * len(s)\\n        odd = s\\n        # Shift Odd digits\\n        for _ in range(10):\\n            odd = add_a(odd, True)\\n            even = odd\\n            # Shift Even digits if applicable\\n            for _ in range(10) if b % 2 else range(1): # <--------------- Trick for CLEAN CODE !!!\\n                ans = get_smaller(ans, even)\\n                even = add_a(even, False)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    # 136 ms, 92.93%. Time: O(N^2). Space: O(N)\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n\\t\\t# Try all shifting positions and compare\\n        def get_smaller(ans, s):\\n            for _ in range(len(s)):\\n                s = s[b:] + s[:b]\\n                ans = min(ans, s)\\n            return ans\\n        \\n\\t\\t# Add number to just odd or even digits.\\n        def add_a(temp, odd = True):\\n            rv = [str((int(c) + a) % 10) if i % 2 == odd else c for i, c in enumerate(temp)]\\n            return \"\".join(rv)\\n        \\n        ans = \"9\" * len(s)\\n        odd = s\\n        # Shift Odd digits\\n        for _ in range(10):\\n            odd = add_a(odd, True)\\n            even = odd\\n            # Shift Even digits if applicable\\n            for _ in range(10) if b % 2 else range(1): # <--------------- Trick for CLEAN CODE !!!\\n                ans = get_smaller(ans, even)\\n                even = add_a(even, False)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1121051,
                "title": "python-faster-and-less-space-than-95",
                "content": "```python\\nfrom itertools import chain\\n\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        def generate_possibilities(start, increment, limit):\\n            possible = set()\\n            while start not in possible:\\n                possible.add(start)\\n                start = (start + increment) % limit\\n            return possible\\n        \\n        \\n        S = len(s)\\n        possibilities = set()\\n        possible_starts = generate_possibilities(0, b, S)\\n        possible_additions = generate_possibilities(0, a, 10)\\n        for add in possible_additions:\\n            possibilities.add(\"\".join([c if (i% 2) == 0 else str((int(c) + add) % 10) for i,c in enumerate(s)]))\\n        if b % 2:\\n            for p in list(possibilities):\\n                for add in possible_additions:\\n                    possibilities.add(\"\".join([c if i% 2 else str((int(c) + add) % 10) for i,c in enumerate(p)]))\\n        \\n        m = next(iter(possibilities))\\n        for start in possible_starts:\\n            for p in list(possibilities):\\n                m = min(m, p[start:] + p[:start])\\n                    \\n        return m\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nfrom itertools import chain\\n\\nclass Solution:\\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\\n        def generate_possibilities(start, increment, limit):\\n            possible = set()\\n            while start not in possible:\\n                possible.add(start)\\n                start = (start + increment) % limit\\n            return possible\\n        \\n        \\n        S = len(s)\\n        possibilities = set()\\n        possible_starts = generate_possibilities(0, b, S)\\n        possible_additions = generate_possibilities(0, a, 10)\\n        for add in possible_additions:\\n            possibilities.add(\"\".join([c if (i% 2) == 0 else str((int(c) + add) % 10) for i,c in enumerate(s)]))\\n        if b % 2:\\n            for p in list(possibilities):\\n                for add in possible_additions:\\n                    possibilities.add(\"\".join([c if i% 2 else str((int(c) + add) % 10) for i,c in enumerate(p)]))\\n        \\n        m = next(iter(possibilities))\\n        for start in possible_starts:\\n            for p in list(possibilities):\\n                m = min(m, p[start:] + p[:start])\\n                    \\n        return m\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106652,
                "title": "85-faster-javascript-solution-using-recursion-and-memoization",
                "content": "```\\nvar findLexSmallestString = function(s, a, b) {\\n    let cache = new Set();\\n    let min = s;\\n\\n    function recurse(curr) {\\n        if (cache.has(curr)) return;\\n        if (curr < min) min = curr;\\n        \\n        cache.add(curr);\\n    \\n        let addArr = curr.split(\\'\\')\\n        \\n        for (let i = 1; i < addArr.length; i += 2) {\\n            addArr[i] = (Number(addArr[i]) + a) % 10;\\n        }\\n        \\n        recurse(addArr.join(\\'\\'));\\n        recurse(curr.slice(b) + curr.slice(0, b));\\n        \\n    }\\n    recurse(s);\\n    \\n    return min;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findLexSmallestString = function(s, a, b) {\\n    let cache = new Set();\\n    let min = s;\\n\\n    function recurse(curr) {\\n        if (cache.has(curr)) return;\\n        if (curr < min) min = curr;\\n        \\n        cache.add(curr);\\n    \\n        let addArr = curr.split(\\'\\')\\n        \\n        for (let i = 1; i < addArr.length; i += 2) {\\n            addArr[i] = (Number(addArr[i]) + a) % 10;\\n        }\\n        \\n        recurse(addArr.join(\\'\\'));\\n        recurse(curr.slice(b) + curr.slice(0, b));\\n        \\n    }\\n    recurse(s);\\n    \\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085464,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> st;\\n        \\n        unordered_map<char, char> mp;\\n        for(int i=0; i<=9; i++) {\\n            char t = \\'0\\' + (i + a) % 10;\\n            mp[\\'0\\' + i] = t;\\n        }\\n        \\n        queue<string> q;\\n        q.push(s);\\n        st.insert(s);\\n        string ans = s;\\n        while(!q.empty()) {\\n            string cur = q.front();\\n            q.pop();\\n            if(cur < ans) ans = cur;\\n            \\n\\t\\t\\t// Add operation.\\n            string add = cur;\\n            for(int i=1; i<add.size(); i+= 2) {\\n                add[i] = mp[add[i]];\\n            }\\n            if(!st.count(add)) {\\n                st.insert(add);\\n                q.push(add);\\n            }\\n            \\n\\t\\t\\t// Rotate operation.\\n            string shift = cur.substr(cur.size() - b) + cur.substr(0, cur.size() - b);\\n            if(!st.count(shift)) {\\n                st.insert(shift);\\n                q.push(shift);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        unordered_set<string> st;\\n        \\n        unordered_map<char, char> mp;\\n        for(int i=0; i<=9; i++) {\\n            char t = \\'0\\' + (i + a) % 10;\\n            mp[\\'0\\' + i] = t;\\n        }\\n        \\n        queue<string> q;\\n        q.push(s);\\n        st.insert(s);\\n        string ans = s;\\n        while(!q.empty()) {\\n            string cur = q.front();\\n            q.pop();\\n            if(cur < ans) ans = cur;\\n            \\n\\t\\t\\t// Add operation.\\n            string add = cur;\\n            for(int i=1; i<add.size(); i+= 2) {\\n                add[i] = mp[add[i]];\\n            }\\n            if(!st.count(add)) {\\n                st.insert(add);\\n                q.push(add);\\n            }\\n            \\n\\t\\t\\t// Rotate operation.\\n            string shift = cur.substr(cur.size() - b) + cur.substr(0, cur.size() - b);\\n            if(!st.count(shift)) {\\n                st.insert(shift);\\n                q.push(shift);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071159,
                "title": "simple-c-using-dfs-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        stack<string> stk;\\n        unordered_set<string> us;\\n        us.insert(s);\\n        stk.push(s);\\n        string smallest = s;\\n        while(!stk.empty())\\n        {\\n            string t = stk.top();\\n            string tp = t;\\n            stk.pop();\\n            //case a\\n            int n = tp.size();\\n            for(int i = 1; i < n; i= i+2)\\n            {\\n                tp[i] = (tp[i]-\\'0\\'+a)%10+\\'0\\';\\n            }\\n            if(us.find(tp) == us.end())\\n            {\\n                smallest = (smallest > tp)?tp:smallest;\\n                stk.push(tp);\\n                us.insert(tp);\\n            }\\n            //case b\\n            string temp = t.substr(n-b%n)+t.substr(0,n-b%n);\\n            if(us.find(temp) == us.end())\\n            {\\n                smallest = (smallest > temp)?temp:smallest;\\n                stk.push(temp);\\n                us.insert(temp);\\n            }\\n        }\\n        return smallest;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) \\n    {\\n        stack<string> stk;\\n        unordered_set<string> us;\\n        us.insert(s);\\n        stk.push(s);\\n        string smallest = s;\\n        while(!stk.empty())\\n        {\\n            string t = stk.top();\\n            string tp = t;\\n            stk.pop();\\n            //case a\\n            int n = tp.size();\\n            for(int i = 1; i < n; i= i+2)\\n            {\\n                tp[i] = (tp[i]-\\'0\\'+a)%10+\\'0\\';\\n            }\\n            if(us.find(tp) == us.end())\\n            {\\n                smallest = (smallest > tp)?tp:smallest;\\n                stk.push(tp);\\n                us.insert(tp);\\n            }\\n            //case b\\n            string temp = t.substr(n-b%n)+t.substr(0,n-b%n);\\n            if(us.find(temp) == us.end())\\n            {\\n                smallest = (smallest > temp)?temp:smallest;\\n                stk.push(temp);\\n                us.insert(temp);\\n            }\\n        }\\n        return smallest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033599,
                "title": "c-dfs-with-short-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        // DFS: for each s, we apply a and b separately, and keep a hash set to store the elements that\\n        // we already visited. Among all of those string, we find the smallest one.\\n        unordered_set<string> visited;\\n        string smallest = s;\\n        findLexSmallestString(s, a, b, visited, smallest);\\n        return smallest;\\n    }\\n    \\nprivate:\\n    void findLexSmallestString(string& s, int a, int b, unordered_set<string>& visited, string& smallest)\\n    {\\n        if (visited.find(s) != visited.end())\\n        {\\n            return;\\n        }\\n        \\n        int size = s.size();\\n        visited.insert(s);\\n        smallest = s < smallest ? s : smallest;\\n        \\n        // DFS plus a\\n        string plus = s;\\n        for (int i = 1; i < size; i += 2)\\n        {\\n            plus[i] = (plus[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        }\\n        findLexSmallestString(plus, a, b, visited, smallest);\\n        \\n        // DFS rotate b\\n        string rotate = s.substr(size - b % size) + s.substr(0, size - b % size);\\n        findLexSmallestString(rotate, a, b, visited, smallest);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        // DFS: for each s, we apply a and b separately, and keep a hash set to store the elements that\\n        // we already visited. Among all of those string, we find the smallest one.\\n        unordered_set<string> visited;\\n        string smallest = s;\\n        findLexSmallestString(s, a, b, visited, smallest);\\n        return smallest;\\n    }\\n    \\nprivate:\\n    void findLexSmallestString(string& s, int a, int b, unordered_set<string>& visited, string& smallest)\\n    {\\n        if (visited.find(s) != visited.end())\\n        {\\n            return;\\n        }\\n        \\n        int size = s.size();\\n        visited.insert(s);\\n        smallest = s < smallest ? s : smallest;\\n        \\n        // DFS plus a\\n        string plus = s;\\n        for (int i = 1; i < size; i += 2)\\n        {\\n            plus[i] = (plus[i] - \\'0\\' + a) % 10 + \\'0\\';\\n        }\\n        findLexSmallestString(plus, a, b, visited, smallest);\\n        \\n        // DFS rotate b\\n        string rotate = s.substr(size - b % size) + s.substr(0, size - b % size);\\n        findLexSmallestString(rotate, a, b, visited, smallest);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032170,
                "title": "c-brute-force-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string res = s;\\n        unordered_set<string> visited;\\n        dfs(s, a, b, visited, res);\\n        return res;\\n    }\\n    \\n    void dfs(const string& s, int a, int b, unordered_set<string>& visited, string& minS){\\n        if(visited.count(s)) return;\\n        visited.insert(s);\\n        minS = min(s, minS);\\n        dfs(rotate(s, b), a, b, visited, minS);\\n        dfs(add(s, a), a, b, visited, minS);\\n    }\\n    \\n    string rotate(const string& s, int b){\\n        return (s+s).substr(s.size()-b, s.size());\\n    }\\n    \\n    string add(string s, int a){\\n        for(int i=1;i<s.size();i+=2){\\n            int j = s[i]-\\'0\\';\\n            j = (j+a) % 10;\\n            s[i] = \\'0\\' + j;\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string findLexSmallestString(string s, int a, int b) {\\n        string res = s;\\n        unordered_set<string> visited;\\n        dfs(s, a, b, visited, res);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1028681,
                "title": "my-java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        String min = s;\\n        Set<String> visited = new HashSet<>(), curr = new HashSet<>();\\n        curr.add(s);\\n\\n        while (!curr.isEmpty()) {\\n            // System.out.println(curr);\\n            Set<String> next = new HashSet<>();\\n            for (String ss : curr) {\\n                visited.add(ss);\\n                String opA = doOpA(ss, a);\\n                if (!visited.contains(opA)) {\\n                    next.add(opA);\\n                    if (min.compareTo(opA) > 0) min = opA;\\n                }\\n                String opB = doOpB(ss, b);\\n                if (!visited.contains(opB)) {\\n                    next.add(opB);\\n                    if (min.compareTo(opB) > 0) min = opB;\\n                }\\n            }\\n            curr = next;\\n        }\\n        return min;\\n    }\\n    \\n    private String doOpA(String s, int a) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for (int i = 1; i < s.length(); i+=2) {\\n            sb.setCharAt(i, (char)(\\'0\\' + (sb.charAt(i)-\\'0\\' + a) % 10));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private String doOpB(String s, int b) {\\n        return s.substring(s.length()-b) + s.substring(0, s.length()-b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String findLexSmallestString(String s, int a, int b) {\\n        String min = s;\\n        Set<String> visited = new HashSet<>(), curr = new HashSet<>();\\n        curr.add(s);\\n\\n        while (!curr.isEmpty()) {\\n            // System.out.println(curr);\\n            Set<String> next = new HashSet<>();\\n            for (String ss : curr) {\\n                visited.add(ss);\\n                String opA = doOpA(ss, a);\\n                if (!visited.contains(opA)) {\\n                    next.add(opA);\\n                    if (min.compareTo(opA) > 0) min = opA;\\n                }\\n                String opB = doOpB(ss, b);\\n                if (!visited.contains(opB)) {\\n                    next.add(opB);\\n                    if (min.compareTo(opB) > 0) min = opB;\\n                }\\n            }\\n            curr = next;\\n        }\\n        return min;\\n    }\\n    \\n    private String doOpA(String s, int a) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for (int i = 1; i < s.length(); i+=2) {\\n            sb.setCharAt(i, (char)(\\'0\\' + (sb.charAt(i)-\\'0\\' + a) % 10));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private String doOpB(String s, int b) {\\n        return s.substring(s.length()-b) + s.substring(0, s.length()-b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025043,
                "title": "dfs-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    string rotatee(string s,int b)\\n    {\\n        \\n        int t=s.length()-b;\\n        while(t--)\\n        {\\n            s.push_back(s[0]);\\n            s.erase(s.begin());\\n            \\n        }\\n        return s;\\n    }\\n    \\n    string addd(string s,int a)\\n    {\\n        int l=s.length();\\n        for(int i=1;i<l;i+=2)\\n        {\\n            s[i]=(((s[i]-\\'0\\')+a)%10)+\\'0\\';\\n        }\\n        return s;\\n    }\\n    \\n    void dfs(string s,set<string> &st,int a,int b)\\n    {\\n     \\n        string r=rotatee(s,b);\\n        string ad=addd(s,a);\\n        \\n            if(st.find(r)==st.end())\\n            {\\n        \\n            st.insert(r);\\n            dfs(r,st,a,b);\\n            }\\n        \\n            if(st.find(ad)==st.end())\\n            {\\n            st.insert(ad);\\n            dfs(ad,st,a,b);\\n            }\\n        \\n    }\\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        set<string> st;\\n        st.insert(s);\\n        \\n        string ans=s;\\n        dfs(s,st,a,b);\\n        \\n\\n        return *st.begin();\\n        \\n        \\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string rotatee(string s,int b)\\n    {\\n        \\n        int t=s.length()-b;\\n        while(t--)\\n        {\\n            s.push_back(s[0]);\\n            s.erase(s.begin());\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1020174,
                "title": "golang-bfs",
                "content": "Golang has no implicit type conversion\\n```\\nfunc findLexSmallestString(s string, a int, b int) string {\\n    m := make(map[string]bool)\\n    b = b % len(s)\\n    res := s\\n    var q []string\\n    q = append(q, s)\\n    for len(q) != 0 {\\n        size := len(q)\\n        for j := 0; j < size; j++ {\\n            s = q[0]\\n            q = q[1:]\\n            str := []byte(s)\\n            for m[string(str)] == false {\\n                m[string(str)] = true\\n                for i := 1; i < len(str); i += 2 {\\n                    str[i] = byte(48) + (str[i] - \\'0\\' + byte(a)) % 10\\n                }\\n                if strings.Compare(string(str), res) == -1 {\\n                    res = string(str)\\n                }\\n                cur := string(str)\\n                q = append(q, cur[len(cur) - b:]+ cur[:len(cur) - b])\\n            }\\n            \\n        }\\n        \\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findLexSmallestString(s string, a int, b int) string {\\n    m := make(map[string]bool)\\n    b = b % len(s)\\n    res := s\\n    var q []string\\n    q = append(q, s)\\n    for len(q) != 0 {\\n        size := len(q)\\n        for j := 0; j < size; j++ {\\n            s = q[0]\\n            q = q[1:]\\n            str := []byte(s)\\n            for m[string(str)] == false {\\n                m[string(str)] = true\\n                for i := 1; i < len(str); i += 2 {\\n                    str[i] = byte(48) + (str[i] - \\'0\\' + byte(a)) % 10\\n                }\\n                if strings.Compare(string(str), res) == -1 {\\n                    res = string(str)\\n                }\\n                cur := string(str)\\n                q = append(q, cur[len(cur) - b:]+ cur[:len(cur) - b])\\n            }\\n            \\n        }\\n        \\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992595,
                "title": "simple-brute-force-dfs-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    \\n    string add(string s, int a){\\n        int n = s.length();\\n        for(int i = 0;i<n;i++){\\n            if(i % 2){\\n                s[i] = (((s[i] - \\'0\\') + a) % 10) + \\'0\\';\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    string rot(string s, int b){\\n        int n = s.length();\\n        string ans = s.substr(n - b) + s.substr(0, n - b);\\n        return ans;\\n    }\\n    \\n    void dfs(string s, int a, int b, set<string>& vis){\\n        if(vis.find(s) != vis.end())    return;\\n        vis.insert(s);\\n        ans = min(ans, s);\\n        dfs(rot(s, b), a, b, vis);\\n        dfs(add(s, a), a, b, vis);\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        ans = s;\\n        set<string> vis;\\n        dfs(s, a, b, vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    \\n    string add(string s, int a){\\n        int n = s.length();\\n        for(int i = 0;i<n;i++){\\n            if(i % 2){\\n                s[i] = (((s[i] - \\'0\\') + a) % 10) + \\'0\\';\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    string rot(string s, int b){\\n        int n = s.length();\\n        string ans = s.substr(n - b) + s.substr(0, n - b);\\n        return ans;\\n    }\\n    \\n    void dfs(string s, int a, int b, set<string>& vis){\\n        if(vis.find(s) != vis.end())    return;\\n        vis.insert(s);\\n        ans = min(ans, s);\\n        dfs(rot(s, b), a, b, vis);\\n        dfs(add(s, a), a, b, vis);\\n    }\\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        ans = s;\\n        set<string> vis;\\n        dfs(s, a, b, vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968332,
                "title": "wrong-test-case-43987654",
                "content": "Why for test case s = \"43987654\", a = 7, b = 3 answer is \"00553311\"? If we can do any operation in any order we can do following operations:\\nAdd: at position: 1, result: 40987654\\nAdd: at position: 3, result: 40957654\\nAdd: at position: 3, result: 40927654\\nAdd: at position: 5, result: 40927354\\nAdd: at position: 5, result: 40927054\\nAdd: at position: 7, result: 40927051\\nRotate: at position: 3, result: 27051409\\nRotate: at position: 6, result: 09270514\\nAdd: at position: 1, result: 06270514\\nAdd: at position: 1, result: 03270514\\nAdd: at position: 1, result: 00270514\\nAdd: at position: 3, result: 00240514\\nAdd: at position: 3, result: 00210514\\nAdd: at position: 5, result: 00210214\\nAdd: at position: 7, result: 00210211\\n\\nWhich gives us answer \"00210211\" which is obviously Lexicographically Smaller String than \"00553311\"?",
                "solutionTags": [],
                "code": "Why for test case s = \"43987654\", a = 7, b = 3 answer is \"00553311\"? If we can do any operation in any order we can do following operations:\\nAdd: at position: 1, result: 40987654\\nAdd: at position: 3, result: 40957654\\nAdd: at position: 3, result: 40927654\\nAdd: at position: 5, result: 40927354\\nAdd: at position: 5, result: 40927054\\nAdd: at position: 7, result: 40927051\\nRotate: at position: 3, result: 27051409\\nRotate: at position: 6, result: 09270514\\nAdd: at position: 1, result: 06270514\\nAdd: at position: 1, result: 03270514\\nAdd: at position: 1, result: 00270514\\nAdd: at position: 3, result: 00240514\\nAdd: at position: 3, result: 00210514\\nAdd: at position: 5, result: 00210214\\nAdd: at position: 7, result: 00210211\\n\\nWhich gives us answer \"00210211\" which is obviously Lexicographically Smaller String than \"00553311\"?",
                "codeTag": "Unknown"
            },
            {
                "id": 943576,
                "title": "simple-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string getA(string s, int a){\\n        \\n        for(int i =0; i<s.length(); i++){\\n            \\n            if(i%2){\\n                \\n                int ch = s[i]-\\'0\\';\\n                ch = (ch+a)%10;\\n                s[i] = ch+\\'0\\';\\n                \\n            }\\n            \\n            \\n        }\\n        \\n       return s; \\n        \\n        \\n        \\n    }\\n    \\n    \\n    string getB(string s, int k){\\n        \\n        reverse(s.begin(),s.end());\\n        reverse(s.begin(),s.begin()+k);\\n        reverse(s.begin()+k,s.end());\\n        return s;\\n        \\n        \\n        \\n        \\n    }\\n\\n    \\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        \\n        set<string> vis;\\n        queue<string> q;\\n        //vector<string> vis;\\n        q.push(s);\\n        \\n        while(!q.empty()){\\n            \\n            string curr = q.front();\\n            q.pop();\\n            \\n            string one = getA(curr,a);\\n            \\n            if(vis.find(one)==vis.end()){\\n                q.push(one);\\n                vis.insert(one);\\n                \\n                \\n            }\\n            \\n             one = getB(curr,b);\\n            \\n            if(vis.find(one)==vis.end()){\\n                q.push(one);\\n                vis.insert(one);\\n                \\n                \\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        \\n        return *vis.begin();\\n        \\n        \\n        \\n        \\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string getA(string s, int a){\\n        \\n        for(int i =0; i<s.length(); i++){\\n            \\n            if(i%2){\\n                \\n                int ch = s[i]-\\'0\\';\\n                ch = (ch+a)%10;\\n                s[i] = ch+\\'0\\';\\n                \\n            }\\n            \\n            \\n        }\\n        \\n       return s; \\n        \\n        \\n        \\n    }\\n    \\n    \\n    string getB(string s, int k){\\n        \\n        reverse(s.begin(),s.end());\\n        reverse(s.begin(),s.begin()+k);\\n        reverse(s.begin()+k,s.end());\\n        return s;\\n        \\n        \\n        \\n        \\n    }\\n\\n    \\n    \\n    string findLexSmallestString(string s, int a, int b) {\\n        \\n        \\n        set<string> vis;\\n        queue<string> q;\\n        //vector<string> vis;\\n        q.push(s);\\n        \\n        while(!q.empty()){\\n            \\n            string curr = q.front();\\n            q.pop();\\n            \\n            string one = getA(curr,a);\\n            \\n            if(vis.find(one)==vis.end()){\\n                q.push(one);\\n                vis.insert(one);\\n                \\n                \\n            }\\n            \\n             one = getB(curr,b);\\n            \\n            if(vis.find(one)==vis.end()){\\n                q.push(one);\\n                vis.insert(one);\\n                \\n                \\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        \\n        return *vis.begin();\\n        \\n        \\n        \\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934561,
                "title": "js-clean-brute-force-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} a\\n * @param {number} b\\n * @return {string}\\n */\\nvar findLexSmallestString = function(s, a, b) {\\n    const map = {};\\n    const rotate = (s) => {\\n        let t = [];\\n        for (let l1=0;l1<s.length;l1++) {\\n            t[(l1+b)%s.length] = s[l1];\\n        }\\n        return t.join(\\'\\');\\n    }\\n    const add = (s) => {\\n        let t = Array.from(s).map(Number);        \\n        t = t.map((el, i) => i%2==1 ? (el+a)%10 : el);        \\n        return t.join(\\'\\');\\n    }\\n    const dfs = (s) => {\\n        if (map[s]) {\\n            return;\\n        }\\n        map[s] = true;\\n        dfs(rotate(s));\\n        dfs(add(s));\\n    }    \\n    dfs(s);    \\n    return Object.keys(map).sort()[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} a\\n * @param {number} b\\n * @return {string}\\n */\\nvar findLexSmallestString = function(s, a, b) {\\n    const map = {};\\n    const rotate = (s) => {\\n        let t = [];\\n        for (let l1=0;l1<s.length;l1++) {\\n            t[(l1+b)%s.length] = s[l1];\\n        }\\n        return t.join(\\'\\');\\n    }\\n    const add = (s) => {\\n        let t = Array.from(s).map(Number);        \\n        t = t.map((el, i) => i%2==1 ? (el+a)%10 : el);        \\n        return t.join(\\'\\');\\n    }\\n    const dfs = (s) => {\\n        if (map[s]) {\\n            return;\\n        }\\n        map[s] = true;\\n        dfs(rotate(s));\\n        dfs(add(s));\\n    }    \\n    dfs(s);    \\n    return Object.keys(map).sort()[0];\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574497,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "I assumed there\\'s unlimited number of outcomes for the string since we can do unlimited operations. Then there\\'s no way to stop the backtrack recursion. That\\'s why I gave up the recursion idea during contest. \\n\\nSo the outcome for such operations are limited? Gonna be some mathmatical logic underlying."
                    },
                    {
                        "username": "Maverick767",
                        "content": "Every operation you do is modulus either the length of the string or the digits 0-9. For example, you can rotate forever but will eventually reach the same starting string after some number of rotations. This is also true for adding a to the digits and arriving at the same digits after x number of additions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force works really great on this question, why BFS?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ianjulo](/ianjulo) ? My python brutal force used 76 ms, which beats 100%."
                    },
                    {
                        "username": "ianjulo",
                        "content": "brutal force? haha"
                    }
                ]
            },
            {
                "id": 1995074,
                "content": [
                    {
                        "username": "nadabao",
                        "content": "I assumed there\\'s unlimited number of outcomes for the string since we can do unlimited operations. Then there\\'s no way to stop the backtrack recursion. That\\'s why I gave up the recursion idea during contest. \\n\\nSo the outcome for such operations are limited? Gonna be some mathmatical logic underlying."
                    },
                    {
                        "username": "Maverick767",
                        "content": "Every operation you do is modulus either the length of the string or the digits 0-9. For example, you can rotate forever but will eventually reach the same starting string after some number of rotations. This is also true for adding a to the digits and arriving at the same digits after x number of additions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "Brutal force works really great on this question, why BFS?"
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ianjulo](/ianjulo) ? My python brutal force used 76 ms, which beats 100%."
                    },
                    {
                        "username": "ianjulo",
                        "content": "brutal force? haha"
                    }
                ]
            }
        ]
    }
]