[
    {
        "title": "Check If Word Is Valid After Substitutions",
        "question_content": "Given a string s, determine if it is valid.\nA string s is valid if, starting with an empty string t = \"\", you can transform t into s after performing the following operation any number of times:\n\n\tInsert string \"abc\" into any position in t. More formally, t becomes tleft + \"abc\" + tright, where t == tleft + tright. Note that tleft and tright may be empty.\n\nReturn true if s is a valid string, otherwise, return false.\n&nbsp;\nExample 1:\n\nInput: s = \"aabcbc\"\nOutput: true\nExplanation:\n\"\" -> \"abc\" -> \"aabcbc\"\nThus, \"aabcbc\" is valid.\nExample 2:\n\nInput: s = \"abcabcababcc\"\nOutput: true\nExplanation:\n\"\" -> \"abc\" -> \"abcabc\" -> \"abcabcabc\" -> \"abcabcababcc\"\nThus, \"abcabcababcc\" is valid.\n\nExample 3:\n\nInput: s = \"abccba\"\nOutput: false\nExplanation: It is impossible to get \"abccba\" using the operation.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 2 * 104\n\ts consists of letters 'a', 'b', and 'c'",
        "solutions": [
            {
                "id": 247626,
                "title": "java-python-c-stack-solution-o-n",
                "content": "## **Solution 1, Brute Force**\\n\\nBrute force using replace will get accepted. Though it\\'s not expected.\\n\\nTime complexity `O(N^2)`, space `O(N^2)` (depending on implementation).\\n**Python**\\n```\\n    def isValid(self, S):\\n        S2 = \"\"\\n        while S != S2:\\n            S, S2 = S.replace(\"abc\", \"\"), S\\n        return S == \"\"\\n```\\n<br>\\n\\n## **Solution 2**\\n\\nKeep a stack, whenever meet `\\'c\\'`,\\npop `a` and `b` at the end of stack.\\nOtherwise return `false`.\\n\\n**Java**\\n```\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'c\\') {\\n                if (stack.isEmpty() || stack.pop() != \\'b\\') return false;\\n                if (stack.isEmpty() || stack.pop() != \\'a\\') return false;\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n```\\n\\n**C++**\\n```\\n    bool isValid(string S) {\\n        vector<char> stack;\\n        for (char c : S) {\\n            if (c == \\'c\\') {\\n                int n = stack.size();\\n                if (n < 2 || stack[n - 1] != \\'b\\' || stack[n - 2] != \\'a\\') return false;\\n                stack.pop_back(), stack.pop_back();\\n            } else {\\n                stack.push_back(c);\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n```\\n\\n**Python**\\n```\\n    def isValid(self, S):\\n        stack = []\\n        for i in S:\\n            if i == \\'c\\':\\n                if stack[-2:] != [\\'a\\', \\'b\\']:\\n                    return False\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return not stack\\n```\\n\\n\\n<br>\\n\\n## **Solution 3,  Accepted Wrong Solution...**\\nOne wrong solution is that check that if `count[a] >= count[b] >= count[c]` always valid.\\nIt\\'s hard for Leetcode to construct all kinds of false positive test cases.\\nOne easy counterexample can be `\"aabbcc\"`, expecting Leetcode to add it later.\\n\\n```\\n    def isValid(self, S):\\n        count = [0, 0, 0]\\n        for i in S:\\n            count[ord(i) - ord(\\'a\\')] += 1\\n            if not count[0] >= count[1] >= count[2]:\\n                return False\\n        return count[0] == count[1] == count[2]\\n```",
                "solutionTags": [],
                "code": "```\\n    def isValid(self, S):\\n        S2 = \"\"\\n        while S != S2:\\n            S, S2 = S.replace(\"abc\", \"\"), S\\n        return S == \"\"\\n```\n```\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'c\\') {\\n                if (stack.isEmpty() || stack.pop() != \\'b\\') return false;\\n                if (stack.isEmpty() || stack.pop() != \\'a\\') return false;\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n```\n```\\n    bool isValid(string S) {\\n        vector<char> stack;\\n        for (char c : S) {\\n            if (c == \\'c\\') {\\n                int n = stack.size();\\n                if (n < 2 || stack[n - 1] != \\'b\\' || stack[n - 2] != \\'a\\') return false;\\n                stack.pop_back(), stack.pop_back();\\n            } else {\\n                stack.push_back(c);\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n```\n```\\n    def isValid(self, S):\\n        stack = []\\n        for i in S:\\n            if i == \\'c\\':\\n                if stack[-2:] != [\\'a\\', \\'b\\']:\\n                    return False\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return not stack\\n```\n```\\n    def isValid(self, S):\\n        count = [0, 0, 0]\\n        for i in S:\\n            count[ord(i) - ord(\\'a\\')] += 1\\n            if not count[0] >= count[1] >= count[2]:\\n                return False\\n        return count[0] == count[1] == count[2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 247548,
                "title": "search-stack-and-2-pointers",
                "content": "**Intuition:** just do the reverse: search for \"abc\" and remove it. The string is valid if we get an empty string in the end.\\n\\n#### Simple Search Solution\\nSearch for substring, remove it, and repeat.\\n\\n**C++**\\n```cpp\\nbool isValid(string S) {\\n  for (auto i = S.find(\"abc\"); i != string::npos; i = S.find(\"abc\"))\\n    S.erase(i, 3);\\n  return S.empty();\\n}\\n```\\n**Complexity Analysis**\\n- Runtime: *O(n * n)*, where n is the number of characters. ```find``` is O(n + 3) and ```erase``` is O(n), and we repeat it n / 3 times.\\n- Memory: *O(n)*.\\n\\n#### Stack\\nWe can use a stack to build the string, removing \"abc\" as we go. This leads to a linear time complexity.\\n\\n**C++**\\n```cpp\\nbool isValid(string s) {\\n    vector<char> st;\\n    for (auto ch : s)\\n        if (ch == \\'c\\' && st.size() > 1 && st.back() == \\'b\\' && st[st.size() - 2] == \\'a\\')\\n            st.resize(st.size() - 2);\\n        else\\n            st.push_back(ch);\\n    return st.empty();\\n}\\n```\\n\\n#### 2 Pointers\\nSimilar to the stack solution, but we use a string and a pointer to build the resulting string.\\n\\n**C++**\\n```cpp\\nbool isValid(string s) {\\n    int j = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (s[i] == \\'c\\' && j > 1 && s[j - 1] == \\'b\\' && s[j - 2] == \\'a\\')\\n            j -= 2;\\n        else\\n            s[j++] = s[i];\\n    }\\n    return j == 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool isValid(string S) {\\n  for (auto i = S.find(\"abc\"); i != string::npos; i = S.find(\"abc\"))\\n    S.erase(i, 3);\\n  return S.empty();\\n}\\n```\n```find```\n```erase```\n```cpp\\nbool isValid(string s) {\\n    vector<char> st;\\n    for (auto ch : s)\\n        if (ch == \\'c\\' && st.size() > 1 && st.back() == \\'b\\' && st[st.size() - 2] == \\'a\\')\\n            st.resize(st.size() - 2);\\n        else\\n            st.push_back(ch);\\n    return st.empty();\\n}\\n```\n```cpp\\nbool isValid(string s) {\\n    int j = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (s[i] == \\'c\\' && j > 1 && s[j - 1] == \\'b\\' && s[j - 2] == \\'a\\')\\n            j -= 2;\\n        else\\n            s[j++] = s[i];\\n    }\\n    return j == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247643,
                "title": "java-3-lines-solution",
                "content": "```\\n    \\tString abc = \"abc\";\\n    \\t\\n    \\twhile(S.contains(abc)) {\\n    \\t\\tS = S.replace(abc, \"\");\\n    \\t}\\n    \\t\\n        return S.isEmpty();\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    \\tString abc = \"abc\";\\n    \\t\\n    \\twhile(S.contains(abc)) {\\n    \\t\\tS = S.replace(abc, \"\");\\n    \\t}\\n    \\t\\n        return S.isEmpty();\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002730,
                "title": "c-short-o-n-time-o-1-space",
                "content": "## Solution 1.\\n\\n`j` is read pointer and `i` is write pointer. We always write `s[j]` to `s[i]`.\\n\\nIf the last 3 characters in front of `i` is `abc`, we clean them by `i -= 3`.\\n\\nIn the end, return `i == 0`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int i = 0, N = s.size();\\n        for (int j = 0; j < N; ++j) {\\n            s[i++] = s[j];\\n            if (i >= 3 && s[i - 3] == \\'a\\' && s[i - 2] == \\'b\\' && s[i - 1] == \\'c\\') i -= 3;\\n        }\\n        return i == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int i = 0, N = s.size();\\n        for (int j = 0; j < N; ++j) {\\n            s[i++] = s[j];\\n            if (i >= 3 && s[i - 3] == \\'a\\' && s[i - 2] == \\'b\\' && s[i - 1] == \\'c\\') i -= 3;\\n        }\\n        return i == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266550,
                "title": "python-stack-o-n-solution-with-explanation",
                "content": "#### Explanation :\\n1. If length of S be less than 3, absolutely it doesn\\'t contains any *\\'abc\\'*\\n2. Create a Stack and call it **Check**.\\n3. If the last three character of **Check** be *\\'abc\\'*, remove them.*(pop, pop, pop)*\\n4. So on.\\n5. if stack be empty, return true otherwise false.\\n\\n#### Example 1 :\\n`Input: \"aabcbc\"`\\n1. Check = [a]\\n2. Check = [a, a]\\n3. Check = [a, a, b]\\n4. Check = [a, **a, b, c**], Remove a,b,c (pop, pop , pop), Then Check = [a]\\n5. Check = [a, b]\\n6. Check = [**a, b, c**], Remove a,b,c (pop, pop , pop), Then Check = []\\n7. Check is Empty, Return `True`.\\n\\n#### Example 2 :\\n`Input: \"abcaba\"`\\n1. Check = [a]\\n2. Check = [a, b]\\n3. Check = [a, **a, b, c**], Remove a,b,c (pop, pop , pop), Then Check = [a]\\n4. Check = [a, b]\\n5. Check = [a, b, a]\\n6. Check is not Empty, Return `False`.\\n\\n#### Code : \\n```\\ndef isValid(self, S: str) -> bool:\\n    if len(S)<3:\\n        return False\\n    check=[]\\n    for c in S:\\n        check.append(c)\\n        if len(check)>=3:\\n            if check[-1]==\\'c\\' and check[-2]==\\'b\\' and check[-3]==\\'a\\': #three last characters be a,b,c\\n                check.pop()\\n                check.pop()\\n                check.pop()\\n    return not check \\'\\'\\'means check == []\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef isValid(self, S: str) -> bool:\\n    if len(S)<3:\\n        return False\\n    check=[]\\n    for c in S:\\n        check.append(c)\\n        if len(check)>=3:\\n            if check[-1]==\\'c\\' and check[-2]==\\'b\\' and check[-3]==\\'a\\': #three last characters be a,b,c\\n                check.pop()\\n                check.pop()\\n                check.pop()\\n    return not check \\'\\'\\'means check == []\\'\\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 263378,
                "title": "java-easy-understanding-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char curr: S.toCharArray()) {\\n            if(curr == \\'a\\'){\\n                stack.push(\\'c\\');\\n                stack.push(\\'b\\');\\n            }else if(stack.isEmpty() || stack.pop() != curr) return false;\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char curr: S.toCharArray()) {\\n            if(curr == \\'a\\'){\\n                stack.push(\\'c\\');\\n                stack.push(\\'b\\');\\n            }else if(stack.isEmpty() || stack.pop() != curr) return false;\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340880,
                "title": "java-92-faster-6-ms-4-lines-of-clean-code",
                "content": "<-----**If you like the solution . Kindly UPvote for better reach**\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while(s.contains(\"abc\"))\\n            s=s.replace(\"abc\",\"\"); \\n\\t\\tif(s.isEmpty())\\n\\t\\t\\treturn true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while(s.contains(\"abc\"))\\n            s=s.replace(\"abc\",\"\"); \\n\\t\\tif(s.isEmpty())\\n\\t\\t\\treturn true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247653,
                "title": "c-easy-short-solution",
                "content": "class Solution {\\npublic:\\n    bool isValid(string S) {\\n        \\n        while(!S.empty())\\n        {\\n            auto posn = S.find( \"abc\" );\\n            if( posn == string::npos )\\n                return 0;\\n            S.erase(posn, 3 );\\n        }\\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(string S) {\\n        \\n        while(!S.empty())\\n        {\\n            auto posn = S.find( \"abc\" );\\n            if( posn == string::npos )\\n                return 0;\\n            S.erase(posn, 3 );\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 700237,
                "title": "simple-c-solution-using-stack-32ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        stack<char>stk ;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'a\\'){\\n                stk.push(S[i]);\\n            }else if(S[i]==\\'b\\'){\\n                if(stk.empty()==true || stk.top()!=\\'a\\')return false;\\n                stk.push(S[i]);   \\n            }else if(S[i]==\\'c\\'){\\n                if(stk.empty() || stk.top()!=\\'b\\')return false;\\n                stk.pop();\\n                if(stk.empty() || stk.top()!=\\'a\\')return false;\\n                stk.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return stk.empty()==true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        stack<char>stk ;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'a\\'){\\n                stk.push(S[i]);\\n            }else if(S[i]==\\'b\\'){\\n                if(stk.empty()==true || stk.top()!=\\'a\\')return false;\\n                stk.push(S[i]);   \\n            }else if(S[i]==\\'c\\'){\\n                if(stk.empty() || stk.top()!=\\'b\\')return false;\\n                stk.pop();\\n                if(stk.empty() || stk.top()!=\\'a\\')return false;\\n                stk.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return stk.empty()==true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651582,
                "title": "o-n-similar-to-parenthesis-solved-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.length()==0)   return true;\\n        if(s.length()%3!=0) return false;   // return false as string must ave equal no of a,b and c\\n        \\n        stack<char> sk;\\n        for(auto i:s)\\n        {\\n            if(i!=\\'c\\')          // if char encountered is not \\'c\\' then push\\n                sk.push(i);\\n            else\\n            {       // once we encounter \\'c\\' we must have preceding  \"ab\"\\n                    // else seq is not valid\\n                if(sk.size()>=2)\\n                {\\n                    if(sk.top()==\\'b\\')       \\n                    {\\n                        sk.pop();\\n                        if(sk.top()==\\'a\\')   // now checking for \\'a\\' to make sequence valid\\n                            sk.pop();\\n                        else\\n                            return false;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return (sk.size()==0) ? true : false;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.length()==0)   return true;\\n        if(s.length()%3!=0) return false;   // return false as string must ave equal no of a,b and c\\n        \\n        stack<char> sk;\\n        for(auto i:s)\\n        {\\n            if(i!=\\'c\\')          // if char encountered is not \\'c\\' then push\\n                sk.push(i);\\n            else\\n            {       // once we encounter \\'c\\' we must have preceding  \"ab\"\\n                    // else seq is not valid\\n                if(sk.size()>=2)\\n                {\\n                    if(sk.top()==\\'b\\')       \\n                    {\\n                        sk.pop();\\n                        if(sk.top()==\\'a\\')   // now checking for \\'a\\' to make sequence valid\\n                            sk.pop();\\n                        else\\n                            return false;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return (sk.size()==0) ? true : false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247546,
                "title": "simple-python-stack-based-solution",
                "content": "Very simple logic. \\nIf you see a \\'c\\', check if there is \\'a\\' and \\'b\\'  in stack.\\n\\n```\\ndef isValid(self, S: str) -> bool:\\n        stack = []\\n        for i in range(len(S)):\\n            if S[i] == \\'c\\':\\n                if not stack or stack.pop() != \\'b\\': return False\\n                if not stack or stack.pop() != \\'a\\': return False\\n            else:\\n                stack.append(S[i])\\n        return len(stack) == 0\\n```",
                "solutionTags": [],
                "code": "```\\ndef isValid(self, S: str) -> bool:\\n        stack = []\\n        for i in range(len(S)):\\n            if S[i] == \\'c\\':\\n                if not stack or stack.pop() != \\'b\\': return False\\n                if not stack or stack.pop() != \\'a\\': return False\\n            else:\\n                stack.append(S[i])\\n        return len(stack) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3067699,
                "title": "java-c-100-solution-using-stack-check-if-word-is-valid-after-substitutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        int n = s.length();\\n        Stack<Character> stk = new Stack<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            stk.push(s.charAt(i));\\n            if(s.charAt(i)==\\'c\\' && stk.size()>=3)\\n            {\\n                char c,b,a;\\n                c = stk.pop();\\n                b = stk.pop();\\n                a = stk.pop();\\n                if(a==\\'a\\' && b==\\'b\\' && c==\\'c\\')\\n                {\\n                    //Ignore\\n                }\\n                else\\n                {\\n                    stk.push(a);\\n                    stk.push(b);\\n                    stk.push(c);\\n                }\\n            }\\n            else if(s.charAt(i)==\\'c\\')\\n                return false;\\n        }\\n        return stk.empty();\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.size();\\n        stack<char> stk;\\n        for(int i=0;i<n;i++)\\n        {\\n            stk.push(s[i]);\\n            if(s[i]==\\'c\\' && stk.size()>=3)\\n            {\\n                char c,b,a;\\n                c = stk.top();\\n                stk.pop();\\n                b = stk.top();\\n                stk.pop();\\n                a = stk.top();\\n                stk.pop();\\n                if(a==\\'a\\' && b==\\'b\\' && c==\\'c\\')\\n                {\\n                    //Ignore\\n                }\\n                else\\n                {\\n                    stk.push(a);\\n                    stk.push(b);\\n                    stk.push(c);\\n                }\\n            }\\n            else if(s[i]==\\'c\\')\\n                return false;\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        int n = s.length();\\n        Stack<Character> stk = new Stack<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            stk.push(s.charAt(i));\\n            if(s.charAt(i)==\\'c\\' && stk.size()>=3)\\n            {\\n                char c,b,a;\\n                c = stk.pop();\\n                b = stk.pop();\\n                a = stk.pop();\\n                if(a==\\'a\\' && b==\\'b\\' && c==\\'c\\')\\n                {\\n                    //Ignore\\n                }\\n                else\\n                {\\n                    stk.push(a);\\n                    stk.push(b);\\n                    stk.push(c);\\n                }\\n            }\\n            else if(s.charAt(i)==\\'c\\')\\n                return false;\\n        }\\n        return stk.empty();\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.size();\\n        stack<char> stk;\\n        for(int i=0;i<n;i++)\\n        {\\n            stk.push(s[i]);\\n            if(s[i]==\\'c\\' && stk.size()>=3)\\n            {\\n                char c,b,a;\\n                c = stk.top();\\n                stk.pop();\\n                b = stk.top();\\n                stk.pop();\\n                a = stk.top();\\n                stk.pop();\\n                if(a==\\'a\\' && b==\\'b\\' && c==\\'c\\')\\n                {\\n                    //Ignore\\n                }\\n                else\\n                {\\n                    stk.push(a);\\n                    stk.push(b);\\n                    stk.push(c);\\n                }\\n            }\\n            else if(s[i]==\\'c\\')\\n                return false;\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830729,
                "title": "easy-c-stack-solution",
                "content": "```\\nbool isValid(string s) {\\n        stack<char> st;\\n        unordered_map<char,int> m;\\n        for(auto it : s){\\n            m[it]++;\\n        }\\n        if(m[\\'a\\']!=m[\\'b\\']) return false;\\n        if(m[\\'a\\']!=m[\\'c\\']) return false;\\n        if(m[\\'b\\']!=m[\\'c\\']) return false;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(!st.empty() and st.top()==\\'a\\' and s[i]==\\'b\\') st.push(s[i]);\\n            else if(!st.empty() and st.top()==\\'b\\' and s[i]==\\'c\\'){\\n                st.pop();\\n                if(!st.empty())\\n                st.pop();\\n            }\\n            else st.push(s[i]);\\n        }\\n        if(st.empty()) return true;\\n        return false;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nbool isValid(string s) {\\n        stack<char> st;\\n        unordered_map<char,int> m;\\n        for(auto it : s){\\n            m[it]++;\\n        }\\n        if(m[\\'a\\']!=m[\\'b\\']) return false;\\n        if(m[\\'a\\']!=m[\\'c\\']) return false;\\n        if(m[\\'b\\']!=m[\\'c\\']) return false;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(!st.empty() and st.top()==\\'a\\' and s[i]==\\'b\\') st.push(s[i]);\\n            else if(!st.empty() and st.top()==\\'b\\' and s[i]==\\'c\\'){\\n                st.pop();\\n                if(!st.empty())\\n                st.pop();\\n            }\\n            else st.push(s[i]);\\n        }\\n        if(st.empty()) return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1198831,
                "title": "python3-using-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef isValid(self, s: str) -> bool:\\n\\t\\t\"\"\"\\n\\t\\tWe can consider this problem as a valid parenthesis, \\n\\t\\twhere for every \\'a\\' there must be \\'b\\' and for every \\'b\\' there must be \\'c\\'.\\n\\t\\tWe can use stack to track the elements.\\n\\t\\t\"\"\"\\n\\t\\t\\t# the  first ch must be \\'a\\' and last ch must be \\'c\\'\\n\\t\\t\\tif s[0] != \\'a\\' or s[-1]!=\\'c\\':\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tstack = []\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tch = s[i]\\n\\t\\t\\t\\t# if ch is \\'a\\' or \\'b\\' then simply append it into the stack\\n\\t\\t\\t\\tif ch == \\'a\\' or ch == \\'b\\':\\n\\t\\t\\t\\t\\tstack.append(ch)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t# this means if ch is \\'c\\' then there must be \\'b\\' on the top of the stack\\n\\t\\t\\t\\t\\tif len(stack)==0 or stack[-1]!=\\'b\\':\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# there must be \\'a\\' on the top of the stack after popping out \\'b\\'\\n\\t\\t\\t\\t\\tif len(stack) == 0 or stack[-1]!=\\'a\\':\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t# if the string is valid, the stack must be empty in the end\\n\\t\\t\\treturn len(stack) == 0\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isValid(self, s: str) -> bool:\\n\\t\\t\"\"\"\\n\\t\\tWe can consider this problem as a valid parenthesis, \\n\\t\\twhere for every \\'a\\' there must be \\'b\\' and for every \\'b\\' there must be \\'c\\'.\\n\\t\\tWe can use stack to track the elements.\\n\\t\\t\"\"\"\\n\\t\\t\\t# the  first ch must be \\'a\\' and last ch must be \\'c\\'\\n\\t\\t\\tif s[0] != \\'a\\' or s[-1]!=\\'c\\':\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tstack = []\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tch = s[i]\\n\\t\\t\\t\\t# if ch is \\'a\\' or \\'b\\' then simply append it into the stack\\n\\t\\t\\t\\tif ch == \\'a\\' or ch == \\'b\\':\\n\\t\\t\\t\\t\\tstack.append(ch)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t# this means if ch is \\'c\\' then there must be \\'b\\' on the top of the stack\\n\\t\\t\\t\\t\\tif len(stack)==0 or stack[-1]!=\\'b\\':\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# there must be \\'a\\' on the top of the stack after popping out \\'b\\'\\n\\t\\t\\t\\t\\tif len(stack) == 0 or stack[-1]!=\\'a\\':\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t# if the string is valid, the stack must be empty in the end\\n\\t\\t\\treturn len(stack) == 0\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1191183,
                "title": "94-faster-java-2-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while (s.contains(\"abc\")) s = s.replace(\"abc\", \"\");\\n        return s.equals(\"\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while (s.contains(\"abc\")) s = s.replace(\"abc\", \"\");\\n        return s.equals(\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778791,
                "title": "short-iterative-python-o-n-stack-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stack = []\\n        for ch in S:\\n            if ch == \\'c\\':\\n                if len(stack) < 2 or stack.pop() != \\'b\\' or stack.pop() != \\'a\\':\\n                    return False\\n            else:\\n                stack.append(ch)\\n        \\n        return not stack\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stack = []\\n        for ch in S:\\n            if ch == \\'c\\':\\n                if len(stack) < 2 or stack.pop() != \\'b\\' or stack.pop() != \\'a\\':\\n                    return False\\n            else:\\n                stack.append(ch)\\n        \\n        return not stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447844,
                "title": "3-lines-java-solution-use-recursion",
                "content": "```\\npublic boolean isValid(String S) {\\n        if (S.isEmpty()) return true;\\n        if (!S.contains(\"abc\")) return false;\\n        return isValid(S.replace(\"abc\", \"\"));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String S) {\\n        if (S.isEmpty()) return true;\\n        if (!S.contains(\"abc\")) return false;\\n        return isValid(S.replace(\"abc\", \"\"));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250085,
                "title": "java-o-n-time-o-1-space",
                "content": "Hi, this is a combination of counting occurrences of characters, and not allowing certain characters to appear after others. For example, it is simple to deduce that \"b\" can never appear after another \"b\", and \"c\" can never appear after an \"a\". \\n\\nSo we scan first to check for wrong occurrences, and then we scan again to count the occurrences of each character. In the second loop, we are careful not to have more \"b\\'s\" than \"a\\'s\" or more \"c\\'s\" than \"b\\'s\". \\n\\n````\\nclass Solution {\\n    public boolean isValid(String S) {\\n        int[] abc = new int[3];\\n        if(S.length() < 3) return false;\\n        char f = S.charAt(0);\\n        for(int i = 1; i < S.length(); i++){\\n            if(f == \\'a\\'){\\n                if(S.charAt(i) == \\'c\\') return false;\\n            }\\n            else if(f == \\'b\\'){\\n                if(S.charAt(i) == \\'b\\') return false;\\n            }\\n            f = S.charAt(i);\\n        }\\n        for(int i = 0; i < S.length(); i++){\\n            char c = S.charAt(i);\\n            if(c == \\'a\\'){\\n                abc[0]++;\\n            }\\n            if(c == \\'b\\'){\\n                if(abc[1] >= abc[0]) return false;\\n                abc[1]++;\\n            }\\n            if(c == \\'c\\'){\\n                if(abc[2] >= abc[1]) return false;\\n                abc[2]++;\\n            }\\n        }\\n        \\n        return abc[0] == abc[1] && abc[1] == abc[2];\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public boolean isValid(String S) {\\n        int[] abc = new int[3];\\n        if(S.length() < 3) return false;\\n        char f = S.charAt(0);\\n        for(int i = 1; i < S.length(); i++){\\n            if(f == \\'a\\'){\\n                if(S.charAt(i) == \\'c\\') return false;\\n            }\\n            else if(f == \\'b\\'){\\n                if(S.charAt(i) == \\'b\\') return false;\\n            }\\n            f = S.charAt(i);\\n        }\\n        for(int i = 0; i < S.length(); i++){\\n            char c = S.charAt(i);\\n            if(c == \\'a\\'){\\n                abc[0]++;\\n            }\\n            if(c == \\'b\\'){\\n                if(abc[1] >= abc[0]) return false;\\n                abc[1]++;\\n            }\\n            if(c == \\'c\\'){\\n                if(abc[2] >= abc[1]) return false;\\n                abc[2]++;\\n            }\\n        }\\n        \\n        return abc[0] == abc[1] && abc[1] == abc[2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892010,
                "title": "cpp-must-see-very-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) \\n\\t{\\n       stack<char>stk;\\n\\t   int idx = 0;\\n\\t   \\n\\t   while(idx < s.length())\\n\\t   {\\n\\t       char ch = s[idx];\\n           \\n           if(ch == \\'a\\')\\n           { \\n           \\t   stk.push(ch);\\n\\t\\t   }\\n\\t\\t   else if(ch == \\'b\\')\\n\\t\\t   {\\n\\t\\t   \\t   stk.push(ch);\\n\\t\\t   }\\n\\t\\t   else if(ch == \\'c\\')\\n\\t\\t   {\\n\\t\\t   \\t    if(stk.size() >= 2)\\n\\t\\t   \\t    {\\n\\t\\t   \\t         char ch2 = stk.top();\\n\\t\\t   \\t         stk.pop();\\n\\t\\t\\t\\t\\t char ch1 = stk.top();\\t\\n\\t\\t\\t\\t\\t stk.pop();\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t if(!(ch1==\\'a\\' and ch2==\\'b\\' and ch==\\'c\\'))\\n\\t\\t\\t\\t\\t {\\n\\t\\t\\t\\t\\t \\t stk.push(ch1);\\n\\t\\t\\t\\t\\t \\t stk.push(ch2);\\n\\t\\t\\t\\t\\t \\t stk.push(ch);\\n\\t\\t\\t\\t\\t }\\n\\t\\t        } \\n\\t\\t   }\\n\\t\\t   idx++;\\n\\t   }    \\n\\t   if(stk.empty()==true and idx>=s.length())\\n\\t   return true;\\n\\t   \\n\\t   return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) \\n\\t{\\n       stack<char>stk;\\n\\t   int idx = 0;\\n\\t   \\n\\t   while(idx < s.length())\\n\\t   {\\n\\t       char ch = s[idx];\\n           \\n           if(ch == \\'a\\')\\n           { \\n           \\t   stk.push(ch);\\n\\t\\t   }\\n\\t\\t   else if(ch == \\'b\\')\\n\\t\\t   {\\n\\t\\t   \\t   stk.push(ch);\\n\\t\\t   }\\n\\t\\t   else if(ch == \\'c\\')\\n\\t\\t   {\\n\\t\\t   \\t    if(stk.size() >= 2)\\n\\t\\t   \\t    {\\n\\t\\t   \\t         char ch2 = stk.top();\\n\\t\\t   \\t         stk.pop();\\n\\t\\t\\t\\t\\t char ch1 = stk.top();\\t\\n\\t\\t\\t\\t\\t stk.pop();\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t if(!(ch1==\\'a\\' and ch2==\\'b\\' and ch==\\'c\\'))\\n\\t\\t\\t\\t\\t {\\n\\t\\t\\t\\t\\t \\t stk.push(ch1);\\n\\t\\t\\t\\t\\t \\t stk.push(ch2);\\n\\t\\t\\t\\t\\t \\t stk.push(ch);\\n\\t\\t\\t\\t\\t }\\n\\t\\t        } \\n\\t\\t   }\\n\\t\\t   idx++;\\n\\t   }    \\n\\t   if(stk.empty()==true and idx>=s.length())\\n\\t   return true;\\n\\t   \\n\\t   return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653460,
                "title": "c-easy-to-understand-detailed",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool isValid(string S) {\\n        vector<char> stack;\\n        for (char c : S) {\\n            if (c == \\'c\\') {\\n                int n = stack.size();\\n                if (n < 2 || stack[n - 1] != \\'b\\' || stack[n - 2] != \\'a\\') return false;\\n                stack.pop_back(), stack.pop_back();\\n            } else {\\n                stack.push_back(c);\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isValid(string S) {\\n        vector<char> stack;\\n        for (char c : S) {\\n            if (c == \\'c\\') {\\n                int n = stack.size();\\n                if (n < 2 || stack[n - 1] != \\'b\\' || stack[n - 2] != \\'a\\') return false;\\n                stack.pop_back(), stack.pop_back();\\n            } else {\\n                stack.push_back(c);\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276513,
                "title": "java-o-n-solution",
                "content": "In this approach we are simply checking character by character,\\n* if character is not \\'c\\' simply push it in the stack.\\n* if the character is \\'c\\'  and stack\\'s top most element is \\'b\\' pop it and then check if the top most element now is \\'a\\' if so pop it.\\n\\nsimply after completely checking the string character by character, and popping out \\'b\\' then \\'a\\' (whenever \\'c\\' comes,) we are able to pop out all \\'abc\\'s, now we will check if the stack is empty or not, well it should be if the word is valid because, we popped out all the \\'abc\\'s so anything remaining in the stack is a clear indication that something is there which is making the string invalid, so return true if stack is empty otherwise false.\\n\\nNote: Refer the code below after reading above approach for better understanding.\\n\\n```class Solution {\\n    public boolean isValid(String s) {\\n        \\n        \\n           Stack<Character> st = new Stack<>();\\n    \\n    for(int i=0;i<s.length();i++){\\n        \\n        char ch = s.charAt(i);\\n        \\n        if(ch == \\'a\\' || ch == \\'b\\'){\\n            st.push(ch);\\n        }\\n        else{\\n                \\n                if(st.size()>0 && st.peek() == \\'b\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n                if(st.size()>0 && st.peek()==\\'a\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n        }\\n        \\n    }\\n        \\nif(st.size()==0){\\n    return true;\\n}\\n    return false;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```class Solution {\\n    public boolean isValid(String s) {\\n        \\n        \\n           Stack<Character> st = new Stack<>();\\n    \\n    for(int i=0;i<s.length();i++){\\n        \\n        char ch = s.charAt(i);\\n        \\n        if(ch == \\'a\\' || ch == \\'b\\'){\\n            st.push(ch);\\n        }\\n        else{\\n                \\n                if(st.size()>0 && st.peek() == \\'b\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n                if(st.size()>0 && st.peek()==\\'a\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n        }\\n        \\n    }\\n        \\nif(st.size()==0){\\n    return true;\\n}\\n    return false;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 937857,
                "title": "easy-to-understand-c-solution-18-fast-beginner-friendly",
                "content": "The idea behind this solution is to check for the substring \"abc\" and erase when found. If there is a leftover string that cannot fit into a component \"abc\", we know that the string cannot be formed with the given rules. \\n\\nAn optimisation is added to increasing runtime with this method. \\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0]!=\\'a\\'||s.size()%3!=0){//Quick and easy optimisation, check if the whole string starts with \\'a\\', and if the length is a multiple of 3.\\n            return false;\\n        }\\n        string phrase=\"abc\";\\n        while(!s.empty()){\\n            int start_point=s.find(\"abc\");\\n            if(start_point==string::npos){\\n                if(!s.empty()){\\n                    return false;\\n                }\\n            }\\n            else{\\n                s.erase(start_point,3);\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0]!=\\'a\\'||s.size()%3!=0){//Quick and easy optimisation, check if the whole string starts with \\'a\\', and if the length is a multiple of 3.\\n            return false;\\n        }\\n        string phrase=\"abc\";\\n        while(!s.empty()){\\n            int start_point=s.find(\"abc\");\\n            if(start_point==string::npos){\\n                if(!s.empty()){\\n                    return false;\\n                }\\n            }\\n            else{\\n                s.erase(start_point,3);\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651234,
                "title": "one-line-java-solution",
                "content": "```return S.isEmpty()|| (S.contains(\"abc\") && isValid(S.replaceAll(\"abc\",\"\")));```",
                "solutionTags": [],
                "code": "```return S.isEmpty()|| (S.contains(\"abc\") && isValid(S.replaceAll(\"abc\",\"\")));```",
                "codeTag": "Unknown"
            },
            {
                "id": 362940,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String S) {// \\u6BCF\\u6B21\\u628Aabc\\u66FF\\u6362\\u6389\\uFF0C\\u53EA\\u8981\\u770B\\u6700\\u7EC8\\u662F\\u4E0D\\u662F\\u7A7A\\u5C31\\u884C\\n        if (S.equals(\"\"))\\n\\t\\t\\treturn true;\\n\\t\\telse {\\n\\t\\t\\tif (S.contains(\"abc\")) {\\n\\t\\t\\t\\tS = S.replace(\"abc\", \"\");\\n\\t\\t\\t\\treturn isValid(S);\\n\\t\\t\\t} else\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {// \\u6BCF\\u6B21\\u628Aabc\\u66FF\\u6362\\u6389\\uFF0C\\u53EA\\u8981\\u770B\\u6700\\u7EC8\\u662F\\u4E0D\\u662F\\u7A7A\\u5C31\\u884C\\n        if (S.equals(\"\"))\\n\\t\\t\\treturn true;\\n\\t\\telse {\\n\\t\\t\\tif (S.contains(\"abc\")) {\\n\\t\\t\\t\\tS = S.replace(\"abc\", \"\");\\n\\t\\t\\t\\treturn isValid(S);\\n\\t\\t\\t} else\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247569,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        A = [\\'abc\\' * i for i in range(6667)]\\n        if S in A:\\n            return True\\n        while len(S)>3:\\n            if \\'abc\\' in S:\\n                S = S.replace(\\'abc\\',\\'\\')\\n            else:\\n                return False\\n        if S == \\'abc\\':\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        A = [\\'abc\\' * i for i in range(6667)]\\n        if S in A:\\n            return True\\n        while len(S)>3:\\n            if \\'abc\\' in S:\\n                S = S.replace(\\'abc\\',\\'\\')\\n            else:\\n                return False\\n        if S == \\'abc\\':\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886246,
                "title": "stack-valid-parentheses-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a **Stack** to Solve This Problem. This Problem is Exactly **Same as Valid Parenthesis**.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<string> st;\\n        for(int i = 0;i<s.size();i++)\\n        {   \\n            string str(1,s[i]);\\n            if(st.empty()) st.push(str);\\n            else\\n            {\\n                string tmp = st.top();\\n                if(s[i]-tmp[tmp.size()-1]==1)\\n                {\\n                   st.pop();\\n                   tmp+=s[i]; \\n                   if(tmp.size()<3) st.push(tmp);\\n                } \\n                else st.push(str);\\n            }\\n        }\\n        return st.size()==0;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/923dbf6a-8105-4923-a6d7-1e83b9ff7202_1691585643.2219536.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<string> st;\\n        for(int i = 0;i<s.size();i++)\\n        {   \\n            string str(1,s[i]);\\n            if(st.empty()) st.push(str);\\n            else\\n            {\\n                string tmp = st.top();\\n                if(s[i]-tmp[tmp.size()-1]==1)\\n                {\\n                   st.pop();\\n                   tmp+=s[i]; \\n                   if(tmp.size()<3) st.push(tmp);\\n                } \\n                else st.push(str);\\n            }\\n        }\\n        return st.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072025,
                "title": "js-t-100-s-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar isValid = function (s) {\\n  while (s.length) {\\n    if (s.indexOf(\"abc\") === -1) break;\\n    s = s.replaceAll(\"abc\", \"\");\\n  }\\n  return !s.length;\\n};\\n\\n```\\n\\n![1.jpg](https://assets.leetcode.com/users/images/1420e185-6a39-4562-bae9-f43367ef5587_1674118852.2081017.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function (s) {\\n  while (s.length) {\\n    if (s.indexOf(\"abc\") === -1) break;\\n    s = s.replaceAll(\"abc\", \"\");\\n  }\\n  return !s.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069665,
                "title": "7ms-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to determine if a given string s is valid, where a valid string is one in which c can only be present if it is immediately preceded by b and b is immediately preceded by a. My first thoughts would be to use a stack data structure to keep track of the characters in the string and check if the conditions are met.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is to iterate through the characters in the string and for each character, if the current character is c, I will check if the stack has at least two elements and the top element is b, and if so, I will pop b and check if the new top element is a. If it is not, the string is not valid. If the current character is not c, I will push it onto the stack. After iterating through the string, I will check if the stack is empty and return True if it is, indicating that the string is valid. Otherwise, I will return False.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for (char c : s) {\\n            if (c == \\'c\\') {\\n                if (st.size() < 2 || st.top() != \\'b\\') return false;\\n                st.pop();\\n                if (st.top() != \\'a\\') return false;\\n                st.pop();\\n            } else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for (char c : s) {\\n            if (c == \\'c\\') {\\n                if (st.size() < 2 || st.top() != \\'b\\') return false;\\n                st.pop();\\n                if (st.top() != \\'a\\') return false;\\n                st.pop();\\n            } else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658673,
                "title": "java-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n            public boolean isValid(String s) {\\n        // Stack<Character> stack = new Stack<>();\\n        // for (char c: s.toCharArray()) {\\n        //     if (c == \\'c\\') {\\n        //         if (stack.isEmpty() || stack.pop() != \\'b\\') return false;\\n        //         if (stack.isEmpty() || stack.pop() != \\'a\\') return false;\\n        //     } else {\\n        //         stack.push(c);\\n        //     }\\n        // }\\n        // return stack.isEmpty();\\n        while(s.contains(\"abc\"))s=s.replace(\"abc\",\"\");\\n        return s==\"\";\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n            public boolean isValid(String s) {\\n        // Stack<Character> stack = new Stack<>();\\n        // for (char c: s.toCharArray()) {\\n        //     if (c == \\'c\\') {\\n        //         if (stack.isEmpty() || stack.pop() != \\'b\\') return false;\\n        //         if (stack.isEmpty() || stack.pop() != \\'a\\') return false;\\n        //     } else {\\n        //         stack.push(c);\\n        //     }\\n        // }\\n        // return stack.isEmpty();\\n        while(s.contains(\"abc\"))s=s.replace(\"abc\",\"\");\\n        return s==\"\";\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238315,
                "title": "easy-simple-stack-and-string-replace-approaches",
                "content": "### Without Stack Approach\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        incomplete = True\\n        \\n        while incomplete:\\n            if \\'abc\\' in s:\\n                s= s.replace(\\'abc\\',\\'\\')\\n            else:\\n                incomplete = False\\n        \\n        return s == \\'\\'\\n```\\n\\n### With Stack Approach\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        \\n        for i in s:\\n            if i == \\'c\\' and len(stack) >= 2 and stack[-1] == \\'b\\' and stack[-2] == \\'a\\':\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        \\n        if \\'\\'.join(stack) == \\'abc\\': stack = []\\n            \\n        return stack == []\\n```                \\n**Please upvote if this helped! :)**\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        incomplete = True\\n        \\n        while incomplete:\\n            if \\'abc\\' in s:\\n                s= s.replace(\\'abc\\',\\'\\')\\n            else:\\n                incomplete = False\\n        \\n        return s == \\'\\'\\n```\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        \\n        for i in s:\\n            if i == \\'c\\' and len(stack) >= 2 and stack[-1] == \\'b\\' and stack[-2] == \\'a\\':\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        \\n        if \\'\\'.join(stack) == \\'abc\\': stack = []\\n            \\n        return stack == []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344384,
                "title": "java-92-faster-3-lines-of-code",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while (s.contains(\"abc\"))\\n            s = s.replace(\"abc\", \"\");\\n        return s.length() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while (s.contains(\"abc\"))\\n            s = s.replace(\"abc\", \"\");\\n        return s.length() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291378,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack=[]\\n        for i in s:\\n            if i == \\'a\\':stack.append(i)\\n            elif i==\\'b\\':\\n                if not stack:return False\\n                else:\\n                    if stack[-1]==\\'a\\':stack.pop()\\n                    else:return False\\n                    stack.append(i)\\n            else:\\n                if not stack:return False\\n                else:\\n                    if stack[-1]==\\'b\\':stack.pop()\\n                    else:return False\\n\\n        return len(stack)==0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack=[]\\n        for i in s:\\n            if i == \\'a\\':stack.append(i)\\n            elif i==\\'b\\':\\n                if not stack:return False\\n                else:\\n                    if stack[-1]==\\'a\\':stack.pop()\\n                    else:return False\\n                    stack.append(i)\\n            else:\\n                if not stack:return False\\n                else:\\n                    if stack[-1]==\\'b\\':stack.pop()\\n                    else:return False\\n\\n        return len(stack)==0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220206,
                "title": "c-simple-o-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        ios_base::sync_with_stdio(false);\\t\\n        cin.tie(NULL);\\t\\n        stack<char> valid;\\n        for (auto ele: s){\\n            if (ele==\\'a\\')\\n                valid.push(ele);\\n            else if(ele==\\'b\\' && !valid.empty() && valid.top()==\\'a\\'){\\n                valid.pop();\\n                valid.push(ele);\\n            }\\n            else if(ele==\\'c\\' && !valid.empty() && valid.top()==\\'b\\')\\n                valid.pop();\\n            else\\n                return false;\\n        }\\n        return valid.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        ios_base::sync_with_stdio(false);\\t\\n        cin.tie(NULL);\\t\\n        stack<char> valid;\\n        for (auto ele: s){\\n            if (ele==\\'a\\')\\n                valid.push(ele);\\n            else if(ele==\\'b\\' && !valid.empty() && valid.top()==\\'a\\'){\\n                valid.pop();\\n                valid.push(ele);\\n            }\\n            else if(ele==\\'c\\' && !valid.empty() && valid.top()==\\'b\\')\\n                valid.pop();\\n            else\\n                return false;\\n        }\\n        return valid.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155359,
                "title": "java-string",
                "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t\\n        while(s.length()!=0)\\n        {\\n            if(s.contains(\"abc\"))\\n                s=s.replace(\"abc\",\"\");\\n            else \\n                return false;       \\n        }\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n\\t\\n        while(s.length()!=0)\\n        {\\n            if(s.contains(\"abc\"))\\n                s=s.replace(\"abc\",\"\");\\n            else \\n                return false;       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1009739,
                "title": "c-3-solutions-vector-read-write-pointer-stack",
                "content": "### Vector Solution is the Fastest\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      vector<char> v;\\n      for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'c\\'){\\n          int sz = v.size();\\n          if(sz<2 || v[sz-2]!=\\'a\\' || v[sz-1]!=\\'b\\') return false;\\n          v.pop_back();\\n          v.pop_back();\\n        }else{\\n          v.push_back(s[i]);\\n        }\\n      }\\n      return v.size()==0;\\n        \\n    }\\n};\\n```\\n\\n\\n### Read and Write Pointer is faster\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      int i = 0, N = s.size();\\n        for (int j = 0; j < N; ++j) {\\n            s[i++] = s[j];\\n            if (i >= 3 && s[i - 3] == \\'a\\' && s[i - 2] == \\'b\\' && s[i - 1] == \\'c\\') i -= 3;\\n        }\\n        return i == 0;\\n    }\\n};\\n```\\n\\n \\n ### Stack is Slow compared to Vector & Pointer Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      stack<char> Stack;\\n      for(int i = 0; i< s.size(); i++){\\n        if(s[i]==\\'c\\'){\\n          if(Stack.empty() || Stack.top()!=\\'b\\') return false;\\n          Stack.pop();\\n          if(Stack.empty() || Stack.top()!=\\'a\\') return false;\\n          Stack.pop();\\n        }else{\\n          Stack.push(s[i]);\\n        }\\n      }\\n      return Stack.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      vector<char> v;\\n      for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'c\\'){\\n          int sz = v.size();\\n          if(sz<2 || v[sz-2]!=\\'a\\' || v[sz-1]!=\\'b\\') return false;\\n          v.pop_back();\\n          v.pop_back();\\n        }else{\\n          v.push_back(s[i]);\\n        }\\n      }\\n      return v.size()==0;\\n        \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      int i = 0, N = s.size();\\n        for (int j = 0; j < N; ++j) {\\n            s[i++] = s[j];\\n            if (i >= 3 && s[i - 3] == \\'a\\' && s[i - 2] == \\'b\\' && s[i - 1] == \\'c\\') i -= 3;\\n        }\\n        return i == 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      stack<char> Stack;\\n      for(int i = 0; i< s.size(); i++){\\n        if(s[i]==\\'c\\'){\\n          if(Stack.empty() || Stack.top()!=\\'b\\') return false;\\n          Stack.pop();\\n          if(Stack.empty() || Stack.top()!=\\'a\\') return false;\\n          Stack.pop();\\n        }else{\\n          Stack.push(s[i]);\\n        }\\n      }\\n      return Stack.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945165,
                "title": "simple-java-solution",
                "content": "As per the question the stating of the string is always a empty string .\\nSo in the input string every time we encounter a \"abc\" replace it with a \"\" .\\nSo at the end if it is a empty the result is true else false.\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        String check = \"abc\";\\n        while(s.contains(check))\\n            s = s.replace(check,\"\"); \\n        return s.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        String check = \"abc\";\\n        while(s.contains(check))\\n            s = s.replace(check,\"\"); \\n        return s.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845895,
                "title": "java-stack-but-bad-question",
                "content": "Although there are a lot of passed solution using, for example, stack. I don\\'t think it is clear.\\nNo statement in the problem shows that a + str + b + str + c is a valid string.\\nSee my second solution for excluding this case;\\nref from [@lee215](https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/discuss/247626/JavaPythonC%2B%2B-Stack-Solution-O(N)).\\n```\\n\\t\\tStack<Character> st = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'c\\') {\\n                if (st.isEmpty() || st.pop() != \\'b\\') return false;\\n                if (st.isEmpty() || st.pop() != \\'a\\') return false;\\n            } else st.push(c);\\n        }\\n        return st.isEmpty();\\n```\\n\\n2nd: (not pass)\\n```\\n    public boolean isValid(String s) {\\n        int len = s.length();\\n        if (len % 3 != 0) return false; \\n        if (len == 0) return true;\\n        if (len == 3) return s.equals(\"abc\");\\n        if (s.substring(0, 3).equals(\"abc\") && isValid(s.substring(3))) return true;\\n        if (s.substring(len - 3).equals(\"abc\") && isValid(s.substring(0, len - 3))) return true;\\n        if (s.substring(0, 1).equals(\"a\") && s.substring(len - 2).equals(\"bc\") && isValid(s.substring(1, len - 2))) return true;\\n        if (s.substring(0, 2).equals(\"ab\") && s.substring(len - 1).equals(\"c\") && isValid(s.substring(2, len - 1))) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tStack<Character> st = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'c\\') {\\n                if (st.isEmpty() || st.pop() != \\'b\\') return false;\\n                if (st.isEmpty() || st.pop() != \\'a\\') return false;\\n            } else st.push(c);\\n        }\\n        return st.isEmpty();\\n```\n```\\n    public boolean isValid(String s) {\\n        int len = s.length();\\n        if (len % 3 != 0) return false; \\n        if (len == 0) return true;\\n        if (len == 3) return s.equals(\"abc\");\\n        if (s.substring(0, 3).equals(\"abc\") && isValid(s.substring(3))) return true;\\n        if (s.substring(len - 3).equals(\"abc\") && isValid(s.substring(0, len - 3))) return true;\\n        if (s.substring(0, 1).equals(\"a\") && s.substring(len - 2).equals(\"bc\") && isValid(s.substring(1, len - 2))) return true;\\n        if (s.substring(0, 2).equals(\"ab\") && s.substring(len - 1).equals(\"c\") && isValid(s.substring(2, len - 1))) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571352,
                "title": "simple-c-code-using-stack",
                "content": "```\\nbool isValid(string S) {\\n\\tstring t;\\n\\tfor (int i = 0; i < S.length(); ++i) {\\n\\t\\tt.push_back(S[i]);\\n\\t\\twhile (t.size() >= 3 && t.back() == \\'c\\' && t[t.size() - 2] == \\'b\\' && t[t.size() - 3] == \\'a\\') {\\n\\t\\t\\tt.pop_back();\\n\\t\\t\\tt.pop_back();\\n\\t\\t\\tt.pop_back();\\n\\t\\t}\\n\\t}\\n\\treturn (bool)(!t.size());\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nbool isValid(string S) {\\n\\tstring t;\\n\\tfor (int i = 0; i < S.length(); ++i) {\\n\\t\\tt.push_back(S[i]);\\n\\t\\twhile (t.size() >= 3 && t.back() == \\'c\\' && t[t.size() - 2] == \\'b\\' && t[t.size() - 3] == \\'a\\') {\\n\\t\\t\\tt.pop_back();\\n\\t\\t\\tt.pop_back();\\n\\t\\t\\tt.pop_back();\\n\\t\\t}\\n\\t}\\n\\treturn (bool)(!t.size());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491793,
                "title": "swift-stack-solution-o-n",
                "content": "```\\nclass Solution {\\n    func isValid(_ S: String) -> Bool {\\n        var stack:[Character] = []\\n        for item in S{\\n            if item == \"c\"{\\n                let prev2 = stack.popLast()\\n                let prev1 = stack.popLast()\\n                if prev1 == \"a\" && prev2 == \"b\"{\\n                    continue\\n                }else{\\n                    return false\\n                }\\n            }else{\\n                stack.append(item)\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    func isValid(_ S: String) -> Bool {\\n        var stack:[Character] = []\\n        for item in S{\\n            if item == \"c\"{\\n                let prev2 = stack.popLast()\\n                let prev1 = stack.popLast()\\n                if prev1 == \"a\" && prev2 == \"b\"{\\n                    continue\\n                }else{\\n                    return false\\n                }\\n            }else{\\n                stack.append(item)\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428162,
                "title": "java-6ms-o-n-stack-based-solution-easy-5-liner-with-comments",
                "content": "Intuition: We work in reverse and delete all the \\'abc\\' occurances recursively(using a stack here). If we are left with nothing in the end after removing all such occurances we return true else false.\\t\\n\\t\\n\\tclass Solution {\\n    public boolean isValid(String S) {\\n        char[]stk=new char[S.length()]; int top=-1;\\n        char[] arr=S.toCharArray();\\n        \\n        for(int i=0;i<arr.length;i++)\\n\\t\\t/* if current character is \\'c\\' and we have \\'a\\' & \\'b\\' on top of the stack, move top two places before to forget/dump this \\'abc\\' occurance*/\\n            if(arr[i]==\\'c\\' && top>0 && stk[top]==\\'b\\' && stk[top-1]==\\'a\\')    \\n                top-=2;\\n            else   \\n                stk[++top]=arr[i]; \\n\\n        return top==-1;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValid(String S) {\\n        char[]stk=new char[S.length()]; int top=-1;\\n        char[] arr=S.toCharArray();\\n        \\n        for(int i=0;i<arr.length;i++)\\n\\t\\t/* if current character is \\'c\\' and we have \\'a\\' & \\'b\\' on top of the stack, move top two places before to forget/dump this \\'abc\\' occurance*/\\n            if(arr[i]==\\'c\\' && top>0 && stk[top]==\\'b\\' && stk[top-1]==\\'a\\')    \\n                top-=2;\\n            else   \\n                stk[++top]=arr[i]; \\n\\n        return top==-1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 424502,
                "title": "python-100-fast-100-memory",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        n = len(S)\\n        if n%3 or S[0]==\\'b\\' or S[0]==\\'c\\' or S[n-1]==\\'a\\' or S[n-1]==\\'b\\':\\n            return False\\n        if \\'ac\\' in S or \\'bb\\' in S:\\n            return False   \\n        return S.count(\\'a\\')==S.count(\\'b\\') and S.count(\\'b\\')==S.count(\\'c\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        n = len(S)\\n        if n%3 or S[0]==\\'b\\' or S[0]==\\'c\\' or S[n-1]==\\'a\\' or S[n-1]==\\'b\\':\\n            return False\\n        if \\'ac\\' in S or \\'bb\\' in S:\\n            return False   \\n        return S.count(\\'a\\')==S.count(\\'b\\') and S.count(\\'b\\')==S.count(\\'c\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423848,
                "title": "easy-to-understand-c-solution-16ms-beats-89",
                "content": "Runtime: 16 ms, faster than 89.58% of C++ online submissions for Check If Word Is Valid After Substitutions.\\nMemory Usage: 10.4 MB, less than 100.00% of C++ online submissions for Check If Word Is Valid After Substitutions.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        stack<char> st;\\n        for(char ch : S)\\n        {\\n            if(ch == \\'a\\')\\n                st.push(ch);\\n            else if(ch == \\'b\\')\\n            {\\n                if(st.empty() || st.top() != \\'a\\')\\n                    return false;\\n                st.push(ch);\\n            }\\n            else if(ch == \\'c\\')\\n            {\\n                if(st.empty() || st.top() != \\'b\\')\\n                    return false;\\n                st.pop();\\n                if(st.empty() || st.top() != \\'a\\')\\n                    return false;\\n                else\\n                    st.pop();\\n            }\\n        }\\n        return (st.empty());\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(string S) {\\n        stack<char> st;\\n        for(char ch : S)\\n        {\\n            if(ch == \\'a\\')\\n                st.push(ch);\\n            else if(ch == \\'b\\')\\n            {\\n                if(st.empty() || st.top() != \\'a\\')\\n                    return false;\\n                st.push(ch);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 410700,
                "title": "java-using-stack",
                "content": "For what I did. I marked abc with different val, a == 1, b == 2, c == 3;\\nif we have a string aabcbc\\nthen for index from 0 to end we will have stack as follow:\\n1\\n1 1\\n1 2\\n1\\n2\\nempty\\n\\n```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int i = 0; i < S.length(); ++i){\\n            if(stack.isEmpty()){\\n                if(S.charAt(i) == \\'a\\'){\\n                    stack.push(1);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                switch(S.charAt(i)){\\n                    case \\'a\\':\\n                        stack.push(1);\\n                        break;\\n                    case \\'b\\':\\n                        if(stack.peek() == 1){\\n                            stack.pop();\\n                            stack.push(2);\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                        break;\\n                    default:\\n                        if(stack.peek() == 2){\\n                            stack.pop();\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        if(stack.isEmpty()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int i = 0; i < S.length(); ++i){\\n            if(stack.isEmpty()){\\n                if(S.charAt(i) == \\'a\\'){\\n                    stack.push(1);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                switch(S.charAt(i)){\\n                    case \\'a\\':\\n                        stack.push(1);\\n                        break;\\n                    case \\'b\\':\\n                        if(stack.peek() == 1){\\n                            stack.pop();\\n                            stack.push(2);\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                        break;\\n                    default:\\n                        if(stack.peek() == 2){\\n                            stack.pop();\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        if(stack.isEmpty()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336280,
                "title": "simple-solution-in-python-using-count-and-replace",
                "content": "We simply want to use count and replace in Python to check if we have any instances of \"abc\" left to replace, and if so, replace them. At the end, when there are no more instances of \"abc\" we return whether the string is empty.\\n\\n```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n\\n\\twhile S.count(\\'abc\\'):\\n\\t\\tS = S.replace(\\'abc\\',\\'\\')\\n\\n\\treturn not S\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n\\n\\twhile S.count(\\'abc\\'):\\n\\t\\tS = S.replace(\\'abc\\',\\'\\')\\n\\n\\treturn not S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252159,
                "title": "just-use-replaceall-abc",
                "content": "I don\\'t understand why this is medium difficulty...\\n\\npublic boolean isValid(String S) {\\n        while (S.contains(\"abc\")) {\\n            S = S.replaceAll(\"abc\", \"\");\\n        }\\n        return S.length() == 0;\\n    }",
                "solutionTags": [],
                "code": "I don\\'t understand why this is medium difficulty...\\n\\npublic boolean isValid(String S) {\\n        while (S.contains(\"abc\")) {\\n            S = S.replaceAll(\"abc\", \"\");\\n        }\\n        return S.length() == 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 248246,
                "title": "java-stack-20-ms-100-easy",
                "content": "Solution based on stashing letters in stack. If we see characters in sequence of \"abc\" - split it, pop from stack on last \"c\". Otherwise accumulate or return false\\n\\n```\\n    public boolean isValid(String S) {\\n        Stack<String> s = new Stack();\\n        char[] arr = S.toCharArray();\\n        int N = arr.length;\\n        for (int i = 0; i < N; i++) {\\n            char next = arr[i];\\n            if (next == \\'a\\') {\\n                s.push(\"a\");\\n            } else if (next == \\'b\\' && !s.isEmpty() && s.peek().equals(\"a\"))  {\\n                s.pop();\\n                s.push(\"ab\");\\n            } else if (next == \\'c\\' && !s.isEmpty() && s.peek().equals(\"ab\"))  {\\n                s.pop();\\n            } else\\n                return false;\\n        }\\n        return s.isEmpty();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n    public boolean isValid(String S) {\\n        Stack<String> s = new Stack();\\n        char[] arr = S.toCharArray();\\n        int N = arr.length;\\n        for (int i = 0; i < N; i++) {\\n            char next = arr[i];\\n            if (next == \\'a\\') {\\n                s.push(\"a\");\\n            } else if (next == \\'b\\' && !s.isEmpty() && s.peek().equals(\"a\"))  {\\n                s.pop();\\n                s.push(\"ab\");\\n            } else if (next == \\'c\\' && !s.isEmpty() && s.peek().equals(\"ab\"))  {\\n                s.pop();\\n            } else\\n                return false;\\n        }\\n        return s.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082130,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValid(String str) {\\n\\n        StringBuilder s = new StringBuilder(str);\\n\\n        while(s.length()!=0){\\n            int a = s.indexOf(\"abc\");\\n            if(a==-1) return false;\\n            else{\\n                s.delete(a,a+3);\\n            }\\n        }\\n\\n        if(s.length()==0) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String str) {\\n\\n        StringBuilder s = new StringBuilder(str);\\n\\n        while(s.length()!=0){\\n            int a = s.indexOf(\"abc\");\\n            if(a==-1) return false;\\n            else{\\n                s.delete(a,a+3);\\n            }\\n        }\\n\\n        if(s.length()==0) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629151,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0]!=\\'a\\')\\n        return false;\\n        stack<char> st;\\n        for(char ch:s){\\n            if(ch==\\'a\\')\\n                st.push(ch);\\n            else if(ch==\\'b\\'){\\n                if(!st.empty()&&st.top()==\\'a\\')\\n                    st.push(ch);\\n                else\\n                    return false;\\n            }\\n            else\\n            {\\n                if(!st.empty()&&st.top()==\\'b\\'){\\n                    st.pop();\\n                        if(!st.empty()&&st.top()==\\'a\\')\\n                            st.pop();\\n                        else return false;\\n                    }\\n                else\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0]!=\\'a\\')\\n        return false;\\n        stack<char> st;\\n        for(char ch:s){\\n            if(ch==\\'a\\')\\n                st.push(ch);\\n            else if(ch==\\'b\\'){\\n                if(!st.empty()&&st.top()==\\'a\\')\\n                    st.push(ch);\\n                else\\n                    return false;\\n            }\\n            else\\n            {\\n                if(!st.empty()&&st.top()==\\'b\\'){\\n                    st.pop();\\n                        if(!st.empty()&&st.top()==\\'a\\')\\n                            st.pop();\\n                        else return false;\\n                    }\\n                else\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597382,
                "title": "easy-to-understand-2-approaches-c",
                "content": "\\n\\n# Approach\\n- solution 1 Recursion \\n- solution 2 using stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//recursion\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       if(s.size()==0)\\n       return true;\\n\\n       int find = s.find(\"abc\");\\n       if(find != string::npos){\\n           //found\\n           string tleft = s.substr(0,find);\\n           string tright = s.substr(find+3,s.size());\\n           \\n           return isValid(tleft + tright);\\n       } \\n       return false;\\n    }\\n};\\n\\n//TC O(N^2)\\n\\n```\\n\\n```\\n// stack \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0] != \\'a\\'){\\n            return false;\\n        }\\n\\n        stack<char>st;\\n        for(char ch:s){\\n            if(ch == \\'a\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\'b\\'){\\n                if(!st.empty() && st.top() == \\'a\\'){\\n                    st.push(ch);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                // if ch == \\'c\\'\\n                if(!st.empty() && st.top() == \\'b\\'){\\n                    st.pop();\\n                    if(!st.empty() && st.top() == \\'a\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n//recursion\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       if(s.size()==0)\\n       return true;\\n\\n       int find = s.find(\"abc\");\\n       if(find != string::npos){\\n           //found\\n           string tleft = s.substr(0,find);\\n           string tright = s.substr(find+3,s.size());\\n           \\n           return isValid(tleft + tright);\\n       } \\n       return false;\\n    }\\n};\\n\\n//TC O(N^2)\\n\\n```\n```\\n// stack \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0] != \\'a\\'){\\n            return false;\\n        }\\n\\n        stack<char>st;\\n        for(char ch:s){\\n            if(ch == \\'a\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\'b\\'){\\n                if(!st.empty() && st.top() == \\'a\\'){\\n                    st.push(ch);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                // if ch == \\'c\\'\\n                if(!st.empty() && st.top() == \\'b\\'){\\n                    st.pop();\\n                    if(!st.empty() && st.top() == \\'a\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540701,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        if(s.size()%3!=0) return false;\\n        stack<char> st;\\n\\n        for(char c:s){\\n            if(st.empty()) st.push(c);\\n            else if(c==\\'c\\'){\\n                char b=st.top();st.pop();\\n                if(st.empty()) return false;\\n                char a = st.top(); st.pop();\\n                if(b!=\\'b\\' || a!=\\'a\\') return false;\\n            }\\n            else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        prev = None\\n        while s != \"\" and s != prev:\\n            prev = s\\n            s = s.replace(\"abc\", \"\")\\n        return s == \"\"\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] cs = s.toCharArray();\\n        int i = 0;\\n        for (char c : cs) {\\n            if (c != \\'a\\' && (i == 0 || c != cs[--i] + 1)) {\\n                return false;\\n            }\\n            if (c != \\'c\\') {\\n                cs[i++] = c;\\n            }\\n        }\\n        return i == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        if(s.size()%3!=0) return false;\\n        stack<char> st;\\n\\n        for(char c:s){\\n            if(st.empty()) st.push(c);\\n            else if(c==\\'c\\'){\\n                char b=st.top();st.pop();\\n                if(st.empty()) return false;\\n                char a = st.top(); st.pop();\\n                if(b!=\\'b\\' || a!=\\'a\\') return false;\\n            }\\n            else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        prev = None\\n        while s != \"\" and s != prev:\\n            prev = s\\n            s = s.replace(\"abc\", \"\")\\n        return s == \"\"\\n```\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] cs = s.toCharArray();\\n        int i = 0;\\n        for (char c : cs) {\\n            if (c != \\'a\\' && (i == 0 || c != cs[--i] + 1)) {\\n                return false;\\n            }\\n            if (c != \\'c\\') {\\n                cs[i++] = c;\\n            }\\n        }\\n        return i == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362070,
                "title": "c-check-if-word-is-valid-after-substitutions-very-easy-100-beat",
                "content": "# Approach\\nIn this case we use iterative approach for saving space with the help of stack.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public bool IsValid(string s) \\n    {\\n        if(s.Length % 3 != 0) return false;\\n\\n        Stack<char> stack = new Stack<char>();\\n\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            if(s[i] != \\'c\\') stack.Push(s[i]);\\n            else\\n            {\\n                if(stack.Count < 2) return false;\\n                if(stack.Pop() != \\'b\\' || stack.Pop() != \\'a\\') return false;\\n            }\\n        }\\n\\n        return (stack.Count == 0)? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsValid(string s) \\n    {\\n        if(s.Length % 3 != 0) return false;\\n\\n        Stack<char> stack = new Stack<char>();\\n\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            if(s[i] != \\'c\\') stack.Push(s[i]);\\n            else\\n            {\\n                if(stack.Count < 2) return false;\\n                if(stack.Pop() != \\'b\\' || stack.Pop() != \\'a\\') return false;\\n            }\\n        }\\n\\n        return (stack.Count == 0)? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342101,
                "title": "chatgpt-c-solution-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool isValid(string s) {\\n    int i = 0, n = s.size();\\n    for (int j = 0; j < n; j++, i++) {\\n        s[i] = s[j];\\n        if (i >= 2 && s[i] == \\'c\\' && s[i-1] == \\'b\\' && s[i-2] == \\'a\\') {\\n            i -= 3;\\n        }\\n    }\\n    return i == 0;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isValid(string s) {\\n    int i = 0, n = s.size();\\n    for (int j = 0; j < n; j++, i++) {\\n        s[i] = s[j];\\n        if (i >= 2 && s[i] == \\'c\\' && s[i-1] == \\'b\\' && s[i-2] == \\'a\\') {\\n            i -= 3;\\n        }\\n    }\\n    return i == 0;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028339,
                "title": "most-easiest-approach-to-solve",
                "content": "# Intuition\\n  Thought at first time was to store this characters and keep track of last 3 pushes...so that it equals abc or not...So I think 3 stacks is better option...\\n\\n Example stacks st1, st2, st3 :\\n\\n st3 : abc\\n \\n then make arrangements such that\\n st2 : ab\\n \\n then\\n st1 : a\\n\\n\\n# Approach\\n   ##  Using three stacks we simply make it more easier.We track the last 3 elements in stack just by making 3 stacks.\\n\\n\\n   \\n\\n# Complexity\\n- Time complexity: linear\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool isValid(string s) \\n{\\n    int n=s.length();\\n\\n    if(n<=2)\\n        return false;\\n       \\n    stack<char>st1,st2,st3;\\n\\n    st3.push(s[0]);\\n    st3.push(s[1]);\\n\\n    for(int i=2;i<n;i++)\\n    {\\n        st3.push(s[i]);\\n\\n        if(st3.size()>=3)\\n          {\\n            st2=st3;\\n            st2.pop();\\n            st1=st2;\\n            st1.pop();\\n\\n            if((st1.top()==\\'a\\')&&(st2.top()==\\'b\\')&&(st3.top()==\\'c\\'))\\n            {\\n                st3.pop();\\n                st3.pop();\\n                st3.pop(); \\n            }\\n       }\\n\\n    }\\n\\n    if(st3.empty())\\n          return true;\\n\\n    return false;  \\n   \\n}\\n\\n};\\n```\\n\\n\\n# Motivation Quote:\\n ## Learn the rules like a pro so you can break them like an artist \\u2764\\uFE0F\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool isValid(string s) \\n{\\n    int n=s.length();\\n\\n    if(n<=2)\\n        return false;\\n       \\n    stack<char>st1,st2,st3;\\n\\n    st3.push(s[0]);\\n    st3.push(s[1]);\\n\\n    for(int i=2;i<n;i++)\\n    {\\n        st3.push(s[i]);\\n\\n        if(st3.size()>=3)\\n          {\\n            st2=st3;\\n            st2.pop();\\n            st1=st2;\\n            st1.pop();\\n\\n            if((st1.top()==\\'a\\')&&(st2.top()==\\'b\\')&&(st3.top()==\\'c\\'))\\n            {\\n                st3.pop();\\n                st3.pop();\\n                st3.pop(); \\n            }\\n       }\\n\\n    }\\n\\n    if(st3.empty())\\n          return true;\\n\\n    return false;  \\n   \\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895518,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        stack<char>st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n             if( !st.empty() && st.top()==\\'b\\'&& s[i]==\\'c\\')\\n            {\\n                st.pop();\\n                if( !st.empty() && st.top()==\\'a\\')\\n                    st.pop();\\n                else\\n                    st.push(\\'b\\');\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        return st.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        stack<char>st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n             if( !st.empty() && st.top()==\\'b\\'&& s[i]==\\'c\\')\\n            {\\n                st.pop();\\n                if( !st.empty() && st.top()==\\'a\\')\\n                    st.pop();\\n                else\\n                    st.push(\\'b\\');\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        return st.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776423,
                "title": "fastly-solve-this-problem-in-o-n-code-is-written-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem i solved using stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to solve this problem is scan string from left to right and when string char is \"a\" push onto the stack and when string char is \"b\" then check if top of the stack is \"a\" or not if yes then pop \"a\" and push \"b\" if no then return false.\\nand if string char is \"c\" then check top of the stack is \"b\" or not if yes then pop from stack and if no then return false.\\nwhen string gets over then at the end check stack empty or not if yes then return true otherwise false;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is o(n) in worst case\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity is o(n) in worst case\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'b\\' || s[0]==\\'c\\')\\n        {\\n            return false;\\n        }\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                st.push(s[i]);\\n                // st.push(s[i]);\\n            }\\n            else if(!st.empty() && s[i]==\\'b\\')\\n            {\\n                if(st.top()==\\'a\\')\\n                {\\n                    st.pop();\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if(!st.empty() && st.top()==\\'b\\')\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        if(st.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'b\\' || s[0]==\\'c\\')\\n        {\\n            return false;\\n        }\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                st.push(s[i]);\\n                // st.push(s[i]);\\n            }\\n            else if(!st.empty() && s[i]==\\'b\\')\\n            {\\n                if(st.top()==\\'a\\')\\n                {\\n                    st.pop();\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if(!st.empty() && st.top()==\\'b\\')\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        if(st.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542403,
                "title": "stack-solution-with-o-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()){\\n            if(ch ==\\'a\\'){\\n                stack.push(\\'a\\');\\n            }\\n            else if(ch ==\\'b\\'){\\n                if(stack.size() <1 || stack.peek() != \\'a\\'){\\n                    return false;\\n                }\\n                stack.push(\\'b\\');\\n            }else{\\n                if(stack.size() < 2){\\n                    return false;\\n                }\\n                Character first = stack.pop();\\n                Character second = stack.pop();\\n                if(first != \\'b\\' || second != \\'a\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()){\\n            if(ch ==\\'a\\'){\\n                stack.push(\\'a\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2302064,
                "title": "java-stack-valid-after-substitutions-easy-explanation-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        //Lets see how we can solve that as we know we have only abc in string.\\n        //Like           aabcbc\\n        // See as that   ((b)b) Think a is \\'(\\' and c is \\')\\'.\\n        // If a string is made by using abc only we can remove abc to make it empty also.\\n        \\n        //Think in Reverse Way.\\n        \\n        \\n        \\n        Stack<Character> stack = new Stack<>();\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            \\n            // We have to work only when we get \\')\\' means c.\\n            \\n            if(arr[i] == \\'c\\')\\n            {\\n                // If we at c means we have 2 elements before us a and b.\\n                // When we first pop we get b at second pop we get a\\n                \\n            // If this all hold true we will delete a and b we are not adding c so c also\\n                \\n                if(stack.size()>=2 && stack.pop() == \\'b\\' && stack.pop() == \\'a\\')\\n                {\\n\\n                }\\n                else\\n                {\\n                    \\n                    // If anywhere we get false in any condition that means this is not a                          valid set i.e. abc pattern is not present.\\n                    \\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                // For a and b we simply add.\\n                \\n                stack.push(arr[i]);\\n            }\\n        }\\n        \\n        //If we have only abc pattern the stack will become empty.\\n        \\n        return stack.size()==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        //Lets see how we can solve that as we know we have only abc in string.\\n        //Like           aabcbc\\n        // See as that   ((b)b) Think a is \\'(\\' and c is \\')\\'.\\n        // If a string is made by using abc only we can remove abc to make it empty also.\\n        \\n        //Think in Reverse Way.\\n        \\n        \\n        \\n        Stack<Character> stack = new Stack<>();\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            \\n            // We have to work only when we get \\')\\' means c.\\n            \\n            if(arr[i] == \\'c\\')\\n            {\\n                // If we at c means we have 2 elements before us a and b.\\n                // When we first pop we get b at second pop we get a\\n                \\n            // If this all hold true we will delete a and b we are not adding c so c also\\n                \\n                if(stack.size()>=2 && stack.pop() == \\'b\\' && stack.pop() == \\'a\\')\\n                {\\n\\n                }\\n                else\\n                {\\n                    \\n                    // If anywhere we get false in any condition that means this is not a                          valid set i.e. abc pattern is not present.\\n                    \\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                // For a and b we simply add.\\n                \\n                stack.push(arr[i]);\\n            }\\n        }\\n        \\n        //If we have only abc pattern the stack will become empty.\\n        \\n        return stack.size()==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249534,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n\\n            if(ch == \\'a\\' || ch == \\'b\\'){\\n                st.push(ch);\\n            }else{\\n                if(st.size() == 0 || st.size() == 1) return false;\\n\\n                int top = st.pop();\\n                int stop = st.pop();\\n                if(top != \\'b\\' || stop != \\'a\\') return false;\\n            }\\n        }\\n\\n        return st.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n\\n            if(ch == \\'a\\' || ch == \\'b\\'){\\n                st.push(ch);\\n            }else{\\n                if(st.size() == 0 || st.size() == 1) return false;\\n\\n                int top = st.pop();\\n                int stop = st.pop();\\n                if(top != \\'b\\' || stop != \\'a\\') return false;\\n            }\\n        }\\n\\n        return st.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210215,
                "title": "simple-stack-based-solution",
                "content": "if \\'c\\' is to be inserted, there must \"ab\" before insertion. Similary if \\'b\\' is to be inserted, there must be \"a\" before insertion. Otheriwise, it\\'s an invalid string. Here \\'d\\' char is used to indicate that either a, b or c can be inserted in array i.e it\\'s not filled yet.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<vector<char>> st;\\n        \\n        for(char ch: s){\\n            if(ch==\\'a\\'){\\n                vector<char> v{\\'a\\',\\'d\\',\\'d\\'};\\n                st.push(v);\\n            }else if(ch==\\'b\\'){\\n                if(!st.empty() and st.top()[1]==\\'d\\'){\\n                    st.pop();\\n                    vector<char> v{\\'a\\',\\'b\\',\\'d\\'};\\n                    st.push(v);\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                 if(!st.empty() && st.top()[2]==\\'d\\'){\\n                    st.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        if(st.empty()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<vector<char>> st;\\n        \\n        for(char ch: s){\\n            if(ch==\\'a\\'){\\n                vector<char> v{\\'a\\',\\'d\\',\\'d\\'};\\n                st.push(v);\\n            }else if(ch==\\'b\\'){\\n                if(!st.empty() and st.top()[1]==\\'d\\'){\\n                    st.pop();\\n                    vector<char> v{\\'a\\',\\'b\\',\\'d\\'};\\n                    st.push(v);\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                 if(!st.empty() && st.top()[2]==\\'d\\'){\\n                    st.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        if(st.empty()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139559,
                "title": "easy-c-code",
                "content": "class Solution {\\npublic:\\n\\n    bool isValid(string s) {\\n        \\n        while( s.find(\"abc\") != string::npos )\\n            s.replace(s.find(\"abc\"), 3, \"\");\\n        \\n        if(s.empty()) return 1;\\n        else return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool isValid(string s) {\\n        \\n        while( s.find(\"abc\") != string::npos )\\n            s.replace(s.find(\"abc\"), 3, \"\");\\n        \\n        if(s.empty()) return 1;\\n        else return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2045851,
                "title": "python-stack",
                "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        \\n        if len(s)%3 !=0:\\n            return False\\n        stack = []\\n        letters = [\\'a\\',\\'b\\']\\n        \\n        for x in s:\\n            if x in letters:\\n                stack.append(x)\\n            else:\\n                if len(stack) == 0 or stack.pop()!=\\'b\\':\\n                    return False\\n                if len(stack) == 0 or stack.pop()!=\\'a\\':\\n                    return False\\n        return len(stack) == 0",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        \\n        if len(s)%3 !=0:\\n            return False\\n        stack = []\\n        letters = [\\'a\\',\\'b\\']\\n        \\n        for x in s:\\n            if x in letters:\\n                stack.append(x)\\n            else:\\n                if len(stack) == 0 or stack.pop()!=\\'b\\':\\n                    return False\\n                if len(stack) == 0 or stack.pop()!=\\'a\\':\\n                    return False\\n        return len(stack) == 0",
                "codeTag": "Java"
            },
            {
                "id": 1997919,
                "title": "2-solutions-with-and-without-stack-short-and-concise-c",
                "content": "**Using Stack**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> s;\\n        \\n        for(char c : str) {\\n            if(c == \\'a\\') s.push(c);\\n            else if(c == \\'b\\') {\\n                if(s.empty() || s.top() != \\'a\\') return false;\\n                s.push(c);\\n            }\\n            else {\\n                if(s.empty() || s.top() != \\'b\\') return false;\\n                s.pop();\\n                s.pop();\\n            }\\n        }\\n        \\n        return s.empty();\\n    }\\n};\\n```\\n\\n**Without Stack**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       while(s.size()) {\\n           int p = s.find(\"abc\");\\n           if(p < 0 || p > s.size() - 1) return false;\\n           else s.erase(p, 3);\\n       }\\n       return true;    \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> s;\\n        \\n        for(char c : str) {\\n            if(c == \\'a\\') s.push(c);\\n            else if(c == \\'b\\') {\\n                if(s.empty() || s.top() != \\'a\\') return false;\\n                s.push(c);\\n            }\\n            else {\\n                if(s.empty() || s.top() != \\'b\\') return false;\\n                s.pop();\\n                s.pop();\\n            }\\n        }\\n        \\n        return s.empty();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       while(s.size()) {\\n           int p = s.find(\"abc\");\\n           if(p < 0 || p > s.size() - 1) return false;\\n           else s.erase(p, 3);\\n       }\\n       return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904579,
                "title": "5ms-o-n-faster-than-99",
                "content": "```\\n\\t\\tint n=s.length()-1; // cal. length of string-1\\n\\t\\t//checking whether string ends with **a** or **b** or its length is not **multiple of 3** and\\n\\t\\t//return false if any of these condition becomes true\\n        if(s.charAt(n)==\\'a\\'||s.charAt(n)==\\'b\\'||(n+1)%3!=0)return false;\\n        Deque<Character> st=new ArrayDeque<>();\\n        for(char ch:s.toCharArray()){\\n\\t\\t//putting characters in stack if they are a or b (just think about the concept of \\n\\t\\t//balanced paranthesis)\\n            if(ch==\\'a\\'||ch==\\'b\\') st.push(ch);\\n            else{\\n\\t\\t\\t//here we can see that if we encounter c then it means the top of stack has to be \\n\\t\\t\\t//**b** and after that **a** and if any of this is not true then just return false \\n\\t\\t\\t//otherwise pop two characters from stack and move on to next character\\n                if(st.isEmpty()||st.pop()==\\'a\\') return false;\\n                if(st.isEmpty()||st.pop()==\\'b\\') return false;\\n            }\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\t\\tint n=s.length()-1; // cal. length of string-1\\n\\t\\t//checking whether string ends with **a** or **b** or its length is not **multiple of 3** and\\n\\t\\t//return false if any of these condition becomes true\\n        if(s.charAt(n)==\\'a\\'||s.charAt(n)==\\'b\\'||(n+1)%3!=0)return false;\\n        Deque<Character> st=new ArrayDeque<>();\\n        for(char ch:s.toCharArray()){\\n\\t\\t//putting characters in stack if they are a or b (just think about the concept of \\n\\t\\t//balanced paranthesis)\\n            if(ch==\\'a\\'||ch==\\'b\\') st.push(ch);\\n            else{\\n\\t\\t\\t//here we can see that if we encounter c then it means the top of stack has to be \\n\\t\\t\\t//**b** and after that **a** and if any of this is not true then just return false \\n\\t\\t\\t//otherwise pop two characters from stack and move on to next character\\n                if(st.isEmpty()||st.pop()==\\'a\\') return false;\\n                if(st.isEmpty()||st.pop()==\\'b\\') return false;\\n            }\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849841,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c:s){\\n            if( c != \\'c\\')\\n                st.push(c);\\n            else{\\n                string t = \"\";\\n                if(st.size() > 1){\\n                    t += st.top();  st.pop();\\n                    t += st.top();  st.pop();\\n                }\\n                if(t != \"ba\")\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c:s){\\n            if( c != \\'c\\')\\n                st.push(c);\\n            else{\\n                string t = \"\";\\n                if(st.size() > 1){\\n                    t += st.top();  st.pop();\\n                    t += st.top();  st.pop();\\n                }\\n                if(t != \"ba\")\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843907,
                "title": "beginner-friendly-solution-c",
                "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        string str; //declare a string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.push(s[i]);\\n            if(s[i]==\\'c\\')  // check when the c is inserted into the stack\\n            {\\n                int k=3;\\n                while(k--){\\n                if(st.empty())\\n                    break;\\n                char ch=st.top();\\n                st.pop();\\n                str+=ch;\\n                }\\n                cout<<str<<\"\\\\n\";\\n                if(str!=\"cba\")\\n                    return false;\\n                str.clear();       //clear after every check\\n            }\\n        }\\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        string str; //declare a string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.push(s[i]);\\n            if(s[i]==\\'c\\')  // check when the c is inserted into the stack\\n            {\\n                int k=3;\\n                while(k--){\\n                if(st.empty())\\n                    break;\\n                char ch=st.top();\\n                st.pop();\\n                str+=ch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1831206,
                "title": "recursive-easy-c-beginner-friendly",
                "content": "```\\nbool isValid(string s) {\\n        int n = s.length();\\n        int index = s.find(\"abc\");\\n        \\n        if (s == \"abc\")\\n            return true;\\n        \\n        if (index == -1)\\n            return false;\\n        \\n        return isValid(s.substr(0, index)+s.substr(index+3));\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool isValid(string s) {\\n        int n = s.length();\\n        int index = s.find(\"abc\");\\n        \\n        if (s == \"abc\")\\n            return true;\\n        \\n        if (index == -1)\\n            return false;\\n        \\n        return isValid(s.substr(0, index)+s.substr(index+3));\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1800316,
                "title": "c-time-o-n-space-o-1-easy-simple-solution",
                "content": "**Intuition**\\n`j` is read pointer and `i` is write pointer. We always write `s[j]` to `s[i]`.\\nIf the last 3 characters in front of `i` is `\"abc\"`, we clean them by `i -= 3`.\\nIn the end, return `i == 0`.\\n**Code**\\n```\\nclass Solution {\\npublic:\\n\\tbool isValid(string s) {\\n\\t\\tint i = 0;\\n\\t\\tint j = 0;\\n\\t\\tint n = s.size();\\n\\t\\twhile (j < n)\\n\\t\\t{\\n\\t\\t\\ts[i] = s[j];\\n\\t\\t\\t// checking is last three character is \"abc\" then we erase them means set i to i-3\\n\\t\\t\\tif (i >= 2 && s[i - 2] == \\'a\\' && s[i - 1] == \\'b\\' && s[i] == \\'c\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\ti -= 3;\\n\\t\\t\\t}\\n\\t\\t\\ti++; j++;\\n\\t\\t}\\n\\t\\treturn (i == 0);\\n\\t}\\n};\\n```\\n**Time Complexity : O(n)**\\n**Space Complexity : O(1)**\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool isValid(string s) {\\n\\t\\tint i = 0;\\n\\t\\tint j = 0;\\n\\t\\tint n = s.size();\\n\\t\\twhile (j < n)\\n\\t\\t{\\n\\t\\t\\ts[i] = s[j];\\n\\t\\t\\t// checking is last three character is \"abc\" then we erase them means set i to i-3\\n\\t\\t\\tif (i >= 2 && s[i - 2] == \\'a\\' && s[i - 1] == \\'b\\' && s[i] == \\'c\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\ti -= 3;\\n\\t\\t\\t}\\n\\t\\t\\ti++; j++;\\n\\t\\t}\\n\\t\\treturn (i == 0);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793602,
                "title": "98-67-lesser-memory-only-3-lines-of-code-very-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while(\"abc\" in s): \\n            s = s.replace(\"abc\",\"\") # continuously replace \"abc\" by \"\". By the end if we end up with \"\", then the word is valid.\\n        return s == \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while(\"abc\" in s): \\n            s = s.replace(\"abc\",\"\") # continuously replace \"abc\" by \"\". By the end if we end up with \"\", then the word is valid.\\n        return s == \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732646,
                "title": "c-easy-to-understand-stack-usage-2-approaches-o-1-space-complexity",
                "content": "**Approach 1 \\nO(n) time complexity\\nO(n) space complexity**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      stack<char> st;\\n        for(char &ch:s)\\n        {\\n          if(ch==\\'c\\')\\n          {\\n              if(st.size()<2)\\n              {\\n                  return false;\\n              }\\n              else\\n              {\\n                  char c1=st.top();\\n                  if(c1!=\\'b\\')\\n                  {\\n                      return false;\\n                  }\\n                  st.pop();\\n                  char c2=st.top();\\n                  if(c2!=\\'a\\')\\n                  {\\n                      return false;\\n                  }\\n                  st.pop();\\n              }\\n          }\\n          else\\n          {\\n              st.push(ch);\\n          }\\n        }\\n        return st.empty();\\n    }\\n};\\n```\\n**Approach 2\\nO(n) time complexity\\nO(1) space complexity**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n=s.size();\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[j++]=s[i];\\n            if(j>=3&&s[j-1]==\\'c\\'&&s[j-2]==\\'b\\'&&s[j-3]==\\'a\\')\\n            {\\n                j-=3;\\n            }\\n        }\\n        return j==0;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      stack<char> st;\\n        for(char &ch:s)\\n        {\\n          if(ch==\\'c\\')\\n          {\\n              if(st.size()<2)\\n              {\\n                  return false;\\n              }\\n              else\\n              {\\n                  char c1=st.top();\\n                  if(c1!=\\'b\\')\\n                  {\\n                      return false;\\n                  }\\n                  st.pop();\\n                  char c2=st.top();\\n                  if(c2!=\\'a\\')\\n                  {\\n                      return false;\\n                  }\\n                  st.pop();\\n              }\\n          }\\n          else\\n          {\\n              st.push(ch);\\n          }\\n        }\\n        return st.empty();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n=s.size();\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[j++]=s[i];\\n            if(j>=3&&s[j-1]==\\'c\\'&&s[j-2]==\\'b\\'&&s[j-3]==\\'a\\')\\n            {\\n                j-=3;\\n            }\\n        }\\n        return j==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645671,
                "title": "check-if-word-is-valid-after-substitutions",
                "content": "```\\nclass Solution:\\n    def isValid(self, s):\\n        while \"abc\" in s:\\n            s = s.split(\"abc\")\\n            s = \"\".join(s)\\n            \\n        return len(s)==0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s):\\n        while \"abc\" in s:\\n            s = s.split(\"abc\")\\n            s = \"\".join(s)\\n            \\n        return len(s)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642146,
                "title": "python-3-lines-of-code-99-faster",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        if len(s) == 0: return True\\n        if \"abc\" in s: return self.isValid(s.replace(\"abc\", \"\"))\\n        return False\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        if len(s) == 0: return True\\n        if \"abc\" in s: return self.isValid(s.replace(\"abc\", \"\"))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596490,
                "title": "java-2-solutions",
                "content": "Using a stack:\\n\\n```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> characters = new Stack();\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'c\\') {\\n                if(characters.isEmpty() || characters.pop() != \\'b\\' || characters.isEmpty() || characters.pop() != \\'a\\')\\n                    return false;\\n            } else {\\n                characters.push(s.charAt(i));\\n            }\\n        }\\n        \\n        return characters.isEmpty();\\n    }\\n}\\n```\\n\\nWithout a stack:\\n\\n```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while(s.contains(\"abc\"))\\n            s = s.replace(\"abc\", \"\");\\n        \\n        return s.length() == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> characters = new Stack();\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'c\\') {\\n                if(characters.isEmpty() || characters.pop() != \\'b\\' || characters.isEmpty() || characters.pop() != \\'a\\')\\n                    return false;\\n            } else {\\n                characters.push(s.charAt(i));\\n            }\\n        }\\n        \\n        return characters.isEmpty();\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while(s.contains(\"abc\"))\\n            s = s.replace(\"abc\", \"\");\\n        \\n        return s.length() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575456,
                "title": "c-8ms-98-simple-easy-small-stack",
                "content": "Runtime: 8 ms, faster than 98.37% of C++ online submissions for Check If Word Is Valid After Substitutions.\\nMemory Usage: 8.2 MB, less than 86.71% of C++ online submissions for Check If Word Is Valid After Substitutions.\\n```\\nclass Solution {\\npublic:\\n  bool isValid(string s) {\\n    vector<char>st;\\n    \\n    for(auto &ch : s)\\n      if(ch == \\'c\\'){\\n        if(st.empty() || st.back() == \\'a\\') return false;\\n        st.pop_back();\\n        if(st.empty() || st.back() == \\'b\\') return false;\\n        st.pop_back();\\n      }else st.push_back(ch);\\n    \\n    return st.empty();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isValid(string s) {\\n    vector<char>st;\\n    \\n    for(auto &ch : s)\\n      if(ch == \\'c\\'){\\n        if(st.empty() || st.back() == \\'a\\') return false;\\n        st.pop_back();\\n        if(st.empty() || st.back() == \\'b\\') return false;\\n        st.pop_back();\\n      }else st.push_back(ch);\\n    \\n    return st.empty();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510597,
                "title": "java-stack-o-n-time-and-o-n-space",
                "content": "This is a modified version of balanced paranthesis problem. For every \\'a\\', there should be \\'bc\\' after it.\\n\\n```\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        Stack<Character> st = new Stack<>();\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'a\\' || c==\\'b\\')\\n                st.push(c);\\n            else\\n            {\\n                if(!st.isEmpty() && st.peek()==\\'b\\')\\n                {\\n                    char ch = st.pop();\\n                    if(!st.isEmpty() && st.peek()==\\'a\\')\\n                        st.pop();\\n                    else\\n                        st.push(ch);\\n                }\\n                else\\n                    st.push(c);\\n            }\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        Stack<Character> st = new Stack<>();\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'a\\' || c==\\'b\\')\\n                st.push(c);\\n            else\\n            {\\n                if(!st.isEmpty() && st.peek()==\\'b\\')\\n                {\\n                    char ch = st.pop();\\n                    if(!st.isEmpty() && st.peek()==\\'a\\')\\n                        st.pop();\\n                    else\\n                        st.push(ch);\\n                }\\n                else\\n                    st.push(c);\\n            }\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501769,
                "title": "2-lines-code-beats-96",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while ((s = s.replace(\"abc\", \"\")).contains(\"abc\")) {}\\n        return s.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while ((s = s.replace(\"abc\", \"\")).contains(\"abc\")) {}\\n        return s.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476772,
                "title": "java-easy-to-understand-using-stack-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        Stack<Character> st = new Stack<>();\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'a\\' || ch == \\'b\\')\\n                st.push(ch);\\n            else\\n            {\\n                if(st.size() <= 1)\\n                    return false;\\n                else{\\n                    char b = st.pop();\\n                    char a = st.pop();\\n                    if(a != \\'a\\' || b != \\'b\\')\\n                        return false;\\n                }\\n            }\\n            if(map.containsKey(ch))\\n                    map.put(ch,map.get(ch)+1);\\n                else    map.put(ch,1);\\n        }\\n        int x=0;\\n        if(map.containsKey(\\'a\\') && map.size()>=3)\\n            x = map.get(\\'a\\');\\n        else return false;\\n        \\n        for(int i : map.values())\\n        {\\n            if(x!=i)\\n                return false;\\n        }\\n        \\n        return true ;\\n        \\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        Stack<Character> st = new Stack<>();\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'a\\' || ch == \\'b\\')\\n                st.push(ch);\\n            else\\n            {\\n                if(st.size() <= 1)\\n                    return false;\\n                else{\\n                    char b = st.pop();\\n                    char a = st.pop();\\n                    if(a != \\'a\\' || b != \\'b\\')\\n                        return false;\\n                }\\n            }\\n            if(map.containsKey(ch))\\n                    map.put(ch,map.get(ch)+1);\\n                else    map.put(ch,1);\\n        }\\n        int x=0;\\n        if(map.containsKey(\\'a\\') && map.size()>=3)\\n            x = map.get(\\'a\\');\\n        else return false;\\n        \\n        for(int i : map.values())\\n        {\\n            if(x!=i)\\n                return false;\\n        }\\n        \\n        return true ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378500,
                "title": "c-stack-solution",
                "content": "I recommend you solve Valid Parentheses first. Here\\'s the same idea.\\n``` \\nbool isValid(string s) {\\n        stack<char> st;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (!st.empty() && s[i] == \\'c\\') {\\n                if (!st.empty() && st.top() == \\'b\\') {\\n                    st.pop();\\n                } else {\\n                    return false;\\n                }\\n                if (!st.empty() && st.top() == \\'a\\') {\\n                    st.pop();\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                st.push(s[i]);\\n            }\\n        }\\n        return st.empty();\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "``` \\nbool isValid(string s) {\\n        stack<char> st;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (!st.empty() && s[i] == \\'c\\') {\\n                if (!st.empty() && st.top() == \\'b\\') {\\n                    st.pop();\\n                } else {\\n                    return false;\\n                }\\n                if (!st.empty() && st.top() == \\'a\\') {\\n                    st.pop();\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                st.push(s[i]);\\n            }\\n        }\\n        return st.empty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354243,
                "title": "short-java-solution-o-n",
                "content": "traverse from end and while \\'a\\' comes pop \\'b\\' and \\'c\\' respectively\\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=s.length()-1;i>=0;--i){\\n            char temp=s.charAt(i);\\n            if(temp==\\'a\\'){\\n                if(stack.isEmpty() || stack.peek()!=\\'b\\') return false;\\n                stack.pop();\\n                if(stack.isEmpty() || stack.peek()!=\\'c\\') return false;\\n                stack.pop();\\n            }\\n            else stack.push(temp);\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=s.length()-1;i>=0;--i){\\n            char temp=s.charAt(i);\\n            if(temp==\\'a\\'){\\n                if(stack.isEmpty() || stack.peek()!=\\'b\\') return false;\\n                stack.pop();\\n                if(stack.isEmpty() || stack.peek()!=\\'c\\') return false;\\n                stack.pop();\\n            }\\n            else stack.push(temp);\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339139,
                "title": "java-easy",
                "content": "class Solution {\\n    public boolean isValid(String s) {\\n        \\n         if(s.equals(\"abc\")) return true;\\n        \\n         Stack<Character> st = new Stack<>();\\n    \\n         for(int i = 0 ; i < s.length();i++){\\n         char ch = s.charAt(i);\\n        \\n         if(ch == \\'c\\'){\\n            if(st.size()>= 2 && st.pop() == \\'b\\' && st.pop() == \\'a\\'){\\n                \\n            }else{\\n                return false;\\n            }\\n        }else{\\n            st.push(ch);\\n        }\\n        \\n    }\\n\\n        return st.size() == 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n        \\n         if(s.equals(\"abc\")) return true;\\n        \\n         Stack<Character> st = new Stack<>();\\n    \\n         for(int i = 0 ; i < s.length();i++){\\n         char ch = s.charAt(i);\\n        \\n         if(ch == \\'c\\'){\\n            if(st.size()>= 2 && st.pop() == \\'b\\' && st.pop() == \\'a\\'){\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1283339,
                "title": "5-line-c-code-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c: s){\\n            if(c==\\'c\\' && st.size()>1){\\n                if(st.top()==\\'b\\') st.pop();\\n                else return false;\\n                if(st.top()==\\'a\\') st.pop();\\n                else return false;\\n            }\\n            else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c: s){\\n            if(c==\\'c\\' && st.size()>1){\\n                if(st.top()==\\'b\\') st.pop();\\n                else return false;\\n                if(st.top()==\\'a\\') st.pop();\\n                else return false;\\n            }\\n            else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281013,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        //push the a and b into the stack\\n        //when ever you get c  make sure you have b at the top and next a\\n        //if not return false;\\n        stack<char> stk;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'b\\')\\n                stk.push(s[i]);\\n            else \\n            {\\n                //if it is a \\'c\\'\\n                if(stk.size()<2)\\n                    return false;\\n                if(stk.top()!=\\'b\\')\\n                    return false;\\n                stk.pop();\\n                if(stk.top()!=\\'a\\')\\n                    return false;\\n                stk.pop();\\n                \\n            }\\n        }\\n        return (stk.empty());\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        //push the a and b into the stack\\n        //when ever you get c  make sure you have b at the top and next a\\n        //if not return false;\\n        stack<char> stk;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'b\\')\\n                stk.push(s[i]);\\n            else \\n            {\\n                //if it is a \\'c\\'\\n                if(stk.size()<2)\\n                    return false;\\n                if(stk.top()!=\\'b\\')\\n                    return false;\\n                stk.pop();\\n                if(stk.top()!=\\'a\\')\\n                    return false;\\n                stk.pop();\\n                \\n            }\\n        }\\n        return (stk.empty());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271956,
                "title": "very-easy-code-using-stack",
                "content": "Here any time if we see abc sequence we will simply pop it from the stack\\nand at the end if the stack becomes empty we will return true else false\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i =0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'c\\'){\\n                if(st.size()>=2  && st.pop()==\\'b\\' && st.pop()==\\'a\\'){\\n                    //paired\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        return st.size()==0;\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i =0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'c\\'){\\n                if(st.size()>=2  && st.pop()==\\'b\\' && st.pop()==\\'a\\'){\\n                    //paired\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1260993,
                "title": "java-easy-stack",
                "content": "*This problem is literally a cake walk if you asssume that  by using the given string, if you are able to make a \"\" (blank string) of it than simply return true at last otherwise return false*\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n          Stack<Character> stack = new Stack<>();\\n          \\n          for(int i = 0 ; i<s.length() ; i++ ){\\n               if(s.charAt(i)==\\'c\\'){\\n                 if(stack.size() >=2 && stack.pop()==\\'b\\' && stack.peek()==\\'a\\'){\\n                      stack.pop();\\n                 }\\n                 else{\\n                      return false;\\n                 }\\n               }\\n               else{\\n                 stack.push(s.charAt(i));\\n               }\\n          }\\n      return stack.size() == 0 ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n          Stack<Character> stack = new Stack<>();\\n          \\n          for(int i = 0 ; i<s.length() ; i++ ){\\n               if(s.charAt(i)==\\'c\\'){\\n                 if(stack.size() >=2 && stack.pop()==\\'b\\' && stack.peek()==\\'a\\'){\\n                      stack.pop();\\n                 }\\n                 else{\\n                      return false;\\n                 }\\n               }\\n               else{\\n                 stack.push(s.charAt(i));\\n               }\\n          }\\n      return stack.size() == 0 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253192,
                "title": "c-simple-solution-using-stack-please-upvote-if-you-like",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n=s.length();\\n        stack<char> s1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                s1.push(s[i]);\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                if(s1.empty() || s1.top()!=\\'a\\')\\n                {\\n                    return false;\\n                }\\n                s1.push(s[i]);\\n            }\\n            else if(s[i]==\\'c\\')\\n            {\\n                if(s1.empty() || s1.top()!=\\'b\\')\\n                {\\n                    return false;\\n                }\\n                if(s1.top()==\\'b\\')\\n                {\\n                    s1.pop();\\n                    if(s1.empty() || s1.top()!=\\'a\\')\\n                    {\\n                        return false;\\n                    }\\n                    s1.pop();\\n                }\\n            }\\n        }\\n        if(s1.empty())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n=s.length();\\n        stack<char> s1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                s1.push(s[i]);\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                if(s1.empty() || s1.top()!=\\'a\\')\\n                {\\n                    return false;\\n                }\\n                s1.push(s[i]);\\n            }\\n            else if(s[i]==\\'c\\')\\n            {\\n                if(s1.empty() || s1.top()!=\\'b\\')\\n                {\\n                    return false;\\n                }\\n                if(s1.top()==\\'b\\')\\n                {\\n                    s1.pop();\\n                    if(s1.empty() || s1.top()!=\\'a\\')\\n                    {\\n                        return false;\\n                    }\\n                    s1.pop();\\n                }\\n            }\\n        }\\n        if(s1.empty())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249317,
                "title": "c-fastest-using-stack-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n  int n = s.size();\\n  if (n % 3 != 0)return false;\\n  stack<char> st;\\n\\n  for (int i = 0; i < n; i++) {\\n    if (s[i] != \\'c\\') {st.push(s[i]);}\\n    else {\\n        if(st.empty() || st.top()!=\\'b\\')return false;\\n      st.pop();\\n        if(st.empty() || st.top()!=\\'a\\')return false;\\n      st.pop();\\n    }\\n  }\\n\\n  if (st.empty())return true;\\n  else return false;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n  int n = s.size();\\n  if (n % 3 != 0)return false;\\n  stack<char> st;\\n\\n  for (int i = 0; i < n; i++) {\\n    if (s[i] != \\'c\\') {st.push(s[i]);}\\n    else {\\n        if(st.empty() || st.top()!=\\'b\\')return false;\\n      st.pop();\\n        if(st.empty() || st.top()!=\\'a\\')return false;\\n      st.pop();\\n    }\\n  }\\n\\n  if (st.empty())return true;\\n  else return false;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236791,
                "title": "c-fastest-solution-o-n-time-and-o-n-space",
                "content": "```\\nbool isValid(string s) {\\n        stack<char>st;\\n        \\n        for(char ch : s){\\n            if(!st.empty() && ch == \\'c\\'){\\n                char ch2 = st.top();\\n                st.pop();\\n                if(!st.empty() && ch2 == \\'b\\' && st.top() == \\'a\\')\\n                    st.pop();\\n                \\n                else{\\n                    st.push(ch2);\\n                    st.push(ch);\\n                }\\n            }\\n            \\n            else\\n                st.push(ch);\\n        }\\n        \\n        if(!st.empty())\\n            return false;\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isValid(string s) {\\n        stack<char>st;\\n        \\n        for(char ch : s){\\n            if(!st.empty() && ch == \\'c\\'){\\n                char ch2 = st.top();\\n                st.pop();\\n                if(!st.empty() && ch2 == \\'b\\' && st.top() == \\'a\\')\\n                    st.pop();\\n                \\n                else{\\n                    st.push(ch2);\\n                    st.push(ch);\\n                }\\n            }\\n            \\n            else\\n                st.push(ch);\\n        }\\n        \\n        if(!st.empty())\\n            return false;\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222134,
                "title": "java-solution-takes-6ms",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s == null || s.length() < 3 || s.charAt(0) != \\'a\\' || s.charAt(s.length()-1) != \\'c\\'){\\n            return false;\\n        }\\n        Stack<Character> stack = new Stack<>();\\n        for(char c:s.toCharArray()){\\n            if(c == \\'c\\'){\\n                if(stack.isEmpty() || stack.pop() != \\'b\\' || stack.isEmpty() || stack.pop() != \\'a\\'){\\n                    return false;\\n                }\\n                continue;\\n            }\\n            stack.push(c);\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s == null || s.length() < 3 || s.charAt(0) != \\'a\\' || s.charAt(s.length()-1) != \\'c\\'){\\n            return false;\\n        }\\n        Stack<Character> stack = new Stack<>();\\n        for(char c:s.toCharArray()){\\n            if(c == \\'c\\'){\\n                if(stack.isEmpty() || stack.pop() != \\'b\\' || stack.isEmpty() || stack.pop() != \\'a\\'){\\n                    return false;\\n                }\\n                continue;\\n            }\\n            stack.push(c);\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166596,
                "title": "using-string-as-stack-and-stl-c",
                "content": "```\\nbool isValid(string s) {\\n        string s1=\"\";\\n        for(char ele:s)\\n        {\\n            if(ele==\\'c\\'&&s1.length()>1)\\n            {\\n                s1+=ele;\\n                if(s1.substr(s1.size()-3,3)==\"abc\")\\n                {\\n                    int k=3;\\n                    while(k--)\\n                        s1.pop_back();\\n                }\\n                continue;\\n            }\\n            s1+=ele;\\n        }\\n        return s1.size()==0;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nbool isValid(string s) {\\n        string s1=\"\";\\n        for(char ele:s)\\n        {\\n            if(ele==\\'c\\'&&s1.length()>1)\\n            {\\n                s1+=ele;\\n                if(s1.substr(s1.size()-3,3)==\"abc\")\\n                {\\n                    int k=3;\\n                    while(k--)\\n                        s1.pop_back();\\n                }\\n                continue;\\n            }\\n            s1+=ele;\\n        }\\n        return s1.size()==0;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120410,
                "title": "using-stack-is-slower-that-replace-6-vs-96-speed",
                "content": "I tried three different solutions: built-in replace, re.sub(), stack. The replace was faster than re.sub() and way faster than stack (24 ms, 28 ms, 240 ms)\\n\\nDoes anybody know why stack is slower than built-in replace?\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while \"abc\" in s:\\n            s = s.replace(\"abc\", \"\")\\n        return not s\\n\\nfrom re import search, sub\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while search(r\"abc\", s):\\n            s = sub(\"abc\", \"\", s)\\n        return not s\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        for c in s:\\n            if (len(stack) > 2 and stack[-3] == \"a\" and stack[-2] == \"b\" and\\n                    stack[-1] == \"c\"):\\n                stack = stack[:-3]\\n            stack.append(c)\\n        return stack == [\\'a\\', \\'b\\', \\'c\\']\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while \"abc\" in s:\\n            s = s.replace(\"abc\", \"\")\\n        return not s\\n\\nfrom re import search, sub\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while search(r\"abc\", s):\\n            s = sub(\"abc\", \"\", s)\\n        return not s\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        for c in s:\\n            if (len(stack) > 2 and stack[-3] == \"a\" and stack[-2] == \"b\" and\\n                    stack[-1] == \"c\"):\\n                stack = stack[:-3]\\n            stack.append(c)\\n        return stack == [\\'a\\', \\'b\\', \\'c\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104473,
                "title": "easiest-of-solutions-must-see-c",
                "content": "\\'\\'\\'\\n bool isValid(string s) {\\n\\n        int i =0;\\n        while(s.size()>3 and i<s.size())\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                if(s[i+1] == \\'b\\')\\n                {\\n                    if(s[i+2]==\\'c\\')\\n                    {\\n                        s.erase(s.begin() +i,s.begin()+i+3);\\n                        i=0;\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        if(s ==  \"abc\")\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n bool isValid(string s) {\\n\\n        int i =0;\\n        while(s.size()>3 and i<s.size())\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                if(s[i+1] == \\'b\\')\\n                {\\n                    if(s[i+2]==\\'c\\')\\n                    {\\n                        s.erase(s.begin() +i,s.begin()+i+3);\\n                        i=0;\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        if(s ==  \"abc\")\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1061610,
                "title": "easy-to-understand-java-stack-implementation",
                "content": "```\\nclass Solution {\\n    \\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: s.toCharArray())\\n        {\\n            if(ch == \\'a\\' || ch == \\'b\\')\\n                stack.push(ch);\\n            else\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'b\\')\\n                    return false;\\n                stack.pop();\\n                if(stack.isEmpty() || stack.peek()!=\\'a\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: s.toCharArray())\\n        {\\n            if(ch == \\'a\\' || ch == \\'b\\')\\n                stack.push(ch);\\n            else\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'b\\')\\n                    return false;\\n                stack.pop();\\n                if(stack.isEmpty() || stack.peek()!=\\'a\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057096,
                "title": "easy-and-fast-js-solution",
                "content": "```\\nvar isValid = function(s) {\\n    let subS = s.split(\\'abc\\').join(\\'\\');\\n    while(subS.length < s.length){\\n         s = subS;\\n         subS = s.split(\\'abc\\').join(\\'\\') ;\\n    }\\n    \\n    return s.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function(s) {\\n    let subS = s.split(\\'abc\\').join(\\'\\');\\n    while(subS.length < s.length){\\n         s = subS;\\n         subS = s.split(\\'abc\\').join(\\'\\') ;\\n    }\\n    \\n    return s.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053275,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while len(s) != 0:\\n            s = s.replace(\\'abc\\', \\'\\')\\n            if (len(s) != 0) and (len(s) == len(s.replace(\\'abc\\', \\'\\'))):\\n                return False\\n        return True \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while len(s) != 0:\\n            s = s.replace(\\'abc\\', \\'\\')\\n            if (len(s) != 0) and (len(s) == len(s.replace(\\'abc\\', \\'\\'))):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050023,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // Wipe out \\'abc\\' in s, and then wipe out \\'abc\\' in the new string, recursively doing this until there is\\n        // no more \\'abc\\' in the string. If the string is empty, return true, otherwise return false.\\n        if (s.empty())\\n        {\\n            return true;\\n        }\\n        \\n        if (s.find(\"abc\") == string::npos)\\n        {\\n            return false;\\n        }\\n        \\n        string res;\\n        int size = s.size();\\n        for (int i = 0; i < size;)\\n        {\\n            char c1 = s[i], c2 = i + 1 < size ? s[i + 1] : \\' \\';\\n            char c3 = i + 2 < size ? s[i + 2] : \\' \\';\\n            if (c1 == \\'a\\' && c2 == \\'b\\' && c3 == \\'c\\')\\n            {\\n                i += 3;\\n            }\\n            else\\n            {\\n                res += s[i];\\n                ++i;\\n            }\\n        }\\n        \\n        return isValid(res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // Wipe out \\'abc\\' in s, and then wipe out \\'abc\\' in the new string, recursively doing this until there is\\n        // no more \\'abc\\' in the string. If the string is empty, return true, otherwise return false.\\n        if (s.empty())\\n        {\\n            return true;\\n        }\\n        \\n        if (s.find(\"abc\") == string::npos)\\n        {\\n            return false;\\n        }\\n        \\n        string res;\\n        int size = s.size();\\n        for (int i = 0; i < size;)\\n        {\\n            char c1 = s[i], c2 = i + 1 < size ? s[i + 1] : \\' \\';\\n            char c3 = i + 2 < size ? s[i + 2] : \\' \\';\\n            if (c1 == \\'a\\' && c2 == \\'b\\' && c3 == \\'c\\')\\n            {\\n                i += 3;\\n            }\\n            else\\n            {\\n                res += s[i];\\n                ++i;\\n            }\\n        }\\n        \\n        return isValid(res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033109,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    boolean flag=false;\\n    public boolean isValid(String s) {\\n        if(s.length()%3!=0)\\n            return false;\\n        reduce(s);\\n        return flag;\\n        \\n    }\\n    void reduce(String s)\\n    {\\n        if(s.equals(\"\"))\\n        {\\n            flag=true;\\n            return;\\n        }\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            \\n            if(s.charAt(i)==\\'a\\'&&s.charAt(i+1)==\\'b\\'&&s.charAt(i+2)==\\'c\\')\\n            {\\n                 if(i+3<s.length())\\n                s=s.substring(0,i)+s.substring(i+3);\\n                else\\n                    s=s.substring(0,i);\\n                reduce(s);\\n                break;\\n               \\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean flag=false;\\n    public boolean isValid(String s) {\\n        if(s.length()%3!=0)\\n            return false;\\n        reduce(s);\\n        return flag;\\n        \\n    }\\n    void reduce(String s)\\n    {\\n        if(s.equals(\"\"))\\n        {\\n            flag=true;\\n            return;\\n        }\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            \\n            if(s.charAt(i)==\\'a\\'&&s.charAt(i+1)==\\'b\\'&&s.charAt(i+2)==\\'c\\')\\n            {\\n                 if(i+3<s.length())\\n                s=s.substring(0,i)+s.substring(i+3);\\n                else\\n                    s=s.substring(0,i);\\n                reduce(s);\\n                break;\\n               \\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007884,
                "title": "java-88-stack-with-detailed-comments",
                "content": "Summary: similar to checking valid parentheses with a stack, linear scan left to right, \\'a\\', \\'b\\' get pushed to the stack. \\'c\\' will try to pop \\'b\\', \\'a\\' from the stack, early return false if popping failed. Make sure stack is empty at the end. Linear space and time.\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if (s.length() % 3 != 0) return false; //small optimization\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s.toCharArray()){\\n            if (c != \\'c\\'){\\n                stack.push(c); //push \\'a\\', \\'b\\'\\n            } else {\\n                if (stack.size() < 2 || stack.pop() != \\'b\\' || stack.pop() != \\'a\\') return false; //try to pop \\'b\\', \\'a\\' in that order\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if (s.length() % 3 != 0) return false; //small optimization\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s.toCharArray()){\\n            if (c != \\'c\\'){\\n                stack.push(c); //push \\'a\\', \\'b\\'\\n            } else {\\n                if (stack.size() < 2 || stack.pop() != \\'b\\' || stack.pop() != \\'a\\') return false; //try to pop \\'b\\', \\'a\\' in that order\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902322,
                "title": "java-easy-to-understand",
                "content": "\\t public boolean isValid(String s) {\\n        String abc = \"abc\";\\n        StringBuilder builder = new StringBuilder();\\n        while(s.indexOf(abc) >= 0){\\n            builder = new StringBuilder();\\n            int index = s.indexOf(abc);\\n            builder.append(s.substring(0, index)).append(s.substring(index + 3));\\n            s = builder.toString();\\n        }\\n        return s.isEmpty();\\n    }",
                "solutionTags": [],
                "code": "\\t public boolean isValid(String s) {\\n        String abc = \"abc\";\\n        StringBuilder builder = new StringBuilder();\\n        while(s.indexOf(abc) >= 0){\\n            builder = new StringBuilder();\\n            int index = s.indexOf(abc);\\n            builder.append(s.substring(0, index)).append(s.substring(index + 3));\\n            s = builder.toString();\\n        }\\n        return s.isEmpty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 890708,
                "title": "easy-c-solution-using-string-find",
                "content": "Just find \"abc\" and remove until there is no abc remains.Then check if string is empty return true otherwise return false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        int startingPoint;\\n        while(s.length()!=0)\\n        {\\n            startingPoint=s.find(\"abc\");\\n            if(startingPoint==string::npos)\\n            {\\n                if(s.length()!=0)return false;\\n            }\\n            else\\n            {\\n            s.erase(startingPoint,3);\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        int startingPoint;\\n        while(s.length()!=0)\\n        {\\n            startingPoint=s.find(\"abc\");\\n            if(startingPoint==string::npos)\\n            {\\n                if(s.length()!=0)return false;\\n            }\\n            else\\n            {\\n            s.erase(startingPoint,3);\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882965,
                "title": "easy-c-solution-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> S;\\n        for(char i:s){\\n            if(i==\\'c\\'){\\n                if(S.empty() || S.top()!=\\'b\\')return false;\\n                S.pop();\\n                if(S.empty() || S.top()!=\\'a\\')return false;\\n                S.pop();\\n            \\n            }else{\\n                S.push(i);\\n            }\\n        }\\n        if(!S.empty()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> S;\\n        for(char i:s){\\n            if(i==\\'c\\'){\\n                if(S.empty() || S.top()!=\\'b\\')return false;\\n                S.pop();\\n                if(S.empty() || S.top()!=\\'a\\')return false;\\n                S.pop();\\n            \\n            }else{\\n                S.push(i);\\n            }\\n        }\\n        if(!S.empty()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824818,
                "title": "stack-c-simple-code-with-explanation",
                "content": "Whenever we encounter a \\'c\\' we check if the last two elements inserted in stack are \\'a\\' & \\'b\\'. If not return false. \\nThe logic behind this is that we will always have a \\'abc\\' string in input, after recursively removing \\'abc\\' from the string if we are left with an empty stack, then the string is valid. Otherwise its not.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        int n = s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty() || s[i]!=\\'c\\')\\n               st.push(s[i]);\\n            else if(s[i]==\\'c\\')\\n            {\\n                if(st.empty())\\n                    return false;\\n                char b = st.top();\\n                st.pop();\\n                if(st.empty())\\n                    return false;\\n                char a = st.top();\\n                if(a==\\'a\\' && b==\\'b\\')\\n                    st.pop();\\n                else return false;\\n            }\\n        }\\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        int n = s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty() || s[i]!=\\'c\\')\\n               st.push(s[i]);\\n            else if(s[i]==\\'c\\')\\n            {\\n                if(st.empty())\\n                    return false;\\n                char b = st.top();\\n                st.pop();\\n                if(st.empty())\\n                    return false;\\n                char a = st.top();\\n                if(a==\\'a\\' && b==\\'b\\')\\n                    st.pop();\\n                else return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 824816,
                "title": "c-simple-stack-solution-o-n",
                "content": "If c comes you check the top 2 elements if they are not equal to a and b then return false or if the stack is empty or if in the end stack is not empty.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\'c\\'){\\n                st.push(s[i]);\\n            }else{\\n                if(st.empty()){\\n                    return false;\\n                }\\n                char a;\\n                if(!st.empty()){\\n                    a=st.top();\\n                    st.pop();\\n                }\\n                if(st.empty() || st.top()!=\\'a\\' || a!=\\'b\\'){\\n                    return false;\\n                }else{\\n                    st.pop();\\n                }\\n            }\\n        }\\n        if(!st.empty()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\'c\\'){\\n                st.push(s[i]);\\n            }else{\\n                if(st.empty()){\\n                    return false;\\n                }\\n                char a;\\n                if(!st.empty()){\\n                    a=st.top();\\n                    st.pop();\\n                }\\n                if(st.empty() || st.top()!=\\'a\\' || a!=\\'b\\'){\\n                    return false;\\n                }else{\\n                    st.pop();\\n                }\\n            }\\n        }\\n        if(!st.empty()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687050,
                "title": "using-repetitive-split-and-join",
                "content": "Here is my solution relying heavily on Python\\'s built-in string manipulation methods:\\nWe split an input string on valid string and join the remainder and repeat the split-join cycle until we get empty string, at the moment we don\\'t get a string split in at least 2, we return false.\\n```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        valid_str = \\'abc\\'\\n        while 1:\\n            split = S.split(valid_str)\\n            if len(split) == 1:\\n                return False\\n            S = \\'\\'.join(split)\\n            if S == \\'\\':\\n                return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        valid_str = \\'abc\\'\\n        while 1:\\n            split = S.split(valid_str)\\n            if len(split) == 1:\\n                return False\\n            S = \\'\\'.join(split)\\n            if S == \\'\\':\\n                return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634612,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stk = []\\n        for c in S:\\n            if c == \\'a\\' or c == \\'b\\':\\n                stk.append(c)\\n            if c == \\'c\\':\\n                if len(stk) < 2:\\n                    return False\\n                if stk[-2] != \\'a\\' or stk[-1] != \\'b\\':\\n                    return False\\n                stk.pop()\\n                stk.pop()\\n        return len(stk) == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stk = []\\n        for c in S:\\n            if c == \\'a\\' or c == \\'b\\':\\n                stk.append(c)\\n            if c == \\'c\\':\\n                if len(stk) < 2:\\n                    return False\\n                if stk[-2] != \\'a\\' or stk[-1] != \\'b\\':\\n                    return False\\n                stk.pop()\\n                stk.pop()\\n        return len(stk) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593417,
                "title": "2-pointer-solution-o-n-time-o-1-space-very-few-lines-c-solution",
                "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n    \\n       int i = 0, n = s.length();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            s[i] = s[j];\\n            if (i >1 && s[i - 1] == \\'b\\'&&s[i-2]==\\'a\\'&&s[i]==\\'c\\')\\n                i -= 3;\\n        }\\n        return !i;\\n\\n    }\\n};\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n    \\n       int i = 0, n = s.length();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            s[i] = s[j];\\n            if (i >1 && s[i - 1] == \\'b\\'&&s[i-2]==\\'a\\'&&s[i]==\\'c\\')\\n                i -= 3;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 577829,
                "title": "java-replace",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        if (S == null) return false;\\n        S = S.replaceAll(\"abc\", \"\");\\n        S = S.replace(\"abc\", \"\");\\n        return S.equals(\"abc\") || S.equals(\"\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        if (S == null) return false;\\n        S = S.replaceAll(\"abc\", \"\");\\n        S = S.replace(\"abc\", \"\");\\n        return S.equals(\"abc\") || S.equals(\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570741,
                "title": "faster-than-98-02-of-python3-online-submissions",
                "content": "I proposed a string replace implementation algorithm which is faster than 98.02% Python3 submissions.\\n\\n```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while \\'abc\\' in S:\\n            S = S.replace(\\'abc\\', \\'\\')\\n        return not S\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while \\'abc\\' in S:\\n            S = S.replace(\\'abc\\', \\'\\')\\n        return not S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556413,
                "title": "java-easy-3-line-solution",
                "content": "Intuition : The String S is built this way : \"abc\" --> some transformations --> S. \\nWe can reverse engineer this, and removing \"abc\" repeatedly till we do not find any more \"abc\"s as substring. Every iteration step should lead us to another substring which has \"abc\" as a substring (As they are all of the form X + \"abc\" + Y). Now as X + Y in turn is \"abc\" itself, the end result for a valid string, thus, is an empty string.\\n```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        while(S.contains(\"abc\"))\\n            S = S.replace(\"abc\", \"\");\\n        return S.length() == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        while(S.contains(\"abc\"))\\n            S = S.replace(\"abc\", \"\");\\n        return S.length() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551732,
                "title": "python-3-solution-using-replace-and-stack",
                "content": "**Using replace()**\\n```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while \\'abc\\' in S:\\n            S = S.replace(\\'abc\\',\\'\\',S.count(\\'abc\\'))\\n        return len(S)==0\\n```\\n\\n**Using Stack**\\n```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stack = []\\n        for i in S:\\n            if i == \\'c\\':\\n                if stack[-2:] != [\\'a\\', \\'b\\']:\\n                    return False\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return not stack",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while \\'abc\\' in S:\\n            S = S.replace(\\'abc\\',\\'\\',S.count(\\'abc\\'))\\n        return len(S)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534081,
                "title": "super-simple-javascript-solution",
                "content": "```\\n/**\\n * @param {string} S\\n * @return {boolean}\\n */\\nvar isValid = function(S) {\\n    while(S.indexOf(\\'abc\\')>=0) {\\n        S=S.split(\\'abc\\').join(\\'\\');\\n    }\\n    return S.length === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {boolean}\\n */\\nvar isValid = function(S) {\\n    while(S.indexOf(\\'abc\\')>=0) {\\n        S=S.split(\\'abc\\').join(\\'\\');\\n    }\\n    return S.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506273,
                "title": "javascript-o-1",
                "content": "```\\n/**\\n * @param {string} S\\n * @return {boolean}\\n */\\nconst isValid = (S) => {\\n  let i = 0;\\n  const st = [];\\n  while (i < S.length) {\\n    const ch = S.charAt(i++);\\n    if (ch !== \\'c\\') {\\n        st.push(ch);\\n    } else {\\n      if (!(st.pop() === \\'b\\' && st.pop() === \\'a\\')) {\\n        return false;\\n      }        \\n    }\\n  }\\n\\n  return st.length === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {boolean}\\n */\\nconst isValid = (S) => {\\n  let i = 0;\\n  const st = [];\\n  while (i < S.length) {\\n    const ch = S.charAt(i++);\\n    if (ch !== \\'c\\') {\\n        st.push(ch);\\n    } else {\\n      if (!(st.pop() === \\'b\\' && st.pop() === \\'a\\')) {\\n        return false;\\n      }        \\n    }\\n  }\\n\\n  return st.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459055,
                "title": "simple-java-solution-excellent-memory-usage-no-string-replacement-required",
                "content": "1 on top of stack -> a was last seen\\n2 on top of stack -> b was last seen\\nNo need to add 3 for \\'c\\' since \\'c\\' is the end of a block/region\\n\\n```\\n\\tpublic boolean isValid(String s) {\\n        \\n        if(s == null || s.isEmpty()) {\\n            return false;\\n        }\\n        \\n        s = s.toLowerCase();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == \\'a\\') {\\n                stack.push(1);\\n            }\\n            else if(c == \\'b\\') {\\n                if(stack.isEmpty() || stack.peek() != 1) {\\n                    return false;\\n                }\\n                stack.pop();\\n                stack.push(2);\\n            }\\n            else if(c == \\'c\\') {\\n                if(stack.isEmpty() || stack.peek() != 2) {\\n                    return false;\\n                }\\n                stack.pop();\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        return stack.isEmpty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean isValid(String s) {\\n        \\n        if(s == null || s.isEmpty()) {\\n            return false;\\n        }\\n        \\n        s = s.toLowerCase();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == \\'a\\') {\\n                stack.push(1);\\n            }\\n            else if(c == \\'b\\') {\\n                if(stack.isEmpty() || stack.peek() != 1) {\\n                    return false;\\n                }\\n                stack.pop();\\n                stack.push(2);\\n            }\\n            else if(c == \\'c\\') {\\n                if(stack.isEmpty() || stack.peek() != 2) {\\n                    return false;\\n                }\\n                stack.pop();\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        return stack.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405645,
                "title": "simple-python",
                "content": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        \\n        for char in S:\\n            stack.append(char)\\n            \\n            if len(stack) >= 3 and stack[-3] + stack[-2] + stack[-1] == \\'abc\\':\\n                for i in range(3):\\n                    stack.pop()\\n            \\n        return not stack",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        \\n        for char in S:\\n            stack.append(char)\\n            \\n            if len(stack) >= 3 and stack[-3] + stack[-2] + stack[-1] == \\'abc\\':\\n                for i in range(3):\\n                    stack.pop()\\n            \\n        return not stack",
                "codeTag": "Java"
            },
            {
                "id": 390642,
                "title": "python-3-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef isValid(self, S: str) -> bool:\\n\\t\\t\\twhile \"abc\" in S:\\n\\t\\t\\t\\tidx = S.index(\"abc\")\\n\\t\\t\\t\\tS = S[:idx] + S[idx + 3:]\\n\\t\\t\\treturn not S",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef isValid(self, S: str) -> bool:\\n\\t\\t\\twhile \"abc\" in S:\\n\\t\\t\\t\\tidx = S.index(\"abc\")\\n\\t\\t\\t\\tS = S[:idx] + S[idx + 3:]\\n\\t\\t\\treturn not S",
                "codeTag": "Java"
            },
            {
                "id": 384915,
                "title": "java-1-stringbuilder-indexof-delete-2-using-stack",
                "content": "```\\n    public boolean isValid(String S) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch : S.toCharArray()){\\n            if(ch!=\\'c\\')\\n                stack.push(ch);\\n            else if(!stack.isEmpty() && stack.pop()==\\'b\\' && !stack.isEmpty() && stack.pop()==\\'a\\')\\n                continue;\\n            else\\n                return false;\\n\\n        }\\n\\n        return stack.isEmpty();\\n    }\\n```\\n```\\n    public boolean isValid(String S) {\\n        StringBuilder sb = new StringBuilder(S);\\n        while(true){\\n            int ind = sb.indexOf(\"abc\");\\n            if(ind < 0)\\n                break;\\n\\n            sb.delete(ind, ind+3);\\n        }\\n\\n        return sb.length()==0 ? true : false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isValid(String S) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch : S.toCharArray()){\\n            if(ch!=\\'c\\')\\n                stack.push(ch);\\n            else if(!stack.isEmpty() && stack.pop()==\\'b\\' && !stack.isEmpty() && stack.pop()==\\'a\\')\\n                continue;\\n            else\\n                return false;\\n\\n        }\\n\\n        return stack.isEmpty();\\n    }\\n```\n```\\n    public boolean isValid(String S) {\\n        StringBuilder sb = new StringBuilder(S);\\n        while(true){\\n            int ind = sb.indexOf(\"abc\");\\n            if(ind < 0)\\n                break;\\n\\n            sb.delete(ind, ind+3);\\n        }\\n\\n        return sb.length()==0 ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375441,
                "title": "python-100-solution-in-time-and-96-in-space",
                "content": "For Time\\n        while S.__contains__(\\'abc\\') and S:\\n            S = \\'\\'.join(S.split(\\'abc\\'))\\n        return False if S else True\\n\\t\\t\\nFor Space\\n\\t\\t        stack = []\\n        for ch in S:\\n            if ch in (\\'a\\', \\'b\\'):\\n                stack.append(ch)\\n            else:\\n                import pdb;\\n                pdb.set_trace()\\n                if not(len(stack)>=2 and stack.pop()== \\'b\\' and stack.pop() == \\'a\\'):\\n                    return False\\n        return False if stack else True",
                "solutionTags": [],
                "code": "For Time\\n        while S.__contains__(\\'abc\\') and S:\\n            S = \\'\\'.join(S.split(\\'abc\\'))\\n        return False if S else True\\n\\t\\t\\nFor Space\\n\\t\\t        stack = []\\n        for ch in S:\\n            if ch in (\\'a\\', \\'b\\'):\\n                stack.append(ch)\\n            else:\\n                import pdb;\\n                pdb.set_trace()\\n                if not(len(stack)>=2 and stack.pop()== \\'b\\' and stack.pop() == \\'a\\'):\\n                    return False\\n        return False if stack else True",
                "codeTag": "Python3"
            },
            {
                "id": 352625,
                "title": "python-stack",
                "content": "```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        \\n        N = len(S)\\n        if N % 3 or N == 0:\\n            return False\\n        \\n        arr = [None] * N\\n        arri = 0\\n        for c in S:\\n            arr[arri] = c\\n            arri += 1\\n            if arri >= 3 and arr[arri-3] == \\'a\\' and arr[arri-2] == \\'b\\' and arr[arri-1] == \\'c\\':\\n                arri -= 3\\n        return arri == 0\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        \\n        N = len(S)\\n        if N % 3 or N == 0:\\n            return False\\n        \\n        arr = [None] * N\\n        arri = 0\\n        for c in S:\\n            arr[arri] = c\\n            arri += 1\\n            if arri >= 3 and arr[arri-3] == \\'a\\' and arr[arri-2] == \\'b\\' and arr[arri-1] == \\'c\\':\\n                arri -= 3\\n        return arri == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335431,
                "title": "3-lines-c",
                "content": "```\\npublic bool IsValid(string S)\\n{\\n\\twhile (S.Contains(\"abc\"))\\n\\t\\tS = S.Replace(\"abc\", \"\");\\n\\treturn S.Length == 0;\\n}",
                "solutionTags": [],
                "code": "```\\npublic bool IsValid(string S)\\n{\\n\\twhile (S.Contains(\"abc\"))\\n\\t\\tS = S.Replace(\"abc\", \"\");\\n\\treturn S.Length == 0;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 319907,
                "title": "3-lines-python3-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while S and \\'abc\\' in S:\\n            S = re.sub(\\'abc\\', \\'\\', S)\\n        return not S\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while S and \\'abc\\' in S:\\n            S = re.sub(\\'abc\\', \\'\\', S)\\n        return not S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307447,
                "title": "very-simple-regex-solution",
                "content": "It\\'s more of a hack than a valid interview solution; but oh well. :D\\n```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        if (S == null) return false;\\n        while (S.contains(\"abc\")) {\\n            S = S.replaceAll(\"abc\", \"\");\\n        }\\n        return S.isEmpty();\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        if (S == null) return false;\\n        while (S.contains(\"abc\")) {\\n            S = S.replaceAll(\"abc\", \"\");\\n        }\\n        return S.isEmpty();\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279868,
                "title": "5-line-super-simple-java-solution",
                "content": "The idea is that if the string contains \"abc\" then it will keep replacing \"abc\" with \"\" until the replacing operation cannot be done. Hope this helps! :)\\n```\\n    public boolean isValid(String S) {\\n        while(S.contains(\"abc\")){\\n            S = S.replace(\"abc\",\"\");\\n            if(S.equals(\"\"))\\n                return true;\\n        }return false;\\n    }",
                "solutionTags": [],
                "code": "The idea is that if the string contains \"abc\" then it will keep replacing \"abc\" with \"\" until the replacing operation cannot be done. Hope this helps! :)\\n```\\n    public boolean isValid(String S) {\\n        while(S.contains(\"abc\")){\\n            S = S.replace(\"abc\",\"\");\\n            if(S.equals(\"\"))\\n                return true;\\n        }return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 266825,
                "title": "c-constant-space-simple-with-explanation",
                "content": "The idea is simple, if a ``Word`` is valid after substitution, then erasing substring ``\"abc\"`` each time to either **empty string** OR ``\"abc\"`` substr.\\nAt each iteration, I am deleting substr ``\"abc\"``.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        if(S.empty()) return false;\\n        if(S==\"abc\") return true;\\n        while(!S.empty()){\\n            size_t f = S.find(\"abc\");\\n            if(f==std::string::npos) return false; // no \"abc\" substr\\n            S.erase(S.begin()+f,S.begin()+f+3);    // remove \"abc\"\\n            if(S==\"abc\") return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        if(S.empty()) return false;\\n        if(S==\"abc\") return true;\\n        while(!S.empty()){\\n            size_t f = S.find(\"abc\");\\n            if(f==std::string::npos) return false; // no \"abc\" substr\\n            S.erase(S.begin()+f,S.begin()+f+3);    // remove \"abc\"\\n            if(S==\"abc\") return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265113,
                "title": "c-easy-solution-beat-99-using-recursive",
                "content": "```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\nstatic const int _ = [](){\\n\\tios::sync_with_stdio(false);\\n\\tcin.sync_with_stdio(false);\\n\\tcout.sync_with_stdio(false);\\n\\tcin.tie(nullptr);\\n\\tcout.tie(nullptr);\\n\\treturn 0;\\n}();\\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s == \"\") return true;\\n        if(s.size() < 3) return false;\\n        \\n        bool ans = false;\\n        size_t pos = s.find(\"abc\", 0);\\n        size_t i = 0, diff = 0;\\n        if(pos == string::npos) return ans;\\n        \\n        string helper;\\n        \\n        for(; pos != string::npos ; pos = s.find(\"abc\", i)) {\\n        \\t//cout << \"i: \" << i << \" pos: \" << pos << endl;\\n        \\tif(pos != i) {\\n        \\t\\tdiff = pos - i;\\n        \\t\\thelper += s.substr(i, diff);\\n        \\t\\t//cout << \"helper: \" << helper << endl;\\n\\t\\t\\t}\\n        \\tpos += 2;\\n        \\ti = pos + 1;\\n\\t\\t}\\n        \\n        diff = s.size() - i;\\n        helper += s.substr(i, diff);\\n        //cout << \"last helper: \" << helper << endl;\\n        \\n        if(isValid(helper))\\n        \\tans = true;\\n        \\t\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\nstatic const int _ = [](){\\n\\tios::sync_with_stdio(false);\\n\\tcin.sync_with_stdio(false);\\n\\tcout.sync_with_stdio(false);\\n\\tcin.tie(nullptr);\\n\\tcout.tie(nullptr);\\n\\treturn 0;\\n}();\\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s == \"\") return true;\\n        if(s.size() < 3) return false;\\n        \\n        bool ans = false;\\n        size_t pos = s.find(\"abc\", 0);\\n        size_t i = 0, diff = 0;\\n        if(pos == string::npos) return ans;\\n        \\n        string helper;\\n        \\n        for(; pos != string::npos ; pos = s.find(\"abc\", i)) {\\n        \\t//cout << \"i: \" << i << \" pos: \" << pos << endl;\\n        \\tif(pos != i) {\\n        \\t\\tdiff = pos - i;\\n        \\t\\thelper += s.substr(i, diff);\\n        \\t\\t//cout << \"helper: \" << helper << endl;\\n\\t\\t\\t}\\n        \\tpos += 2;\\n        \\ti = pos + 1;\\n\\t\\t}\\n        \\n        diff = s.size() - i;\\n        helper += s.substr(i, diff);\\n        //cout << \"last helper: \" << helper << endl;\\n        \\n        if(isValid(helper))\\n        \\tans = true;\\n        \\t\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 254728,
                "title": "c-both-100-stack-o-n-time-space",
                "content": "```\\npublic bool IsValid(string S) {\\n        Stack<char> stack = new Stack<char>();\\n        foreach(char i in S){\\n            switch (i){\\n                case \\'a\\':\\n                    stack.Push(i);\\n                    break;\\n                case \\'b\\':\\n                    if(stack.Count == 0 || stack.Peek() == \\'c\\') return false;\\n                    stack.Push(i);\\n                    break;\\n                case \\'c\\':\\n                    if(stack.Count == 0 || stack.Peek() != \\'b\\') return false;\\n                    stack.Pop();\\n\\t\\t\\t\\t\\tif(stack.Count == 0 || stack.Peek() != \\'a\\') return false;\\n                    stack.Pop();\\n                    break;\\n            }\\n        }\\n        if(stack.Count > 0) return false;\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic bool IsValid(string S) {\\n        Stack<char> stack = new Stack<char>();\\n        foreach(char i in S){\\n            switch (i){\\n                case \\'a\\':\\n                    stack.Push(i);\\n                    break;\\n                case \\'b\\':\\n                    if(stack.Count == 0 || stack.Peek() == \\'c\\') return false;\\n                    stack.Push(i);\\n                    break;\\n                case \\'c\\':\\n                    if(stack.Count == 0 || stack.Peek() != \\'b\\') return false;\\n                    stack.Pop();\\n\\t\\t\\t\\t\\tif(stack.Count == 0 || stack.Peek() != \\'a\\') return false;\\n                    stack.Pop();\\n                    break;\\n            }\\n        }\\n        if(stack.Count > 0) return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 253549,
                "title": "python-o-n-solution-with-idea-of-valid-parentheses",
                "content": "let\\'s think about how to slove [valid parentheses](https://leetcode.com/problems/valid-parentheses/), where \"(\" needs to follow by \")\"/\"(\". where if we have \")\" and the last element in the stack is \"(\" we can go ahead and remove it. \\n\\nif the stack is empty at the end then it is valid else not.\\n\\n----------------------\\n\"a\" can be treat as one kind of Parentheses where it closed by \"b\", and \"b\" close by \"c\".\\nif we find \"b\" and the last element in stack is \"a\", we can pop \"a\", where \"b\" should wait for it\\'s close patentheese \"c\". \\n\\n\\n\\n```\\nclass Solution(object):\\n    def isValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: bool\\n        \"\"\"\\n        if not S:\\n            return False\\n        s = []\\n        for char in S:\\n            if char == \"a\":\\n                s.append(char)\\n            if char == \"b\":\\n                if not s:\\n                    return False\\n                if s[-1] == \"a\":\\n                    s.pop()\\n                    s.append(char)\\n            if char == \"c\":\\n                if not s:\\n                    return False\\n                if s[-1] == \\'b\\':\\n                    s.pop()\\n        return len(s) == 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: bool\\n        \"\"\"\\n        if not S:\\n            return False\\n        s = []\\n        for char in S:\\n            if char == \"a\":\\n                s.append(char)\\n            if char == \"b\":\\n                if not s:\\n                    return False\\n                if s[-1] == \"a\":\\n                    s.pop()\\n                    s.append(char)\\n            if char == \"c\":\\n                if not s:\\n                    return False\\n                if s[-1] == \\'b\\':\\n                    s.pop()\\n        return len(s) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251273,
                "title": "simple-and-easy-to-understand-but-less-efficient",
                "content": "Basically, just keeps removing \"abc\" and check if the string can be empty after that.\\n\\n```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        while (S.contains(\"abc\")) {\\n            S = S.replace(\"abc\", \"\");\\n        }\\n        return S.length() == 0 ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        while (S.contains(\"abc\")) {\\n            S = S.replace(\"abc\", \"\");\\n        }\\n        return S.length() == 0 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249711,
                "title": "java-3-line-stack-solution-o-n-time-space",
                "content": "```\\n    public boolean isValid(String S) {\\n        Deque<Character> d = new ArrayDeque<Character>();\\n        for( char c : S.toCharArray() ) if( c!=\\'c\\' ) d.push(c); else if( d.isEmpty() || d.pop()!=\\'b\\' || d.isEmpty() || d.pop()!=\\'a\\' ) return false;\\n        return d.isEmpty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isValid(String S) {\\n        Deque<Character> d = new ArrayDeque<Character>();\\n        for( char c : S.toCharArray() ) if( c!=\\'c\\' ) d.push(c); else if( d.isEmpty() || d.pop()!=\\'b\\' || d.isEmpty() || d.pop()!=\\'a\\' ) return false;\\n        return d.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249412,
                "title": "c-simplest-solution-with-0-n-time-complexity-and-0-1-space-complexity",
                "content": "A count should always be higher or equal than b and c .\\nSimilarly B count should always be higher than c.\\nIf this condition doesnot hold true we will return false;\\nelse\\nif count of a ,b and c is equal than return true otherwise return false;\\n[class Solution {\\npublic:\\n    bool isValid(string S) {\\n        int n=S.length();\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'a\\')a++;\\n            else if(S[i]==\\'b\\')b++;\\n            else if(S[i]==\\'c\\')c++;\\n            if(a<b||b<c||a<c){\\n                return 0;\\n            }\\n        }\\n        if(a==b&&a==c)return 1;\\n        return 0;\\n    }\\n};](http://)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValid(string S) {\\n        int n=S.length();\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'a\\')a++;\\n            else if(S[i]==\\'b\\')b++;\\n            else if(S[i]==\\'c\\')c++;\\n            if(a<b||b<c||a<c){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 249287,
                "title": "java-super-easy-and-fast-o-n-solution-beats-100-time-and-100-space",
                "content": "```\\n    public boolean isValid(String S) {\\n        Stack<Character> stk=new Stack<>();\\n        for(int i=0;i<S.length();i++) {\\n            if(S.charAt(i)==\\'c\\'&&!stk.isEmpty()) {\\n                char tmp=stk.pop();\\n                if(!stk.isEmpty()&&tmp==\\'b\\'&&stk.peek()==\\'a\\') {\\n                    stk.pop();\\n                    continue;\\n                }\\n                else stk.push(tmp);\\n            }\\n            stk.push(S.charAt(i));\\n        } \\n        return stk.isEmpty();\\n    }",
                "solutionTags": [],
                "code": "```\\n    public boolean isValid(String S) {\\n        Stack<Character> stk=new Stack<>();\\n        for(int i=0;i<S.length();i++) {\\n            if(S.charAt(i)==\\'c\\'&&!stk.isEmpty()) {\\n                char tmp=stk.pop();\\n                if(!stk.isEmpty()&&tmp==\\'b\\'&&stk.peek()==\\'a\\') {\\n                    stk.pop();\\n                    continue;\\n                }\\n                else stk.push(tmp);\\n            }\\n            stk.push(S.charAt(i));\\n        } \\n        return stk.isEmpty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 248843,
                "title": "why-is-aabcbabcc-is-valid",
                "content": "The idea would be compare S to \\'abc\\' from left to right; remove any matched letter and continue this process until nothing can be matched; then try the other direction. If finally we go an empty string, then return True, otherwise False.\\n\\n```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        \"\"\"\\n        The idea would be compare S to \\'abc\\' from left to right; remove any matched letter and continue this process until nothing can be matched; then try the other direction. If finally we go an empty string, then return True, otherwise False.\\n        \"\"\"\\n        T = \\'abc\\'\\n        if S is None or len(S) < len(T):\\n            return False\\n        # matching from left first\\n        left = 0\\n        right = len(S)\\n        while left < right:\\n            i = 0\\n            while i < len(T) and left + i < right and S[left + i] == T[i]:\\n                i += 1\\n            if i == 0:\\n                # nothing can be matched from left any more\\n                break\\n            left += i\\n        while left < right:\\n            i = 0\\n            while i < len(T) and left + i < right and S[right - i - 1] == T[-i - 1]:\\n                i += 1\\n            if i == 0:\\n                # nothing can be matched from tight any more\\n                break\\n            right -= i\\n        return left >= right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        \"\"\"\\n        The idea would be compare S to \\'abc\\' from left to right; remove any matched letter and continue this process until nothing can be matched; then try the other direction. If finally we go an empty string, then return True, otherwise False.\\n        \"\"\"\\n        T = \\'abc\\'\\n        if S is None or len(S) < len(T):\\n            return False\\n        # matching from left first\\n        left = 0\\n        right = len(S)\\n        while left < right:\\n            i = 0\\n            while i < len(T) and left + i < right and S[left + i] == T[i]:\\n                i += 1\\n            if i == 0:\\n                # nothing can be matched from left any more\\n                break\\n            left += i\\n        while left < right:\\n            i = 0\\n            while i < len(T) and left + i < right and S[right - i - 1] == T[-i - 1]:\\n                i += 1\\n            if i == 0:\\n                # nothing can be matched from tight any more\\n                break\\n            right -= i\\n        return left >= right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248748,
                "title": "java-o-n",
                "content": "Starting from the left, the amount of \\'c\\' can not exceed that of \\'b\\', and so can\\'t \\'b\\' exceed \\'a\\'\\n```\\npublic boolean isValid(String S) {\\n        int[] nums = new int[3];\\n        for(char c:S.toCharArray()){\\n            int n = c-\\'a\\';nums[n]++;\\n            for(int i=n-1;i>=0;i--)\\n                if(nums[n]>nums[i]) return false;\\n        }\\n        return nums[0]==nums[1] && nums[1]==nums[2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String S) {\\n        int[] nums = new int[3];\\n        for(char c:S.toCharArray()){\\n            int n = c-\\'a\\';nums[n]++;\\n            for(int i=n-1;i>=0;i--)\\n                if(nums[n]>nums[i]) return false;\\n        }\\n        return nums[0]==nums[1] && nums[1]==nums[2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248718,
                "title": "javascript-replace-solution",
                "content": "```js\\nconst isValid = (S) => {\\n    if (S.length < 3) return false;\\n    let current = S, replaced = S.replace(/abc/g, \\'\\');\\n    while (current !== replaced) {\\n        current = replaced;\\n        replaced = replaced.replace(/abc/g, \\'\\');\\n    }\\n    return replaced.length === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nconst isValid = (S) => {\\n    if (S.length < 3) return false;\\n    let current = S, replaced = S.replace(/abc/g, \\'\\');\\n    while (current !== replaced) {\\n        current = replaced;\\n        replaced = replaced.replace(/abc/g, \\'\\');\\n    }\\n    return replaced.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248547,
                "title": "stack-o-n-c",
                "content": "``` bool isValid(string S) {\\n        vector<char> v;\\n        for (auto x : S) {\\n            if (x == \\'a\\' || x == \\'b\\') {\\n                v.push_back(x);\\n                continue;\\n            } else if (x == \\'c\\') {\\n                int n = v.size();\\n                if (n >= 2 && v[n-1] == \\'b\\' && v[n-2] == \\'a\\') {\\n                    v.pop_back();\\n                    v.pop_back();\\n                    continue;\\n                }\\n            } \\n            return false;  \\n        }\\n        return v.empty();\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "``` bool isValid(string S) {\\n        vector<char> v;\\n        for (auto x : S) {\\n            if (x == \\'a\\' || x == \\'b\\') {\\n                v.push_back(x);\\n                continue;\\n            } else if (x == \\'c\\') {\\n                int n = v.size();\\n                if (n >= 2 && v[n-1] == \\'b\\' && v[n-2] == \\'a\\') {\\n                    v.pop_back();\\n                    v.pop_back();\\n                    continue;\\n                }\\n            } \\n            return false;  \\n        }\\n        return v.empty();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248329,
                "title": "w-java-stupid-question",
                "content": "Just did a replace for abc and keep looping the same till any occurence of \"abc\" is present.\\n```\\npublic boolean isValid(String S) {\\n        while(S.contains(\"abc\")) {\\n            S = S.replace(\"abc\", \"\");\\n        }\\n        return S.length() == 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String S) {\\n        while(S.contains(\"abc\")) {\\n            S = S.replace(\"abc\", \"\");\\n        }\\n        return S.length() == 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248236,
                "title": "java-solution-using-stack-with-explanation",
                "content": "We always push \\'a\\' to the stack, no matter what is on the top of the stack. For \\'b\\' we have to check that the stack is not empty and the top item is \"a\", then we pop \"a\" and push \"ab\" to the stack. For \\'c\\' we have to check that the stack is not empty and the top item is \"ab\", then we pop this item because we have just encountered a valid string \"abc\" and we have to remove it. At the end we check whether the stack is empty, because for a valid string, all the \"abc\" strings have to be popped from the stack.\\n\\n```\\npublic boolean isValid(String S) {\\n    Stack<String> stack = new Stack<>();\\n    for (char ch : S.toCharArray()) {\\n        switch (ch) {\\n            case \\'a\\':\\n                stack.push(\"a\");\\n                break;\\n            case \\'b\\':\\n                if (stack.isEmpty() || !stack.peek().equals(\"a\")) {\\n                    return false;\\n                }\\n                stack.push(stack.pop() + \"b\");\\n                break;\\n            case \\'c\\':\\n                if (stack.isEmpty() || !stack.peek().equals(\"ab\")) {\\n                    return false;\\n                }\\n                stack.pop();\\n                break;\\n            default:\\n                throw new IllegalArgumentException(\"Not possible!\");\\n        }\\n    }\\n    return stack.isEmpty();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String S) {\\n    Stack<String> stack = new Stack<>();\\n    for (char ch : S.toCharArray()) {\\n        switch (ch) {\\n            case \\'a\\':\\n                stack.push(\"a\");\\n                break;\\n            case \\'b\\':\\n                if (stack.isEmpty() || !stack.peek().equals(\"a\")) {\\n                    return false;\\n                }\\n                stack.push(stack.pop() + \"b\");\\n                break;\\n            case \\'c\\':\\n                if (stack.isEmpty() || !stack.peek().equals(\"ab\")) {\\n                    return false;\\n                }\\n                stack.pop();\\n                break;\\n            default:\\n                throw new IllegalArgumentException(\"Not possible!\");\\n        }\\n    }\\n    return stack.isEmpty();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247824,
                "title": "java-stack-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char cur = s.charAt(i);\\n            if (cur == \\'a\\' || cur == \\'b\\') stack.push(cur);\\n            else {\\n                if (stack.isEmpty() || stack.peek() != \\'b\\') return false;\\n                stack.pop();\\n                if (stack.isEmpty() || stack.peek() != \\'a\\') return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char cur = s.charAt(i);\\n            if (cur == \\'a\\' || cur == \\'b\\') stack.push(cur);\\n            else {\\n                if (stack.isEmpty() || stack.peek() != \\'b\\') return false;\\n                stack.pop();\\n                if (stack.isEmpty() || stack.peek() != \\'a\\') return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247666,
                "title": "python-solution-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        if len(S) <3:\\n            return False\\n        \\n        na = nb = nc = 0\\n        for c in S:\\n            if c == \\'a\\':\\n                na += 1\\n            elif c == \\'b\\':\\n                nb += 1\\n            else:\\n                nc += 1\\n            \\n            if nb > na or nc > na or nc > nb:\\n                return False\\n        return na == nb == nc\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        if len(S) <3:\\n            return False\\n        \\n        na = nb = nc = 0\\n        for c in S:\\n            if c == \\'a\\':\\n                na += 1\\n            elif c == \\'b\\':\\n                nb += 1\\n            else:\\n                nc += 1\\n            \\n            if nb > na or nc > na or nc > nb:\\n                return False\\n        return na == nb == nc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097834,
                "title": "simple-python-3-line-solution-beats-99-68-users-in-memory-and-89-59-users-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while(\"abc\" in s):\\n            s=s.replace(\"abc\",\"\")\\n        return True if len(s)==0 else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while(\"abc\" in s):\\n            s=s.replace(\"abc\",\"\")\\n        return True if len(s)==0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076776,
                "title": "beats-95-5-simple-approach",
                "content": "# Intuition\\nThis code is designed to check if a given string s follows a specific pattern. The pattern consists of \"a\"s followed by \"b\"s, and each \"b\" is preceded by an \"a\". The code uses a stack data structure to keep track of the characters in the string while processing it.\\n\\n# Approach\\nThe code starts by checking if the first character of the string s is \\'a\\'. If it\\'s not, the function returns false immediately.\\n\\nIt then initializes an empty stack st to help keep track of the characters as it processes the string.\\n\\nIt iterates through each character ch in the string:\\n\\nIf ch is \\'a\\', it pushes \\'a\\' onto the stack.\\nIf ch is \\'b\\', it checks if the stack is not empty and the top of the stack is \\'a\\'. If so, it pushes \\'b\\' onto the stack.\\nIf ch is neither \\'a\\' nor \\'b\\', it returns false because the string contains invalid characters.\\nAfter processing all characters, the code checks if the stack is empty. If the stack is empty, it means that the string has been properly matched according to the pattern, and the function returns true. Otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        if(s[0]!= \\'a\\') return false;\\n\\n        stack<char> st;\\n\\n        for(char ch:s) {\\n            if(ch == \\'a\\') {\\n                st.push(ch);\\n            }\\n            else if(ch == \\'b\\') {\\n                if(!st.empty() && st.top() == \\'a\\') {\\n                    st.push(ch);\\n                } \\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if(!st.empty() && st.top() == \\'b\\') {\\n                    st.pop();\\n                    if(!st.empty() && st.top() == \\'a\\') {\\n                        st.pop();\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        if(s[0]!= \\'a\\') return false;\\n\\n        stack<char> st;\\n\\n        for(char ch:s) {\\n            if(ch == \\'a\\') {\\n                st.push(ch);\\n            }\\n            else if(ch == \\'b\\') {\\n                if(!st.empty() && st.top() == \\'a\\') {\\n                    st.push(ch);\\n                } \\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if(!st.empty() && st.top() == \\'b\\') {\\n                    st.pop();\\n                    if(!st.empty() && st.top() == \\'a\\') {\\n                        st.pop();\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070854,
                "title": "vector-simple-fast-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake one vector to check last element is present or not ,\\nif char is c then it means there are a and b are present if they are not consecutive to c -b then it is not valid ,\\nif during pop operation of b and c if vector is empty then it it is not valid \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) for worst case ,else o(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isValid(string s) {\\n    int n=s.size();\\n    if(n%3!=0) return false;\\n\\n    // stack<char>st;\\n    vector<char>st;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'c\\' && !st.empty()) {\\n            char top1=st.back();st.pop_back();\\n            if(st.empty()) return false;\\n            char top2=st.back();st.pop_back();\\n\\n            if(top1==\\'b\\' && top2==\\'a\\') continue;\\n            else return false;\\n        }\\n        else st.push_back(s[i]);\\n    }\\n    if(!st.empty())return false;\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isValid(string s) {\\n    int n=s.size();\\n    if(n%3!=0) return false;\\n\\n    // stack<char>st;\\n    vector<char>st;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'c\\' && !st.empty()) {\\n            char top1=st.back();st.pop_back();\\n            if(st.empty()) return false;\\n            char top2=st.back();st.pop_back();\\n\\n            if(top1==\\'b\\' && top2==\\'a\\') continue;\\n            else return false;\\n        }\\n        else st.push_back(s[i]);\\n    }\\n    if(!st.empty())return false;\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063688,
                "title": "golang-stack-implementation",
                "content": "# Code\\n```\\nimport \"unicode/utf8\"\\n\\ntype Stack struct {\\n\\ttop  int\\n\\tdata []rune\\n}\\n\\nfunc NewStack(maxSize int) *Stack {\\n\\tdata := make([]rune, maxSize)\\n\\treturn &Stack{\\n\\t\\ttop:  -1,\\n\\t\\tdata: data,\\n\\t}\\n}\\n\\nfunc (s *Stack) push(ch rune) {\\n\\ts.data[s.top+1] = ch\\n\\ts.top++\\n\\n}\\n\\nfunc (s *Stack) peek(depth int) rune {\\n\\treturn s.data[s.top-depth]\\n}\\n\\nfunc (s *Stack) pop() rune {\\n\\tdefer func() {\\n\\t\\ts.top--\\n\\t}()\\n\\treturn s.data[s.top]\\n}\\n\\nfunc (s *Stack) isEmpty() bool {\\n\\treturn s.top == -1\\n}\\n\\nfunc (s *Stack) size() int {\\n\\treturn s.top + 1\\n}\\n\\nfunc isValid(s string) bool {\\n\\tn := utf8.RuneCountInString(s) // len(s) can also be used in this case as the characters are known at compile time. But len(s) may give unexpected results sometimes.\\n    // For example : s = \"\\xA3\", then len(s) returns 2, whereas RuneCountInString(s) returns 1\\n\\n\\tif s[0] != \\'a\\' || s[n-1] != \\'c\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tstack := NewStack(n)\\n\\tinput := []rune(s)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\t\\n\\t\\t// if the char is \\'a\\' or \\'b\\'\\n\\t\\tif input[i] == \\'a\\' || input[i] == \\'b\\' {\\n\\t\\t\\tstack.push(input[i])\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// if the char is \\'c\\'\\n\\t\\t\\n\\t\\tif stack.size() < 2 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tif stack.peek(0) != \\'b\\' || stack.peek(1) != \\'a\\' {\\n\\t\\t\\treturn false\\n\\t\\t} \\n\\t\\t\\n\\t\\tstack.pop()\\n\\t\\tstack.pop()\\n\\t}\\n\\n\\treturn stack.isEmpty()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"unicode/utf8\"\\n\\ntype Stack struct {\\n\\ttop  int\\n\\tdata []rune\\n}\\n\\nfunc NewStack(maxSize int) *Stack {\\n\\tdata := make([]rune, maxSize)\\n\\treturn &Stack{\\n\\t\\ttop:  -1,\\n\\t\\tdata: data,\\n\\t}\\n}\\n\\nfunc (s *Stack) push(ch rune) {\\n\\ts.data[s.top+1] = ch\\n\\ts.top++\\n\\n}\\n\\nfunc (s *Stack) peek(depth int) rune {\\n\\treturn s.data[s.top-depth]\\n}\\n\\nfunc (s *Stack) pop() rune {\\n\\tdefer func() {\\n\\t\\ts.top--\\n\\t}()\\n\\treturn s.data[s.top]\\n}\\n\\nfunc (s *Stack) isEmpty() bool {\\n\\treturn s.top == -1\\n}\\n\\nfunc (s *Stack) size() int {\\n\\treturn s.top + 1\\n}\\n\\nfunc isValid(s string) bool {\\n\\tn := utf8.RuneCountInString(s) // len(s) can also be used in this case as the characters are known at compile time. But len(s) may give unexpected results sometimes.\\n    // For example : s = \"\\xA3\", then len(s) returns 2, whereas RuneCountInString(s) returns 1\\n\\n\\tif s[0] != \\'a\\' || s[n-1] != \\'c\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tstack := NewStack(n)\\n\\tinput := []rune(s)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\t\\n\\t\\t// if the char is \\'a\\' or \\'b\\'\\n\\t\\tif input[i] == \\'a\\' || input[i] == \\'b\\' {\\n\\t\\t\\tstack.push(input[i])\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// if the char is \\'c\\'\\n\\t\\t\\n\\t\\tif stack.size() < 2 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tif stack.peek(0) != \\'b\\' || stack.peek(1) != \\'a\\' {\\n\\t\\t\\treturn false\\n\\t\\t} \\n\\t\\t\\n\\t\\tstack.pop()\\n\\t\\tstack.pop()\\n\\t}\\n\\n\\treturn stack.isEmpty()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4050775,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.length()<3)\\n        {\\n            return false;\\n        }\\n        else if(s.length()==3)\\n        {\\n            if(s==\"abc\")\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'b\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(st.size()<2)\\n                {\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    char c1=st.top();\\n                    st.pop();\\n                    char c2=st.top();\\n                    st.pop();\\n                    if(c1==\\'b\\' and c2==\\'a\\')\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        st.push(c2);\\n                        st.push(c1);\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        if(st.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.length()<3)\\n        {\\n            return false;\\n        }\\n        else if(s.length()==3)\\n        {\\n            if(s==\"abc\")\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'b\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(st.size()<2)\\n                {\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    char c1=st.top();\\n                    st.pop();\\n                    char c2=st.top();\\n                    st.pop();\\n                    if(c1==\\'b\\' and c2==\\'a\\')\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        st.push(c2);\\n                        st.push(c1);\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        if(st.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040725,
                "title": "simple-stack-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n\\n        for(auto it:s)\\n        {   st.push(it);\\n            if(it==\\'c\\')\\n            {\\n                if(st.size()>=3)\\n                {\\n                    char x=st.top();\\n                    st.pop();\\n                     char y=st.top();\\n                    st.pop();\\n                     char z=st.top();\\n                    st.pop();\\n\\n                    if(y==\\'b\\' && z==\\'a\\')\\n                    continue;\\n                    else\\n                    return false;\\n                }\\n                else\\n                return false;\\n            }\\n        }\\n\\n        return st.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n\\n        for(auto it:s)\\n        {   st.push(it);\\n            if(it==\\'c\\')\\n            {\\n                if(st.size()>=3)\\n                {\\n                    char x=st.top();\\n                    st.pop();\\n                     char y=st.top();\\n                    st.pop();\\n                     char z=st.top();\\n                    st.pop();\\n\\n                    if(y==\\'b\\' && z==\\'a\\')\\n                    continue;\\n                    else\\n                    return false;\\n                }\\n                else\\n                return false;\\n            }\\n        }\\n\\n        return st.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025340,
                "title": "c-easy-brute-force-approach-just-do-what-ask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      int sz=s.size();\\n      \\n        for(int i=sz-1;i>=0;i--)\\n         {\\n            //if it is \\'a\\' then we can start extracting \"abc\"from string\\n              if(s[i]==\\'a\\')\\n                {\\n                  //we exctract 3 character from \\'a\\' \\n                     string str1=s.substr(i,3);\\n                    //if it not \"abc\" then we return false becuase in the question it is given that string is concat of \"abc\"\\n                       if(str1!=\"abc\")\\n                                 return false;\\n                                 //otherwise we reduce out string and erase \"abc\" from it\\n                    s=s.substr(0,i)+s.substr(i+3);\\n                    \\n                \\n                }\\n         }\\n         //if the string is greater then 0 then we return false othwerise we return true string is empty \"\" and we reach result\\n       \\n         return s.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      int sz=s.size();\\n      \\n        for(int i=sz-1;i>=0;i--)\\n         {\\n            //if it is \\'a\\' then we can start extracting \"abc\"from string\\n              if(s[i]==\\'a\\')\\n                {\\n                  //we exctract 3 character from \\'a\\' \\n                     string str1=s.substr(i,3);\\n                    //if it not \"abc\" then we return false becuase in the question it is given that string is concat of \"abc\"\\n                       if(str1!=\"abc\")\\n                                 return false;\\n                                 //otherwise we reduce out string and erase \"abc\" from it\\n                    s=s.substr(0,i)+s.substr(i+3);\\n                    \\n                \\n                }\\n         }\\n         //if the string is greater then 0 then we return false othwerise we return true string is empty \"\" and we reach result\\n       \\n         return s.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021586,
                "title": "easy-beginner-friendly-recursion-naive-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove all occurances of abc from given string.\\nBasically transform s into t ie...convert given string into empty string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse STL find() to get the first occurance of \"abc\". Now divide the string into 2 parts. First part before the starting index of \"abc\" and the second part after \"abc\". \\nNow call recursion for our new string without \"abc\". If string size becomes 0, then return true.\\n\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N) -> recursive space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.size()==0)\\n            return true;\\n        \\n        int n = s.length();\\n        int find = s.find(\"abc\");\\n        if(find != string :: npos)\\n        {\\n            string t1 = s.substr(0, find); //1st part before \"abc\"\\n            string t2 = s.substr(find+3, n); //2nd part after \"abc\"\\n\\n            return isValid(t1+t2); \\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.size()==0)\\n            return true;\\n        \\n        int n = s.length();\\n        int find = s.find(\"abc\");\\n        if(find != string :: npos)\\n        {\\n            string t1 = s.substr(0, find); //1st part before \"abc\"\\n            string t2 = s.substr(find+3, n); //2nd part after \"abc\"\\n\\n            return isValid(t1+t2); \\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017601,
                "title": "swift-optimal-beating-50-users",
                "content": "# Intuition\\nTo replace the occurences of \"abc\" and finally check the given string.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        // ss is a copy of s that can be modified\\n        var ss = s\\n        // as long as ss has \"abc\"\\n        while ss.contains(\"abc\"){\\n            if ss.contains(\"abc\"){\\n                // replacing \"abc\"s with blanks as many times found\\n                ss = ss.replacingOccurrences(of: \"abc\", with: \"\")\\n            }\\n        }\\n        // returning an emoty (true) ss means the format was valid, else invalid\\n        return ss.isEmpty\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        // ss is a copy of s that can be modified\\n        var ss = s\\n        // as long as ss has \"abc\"\\n        while ss.contains(\"abc\"){\\n            if ss.contains(\"abc\"){\\n                // replacing \"abc\"s with blanks as many times found\\n                ss = ss.replacingOccurrences(of: \"abc\", with: \"\")\\n            }\\n        }\\n        // returning an emoty (true) ss means the format was valid, else invalid\\n        return ss.isEmpty\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011372,
                "title": "c-easy-memory-beating-98-users-with-comments",
                "content": "# Intuition\\nTo check the given string multiple times and manipulate to see if the \"abc\" pattern still exists.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // as long as s has \\'abc\\'\\n        while(s.find(\"abc\") != string::npos){\\n            if(s.find(\"abc\") != string::npos){\\n                // replacing the \\'abc\\' of s with blank space every time found\\n                s = s.replace(s.find(\"abc\"), sizeof(\"abc\") - 1, \"\");\\n            }\\n        }\\n        // finally checking if s was supposed to remain valid after replacing those \\'abc\\'s (one or more as given inside s)\\n        return s.empty();\\n            }\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // as long as s has \\'abc\\'\\n        while(s.find(\"abc\") != string::npos){\\n            if(s.find(\"abc\") != string::npos){\\n                // replacing the \\'abc\\' of s with blank space every time found\\n                s = s.replace(s.find(\"abc\"), sizeof(\"abc\") - 1, \"\");\\n            }\\n        }\\n        // finally checking if s was supposed to remain valid after replacing those \\'abc\\'s (one or more as given inside s)\\n        return s.empty();\\n            }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011049,
                "title": "c-stack-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i=0;i<n;i++){\\n            if(!st.empty() && s[i]==\\'c\\' && st.top()==\\'b\\'){\\n                st.pop();\\n                if(st.empty()){\\n                    st.push(\\'b\\');\\n                    st.push(\\'c\\');\\n                }\\n                else{\\n                    char ch = st.top();\\n                    st.pop();\\n                    if(ch !=\\'a\\'){\\n                        st.push(ch);\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                }\\n            }\\n            else{\\n            st.push(s[i]);\\n            }\\n        }\\n        if(st.empty()) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i=0;i<n;i++){\\n            if(!st.empty() && s[i]==\\'c\\' && st.top()==\\'b\\'){\\n                st.pop();\\n                if(st.empty()){\\n                    st.push(\\'b\\');\\n                    st.push(\\'c\\');\\n                }\\n                else{\\n                    char ch = st.top();\\n                    st.pop();\\n                    if(ch !=\\'a\\'){\\n                        st.push(ch);\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                }\\n            }\\n            else{\\n            st.push(s[i]);\\n            }\\n        }\\n        if(st.empty()) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002844,
                "title": "concise-and-clear-code-using-stack-in-java",
                "content": "# Intuition\\nJust a simple approach man we need to check for the string \"abc\" so keep storing \\'a\\' and \\'b\\' in stack but as soon as you get \\'c\\' , pop \\'b\\' and \\'a\\' from the stack and if you finds that the top of the stack doesn\\'t have \\'b\\' and \\'a\\' at the top or the stack is empty then simply return false and at the end if the stack is not empty return false otherwise return true.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character>stack = new Stack<>();\\n        for(char ch:s.toCharArray()){\\n            if(ch!=\\'c\\') stack.push(ch);\\n            else{\\n                if(stack.isEmpty() || stack.pop()!=\\'b\\') return false;\\n                if(stack.isEmpty() || stack.pop()!=\\'a\\') return false;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character>stack = new Stack<>();\\n        for(char ch:s.toCharArray()){\\n            if(ch!=\\'c\\') stack.push(ch);\\n            else{\\n                if(stack.isEmpty() || stack.pop()!=\\'b\\') return false;\\n                if(stack.isEmpty() || stack.pop()!=\\'a\\') return false;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000091,
                "title": "easy-brute-force-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) \\n    {\\n     Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.size()<=1)\\n            {\\n                st.push(s.charAt(i));\\n            }\\n            else\\n            {\\n                char c=s.charAt(i);\\n                char b=st.pop();\\n                char a=st.pop();\\n                String temp=a+\"\"+b+\"\"+c+\"\";\\n                if(temp.equals(\"abc\")==false)\\n                {\\n                    st.push(a);\\n                    st.push(b);\\n                    st.push(c);\\n                }\\n                \\n            }\\n                \\n        }\\n        // System.out.println(st);\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) \\n    {\\n     Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.size()<=1)\\n            {\\n                st.push(s.charAt(i));\\n            }\\n            else\\n            {\\n                char c=s.charAt(i);\\n                char b=st.pop();\\n                char a=st.pop();\\n                String temp=a+\"\"+b+\"\"+c+\"\";\\n                if(temp.equals(\"abc\")==false)\\n                {\\n                    st.push(a);\\n                    st.push(b);\\n                    st.push(c);\\n                }\\n                \\n            }\\n                \\n        }\\n        // System.out.println(st);\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998418,
                "title": "check-if-word-is-valid-after-substitutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-  A naive approach to validating a string involves repeatedly removing \\'abc\\' triplets from the string until no more can be removed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Force Approach (O(N^2)): A naive approach to validating a string involves repeatedly removing \\'abc\\' triplets from the string until no more can be removed. This method has a time complexity of O(N^2), as it may require multiple passes through the string, with each pass potentially removing one or more triplets.\\n\\n\\n- Optimal Approach (O(N)): The optimal solution uses a stack to efficiently validate the string in a single pass. It checks each character against the \\'abc\\' pattern, popping \\'ba\\' when \\'c\\' is encountered. This approach has a linear time complexity of O(N), where N is the length of the input string, making it more efficient and scalable than the brute force method.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st; // Initialize a stack to keep track of characters.\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'c\\') { // If the current character is \\'c\\'.\\n                if (st.size() >= 2 && st.top() == \\'b\\') { // Check if there are at least two characters in the stack and the top character is \\'b\\'.\\n                    st.pop(); // Pop \\'b\\'.\\n                    if (st.top() == \\'a\\') { // Check if the character before \\'b\\' is \\'a\\'.\\n                        st.pop(); // Pop \\'a\\'.\\n                    } else {\\n                        return false; // Invalid sequence if \\'a\\' is not before \\'b\\'.\\n                    }\\n                } else {\\n                    return false; // Invalid sequence if \\'b\\' is not on top of the stack or there are fewer than two characters in the stack.\\n                }\\n            } else {\\n                st.push(s[i]); // Push characters other than \\'c\\' onto the stack.\\n            }\\n        }\\n\\n        return st.empty(); // If the stack is empty at the end, the string is valid; otherwise, it\\'s not valid.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st; // Initialize a stack to keep track of characters.\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'c\\') { // If the current character is \\'c\\'.\\n                if (st.size() >= 2 && st.top() == \\'b\\') { // Check if there are at least two characters in the stack and the top character is \\'b\\'.\\n                    st.pop(); // Pop \\'b\\'.\\n                    if (st.top() == \\'a\\') { // Check if the character before \\'b\\' is \\'a\\'.\\n                        st.pop(); // Pop \\'a\\'.\\n                    } else {\\n                        return false; // Invalid sequence if \\'a\\' is not before \\'b\\'.\\n                    }\\n                } else {\\n                    return false; // Invalid sequence if \\'b\\' is not on top of the stack or there are fewer than two characters in the stack.\\n                }\\n            } else {\\n                st.push(s[i]); // Push characters other than \\'c\\' onto the stack.\\n            }\\n        }\\n\\n        return st.empty(); // If the stack is empty at the end, the string is valid; otherwise, it\\'s not valid.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570083,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1849248,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1572504,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1948758,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1947358,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1821995,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            }
        ]
    },
    {
        "title": "Shuffle the Array",
        "question_content": "<p>Given the array <code>nums</code> consisting of <code>2n</code> elements in the form <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code>.</p>\r\n\r\n<p><em>Return the array in the form</em> <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2,5,1,3,4,7], n = 3\r\n<strong>Output:</strong> [2,3,5,4,1,7] \r\n<strong>Explanation:</strong> Since x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 then the answer is [2,3,5,4,1,7].\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4,4,3,2,1], n = 4\r\n<strong>Output:</strong> [1,4,2,3,3,2,4,1]\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,2,2], n = 2\r\n<strong>Output:</strong> [1,2,1,2]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\r\n\t<li><code>nums.length == 2n</code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 675956,
                "title": "in-place-o-n-time-o-1-space-with-explanation-analysis",
                "content": "**COMPLEXITY:**\\n* Time: O(n) where n = nums.length\\n* Space: O(1)\\n\\n<hr>\\n\\n**EXPLANATION:**\\n\\n**Prerequisites:**\\nSome bit manipulation knowledge will be helpful in understanding this algorithm. This algorithm uses:\\n* Bitwise AND ```&```\\n* Bitwise OR ```|```\\n* Left Shift ```<<```\\n* Right Shift ```>>```\\n* Binary Representations of Numbers\\n\\n\\n**Intuition:**\\n* This in-place algorithm relies on the constraint ```1 <= nums[i] <= 10^3```. This means the largest possible number in the nums array is ```1000```. \\n* The binary representation of ```1000``` is ```1111101000```.\\n* If we count the number of bits in ```1111101000``` we get 10.\\n* Because the largest possible number only uses 10 bits, we can fit two numbers into one 32-bit binary representation.\\n* This means we can store pairs of numbers in one binary representation without fear of overwriting a number.\\n\\n**Implementation:**\\nAs shown in the description of the problem, the array starts in the form ```[x1,x2,...,xn,y1,y2,...,yn]```\\n\\nThis algorithm will use two loops:\\n1. **Loop 1** will group the numbers into pairs ```[x1, y1], [x2, y2]... [xn,yn]``` by storing both numbers ```xn``` and ```yn``` in one binary representation.\\n2. **Loop 2** will then place these pairs in their final position.\\n\\n**How do we store two numbers in one binary representation?**\\n\\nWe will use two pointers ```i``` and ```j```:\\n```i``` will traverse backwards from ```n``` to ```0```.\\n```j``` will traverse backwards from the end of the array to ```n```.\\n\\nStore both ```nums[i]``` and ```nums[j]``` in ```nums[j]```.\\n\\n1. Because ```nums[j]``` is already storing its number we do not need to add it. Instead we need to left shift this number over by ```10``` bits to make room to add the second number ```nums[i]```. We shift it over by ```10``` bits because the largest possible number is ```1000``` which uses ```10``` bits.\\n```\\nnums[j] <<= 10\\n```\\n2. To add nums[i] we can Bitwise OR ```nums[i]``` with ```nums[j]```: \\n```\\nnums[j] |= nums[i]\\n```\\n\\n**Loop 1:**\\n\\nWhen using the following input, Loop 1 will look like the example below:\\n```nums = [1,2,3,4,4,3,2,1]```, ```n = 4```\\n\\nNotes:\\n* In the below example ```[2,3]``` represents the two numbers ```2``` and ```3``` stored in one binary representation.\\n* The reason we traverse backwards and store the pairs in the last n numbers is so that when we do a forward traversal for Loop 2 to place numbers in their final place we do not overwrite numbers along the way.\\n```\\n      i       j\\n1 2 3 4 4 3 2 1\\n\\n    i       j\\n1 2 3 4 4 3 2 [1,4]\\n\\n\\n  i       j\\n1 2 3 4 4 3 [2,3] [1,4]\\n\\ni       j\\n1 2 3 4 4 [3,2] [2,3] [1,4]\\n\\n1 2 3 4 [4,1] [3,2] [2,3] [1,4]\\n```\\n\\n\\n**Loop 2:**\\nLoop 2 will now place numbers in the final position.\\n\\nWe will use two pointers ```i``` and ```j```.\\n```i``` will traverse forwards from 0 to n.\\n```j``` will traverse forwards from n to the end of the array.\\n\\nThe final numbers for positions``` nums[i]``` and ```nums[i + 1]``` can be found in the binary representation at ```nums[j]```.\\n* Get both numbers from ```nums[j]``` and update ```nums[i]``` and ```nums[i + 1]```\\n* Increment ```i``` by ```2``` to place the next pair.\\n* Increment ```j``` by ```1``` to get the numbers for the next two positions ```nums[i]``` and ```nums[i + 1]```\\n\\n**How do we get the two numbers out of ```nums[j]```?**\\n1. To get the first number we will Bitwise AND ```nums[j]``` with ```1023```. We use ```1023``` because the largest possible number is ```1000``` which uses ```10``` bits. ```10``` bits of all 1s is ```1111111111``` which is the binary representation of ```1023```. Bitwise AND with ```1023``` will cancel out any number after the first ```10``` bits and we\\'ll be left with the first number only.\\n```\\nconst num1 = nums[j] & 1023\\n```\\n2. To get the second number we right shift the number back over 10 places.      \\n```\\nconst num2 = nums[j] >> 10\\n```\\n\\n<hr>\\n\\n**SOLUTION:**\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let i = n - 1\\n    for (let j = nums.length - 1; j >= n; j--) {\\n        nums[j] <<= 10\\n        nums[j] |= nums[i]\\n        i--\\n    }\\n    \\n    i = 0\\n    for (let j = n; j < nums.length; j++) {\\n        const num1 = nums[j] & 1023\\n        const num2 = nums[j] >> 10\\n        nums[i] = num1\\n        nums[i + 1] = num2\\n        i += 2    \\n    }\\n    \\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```&```\n```|```\n```<<```\n```>>```\n```1 <= nums[i] <= 10^3```\n```1000```\n```1000```\n```1111101000```\n```1111101000```\n```[x1,x2,...,xn,y1,y2,...,yn]```\n```[x1, y1], [x2, y2]... [xn,yn]```\n```xn```\n```yn```\n```i```\n```j```\n```i```\n```n```\n```0```\n```j```\n```n```\n```nums[i]```\n```nums[j]```\n```nums[j]```\n```nums[j]```\n```10```\n```nums[i]```\n```10```\n```1000```\n```10```\n```\\nnums[j] <<= 10\\n```\n```nums[i]```\n```nums[j]```\n```\\nnums[j] |= nums[i]\\n```\n```nums = [1,2,3,4,4,3,2,1]```\n```n = 4```\n```[2,3]```\n```2```\n```3```\n```\\n      i       j\\n1 2 3 4 4 3 2 1\\n\\n    i       j\\n1 2 3 4 4 3 2 [1,4]\\n\\n\\n  i       j\\n1 2 3 4 4 3 [2,3] [1,4]\\n\\ni       j\\n1 2 3 4 4 [3,2] [2,3] [1,4]\\n\\n1 2 3 4 [4,1] [3,2] [2,3] [1,4]\\n```\n```i```\n```j```\n```i```\n```j```\n``` nums[i]```\n```nums[i + 1]```\n```nums[j]```\n```nums[j]```\n```nums[i]```\n```nums[i + 1]```\n```i```\n```2```\n```j```\n```1```\n```nums[i]```\n```nums[i + 1]```\n```nums[j]```\n```nums[j]```\n```1023```\n```1023```\n```1000```\n```10```\n```10```\n```1111111111```\n```1023```\n```1023```\n```10```\n```\\nconst num1 = nums[j] & 1023\\n```\n```\\nconst num2 = nums[j] >> 10\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let i = n - 1\\n    for (let j = nums.length - 1; j >= n; j--) {\\n        nums[j] <<= 10\\n        nums[j] |= nums[i]\\n        i--\\n    }\\n    \\n    i = 0\\n    for (let j = n; j < nums.length; j++) {\\n        const num1 = nums[j] & 1023\\n        const num2 = nums[j] >> 10\\n        nums[i] = num1\\n        nums[i + 1] = num2\\n        i += 2    \\n    }\\n    \\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314638,
                "title": "java-c-simple-o-1-space-in-place-100-faster-efficient-explained",
                "content": "<u>**BASIC IDEA:**</u>\\n1. **Store the pair of numbers** and then\\n2. **Retreive each number,** from that pair where they were stored, **one by one** and place them at their desired positions.\\n\\n<u>**GENERAL EXAMPLE:**</u>\\n*Suppose, you are performing a task and someone gives you another task, in order to avoid disturbance in the flow of previous task, you can keep both the tasks on one side and complete the task one by one according to the requirement.*\\n\\n<u>**SAME CONCEPT FOR ARRAYS:**</u>\\n*In order to avoid overwriting values, store the \"pair of numbers\" in the right half of the array and retrieve the numbers by one according to the requirement.*\\n\\n**#  <u>DETAILED EXPLANATION IS GIVEN BELOW THE CODE</u> #**\\n\\n<u>**NOTE:**</u>  --> Runtime Fluctuates a lot in case of C++(0ms to 4ms)\\n\\n<u>**C++ / JAVA CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/arHM8WHa/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n<hr>\\n\\n**Using Bitwise Operator to make it a bit faster**<br>\\n\\n<u>**NOTE:**</u>  --> Runtime Fluctuates a lot in case of C++(0ms to 4ms)\\n\\n<u>**C++ / JAVA CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/QHAeabD9/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\n<hr>\\n\\n<u>**EXPLANATION:**</u>\\n\\n**Let\\'s understand in general term:**\\n\\nSuppose we have 2 numbers `num1 = 4` and `num2 = 9` and `maxValue = 10`\\n**Formula:**\\n**to store** -> pair = (num2 &times; maxValue) + num1\\n**to retrieve** -> pair % maxValue and pair / maxValue\\n\\n1. **Storing the pair of numbers**\\n\\n\\t(9 &times; 10) + 4 = 94 --> from above formula (num2 &times; maxValue) + num1\\n\\t**94 is stored**\\n\\n2. **Retrieving each number one by one**\\n\\n\\t94 % 10 = 4\\n\\t**we got first number as 4**\\n\\n\\t94 / 10 = 9\\n\\t**we got second number as 9**\\n\\nSame idea goes for large cases and array as well but instead of 10, we will take 1024 to store pairs and retrieve each number\\n**<u>NOTE:</u> Here, we will take 1024 because of the given constraints `1 <= nums[i] <= 10^3` i.e. the largest number in the array will be 1000**\\n\\nNow, \\n**Binary representation** of **1000** is **1111101000**, consisting of total **10 bits**\\n**Binary representation** of **1024** is **10000000000**, consisting of total **11 bits**\\nand if we multiply 1000 with 1024 i.e. **(1000 * 1024)**, we will get **1024000**\\n**Binary representation** of **1024000** is **11111010000000000000**, consisting of total **20 bits** which is less than the number of bits **(32bits)** of int data type, so we can store the number pairs(by multiplying one number with 1024 and adding another number to it) to retrieve each indivisual number later on(by taking out the remainder and the quotient).\\neg: suppose we have an **`array of length 4`** and **`n is 2`**\\n`nums = [5, 2, 1000, 3]` and `n = 2`\\n\\n1. **We will store the pair of numbers first**\\n\\n\\tAccording to algorithm\\n\\t\\n\\t```\\n\\t// to store the pair of numbers in right half of the original array\\n\\tfor(int i = n; i < len; i++)\\n\\tnums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t```\\n\\t* \\t**Iteration 1:**\\n\\t\\twhen i = 2, (i = 2 because value of n is 2)\\n\\t\\tnums[2] = (1000 &times; 1024) + 5 \\n\\t\\tso, nums[2] = 1024005\\n\\n\\t* \\t**Iteration 2:**\\n\\t\\twhen i = 3,\\n\\t\\tnums[3] = (3 &times; 1024) + 2\\n\\t\\tso, nums[3] = 3074\\n\\n\\t**Now, the original array**\\n\\t[5, 2, 1000, 3]\\n\\t&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;<-- Indexes\\n\\t**becomes**\\n\\t[5, 2, 1024005, 3074]\\n\\t&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;<-- Indexes\\n\\n2. **We will retrieve the numbers one by one from the pairs which we have stored at 2nd and 3rd index**\\n\\n\\tAccording to algorithm\\n\\t```\\n\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n\\tint index = 0;\\n\\tfor(int i = n; i < len; i++, index += 2){\\n\\t\\tnums[index] = nums[i] % 1024;\\n\\t\\tnums[index + 1] = nums[i] / 1024;\\n\\t}\\n\\t```\\n\\n\\t* \\t**Iteration 1:**\\n\\t\\twhen index = 0 and i = 2, (i = 2 because value of n is 2)\\n\\t\\tnums[0] = 1024005 % 1024 = 5\\n\\t\\tnums[1] = 1024005 / 1024 = 1000\\n\\t\\tnow, index = 2 (from index += 2)\\n\\n\\t* \\t**Iteration 2:**\\n\\t\\twhen index = 2, i = 3,\\n\\t\\tnums[2] = 3074 % 1024 = 2\\n\\t\\tnums[3] = 3074 / 1024 = 3\\n\\n\\tIteration will be stopped now as the condition become false and we got the array as following\\n\\t**[5, 1000, 2, 3]  <-- Desired Output**\\n\\t&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;<-- Indexes\\n<hr>\\n\\n<u>**COMPLEXITY:**</u>\\n* **Time: O(n)**, where n is the given number, which is half of the length of the array\\n* **Space: O(1)**, in-place<br>\\n\\nSince we need to solve it in 0(1) space or **in-place**, we will use the original array.\\n<hr>\\n\\n**You might be wondering why I took** `1024`\\nLet\\'s understand why\\n\\n**One Line answer**\\nMultiply by number which is greater than both of num1 and num2(max num1 or num2 can be 1000 or 10 ^ 3)\\n\\n**Long answer**\\nLet\\'s understand in general term i.e. 1 <= num1,  num2 <= 10 i.e. min value of num1 and num2 can be 1 and max value can be 10\\n\\nNow, suppose 2 numbers num1 = 10 and num2 = 4 and maxValue = 10\\n**Formula:**\\n**to store** -> pair = (num2 * maxValue) + num1\\n**to retrieve** -> pair % maxValue and pair / maxValue\\n\\n1. **Storing the pair of numbers**\\n\\n\\t4 * 10 + 10 = 50 --> from above formula (num2 * maxValue) + num1\\n\\t**50 is stored**\\n\\n2. **Retrieving each number one by one**\\n\\n\\t50 % 10 = 0 \\n\\t**we got first number as 0** -- > not what we wanted\\n\\n\\t50 / 10 = 5 \\n\\t**we got second number as 5** -- > not what we wanted\\n\\nNow, suppose 2 numbers num1 = 10 and num2 = 4 and maxValue = 11(here max value is different from above)\\n1. **Storing the pair of numbers**\\n\\n\\t4 * 11 + 10 = 54 --> from above formula (num2 * maxValue) + num1\\n\\t**54 is stored**\\n\\n2. **Retrieving each number one by one**\\n\\n\\t54 % 11 = 10\\n\\t**we got first number as 10** -- > what we wanted\\n\\n\\t54 / 11 = 4\\n\\t**we got second number as 4** -- > what we wanted\\n\\nSo, we can conclude that **multiply by number which is greater than both of num1 and num2.**\\neg:\\nfor(0 to 9) take 10(i.e. greater than 0 and 9)\\nfor(0 to 19) take 20(i.e. greater than 0 and 19)\\nfor(0 to 29) take 30(i.e. greater than 0 and 29) and so on\\n\\nSame idea goes for large cases and array as well but instead of 10, we will take 1024(as max value can be 1000 according to constraints) to store pairs and retrieve each number.\\n\\nHere, we are taking 1024 because of the given constraints **1 <= nums[i] <= 10^3** i.e. the largest number in the array will be `1000`.\\n**NOTE: we could have taken `1001`(according to constraints) instead of `1024` but took `1024` because 2<sup>10</sup> will give 1024 and will be easier to use this value(1024) while performing bitwise operation as 1024 is a power of 2 and multiplying 1024 * 1000(max value according to constraint) fits in 32 bits of int and there will be no overflow.**\\n\\n<strong>Try taking 1001 (will give desired output)</strong>\\n![image](https://assets.leetcode.com/users/images/4077adb7-92eb-4df4-bc01-e57048f6facc_1629368199.7840974.png)\\n<hr>\\n<br>\\n\\n<strong>And now try taking 1000 (will not give desired output)</strong>\\n![image](https://assets.leetcode.com/users/images/9dc75c5d-42e3-47ec-9b37-4abbcef021f4_1629368059.1304839.png)\\n\\n<strong>Multiplying with 1000 and retrieving values by nums[i] % 1000 and nums[i] / 1000 will not give you the desired output</strong>\\n<hr>\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<hr>\\n\\n# **Please Upvote If you got any help from the provided solution!!!**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\\t// to store the pair of numbers in right half of the original array\\n\\tfor(int i = n; i < len; i++)\\n\\tnums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t```\n```\\n\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n\\tint index = 0;\\n\\tfor(int i = n; i < len; i++, index += 2){\\n\\t\\tnums[index] = nums[i] % 1024;\\n\\t\\tnums[index + 1] = nums[i] / 1024;\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 674309,
                "title": "java-straightforward-1-loop",
                "content": "No need to explain, right?\\n```\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[2 * n];\\n        for (int i = 0, j = n, idx = 0; idx < res.length; i++, j++) {\\n            res[idx++] = nums[i];\\n            res[idx++] = nums[j];\\n        } \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[2 * n];\\n        for (int i = 0, j = n, idx = 0; idx < res.length; i++, j++) {\\n            res[idx++] = nums[i];\\n            res[idx++] = nums[j];\\n        } \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675007,
                "title": "python-o-n-time-o-1-space-detailed-explanation",
                "content": "1. Each \"nums[i]\" has a \"desired\" index. \\ne.g. for an array of 8 numbers, nums[0] wants to go to index \"0\", nums[4] wants to go to index \"1\", nums[1] wants to go to index \"2\", nums[5] wants to go to index \"3\", nums[2] wants to go to index \"4\"... \\nThe target index of nums[i] is nums[i]\\'s \"desired index\".\\n2. We loop through all nums and swap each nums[i] into its \"desired\" index. As soon as a number is placed into its \"desired\" place, we mark it as \"negative\", so that it won\\'t be processed again when we see it later (yes, because nums[i]\\'s desired index might be after itself, we might see it agian later). \\n3. Now nums[i] is in its desired place, but how about another number that \"is swapped\" by nums[i]? That number is currently in position \"i\" now because of the swap. We recursively put that number into its \"desired\" place too, until all the \"be-swapped\" numbers are also in their desired place. \\n4. After that, we can move to the next index \"i\" and do the same thing.\\n5. Don\\'t forget to change all numbers back to positive value after all finsihed.\\n\\n```\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        getDesireIdx = lambda i: i*2 if i<n else (i-n)*2+1\\n        for i in range(2*n):\\n            j=i\\n            while nums[i]>=0:\\n                j=getDesireIdx(j)\\n                nums[i],nums[j]=nums[j],-nums[i]\\n        for i in range(2*n):\\n            nums[i]=-nums[i]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        getDesireIdx = lambda i: i*2 if i<n else (i-n)*2+1\\n        for i in range(2*n):\\n            j=i\\n            while nums[i]>=0:\\n                j=getDesireIdx(j)\\n                nums[i],nums[j]=nums[j],-nums[i]\\n        for i in range(2*n):\\n            nums[i]=-nums[i]\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 675110,
                "title": "easiest-python-solution-with-zip-o-n-time",
                "content": "I divide the array into two parts, iterate items in one loop and return the result.\\n \\n```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n \\xA0 \\xA0 \\xA0 \\xA0res = []\\n \\xA0 \\xA0 \\xA0 \\xA0for i, j in zip(nums[:n],nums[n:]):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0res += [i,j]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n \\xA0 \\xA0 \\xA0 \\xA0res = []\\n \\xA0 \\xA0 \\xA0 \\xA0for i, j in zip(nums[:n],nums[n:]):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0res += [i,j]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 865924,
                "title": "in-place-o-n-time-o-1-ultimate-simple-java-solution",
                "content": "Just use the assumption that the numbers are less than 1000. So we can save the pairs together.\\n\\n```\\n\\npublic int[] shuffle(int[] nums, int n) {\\n        for(int i = 0; i < n; i++){\\n            nums[i] += nums[n + i] * 10000;\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            nums[2 * i + 1] = nums[i] / 10000;\\n            nums[2 * i] = nums[i] % 10000;\\n        }\\n        \\n        return nums;\\n    }",
                "solutionTags": [],
                "code": "Just use the assumption that the numbers are less than 1000. So we can save the pairs together.\\n\\n```\\n\\npublic int[] shuffle(int[] nums, int n) {\\n        for(int i = 0; i < n; i++){\\n            nums[i] += nums[n + i] * 10000;\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            nums[2 * i + 1] = nums[i] / 10000;\\n            nums[2 * i] = nums[i] % 10000;\\n        }\\n        \\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2710721,
                "title": "java-0-ms-faster-than-100-00-o-n",
                "content": "**Upvote if you like my solution! I\\'ll be happy :)**\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] result = new int[2*n];\\n        for (int i = 0; i < n; i++) {\\n            result[2 * i] = nums[i];\\n            result[2 * i + 1] = nums[n + i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] result = new int[2*n];\\n        for (int i = 0; i < n; i++) {\\n            result[2 * i] = nums[i];\\n            result[2 * i + 1] = nums[n + i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720690,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = [];\\n    for (i = 0; i < n; i++) {\\n        res.push(nums[i],nums[i+n]);\\n    }\\n    return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = [];\\n    for (i = 0; i < n; i++) {\\n        res.push(nums[i],nums[i+n]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674947,
                "title": "o-1-space-o-n-time-detailed-explanation",
                "content": "*(Please stop downvoating only because of a paper that solves a completely different problem!)*\\n\\n\\n## **Explanation**\\n----\\nUse the negative sign as a flag for the number that is already in its final place. Once a number is in its final place, we do not move it anymore.\\n\\nThe for-loop goes through every number. If the number is already in its final place, leave it as it is.\\n\\nOtherwise if the number is not in its final place, use a static index `i` to permanently mark its current place.\\nKeep in mind: `nums[i]` will change. **Do not imagine it is certain number. Imagine `nums[i]` as a slot.** The number in the slot may change. It is just a slot as a temporary buffer to temporarily store the number that is not in its final place. Let\\'s call the number as **_the buffered number_**.\\n\\nUse another dynamic index `j` to indicate the final place for the number that is currently in the buffer slot `nums[i]`.\\n\\nIn the while-loop, we find the correct final place for the buffered number. Kick out the number that is currently in `nums[j]` because it is not the correct final place for it. `nums[j]` is the final slot for the buffered number. OK, now the buffered number finds its final place, but how about the number that was just kicked out from `nums[j]`? No worries, longly kid, we will find a temporary shelter for you -- that is the slot `nums[i]`. We already found the final place for the buffered number, so it doesn\\'t have to be buffered any more. `nums[i]` now buffers the kicked-out number.\\n\\nThen we continue help the new buffered to find its final place. Until the buffered number\\'s final place is `nums[i]` it self.\\n\\n## **Time Complexity Analysis**\\n----\\n\\nThis algorithm time complexity is O(n), because every run of the while-loop body will find out the final place for one number. There are O(n) numbers, so the algorithm time complexity is O(n).\\n\\n\\n## **Ruby Code**\\n----\\n```\\n# @param {Integer[]} nums\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef shuffle(nums, n)\\n    for i in (0...nums.size)\\n        j = i\\n        while nums[i] >= 0\\n            j = j < n ? j * 2 : (j - n) * 2 + 1\\n            nums[i], nums[j] = nums[j], -nums[i]\\n        end\\n    end\\n    for i in (0...nums.size)\\n        nums[i] = -nums[i]\\n    end\\n    nums\\nend\\n```\\n\\n## **JavaScript Code**\\n----\\nIf the trick imagining `nums[i]` as a buffer slot still doesn\\'t make much sense to you, let\\'s explicitly allocate one more O(1) space `buffer`.\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    for (var i = 0; i < nums.length; i++) {\\n        var j = i;\\n        var buffer = nums[i];\\n        while (buffer >= 0) {\\n            j = j < n ? j * 2 : (j - n) * 2 + 1;\\n            var tmp = buffer; buffer = nums[j]; nums[j] = -tmp;\\n        }\\n    }\\n    for (var i = 0; i < nums.length; i++) {\\n        nums[i] *= -1;\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef shuffle(nums, n)\\n    for i in (0...nums.size)\\n        j = i\\n        while nums[i] >= 0\\n            j = j < n ? j * 2 : (j - n) * 2 + 1\\n            nums[i], nums[j] = nums[j], -nums[i]\\n        end\\n    end\\n    for i in (0...nums.size)\\n        nums[i] = -nums[i]\\n    end\\n    nums\\nend\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    for (var i = 0; i < nums.length; i++) {\\n        var j = i;\\n        var buffer = nums[i];\\n        while (buffer >= 0) {\\n            j = j < n ? j * 2 : (j - n) * 2 + 1;\\n            var tmp = buffer; buffer = nums[j]; nums[j] = -tmp;\\n        }\\n    }\\n    for (var i = 0; i < nums.length; i++) {\\n        nums[i] *= -1;\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3127426,
                "title": "o-1-sc-o-n-tc-c-easy-multiplication-and-modular-tricks",
                "content": "# Intuition\\nThe idea is to use multiplication and modular tricks to store two elements at the same index. \\nObserve the below example :\\n\\n![image.png](https://assets.leetcode.com/users/images/2feef461-e5fc-4552-81ab-9b9c84860169_1675261153.952608.png)\\n\\nWe will use the same approach to solve the problem.\\n\\n# Approach\\n- Initialize two pointers first = 0 and second = n , where N is the size of the array.\\n- Initialise an element max equal to 1 + maximum element of the array and since it is given that maximum value can be 10^3 so we can use 1001. \\n- Note: You can initialise max to any integer greater than 1000. \\n- Iterate over the array and perform the following operations:\\n- - If the current index is even:\\n- - - Update A[i] = A[i] + (A[first] % mx) * mx\\n- - - Increment first by 1.\\n- - If the current index is odd:\\n- - - Update A[i] = A[i] + (A[second] % mx) * mx\\n- - - Increment second by 1.\\n- To update the array element back to its original form, divide A[i] by max.\\n\\n# Complexity\\n- Time complexity : O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int first = 0, second = n, max = 1001;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i%2==0)\\n            nums[i]=(nums[first++]%max)*max + nums[i];\\n            else\\n            nums[i]=(nums[second++]%max)*max + nums[i];\\n        }\\n        for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int first = 0, second = n, max = 1001;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i%2==0)\\n            nums[i]=(nums[first++]%max)*max + nums[i];\\n            else\\n            nums[i]=(nums[second++]%max)*max + nums[i];\\n        }\\n        for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684649,
                "title": "o-n-time-o-1-space-no-bitwise-cheating-beats-99-7-time-and-beats-100-space",
                "content": "Two rules: \\nith element  -> 2ith element in new array\\ni + n th element -> 2i + 1 th element in the new array\\n\\nAdjust the array backwards,\\nFor each step, consider ith element\\nBefore the ith element, the array is ordered by orgianial order\\nAfter the ith element, the array is ordered by new order\\nFor the ith element, find the proper element using the two rules\\n\\nC++ version\\n```\\n\\nclass Solution {\\npublic:\\n   vector<int> shuffle(vector<int>& nums, int n) {\\n       for (int i = 2*n-1; i > 0; i--) {\\n           int k = i;\\n           do {\\n               if (k % 2 == 1)\\n                   k = k/2 + n;\\n               else\\n                   k = k/2;\\n           } while (k > i);\\n           swap(nums[i], nums[k]);\\n       }\\n       return nums;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n   vector<int> shuffle(vector<int>& nums, int n) {\\n       for (int i = 2*n-1; i > 0; i--) {\\n           int k = i;\\n           do {\\n               if (k % 2 == 1)\\n                   k = k/2 + n;\\n               else\\n                   k = k/2;\\n           } while (k > i);\\n           swap(nums[i], nums[k]);\\n       }\\n       return nums;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532727,
                "title": "easy-c-solution-with-few-lines-of-code",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n## Code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector <int> ans;\\n        for(int i=0; i<n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n***Please upvote if it was helpful for you, thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector <int> ans;\\n        for(int i=0; i<n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909259,
                "title": "java-in-place-o-n-time-and-o-1-space",
                "content": "Intuition: Store the number pairs in the right half of the array. Iterate and put pairs in proper positions.\\n\\nQ) How to store 2 numbers in the same array cell?\\nA) If there are two numbers n1 and n2, one could come up with a larger number M (greater than both n1 and n2) and store a single number having value V = M\\\\*n1+n2. Later on, if we want to extract the 2 numbers from V, we can do so like so,\\n\\n```\\nn1 = V/M\\nn2 = V%M\\n```\\n\\nSince given array numbers are between 1 and 1000, this method won\\'t give an overflow.\\n\\nCode:\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int max = 1001; // M in the above explanation\\n        \\n\\t\\t//Store number pairs in right half\\n        for(int i=n;i<nums.length;i++){\\n            nums[i] = max*nums[i]+nums[i-n];\\n        }\\n        \\n\\t\\t//Put pairs in proper positions\\n        int ind = 0;\\n        for(int i=n;i<nums.length;i++){\\n            nums[ind] = nums[i]%max;\\n            nums[ind+1] = nums[i]/max;\\n            ind+=2;\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nn1 = V/M\\nn2 = V%M\\n```\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int max = 1001; // M in the above explanation\\n        \\n\\t\\t//Store number pairs in right half\\n        for(int i=n;i<nums.length;i++){\\n            nums[i] = max*nums[i]+nums[i-n];\\n        }\\n        \\n\\t\\t//Put pairs in proper positions\\n        int ind = 0;\\n        for(int i=n;i<nums.length;i++){\\n            nums[ind] = nums[i]%max;\\n            nums[ind+1] = nums[i]/max;\\n            ind+=2;\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674426,
                "title": "python-very-simple-solution",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ## APPROACH : GREEDY ##\\n        ans = []\\n        for i in range(n):\\n            ans.append(nums[i])\\n            ans.append(nums[i+n])\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ## APPROACH : GREEDY ##\\n        ans = []\\n        for i in range(n):\\n            ans.append(nums[i])\\n            ans.append(nums[i+n])\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 674400,
                "title": "java-python-3-straight-forward-code",
                "content": "Pattern: `i -> 2 * i`, `i + n -> 2 * i + 1`\\n\\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[ 2 * n];\\n        for (int i = 0; i < n; ++i) {\\n            ans[2 * i] = nums[i];\\n            ans[2 * i + 1] = nums[i + n];\\n        }\\n        return ans;\\n    }\\n```\\nOr\\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2 * n];\\n        for (int i = 0; i < 2 * n; ++i) {\\n            ans[i] = nums[i / 2 + i % 2 * n];\\n        }\\n        return ans;\\n    }\\n```\\nOr\\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        return IntStream.range(0, 2 * n).map(i -> nums[i / 2 + i % 2 * n]).toArray();\\n    }\\n```\\n\\n```python\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [nums[i // 2 + i % 2 * n] for i in range(2 * n)]\\n```\\nOr better readability at a cost of space O(n): - credit to **@ggplay**\\n\\n```python\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [num for tup in zip(nums[: n], nums[n :]) for num in tup]\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[ 2 * n];\\n        for (int i = 0; i < n; ++i) {\\n            ans[2 * i] = nums[i];\\n            ans[2 * i + 1] = nums[i + n];\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2 * n];\\n        for (int i = 0; i < 2 * n; ++i) {\\n            ans[i] = nums[i / 2 + i % 2 * n];\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        return IntStream.range(0, 2 * n).map(i -> nums[i / 2 + i % 2 * n]).toArray();\\n    }\\n```\n```python\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [nums[i // 2 + i % 2 * n] for i in range(2 * n)]\\n```\n```python\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [num for tup in zip(nums[: n], nums[n :]) for num in tup]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1620167,
                "title": "java-easy-solution-o-n",
                "content": "**Upvote! If you like the solution**\\n\\nisn\\'t it easy?\\n\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       \\n        int[] ans = new int[2*n];\\n        \\n        for(int i=0;i<n;i++){\\n            ans[2*i]=nums[i];\\n            ans[2*i+1]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       \\n        int[] ans = new int[2*n];\\n        \\n        for(int i=0;i<n;i++){\\n            ans[2*i]=nums[i];\\n            ans[2*i+1]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831420,
                "title": "python-3-2-solutions-with-slight-change",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe traverse the list till the for n elements. Time = O(n) = O(N/2) = O(N)\\n\\n**Solution 1:**\\n```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\tresult = [float(\"-inf\") for i in range(2*n)]        \\n\\tfor i in range(n):\\n\\t\\tresult[(2*i)] = nums[i]\\n\\t\\tresult[(2*i)+1] = nums[n+i]\\n\\treturn result\\n```\\n\\n**Solution 2:**\\n```\\t\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\tresult = []\\n\\tfor i in range(n):\\n\\t\\tresult.append(nums[i])\\n\\t\\tresult.append(nums[n+i])\\n\\treturn result\\t\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\tresult = [float(\"-inf\") for i in range(2*n)]        \\n\\tfor i in range(n):\\n\\t\\tresult[(2*i)] = nums[i]\\n\\t\\tresult[(2*i)+1] = nums[n+i]\\n\\treturn result\\n```\n```\\t\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\tresult = []\\n\\tfor i in range(n):\\n\\t\\tresult.append(nums[i])\\n\\t\\tresult.append(nums[n+i])\\n\\treturn result\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1104446,
                "title": "javascript-faster-than-98-99-simple",
                "content": "```\\nvar shuffle = function(nums, n) {\\n    let res = []\\n    for(let i=0; i < n; i++){  \\n        res.push(nums[i])\\n        res.push(nums[i+n])\\n    }\\n    return res \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    let res = []\\n    for(let i=0; i < n; i++){  \\n        res.push(nums[i])\\n        res.push(nums[i+n])\\n    }\\n    return res \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149340,
                "title": "putta-easy-solution-c-o-1-space-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1b)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        \\n    for(int i=0;i<n;i++){\\n        nums[i] = nums[i]<<10; // Left shifting xi by 10 bits \\n        nums[i] = nums[i] | nums[i+n]; //Adding yi to xi \\n    }\\n    int j = 2*n-1;\\n    for(int i = n-1;i>-1;i--,j = j-2)\\n    {\\n        int x = nums[i] >> 10; // Extracting xi by Right shifting 10 bits \\n        int y = nums[i] & ((1024) -1); // Extracting yi by & on LSB 10 bits \\n        nums[j] = y;\\n        nums[j-1] = x;\\n      \\n    }\\n    return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        \\n    for(int i=0;i<n;i++){\\n        nums[i] = nums[i]<<10; // Left shifting xi by 10 bits \\n        nums[i] = nums[i] | nums[i+n]; //Adding yi to xi \\n    }\\n    int j = 2*n-1;\\n    for(int i = n-1;i>-1;i--,j = j-2)\\n    {\\n        int x = nums[i] >> 10; // Extracting xi by Right shifting 10 bits \\n        int y = nums[i] & ((1024) -1); // Extracting yi by & on LSB 10 bits \\n        nums[j] = y;\\n        nums[j-1] = x;\\n      \\n    }\\n    return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865856,
                "title": "java-two-pointer-verbose-code",
                "content": "* **Please upvote if helpful!!**\\n\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n\\n        int[] result = new int[nums.length];\\n\\n        int leftPointer = 0;\\n        int rightPointer = n;\\n\\n        int index = 0;\\n\\n        while (rightPointer < nums.length) {\\n\\n            result[index] = nums[leftPointer];\\n            result[index + 1] = nums[rightPointer];\\n\\n            leftPointer++;\\n            rightPointer++;\\n            index = index + 2;\\n\\n\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n\\n        int[] result = new int[nums.length];\\n\\n        int leftPointer = 0;\\n        int rightPointer = n;\\n\\n        int index = 0;\\n\\n        while (rightPointer < nums.length) {\\n\\n            result[index] = nums[leftPointer];\\n            result[index + 1] = nums[rightPointer];\\n\\n            leftPointer++;\\n            rightPointer++;\\n            index = index + 2;\\n\\n\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148790,
                "title": "python-3-1-line-sorry-but-w-detailed-example-t-m-98-44",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n                                                        #  Example: [2,5,1,3,4,7      n = 3\\n        \\n        return list(chain(*zip(nums[:n],nums[n:])))     # list(chain(*zip([2,5,1],nums[3,4,7])))\\n                                                        # list(chain(*[(2,3), (5,4), (1,7)])\\n                                                        # list(chain((2,3), (5,4), (1,7))\\n                                                        # list(2,3, 5,4, 1,7)\\n                                                        # [2,3,5,4,1,7]\\n```\\n[https://leetcode.com/problems/shuffle-the-array/submissions/892368758/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n                                                        #  Example: [2,5,1,3,4,7      n = 3\\n        \\n        return list(chain(*zip(nums[:n],nums[n:])))     # list(chain(*zip([2,5,1],nums[3,4,7])))\\n                                                        # list(chain(*[(2,3), (5,4), (1,7)])\\n                                                        # list(chain((2,3), (5,4), (1,7))\\n                                                        # list(2,3, 5,4, 1,7)\\n                                                        # [2,3,5,4,1,7]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025666,
                "title": "simple-1-liner-in-python-faster-than-99",
                "content": "#### Code\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [j for i in zip(nums[:n], nums[n:]) for j in i]\\n```\\n\\n#### Explanation:\\n\\n- `zip(nums[:n], nums[n:]` will return `[(x1, y1), (x2, y2), ...]`.\\n- `[j for i in two_dimensional_list for j in i]` will flatten the 2d array to give `[x1, y1, x2, y2, ...]`.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [j for i in zip(nums[:n], nums[n:]) for j in i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153854,
                "title": "swift-shuffle-the-array",
                "content": "**Well, it\\'s a classic.**\\n**If you have a solution easier than this, please share :)**\\n\\n```swift\\nclass Solution {\\n    func shuffle(_ nums: [Int], _ n: Int) -> [Int] {\\n        var res = [Int]()\\n        for i in 0..<n {\\n            res.append(nums[i])\\n            res.append(nums[i + n])\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shuffle(_ nums: [Int], _ n: Int) -> [Int] {\\n        var res = [Int]()\\n        for i in 0..<n {\\n            res.append(nums[i])\\n            res.append(nums[i + n])\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941186,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(nums[i]);\\n            v.push_back(nums[n+i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(nums[i]);\\n            v.push_back(nums[n+i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148543,
                "title": "beats-100-simple-and-in-place-with-video-java-c-python",
                "content": "# Simple Approach\\n1. Create a new array of size 2n.\\n2. The first half of the array is taking even places i.e res[2*i] = A[i]\\n3. The second half of the array is taking odd places i.e res[2*i+1]=A[n+i]\\n\\n![image](https://assets.leetcode.com/users/images/71a69a22-faed-4f9b-8f07-383b71a19832_1675647440.577359.jpeg)\\n\\n\\n```\\n\\tpublic int[] shuffle(int[] nums, int n) {\\n        int[] result = new int[2 * n];\\n        for (int i = 0; i < n; ++i) {\\n            result[2 * i] = nums[i];\\n            result[2 * i + 1] = nums[n + i];\\n        }\\n        return result;\\n    }\\n```\\n\\nHowever if you are preparing for intense Interviews. \\n\\n# In Place Hashing\\nThe core idea of this algorithm is to store 2 numbers together and extract them later. \\n\\n![image](https://assets.leetcode.com/users/images/c3b8e6e8-d1b0-4743-ae35-39e3c0dfdc36_1675647493.4934015.jpeg)\\n\\n5 and 3 for example: 3*10 +5 = 35 so whenever we want 5 its 35%5 and whenever we want 3 its 35/3.\\n\\nBut 10 is a small number and the given range is 1000, so we can use 10000 in place of 10.\\n\\n1. Have 2 pointers first = 0 and second = n Iterate over the array.\\n2.  if i is even nums[i]=(nums[first++]%max)*max + nums[i];\\n3.  if i is odd nums[i]=(nums[second++]%max)*max + nums[i];\\n4. . Divide the entire array by 10000\\n\\n\\n\\nhttps://youtu.be/sSW_MZZXIDY\\n\\n![image](https://assets.leetcode.com/users/images/0c94cf04-382e-4de0-b162-1a1fcfa2450a_1675647862.7321172.jpeg)\\n\\n\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int first = 0, second = n, max = 10000;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i%2==0)\\n            nums[i]=(nums[first++]%max)*max + nums[i];\\n            else\\n            nums[i]=(nums[second++]%max)*max + nums[i];\\n        }\\n        for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n        return nums;\\n    }\\n```\\n\\n```\\nvector<int> shuffle(vector<int>& nums, int n) {\\n    int first = 0, second = n, max = 10000;\\n    for(int i=0;i<2*n;i++) {\\n        if(i%2==0)\\n        nums[i]= (nums[first++]%max)*max + nums[i];\\n        else\\n        nums[i]= (nums[second++]%max)*max + nums[i];\\n    }\\n    for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n    return nums;\\n}\\n```\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums, n):\\n        first = 0\\n        second = n\\n        max_val = 10000\\n        for i in range(2 * n):\\n            if i % 2 == 0:\\n                nums[i] = (nums[first] % max_val) * max_val + nums[i]\\n                first += 1\\n            else:\\n                nums[i] = (nums[second] % max_val) * max_val + nums[i]\\n                second += 1\\n        for i in range(2 * n):\\n            nums[i] = nums[i] // max_val\\n        return nums\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n\\tpublic int[] shuffle(int[] nums, int n) {\\n        int[] result = new int[2 * n];\\n        for (int i = 0; i < n; ++i) {\\n            result[2 * i] = nums[i];\\n            result[2 * i + 1] = nums[n + i];\\n        }\\n        return result;\\n    }\\n```\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int first = 0, second = n, max = 10000;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i%2==0)\\n            nums[i]=(nums[first++]%max)*max + nums[i];\\n            else\\n            nums[i]=(nums[second++]%max)*max + nums[i];\\n        }\\n        for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n        return nums;\\n    }\\n```\n```\\nvector<int> shuffle(vector<int>& nums, int n) {\\n    int first = 0, second = n, max = 10000;\\n    for(int i=0;i<2*n;i++) {\\n        if(i%2==0)\\n        nums[i]= (nums[first++]%max)*max + nums[i];\\n        else\\n        nums[i]= (nums[second++]%max)*max + nums[i];\\n    }\\n    for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n    return nums;\\n}\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums, n):\\n        first = 0\\n        second = n\\n        max_val = 10000\\n        for i in range(2 * n):\\n            if i % 2 == 0:\\n                nums[i] = (nums[first] % max_val) * max_val + nums[i]\\n                first += 1\\n            else:\\n                nums[i] = (nums[second] % max_val) * max_val + nums[i]\\n                second += 1\\n        for i in range(2 * n):\\n            nums[i] = nums[i] // max_val\\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099699,
                "title": "without-extra-space-93-less-space-python-3",
                "content": "I think this was asked in facebook once. \\nHere TC is not that important. SC is what matters.\\nLogic: \\nWe need to store 2 numbers in one place. the actual number and the shuffled number. \\nBut if we directly shuffle, we will lose the actual number. So we can multiple the actual with a factor and add shuffled to it. \\nActual = a1\\nShuffled = a2\\nWe take some multiplication factor that\\'s greater than maximum limit of num[i]\\nso here in this case take 1001.\\nTo store both numbers use x[i] = a1* 1001  + a2\\nto find a1 we take x[i]//1001 (or take the number as it is , if its havent been changed yet)\\nfinally we retrieve the result using  a2 = x[i]%1001\\n\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        maximum = 1001\\n        i ,j, k = 0, n, 0\\n\\t\\t#update the array to convert nums[i] to x[i]\\n        while k<len(nums):\\n            a1 = nums[k] if nums[k]//maximum == 0 else nums[k]//maximum\\n            if k&1:\\n                a2 = nums[j] if nums[j]//maximum == 0 else nums[j]//maximum\\n                j+=1\\n            else:\\n                a2 = nums[i] if nums[i]//maximum == 0 else nums[i]//maximum\\n                i+=1\\n            nums[k] = a1* maximum + a2\\n            k+=1\\n\\t\\t#convert x[i] to shuffled\\n        for i in range(len(nums)):\\n            nums[i]= nums[i]%maximum\\n        return nums\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        maximum = 1001\\n        i ,j, k = 0, n, 0\\n\\t\\t#update the array to convert nums[i] to x[i]\\n        while k<len(nums):\\n            a1 = nums[k] if nums[k]//maximum == 0 else nums[k]//maximum\\n            if k&1:\\n                a2 = nums[j] if nums[j]//maximum == 0 else nums[j]//maximum\\n                j+=1\\n            else:\\n                a2 = nums[i] if nums[i]//maximum == 0 else nums[i]//maximum\\n                i+=1\\n            nums[k] = a1* maximum + a2\\n            k+=1\\n\\t\\t#convert x[i] to shuffled\\n        for i in range(len(nums)):\\n            nums[i]= nums[i]%maximum\\n        return nums\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 840292,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        nums[..n as usize]\\n            .iter()\\n            .zip(nums[n as usize..].iter())\\n            .flat_map(|(&x, &y)| vec![x, y])\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        nums[..n as usize]\\n            .iter()\\n            .zip(nums[n as usize..].iter())\\n            .flat_map(|(&x, &y)| vec![x, y])\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736116,
                "title": "javascript-solution",
                "content": "This is my Javascript solution:\\n\\n```\\nvar shuffle = function(nums, n) {\\n    let result = [];\\n    for(let i = 0; i < n; i++){\\n        result.push(nums[i]);\\n        result.push(nums[i+n]);   \\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    let result = [];\\n    for(let i = 0; i < n; i++){\\n        result.push(nums[i]);\\n        result.push(nums[i+n]);   \\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 677669,
                "title": "javascript-one-liner-with-map",
                "content": "```\\n(nums, n) => nums.map((x, i) => i % 2 === 0 ? nums[i / 2] : nums[n + (i - 1) / 2])\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n(nums, n) => nums.map((x, i) => i % 2 === 0 ? nums[i / 2] : nums[n + (i - 1) / 2])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 982795,
                "title": "coderaky-soultion",
                "content": "Leetcode c++ Solutions \\uD83D\\uDE4C\\nhttps://github.com/coderaky/leetcoder\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n+i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n+i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815592,
                "title": "in-place-time-o-n-memory-o-1",
                "content": "\\n\\n***Packing***:  in the upper 16 bits of the first N elements we put the original value Xi , and in the lower 16 bits - Yi, where  i = 0, ... , N\\n```\\nnums: |  X1   |  X2   |  X3   |  X4   |  Y1   |   Y2   |    Y3   |   Y4   |\\n =>   | x1 y1 | x2 y2 | x3 y3 | x4 y4 |  Y1   |   Y2   |    Y3   |   Y4   |\\n```\\n***Unpacking***: starting from position N, we perform bitwise operations (& and >>) for the first N elements, and the resulting pair values are entered into the current end. After processing each element from the first half of the array, we update the corresponding end indices.\\n\\n\\n```\\nstd::vector<int> shuffle(std::vector<int>& nums, int n) {\\n\\tint endY = 2 * n - 1;\\n\\tint endX = n - 1;\\n\\n\\tfor (int i = endX, j = endY; i >= 0; i--, j--) {\\n\\t\\tnums[i] <<= 0x10;   // shl on 16 bits\\n\\t\\tnums[i] |= nums[j];\\n\\t}\\n\\t\\n\\tfor (int i = endX, j = endY; i >= 0; i--, j -= 2) {        \\n\\t\\tnums[j]     = nums[i] & 0xFFFF;  // x & mask, where mask is 1111 1111 1111 1111 \\n\\t\\tnums[j - 1] = nums[i] >> 0x10;   // shr on 16 bits\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nnums: |  X1   |  X2   |  X3   |  X4   |  Y1   |   Y2   |    Y3   |   Y4   |\\n =>   | x1 y1 | x2 y2 | x3 y3 | x4 y4 |  Y1   |   Y2   |    Y3   |   Y4   |\\n```\n```\\nstd::vector<int> shuffle(std::vector<int>& nums, int n) {\\n\\tint endY = 2 * n - 1;\\n\\tint endX = n - 1;\\n\\n\\tfor (int i = endX, j = endY; i >= 0; i--, j--) {\\n\\t\\tnums[i] <<= 0x10;   // shl on 16 bits\\n\\t\\tnums[i] |= nums[j];\\n\\t}\\n\\t\\n\\tfor (int i = endX, j = endY; i >= 0; i--, j -= 2) {        \\n\\t\\tnums[j]     = nums[i] & 0xFFFF;  // x & mask, where mask is 1111 1111 1111 1111 \\n\\t\\tnums[j - 1] = nums[i] >> 0x10;   // shr on 16 bits\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674365,
                "title": "clean-python-3-generator-and-one-liner",
                "content": "Time: `O(N)`\\nSpace: `O(N)` for output list\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        def gen(A):\\n            for i in range(n): \\n                yield from (A[i], A[i+n])\\n        return list(gen(nums))\\n```\\n\\nOne liner:\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return sum(([nums[i], nums[i+n]] for i in range(n)), [])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        def gen(A):\\n            for i in range(n): \\n                yield from (A[i], A[i+n])\\n        return list(gen(nums))\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return sum(([nums[i], nums[i+n]] for i in range(n)), [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471154,
                "title": "c-in-place-o-1-example-added",
                "content": "I got this solution from one of the most upvoted solutions, and I must say that person has amazing observation skills, using one of the constaraints that no element > 1000 to devise the solution, is honestly beyond my intelligence as of now. I have included the result of dry run as comments.\\n\\n```\\nvector<int> shuffle(vector<int> nums, int val) {\\n        // nums = [2,5,1,3,4,7], n=3\\n        \\n        for(int i = 0; i < val; i++)  nums[i] += nums[val + i] * 10000;\\n        \\n        //After 1st loop: [30002,40005,70001,3,4,7]\\n       \\n        for(int i = val - 1; i >= 0; i--){\\n            //i starts at i=2\\n            \\n            nums[2 * i + 1] = nums[i] / 10000;\\n            //nums[5] = nums[2]/10000 = 70001/10000 = 7\\n\\t\\t\\t//nums[3] = 4\\n\\t\\t\\t//nums[1] = 3\\n            \\n            nums[2 * i] = nums[i] % 10000;\\n            //nums[4] = nums[2]/10000 = 70001 % 10000 = 1 \\n\\t\\t\\t//nums[2] = 5\\n\\t\\t\\t//nums[0] = 2\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> shuffle(vector<int> nums, int val) {\\n        // nums = [2,5,1,3,4,7], n=3\\n        \\n        for(int i = 0; i < val; i++)  nums[i] += nums[val + i] * 10000;\\n        \\n        //After 1st loop: [30002,40005,70001,3,4,7]\\n       \\n        for(int i = val - 1; i >= 0; i--){\\n            //i starts at i=2\\n            \\n            nums[2 * i + 1] = nums[i] / 10000;\\n            //nums[5] = nums[2]/10000 = 70001/10000 = 7\\n\\t\\t\\t//nums[3] = 4\\n\\t\\t\\t//nums[1] = 3\\n            \\n            nums[2 * i] = nums[i] % 10000;\\n            //nums[4] = nums[2]/10000 = 70001 % 10000 = 1 \\n\\t\\t\\t//nums[2] = 5\\n\\t\\t\\t//nums[0] = 2\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1393426,
                "title": "c-pure-logic-6lines",
                "content": "///\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n\\t\\n        vector<int> res(nums.size());\\n        int i=0,j=n;\\n        for(int k=0;k<nums.size();k++){\\n            if(k%2==0)\\n                res[k]=nums[i++];\\n            else\\n                res[k]=nums[j++];\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n\\t\\n        vector<int> res(nums.size());\\n        int i=0,j=n;\\n        for(int k=0;k<nums.size();k++){\\n            if(k%2==0)\\n                res[k]=nums[i++];\\n            else\\n                res[k]=nums[j++];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 691824,
                "title": "java-runtime-0-ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int num = nums.length;\\n        int[] a = new int[num];\\n        int index = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n           a[index] = nums[i];\\n           index++;\\n           a[index] = nums[i+n];\\n           index++; \\n       }\\n        return a;\\n    }\\n}\\n\\nP.S If you find it helpful do upvote.\\n:)",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int num = nums.length;\\n        int[] a = new int[num];\\n        int index = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n           a[index] = nums[i];\\n           index++;\\n           a[index] = nums[i+n];\\n           index++; \\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3148452,
                "title": "python3-56-ms-faster-than-94-54-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/9b4c5457-47dd-42a3-9a62-b4bd318df0fc_1675644643.8485587.png)\\n\\n```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ls=[]\\n        for i in range(n):\\n            ls+=[nums[i]]\\n            ls+=[nums[i+n]]\\n        return ls\\n```\\nHere\\'s a step by step description of the code:\\n1. Initialize an empty list ls to store the shuffled elements.\\n1. Loop through nums by incrementing the index i from 0 to n-1.\\n1. For each iteration of the loop, add the element at index i in nums to ls using ls += [nums[i]].\\n1. After that, add the element at index i + n in nums to ls using ls += [nums[i + n]].\\n1. Repeat steps 3 and 4 for all iterations of the loop until i is equal to n-1.\\n1. After the loop, return the ls list as the shuffled result in the form [x1, y1, x2, y2, ..., xn, yn].",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ls=[]\\n        for i in range(n):\\n            ls+=[nums[i]]\\n            ls+=[nums[i+n]]\\n        return ls\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3149696,
                "title": "bitmasking-approach-to-solve-1470-shuffle-the-array",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Approach\\n We will encode the y(i) and x(i) with in first n number of places via bitmusking . Then will decode them in there exact places \\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int tenBitNum = pow(2,10)-1;  // Geting a 10 bit number to extract the First encoded number \\n        for(int i=0;i<n;i++){   // encoding the the y(i) and x(i) number in the i th index \\n            int secNum = nums[n+i] << 10 ;\\n             nums[i] = nums[i] | secNum ; \\n        }\\n        for(int i = n - 1  ; i >= 0 ; i-- ){   // decoding the the y(i) and x(i) number in the i th index \\n            nums[2*i + 1] = nums[i] >> 10 ;\\n            nums[2*i] =  nums[i] & tenBitNum ;\\n        }\\n        return nums ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int tenBitNum = pow(2,10)-1;  // Geting a 10 bit number to extract the First encoded number \\n        for(int i=0;i<n;i++){   // encoding the the y(i) and x(i) number in the i th index \\n            int secNum = nums[n+i] << 10 ;\\n             nums[i] = nums[i] | secNum ; \\n        }\\n        for(int i = n - 1  ; i >= 0 ; i-- ){   // decoding the the y(i) and x(i) number in the i th index \\n            nums[2*i + 1] = nums[i] >> 10 ;\\n            nums[2*i] =  nums[i] & tenBitNum ;\\n        }\\n        return nums ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148580,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "<iframe src=\"https://leetcode.com/playground/kFBKTVFH/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/kFBKTVFH/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2667752,
                "title": "java-beginner-easy-to-understand",
                "content": "upvote if this code helped\\n\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n        for(int i=0;i<n;i++){\\n            \\n            ans[2*i]= nums[i];\\n            ans[2*i+1]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n        for(int i=0;i<n;i++){\\n            \\n            ans[2*i]= nums[i];\\n            ans[2*i+1]=nums[i+n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2192036,
                "title": "java-easy-solution",
                "content": "plz upvote if u like the solution\\n\\n\\t\\n\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic int[] shuffle(int[] nums, int n) {\\n\\t\\t\\t\\t\\t\\tint [] ans = new int[2*n];\\n\\t\\t\\t\\t\\tint i = 0;\\n\\t\\t\\t\\t\\t int left = 0;\\n\\t\\t\\t\\t\\tint right = n;\\n\\n\\t\\t\\t\\t\\twhile(left < n){\\n\\t\\t\\t\\t\\t\\tans[i++] = nums[left++];\\n\\t\\t\\t\\t\\t\\tans[i++] = nums[right++];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic int[] shuffle(int[] nums, int n) {\\n\\t\\t\\t\\t\\t\\tint [] ans = new int[2*n];\\n\\t\\t\\t\\t\\tint i = 0;\\n\\t\\t\\t\\t\\t int left = 0;\\n\\t\\t\\t\\t\\tint right = n;\\n\\n\\t\\t\\t\\t\\twhile(left < n){\\n\\t\\t\\t\\t\\t\\tans[i++] = nums[left++];\\n\\t\\t\\t\\t\\t\\tans[i++] = nums[right++];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 941189,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l=[]\\n        for i in range(n):\\n            l.append(nums[i])\\n\\t\\t\\tl.append(nums[n+i])\\n        return l\\n```\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l=[]\\n        for i in range(n):\\n            l.extend([nums[i],nums[i+1]])\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l=[]\\n        for i in range(n):\\n            l.append(nums[i])\\n\\t\\t\\tl.append(nums[n+i])\\n        return l\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l=[]\\n        for i in range(n):\\n            l.extend([nums[i],nums[i+1]])\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723993,
                "title": "java-in-place-swap-without-using-additional-array",
                "content": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        //No additional memory, swap the elements\\n        \\n\\t\\t//1st loop \\n\\t\\t//First & last elements in correct poistion. Go from 2nd till Nth element  i.e. loop will execute N-1 times. \\n\\t\\t//Swap ith element with Nth element. For N=5, Swap element at i=1 with element at i=5 element.\\n        \\n\\t\\t//2nd loop\\n\\t\\t//First two and last two elements in correct position. Go from 3rd element till till Nth element  i.e. loop will execute N-2 times.\\n\\t\\t//Swap ith element with Nth element. For N=5, Swap i=2 with i=5 element.\\n        \\n\\t\\t//Go on ... till no more swaps are needed\\n        \\n        for(int i=1; i<n; i++) {\\n            for(int j=i, k=n; j<n; j++,k++) {\\n                int temp = nums[j];\\n                nums[j] = nums[k];\\n                nums[k] = temp;    \\n            }\\n        }\\n        return nums;\\n        \\n        //Simple solution - Using a new array\\n        /*int[] toRet = new int[nums.length];\\n        for(int i=0, j=n, k=0; i < n; i++, j++) {\\n            toRet[k++] = nums[i];\\n            toRet[k++] = nums[j];\\n        }\\n        return toRet;*/\\n    }\\n```\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        //No additional memory, swap the elements\\n        \\n\\t\\t//1st loop \\n\\t\\t//First & last elements in correct poistion. Go from 2nd till Nth element  i.e. loop will execute N-1 times. \\n\\t\\t//Swap ith element with Nth element. For N=5, Swap element at i=1 with element at i=5 element.\\n        \\n\\t\\t//2nd loop\\n\\t\\t//First two and last two elements in correct position. Go from 3rd element till till Nth element  i.e. loop will execute N-2 times.\\n\\t\\t//Swap ith element with Nth element. For N=5, Swap i=2 with i=5 element.\\n        \\n\\t\\t//Go on ... till no more swaps are needed\\n        \\n        for(int i=1; i<n; i++) {\\n            for(int j=i, k=n; j<n; j++,k++) {\\n                int temp = nums[j];\\n                nums[j] = nums[k];\\n                nums[k] = temp;    \\n            }\\n        }\\n        return nums;\\n        \\n        //Simple solution - Using a new array\\n        /*int[] toRet = new int[nums.length];\\n        for(int i=0, j=n, k=0; i < n; i++, j++) {\\n            toRet[k++] = nums[i];\\n            toRet[k++] = nums[j];\\n        }\\n        return toRet;*/\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3150071,
                "title": "c-easy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple taverse from 0 to n and push i,i+n as adjacent elemnts.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$--> not taking answer vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& arr, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(arr[i]);\\n            ans.push_back(arr[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& arr, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(arr[i]);\\n            ans.push_back(arr[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148478,
                "title": "98-javascript-very-very-easy-to-understand-solution-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/eh0oJfhEX_M\\n\\nKorean video!\\n\\nhttps://youtu.be/zUqYU6WXYpw\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = []\\n\\n    for(let i =0; i<nums.length/2;i++){\\n        res.push(nums[i],nums[i+n])\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = []\\n\\n    for(let i =0; i<nums.length/2;i++){\\n        res.push(nums[i],nums[i+n])\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148370,
                "title": "daily-leetcoding-challenge-february-day-6",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/shuffle-the-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/shuffle-the-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1107174,
                "title": "inplace-solution-without-temp-variable-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int max_num = *max_element(nums.begin(), nums.end()) + 1;\\n        for (int i = 0; i < 2 * n; i++) {\\n            nums[i] *= max_num;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            nums[2 * i] += nums[i] / max_num;\\n        }\\n        for (int i = n; i < 2 * n; i++) {\\n            nums[2 * (i - n) + 1] += nums[i] / max_num;\\n        }\\n        for (int i = 0; i < 2 * n; i++) {\\n            nums[i] %= max_num;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int max_num = *max_element(nums.begin(), nums.end()) + 1;\\n        for (int i = 0; i < 2 * n; i++) {\\n            nums[i] *= max_num;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            nums[2 * i] += nums[i] / max_num;\\n        }\\n        for (int i = n; i < 2 * n; i++) {\\n            nums[2 * (i - n) + 1] += nums[i] / max_num;\\n        }\\n        for (int i = 0; i < 2 * n; i++) {\\n            nums[i] %= max_num;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093724,
                "title": "java-easy-self-explanatory-solution",
                "content": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        int[] shuffled = new int[nums.length];\\n        for(int i=0;i<n;i++){\\n            shuffled[i*2] = nums[i];\\n            shuffled[i*2+1] = nums[i+n];\\n\\n        }\\n        return shuffled;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        int[] shuffled = new int[nums.length];\\n        for(int i=0;i<n;i++){\\n            shuffled[i*2] = nums[i];\\n            shuffled[i*2+1] = nums[i+n];\\n\\n        }\\n        return shuffled;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3345446,
                "title": "the-best-solution-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nconst shuffle = (nums, n) => {\\n  const result = new Array(2 * n);\\n  let j = 0;\\n  for (let i = 0; i < n; i++) {\\n    result[j++] = nums[i];\\n    result[j++] = nums[i + n];\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nconst shuffle = (nums, n) => {\\n  const result = new Array(2 * n);\\n  let j = 0;\\n  for (let i = 0; i < n; i++) {\\n    result[j++] = nums[i];\\n    result[j++] = nums[i + n];\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2586868,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int res[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n;i++) {\\n            res[j++]=nums[i]; \\n            res[j++]=nums[i+n];\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int res[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n;i++) {\\n            res[j++]=nums[i]; \\n            res[j++]=nums[i+n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1045198,
                "title": "javascript-onliner-flatmap-solution",
                "content": "```\\nconst shuffle = (nums, n) => nums.slice(0, n).flatMap((x, i) => [x, nums[i + n]])\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst shuffle = (nums, n) => nums.slice(0, n).flatMap((x, i) => [x, nums[i + n]])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 911668,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) space O(n)\\nvar shuffle = function(nums, n) {\\n    const result = []\\n    \\n    for(let i=0; i<n; i++) {\\n        result.push(nums[i])            \\n        result.push(nums[i+n])\\n    }\\n    \\n    return result\\n};\\n```\\n\\n```\\n// time O(n) space O(n)\\nvar shuffle = function(nums, n) {\\n    const result = []\\n    let isEvenIndex = true\\n    \\n    for(let i=0; i<n; i++) {\\n        if(isEvenIndex) {\\n            result.push(nums[i])\\n            i--\\n        } else {\\n            result.push(nums[i+n])\\n        }\\n        \\n        isEvenIndex = !isEvenIndex\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) space O(n)\\nvar shuffle = function(nums, n) {\\n    const result = []\\n    \\n    for(let i=0; i<n; i++) {\\n        result.push(nums[i])            \\n        result.push(nums[i+n])\\n    }\\n    \\n    return result\\n};\\n```\n```\\n// time O(n) space O(n)\\nvar shuffle = function(nums, n) {\\n    const result = []\\n    let isEvenIndex = true\\n    \\n    for(let i=0; i<n; i++) {\\n        if(isEvenIndex) {\\n            result.push(nums[i])\\n            i--\\n        } else {\\n            result.push(nums[i+n])\\n        }\\n        \\n        isEvenIndex = !isEvenIndex\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732995,
                "title": "swift-solution",
                "content": "\\n```\\nclass Solution {\\n    func shuffle(_ nums: [Int], _ n: Int) -> [Int] {\\n        var result: [Int] = []\\n        for i in (0..<n){\\n            result.append(nums[i])\\n            result.append(nums[i+n])\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func shuffle(_ nums: [Int], _ n: Int) -> [Int] {\\n        var result: [Int] = []\\n        for i in (0..<n){\\n            result.append(nums[i])\\n            result.append(nums[i+n])\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676054,
                "title": "a-k-k-1-nums-j-nums-i",
                "content": "```\\nvector<int> shuffle(vector<int>& nums, int we_dont_care_XD) {\\n        \\n        int i=0 , j=nums.size()/2 , k=0;\\n\\t\\t\\n        vector<int> a(nums.size());\\n\\t\\t\\n        while(k < nums.size())\\n            a[k++] = k&1 ? nums[j++] : nums[i++];\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nvector<int> shuffle(vector<int>& nums, int we_dont_care_XD) {\\n        \\n        int i=0 , j=nums.size()/2 , k=0;\\n\\t\\t\\n        vector<int> a(nums.size());\\n\\t\\t\\n        while(k < nums.size())\\n            a[k++] = k&1 ? nums[j++] : nums[i++];\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674374,
                "title": "python-1-liner-easy-fast-using-zip-chain",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums, n):\\n        return list(chain.from_iterable(zip(nums[:n], nums[n:])))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums, n):\\n        return list(chain.from_iterable(zip(nums[:n], nums[n:])))",
                "codeTag": "Java"
            },
            {
                "id": 3148945,
                "title": "c-2-pointer-comments-added-easy",
                "content": "# Complexity\\n- Time complexity:\\n**O(N)**\\n\\n- Space complexity:\\n**O(N)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) \\n    {\\n        vector<int> ans;       // for storing final answer\\n\\n        // 2 pointer Approach\\n        int l = 0;\\n        int r = n;\\n\\n        while(r<2*n)\\n        {\\n            ans.push_back(nums[l++]);       // taking X\\n            ans.push_back(nums[r++]);       // taking Y\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) \\n    {\\n        vector<int> ans;       // for storing final answer\\n\\n        // 2 pointer Approach\\n        int l = 0;\\n        int r = n;\\n\\n        while(r<2*n)\\n        {\\n            ans.push_back(nums[l++]);       // taking X\\n            ans.push_back(nums[r++]);       // taking Y\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148725,
                "title": "two-pointers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\n\\nSolution :\\n   Using two pointers.\\n\\n   For eg. nums = [2,5,1,3,4,7]\\n              \\n     i] [2,5,1,3,4,7]\\n         i     j\\n     ii] [2,5,1,3,4,7]\\n            i     j\\n     i] [2,5,1,3,4,7]\\n             i     j\\n\\n*/\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=nums.size()/2;\\n        for(;j<nums.size();i++,j++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[j]);\\n        }\\n\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\n\\nSolution :\\n   Using two pointers.\\n\\n   For eg. nums = [2,5,1,3,4,7]\\n              \\n     i] [2,5,1,3,4,7]\\n         i     j\\n     ii] [2,5,1,3,4,7]\\n            i     j\\n     i] [2,5,1,3,4,7]\\n             i     j\\n\\n*/\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=nums.size()/2;\\n        for(;j<nums.size();i++,j++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[j]);\\n        }\\n\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148631,
                "title": "day-37-easiest-beginner-friendly-sol-o-n-time",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize an empty vector \"shuffleArray\" with a size of 2 * n.\\n2. For a loop that starts from i=0, j=n and continues until i<n and j<2n, do the following:\\n    - a. Assign nums[i] to shuffleArray[i2].\\n    - b. Assign nums[j] to shuffleArray[i*2+1].\\n1. Return the \"shuffleArray\".\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> shuffleArray(2*n);\\n        for(int i = 0; i < n; i++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[i+n];\\n        }\\n        return shuffleArray;\\n    }\\n};\\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> shuffleArray(2*n);\\n        for(int i = 0, j = n; i < n, j < 2*n; i++, j++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[j];\\n        }\\n        return shuffleArray;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] shuffleArray = new int[2*n];\\n        for(int i = 0, j = n; i < n && j < 2*n; i++, j++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[j];\\n        }\\n        return shuffleArray;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        shuffleArray = [0] * (2 * n)\\n        for i in range(n):\\n            shuffleArray[2 * i] = nums[i]\\n            shuffleArray[2 * i + 1] = nums[i + n]\\n        return shuffleArray\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(2*n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> shuffleArray(2*n);\\n        for(int i = 0; i < n; i++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[i+n];\\n        }\\n        return shuffleArray;\\n    }\\n};\\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> shuffleArray(2*n);\\n        for(int i = 0, j = n; i < n, j < 2*n; i++, j++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[j];\\n        }\\n        return shuffleArray;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] shuffleArray = new int[2*n];\\n        for(int i = 0, j = n; i < n && j < 2*n; i++, j++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[j];\\n        }\\n        return shuffleArray;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        shuffleArray = [0] * (2 * n)\\n        for i in range(n):\\n            shuffleArray[2 * i] = nums[i]\\n            shuffleArray[2 * i + 1] = nums[i + n]\\n        return shuffleArray\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148587,
                "title": "java-o-n-time-6-lines-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] shuffle(int[] nums, int n) {\\n    var ans = new int[2*n];\\n    var j = 0;\\n\\n    for (var i=0; i<n; i++) {\\n      ans[j++] = nums[i];\\n      ans[j++] = nums[i+n];\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public int[] shuffle(int[] nums, int n) {\\n    var ans = new int[2*n];\\n    var j = 0;\\n\\n    for (var i=0; i<n; i++) {\\n      ans[j++] = nums[i];\\n      ans[j++] = nums[i+n];\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772874,
                "title": "c-easy-to-understand-tc-o-1-sc-o-1-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int j = n;\\n        vector<int>ans;\\n        for(int  i = 0; i<n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[j]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**# Complexity :\\nTime complexity: O(n) --- > Linear time complexity\\nSpace complexity:O(n) ----> Linear space complexity as we used the vector**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int j = n;\\n        vector<int>ans;\\n        for(int  i = 0; i<n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[j]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958308,
                "title": "c-easy-solution-without-using-built-in-functions",
                "content": "```\\npublic int[] Shuffle(int[] nums, int n)\\n    {\\n        int x = 0;\\n        int[] result = new int[nums.Length];\\n        for (int i = 0; i < result.Length; i++)\\n        {\\n            if (i % 2 == 0)\\n            {\\n                result[i] = nums[x];\\n                x++;\\n            }\\n            else\\n            {\\n                result[i] = nums[n];\\n                n++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic int[] Shuffle(int[] nums, int n)\\n    {\\n        int x = 0;\\n        int[] result = new int[nums.Length];\\n        for (int i = 0; i < result.Length; i++)\\n        {\\n            if (i % 2 == 0)\\n            {\\n                result[i] = nums[x];\\n                x++;\\n            }\\n            else\\n            {\\n                result[i] = nums[n];\\n                n++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 884982,
                "title": "simple-ruby-solution",
                "content": "```\\ndef shuffle(nums, n)\\n    result = []\\n    \\n    n.times do |i|\\n       result << nums[i]\\n        result << nums[i+n]\\n    end\\n    \\n    result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef shuffle(nums, n)\\n    result = []\\n    \\n    n.times do |i|\\n       result << nums[i]\\n        result << nums[i+n]\\n    end\\n    \\n    result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 768319,
                "title": "c-o-n-solutions",
                "content": "**Solution1: two-index**\\n\\nHave two pointers (idx1 and idx2) pointing at the beginning of the 1st half and 2nd half of the input array respectively, then fill in the result array by moving idx1 and idx2 rightward alternatly. \\n\\nTime complexity and space complexity are both O(n).\\n\\n```\\npublic class Solution {\\n    public int[] Shuffle(int[] nums, int n) {\\n     \\n        if(nums == null || nums.Length == 0)\\n            return nums;\\n        \\n        int[] res = new int[2 * n];\\n        int idx1 = 0, idx2 = n;\\n        \\n        for(int i = 0; i < 2 * n; i++)\\n        {\\n            if(i % 2 == 0)\\n                res[i] = nums[idx1++];\\n            else\\n                res[i] = nums[idx2++];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n\\n**Solution2: one-index**\\n\\nMap nums[i] to res[2 * i], nums[n + i] to res[2 * i + 1]. Every iteration within the for loop fills in two cells of the result array.\\n\\nTime complexity and space complexity are both O(n).\\n\\n```\\npublic class Solution{\\n    public int[] Shuffle(int[] nums, int n){\\n\\t\\n        if (nums == null || nums.Length == 0)\\n            return nums;\\n\\n        int[] res = new int[2 * n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[2 * i] = nums[i];\\n            res[2 * i + 1] = nums[n + i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] Shuffle(int[] nums, int n) {\\n     \\n        if(nums == null || nums.Length == 0)\\n            return nums;\\n        \\n        int[] res = new int[2 * n];\\n        int idx1 = 0, idx2 = n;\\n        \\n        for(int i = 0; i < 2 * n; i++)\\n        {\\n            if(i % 2 == 0)\\n                res[i] = nums[idx1++];\\n            else\\n                res[i] = nums[idx2++];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution{\\n    public int[] Shuffle(int[] nums, int n){\\n\\t\\n        if (nums == null || nums.Length == 0)\\n            return nums;\\n\\n        int[] res = new int[2 * n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[2 * i] = nums[i];\\n            res[2 * i + 1] = nums[n + i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740333,
                "title": "c-one-liner",
                "content": "```\\npublic int[] Shuffle(int[] nums, int n) => nums\\n\\t.Select((x, i) => (i: i < n ? 2 * i : 2 * (i - n) + 1, x))\\n\\t.OrderBy(x => x.i)\\n\\t.Select(x => x.x)\\n\\t.ToArray();\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] Shuffle(int[] nums, int n) => nums\\n\\t.Select((x, i) => (i: i < n ? 2 * i : 2 * (i - n) + 1, x))\\n\\t.OrderBy(x => x.i)\\n\\t.Select(x => x.x)\\n\\t.ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729048,
                "title": "python-in-place-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n          \\n        for i in range(n, 2*n):\\n            nums[i] = (nums[i] << 10) | nums[i-n]\\n        \\n        for i in range(n, 2*n):\\n            nums[(i-n)*2] = nums[i] & (2 ** 10 - 1)\\n            nums[(i-n)*2+1] = nums[i] >> 10\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n          \\n        for i in range(n, 2*n):\\n            nums[i] = (nums[i] << 10) | nums[i-n]\\n        \\n        for i in range(n, 2*n):\\n            nums[(i-n)*2] = nums[i] & (2 ** 10 - 1)\\n            nums[(i-n)*2+1] = nums[i] >> 10\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684920,
                "title": "java-simple-and-easy-solution-100-faster-and-100-less-space",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int left=0,mid=n;\\n        int b[]= new int[2*n];\\n        for(int i=0;i<2*n;i=i+2)\\n        {\\n            b[i] = nums[left++];\\n            b[i+1] = nums[mid++];\\n        }\\n        return b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int left=0,mid=n;\\n        int b[]= new int[2*n];\\n        for(int i=0;i<2*n;i=i+2)\\n        {\\n            b[i] = nums[left++];\\n            b[i+1] = nums[mid++];\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674302,
                "title": "c-iteration-with-offset-explained-100-speed-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        \\n        //Alternately add x (first half numbers) and y to populate ans\\n        for (int i = 0; i < n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[n+i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        \\n        //Alternately add x (first half numbers) and y to populate ans\\n        for (int i = 0; i < n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[n+i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149603,
                "title": "easy-c-solution-using-two-queues",
                "content": "In the first loop, I am storing two half contents of vector in two different queues.\\nIn the second loop, I am rewriting the stored values of queues back into the vector alternatively.\\n\\n```\\n#include <queue>\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        queue<int> p,q;\\n        std::vector<int>::iterator itr1=nums.begin(),itr2=nums.begin()+nums.size()/2;\\n        while(itr2!=nums.end())\\n        {\\n            p.push(*itr1);\\n            q.push(*itr2);\\n            itr1++;\\n            itr2++;\\n        }\\n        itr1=nums.begin();\\n        itr2=nums.begin()+1;\\n        while(itr2!=nums.end()&&itr1!=nums.end())\\n        {\\n            *itr1=p.front();\\n            p.pop();\\n            *itr2=q.front();\\n            q.pop();\\n            itr1+=2;\\n            itr2+=2;\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        queue<int> p,q;\\n        std::vector<int>::iterator itr1=nums.begin(),itr2=nums.begin()+nums.size()/2;\\n        while(itr2!=nums.end())\\n        {\\n            p.push(*itr1);\\n            q.push(*itr2);\\n            itr1++;\\n            itr2++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3149513,
                "title": "java-solution-easy-method-0ms-runtime-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis program comes with a pattern to follow. The array must look like 0,n+0,1,n+1 ....\\nSo lets get started...\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere lets simply initialize an array of length `2n` because total size of given array `nums` is `2n`\\nNow iterating all the elements till nth. We store `i`th and `i+n`th element to the array. This way we store 2 elements in one iteration upto `n`. So total `2n` elements stored.\\nWe got our result.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[] = new int[2*n];\\n        int k = 0;\\n        for(int i = 0; i < n; i++){\\n            ans[k++] = nums[i];\\n            ans[k++] = nums[i+n];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nI Hope the approach is clear to you.\\n\\nPLEASE DO UPVOTE!!!\\n\\nThank You",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[] = new int[2*n];\\n        int k = 0;\\n        for(int i = 0; i < n; i++){\\n            ans[k++] = nums[i];\\n            ans[k++] = nums[i+n];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148896,
                "title": "easy-c-beginner-friendly-understandable",
                "content": "# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148483,
                "title": "python-solution-reduce",
                "content": "\\n```python\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return reduce(lambda x, y: x + [nums[y], nums[y + n]], range(n), [])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return reduce(lambda x, y: x + [nums[y], nums[y + n]], range(n), [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111192,
                "title": "java-best-solution-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Seperate the Halfs in different arrays.\\n- Then Combine According to the Pattern.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int size = 2*n;\\n        ArrayList<Integer> a = new ArrayList<>();\\n        ArrayList<Integer> b = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            a.add(nums[i]);\\n            b.add(nums[n +i]);\\n        }\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int j = 0; j < n; j++) {\\n            list.add(a.get(j));\\n            list.add(b.get(j));\\n        }\\n        int[] arr = new int[size];\\n        for (int k = 0; k < size; k++) {\\n            arr[k] = list.get(k).intValue();\\n        }\\n        return arr;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e4f1e2a8-b10b-46db-9ce6-9c2562a1a933_1674945307.2145095.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int size = 2*n;\\n        ArrayList<Integer> a = new ArrayList<>();\\n        ArrayList<Integer> b = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            a.add(nums[i]);\\n            b.add(nums[n +i]);\\n        }\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int j = 0; j < n; j++) {\\n            list.add(a.get(j));\\n            list.add(b.get(j));\\n        }\\n        int[] arr = new int[size];\\n        for (int k = 0; k < size; k++) {\\n            arr[k] = list.get(k).intValue();\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717036,
                "title": "python-simple-solution-in-4-lines-faster-than-98-85",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        a,n=[],len(nums)//2\\n        for i in range(n):\\n            a.extend([nums[i],nums[n+i]])\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        a,n=[],len(nums)//2\\n        for i in range(n):\\n            a.extend([nums[i],nums[n+i]])\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579034,
                "title": "java-100-00-faster-solution-with-explanation",
                "content": "##### **If the solution was helpful don\\'t forget to vote**\\nRuntime: 0 ms, faster than 100.00% to Runtime: 1 ms, faster than 67.58%\\n![image](https://assets.leetcode.com/users/images/d9f00fe3-c554-42d7-94c8-b832918b2660_1663236617.6566644.jpeg)\\n\\n\\n1. [x1,x2,x3,y1,y2,y3]->[x1,y1,x2,y2,x3,y3], n = 3 - half of array(pointer)\\n1. mentally divide the array into two parts before and after the pointer\\n1. [x1,x2,x3] [pointer -> (y1),y2,y3]\\n1. create an empty array with nums.length [0, 0, 0, 0, 0, 0]\\n1. put elements form nums[leftPartStartIndex] to all even positions of result[] and increase leftPartStartIndex to 1\\n1. put elements form nums[rightPartStartIndex] to all odd positions of result[] and increase rightPartStartIndex to 1\\n1. this is because all X are on the left part and should take all even positions in result[] and all Y should take odd\\n\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\n        int[] result = new int[nums.length];\\n        int leftPartStartIndex = 0;\\n        int rightPartStartIndex = n;\\n\\n        for (int i = 0; i < result.length; i += 2) {\\n            result[i] = nums[leftPartStartIndex];\\n            leftPartStartIndex++;\\n        }\\n        \\n        for (int i = 1; i <= result.length; i += 2) {\\n            result[i] = nums[rightPartStartIndex];\\n            rightPartStartIndex++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\n        int[] result = new int[nums.length];\\n        int leftPartStartIndex = 0;\\n        int rightPartStartIndex = n;\\n\\n        for (int i = 0; i < result.length; i += 2) {\\n            result[i] = nums[leftPartStartIndex];\\n            leftPartStartIndex++;\\n        }\\n        \\n        for (int i = 1; i <= result.length; i += 2) {\\n            result[i] = nums[rightPartStartIndex];\\n            rightPartStartIndex++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697309,
                "title": "python-code-shuffle-the-array",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        c=[]\\n        for i in range(n):\\n            c.append(nums[i])\\n            c.append(nums[n+i])\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        c=[]\\n        for i in range(n):\\n            c.append(nums[i])\\n            c.append(nums[n+i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588502,
                "title": "python-easiest-solution",
                "content": "```\\neasy python solution\\n```class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            if i+n<=len(nums)-1:\\n                k.append(nums[i])\\n                k.append(nums[i+n])\\n        return k\\n\\t\\t```\\n\\t\\t\\n\\t\\t\\n\\nPlease UPVOTE if you like the Solution",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\neasy python solution\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1204621,
                "title": "java-very-simple-approach",
                "content": "public int[] shuffle(int[] nums, int n)\\n    {\\n        int[] res = new int[nums.length];\\n        int  j =0;\\n        for(int i =0;i<n;i++)\\n        {\\n            res[j++] = nums[i];\\n            res[j++] = nums[i+n];\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "public int[] shuffle(int[] nums, int n)\\n    {\\n        int[] res = new int[nums.length];\\n        int  j =0;\\n        for(int i =0;i<n;i++)\\n        {\\n            res[j++] = nums[i];\\n            res[j++] = nums[i+n];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1043705,
                "title": "best-java-solution",
                "content": "Faster than 100%\\n\\nint[] result = new int[2 * n];\\n        \\n        int counter = 0;\\n        for (int i = 0; i < n; i++) {\\n           result[counter] = nums[i];\\n           result[counter + 1] = nums[i + n];\\n           counter = counter + 2;\\n        }\\n        \\n        return result;",
                "solutionTags": [],
                "code": "Faster than 100%\\n\\nint[] result = new int[2 * n];\\n        \\n        int counter = 0;\\n        for (int i = 0; i < n; i++) {\\n           result[counter] = nums[i];\\n           result[counter + 1] = nums[i + n];\\n           counter = counter + 2;\\n        }\\n        \\n        return result;",
                "codeTag": "Unknown"
            },
            {
                "id": 683160,
                "title": "python-3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\t\\tresult = []\\n\\t\\tfor i in range(n):\\n\\t\\t\\tresult += nums[i::n]\\n\\t\\treturn result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\t\\tresult = []\\n\\t\\tfor i in range(n):\\n\\t\\t\\tresult += nums[i::n]\\n\\t\\treturn result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677223,
                "title": "javascript-1-line-recursive-solution",
                "content": "_Runtime: 100 ms, faster than 53.00% of JavaScript online submissions_\\n_Memory Usage: 50.5 MB, less than 100.00% of JavaScript online submissions_\\n\\n```javascript\\nconst shuffle = (nums, n, a = []) =>\\n  !nums.length\\n    ? a\\n    : shuffle(\\n        nums,\\n        n - 1,\\n        a.concat(nums.splice(0, 1), nums.splice(1 * n - 1, 1)),\\n      );\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nconst shuffle = (nums, n, a = []) =>\\n  !nums.length\\n    ? a\\n    : shuffle(\\n        nums,\\n        n - 1,\\n        a.concat(nums.splice(0, 1), nums.splice(1 * n - 1, 1)),\\n      );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908058,
                "title": "java-100-beat-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        \\n        int[] temp = new int[nums.length];\\n        int mid = nums.length/2;\\n        int i = 0; //iterator for left half\\n        int j = mid; //iterator for right half\\n        int k = 0; //iterator for temp array\\n        while(i<mid && j < nums.length){\\n            temp[k] = nums[i];\\n            i++;\\n            k++;\\n            temp[k] = nums[j];\\n            j++;\\n            k++;\\n        } \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        \\n        int[] temp = new int[nums.length];\\n        int mid = nums.length/2;\\n        int i = 0; //iterator for left half\\n        int j = mid; //iterator for right half\\n        int k = 0; //iterator for temp array\\n        while(i<mid && j < nums.length){\\n            temp[k] = nums[i];\\n            i++;\\n            k++;\\n            temp[k] = nums[j];\\n            j++;\\n            k++;\\n        } \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636383,
                "title": "beats-in-runtime-only-in-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[nums.length];\\n        for(int i = 0, j = 0; j < n; i++) {\\n            if(i % 2 == 0) {\\n                res[i] = nums[j];\\n            } else {\\n                res[i] = nums[j+n];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[nums.length];\\n        for(int i = 0, j = 0; j < n; i++) {\\n            if(i % 2 == 0) {\\n                res[i] = nums[j];\\n            } else {\\n                res[i] = nums[j+n];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503509,
                "title": "100-fast-and-efficient-code-for-beginner",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp = 2 * n;\\n        int [] arr = new int[temp];\\n        for(int i = 0; i < n; i++) {\\n            arr[2 * i] = nums[i];\\n            arr[(2 * i )+ 1] = nums[i + n];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp = 2 * n;\\n        int [] arr = new int[temp];\\n        for(int i = 0; i < n; i++) {\\n            arr[2 * i] = nums[i];\\n            arr[(2 * i )+ 1] = nums[i + n];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152283,
                "title": "golang-simple-one-pass",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nfunc shuffle(nums []int, n int) []int {\\n    res := []int{}\\n\\n    for i := 0; i < n; i++ {\\n        res = append(res, nums[i], nums[i + n])\\n    }\\n\\n    return res\\n}   \\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shuffle(nums []int, n int) []int {\\n    res := []int{}\\n\\n    for i := 0; i < n; i++ {\\n        res = append(res, nums[i], nums[i + n])\\n    }\\n\\n    return res\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3150985,
                "title": "java-100-faster-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/be70a16d-ea9b-4127-9f55-d19353f060e1_1675690966.5966349.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\n        //Take two variables i and j start i from 0 and j from n\\n        int i = 0;\\n        int j = n;\\n\\n        int ans[] = new int[nums.length];//to store the suffled array\\n\\n        int k = 0;//to traverse in ans array\\n\\n        while(k < nums.length){\\n\\n            //If K is even than copy the element on the i\\'th index in nums array to ans array \\n            if(k % 2 == 0){\\n                ans[k] = nums[i];\\n                 i++;\\n                 k++;\\n            }\\n            else{\\n                //If K is odd than copy the element on the j\\'th index in nums array to ans array\\n                ans[k] = nums[j];\\n                 k++;\\n                 j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\n        //Take two variables i and j start i from 0 and j from n\\n        int i = 0;\\n        int j = n;\\n\\n        int ans[] = new int[nums.length];//to store the suffled array\\n\\n        int k = 0;//to traverse in ans array\\n\\n        while(k < nums.length){\\n\\n            //If K is even than copy the element on the i\\'th index in nums array to ans array \\n            if(k % 2 == 0){\\n                ans[k] = nums[i];\\n                 i++;\\n                 k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3150716,
                "title": "c-beats-95-of-submissions",
                "content": "# Intuition\\n- Easy and super simple !!!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Get the length of the nums array.\\n- Traverse the array (len/2) times, where you\\'ll be able to append current element and (current element + nth) element simultaneously.\\n- Return the res array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) \\n    {\\n        int len = nums.size();\\n        vector <int> res;\\n\\n        for(int i = 0; i < len/2; i++)\\n        {\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n++]);\\n        }\\n\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) \\n    {\\n        int len = nums.size();\\n        vector <int> res;\\n\\n        for(int i = 0; i < len/2; i++)\\n        {\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n++]);\\n        }\\n\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149288,
                "title": "beginner-friendly-solution-easy",
                "content": "# Intuition\\nSimple Loop\\n\\n# Approach\\n- Make an array of 2n size \\n- use for loop from 0 to n\\n- store at i and (i+n) index in array\\n- return array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n vector<int>arr;\\n        for(int i=0;i<n;i++){\\n        arr.push_back(nums[i]);\\n            arr.push_back(nums[i+n]);\\n        }\\n        return arr;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n vector<int>arr;\\n        for(int i=0;i<n;i++){\\n        arr.push_back(nums[i]);\\n            arr.push_back(nums[i+n]);\\n        }\\n        return arr;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149191,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans(2*n);\\n        for(int i=0;i<n;i++){\\n            ans[2*i]=nums[i];\\n            ans[2*i+1]=nums[n+i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans(2*n);\\n        for(int i=0;i<n;i++){\\n            ans[2*i]=nums[i];\\n            ans[2*i+1]=nums[n+i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148912,
                "title": "fast-c-solution",
                "content": "# Solution in C++\\n\\n<iframe src=\"https://leetcode.com/playground/2wKHrGhQ/shared\" frameBorder=\"0\" width=\"600\" height=\"450\"></iframe>\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/f3cc070c-d1eb-44ea-a848-7e67e76f2290_1675656196.263727.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Solution in C++\\n\\n<iframe src=\"https://leetcode.com/playground/2wKHrGhQ/shared\" frameBorder=\"0\" width=\"600\" height=\"450\"></iframe>\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/f3cc070c-d1eb-44ea-a848-7e67e76f2290_1675656196.263727.jpeg)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3148905,
                "title": "python-1-liner",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ including output space, else $$O(1)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def shuffle(self, nums: list[int], n: int) -> list[int]:\\n        return [nums[j] for i in range(n) for j in (i, i + n)]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```python\\nclass Solution:\\n    def shuffle(self, nums: list[int], n: int) -> list[int]:\\n        return [nums[j] for i in range(n) for j in (i, i + n)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148557,
                "title": "java-one-liner-streams",
                "content": "# Code\\n```\\nclass Solution {\\n\\tpublic static int[] shuffle(int[] nums, int n) {\\n\\t\\treturn IntStream.range(0, n).flatMap(i -> IntStream.of(nums[i], nums[i + n])).toArray();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Data Stream"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int[] shuffle(int[] nums, int n) {\\n\\t\\treturn IntStream.range(0, n).flatMap(i -> IntStream.of(nums[i], nums[i + n])).toArray();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148491,
                "title": "python-1-itertools-chain-2-numpy-3-conventional-for-loop",
                "content": "**Solution 1: itertools.chain(), zip()**\\nhttps://leetcode.com/submissions/detail/892325819/   \\nRuntime: **60 ms**, faster than 84.21% of Python3 online submissions for Shuffle the Array.   \\nMemory Usage: 14.1 MB, less than 86.30% of Python3 online submissions for Shuffle the Array.    \\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return list(chain(*[[x,y] for x,y in zip(nums[:n], nums[n:])]))\\n```\\n\\n**Solution 2: numpy**  \\nhttps://leetcode.com/submissions/detail/892330831/  \\nRuntime: **127 ms**, faster than 16.21% of Python3 online submissions for Shuffle the Array.   \\nMemory Usage: 32.1 MB, less than 33.52% of Python3 online submissions for Shuffle the Array.   \\n```\\nimport numpy as np\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return np.array(nums).reshape(2,-1).transpose().reshape(1,-1).squeeze().tolist()\\n```\\n\\n**Solution 3: conventional for-loop, O(n)**  \\nhttps://leetcode.com/submissions/detail/892331780/ \\nRuntime: **61 ms**, faster than 79.49% of Python3 online submissions for Shuffle the Array.\\nMemory Usage: 14.2 MB, less than 33.52% of Python3 online submissions for Shuffle the Array.\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l = []\\n        for i in range(n):\\n            l.append(nums[i])\\n            l.append(nums[i+n])\\n        return l\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return list(chain(*[[x,y] for x,y in zip(nums[:n], nums[n:])]))\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return np.array(nums).reshape(2,-1).transpose().reshape(1,-1).squeeze().tolist()\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l = []\\n        for i in range(n):\\n            l.append(nums[i])\\n            l.append(nums[i+n])\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148480,
                "title": "o-1-in-space",
                "content": "# Intuition\\nMoves each element in the array to its target position. Repeat the process for the replaced element.\\n\\n# Approach\\nFor each element in the array, move it to its final position, then repeat the process for the replaced element. Multiply the value in the position by -1 so we know when to stop the process (completed the cycle in the graph).\\n\\nThen iterate over each element to restore the original value.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        nums[0] *= -1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int j = i;\\n            int currentNumber = nums[i];\\n            while (nums[j] > 0) {\\n                int target;\\n                if (j < n) {\\n                    target = j * 2;\\n                } else {\\n                    target = (j - n) * 2 + 1;\\n                }\\n                var temp = nums[target];\\n                nums[target] = currentNumber;\\n                currentNumber = temp;\\n                nums[j] *= -1;\\n                j = target;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = Math.abs(nums[i]);\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        nums[0] *= -1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int j = i;\\n            int currentNumber = nums[i];\\n            while (nums[j] > 0) {\\n                int target;\\n                if (j < n) {\\n                    target = j * 2;\\n                } else {\\n                    target = (j - n) * 2 + 1;\\n                }\\n                var temp = nums[target];\\n                nums[target] = currentNumber;\\n                currentNumber = temp;\\n                nums[j] *= -1;\\n                j = target;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = Math.abs(nums[i]);\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148402,
                "title": "python-single-line-list-comprehension",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [nums[x + n * y] for x in range(n) for y in range(2)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [nums[x + n * y] for x in range(n) for y in range(2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800328,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> shuffle(vector<int>& nums, int n) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tans.push_back(nums[i]);\\n\\t\\t\\t\\tans.push_back(nums[n+i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> shuffle(vector<int>& nums, int n) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tans.push_back(nums[i]);\\n\\t\\t\\t\\tans.push_back(nums[n+i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2450292,
                "title": "java-easy-2-lines",
                "content": "```\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int na[] = new int[2*n];\\n        for(int i =0;i<2*n;i++){\\n            na[i]= (i%2==0) ? nums[i/2] : nums[n + i/2];\\n        }\\n        return na;   \\n    } \\n   \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int na[] = new int[2*n];\\n        for(int i =0;i<2*n;i++){\\n            na[i]= (i%2==0) ? nums[i/2] : nums[n + i/2];\\n        }\\n        return na;   \\n    } \\n   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269850,
                "title": "python-3-simple-solution",
                "content": "Here is my simple solution:\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        a = []\\n        for x in range(n):\\n            a.append(nums[x])\\n            a.append(nums[x+n])\\n        return a\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "Here is my simple solution:\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        a = []\\n        for x in range(n):\\n            a.append(nums[x])\\n            a.append(nums[x+n])\\n        return a\\n",
                "codeTag": "Java"
            },
            {
                "id": 2062844,
                "title": "100-faster-java-easy-approach",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[] = new int[2*n];\\n        int k=0;\\n        for(int i=0;i<ans.length;i+=2){\\n            ans[i] = nums[k];\\n            ans[i+1] = nums[k+n];\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[] = new int[2*n];\\n        int k=0;\\n        for(int i=0;i<ans.length;i+=2){\\n            ans[i] = nums[k];\\n            ans[i+1] = nums[k+n];\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060992,
                "title": "easiest-two-pointer-approach-space-complexity-o-n",
                "content": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        \\n        // i -->  0 1 2 3 4 5 \\n        // val--> 2,5,1,3,4,7\\n        // out--> \\n        // i = 0 --> nums[0],nums[3] || res[2,3] resIndex = 0, 1,\\n        // i = 1 --> nums[1],nums[4] || res[2,3, 5,4] resIndex = 2, 3, \\n        // i = 2 --> nums[2],nums[5] || res[2,3, 5,4, 1,7] resIndex = 4, 5\\n        // nums[i], nums[i+n]\\n        // resIndex++ assign(0) and increment(0+1) ==> 1\\n        int[] result = new int[nums.length];\\n        int resIndex = 0;\\n        for(int i=0; i<n; i++) {\\n            result[resIndex++] = nums[i];\\n            result[resIndex++] = nums[i+n];\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        \\n        // i -->  0 1 2 3 4 5 \\n        // val--> 2,5,1,3,4,7\\n        // out--> \\n        // i = 0 --> nums[0],nums[3] || res[2,3] resIndex = 0, 1,\\n        // i = 1 --> nums[1],nums[4] || res[2,3, 5,4] resIndex = 2, 3, \\n        // i = 2 --> nums[2],nums[5] || res[2,3, 5,4, 1,7] resIndex = 4, 5\\n        // nums[i], nums[i+n]\\n        // resIndex++ assign(0) and increment(0+1) ==> 1\\n        int[] result = new int[nums.length];\\n        int resIndex = 0;\\n        for(int i=0; i<n; i++) {\\n            result[resIndex++] = nums[i];\\n            result[resIndex++] = nums[i+n];\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811742,
                "title": "java-space-o-1-time-o-n-solved-without-taking-extra-array",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int size = nums.length;\\n        for(int i=n;i<size;i++){\\n            nums[i]=(nums[i]*10000)+nums[i-n];\\n        }\\n        for(int i=0;i<size;i=i+2){\\n            nums[i]=nums[n]%10000;\\n            nums[i+1]=nums[n]/10000;\\n            n++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int size = nums.length;\\n        for(int i=n;i<size;i++){\\n            nums[i]=(nums[i]*10000)+nums[i-n];\\n        }\\n        for(int i=0;i<size;i=i+2){\\n            nums[i]=nums[n]%10000;\\n            nums[i+1]=nums[n]/10000;\\n            n++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752042,
                "title": "python-beautiful-o-n-time-o-1-space-with-explanation",
                "content": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n        \\n        for i in range(n):\\n            nums[i] = nums[i] * 10000 + nums[n + i]\\n        \\n        for i in range(n-1,-1,-1):\\n            \\n            nums[2 * i + 1] = nums[i] % 10000\\n            nums[2 * i] = nums[i] // 10000\\n        \\n        return nums\\n            \\n```\\n\\nConsider the example: [2,5,1,3,4,7]. Output should be [2,3,5,4,1,7].\\n\\nIn the first for loop we kinda hide two numbers inside one. After doing this loop the array will be [20003,50004,10007,3,4,7]. Look at the first half of the array, it contains all numbers in desired order! Compare the first half of the array with the output we want to get.\\n\\nNow we just need to extract these numbers from this combined form. That\\'s exactly what the second loop does. It starts from the end of the array and one by one extracts combined numbers and puts them into the correct positions.\\n\\nThis trick of multiplying by 10000 only possible because of the constraint 1 <= nums[i] <= 10^3. So if the upper bound is larger we have to change 10000 to a larger number. This is not a universal solution, but I like it\\'s smartness. \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n        \\n        for i in range(n):\\n            nums[i] = nums[i] * 10000 + nums[n + i]\\n        \\n        for i in range(n-1,-1,-1):\\n            \\n            nums[2 * i + 1] = nums[i] % 10000\\n            nums[2 * i] = nums[i] // 10000\\n        \\n        return nums\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1641213,
                "title": "java-c-simple-o-1-space-in-place-100-faster-efficient-explained",
                "content": "# **Please Upvote If you got any help from the provided solution!!!**\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n**COMPLEXITY:**\\n* **Time: O(n)**, where n is the given number, which is half of the length of the array\\n* **Space: O(1)**, in-place<br>\\n\\n\\nSince we need to solve it in 0(1) space or **in-place**, we will use the original array.\\n\\n**BASIC IDEA:**\\n1. **Store the pair of numbers** and then\\n2. **Retreive each number,** from that pair where they were stored, **one by one** and place them at their desired positions.\\n<br>\\n\\n**GENERAL EXAMPLE:**\\n*Suppose, you are performing a task and someone gives you another task, in order to avoid disturbance in the flow of previous task, you can keep both the tasks on one side and complete the task one by one according to the requirement.*\\n\\n**SAME CONCEPT FOR ARRAYS:**\\n*In order to avoid overwriting values, store the \"pair of numbers\" in the right half of the array and retrieve the numbers by one according to the requirement.*\\n<br>\\n**#  <u>DETAILED EXPLANATION IS GIVEN BELOW THE CODE</u> #**\\n<br>\\n\\n<u>**NOTE:**</u>  --> Runtime Fluctuates a lot in case of C++(0ms to 4ms)\\n\\n<u>**C++ / JAVA CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/arHM8WHa/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n<hr>\\n\\n**Using Bitwise Operator to make it a bit faster**<br>\\n\\n<u>**NOTE:**</u>  --> Runtime Fluctuates a lot in case of C++(0ms to 4ms)\\n\\n<u>**C++ / JAVA CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/QHAeabD9/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\n<hr>\\n\\n<u>**EXPLANATION:**</u>\\n\\n**Let\\'s understand in general term:**\\n\\nSuppose we have 2 numbers `num1 = 4` and `num2 = 9` and `maxValue = 10`\\n**Formula:**\\n**to store** -> pair = (num2 &times; maxValue) + num1\\n**to retrieve** -> pair % maxValue and pair / maxValue\\n\\n1. **Storing the pair of numbers**\\n\\n\\t(9 &times; 10) + 4 = 94 --> from above formula (num2 &times; maxValue) + num1\\n\\t**94 is stored**\\n\\n2. **Retrieving each number one by one**\\n\\n\\t94 % 10 = 4\\n\\t**we got first number as 4**\\n\\n\\t94 / 10 = 9\\n\\t**we got second number as 9**\\n\\nSame idea goes for large cases and array as well but instead of 10, we will take 1024 to store pairs and retrieve each number\\n**<u>NOTE:</u> Here, we will take 1024 because of the given constraints `1 <= nums[i] <= 10^3` i.e. the largest number in the array will be 1000**\\n\\nNow, \\n**Binary representation** of **1000** is **1111101000**, consisting of total **10 bits**\\n**Binary representation** of **1024** is **10000000000**, consisting of total **11 bits**\\nand if we multiply 1000 with 1024 i.e. **(1000 * 1024)**, we will get **1024000**\\n**Binary representation** of **1024000** is **11111010000000000000**, consisting of total **20 bits** which is less than the number of bits **(32bits)** of int data type, so we can store the number pairs(by multiplying one number with 1024 and adding another number to it) to retrieve each indivisual number later on(by taking out the remainder and the quotient).\\neg: suppose we have an **`array of length 4`** and **`n is 2`**\\n`nums = [5, 2, 1000, 3]` and `n = 2`\\n\\n1. **We will store the pair of numbers first**\\n\\n\\tAccording to algorithm\\n\\t\\n\\t```\\n\\t// to store the pair of numbers in right half of the original array\\n\\tfor(int i = n; i < len; i++)\\n\\tnums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t```\\n\\t* \\t**Iteration 1:**\\n\\t\\twhen i = 2, (i = 2 because value of n is 2)\\n\\t\\tnums[2] = (1000 &times; 1024) + 5 \\n\\t\\tso, nums[2] = 1024005\\n\\n\\t* \\t**Iteration 2:**\\n\\t\\twhen i = 3,\\n\\t\\tnums[3] = (3 &times; 1024) + 2\\n\\t\\tso, nums[3] = 3074\\n\\n\\t**Now, the original array**\\n\\t[5, 2, 1000, 3]\\n\\t&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;<-- Indexes\\n\\t**becomes**\\n\\t[5, 2, 1024005, 3074]\\n\\t&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;<-- Indexes\\n\\n2. **We will retrieve the numbers one by one from the pairs which we have stored at 2nd and 3rd index**\\n\\n\\tAccording to algorithm\\n\\t```\\n\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n\\tint index = 0;\\n\\tfor(int i = n; i < len; i++, index += 2){\\n\\t\\tnums[index] = nums[i] % 1024;\\n\\t\\tnums[index + 1] = nums[i] / 1024;\\n\\t}\\n\\t```\\n\\n\\t* \\t**Iteration 1:**\\n\\t\\twhen index = 0 and i = 2, (i = 2 because value of n is 2)\\n\\t\\tnums[0] = 1024005 % 1024 = 5\\n\\t\\tnums[1] = 1024005 / 1024 = 1000\\n\\t\\tnow, index = 2 (from index += 2)\\n\\n\\t* \\t**Iteration 2:**\\n\\t\\twhen index = 2, i = 3,\\n\\t\\tnums[2] = 3074 % 1024 = 2\\n\\t\\tnums[3] = 3074 / 1024 = 3\\n\\n\\tIteration will be stopped now as the condition become false and we got the array as following\\n\\t**[5, 1000, 2, 3]  <-- Desired Output**\\n\\t&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;<-- Indexes\\n<hr>\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<hr>\\n\\n# **Please Upvote If you got any help from the provided solution!!!**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\\t// to store the pair of numbers in right half of the original array\\n\\tfor(int i = n; i < len; i++)\\n\\tnums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t```\n```\\n\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n\\tint index = 0;\\n\\tfor(int i = n; i < len; i++, index += 2){\\n\\t\\tnums[index] = nums[i] % 1024;\\n\\t\\tnums[index + 1] = nums[i] / 1024;\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552721,
                "title": "c-5line-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int index=0;index<n;index++)\\n        {\\n            ans.push_back(nums[index]);\\n            ans.push_back(nums[n+index]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int index=0;index<n;index++)\\n        {\\n            ans.push_back(nums[index]);\\n            ans.push_back(nums[n+index]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363983,
                "title": "java-0ms-100-fast",
                "content": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        int[] numsResult = nums.clone();\\n        int currentIndex = 0;\\n        for(int i = 0; i < nums.length - n; i++) { // from index 0 to array length - n\\n            numsResult[currentIndex] = nums[i];\\n            numsResult[currentIndex + 1] = nums[i + n];\\n            currentIndex += 2; // increase current index by 2\\n        }\\n        return numsResult;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        int[] numsResult = nums.clone();\\n        int currentIndex = 0;\\n        for(int i = 0; i < nums.length - n; i++) { // from index 0 to array length - n\\n            numsResult[currentIndex] = nums[i];\\n            numsResult[currentIndex + 1] = nums[i + n];\\n            currentIndex += 2; // increase current index by 2\\n        }\\n        return numsResult;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261684,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Take 2 pointers, start 1 from zero and second from n. initialise an array and add values with the help of both pointers.\\n\\n\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[n*2];\\n        int c = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                newArr[i] = nums[c];\\n                c++;\\n            }\\n            else{\\n                newArr[i]= nums[n];\\n                n++;\\n            }\\n        }\\n        newArr[n] = nums[n];\\n        return newArr;\\n    }\\n}\\n```\\n\\nUpvote if it helped.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[n*2];\\n        int c = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                newArr[i] = nums[c];\\n                c++;\\n            }\\n            else{\\n                newArr[i]= nums[n];\\n                n++;\\n            }\\n        }\\n        newArr[n] = nums[n];\\n        return newArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242662,
                "title": "java-2-line-code-faster-then-100",
                "content": "public int[] shuffle(int[] nums, int n) {\\n      int answer[]=new int[nums.length];\\n      int index=0,j=n;\\n        for(int i=0;i<n;i++){\\n            answer[index++]=nums[i];\\n            answer[index++]=nums[j++];\\n        }\\n        return answer;\\n    }",
                "solutionTags": [],
                "code": "public int[] shuffle(int[] nums, int n) {\\n      int answer[]=new int[nums.length];\\n      int index=0,j=n;\\n        for(int i=0;i<n;i++){\\n            answer[index++]=nums[i];\\n            answer[index++]=nums[j++];\\n        }\\n        return answer;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1180919,
                "title": "go-easy",
                "content": "Do upvote if you like it! :)\\n```\\nfunc shuffle(nums []int, n int) []int {\\n     var res []int\\n    for i:=0;i<n;i++{\\n        res=append(res,nums[i])\\n        res=append(res,nums[i+n])\\n    }\\n     return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc shuffle(nums []int, n int) []int {\\n     var res []int\\n    for i:=0;i<n;i++{\\n        res=append(res,nums[i])\\n        res=append(res,nums[i+n])\\n    }\\n     return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158747,
                "title": "python-solution-99-18",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        \\n        result = []\\n        for i in range(n):\\n            result.append(nums[i])\\n            result.append(nums[n+i])\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        \\n        result = []\\n        for i in range(n):\\n            result.append(nums[i])\\n            result.append(nums[n+i])\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116865,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nint[] result = new int[nums.length];\\n        int x=0;\\n        int y =n;\\n        for(int i = 0;i<nums.length;i++){\\n            if(i%2==0) result[i]= nums[x++];\\n            else result[i]=nums[y++];\\n            \\n        }\\n        return result;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint[] result = new int[nums.length];\\n        int x=0;\\n        int y =n;\\n        for(int i = 0;i<nums.length;i++){\\n            if(i%2==0) result[i]= nums[x++];\\n            else result[i]=nums[y++];\\n            \\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 784709,
                "title": "javascript-76ms",
                "content": "```\\nvar shuffle = function(nums, n) {\\n    let arr= []\\n    for(let i=0; i< n; i++){\\n        arr.push(nums[i])\\n        arr.push(nums[n+i])\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    let arr= []\\n    for(let i=0; i< n; i++){\\n        arr.push(nums[i])\\n        arr.push(nums[n+i])\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747439,
                "title": "straightforward-go-solution",
                "content": "```\\nfunc shuffle(nums []int, n int) []int {\\n    x := nums[:n]\\n    y := nums[n:]\\n    \\n    var retVal []int\\n    \\n    for i := 0; i < len(x); i++ {\\n        retVal = append(retVal, x[i]);\\n        retVal = append(retVal, y[i]);\\n    }\\n    \\n    return retVal\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shuffle(nums []int, n int) []int {\\n    x := nums[:n]\\n    y := nums[n:]\\n    \\n    var retVal []int\\n    \\n    for i := 0; i < len(x); i++ {\\n        retVal = append(retVal, x[i]);\\n        retVal = append(retVal, y[i]);\\n    }\\n    \\n    return retVal\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717900,
                "title": "c-solution",
                "content": "```\\nint* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    *returnSize = numsSize;\\n    int i, j=0;\\n    int *shufflenums;\\n    shufflenums = (int*)malloc(sizeof(int)*numsSize);\\n    for(i=0;i<n;i++){\\n        shufflenums[j++] = nums[i];\\n        shufflenums[j++] = nums[i+n];\\n    }\\n    return shufflenums;\\n}\\n``",
                "solutionTags": [],
                "code": "```\\nint* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    *returnSize = numsSize;\\n    int i, j=0;\\n    int *shufflenums;\\n    shufflenums = (int*)malloc(sizeof(int)*numsSize);\\n    for(i=0;i<n;i++){\\n        shufflenums[j++] = nums[i];\\n        shufflenums[j++] = nums[i+n];\\n    }\\n    return shufflenums;\\n}\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 707179,
                "title": "javascript-solution-faster-than-93",
                "content": "```\\nvar shuffle = function(nums, n) {\\n    let arr = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        arr.push(nums[i]);\\n        arr.push(nums[i + n]);\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    let arr = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        arr.push(nums[i]);\\n        arr.push(nums[i + n]);\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703905,
                "title": "basic-generator-based-python-3-solution-95-100",
                "content": "I went through most of the Python solutions, but I haven\\'t seen any that used the generator pattern. It\\'s relatively fast, running at 56 ms at times (faster than 95.42% at the time of writing), and doesn\\'t use a lot of memory (13.8 MB, less than 100%). \\n\\nIt\\'s just a simple, no-nonsense solution. No allocating of additional lists, no list comprehensions, no usage of itertools. Just an easy to understand `for` loop making use of the provided `n`. Ideally you\\'d also change the return type to `Generator`,  but this works.\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        for i in range(n):\\n            yield nums[i]\\n            yield nums[i+n]\\n```\\n\\nEdit: Apparently I missed two solutions that take a similar approach: [#1](https://leetcode.com/problems/shuffle-the-array/discuss/674365/Clean-Python-3-generator-and-one-liner) and [#2](https://leetcode.com/problems/shuffle-the-array/discuss/690596/Less-memory-than-100-of-Python3-solutions-faster-than-96).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        for i in range(n):\\n            yield nums[i]\\n            yield nums[i+n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703501,
                "title": "java-100-faster-and-100-lesser-memory",
                "content": "```\\nclass Solution {\\n    \\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[2*n];\\n        for(int i = 0; i < n; i++) {\\n            res[2* i] = nums[i];\\n            res[(2 * i) + 1] = nums[i + n];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[2*n];\\n        for(int i = 0; i < n; i++) {\\n            res[2* i] = nums[i];\\n            res[(2 * i) + 1] = nums[i + n];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695039,
                "title": "simple-java-solution-o-n-time-6-lines-of-code-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] op = new int[2*n];\\n        for(int i=0,c=0;i<n;i++){\\n            op[c++]=nums[i];            \\n            op[c++]=nums[i+n];\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] op = new int[2*n];\\n        for(int i=0,c=0;i<n;i++){\\n            op[c++]=nums[i];            \\n            op[c++]=nums[i+n];\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679886,
                "title": "in-place-o-n-time-o-1-space-using-continuous-swap",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        for(int i=1;i<n;++i){\\n            if(nums[i]>0){\\n                int next = i<<1;\\n                while(next!=i){\\n                    int tem = nums[next];\\n                    nums[next] = -nums[i];\\n                    nums[i]=tem;\\n                    if(next<n)next=next<<1;\\n                    else next=((next-n)<<1)+1;\\n                }\\n            }\\n        }\\n        for(int i=2;i<nums.length-1;++i)if(nums[i]<0)nums[i]=-nums[i];\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        for(int i=1;i<n;++i){\\n            if(nums[i]>0){\\n                int next = i<<1;\\n                while(next!=i){\\n                    int tem = nums[next];\\n                    nums[next] = -nums[i];\\n                    nums[i]=tem;\\n                    if(next<n)next=next<<1;\\n                    else next=((next-n)<<1)+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 675537,
                "title": "simple-c-code-faster-than-100",
                "content": "```\\nint* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    int *dst = (int*)malloc(numsSize*sizeof(int));\\n    int i;\\n    for(i=0; i<n; i++){\\n        dst[2*i] = nums[i];\\n        dst[2*i+1] = nums[n+i];\\n    }\\n    *returnSize = numsSize;\\n    return dst;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    int *dst = (int*)malloc(numsSize*sizeof(int));\\n    int i;\\n    for(i=0; i<n; i++){\\n        dst[2*i] = nums[i];\\n        dst[2*i+1] = nums[n+i];\\n    }\\n    *returnSize = numsSize;\\n    return dst;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675172,
                "title": "c-shuffling-in-place-with-auxiliary-vector",
                "content": "**Without auxiliary vector** - Runtime - 20 ms, Memory - 9.8 MB\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int offset = 1, index = n;\\n        for(int i = 0; i < n; i++) {\\n            nums.insert(nums.begin()+offset, nums[index++]);\\n            nums.erase(nums.begin()+index);\\n            offset += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n**With auxiliary vector** - Runtime - 12 ms, Memory - 10 MB\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& v, int n) {\\n        vector<int> res;\\n        int f = 0, s = n, c = 1;\\n        for(int i = 0; i < v.size(); i++) {\\n            res.emplace_back(c ? v[f++] : v[s++]);\\n            c ^= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int offset = 1, index = n;\\n        for(int i = 0; i < n; i++) {\\n            nums.insert(nums.begin()+offset, nums[index++]);\\n            nums.erase(nums.begin()+index);\\n            offset += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& v, int n) {\\n        vector<int> res;\\n        int f = 0, s = n, c = 1;\\n        for(int i = 0; i < v.size(); i++) {\\n            res.emplace_back(c ? v[f++] : v[s++]);\\n            c ^= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674777,
                "title": "c-o-1-space-in-place-hint-all-numbers-are-positive",
                "content": "Use negative numbers to flag the right-placed positions.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        auto _map = [&](int i) { return (i < n) ? (i<<1) : (((i-n)<<1) + 1); };\\n        auto _swap = [&](int i, int j) {\\n            swap(nums[i], nums[j]);\\n            nums[j] = -nums[j];\\n        };\\n        \\n        for (int i = 0; i < 2*n; ++i) {\\n            if (nums[i] < 0) continue;\\n            \\n            int j = i;\\n            do {\\n                j = _map(j);\\n                _swap(i, j);\\n            } while (j != i);\\n        }\\n        \\n        for (auto& v : nums) v = -v;\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        auto _map = [&](int i) { return (i < n) ? (i<<1) : (((i-n)<<1) + 1); };\\n        auto _swap = [&](int i, int j) {\\n            swap(nums[i], nums[j]);\\n            nums[j] = -nums[j];\\n        };\\n        \\n        for (int i = 0; i < 2*n; ++i) {\\n            if (nums[i] < 0) continue;\\n            \\n            int j = i;\\n            do {\\n                j = _map(j);\\n                _swap(i, j);\\n            } while (j != i);\\n        }\\n        \\n        for (auto& v : nums) v = -v;\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072467,
                "title": "hey-i-am-here",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = [];\\n    let m = 0;\\n    for(let i=0; i<n; i++) {\\n        res[m] = nums[i];\\n        res[m+1] = nums[i+n];\\n        m+=2;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = [];\\n    let m = 0;\\n    for(let i=0; i<n; i++) {\\n        res[m] = nums[i];\\n        res[m+1] = nums[i+n];\\n        m+=2;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022367,
                "title": "beats-100-00-and-90-97-of-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int result[]=new int[nums.length];\\n\\t\\tfor(int i=0;i<nums.length;i+=2)\\n\\t\\t{\\n\\t\\t\\tresult[i]=nums[i/2];\\n\\t\\t\\tresult[i+1]=nums[nums.length-n];\\n\\t\\t\\tn=n-1;\\n\\t\\t\\n\\t\\t}\\t\\n\\t\\treturn result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int result[]=new int[nums.length];\\n\\t\\tfor(int i=0;i<nums.length;i+=2)\\n\\t\\t{\\n\\t\\t\\tresult[i]=nums[i/2];\\n\\t\\t\\tresult[i+1]=nums[nums.length-n];\\n\\t\\t\\tn=n-1;\\n\\t\\t\\n\\t\\t}\\t\\n\\t\\treturn result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658432,
                "title": "c-beats-56-97-runtime-99-74-memory-tc-o-n-sc-o-1",
                "content": "# can you do it in inplace ?\\n\\n# Intuition\\nsince 1 <= nums[i] <= 1000\\n\\nAnd we know that using const(any number > 1000, in this case),\\nwe can encode encode num as-\\n**num = (const * a) + b**\\nand we can get a & b from num as-\\n**a = num/const\\nb = num%const**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Example**:-\\nwe have to convert {a,c,e,g,i|b,d,f,h,j} ---> {a,b,c,d,e|f,g,h,i,j}\\n\\nstep-1: {a,c,e,g,i|b,d,f,h,j}\\nEncode using **num = (const * a) + b** for n to 2*n-1 indices of array\\n\\nstep-2: {a,c,e,g,i|(a+b),(c+d),(e+f),(g+h),(i+j)}\\nDecode a & b as-\\n**a = num/const\\nb = num%const**\\n\\nstep-3: {a,b,c,d,e|f,g,h,i,j}\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int k = 1001;\\n        int i,j;\\n        \\n        i = 0;\\n        for(j = n; j < 2*n; j++) { // TC: O(n)\\n            nums[j] = (nums[i] * k) + nums[j];\\n            i++;\\n        }\\n\\n        i = 0;\\n        for(j = n; j < 2*n; j++) { // TC: O(n)\\n            nums[i] = nums[j]/k;\\n            nums[i+1] = nums[j]%k;\\n            i += 2;\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int k = 1001;\\n        int i,j;\\n        \\n        i = 0;\\n        for(j = n; j < 2*n; j++) { // TC: O(n)\\n            nums[j] = (nums[i] * k) + nums[j];\\n            i++;\\n        }\\n\\n        i = 0;\\n        for(j = n; j < 2*n; j++) { // TC: O(n)\\n            nums[i] = nums[j]/k;\\n            nums[i+1] = nums[j]%k;\\n            i += 2;\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418893,
                "title": "java-100-faster-0-ms-easy-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] a = new int[2*n];\\n        int i=0,j;\\n        for(j=0; j<2*n; j+=2){\\n            a[j] = nums[i];\\n            a[j+1] = nums[i+n];\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] a = new int[2*n];\\n        int i=0,j;\\n        for(j=0; j<2*n; j+=2){\\n            a[j] = nums[i];\\n            a[j+1] = nums[i+n];\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344398,
                "title": "even-and-odd-indices-are-kept-track-of-using-even-and-odd-variables",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach used in this function is to iterate through the elements of nums and place them in out according to their position in the shuffled sequence. The positions of the even and odd indices are kept track of using even and odd variables, respectively.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each element of nums, the function checks whether the index is less than n. If it is, then the element is placed at the current odd index of out and odd is incremented by 2 to prepare for the next odd index. Otherwise, the element is placed at the current even index of out and even is incremented by 2 to prepare for the next even index.\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), where n is the length of nums. This is because the function iterates through all elements of nums exactly once. The space complexity is also O(n), because the size of out is the same as the size of nums. However, the actual space used by out may be slightly larger due to the use of reserve and the allocation of memory in multiples of the vector\\'s capacity.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        size_t even(1);\\n        size_t odd(0);\\n        vector<int> out(nums.size(), 0);\\n\\n        for (size_t i = 0; i < nums.size(); i++) {\\n            if (static_cast<int>(i) < n) {\\n                out[odd] = nums[i];\\n                odd += 2;\\n            } else {\\n                out[even] = nums[i];\\n                even += 2;\\n            }\\n        }\\n\\n        return (out);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        size_t even(1);\\n        size_t odd(0);\\n        vector<int> out(nums.size(), 0);\\n\\n        for (size_t i = 0; i < nums.size(); i++) {\\n            if (static_cast<int>(i) < n) {\\n                out[odd] = nums[i];\\n                odd += 2;\\n            } else {\\n                out[even] = nums[i];\\n                even += 2;\\n            }\\n        }\\n\\n        return (out);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315646,
                "title": "100-beat-easiest-method-using-for-loop-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEven and Odd position \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n--> Let\\'s first create an answer array to which we will insert the resulted array.\\n--> Add elements to even position from given array nums.\\n--> Add elements on odd position from n to length of the nums.\\n--> In this way shuffle can be easily done.\\n--> If you like it please upvote.\\uD83D\\uDE0A Happy coding!\\n\\n\\n# Complexity\\n- Time complexity: 0 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:42.8 Mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) \\n    {\\n        int[] ans = new int[nums.length];\\n        int k=0;\\n        int j=0;\\n        for(int i=0; i<nums.length ;i++)\\n        {\\n            \\n           if(i==0 || i % 2==0)\\n           {\\n               ans[k] = nums[j];\\n               k++;\\n               j++;\\n           }\\n           else\\n           {\\n               ans[k] = nums[n];\\n               n++;\\n               k++;\\n           }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) \\n    {\\n        int[] ans = new int[nums.length];\\n        int k=0;\\n        int j=0;\\n        for(int i=0; i<nums.length ;i++)\\n        {\\n            \\n           if(i==0 || i % 2==0)\\n           {\\n               ans[k] = nums[j];\\n               k++;\\n               j++;\\n           }\\n           else\\n           {\\n               ans[k] = nums[n];\\n               n++;\\n               k++;\\n           }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172547,
                "title": "js-runtime-91-58-memory-94-48",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    const arr1 = nums.slice(0, n).reverse();\\n    const arr2 = nums.slice(n).reverse();\\n\\n    for( let i=0; i< nums.length; i++ ) {\\n        if( i%2 === 0 ) {\\n            nums[i] = arr1.pop()\\n        } else {\\n            nums[i] = arr2.pop()\\n        }\\n    }\\n\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    const arr1 = nums.slice(0, n).reverse();\\n    const arr2 = nums.slice(n).reverse();\\n\\n    for( let i=0; i< nums.length; i++ ) {\\n        if( i%2 === 0 ) {\\n            nums[i] = arr1.pop()\\n        } else {\\n            nums[i] = arr2.pop()\\n        }\\n    }\\n\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152962,
                "title": "easy-solution-o-1-space",
                "content": "\\n\\n# Approach\\nThe first and the last numbers do not change. \\ninput:[1,2,3,4,4,3,2,1]\\noutput:[1,4,2,3,3,2,4,1]\\n\\nindex 0 and index length-1 have the desired elements.\\nSTEP1: index 1 is swapped with index n\\n        index 2 is swapped with n+1\\n        index 3 is swapped with n+2\\nNow if you check, index 1 and index length-2 have the desired element.\\ni.e [1,4,3,2,2,3,4,1]\\nSTEP2: Now start with index 2\\n        index 2 is swapped n\\n        index 3 is swapped with n+1\\ni.e [1,4,2,3,3,2,4,1]\\nAs you can see index 2 and index length-3 have the correct elements\\n\\nSTEP3: Start with index 3\\n    Index 3 is swapped with index n\\nThus we get the desired output.\\nie: [1,4,2,3,3,2,4,1]\\n    \\n\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n      int low = 0;\\n      int high = n;  \\n      int temp = 0;\\n      for(int i = 1; i<n;i++)\\n      {\\n          low = i;\\n          high = n;\\n          for(int j=i; j<n;j++)\\n          {\\n                \\n                temp = nums[low];\\n                nums[low] = nums[high];\\n                nums[high] = temp;\\n                low++;\\n                high++;\\n\\n          }\\n      }\\n      return nums;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n      int low = 0;\\n      int high = n;  \\n      int temp = 0;\\n      for(int i = 1; i<n;i++)\\n      {\\n          low = i;\\n          high = n;\\n          for(int j=i; j<n;j++)\\n          {\\n                \\n                temp = nums[low];\\n                nums[low] = nums[high];\\n                nums[high] = temp;\\n                low++;\\n                high++;\\n\\n          }\\n      }\\n      return nums;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151802,
                "title": "two-pointers-easy-understanding-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l = 0\\n        r = n\\n        res = []\\n        while l < n:\\n            res.append(nums[l])\\n            res.append(nums[r])\\n            l+=1\\n            r+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l = 0\\n        r = n\\n        res = []\\n        while l < n:\\n            res.append(nums[l])\\n            res.append(nums[r])\\n            l+=1\\n            r+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151714,
                "title": "simplest-solution-java",
                "content": "# Intuition\\nDivide the array into two half and alternatively merge the elements.\\n\\n# Approach\\nEvery element to be merged is at a distance of n.\\n\\n# Complexity\\n- Time complexity:\\nO(n/2)\\n\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[]=new int [2*n];\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[k++]=nums[i];\\n            ans[k++]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[]=new int [2*n];\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[k++]=nums[i];\\n            ans[k++]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150908,
                "title": "simple-java-c-2-lines-code-with-comments-readable-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        // Method - 1\\n\\n        // int [] arr = new int[nums.length];\\n        // int k = 0;\\n        // for(int i = 0, j = n; i < n; i ++,  j ++) {\\n        //     arr[k] = nums[i];\\n        //     k ++;\\n        //     arr[k] = nums[j];\\n        //     k ++;\\n        // }\\n        // return arr;\\n\\n        // Method - 2\\n\\n        int arr[] = new int[2 * n];\\n        for(int i = 0; i < n; i ++) {\\n            arr[i * 2] = nums[i];\\n            arr[i * 2 + 1] = nums[n + i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        // Method - 1\\n\\n        // int [] arr = new int[nums.length];\\n        // int k = 0;\\n        // for(int i = 0, j = n; i < n; i ++,  j ++) {\\n        //     arr[k] = nums[i];\\n        //     k ++;\\n        //     arr[k] = nums[j];\\n        //     k ++;\\n        // }\\n        // return arr;\\n\\n        // Method - 2\\n\\n        int arr[] = new int[2 * n];\\n        for(int i = 0; i < n; i ++) {\\n            arr[i * 2] = nums[i];\\n            arr[i * 2 + 1] = nums[n + i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149883,
                "title": "in-place-o-1-bit-wise-dry-run-explained-3-ways-meme",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet\\'s understand in general term:\\n\\nSuppose we have 2 numbers num1 = 4 and num2 = 9 and maxValue = 10\\nFormula:\\nto store -> pair = (num2 \\xD7 maxValue) + num1\\nto retrieve -> pair % maxValue and pair / maxValue\\n\\nStoring the pair of numbers\\n\\n(9 \\xD7 10) + 4 = 94 --> from above formula (num2 \\xD7 maxValue) + num1\\n94 is stored\\n\\nRetrieving each number one by one\\n\\n94 % 10 = 4\\nwe got first number as 4\\n\\n94 / 10 = 9\\nwe got second number as 9\\n\\nSame idea goes for large cases and array as well but instead of 10, we will take 1024 to store pairs and retrieve each number\\nNOTE: Here, we will take 1024 because of the given constraints 1 <= nums[i] <= 10^3 i.e. the largest number in the array will be 1000\\n\\nNow,\\nBinary representation of 1000 is 1111101000, consisting of total 10 bits\\nBinary representation of 1024 is 10000000000, consisting of total 11 bits\\nand if we multiply 1000 with 1024 i.e. (1000 * 1024), we will get 1024000\\nBinary representation of 1024000 is 11111010000000000000, consisting of total 20 bits which is less than the number of bits (32bits) of int data type, so we can store the number pairs(by multiplying one number with 1024 and adding another number to it) to retrieve each indivisual number later on(by taking out the remainder and the quotient).\\neg: suppose we have an array of length 4 and n is 2\\nnums = [5, 2, 1000, 3] and n = 2\\n\\nWe will store the pair of numbers first\\n\\n# According to algorithm\\n```\\n// to store the pair of numbers in right half of the original array\\nfor(int i = n; i < len; i++)\\nnums[i] = (nums[i] * 1024) + nums[i - n];\\n```\\n# Iteration 1:\\nwhen i = 2, (i = 2 because value of n is 2)\\nnums[2] = (1000 \\xD7 1024) + 5\\nso, nums[2] = 1024005\\n\\n# Iteration 2:\\nwhen i = 3,\\nnums[3] = (3 \\xD7 1024) + 2\\nso, nums[3] = 3074\\n\\nNow, the original array\\n[5, 2, 1000, 3]\\n0  1     2     3   <-- Indexes\\nbecomes\\n[5, 2, 1024005, 3074]\\n0  1        2          3   <-- Indexes\\n\\nWe will retrieve the numbers one by one from the pairs which we have stored at 2nd and 3rd index\\n\\n# According to algorithm\\n```\\n// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\nint index = 0;\\nfor(int i = n; i < len; i++, index += 2){\\n\\tnums[index] = nums[i] % 1024;\\n\\tnums[index + 1] = nums[i] / 1024;\\n}\\n```\\n# Iteration 1:\\nwhen index = 0 and i = 2, (i = 2 because value of n is 2)\\nnums[0] = 1024005 % 1024 = 5\\nnums[1] = 1024005 / 1024 = 1000\\nnow, index = 2 (from index += 2)\\n\\n# Iteration 2:\\nwhen index = 2, i = 3,\\nnums[2] = 3074 % 1024 = 2\\nnums[3] = 3074 / 1024 = 3\\n\\nIteration will be stopped now as the condition become false and we got the array as following\\n[5, 1000, 2, 3] <-- Desired Output\\n0     1     2  3  <-- Indexes\\n\\n# COMPLEXITY:\\n\\nTime: O(n), where n is the given number, which is half of the length of the array\\nSpace: O(1), in-place\\nSince we need to solve it in 0(1) space or in-place, we will use the original array.\\n\\n# Code\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int totalLength = nums.length, index = 0;\\n        for (int i = n; i < totalLength; i++) nums[i] = (nums[i] << 10) | nums[i - n];\\n        for (int i = n; i < totalLength; i++, index += 2) {\\n            nums[index] = nums[i] & 1023;\\n            nums[index + 1] = nums[i] >>> 10;\\n        } return nums;\\n    }\\n```\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n         int j=0,A[] = new int[2*n];\\n        for(int i=0;i<n;i++){\\n             A[j++]=nums[i];\\n             A[j++]=nums[n+i];\\n        }return A;\\n}\\n```\\n\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int len = nums.length,index = 0;\\n\\t\\t// to store the pair of numbers in right half of the original array\\n        for(int i = n; i < len; i++) nums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n        for(int i = n; i < len; i++, index += 2) {\\n            nums[index] = nums[i] % 1024;\\n            nums[index + 1] = nums[i] / 1024;\\n        } return nums;\\n    }\\n```\\n![mem2.png](https://assets.leetcode.com/users/images/94667c14-d084-4538-bd5f-8c945ed69fdb_1675669826.456102.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n// to store the pair of numbers in right half of the original array\\nfor(int i = n; i < len; i++)\\nnums[i] = (nums[i] * 1024) + nums[i - n];\\n```\n```\\n// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\nint index = 0;\\nfor(int i = n; i < len; i++, index += 2){\\n\\tnums[index] = nums[i] % 1024;\\n\\tnums[index + 1] = nums[i] / 1024;\\n}\\n```\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int totalLength = nums.length, index = 0;\\n        for (int i = n; i < totalLength; i++) nums[i] = (nums[i] << 10) | nums[i - n];\\n        for (int i = n; i < totalLength; i++, index += 2) {\\n            nums[index] = nums[i] & 1023;\\n            nums[index + 1] = nums[i] >>> 10;\\n        } return nums;\\n    }\\n```\n```\\npublic int[] shuffle(int[] nums, int n) {\\n         int j=0,A[] = new int[2*n];\\n        for(int i=0;i<n;i++){\\n             A[j++]=nums[i];\\n             A[j++]=nums[n+i];\\n        }return A;\\n}\\n```\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int len = nums.length,index = 0;\\n\\t\\t// to store the pair of numbers in right half of the original array\\n        for(int i = n; i < len; i++) nums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n        for(int i = n; i < len; i++, index += 2) {\\n            nums[index] = nums[i] % 1024;\\n            nums[index + 1] = nums[i] / 1024;\\n        } return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149840,
                "title": "easiest-way-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& arr, int n) {\\n        vector<int> ans; // initialze for storing the suffled elements of given array\\n        for(int i = 0, j  = n; i < n && j < 2*n;i++,j++){ // first index starting from 0, and second index starting from middle of the array and at each iteration we have to move both by one, till the end\\n            ans.emplace_back(arr[i]);\\n            ans.emplace_back(arr[j]);\\n        }\\n        return ans;\\n    }\\n};\\n/* If you like it please do upvote */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& arr, int n) {\\n        vector<int> ans; // initialze for storing the suffled elements of given array\\n        for(int i = 0, j  = n; i < n && j < 2*n;i++,j++){ // first index starting from 0, and second index starting from middle of the array and at each iteration we have to move both by one, till the end\\n            ans.emplace_back(arr[i]);\\n            ans.emplace_back(arr[j]);\\n        }\\n        return ans;\\n    }\\n};\\n/* If you like it please do upvote */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149656,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>y,z,ans;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i<n) y.push_back(nums[i]);\\n            else z.push_back(nums[i]);\\n        }\\n        \\n        for(int i=0;i<y.size();i++)\\n        {\\n            ans.push_back(y[i]);\\n            ans.push_back(z[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>y,z,ans;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i<n) y.push_back(nums[i]);\\n            else z.push_back(nums[i]);\\n        }\\n        \\n        for(int i=0;i<y.size();i++)\\n        {\\n            ans.push_back(y[i]);\\n            ans.push_back(z[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149299,
                "title": "short-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) \\n    {\\n        int arr[]=new int[nums.length];\\n            int c=0;\\n        for (int i=0;i<arr.length;i=i+2)\\n        {\\n            arr[i]=nums[c];\\n            arr[i+1]=nums[n];\\n            c++;\\n            n++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) \\n    {\\n        int arr[]=new int[nums.length];\\n            int c=0;\\n        for (int i=0;i<arr.length;i=i+2)\\n        {\\n            arr[i]=nums[c];\\n            arr[i+1]=nums[n];\\n            c++;\\n            n++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149275,
                "title": "python-shortest-and-fastest-solution-explained-in-detail",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**For Detailed Explaination Read this Blog:**\\nhttps://www.python-techs.com/2023/02/shuffle-array.html\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        # create an empty list to store the shuffled elements\\n        res = [] \\n        \\n        # loop through the first half of the elements (n elements)\\n        for i in range(n): \\n            # add the current element and the corresponding element from the \\n            # second half of the elements to the result list\\n            res.extend([nums[i], nums[i+n]])\\n        \\n        # return the shuffled list\\n        return res\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        # create an empty list to store the shuffled elements\\n        res = [] \\n        \\n        # loop through the first half of the elements (n elements)\\n        for i in range(n): \\n            # add the current element and the corresponding element from the \\n            # second half of the elements to the result list\\n            res.extend([nums[i], nums[i+n]])\\n        \\n        # return the shuffled list\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149202,
                "title": "100-fast-simple-java-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n           \\n           int []a =new int[2*n];\\n           int ind=0;\\n        for(int i=0;i<nums.length;i+=2){\\n            a[i]=nums[ind++];\\n            a[i+1]=nums[n++];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n           \\n           int []a =new int[2*n];\\n           int ind=0;\\n        for(int i=0;i<nums.length;i+=2){\\n            a[i]=nums[ind++];\\n            a[i+1]=nums[n++];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148915,
                "title": "python3-beginner-friendly-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is a Python implementation of a function that takes in two parameters: an array of integers nums and an integer n. The function shuffles the elements in nums and returns the shuffled array.\\n\\nThe shuffling is done by iterating over nums in steps of n, and appending the current element and the next element after n to the target array. The final target array is then returned as the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create an empty list target to store the shuffled elements.\\n- Use a for loop to iterate over nums in steps of n.\\n- On each iteration, append the current element and the next element after n to the target list.\\n- Return the target list as the result.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        target = []\\n        for i in range(0 , n ) :\\n            target.append(nums[i])\\n            target.append(nums[n + i ] )\\n        return target\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        target = []\\n        for i in range(0 , n ) :\\n            target.append(nums[i])\\n            target.append(nums[n + i ] )\\n        return target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148880,
                "title": "python3-o-n-n-64ms-easiest-explaination-in-details",
                "content": "![Capture.PNG](https://assets.leetcode.com/users/images/9b08f84a-3862-48db-b425-3be774557967_1675655484.3949604.png)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe want $$(0,n-1)$$ array **zipped** with $$(n, length(nums))$$ array. So we can use **two pointer** method.\\n\\n```\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- for combining left and right pointer pointed element $$initialise$$ $$left$$ and $$right$$ pointer with $$0$$ and $$n$$ value.\\n- our **left end** is where we **cross right** pointer initial position.\\n- our **right end** is where we **cross end of nums** array.\\n- now all values in place $$iterate$$ over array till $$left<n$$ and $$right<end$$.\\n- **append** element of left pointer array and right pointer array to answer array.\\n- **return $$answer$$**.\\n```\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N-n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ans = []\\n        left = 0\\n        right = n\\n        end = len(nums)\\n        while(left < n and right < end):\\n            ans.append(nums[left])\\n            ans.append(nums[right])\\n            left += 1\\n            right += 1\\n        return ans\\n```\\n# **Feel free to comment and suggest me anything, and doupvote this solution. ( \\u0361\\uD83D\\uDD25\\u202F\\u035C\\u0296 \\u0361\\uD83D\\uDD25) \\uD83D\\uDC49**\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ans = []\\n        left = 0\\n        right = n\\n        end = len(nums)\\n        while(left < n and right < end):\\n            ans.append(nums[left])\\n            ans.append(nums[right])\\n            left += 1\\n            right += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148836,
                "title": "c-two-pointer-faster-easy-to-understand",
                "content": "* ***Using Two Pointer***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        \\n        // declare a res array\\n        \\n        vector<int> res;\\n        \\n        // use two pointers\\n        \\n        int i = 0;\\n        \\n        int j = n;\\n        \\n        // fill the res array according to condition\\n        \\n        while(i < n)\\n        {\\n            res.push_back(nums[i]);\\n            \\n            res.push_back(nums[j]);\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        \\n        // declare a res array\\n        \\n        vector<int> res;\\n        \\n        // use two pointers\\n        \\n        int i = 0;\\n        \\n        int j = n;\\n        \\n        // fill the res array according to condition\\n        \\n        while(i < n)\\n        {\\n            res.push_back(nums[i]);\\n            \\n            res.push_back(nums[j]);\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148698,
                "title": "python-generators",
                "content": "```\\nreturn (nums[j] for i in range(n) for j in range(i, i + n + 1, n))\\n```\\n*Generators are special iterators in Python which returns the generator object. The point of using it, is to generate a sequence of items without having to store them in memory and this is why you can use Generator only once.*",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn (nums[j] for i in range(n) for j in range(i, i + n + 1, n))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148573,
                "title": "0ms-easy-to-read-understand",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        let n = n as usize;\\n        let mut result:Vec<i32> = vec![0;nums.len()];\\n\\n        for index in 0..n {\\n            let x_index = index *2;\\n            result[x_index] = nums[index];\\n            result[x_index + 1] = nums[index + n];\\n        }\\n        result\\n    }\\n}\\n```\\n# Iterators\\n```\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        let n = n as usize;\\n        (0..n).map(|i| ([nums[i],nums[i+n]]) ).flatten().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        let n = n as usize;\\n        let mut result:Vec<i32> = vec![0;nums.len()];\\n\\n        for index in 0..n {\\n            let x_index = index *2;\\n            result[x_index] = nums[index];\\n            result[x_index + 1] = nums[index + n];\\n        }\\n        result\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        let n = n as usize;\\n        (0..n).map(|i| ([nums[i],nums[i+n]]) ).flatten().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148425,
                "title": "java-simple-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] array=new int[nums.length];\\n        int index=0;\\n        for(int i=0; i<nums.length/2; i++){\\n            array[index]=nums[i];\\n            index++;\\n            array[index]=nums[array.length/2+i];\\n            index++;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] array=new int[nums.length];\\n        int index=0;\\n        for(int i=0; i<nums.length/2; i++){\\n            array[index]=nums[i];\\n            index++;\\n            array[index]=nums[array.length/2+i];\\n            index++;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130074,
                "title": "j",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] a=new int[nums.length];\\n        int t=0;\\n        for(int i=0,j=n;i<n&&j<nums.length;i++,j++){\\n            a[t++]=nums[i];\\n            a[t++]=nums[j];\\n            //System.out.println(nums[i]+\" \"+nums[j]);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] a=new int[nums.length];\\n        int t=0;\\n        for(int i=0,j=n;i<n&&j<nums.length;i++,j++){\\n            a[t++]=nums[i];\\n            a[t++]=nums[j];\\n            //System.out.println(nums[i]+\" \"+nums[j]);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808217,
                "title": "java-easy-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] arr=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k=k+2){\\n            arr[k]=nums[i];\\n            arr[k+1]=nums[j];\\n            i++;\\n            j++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] arr=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k=k+2){\\n            arr[k]=nums[i];\\n            arr[k+1]=nums[j];\\n            i++;\\n            j++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707599,
                "title": "java-0-ms-faster-than-100-00-of-java-online-submissions-for-shuffle-the-array",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int fistPart = 0;\\n        int secondPart = n;\\n        int[] res = new int[nums.length];\\n\\n        for (int i = 0; i < nums.length; ) {\\n            res[i++] = nums[fistPart++];\\n            res[i++] = nums[secondPart++];\\n        }\\n        return res;\\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int fistPart = 0;\\n        int secondPart = n;\\n        int[] res = new int[nums.length];\\n\\n        for (int i = 0; i < nums.length; ) {\\n            res[i++] = nums[fistPart++];\\n            res[i++] = nums[secondPart++];\\n        }\\n        return res;\\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697447,
                "title": "js-very-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/973c2781-8ad1-4682-924d-9b8cf7f40101_1665645082.7997556.png)\\n\\n```\\nvar shuffle = function(nums, n) {\\n    const output = new Array(2*n);\\n    for (let i = 0; i < n; i++) {\\n        output[2*i] = nums[i];\\n        output[2*i+1] = nums[n+i];\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    const output = new Array(2*n);\\n    for (let i = 0; i < n; i++) {\\n        output[2*i] = nums[i];\\n        output[2*i+1] = nums[n+i];\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548250,
                "title": "easy-to-understand-java-solution-simple-while-loop",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] arr = new int[nums.length];\\n        int i=0;\\n\\t    int j=0;\\n        while(i<n) {\\n                arr[i] = nums[j];\\n                i++;\\n                j++;\\n                arr[i] = nums[n];\\n                i++;\\n                n++;\\n            }\\n\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] arr = new int[nums.length];\\n        int i=0;\\n\\t    int j=0;\\n        while(i<n) {\\n                arr[i] = nums[j];\\n                i++;\\n                j++;\\n                arr[i] = nums[n];\\n                i++;\\n                n++;\\n            }\\n\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470030,
                "title": "java-easy-solution-0ms-100-faster",
                "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\t\\n        int[] ans = new int[n*2]; //creating 2n length of array\\n        for(int i=0; i<n; i++) {\\n            ans[i*2] = nums[i]; // ans[i(0,1,2) * 2]=nums[0,1,2]   //[2,_,5,_,1,_]  \\n            ans[i*2+1] = nums[i+n];// ans[i(0,1,2) * 2 + 1]=nums[0,1,2 + 1]  // [2,3,5,4,1,7]\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\t\\n        int[] ans = new int[n*2]; //creating 2n length of array\\n        for(int i=0; i<n; i++) {\\n            ans[i*2] = nums[i]; // ans[i(0,1,2) * 2]=nums[0,1,2]   //[2,_,5,_,1,_]  \\n            ans[i*2+1] = nums[i+n];// ans[i(0,1,2) * 2 + 1]=nums[0,1,2 + 1]  // [2,3,5,4,1,7]\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2406866,
                "title": "simple-python-code-with-explanation",
                "content": "```\\nclass Solution:\\n        #two pointers approach\\n        def shuffle(self, nums: List[int], n: int) -> List[int]:\\n                #initialise the l pointer to 0th index\\n                l = 0 \\n                #initialise the r pointer to middle index\\n                r = len(nums)//2\\n                #create the new list (res)\\n                res = []\\n                #condition breaks when l pointer reaches middle index \\n                #and r pointer reaches the last index\\n                while l < len(nums)//2 and r < len(nums):\\n                        #add the element at l pointer to res -->list\\n                        res.append(nums[l])\\n                        #after adding increase the l pointer by 1\\n                        l = l + 1\\n                        #add the element at r pointer to res-->list\\n                        res.append(nums[r])\\n                        #after adding increase the r pointer by 1\\n                        r = r +1\\n        \\n                #after breaking while loop return res--> list        \\n                return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n        #two pointers approach\\n        def shuffle(self, nums: List[int], n: int) -> List[int]:\\n                #initialise the l pointer to 0th index\\n                l = 0 \\n                #initialise the r pointer to middle index\\n                r = len(nums)//2\\n                #create the new list (res)\\n                res = []\\n                #condition breaks when l pointer reaches middle index \\n                #and r pointer reaches the last index\\n                while l < len(nums)//2 and r < len(nums):\\n                        #add the element at l pointer to res -->list\\n                        res.append(nums[l])\\n                        #after adding increase the l pointer by 1\\n                        l = l + 1\\n                        #add the element at r pointer to res-->list\\n                        res.append(nums[r])\\n                        #after adding increase the r pointer by 1\\n                        r = r +1\\n        \\n                #after breaking while loop return res--> list        \\n                return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352824,
                "title": "java-100-faster-0ms",
                "content": "If you like this solution, Upvote it.\\n```\\nint[] arr = new int[2*n];  // new array of 2*n size.\\n        for(int i=0;i<n;i++){\\n            arr[i*2] = nums[i];       // even index elements.\\n            arr[(i*2)+1] = nums[i+n]; // odd index elements.\\n        }\\n        return arr;\\n```\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint[] arr = new int[2*n];  // new array of 2*n size.\\n        for(int i=0;i<n;i++){\\n            arr[i*2] = nums[i];       // even index elements.\\n            arr[(i*2)+1] = nums[i+n]; // odd index elements.\\n        }\\n        return arr;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1790015,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1789812,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1661982,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1566949,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790271,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1782376,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790161,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1569985,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1789903,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1635681,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790015,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1789812,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1661982,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1566949,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790271,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1782376,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790161,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1569985,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1789903,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1635681,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1575283,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790718,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790398,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1789917,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1756307,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1745882,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1734974,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728968,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1694138,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2058344,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2018385,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 2010722,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 2003805,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1976928,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1957922,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1922691,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1847613,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1843398,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1842216,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1805398,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1801801,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1801122,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1797869,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1797597,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1796936,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1791116,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790977,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790956,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790954,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790951,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790931,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790874,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790771,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790722,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790714,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790634,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790631,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790587,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790540,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790522,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790479,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790462,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790403,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790379,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790346,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790314,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790273,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790268,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790210,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790148,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790139,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1790111,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1790044,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1790039,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1790033,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789887,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789883,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789881,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789878,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789877,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789843,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1789826,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1789823,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1789822,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1789809,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1775038,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1770750,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1752275,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1727197,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1722989,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            }
        ]
    }
]