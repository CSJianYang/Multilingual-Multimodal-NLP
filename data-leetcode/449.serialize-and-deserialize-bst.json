[
    {
        "title": "Group Anagrams",
        "question_content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n&nbsp;\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n&nbsp;\nConstraints:\n\n\t1 <= strs.length <= 104\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 19200,
                "title": "c-unordered-map-and-counting-sort",
                "content": "Use an `unordered_map` to group the strings by their sorted counterparts. Use the sorted string as the key and all anagram strings as the value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            string t = s; \\n            sort(t.begin(), t.end());\\n            mp[t].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\n};\\n```\\n\\nMoreover, since the string only contains lower-case alphabets, we can sort them using counting sort to improve the time complexity.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            mp[strSort(s)].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\nprivate:\\n    string strSort(string s) {\\n        int counter[26] = {0};\\n        for (char c : s) {\\n            counter[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(counter[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            string t = s; \\n            sort(t.begin(), t.end());\\n            mp[t].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for (string s : strs) {\\n            mp[strSort(s)].push_back(s);\\n        }\\n        vector<vector<string>> anagrams;\\n        for (auto p : mp) { \\n            anagrams.push_back(p.second);\\n        }\\n        return anagrams;\\n    }\\nprivate:\\n    string strSort(string s) {\\n        int counter[26] = {0};\\n        for (char c : s) {\\n            counter[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(counter[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19176,
                "title": "share-my-short-java-solution",
                "content": "```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```\\n\\nInstead of sorting, we can also build the key string in this way. Thanks @davidluoyes for pointing this out.\\n\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = new char[26];\\n            for (char c : s.toCharArray()) ca[c - \\'a\\']++;\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs == null || strs.length == 0) return new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ca = new char[26];\\n            for (char c : s.toCharArray()) ca[c - \\'a\\']++;\\n            String keyStr = String.valueOf(ca);\\n            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3687735,
                "title": "beats-100-c-java-python-beginner-friendly",
                "content": "\\n# Intuition:\\n\\nThe intuition is to group words that are anagrams of each other together. Anagrams are words that have the `same` characters but in a `different` order.\\n\\n# Explanation:\\n\\nLet\\'s go through the code step by step using the example input `[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]` to understand how it works.\\n\\n1. **Initializing Variables**\\n    - We start by initializing an empty unordered map called `mp` (short for map), which will store the groups of anagrams.\\n\\n2. **Grouping Anagrams**\\nWe iterate through each word in the input vector `strs`. Let\\'s take the first word, \"eat\", as an example.\\n\\n    - **Sorting the Word**\\nWe create a string variable called `word` and assign it the value of the current word (\"eat\" in this case). \\n\\n        Next, we sort the characters in `word` using the `sort()` function. After sorting, `word` becomes \"aet\". \\n\\n    - **Grouping the Anagram**\\nWe insert `word` as the key into the `mp` unordered map using `mp[word]`, and we push the original word (\"eat\") into the vector associated with that key using `mp[word].push_back(x)`, where `x` is the current word.\\n\\n        Since \"aet\" is a unique sorted representation of all the anagrams, it serves as the key in the `mp` map, and the associated vector holds all the anagrams. \\n\\nFor the given example, the `mp` map would look like this after processing all the words:\\n```\\n{\\n  \"aet\": [\"eat\", \"tea\", \"ate\"],\\n  \"ant\": [\"tan\", \"nat\"],\\n  \"abt\": [\"bat\"]\\n}\\n```\\n\\n3. **Creating the Result**\\nWe initialize an empty vector called `ans` (short for answer) to store the final result.\\n\\n    - We iterate through each key-value pair in the `mp` map using a range-based for loop. For each pair, we push the vector of anagrams (`x.second`) into the `ans` vector.\\n\\nFor the given example, the `ans` vector would look like this:\\n```\\n[\\n  [\"eat\", \"tea\", \"ate\"],\\n  [\"tan\", \"nat\"],\\n  [\"bat\"]\\n]\\n```\\n\\n4. **Returning the Result**\\nWe return the `ans` vector, which contains the groups of anagrams.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        \\n        for(auto x: strs){\\n            string word = x;\\n            sort(word.begin(), word.end());\\n            mp[word].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto x: mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String word : strs) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedWord = new String(chars);\\n            \\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedWord).add(word);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        anagram_map = defaultdict(list)\\n        \\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            anagram_map[sorted_word].append(word)\\n        \\n        return list(anagram_map.values())\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/86270fe9-da59-416b-a22e-21b787b13712_1687773427.3564198.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. [Valid Anagram](https://leetcode.com/problems/valid-anagram/solutions/3687854/3-methods-c-java-python-beginner-friendly/)\\n11. [Group Anagrams](https://leetcode.com/problems/group-anagrams/solutions/3687735/beats-100-c-java-python-beginner-friendly/)\\n12. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n{\\n  \"aet\": [\"eat\", \"tea\", \"ate\"],\\n  \"ant\": [\"tan\", \"nat\"],\\n  \"abt\": [\"bat\"]\\n}\\n```\n```\\n[\\n  [\"eat\", \"tea\", \"ate\"],\\n  [\"tan\", \"nat\"],\\n  [\"bat\"]\\n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        \\n        for(auto x: strs){\\n            string word = x;\\n            sort(word.begin(), word.end());\\n            mp[word].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto x: mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String word : strs) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedWord = new String(chars);\\n            \\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedWord).add(word);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        anagram_map = defaultdict(list)\\n        \\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            anagram_map[sorted_word].append(word)\\n        \\n        return list(anagram_map.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19202,
                "title": "5-line-python-solution-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        letters_to_words = defaultdict(list)\\n        for word in strs:\\n            letters_to_words[tuple(sorted(word))].append(word)\\n        return list(letters_to_words.values())\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        letters_to_words = defaultdict(list)\\n        for word in strs:\\n            letters_to_words[tuple(sorted(word))].append(word)\\n        return list(letters_to_words.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750590,
                "title": "simple-c-detailed-explanation-unordered-map-sorting",
                "content": "# \\t\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n```\\n\\t\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n       vector<vector<string>>ans;\\n        \\n       unordered_map<string, vector<string>>mp;\\n        \\n         /*\\n                Consider example 1 : strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\\n                \\n                After the below opeartion of for loop map will contain\\n                \\n                aet -- eat, tea, ate\\n                ant -- tan, nat\\n                abt -- bat\\n        */\\n        \\n        for(int i = 0 ; i < strs.size() ; i++)\\n        {\\n            string s = strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            mp[strs[i]].push_back(s);\\n        }\\n        \\n        //now simply put the elements  of second column of map in ans\\n        \\n        for(auto i : mp)\\n        {\\n            ans.push_back(i.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n       vector<vector<string>>ans;\\n        \\n       unordered_map<string, vector<string>>mp;\\n        \\n         /*\\n                Consider example 1 : strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\\n                \\n                After the below opeartion of for loop map will contain\\n                \\n                aet -- eat, tea, ate\\n                ant -- tan, nat\\n                abt -- bat\\n        */\\n        \\n        for(int i = 0 ; i < strs.size() ; i++)\\n        {\\n            string s = strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            mp[strs[i]].push_back(s);\\n        }\\n        \\n        //now simply put the elements  of second column of map in ans\\n        \\n        for(auto i : mp)\\n        {\\n            ans.push_back(i.second);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19233,
                "title": "o-m-n-algorithm-using-hash-without-sort",
                "content": "Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value.\\n\\n\\n        \\n        private static final int[] PRIMES = new int[]{2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107};\\n        \\n        public List<String> anagrams(String[] strs) {\\n            List<String> list = new LinkedList<>();\\n            Map<Integer, List<String>> mapString = new HashMap<>();\\n            int result = -1;\\n            for (int i = 0; i < strs.length; i++){\\n                int mapping = 1;\\n                for (int j = 0, max = strs[i].length(); j < max; j++) {\\n                    mapping *= PRIMES[strs[i].charAt(j) - 'a'];\\n                }\\n                List<String> strings = mapString.get(mapping);\\n                if (strings == null) {\\n                    strings = new LinkedList<>();\\n                    mapString.put(mapping, strings);\\n                }\\n                strings.add(strs[i]);\\n            }\\n            for (List<String> mapList : mapString.values()){\\n                if (mapList.size() > 1)\\n                    list.addAll(mapList);\\n            }\\n            return list;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value.\\n\\n\\n        \\n        private static final int[] PRIMES = new int[]{2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107};\\n        \\n        public List<String> anagrams(String[] strs) {\\n            List<String> list = new LinkedList<>();\\n            Map<Integer, List<String>> mapString = new HashMap<>();\\n            int result = -1;\\n            for (int i = 0; i < strs.length; i++){\\n                int mapping = 1;\\n                for (int j = 0, max = strs[i].length(); j < max; j++) {\\n                    mapping *= PRIMES[strs[i].charAt(j) - 'a'];\\n                }\\n                List<String> strings = mapString.get(mapping);\\n                if (strings == null) {\\n                    strings = new LinkedList<>();\\n                    mapString.put(mapping, strings);\\n                }\\n                strings.add(strs[i]);\\n            }\\n            for (List<String> mapList : mapString.values()){\\n                if (mapList.size() > 1)\\n                    list.addAll(mapList);\\n            }\\n            return list;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 834253,
                "title": "simple-and-short-c-solution-with-comments-beats-98-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        // Base case\\n\\t\\tif(strs.size() == 1)\\n            return {{strs[0]}};\\n        \\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> M;\\n        for(int  i = 0; i < strs.size(); i++)\\n        {\\n            string str = strs[i];\\n            sort(strs[i].begin(), strs[i].end()); // Sorting the string\\n            M[strs[i]].push_back(str);  // Sorted string is the key and the value is the initial string\\n        }\\n        for(auto i = M.begin(); i != M.end(); i++)\\n            ans.push_back(i -> second);  // Traversing the map and adding the vectors of string to ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        // Base case\\n\\t\\tif(strs.size() == 1)\\n            return {{strs[0]}};\\n        \\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> M;\\n        for(int  i = 0; i < strs.size(); i++)\\n        {\\n            string str = strs[i];\\n            sort(strs[i].begin(), strs[i].end()); // Sorting the string\\n            M[strs[i]].push_back(str);  // Sorted string is the key and the value is the initial string\\n        }\\n        for(auto i = M.begin(); i != M.end(); i++)\\n            ans.push_back(i -> second);  // Traversing the map and adding the vectors of string to ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384037,
                "title": "python-easily-understood-hash-table-fast-simple",
                "content": "**Appreciate if you could upvote this solution**\\n\\n\\nMethod: `Hash Table`\\n\\nSince the output needs to group the anagrams, it is suitable to use `dict` to store the different anagrams.\\nThus, we need to find a common `key` for those anagrams.\\nAnd one of the best choices is the `sorted string` as all the anagrams have the same anagrams.\\n\\n![image](https://assets.leetcode.com/users/images/69dc8218-5820-42a0-977c-d278e97b6dd1_1659719811.9147549.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_table = {}\\n\\n        for string in strs:\\n            sorted_string = \\'\\'.join(sorted(string))\\n\\n            if sorted_string not in strs_table:\\n                strs_table[sorted_string] = []\\n\\n            strs_table[sorted_string].append(string)\\n\\n        return list(strs_table.values())\\n```\\nTime complexity: `O(m*nlogn))`\\nSpace complexity: `O(n)`\\n<br/>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_table = {}\\n\\n        for string in strs:\\n            sorted_string = \\'\\'.join(sorted(string))\\n\\n            if sorted_string not in strs_table:\\n                strs_table[sorted_string] = []\\n\\n            strs_table[sorted_string].append(string)\\n\\n        return list(strs_table.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664252,
                "title": "python-3-solution-detailed-explanation-faster-than-97-5",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        h = {}\\n        for word in strs:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            if sortedWord not in h:\\n                h[sortedWord] = [word]\\n            else:\\n                h[sortedWord].append(word)\\n        final = []\\n        for value in h.values():\\n            final.append(value)\\n        return final\\n```\\nWe recall that anagrams are strings which have identical counts of characters. So anagrams, when sorted, result in the same string. We take advantage of this last property.\\n\\nWe create a dictionary and for each word in the input array, we add a key to the dictionary if the **sorted version of the word** doesn\\'t already exist in the list of keys. The key then becomes the sorted version of the word, and the value for the key is an array that stores each anagram of the key. i.e. for every next word that is an anagram, **we would sort the word, find the key that is equal to the sorted form, and add the original word to the list of values for the key**.\\n\\nAt the end of it, we just add every value in the dictionary to the final array.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        h = {}\\n        for word in strs:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            if sortedWord not in h:\\n                h[sortedWord] = [word]\\n            else:\\n                h[sortedWord].append(word)\\n        final = []\\n        for value in h.values():\\n            final.append(value)\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718955,
                "title": "three-js-solutions",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    let obj = {};\\n    for (let str of strs) {\\n        let letters = str.split(\"\").sort().join(\"\");\\n        obj[letters] ? obj[letters].push(str) : obj[letters] = [str];\\n    }\\n    return Object.values(obj);\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\\n\\n```\\nvar groupAnagrams = function(strs) {\\n    let m = new Map();\\n    for (let str of strs) {\\n        let sorted = str.split(\"\").sort().join(\"\");\\n        if (m.has(sorted)) m.set(sorted, [...m.get(sorted), str]);\\n        else m.set(sorted, [str]);\\n    }\\n    return Array.from(m.values());\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\\n\\n```\\nvar groupAnagrams = function(strs) {\\n    let res = {};\\n    for (let str of strs) {\\n        let count = new Array(26).fill(0);\\n        for (let char of str) count[char.charCodeAt()-97]++;\\n        let key = count.join(\"#\");\\n        res[key] ? res[key].push(str) : res[key] = [str];\\n    }\\n    return Object.values(res);\\n};\\n// Time Complexity: O(n*k) where n is the size of input array and k is the maximum length of string in input array\\n// Space Complexity: O(n)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    let obj = {};\\n    for (let str of strs) {\\n        let letters = str.split(\"\").sort().join(\"\");\\n        obj[letters] ? obj[letters].push(str) : obj[letters] = [str];\\n    }\\n    return Object.values(obj);\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\n```\\nvar groupAnagrams = function(strs) {\\n    let m = new Map();\\n    for (let str of strs) {\\n        let sorted = str.split(\"\").sort().join(\"\");\\n        if (m.has(sorted)) m.set(sorted, [...m.get(sorted), str]);\\n        else m.set(sorted, [str]);\\n    }\\n    return Array.from(m.values());\\n};\\n// Time Complexity: O(n*klog(k)) where n is the length of input array and k is the maximum length of a string in input array\\n// Space Complexity: O(n)\\n```\n```\\nvar groupAnagrams = function(strs) {\\n    let res = {};\\n    for (let str of strs) {\\n        let count = new Array(26).fill(0);\\n        for (let char of str) count[char.charCodeAt()-97]++;\\n        let key = count.join(\"#\");\\n        res[key] ? res[key].push(str) : res[key] = [str];\\n    }\\n    return Object.values(res);\\n};\\n// Time Complexity: O(n*k) where n is the size of input array and k is the maximum length of string in input array\\n// Space Complexity: O(n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333346,
                "title": "simple-java-solution-beats-99-05-5ms",
                "content": "\\n**Please upvote if you understood the solution**\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\nTime Complexity: O(n * klog(k)) since we are sorting k characters n times in the loop.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173284,
                "title": "clean-javascript-solution",
                "content": "```javascript\\nconst groupAnagrams = strs => {\\n    const map = {};\\n    \\n    for (let str of strs) {\\n        const key = [...str].sort().join(\\'\\');\\n\\n        if (!map[key]) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(str);\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst groupAnagrams = strs => {\\n    const map = {};\\n    \\n    for (let str of strs) {\\n        const key = [...str].sort().join(\\'\\');\\n\\n        if (!map[key]) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(str);\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19335,
                "title": "beat-90-2-18ms-o-n-non-sort-solutions-with-hashmap",
                "content": "**we know each word can be represented by their counter array which counts every letter's occurrences, so we can use this counter array as an ID for the anagram, more specifically, use this counter array's hash code as the key, the anagram list as the value, we can distribute all the words into corresponding anagram group in O(n) time complexity.**\\n\\n```\\npublic int getID(String s){\\n        int[] counter   =   new int[26];\\n        for(char ch : s.toCharArray()){\\n            counter[ch - 'a']++;\\n        }\\n        \\n        return Arrays.hashCode(counter);    //use the counter array's hash code as this anagram's ID\\n    }\\n    \\n    //solution takes 18ms\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> groups   =   new ArrayList<>();\\n        Map<Integer, List<String>> anagramMap   =   new HashMap<>();\\n        \\n        for(String word : strs){\\n            int id   =   getID(word);   //unique for each anagram\\n            List<String> group  =   anagramMap.get(id);\\n            \\n            if(null == group){\\n                group  =   new ArrayList();\\n                anagramMap.put(id, group);\\n           \\n            }\\n            \\n            group.add(word);\\n        }\\n        \\n        groups.addAll(anagramMap.values());\\n        \\n        return groups;\\n    }\\n```\\n\\n***If u think it make sense, plz vote for me, thx : )***\\n\\nbtw, my code was also hosted on github:) https://github.com/Emilio66/leetcode/blob/master/P49_GroupAnagrams.java",
                "solutionTags": [],
                "code": "```\\npublic int getID(String s){\\n        int[] counter   =   new int[26];\\n        for(char ch : s.toCharArray()){\\n            counter[ch - 'a']++;\\n        }\\n        \\n        return Arrays.hashCode(counter);    //use the counter array's hash code as this anagram's ID\\n    }\\n    \\n    //solution takes 18ms\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> groups   =   new ArrayList<>();\\n        Map<Integer, List<String>> anagramMap   =   new HashMap<>();\\n        \\n        for(String word : strs){\\n            int id   =   getID(word);   //unique for each anagram\\n            List<String> group  =   anagramMap.get(id);\\n            \\n            if(null == group){\\n                group  =   new ArrayList();\\n                anagramMap.put(id, group);\\n           \\n            }\\n            \\n            group.add(word);\\n        }\\n        \\n        groups.addAll(anagramMap.values());\\n        \\n        return groups;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19203,
                "title": "2-line-python-solution-ac-with-350ms-some-useful-python-tricks",
                "content": "\\n\\n        def anagrams(self, strs):\\n            count = collections.Counter([tuple(sorted(s)) for s in strs])\\n            return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n\\n\\n - collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting  (objects that hashes to same value)\\n - tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed\\n - filter: selects some elements of the list based on given function (first argument - a lambda function is given here)\\n - lambda function defined here returns True if number of anagrams of that elements is greater than 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n        def anagrams(self, strs):\\n            count = collections.Counter([tuple(sorted(s)) for s in strs])\\n            return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n\\n\\n - collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting  (objects that hashes to same value)\\n - tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed\\n - filter: selects some elements of the list based on given function (first argument - a lambda function is given here)\\n - lambda function defined here returns True if number of anagrams of that elements is greater than 1",
                "codeTag": "Python3"
            },
            {
                "id": 19216,
                "title": "1-line-ruby-python-for-updated-problem",
                "content": "The problem just got updated, now asking for different results. Here are some solutions for the new version.\\n\\nAll of them use the sorted string as the group identifier, so for example the words \"leetcoder\" and \"electrode\" both have the group identifier \"cdeeelort\" (or rather an array version of it), which is how I know that they're anagrams of each other.\\n\\n---\\n\\n**Ruby solution 1**\\n\\nJust sort and group.\\n\\n    def group_anagrams(strs)\\n      strs.sort.group_by { |s| s.chars.sort }.values\\n    end\\n\\n---\\n\\n**Ruby solution 2**\\n\\nGroup first, then sort each group. Could be faster for big cases (though isn't for the OJ test cases).\\n\\n    def group_anagrams(strs)\\n      strs.group_by { |s| s.chars.sort }.values.map(&:sort)\\n    end\\n\\n---\\n\\n**Python solution 1**\\n\\nSort and group by group identifier, then sort each group normally.\\n\\n    def groupAnagrams(self, strs):\\n        return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)]\\n\\nOr \"breaking it down\" to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed *\"no scrollbars\"* rule (I usually use Chrome and didn't think it differed):\\n\\n    def groupAnagrams(self, strs):\\n        groups = itertools.groupby(sorted(strs, key=sorted), sorted)\\n        return [sorted(members) for _, members in groups]\\n\\n---\\n\\n**Python solution 2**\\n\\nUsing defaultdict to collect the groups.\\n\\n    def groupAnagrams(self, strs):\\n        groups = collections.defaultdict(list)\\n        for s in strs:\\n            groups[tuple(sorted(s))].append(s)\\n        return map(sorted, groups.values())",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "The problem just got updated, now asking for different results. Here are some solutions for the new version.\\n\\nAll of them use the sorted string as the group identifier, so for example the words \"leetcoder\" and \"electrode\" both have the group identifier \"cdeeelort\" (or rather an array version of it), which is how I know that they're anagrams of each other.\\n\\n---\\n\\n**Ruby solution 1**\\n\\nJust sort and group.\\n\\n    def group_anagrams(strs)\\n      strs.sort.group_by { |s| s.chars.sort }.values\\n    end\\n\\n---\\n\\n**Ruby solution 2**\\n\\nGroup first, then sort each group. Could be faster for big cases (though isn't for the OJ test cases).\\n\\n    def group_anagrams(strs)\\n      strs.group_by { |s| s.chars.sort }.values.map(&:sort)\\n    end\\n\\n---\\n\\n**Python solution 1**\\n\\nSort and group by group identifier, then sort each group normally.\\n\\n    def groupAnagrams(self, strs):\\n        return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)]\\n\\nOr \"breaking it down\" to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed *\"no scrollbars\"* rule (I usually use Chrome and didn't think it differed):\\n\\n    def groupAnagrams(self, strs):\\n        groups = itertools.groupby(sorted(strs, key=sorted), sorted)\\n        return [sorted(members) for _, members in groups]\\n\\n---\\n\\n**Python solution 2**\\n\\nUsing defaultdict to collect the groups.\\n\\n    def groupAnagrams(self, strs):\\n        groups = collections.defaultdict(list)\\n        for s in strs:\\n            groups[tuple(sorted(s))].append(s)\\n        return map(sorted, groups.values())",
                "codeTag": "Python3"
            },
            {
                "id": 3209086,
                "title": "java-o-n-k-solution-using-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to combine the strings into list of same values and keep track of each list. So the simple solution is to create a HashMap< String, List >.\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nNow the main thing is to find a way to keep Key maintained and same for similar anagrams. One way is to do sorting of the elements.\\nLike -> \\n1. ate -> [\\'a\\',\\'t\\',\\'e\\'] -> after sorting and combining -> aet.\\n2. tae -> [\\'t\\',\\'a\\',\\'e\\'] -> after sorting and combining -> aet.\\n\\n# Complexity\\n- Time complexity: O(n * k * log(k) ), where\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- - n = length of array\\n- - k = length of string\\n\\n- Space complexity: O( n ) , size of map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            char[] valArr = s.toCharArray();\\n            Arrays.sort( valArr );\\n            String key = new String(valArr);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\nNow we can optimise the Key identifying procedure by using Xor and Product of ASCII values of character in Strings. As sorting require extra k*log(k) time and we can reduce it to O(k) for linear traversal.\\n\\n# Complexity\\n- Time complexity: O(n * k), where\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- - n = length of array\\n- - k = length of string\\n\\n- Space complexity: O( n ) , size of map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            String key = getKey(s);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n\\n    private String getKey(String s){\\n        int prod = 1, xor = 0;\\n        for(int len=0; len<s.length(); len++){\\n            char i = s.charAt(len);\\n            prod *= i;\\n            xor = xor^i;\\n        }\\n        return String.valueOf(prod) + \\'_\\' + String.valueOf(xor);\\n    }\\n\\n}\\n```\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/70fb8114-54fb-46bb-8481-e676441046c7_1676881723.60565.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            char[] valArr = s.toCharArray();\\n            Arrays.sort( valArr );\\n            String key = new String(valArr);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, ArrayList<String>> map = new HashMap<>();\\n\\n        for( String s: strs ){\\n\\n            String key = getKey(s);\\n\\n            ArrayList<String> ll = map.getOrDefault( key,\\n                                     new ArrayList<String>() );\\n            ll.add(s);\\n            map.put( key, ll );\\n                                 \\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n        for( Map.Entry<String, ArrayList<String>> entry: map.entrySet() ){\\n            ans.add( entry.getValue() );\\n        }\\n\\n        return ans;\\n    }\\n\\n    private String getKey(String s){\\n        int prod = 1, xor = 0;\\n        for(int len=0; len<s.length(); len++){\\n            char i = s.charAt(len);\\n            prod *= i;\\n            xor = xor^i;\\n        }\\n        return String.valueOf(prod) + \\'_\\' + String.valueOf(xor);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750704,
                "title": "java-easy-solution-hashmap-arraylist",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n        groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n        groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750601,
                "title": "python-c-java-rust-linear-time-hashable-keys-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashing of strings in linear-time. Time complexity is **O(N)**. Space complexity is **O(N)**. \\n\\n**Comment**. To group anagrams, we should use something (i.e., some hash) that:\\n* uniquely distinguishes one group from another;\\n* is the same for all members of each group.\\n\\nAmong the potential candidates are:\\n* list of letter frequencies in alphabetical order, that takes **O(N)** time to compute;\\n* sorted version of a string, that takes **O(N\\\\*logN)** time to compute.\\n\\nHere, we\\'ll go with the first option.\\n\\n<iframe src=\"https://leetcode.com/playground/Sfqzaf8u/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\n",
                "solutionTags": [],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashing of strings in linear-time. Time complexity is **O(N)**. Space complexity is **O(N)**. \\n\\n**Comment**. To group anagrams, we should use something (i.e., some hash) that:\\n* uniquely distinguishes one group from another;\\n* is the same for all members of each group.\\n\\nAmong the potential candidates are:\\n* list of letter frequencies in alphabetical order, that takes **O(N)** time to compute;\\n* sorted version of a string, that takes **O(N\\\\*logN)** time to compute.\\n\\nHere, we\\'ll go with the first option.\\n\\n<iframe src=\"https://leetcode.com/playground/Sfqzaf8u/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 19404,
                "title": "sharing-my-very-concise-solution-with-explanation",
                "content": "    vector<string> anagrams(vector<string> &strs) {\\n        vector<string> result;\\n        vector<string> sortedStrs = strs;\\n        unordered_map<string, vector<int>> map;\\n        for(int i = 0; i < strs.size(); i++){\\n            sort(sortedStrs[i].begin(), sortedStrs[i].end());\\n            map[sortedStrs[i]].push_back(i);\\n        }\\n        for(auto it = map.begin(); it != map.end(); it++){\\n            if(it->second.size() > 1){\\n                for(int i = 0; i < it->second.size(); i++){\\n                    result.push_back(strs[it->second[i]]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nHere is basic idea for this problem.\\n\\nFirst, get a copy of \"strs\". Let's name this copy \"sortedStrs\".\\n\\nSecond, sort all strings in \"sortedStrs\".\\n\\nAnd we have a hash map `unordered_map<string, vector<int>> map`.\\n\\nEvery string in \"sortedStrs\" will be recorded in this hash map with its position.\\n\\nIn the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in \"strs\".\\n\\nDone.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "    vector<string> anagrams(vector<string> &strs) {\\n        vector<string> result;\\n        vector<string> sortedStrs = strs;\\n        unordered_map<string, vector<int>> map;\\n        for(int i = 0; i < strs.size(); i++){\\n            sort(sortedStrs[i].begin(), sortedStrs[i].end());\\n            map[sortedStrs[i]].push_back(i);\\n        }\\n        for(auto it = map.begin(); it != map.end(); it++){\\n            if(it->second.size() > 1){\\n                for(int i = 0; i < it->second.size(); i++){\\n                    result.push_back(strs[it->second[i]]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\nHere is basic idea for this problem.\\n\\nFirst, get a copy of \"strs\". Let's name this copy \"sortedStrs\".\\n\\nSecond, sort all strings in \"sortedStrs\".\\n\\nAnd we have a hash map `unordered_map<string, vector<int>> map`.\\n\\nEvery string in \"sortedStrs\" will be recorded in this hash map with its position.\\n\\nIn the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in \"strs\".\\n\\nDone.",
                "codeTag": "Unknown"
            },
            {
                "id": 3423036,
                "title": "4-best-swift-solutions-easy-to-understand",
                "content": "# First solution using Dictionary\\n\\n## Approach\\n\\nFirstly, the functions creates an empty dictionary with the key as a `String` and the value as an array of `String`. Then, it iterates over each string in the given array of strings `strs`. \\n\\nFor each string in `strs`, the function sorts the characters of the string using the `sorted()` method and creates a new string with the sorted characters. This sorted string is then used as the key to the dictionary. \\n\\nIf the dictionary already has the sorted string as the key, the given string is appended to the array of strings that correspond to the given key. Otherwise, a new key-value pair is added to the dictionary with the sorted string as the key and the given string as the value of a new array.\\n\\nFinally, the function returns an array of arrays of strings. Each array of strings represents a group of anagrams. It is done by using the `values` property of the dictionary to get an array of arrays.\\n\\n## Complexity\\n\\nThis approach has a *time complexity* of $$O(n \\\\cdot m \\\\cdot \\\\log m)$$, where $$n$$ is the number of strings in `strs` and $$m$$ is the maximum length of a string in `strs`.\\n\\nThe *space complexity* of the given solution is $$O(n \\\\cdot m)$$, where $$n$$ is the number of strings in the input array `strs` and $$m$$ is the maximum length of a string in `strs`. \\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [String: [String]]()\\n\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            dict[sortedStr, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Second solution using Dictionary\\n\\n## Approach\\n\\nFirst, a dictionary is created with keys as arrays of integers (count of characters in the string) and values as arrays of strings (the anagrams). \\n\\nThen, for each string in the input array, an array of `counts` of the characters in the string is created. The counts array is initialized with zeros for each of the `26` alphabets. \\n\\nNext, each character in the string is iterated over, and the corresponding `index` in the counts array is incremented. \\n\\nAfter counting the characters in the string, the `counts` array is used as a key in the dictionary. The string is then appended to the corresponding value array for that key. \\n\\nFinally, the values of the dictionary are returned as an array of grouped anagrams.\\n\\n## Complexity\\n\\nThis approach is efficient, as it only requires iterating over each string in the input array once, and the *time complexity* is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string.\\n\\nThe *space complexity* of this approach is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string.\\n\\n## Code\\n\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [[Int]: [String]]()\\n\\n        for str in strs {\\n            var counts = Array(repeating: 0, count: 26)\\n            for char in str {\\n                let index = Int(char.asciiValue! - 97)\\n                counts[index] += 1\\n            }\\n            dict[counts, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n---\\n\\n# Third solution using Dictionary(grouping:)\\n\\n## Approach\\n\\nThe approach to solving the problem involves using the built-in `Dictionary` function `grouping(_:by:)` and the `sorted()` method of strings to group the anagrams together.\\n\\nThe `grouping(_:by:)` function takes an array and a closure that returns a key for each element in the array. It groups the elements of the array by the returned key, and returns a dictionary with keys as the returned key and values as arrays of elements that have the same key.\\n\\nIn this case, the `strs` array is passed to the `grouping(_:by:)` function, and a closure is provided that sorts each string and converts it to a new string. The sorted string is used as the key for the dictionary.\\n\\nThe `sorted()` method on a string returns an array of characters sorted in ascending order. By converting the sorted array of characters back to a string, we obtain a canonical form of the input string, which is the same for all anagrams of that string.\\n\\nFinally, the `values` property of the dictionary is accessed, which returns an array of arrays of anagrams. The `map` function is used to extract the arrays of anagrams and return them as a 2D array.\\n\\n## Complexity\\n\\nThis approach has a *time complexity* of $$O(n \\\\cdot k \\\\cdot \\\\log k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the length of the longest string\\n\\nThe *space complexity* of the given solution is $$O(n \\\\cdot k)$$, as a dictionary is used to store the grouped anagrams.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        Dictionary(grouping: strs, by: { String($0.sorted()) }).values.map { $0 }\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Fourth solution using \\xABProduct of Primes\\xBB\\n\\n## Approach\\n\\nTo solve this problem, the approach used in the given Swift function is based on the idea of hashing. In this approach, each string is assigned a unique hash key based on the product of the prime numbers assigned to each character in the string. The prime numbers assigned to each character are chosen in such a way that the hash keys of two strings will be equal only if they are anagrams of each other. \\n\\nIn the code, a dictionary is used to store the hash keys as keys and the corresponding anagrams as values. For each string in the input array, the hash key is calculated by multiplying the prime numbers assigned to each character in the string. If the hash key is already present in the dictionary, the current string is appended to the list of anagrams for that key. Otherwise, a new key-value pair is added to the dictionary with the hash key and the current string.\\n\\nFinally, the function returns an array containing the values of the dictionary, which are the lists of anagrams grouped together. The order of the anagram groups in the output array can be arbitrary.\\n\\n## Complexity\\n\\nThe *time complexity* of this solution is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the maximum length of a string in the input array.\\n\\nThe space complexity of this solution is $$O(n \\\\cdot k)$$, where $$n$$ is the number of strings in the input array and $$k$$ is the maximum length of a string in the input array.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        let mod = 1_000_000_007\\n        var dict = [Int: [String]]()\\n        let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\\n\\n        for s in strs {\\n            var key = 1\\n            for ch in s {\\n                key = key * primes[Int(ch.asciiValue! - Character(\"a\").asciiValue!)] % mod\\n            }\\n            dict[key, default: []].append(s)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/9d031f2a-2935-4fde-bedc-c35de65d1beb_1681635981.4891484.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [String: [String]]()\\n\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            dict[sortedStr, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict = [[Int]: [String]]()\\n\\n        for str in strs {\\n            var counts = Array(repeating: 0, count: 26)\\n            for char in str {\\n                let index = Int(char.asciiValue! - 97)\\n                counts[index] += 1\\n            }\\n            dict[counts, default: []].append(str)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        Dictionary(grouping: strs, by: { String($0.sorted()) }).values.map { $0 }\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        let mod = 1_000_000_007\\n        var dict = [Int: [String]]()\\n        let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\\n\\n        for s in strs {\\n            var key = 1\\n            for ch in s {\\n                key = key * primes[Int(ch.asciiValue! - Character(\"a\").asciiValue!)] % mod\\n            }\\n            dict[key, default: []].append(s)\\n        }\\n\\n        return Array(dict.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434269,
                "title": "golang-17-lines-of-easy-to-understand-solution-without-using-sort",
                "content": "We can take advantage of anagram\\'s defination:\\n> An anagram is a word or phrase formed by rearranging the letters of a different word or phrase\\n\\nSo we can consider using a hashmap to store every letter\\'s frequency and group those who have the same frequency, but in Golang slice cannot be a key. \\nWe are told:\\n> All inputs will be in lowercase.\\nSo we can use array as a key, whose capacity is 26 since there are only 26 letters. \\n\\n* time complexity: O(nk), n is `len(strs)`, k is the length of the longest string in `strs`\\n* space complexity: O(nk), for we are using a hashmap\\n\\n```\\nfunc groupAnagrams(strs []string) [][]string {\\n\\tmp := map[[26]int][]string{}\\n\\tfor _, s := range strs {\\n\\t\\tk := [26]int{}\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\tk[s[i]-\\'a\\'] += 1\\n\\t\\t}\\n\\t\\tmp[k] = append(mp[k], s)\\n\\t}\\n\\tres := [][]string{}\\n\\tfor _, v := range mp {\\n\\t\\tres = append(res, v)\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n\\tmp := map[[26]int][]string{}\\n\\tfor _, s := range strs {\\n\\t\\tk := [26]int{}\\n\\t\\tfor i := 0; i < len(s); i++ {\\n\\t\\t\\tk[s[i]-\\'a\\'] += 1\\n\\t\\t}\\n\\t\\tmp[k] = append(mp[k], s)\\n\\t}\\n\\tres := [][]string{}\\n\\tfor _, v := range mp {\\n\\t\\tres = append(res, v)\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422306,
                "title": "using-hashtable-easy-to-understand",
                "content": "\\n\\n# Python Solution\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for word in strs:\\n            sorted_word=\"\".join(sorted(word))\\n            if sorted_word not in dic:\\n                dic[sorted_word]=[word]\\n            else:\\n                dic[sorted_word].append(word)\\n        return dic.values()\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for word in strs:\\n            sorted_word=\"\".join(sorted(word))\\n            if sorted_word not in dic:\\n                dic[sorted_word]=[word]\\n            else:\\n                dic[sorted_word].append(word)\\n        return dic.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107534,
                "title": "92-49-javascript-fast-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/nUfXklKCGTk\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n\\n    for(let str of strs){\\n        let s = str.split(\\'\\').sort().join(\\'\\')\\n        if(!map[s]) map[s] = []\\n        map[s].push(str)\\n    }\\n    return Object.values(map)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n\\n    for(let str of strs){\\n        let s = str.split(\\'\\').sort().join(\\'\\')\\n        if(!map[s]) map[s] = []\\n        map[s].push(str)\\n    }\\n    return Object.values(map)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327706,
                "title": "javascript-7-line-solution-using-primes-beats-99-8-without-sorting",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n *\\n * key point: \\n * prime multiply prime is unique, each char canbe represented by a prime\\n * since [a-z] to  [0-25]\\n * use `[charCodeAt() - 97]` to get unique index from the prime array\\n * the prodcut can be set to the key name \"prod\"\\n **/\\n    var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n *\\n * key point: \\n * prime multiply prime is unique, each char canbe represented by a prime\\n * since [a-z] to  [0-25]\\n * use `[charCodeAt() - 97]` to get unique index from the prime array\\n * the prodcut can be set to the key name \"prod\"\\n **/\\n    var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 19224,
                "title": "a-clean-c-solution-with-unordered-map",
                "content": "\\tvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\t\\tunordered_map<string, vector<string>> count;\\n\\t\\tint i = 0;\\n\\t\\tfor (auto s : strs)\\n\\t\\t{\\n\\t\\t\\tsort(s.begin(), s.end());\\n\\t\\t\\tcount[s].push_back(strs[i++]);\\n\\t\\t}\\n\\t\\tvector<vector<string>> res;\\n\\t\\tfor (auto n : count){\\n\\t\\t\\tsort(n.second.begin(), n.second.end());\\n\\t\\t\\tres.push_back(n.second);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "\\tvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\t\\tunordered_map<string, vector<string>> count;\\n\\t\\tint i = 0;\\n\\t\\tfor (auto s : strs)\\n\\t\\t{\\n\\t\\t\\tsort(s.begin(), s.end());\\n\\t\\t\\tcount[s].push_back(strs[i++]);\\n\\t\\t}\\n\\t\\tvector<vector<string>> res;\\n\\t\\tfor (auto n : count){\\n\\t\\t\\tsort(n.second.begin(), n.second.end());\\n\\t\\t\\tres.push_back(n.second);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2838344,
                "title": "100-animation-to-the-hard-solution-and-easy-solution-explained",
                "content": "[https://youtu.be/3cAxlUsBfas]()\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "[https://youtu.be/3cAxlUsBfas]()\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2750734,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/UnfxY7Sm/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nAnother Approach using Prime numbers\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int M = 1e9 + 9;\\n        vector<int> primes = {\\n            2, 3, 5, 7, 11,\\n            13, 17, 19, 23, 29,\\n            31, 37, 41, 43, 47,\\n            53, 59, 61, 67, 71,\\n            73, 79, 83, 89, 97, \\n            101\\n        };\\n\\t\\t// hacked by [\"djrw\", \"beisx\", \"ceflvx\", \"anp\"] :D\\n        // for (int i = 0; i < 26; i++)  primes[i] = i * i + i + 41;\\n        unordered_map<long long, vector<string>> m;\\n        for (int i = 0; i < strs.size(); i++) {\\n            long long k = 1;\\n            for (int j = 0; j < strs[i].size(); j++) {\\n                k *= 1LL * primes[strs[i][j] - \\'a\\'];\\n                k %= M;\\n            }\\n            m[k].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for (auto x : m) ans.push_back(x.second);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int M = 1e9 + 9;\\n        vector<int> primes = {\\n            2, 3, 5, 7, 11,\\n            13, 17, 19, 23, 29,\\n            31, 37, 41, 43, 47,\\n            53, 59, 61, 67, 71,\\n            73, 79, 83, 89, 97, \\n            101\\n        };\\n\\t\\t// hacked by [\"djrw\", \"beisx\", \"ceflvx\", \"anp\"] :D\\n        // for (int i = 0; i < 26; i++)  primes[i] = i * i + i + 41;\\n        unordered_map<long long, vector<string>> m;\\n        for (int i = 0; i < strs.size(); i++) {\\n            long long k = 1;\\n            for (int j = 0; j < strs[i].size(); j++) {\\n                k *= 1LL * primes[strs[i][j] - \\'a\\'];\\n                k %= M;\\n            }\\n            m[k].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for (auto x : m) ans.push_back(x.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399131,
                "title": "c-easy-clean-solution-using-sorting-and-map",
                "content": "**Solution:**\\n\\n**Approach**\\n1. We need to group all `anagrams` together.\\n2. An Anagram is a word or phrase formed by `rearranging the letters` of a different word or phrase, typically using all the original letters `exactly once`.\\n3. If we sort a particular string, we have one `unique string` which can be called as the `primary string` through which all anagrams were made(Just an imagination to understand the concept better).\\n4. For each sorted string, group it with its anagram(original string) using `map`.\\n5. Return the `result` in any order.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity: `O(n * (m * log(m)))`\\n* where n is the total number of strings present in the `vector` and m is the `maximum length` of a string in the vector. Here, sorting the strings causes `(m * log(m))` addition to the complexity.\\n\\nSpace Complexity: `O(n * m)`\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241396,
                "title": "python-simple-solution-brute-force",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = {}\\n        for i in strs:\\n            srt = str(sorted(i))\\n            if srt in ans:\\n                ans[srt].append(i)\\n            else:\\n                ans[srt] = [i]\\n        return list(ans.values())\\n```\\n**.\\n.\\n.\\n.\\n.\\n...Please Up-vote if you find this useful...**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = {}\\n        for i in strs:\\n            srt = str(sorted(i))\\n            if srt in ans:\\n                ans[srt].append(i)\\n            else:\\n                ans[srt] = [i]\\n        return list(ans.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887227,
                "title": "python-3-90-faster-simple-approach",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nKey learnings for me:\\n1. parameter \"list\" in defaultdict is lowercase\\n2. sorted() returns iterable. We need to join the returned list to create a string\\n3. We can loop through dictionary to store the values in result list or we can directly use dic.values()\\n\\n```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n\\tdic = collections.defaultdict(list)\\n\\tfor st in strs:\\n\\t\\ts = \\'\\'.join(sorted(st))\\n\\t\\tdic[s].append(st)\\n\\n\\treturn dic.values()\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n\\tdic = collections.defaultdict(list)\\n\\tfor st in strs:\\n\\t\\ts = \\'\\'.join(sorted(st))\\n\\t\\tdic[s].append(st)\\n\\n\\treturn dic.values()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1398912,
                "title": "python-2-solutions-o-nk-log-k-and-o-nk-26n-explained",
                "content": "#### Solution 1\\nFirst idea is to notice that if we have two anagrams, than when we sort symbols in each of them, then we will have exactly the same string. So we need for each string to sort it and then use defaultdict. \\n\\n#### Complexity\\nTime complexity will be `O(nk * log k)`, space complexity is `O(nk)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        t = defaultdict(list)\\n        for s in strs:\\n            t[\"\".join(sorted(s))].append(s)\\n        return t.values()\\n```\\n\\n#### Solution 2\\nTwo strings are anagrams if and only if their character counts, that is frequencies of each letter `a, b, ..., z` are the same. So it can be done with `defauldict(list)`, where key is 26-element list and values are strings, corresponding to this key.\\n\\n#### Complexity\\nTime complexity is `O(nk + 26n)`, where `n` is number of strings and `k` is the length of the biggest string. Space complexity is `O(26n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        ans = defaultdict(list)\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            ans[tuple(count)].append(s)\\n        return ans.values()\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        t = defaultdict(list)\\n        for s in strs:\\n            t[\"\".join(sorted(s))].append(s)\\n        return t.values()\\n```\n```python\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        ans = defaultdict(list)\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            ans[tuple(count)].append(s)\\n        return ans.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566272,
                "title": "simple-c-solution",
                "content": "Basically, just create a map keyed by all of the sorted and unique words, and its value corresponds with a vector consisting of all the strings that when sorted, results in the key.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> y;\\n        \\n        if(strs.size() == 0) return y;\\n        \\n        map<string,vector<string>> dict;\\n        for(string s: strs)\\n        {\\n            string sorted = s;\\n            sort(sorted.begin(),sorted.end());\\n            dict[sorted].push_back(s);\\n        }\\n        map<string,vector<string>>::iterator o = dict.begin();\\n        while(o != dict.end())\\n        {\\n            y.push_back(o->second);\\n            o++;\\n        }\\n    \\n        return y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> y;\\n        \\n        if(strs.size() == 0) return y;\\n        \\n        map<string,vector<string>> dict;\\n        for(string s: strs)\\n        {\\n            string sorted = s;\\n            sort(sorted.begin(),sorted.end());\\n            dict[sorted].push_back(s);\\n        }\\n        map<string,vector<string>>::iterator o = dict.begin();\\n        while(o != dict.end())\\n        {\\n            y.push_back(o->second);\\n            o++;\\n        }\\n    \\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751413,
                "title": "rust-hashmap-functional-style-with-comments",
                "content": "Strings are grouped by the histogram of letter frequencies. Use this as the key in a hash map, collecting the strings in the map values. I had hopes of making this a one-liner, but have not figured out a way to get around that we have to return the modified histogram/map in the `fold` body. :)\\n\\nImplementation notes:\\n* `N_LETTERS` instead of the magic value 26.\\n* `strs.into_iter` to take ownership of the provided strings and move them into the map.\\n* `or_default` for the most concise insertion of an empty vector if this is the first time we encounter a key.\\n* `into_values` to directly map the values to the output iterator, instead of `into_iter().map(...)`, and to take ownership of the hash map values => the string instances we get as input are the same instances that we return in the output.\\n\\n```\\nuse std::collections::HashMap;\\n\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        strs.into_iter().fold(HashMap::<[u8; N_LETTERS], Vec<String>>::new(), |mut map, s| {\\n            let freqs = s.bytes().map(|b| (b - b\\'a\\') as usize).fold([0; N_LETTERS], |mut freqs, bin| {\\n                freqs[bin] += 1;\\n                freqs\\n            });\\n            map.entry(freqs).or_default().push(s);\\n            map\\n        }).into_values().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        strs.into_iter().fold(HashMap::<[u8; N_LETTERS], Vec<String>>::new(), |mut map, s| {\\n            let freqs = s.bytes().map(|b| (b - b\\'a\\') as usize).fold([0; N_LETTERS], |mut freqs, bin| {\\n                freqs[bin] += 1;\\n                freqs\\n            });\\n            map.entry(freqs).or_default().push(s);\\n            map\\n        }).into_values().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751397,
                "title": "easy-solution-c-java-python",
                "content": "**If You Liked the Solution Please Upvote**\\n\\n`The approach is based on the fact that on sorting all anagrams will result into the same string.`\\n`So we use a map with key= sorted string and value = vector containing all anagrams which on sorting will give the string in key.`\\n`Then we will iterate through the map and store all these vectors into an another vector and return it as answer.`\\n\\n`C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        \\n        for(auto x: strs){\\n            string temp = x;\\n            sort(temp.begin(), temp.end());\\n            \\n            m[temp].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(auto x: m){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`JAVA`\\n\\n```\\n public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String,List<String>> hm = new HashMap<>();\\n        for(String s : strs){\\n            \\n            char[] chars=s.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            \\n            if (!hm.containsKey(key)) {\\n                hm.put(key, new ArrayList<>());\\n            }\\n            hm.get(key).add(s);\\n            \\n        }\\n        return new ArrayList<>(hm.values());\\n    }\\n```\\n\\n`PYTHON`\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        groupedWords = defaultdict(list)\\n        \\n        for word in strs:\\n            groupedWords[\"\".join(sorted(word))].append(word)\\n        \\n        result = []\\n        \\n        for valueSet in groupedWords.values():\\n            result.append(valueSet)\\n        \\n        return  result  \\n```\\n\\n**If You Liked the Solution Please Upvote**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        \\n        for(auto x: strs){\\n            string temp = x;\\n            sort(temp.begin(), temp.end());\\n            \\n            m[temp].push_back(x);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(auto x: m){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String,List<String>> hm = new HashMap<>();\\n        for(String s : strs){\\n            \\n            char[] chars=s.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            \\n            if (!hm.containsKey(key)) {\\n                hm.put(key, new ArrayList<>());\\n            }\\n            hm.get(key).add(s);\\n            \\n        }\\n        return new ArrayList<>(hm.values());\\n    }\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        groupedWords = defaultdict(list)\\n        \\n        for word in strs:\\n            groupedWords[\"\".join(sorted(word))].append(word)\\n        \\n        result = []\\n        \\n        for valueSet in groupedWords.values():\\n            result.append(valueSet)\\n        \\n        return  result  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749902,
                "title": "c-solution-using-soring-and-without-sorting-by-hashmap-with-time-complexity-analysis",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Solution using ***HashMap with sorting.***\\n- Here we store all same strings in a vector inside Hashmap.\\n- We\\u2019ll take every string from strs in temp then sort that by character. Push the main string to the map.\\n- Like these elements with the same character will push to the same vector of hashmap.\\n- Then push all the vectors from map to ans.\\n- **Time complexity:** O(n.klogk) /***k**\\xA0is the length of string and\\xA0**n**\\xA0is the total no. of strings*\\n\\n### Solution 02\\n\\n- Solution using ***Map without sorting.***\\n- Here we\\u2019ll do the same but this time we\\u2019ll take a map of map to skip the sorting part.\\n- If we could use an unordered map then time complexity could reduce to O(nk), but as it takes O(logn) time for any operations, so time takes same as solution 1.\\n- Here we count the characters in map and push it to main map.\\n- **Time complexity:** O(n.klogk) /*insertion into a map takes **logK** time*\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        unordered_map<string, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            string a = strs[i];\\n            sort(a.begin(), a.end());\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        map<map<char, int>, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            map<char, int> a;\\n            for(int j=0; j<strs[i].size(); j++)\\n                a[strs[i][j]]++;\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        unordered_map<string, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            string a = strs[i];\\n            sort(a.begin(), a.end());\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n = strs.size();\\n        map<map<char, int>, vector<string>> mp;\\n        vector<vector<string>>ans;\\n        \\n        int i=0;\\n        while(i<n){\\n            map<char, int> a;\\n            for(int j=0; j<strs[i].size(); j++)\\n                a[strs[i][j]]++;\\n            mp[a].push_back(strs[i]);\\n            i++;\\n        }\\n        for(auto i=mp.begin(); i!= mp.end(); i++){\\n            ans.push_back(i->second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399451,
                "title": "group-anagrams-explanation-w-images-using-map-c-python-java",
                "content": "**Pre-requisite:**\\n*What is an Anagram?*\\nTwo strings are said to be anagrams of each other if they are made up of the same characters with same frequency. For example: the word `LISTEN` and `SILENT` are anagrams. They are composed of the letters `E, I, L, N, S, T`.\\n`Insight-` The input is only `lowercase aplhabets`\\n\\n**Algorithm:**\\n`Technique` - Group By Sorting\\n*SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/9e9dee48-ad03-4047-8a66-b11e8dbcac7f_1628753485.5853918.png)\\n*SORTED SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/12e377a3-1779-4e7c-ba97-f19fb5d390db_1628753533.013706.png)\\n* Once we have made this observation, we create a map for the same where the `key` will be the sorted string, and the `value` would be the list of all the strings that are anagrams.\\n* After iteration over all the strings, we get the desired group of anagrams\\n* The time complexity of this approach depends on the sorting technique you use to sort the strings.\\n\\n**Solution:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```\\n**TIME COMPLEXITY - O(N*KlogK)**, where k is the length of the largest string. \\n* This is because we are sorting string in every iteration.\\n* It would be **different for different sorting techniques** for e.g. `O(N*K) for Counting Sort`\\n\\n**SPACE COMPLEXITY - O(N*K)**\\n\\n\\n**SCRAP APPROACH:**\\n`Brute Force-` Will give TLE on Large Testcases\\n* Iterate over each string in the input array.\\n* For each string, check with each element of the array if they are anagrams.\\n* If it is an anagram, add it to a group.\\n* Else, move the string to a different group\\n\\n**Do Consider the post for upvotes if you liked it. If you find any mistakes do let me know.\\uD83D\\uDE0A\\nIf you are blindly downvoting I hope you get better and stop being jealous :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566674,
                "title": "java-hashmap-solution-and-no-sorting-required",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap();\\n        for (String s : strs) {\\n            int[] m = new int[26];\\n            for (char c : s.toCharArray()) m[c-\\'a\\']++;\\n            String key = Arrays.toString(m);\\n            map.putIfAbsent(key, new ArrayList());\\n            map.get(key).add(s);\\n        }\\n        return new ArrayList(map.values());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap();\\n        for (String s : strs) {\\n            int[] m = new int[26];\\n            for (char c : s.toCharArray()) m[c-\\'a\\']++;\\n            String key = Arrays.toString(m);\\n            map.putIfAbsent(key, new ArrayList());\\n            map.get(key).add(s);\\n        }\\n        return new ArrayList(map.values());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434805,
                "title": "concise-javascript-solution",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    /* sort each string, use that as key in map and when new sorted string matches a key we add it to that */\\n    const map = {};\\n    \\n    for (const str of strs) {\\n        const sorted = str.split(\\'\\').sort().join(\\'\\');\\n        \\n        if (!map[sorted]) {\\n            map[sorted] = [str];\\n        } else {\\n            map[sorted].push(str);\\n        }\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    /* sort each string, use that as key in map and when new sorted string matches a key we add it to that */\\n    const map = {};\\n    \\n    for (const str of strs) {\\n        const sorted = str.split(\\'\\').sort().join(\\'\\');\\n        \\n        if (!map[sorted]) {\\n            map[sorted] = [str];\\n        } else {\\n            map[sorted].push(str);\\n        }\\n    }\\n    \\n    return Object.values(map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889233,
                "title": "java-easy-hashmap",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String,ArrayList<String>> mpp = new HashMap<String,ArrayList<String>>();\\n\\n        for(String st:strs){\\n            char[] ch = st.toCharArray();\\n            Arrays.sort(ch);\\n            String ss = String.valueOf(ch);\\n            if(!mpp.containsKey(ss)) mpp.put(ss,new ArrayList<String>());\\n            mpp.get(ss).add(st);\\n        }\\n        return new ArrayList<>(mpp.values());\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String,ArrayList<String>> mpp = new HashMap<String,ArrayList<String>>();\\n\\n        for(String st:strs){\\n            char[] ch = st.toCharArray();\\n            Arrays.sort(ch);\\n            String ss = String.valueOf(ch);\\n            if(!mpp.containsKey(ss)) mpp.put(ss,new ArrayList<String>());\\n            mpp.get(ss).add(st);\\n        }\\n        return new ArrayList<>(mpp.values());\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566165,
                "title": "simple-python3-solution-using-dictionary-and-sorted-anagrams",
                "content": "The idea here is to use the sorted anagram as a key and the anagrams themselves as the values. In the end, after iterating through the list of words, you\\'ll return the values from the dictionary.\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n      anagrams = defaultdict(list)\\n      for word in strs:\\n        anagrams[\\'\\'.join(sorted(word))].append(word)\\n      return list(anagrams.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n      anagrams = defaultdict(list)\\n      for word in strs:\\n        anagrams[\\'\\'.join(sorted(word))].append(word)\\n      return list(anagrams.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412445,
                "title": "dictionary-sorting-python-easy-solution-with-explanation",
                "content": "# Intuition\\n**Find a way to associate similar words together.** \\nWe can utilize the **wo**rd **co**unt **ap**proach but I preferred the approach where you **so**rt the **wo**rd. This allows **an**agrams to be **so**rted and we can then **ma**tch the **wo**rds. \\nFor example, \\n\\n`\\'tan\\' and \\'nat\\' when sorted would become \\'ant\\' and \\'ant\\'`\\n\\n\\n\\n# Approach\\n1. Iterate over the \\'strs\\' and sort each word.\\n2. Check if the sorted word exists as key in the dictionary/hashmap\\n3. Because we are going to use the original word in the returned output,create a temp variable to store the sorted word.\\n4. Now check if the temporary sorted word exists in the dictionary/hashmap\\n5. If yes, append the word to the values list.\\n6. If no, add a new key-value pair in the dictionary/hashmap.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Create a dictionary to act as hashmap\\n        res = {}\\n        for word in strs:\\n            # We want to retain the original word to add to the dictionary\\n            # Therefore, create a temporary variable with the sorted word\\n            temp = \\'\\'.join(sorted(word))\\n            # If the sorted word exists in the dictionary, \\n            # append to the values list\\n            if temp in res:\\n                res[temp].append(word)\\n            # Else, add a new key-value pair to the dictionary\\n            else:\\n                res[temp] = [word]\\n        # We only require the values list to be returned\\n        return res.values()\\n\\n```\\n<br><br>\\nPlease **up**vote if you find the approach and **ex**planation **us**eful!\\n<br>",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Create a dictionary to act as hashmap\\n        res = {}\\n        for word in strs:\\n            # We want to retain the original word to add to the dictionary\\n            # Therefore, create a temporary variable with the sorted word\\n            temp = \\'\\'.join(sorted(word))\\n            # If the sorted word exists in the dictionary, \\n            # append to the values list\\n            if temp in res:\\n                res[temp].append(word)\\n            # Else, add a new key-value pair to the dictionary\\n            else:\\n                res[temp] = [word]\\n        # We only require the values list to be returned\\n        return res.values()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19178,
                "title": "c-clean-solution-beat-95-83-hash-map",
                "content": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> h;\\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(temp.begin(), temp.end());\\n            h[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto m: h) ans.push_back(m.second);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> h;\\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(temp.begin(), temp.end());\\n            h[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto m: h) ans.push_back(m.second);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2920518,
                "title": "solution",
                "content": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328466,
                "title": "c-one-pass-24ms-99-99-faster-and-15-5-mb-99-73-less-memory",
                "content": "The common idea is to use a hashmap (unordered_map) to group the strings. \\nThere are several ways to choose the key for this task.\\n\\n1. Use sorted string as key, e.g `eat` and `tea` produce the same key, `aet`.\\n2. Use a counter array and transform it to a key somehow, e.g `none` and `neon` have 2 `n`s, 1 `o` and 1 `e`.\\n3. Use a perfect (no collision) hash that produces a unique hash for each anagram.\\n\\nOption 1 is slow, because sorting takes time. Option 2 is better, but it takes more memory than necessary (`26 * sizeof(int)`), needs some transformation operation.\\n\\nFor Option 3, we could multiply each char, like `A` would become `1` and `Z` would become `26`. e.g `eat` -> `5 * 1 * 20` -> `100`, `tea` -> `20 * 5 * 1` -> `100`. Therefore, the hash is indifferent to the order of the chars.\\n\\nThe problem is these numbers are not primes, so their multiplication can cause collisions like `abebe` (not a word)-> `1 * 2 * 5 * 2 * 5` -> `100`. Actually since `A` is `1`, we can add infenitely many `A`s and still get the same hash!\\n\\nWe mentioned that these numbers were not primes, what we can do is instead of mapping `A...Z` to `1...26`, we can map each char to a different, preferably small primes. Thus, if we map each char to the first 26 primes, we can generate a unique hash for each anagram.\\n\\n\\n```\\nuint32_t hash(const string &word) {\\n\\tstatic int primes[26] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };\\n\\n\\tuint32_t hash = 1;\\n\\tfor (char c : word) {\\n\\t\\tint prime = primes[c - \\'a\\'];\\n\\t\\thash *= prime;\\n\\t}\\n\\treturn hash;\\n}\\n```\\n\\n**EDIT: There is a bug in this hashing function, thanks to @WillF for pointing out the overflow issue, please refer to the comments for the updated one.**\\n\\nNow for the rest, normally you\\'d see two passes for this task, one for grouping the strings and one for extracting all values of the `unorderd_map` like\\n```\\nunordered_map<uint32_t, vector<string>> mapping;\\n...\\nfor (string word : strs) { ... }\\n\\n// If only we could do `return mapping.values()`\\nvector<vector<string>> result;\\nfor (auto pair : mapping) {\\n  result.push_back(pair.second);\\n}\\n\\nreturn result;\\n```\\n\\nThis has the problem of a lot of unnecessary copying. `unordered_map` is a blackbox, what we can do is to force it to sequentially place each group by taking care of the allocation process. The key remains the same, but the value now becomes a pointer to the actual container. This way we can directly return the required container without additional passes. \\n\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\tunordered_map<uint32_t, vector<string> *> mapping;\\n\\tvector<vector<string>> ans;\\n\\n\\t// Hack: \\n\\t//  If we reserve size beforehand, the vector will not grow \\n\\t//  during `push_back()` operations\\n\\t//  Thus, the pointers (vector<string> *) won\\'t become invalidated, i.e dangling pointers\\n\\tans.reserve(strs.size());\\n\\n\\t// Optional: \\n\\t//   Empirically, reserving 1/4th of the number of words \\n\\t//   gives the best performance\\n\\tmapping.reserve(strs.size() / 4);\\n\\n\\tfor (string word : strs) {\\n\\t\\tuint32_t h = hash(word);\\n\\n\\t\\tauto search = mapping.find(h);\\n\\t\\tif (search == mapping.end()) {\\n\\t\\t\\t// Create a new bucket for this new anagram\\n\\t\\t\\tvector<string> v { word };\\n\\t\\t\\tans.push_back(std::move(v));\\n\\n\\t\\t\\t// Note that we can\\'t also do &v because it will soon get deallocated\\n\\t\\t\\tmapping[h] = &ans.back();\\n\\t\\t} else {\\n\\t\\t\\tmapping[h]->push_back(word);\\n\\t\\t}\\n\\t\\t// This way we avoid copying the strings in the last step\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\nTo avoid the dangling pointer problem, instead of using references we can just store the index of the corresponding `vector<string>`, so if the `vector<vector<string>>` decides to grow, we will still access the correct container.\\n(indexes and pointers are very related concepts after all.)\\n\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n    unordered_map<uint32_t, size_t> mapping;\\n    vector<vector<string>> ans;\\n    \\n    // Optional: Not mandatory anymore, but still helps with performance\\n    ans.reserve(strs.size());\\n    \\n    // Optional: \\n    //   Empirically, reserving 1/4th of the number of words \\n    //   gives the best performance\\n    mapping.reserve(strs.size() / 4);\\n    \\n    for (string word : strs) {\\n        uint32_t h = hash(word);\\n        \\n        auto search = mapping.find(h);\\n        if (search == mapping.end()) {\\n            // Create a new bucket for this new anagram\\n            vector<string> v { word };\\n            ans.push_back(std::move(v));\\n            \\n            // Store the corresponding vector index for this group\\n            mapping[h] = ans.size() - 1;\\n        } else {\\n            size_t index = mapping[h];\\n            ans[index].push_back(word);\\n        }\\n        // This way we avoid copying the strings in the last step\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nuint32_t hash(const string &word) {\\n\\tstatic int primes[26] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101 };\\n\\n\\tuint32_t hash = 1;\\n\\tfor (char c : word) {\\n\\t\\tint prime = primes[c - \\'a\\'];\\n\\t\\thash *= prime;\\n\\t}\\n\\treturn hash;\\n}\\n```\n```\\nunordered_map<uint32_t, vector<string>> mapping;\\n...\\nfor (string word : strs) { ... }\\n\\n// If only we could do `return mapping.values()`\\nvector<vector<string>> result;\\nfor (auto pair : mapping) {\\n  result.push_back(pair.second);\\n}\\n\\nreturn result;\\n```\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\tunordered_map<uint32_t, vector<string> *> mapping;\\n\\tvector<vector<string>> ans;\\n\\n\\t// Hack: \\n\\t//  If we reserve size beforehand, the vector will not grow \\n\\t//  during `push_back()` operations\\n\\t//  Thus, the pointers (vector<string> *) won\\'t become invalidated, i.e dangling pointers\\n\\tans.reserve(strs.size());\\n\\n\\t// Optional: \\n\\t//   Empirically, reserving 1/4th of the number of words \\n\\t//   gives the best performance\\n\\tmapping.reserve(strs.size() / 4);\\n\\n\\tfor (string word : strs) {\\n\\t\\tuint32_t h = hash(word);\\n\\n\\t\\tauto search = mapping.find(h);\\n\\t\\tif (search == mapping.end()) {\\n\\t\\t\\t// Create a new bucket for this new anagram\\n\\t\\t\\tvector<string> v { word };\\n\\t\\t\\tans.push_back(std::move(v));\\n\\n\\t\\t\\t// Note that we can\\'t also do &v because it will soon get deallocated\\n\\t\\t\\tmapping[h] = &ans.back();\\n\\t\\t} else {\\n\\t\\t\\tmapping[h]->push_back(word);\\n\\t\\t}\\n\\t\\t// This way we avoid copying the strings in the last step\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n```\\nvector<vector<string>> groupAnagrams(vector<string>& strs) {\\n    unordered_map<uint32_t, size_t> mapping;\\n    vector<vector<string>> ans;\\n    \\n    // Optional: Not mandatory anymore, but still helps with performance\\n    ans.reserve(strs.size());\\n    \\n    // Optional: \\n    //   Empirically, reserving 1/4th of the number of words \\n    //   gives the best performance\\n    mapping.reserve(strs.size() / 4);\\n    \\n    for (string word : strs) {\\n        uint32_t h = hash(word);\\n        \\n        auto search = mapping.find(h);\\n        if (search == mapping.end()) {\\n            // Create a new bucket for this new anagram\\n            vector<string> v { word };\\n            ans.push_back(std::move(v));\\n            \\n            // Store the corresponding vector index for this group\\n            mapping[h] = ans.size() - 1;\\n        } else {\\n            size_t index = mapping[h];\\n            ans[index].push_back(word);\\n        }\\n        // This way we avoid copying the strings in the last step\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155441,
                "title": "rust-hashmap-solution-simple",
                "content": "```rs\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut h = HashMap::new();\\n        \\n        for s in strs {\\n            let mut key: Vec<char> = s.chars().collect();\\n            key.sort();\\n            h.entry(key).or_insert(vec![]).push(s);\\n        }\\n        \\n        h.values().cloned().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut h = HashMap::new();\\n        \\n        for s in strs {\\n            let mut key: Vec<char> = s.chars().collect();\\n            key.sort();\\n            h.entry(key).or_insert(vec![]).push(s);\\n        }\\n        \\n        h.values().cloned().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399196,
                "title": "easy-simple-concise-98-faster-well-explained",
                "content": "## IDEA :\\n* The main idea is to make the different groups for every different anagrams.\\n* Since Anagrams means to have same letters with different meanings.\\n* We can use the idea of sort to arrange them in group.\\n* Sorted word of Every Anagram words will be same.\\n****\\nEg: [\"tea\",\"eat\",\"ate] will have sorted word as **\"aet\"**. \\nHere \"aet\" can be key of dictionary and all others as values.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic=defaultdict(list)\\n        for s in strs:\\n            dic[\\'\\'.join(sorted(s))].append(s)\\n        \\n        return dic.values()\\n\\n****\\nThanks and support if you got helpful!! \\uD83E\\uDD17\\nPlease **Upvote** and feel free to ask if you have any doubt. \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA :\\n* The main idea is to make the different groups for every different anagrams.\\n* Since Anagrams means to have same letters with different meanings.\\n* We can use the idea of sort to arrange them in group.\\n* Sorted word of Every Anagram words will be same.\\n****\\nEg: [\"tea\",\"eat\",\"ate] will have sorted word as **\"aet\"**. \\nHere \"aet\" can be key of dictionary and all others as values.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic=defaultdict(list)\\n        for s in strs:\\n            dic[\\'\\'.join(sorted(s))].append(s)\\n        \\n        return dic.values()\\n\\n****\\nThanks and support if you got helpful!! \\uD83E\\uDD17\\nPlease **Upvote** and feel free to ask if you have any doubt. \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1340493,
                "title": "c-simple-short-and-easy-solution-o-nm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = word;\\n            sort(tmp_sorted.begin(), tmp_sorted.end());\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**Faster solution, using Counting Sort, Time Complexity: O(nm)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = countSort(word);\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string countSort(string word) {\\n        vector<int> count(26);\\n        string res;\\n        \\n        for (auto ch : word) count[ch - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) res += string(count[i], i+\\'a\\');\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = word;\\n            sort(tmp_sorted.begin(), tmp_sorted.end());\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> m;\\n        string tmp_sorted;\\n        \\n        for (auto word : strs) {\\n            tmp_sorted = countSort(word);\\n            m[tmp_sorted].push_back(word);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for (auto [word, list] : m) {\\n            res.push_back(list);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    string countSort(string word) {\\n        vector<int> count(26);\\n        string res;\\n        \\n        for (auto ch : word) count[ch - \\'a\\']++;\\n        for (int i = 0; i < 26; i++) res += string(count[i], i+\\'a\\');\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688150,
                "title": "5-line-js-solution-easy-to-understand",
                "content": "```javascript\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let mappings = {};\\n    \\n    for(let word of strs) {\\n        // this will convert \\'eat\\' into \\'e\\',\\'a\\',\\'t\\' and then sort it to \\'a\\',\\'e\\',\\'t\\' and then join to \\'ate\\'\\n        // we do this so the sorted anagram key will always be the same. Other related anagrams will have the same key\\n        const anagramGroup = word.split(\"\").sort().join(\"\");\\n        \\n        // if we have a mapping that exists for the anagram group, push the item to that group, \\n        // else create a new array and append the word\\n        mappings[anagramGroup] ? mappings[anagramGroup].push(word) : mappings[anagramGroup] = [word];\\n    }\\n    // returns all the mappings as a unified array.\\n    return Object.values(mappings);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {\\n    let mappings = {};\\n    \\n    for(let word of strs) {\\n        // this will convert \\'eat\\' into \\'e\\',\\'a\\',\\'t\\' and then sort it to \\'a\\',\\'e\\',\\'t\\' and then join to \\'ate\\'\\n        // we do this so the sorted anagram key will always be the same. Other related anagrams will have the same key\\n        const anagramGroup = word.split(\"\").sort().join(\"\");\\n        \\n        // if we have a mapping that exists for the anagram group, push the item to that group, \\n        // else create a new array and append the word\\n        mappings[anagramGroup] ? mappings[anagramGroup].push(word) : mappings[anagramGroup] = [word];\\n    }\\n    // returns all the mappings as a unified array.\\n    return Object.values(mappings);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19338,
                "title": "sorting-python-solution-beats-100",
                "content": "Nothing fancy, just a straightforward solution using a dictionary.\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        anas = {}\\n        for string in strs:\\n            s = ''.join(sorted(string))\\n            if s in anas:\\n                anas[s].append(string)\\n            else:\\n                anas[s] = [string]\\n        return [ anas[x] for x in anas ]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        anas = {}\\n        for string in strs:\\n            s = ''.join(sorted(string))\\n            if s in anas:\\n                anas[s].append(string)\\n            else:\\n                anas[s] = [string]\\n        return [ anas[x] for x in anas ]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 19329,
                "title": "simple-java-solution",
                "content": "\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\t\\tList<List<String>> res = new ArrayList<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        Arrays.sort(strs);\\n        for (int i = 0; i < strs.length; i++) {\\n        \\tString temp = strs[i];\\n        \\tchar[] ch = temp.toCharArray();\\n        \\tArrays.sort(ch);\\n        \\tif (map.containsKey(String.valueOf(ch))) {\\n        \\t\\tmap.get(String.valueOf(ch)).add(strs[i]);\\n        \\t} else {\\n        \\t\\tList<String> each = new ArrayList<>();\\n        \\t\\teach.add(strs[i]);\\n        \\t\\tmap.put(String.valueOf(ch), each);\\n        \\t}\\n        }\\n        for (List<String> item: map.values()) {\\n        \\tres.add(item);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\t\\tList<List<String>> res = new ArrayList<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        Arrays.sort(strs);\\n        for (int i = 0; i < strs.length; i++) {\\n        \\tString temp = strs[i];\\n        \\tchar[] ch = temp.toCharArray();\\n        \\tArrays.sort(ch);\\n        \\tif (map.containsKey(String.valueOf(ch))) {\\n        \\t\\tmap.get(String.valueOf(ch)).add(strs[i]);\\n        \\t} else {\\n        \\t\\tList<String> each = new ArrayList<>();\\n        \\t\\teach.add(strs[i]);\\n        \\t\\tmap.put(String.valueOf(ch), each);\\n        \\t}\\n        }\\n        for (List<String> item: map.values()) {\\n        \\tres.add(item);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1663675,
                "title": "solution-swift-group-anagrams-test-cases",
                "content": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict: [[Character]:[String]] = [:]\\n        for c in strs {\\n            let abc = c.sorted()\\n            dict[abc] == nil ? (dict[abc] = [c]) : (dict[abc]?.append(c))\\n        }\\n        return dict.map({$1})\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.022 (0.024) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\\n        let expected = [[\"nat\",\"tan\"],[\"bat\"],[\"ate\",\"eat\",\"tea\"]]\\n        XCTAssertEqual(value.count, expected.count)\\n        XCTAssertEqual(value.count, 3)\\n        value.forEach {\\n            XCTAssertTrue(expected.contains($0.sorted()))\\n        }\\n    }\\n    func test1() {\\n        let value = solution.groupAnagrams([\"\"])\\n        XCTAssertEqual(value, [[\"\"]])\\n    }\\n    func test2() {\\n        let value = solution.groupAnagrams([\"a\"])\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var dict: [[Character]:[String]] = [:]\\n        for c in strs {\\n            let abc = c.sorted()\\n            dict[abc] == nil ? (dict[abc] = [c]) : (dict[abc]?.append(c))\\n        }\\n        return dict.map({$1})\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"])\\n        let expected = [[\"nat\",\"tan\"],[\"bat\"],[\"ate\",\"eat\",\"tea\"]]\\n        XCTAssertEqual(value.count, expected.count)\\n        XCTAssertEqual(value.count, 3)\\n        value.forEach {\\n            XCTAssertTrue(expected.contains($0.sorted()))\\n        }\\n    }\\n    func test1() {\\n        let value = solution.groupAnagrams([\"\"])\\n        XCTAssertEqual(value, [[\"\"]])\\n    }\\n    func test2() {\\n        let value = solution.groupAnagrams([\"a\"])\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551701,
                "title": "java-tc-o-totalchars-n-sc-o-n-group-by-signature-of-each-string",
                "content": "```java\\n/**\\n * Categorize by Count of characters\\n *\\n * Time Complexity:\\n * - O(TotalChars + 26*11*2*N) -> To calculate the count of characters and create the signature using StringBuilder.\\n * - O(N) -> to generate final result List of groups.\\n * Total Time Complexity = O(TotalChars + N)\\n *\\n * Space Complexity:\\n * - O(26*11*N) -> To save signatures in HashMap.\\n *                 We do not need to count the space required for values in HashMap as they will be used in result.\\n * Total Space Complexity = O(N)\\n *\\n * N = Number of strings in strs array.\\n */\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n            groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n/**\\n * Categorize by Count of characters\\n *\\n * Time Complexity:\\n * - O(TotalChars + 26*11*2*N) -> To calculate the count of characters and create the signature using StringBuilder.\\n * - O(N) -> to generate final result List of groups.\\n * Total Time Complexity = O(TotalChars + N)\\n *\\n * Space Complexity:\\n * - O(26*11*N) -> To save signatures in HashMap.\\n *                 We do not need to count the space required for values in HashMap as they will be used in result.\\n * Total Space Complexity = O(N)\\n *\\n * N = Number of strings in strs array.\\n */\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (strs == null || strs.length == 0) {\\n            return result;\\n        }\\n        if (strs.length == 1) {\\n            result.add(Arrays.asList(strs));\\n            return result;\\n        }\\n\\n        HashMap<String, List<String>> groups = new HashMap<>();\\n        for (String s : strs) {\\n            String signature = getSignature(s);\\n            groups.putIfAbsent(signature, new ArrayList<>());\\n            groups.get(signature).add(s);\\n        }\\n\\n        return new ArrayList<>(groups.values());\\n    }\\n\\n    private String getSignature(String s) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0) {\\n                sb.append((char) (\\'a\\' + i)).append(count[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19441,
                "title": "simple-javascript-solution",
                "content": "    var groupAnagrams = function(strs) {\\n        strs = strs.sort();\\n        var mapping = {};\\n        for (var i = 0; i < strs.length; i++) {\\n            var str = strs[i];\\n            var sorted = str.split('').sort().join('');\\n            \\n            if (mapping[sorted] === undefined) {\\n                mapping[sorted] = [str];\\n            } else {\\n                mapping[sorted].push(str);\\n            }\\n        }\\n        \\n        var output = [];\\n        for (var arr in mapping) {\\n            output.push(mapping[arr]);\\n        }\\n        \\n        return output;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var groupAnagrams = function(strs) {\\n        strs = strs.sort();\\n        var mapping = {};\\n        for (var i = 0; i < strs.length; i++) {\\n            var str = strs[i];\\n            var sorted = str.split('').sort().join('');\\n            \\n            if (mapping[sorted] === undefined) {\\n                mapping[sorted] = [str];\\n            } else {\\n                mapping[sorted].push(str);\\n            }\\n        }\\n        \\n        var output = [];\\n        for (var arr in mapping) {\\n            output.push(mapping[arr]);\\n        }\\n        \\n        return output;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 4055371,
                "title": "java-using-a-map-sorting-beats-98-95",
                "content": "# Intuition\\nThis problem is about grouping words that are anagrams of each other. An anagram is a word formed by rearranging the letters of another word.\\n\\n\\n# Approach\\nWe use a HashMap to efficiently group anagrams. The key is the sorted version of a word, and the value is a list of anagrams.\\n- We initialize an empty list called `result` to store the grouped anagrams.\\n- First, we check if the input `strs` is empty or null. If it is, we return an empty result.\\n- If `strs` contains only one word, we wrap it in a list and return it because there are no other words to group.\\n- We then go through each word in the `strs` array.\\n  - We convert each word into a character array (`charArray`).\\n  - We sort the character array, creating the sorted version of the word (`sortedWord`).\\n  - If `map` does not contain `sortedWord` as a key, we initialize an empty list for that key.\\n  - We add the word to the list corresponding to `sortedWord`.\\n- After processing all words, we have grouped the anagrams inside the `map`.\\n- We extract the lists of anagrams from the `map` values and add them to the `result` list.\\n- Finally, we return the grouped anagrams as the result.\\n\\n# Complexity\\n- Time complexity: O(N * K * log(K))\\n  - N represents the number of words in the `strs` array.\\n  - K represents the maximum length of a word.\\n  - The algorithm iterates through each word (N operations), sorts each word (K * log(K) time complexity), and performs constant-time operations. The dominant factor is the sorting step, resulting in a time complexity of O(N * K * log(K)).\\n\\n- Space complexity: O(N * K)\\n  - The algorithm uses a HashMap to store sorted words as keys and lists of anagrams as values. In the worst case, assuming each word is unique and has a length of K, the space complexity is O(N * K).\\n\\n\\n# Code\\n```\\nclass Solution {\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\n        List<List<String>> result = new ArrayList<>();\\n\\n\\n        for (String word: strs\\n        ) {\\n            char[] charArray = word.toCharArray();\\n\\n\\n            Arrays.sort(charArray);\\n\\n            String sortedWord = String.valueOf(charArray);\\n\\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n\\n\\n            map.get(sortedWord).add(word);\\n\\n\\n        }\\n        result.addAll(map.values());\\n\\n        return result;\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/4bcbbb97-7806-4680-af9a-63b251d79b5e_1694947233.8470142.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\n        List<List<String>> result = new ArrayList<>();\\n\\n\\n        for (String word: strs\\n        ) {\\n            char[] charArray = word.toCharArray();\\n\\n\\n            Arrays.sort(charArray);\\n\\n            String sortedWord = String.valueOf(charArray);\\n\\n            if (!map.containsKey(sortedWord)) {\\n                map.put(sortedWord, new ArrayList<>());\\n            }\\n\\n\\n            map.get(sortedWord).add(word);\\n\\n\\n        }\\n        result.addAll(map.values());\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665489,
                "title": "python-clean-with-dictionary",
                "content": "\\n```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        anagrams = {}\\n        for word in strs:\\n            sortedWord = \"\".join(sorted(word))\\n            if sortedWord in anagrams:\\n                anagrams[sortedWord].append(word)\\n            else:\\n                anagrams[sortedWord] = [word]\\n        return list(anagrams.values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        anagrams = {}\\n        for word in strs:\\n            sortedWord = \"\".join(sorted(word))\\n            if sortedWord in anagrams:\\n                anagrams[sortedWord].append(word)\\n            else:\\n                anagrams[sortedWord] = [word]\\n        return list(anagrams.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1334481,
                "title": "c-easy-to-understand-fast-and-efficient-code-using-hashtables",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string> > mp;\\n        string t;\\n        for(int i=0;i<strs.size();i++)\\n        {\\n             t=strs[i];\\n             sort(t.begin(),t.end());\\n             mp[t].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto pr:mp)\\n        {\\n            ans.push_back(pr.second);\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string> > mp;\\n        string t;\\n        for(int i=0;i<strs.size();i++)\\n        {\\n             t=strs[i];\\n             sort(t.begin(),t.end());\\n             mp[t].push_back(strs[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1083044,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs == null || strs.Length == 0)\\n            return new List<IList<string>>();\\n        \\n        List<IList<string>> res = new List<IList<string>>();\\n        Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\\n        \\n        foreach (var str in strs)\\n        {\\n            string cur = new string(str.OrderBy(x => x).ToArray());\\n            \\n            if (!dict.ContainsKey(cur))\\n                dict.Add(cur, new List<string>());\\n            \\n            dict[cur].Add(str);\\n        }\\n        \\n        foreach (var item in dict.Values)\\n            res.Add(item);\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs == null || strs.Length == 0)\\n            return new List<IList<string>>();\\n        \\n        List<IList<string>> res = new List<IList<string>>();\\n        Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\\n        \\n        foreach (var str in strs)\\n        {\\n            string cur = new string(str.OrderBy(x => x).ToArray());\\n            \\n            if (!dict.ContainsKey(cur))\\n                dict.Add(cur, new List<string>());\\n            \\n            dict[cur].Add(str);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3421522,
                "title": "c-optimized-o-nk-without-sorting-map-of-map-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmap of map technique. map inside map. the inner map should be of size 26.  (O(nk))\\n\\n`map<map<char,int>,vector<string>> mp`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nk)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        vector<vector<string>> ans;\\n\\n        map<map<char,int>, vector<string>> mp;\\n        int n = strs.size();\\n        string temp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            map<char,int> temp;\\n            for(char c:strs[i]){\\n                temp[c]++;\\n            }\\n\\n            mp[temp].push_back(strs[i]);\\n        }\\n\\n\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            ans.push_back(itr->second);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        vector<vector<string>> ans;\\n\\n        map<map<char,int>, vector<string>> mp;\\n        int n = strs.size();\\n        string temp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            map<char,int> temp;\\n            for(char c:strs[i]){\\n                temp[c]++;\\n            }\\n\\n            mp[temp].push_back(strs[i]);\\n        }\\n\\n\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            ans.push_back(itr->second);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750624,
                "title": "fastest-solution-possible-short-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for a in(strs):\\n            t=list(a)\\n            t.sort()\\n            t=\"\".join(t)\\n            if(t in dic):\\n                dic[t].append(a)\\n            else:\\n                dic[t]=[a]\\n        ans=[]\\n        for a in dic:\\n            ans.append(dic[a])\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic={}\\n        for a in(strs):\\n            t=list(a)\\n            t.sort()\\n            t=\"\".join(t)\\n            if(t in dic):\\n                dic[t].append(a)\\n            else:\\n                dic[t]=[a]\\n        ans=[]\\n        for a in dic:\\n            ans.append(dic[a])\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909435,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521631,
                "title": "in-c-what-a-pain",
                "content": "```\\nstruct word {\\n    char sorted[256];\\n    char s[256];\\n    UT_hash_handle hh;\\n};\\n\\nint comp(const void *aa, const void *bb)\\n{\\n    char a, b;\\n    a = *(char *)aa;\\n    b = *(char *)bb;\\n    \\n    if (a < b)\\n        return -1;\\n    else if (a > b)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nchar *sort_string(char *s)\\n{\\n    char *rs = malloc(strlen(s)+1);\\n    assert(rs);\\n    strcpy(rs, s);\\n    qsort((void *)rs, strlen(rs), 1, comp);\\n    return rs;\\n}\\n\\nint word_sort(struct word *a, struct word *b) {\\n    return strcmp(a->sorted,b->sorted);\\n}\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\\n    struct word *w, *tmp;\\n    int i;\\n    struct word *words = NULL;\\n    \\n    for (i = 0; i < strsSize; i++) {\\n        char *sorted = sort_string(strs[i]);\\n        w = (struct word *)malloc(sizeof *w);\\n        strncpy(w->sorted, sorted, 256);\\n        strncpy(w->s, strs[i], 256);\\n        HASH_ADD_STR( words, sorted, w );\\n        free(sorted);\\n    }\\n    \\n    char ***ret = malloc(strsSize * sizeof(char *));\\n    int *retcolsizes = malloc(strsSize * sizeof(int));\\n    *returnColumnSizes = retcolsizes;\\n    assert(*returnColumnSizes);\\n    assert(ret);\\n    \\n    *returnSize = -1;\\n    char *anagram = NULL;\\n    \\n    /* XXX: what we would like is something like (python):\\n     *      return dic.values();\\n     * I know its C, but there has to be a better way.\\n     */\\n    HASH_SORT(words, word_sort);\\n    HASH_ITER(hh, words, w, tmp) {\\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n        } else {\\n            *returnSize += 1;\\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\\n            assert(ret[*returnSize]);\\n            retcolsizes[*returnSize] = 0;\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n            anagram = w->sorted;\\n        }\\n    }\\n    \\n    /* XXX: we are leaking a bunch of memory for the struct word\\'s*/\\n    *returnSize += 1;\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct word {\\n    char sorted[256];\\n    char s[256];\\n    UT_hash_handle hh;\\n};\\n\\nint comp(const void *aa, const void *bb)\\n{\\n    char a, b;\\n    a = *(char *)aa;\\n    b = *(char *)bb;\\n    \\n    if (a < b)\\n        return -1;\\n    else if (a > b)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nchar *sort_string(char *s)\\n{\\n    char *rs = malloc(strlen(s)+1);\\n    assert(rs);\\n    strcpy(rs, s);\\n    qsort((void *)rs, strlen(rs), 1, comp);\\n    return rs;\\n}\\n\\nint word_sort(struct word *a, struct word *b) {\\n    return strcmp(a->sorted,b->sorted);\\n}\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nchar *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){\\n    struct word *w, *tmp;\\n    int i;\\n    struct word *words = NULL;\\n    \\n    for (i = 0; i < strsSize; i++) {\\n        char *sorted = sort_string(strs[i]);\\n        w = (struct word *)malloc(sizeof *w);\\n        strncpy(w->sorted, sorted, 256);\\n        strncpy(w->s, strs[i], 256);\\n        HASH_ADD_STR( words, sorted, w );\\n        free(sorted);\\n    }\\n    \\n    char ***ret = malloc(strsSize * sizeof(char *));\\n    int *retcolsizes = malloc(strsSize * sizeof(int));\\n    *returnColumnSizes = retcolsizes;\\n    assert(*returnColumnSizes);\\n    assert(ret);\\n    \\n    *returnSize = -1;\\n    char *anagram = NULL;\\n    \\n    /* XXX: what we would like is something like (python):\\n     *      return dic.values();\\n     * I know its C, but there has to be a better way.\\n     */\\n    HASH_SORT(words, word_sort);\\n    HASH_ITER(hh, words, w, tmp) {\\n        if (anagram != NULL && strcmp(w->sorted, anagram) == 0) {\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n        } else {\\n            *returnSize += 1;\\n            ret[*returnSize] = malloc(strsSize * sizeof(char *));\\n            assert(ret[*returnSize]);\\n            retcolsizes[*returnSize] = 0;\\n            ret[*returnSize][retcolsizes[*returnSize]] = w->s; // was malloc\\'ed\\n            retcolsizes[*returnSize] += 1;\\n            anagram = w->sorted;\\n        }\\n    }\\n    \\n    /* XXX: we are leaking a bunch of memory for the struct word\\'s*/\\n    *returnSize += 1;\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235518,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {  \\n    const m = new Map();\\n    \\n    for(const s of strs) {\\n        const keys = Array(26).fill(0);\\n        for(const c of s){\\n            ++keys[c.charCodeAt(0) - 97]\\n        }\\n        const key = keys.join(\"#\");\\n        let val = [];\\n        if(m.has(key)) {\\n            val = m.get(key)\\n        }  \\n        val.push(s);\\n        m.set(key, val);\\n    }\\n \\n    return Array.from(m.values());\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function(strs) {  \\n    const m = new Map();\\n    \\n    for(const s of strs) {\\n        const keys = Array(26).fill(0);\\n        for(const c of s){\\n            ++keys[c.charCodeAt(0) - 97]\\n        }\\n        const key = keys.join(\"#\");\\n        let val = [];\\n        if(m.has(key)) {\\n            val = m.get(key)\\n        }  \\n        val.push(s);\\n        m.set(key, val);\\n    }\\n \\n    return Array.from(m.values());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043475,
                "title": "java-easy-to-understand-very-easy-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs){\\n        List<List<String>>s=new ArrayList<>();\\n        Map<String,List<String>>map=new LinkedHashMap<>();\\n        \\n        for(String e:strs){\\n            char ch[]=e.toCharArray();\\n            Arrays.sort(ch);\\n            String str=new String(ch);\\n            \\n            if(!map.containsKey(str)){\\n                map.put(str,new ArrayList<>());\\n            }\\n            map.get(str).add(e);\\n        }\\n        s.addAll(map.values());\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs){\\n        List<List<String>>s=new ArrayList<>();\\n        Map<String,List<String>>map=new LinkedHashMap<>();\\n        \\n        for(String e:strs){\\n            char ch[]=e.toCharArray();\\n            Arrays.sort(ch);\\n            String str=new String(ch);\\n            \\n            if(!map.containsKey(str)){\\n                map.put(str,new ArrayList<>());\\n            }\\n            map.get(str).add(e);\\n        }\\n        s.addAll(map.values());\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750714,
                "title": "java-solution-using-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] str) {\\n        int n=str.length;\\n        HashMap<String,ArrayList<String>> hm=new HashMap<>();\\n        List<List<String>> list=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            char [] ch=str[i].toCharArray();\\n            Arrays.sort(ch);\\n            String temp=new String(ch);\\n            if(hm.containsKey(temp)){\\n                hm.get(temp).add(str[i]);\\n            }\\n            else{\\n                ArrayList<String> t=new ArrayList<>();\\n                t.add(str[i]);\\n                hm.put(temp,t);\\n            }\\n        }\\n        \\n        for(String key:hm.keySet()){\\n            list.add(hm.get(key));\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] str) {\\n        int n=str.length;\\n        HashMap<String,ArrayList<String>> hm=new HashMap<>();\\n        List<List<String>> list=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            char [] ch=str[i].toCharArray();\\n            Arrays.sort(ch);\\n            String temp=new String(ch);\\n            if(hm.containsKey(temp)){\\n                hm.get(temp).add(str[i]);\\n            }\\n            else{\\n                ArrayList<String> t=new ArrayList<>();\\n                t.add(str[i]);\\n                hm.put(temp,t);\\n            }\\n        }\\n        \\n        for(String key:hm.keySet()){\\n            list.add(hm.get(key));\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190927,
                "title": "c-very-simple-solution",
                "content": "\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n            Dictionary<string, IList<string>> dic = new Dictionary<string, IList<string>>();\\n            for (int i = 0; i < strs.Length; i++)\\n            {\\n                char[] arr=strs[i].ToCharArray();\\n                Array.Sort(arr);\\n                string sorted=new string(arr);\\n                if(dic.ContainsKey(sorted))\\n                {\\n                    dic[sorted].Add(strs[i]);\\n                }\\n                else\\n                {\\n                    dic.Add(sorted, new List<string>() {strs[i]});\\n                }\\n            }\\n            var result= dic.Values.ToList();\\n            return result;        \\n    }",
                "solutionTags": [
                    "C#"
                ],
                "code": "\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n            Dictionary<string, IList<string>> dic = new Dictionary<string, IList<string>>();\\n            for (int i = 0; i < strs.Length; i++)\\n            {\\n                char[] arr=strs[i].ToCharArray();\\n                Array.Sort(arr);\\n                string sorted=new string(arr);\\n                if(dic.ContainsKey(sorted))\\n                {\\n                    dic[sorted].Add(strs[i]);\\n                }\\n                else\\n                {\\n                    dic.Add(sorted, new List<string>() {strs[i]});\\n                }\\n            }\\n            var result= dic.Values.ToList();\\n            return result;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1362905,
                "title": "javascript",
                "content": "*Runtime*: **136 ms**, faster than **67.24%** of JavaScript online submissions for Group Anagrams.\\n*Memory Usage*:** 49.7 MB**, less than **71.58%** of JavaScript online submissions for Group Anagrams.\\n\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nconst groupAnagrams = function(strs) {\\n    let groups = {}\\n    strs.forEach(str => {\\n        const sortedStr = str.split(\\'\\').sort().join(\\'\\')\\n        if (groups[sortedStr]) {\\n            groups[sortedStr].push(str)\\n        } else {\\n            groups[sortedStr] = [str]\\n        }\\n    })\\n    return Object.values(groups)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nconst groupAnagrams = function(strs) {\\n    let groups = {}\\n    strs.forEach(str => {\\n        const sortedStr = str.split(\\'\\').sort().join(\\'\\')\\n        if (groups[sortedStr]) {\\n            groups[sortedStr].push(str)\\n        } else {\\n            groups[sortedStr] = [str]\\n        }\\n    })\\n    return Object.values(groups)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436097,
                "title": "concise-go-golang-solution",
                "content": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    hm := make(map[string][]string)\\n    for _, w := range strs {\\n        key := sortString(w)\\n        hm[key] = append(hm[key], w)\\n    }\\n    \\n    var ans [][]string\\n    for _, words := range hm {\\n        ans = append(ans, words)\\n    }\\n    return ans\\n}\\n\\nfunc sortString(str string) string {\\n    runes := []rune(str)\\n    sort.Slice(runes, func(a, b int) bool {\\n        return runes[a] < runes[b]\\n    })\\n    return string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    hm := make(map[string][]string)\\n    for _, w := range strs {\\n        key := sortString(w)\\n        hm[key] = append(hm[key], w)\\n    }\\n    \\n    var ans [][]string\\n    for _, words := range hm {\\n        ans = append(ans, words)\\n    }\\n    return ans\\n}\\n\\nfunc sortString(str string) string {\\n    runes := []rune(str)\\n    sort.Slice(runes, func(a, b int) bool {\\n        return runes[a] < runes[b]\\n    })\\n    return string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267058,
                "title": "straightforward-python3-solution",
                "content": "```\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dict = {}        \\n        for str in strs:\\n            key_str = \\'\\'.join(sorted(str))\\n            if key_str in dict:\\n                dict[key_str].append(str)                \\n            else:\\n                dict[key_str] = [str]\\n\\n        return list(dict.values())\\n```",
                "solutionTags": [],
                "code": "```\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dict = {}        \\n        for str in strs:\\n            key_str = \\'\\'.join(sorted(str))\\n            if key_str in dict:\\n                dict[key_str].append(str)                \\n            else:\\n                dict[key_str] = [str]\\n\\n        return list(dict.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3579337,
                "title": "fastest-way-to-solve-this-question-beats-97-36",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires grouping anagrams together in a given array of strings. Two strings are considered anagrams if they have the same characters, but in a different order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an empty hash map, map, to store the grouped anagrams.\\n\\n2. Iterate through each string, str, in the input array strs:\\n\\n3. Convert str into a character array, chars.\\n\\n4. Sort chars in non-decreasing order.\\n\\n5. Convert chars back to a string, sortedStr.\\n\\n6. If sortedStr is not present in map, add it as a new key with an empty list as the value.\\n\\n7. Append str to the list associated with sortedStr in map.\\n\\n8. Return a new ArrayList containing all the values (lists of anagrams) from map.\\n\\n# Complexity\\n- Time complexity:O(n * m * log m), where n is the number of strings in the input array and m is the maximum length of a string. Sorting each string takes O(m * log m) time, and we do this for each of the n strings.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m), the space used by the hash map map and the returned ArrayList, where n is the number of strings and m is the maximum length of a string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs.length == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String i : strs) {\\n            char[] chars = i.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedStr = String.valueOf(chars);\\n            \\n            if (!map.containsKey(sortedStr)) {\\n                map.put(sortedStr, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedStr).add(i);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        if (strs.length == 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        for (String i : strs) {\\n            char[] chars = i.toCharArray();\\n            Arrays.sort(chars);\\n            String sortedStr = String.valueOf(chars);\\n            \\n            if (!map.containsKey(sortedStr)) {\\n                map.put(sortedStr, new ArrayList<>());\\n            }\\n            \\n            map.get(sortedStr).add(i);\\n        }\\n        \\n        return new ArrayList<>(map.values());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753997,
                "title": "js-ts-solution-hashing-fast-simple-intuitive",
                "content": "# Code\\n```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n    let map = new Map<string, string[]>();\\n    for (let s of strs) {\\n        let charFreq = Array.from({ length: 26 }, () => 0);\\n        for (let i = 0; i < s.length; i++)charFreq[s.charCodeAt(i) - 97]++;\\n        let keyStr = charFreq.toString();\\n        if (!map.has(keyStr)) map.set(keyStr, []);\\n        map.get(keyStr).push(s);\\n    }\\n    return Array.from(map.values());\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n    let map = new Map<string, string[]>();\\n    for (let s of strs) {\\n        let charFreq = Array.from({ length: 26 }, () => 0);\\n        for (let i = 0; i < s.length; i++)charFreq[s.charCodeAt(i) - 97]++;\\n        let keyStr = charFreq.toString();\\n        if (!map.has(keyStr)) map.set(keyStr, []);\\n        map.get(keyStr).push(s);\\n    }\\n    return Array.from(map.values());\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750765,
                "title": "python3-5-lines-w-example-t-m-98-99",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\\n        \\n        anadict = defaultdict(list)     # Ex: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]                     \\n        \\n        for s in strs:                  #  s   ana  anadict   \\n            ana = \\'\\'.join(sorted(s))    # \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n            anadict[ana].append(s)      # eat  aet  {\\'aet\\': [\\'eat\\']}\\n                                        # tea  aet  {\\'aet\\': [\\'eat\\', \\'tea\\']}\\n                                        # tan  ant  {\\'aet\\': [\\'eat\\', \\'tea\\'], \\'ant\\': [\\'tan\\']}\\n                                        # ate  aet  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\']}\\n                                        # nat  ant  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\']}\\n                                        # bat  abt  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\'], \\'abt\\': [\\'bat\\']}\\n\\n        return list(anadict.values())   # [[\\'eat\\', \\'tea\\', \\'ate\\'], [\\'tan\\', \\'nat\\'], [\\'bat\\']]\\n```\\n\\n[https://leetcode.com/submissions/detail/583502656/](http://)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\\n        \\n        anadict = defaultdict(list)     # Ex: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]                     \\n        \\n        for s in strs:                  #  s   ana  anadict   \\n            ana = \\'\\'.join(sorted(s))    # \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n            anadict[ana].append(s)      # eat  aet  {\\'aet\\': [\\'eat\\']}\\n                                        # tea  aet  {\\'aet\\': [\\'eat\\', \\'tea\\']}\\n                                        # tan  ant  {\\'aet\\': [\\'eat\\', \\'tea\\'], \\'ant\\': [\\'tan\\']}\\n                                        # ate  aet  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\']}\\n                                        # nat  ant  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\']}\\n                                        # bat  abt  {\\'aet\\': [\\'eat\\', \\'tea\\', \\'ate\\'], \\'ant\\': [\\'tan\\', \\'nat\\'], \\'abt\\': [\\'bat\\']}\\n\\n        return list(anadict.values())   # [[\\'eat\\', \\'tea\\', \\'ate\\'], [\\'tan\\', \\'nat\\'], [\\'bat\\']]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595584,
                "title": "solution",
                "content": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<vector<string> > Anagrams(vector<string>& str) {\\n        vector<vector<string>> ans;\\n        unordered_map<string,vector<string>> mp;\\n        \\n        for(auto x: str)\\n        {\\n            string temp = x;\\n            sort(x.begin(),x.end());\\n            mp[x].push_back(temp);\\n        }\\n        for(auto x: mp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n    \\n    // for this example the map will be\\n    // example:- N = 5\\n    // words[] = {act,god,cat,dog,tac}\\n    \\n    // The map will be:- \\n    // string     vector<string>\\n    // act        cat tac\\n    // god        dog\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 19264,
                "title": "map-lambda-list-comprehension-3-lines-of-python",
                "content": "    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        map(lambda item: dic[''.join(sorted(item))].append(item), strs)\\n        return [x for key in dic.keys() for x in dic[key] if len(dic[key]) > 1]\\n\\nEquivalent to:\\n\\n    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        for item in strs:\\n            after = ''.join(sorted(item))\\n            dic[after].append(item)\\n        ans = []\\n        for item in dic:\\n            values = dic[item]\\n            if len(values) > 1:\\n                ans.extend(values)\\n        return ans",
                "solutionTags": [],
                "code": "    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        map(lambda item: dic[''.join(sorted(item))].append(item), strs)\\n        return [x for key in dic.keys() for x in dic[key] if len(dic[key]) > 1]\\n\\nEquivalent to:\\n\\n    def anagrams(self, strs):\\n        dic = defaultdict(list)\\n        for item in strs:\\n            after = ''.join(sorted(item))\\n            dic[after].append(item)\\n        ans = []\\n        for item in dic:\\n            values = dic[item]\\n            if len(values) > 1:\\n                ans.extend(values)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 4006990,
                "title": "three-simple-java-solutions-runtime-5ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# code1\\nRuntime 5ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char chars[] = s.toCharArray();\\n            Arrays.sort(chars);\\n            String s2 = new String(chars);\\n            \\n            List<String> arr = hashmap.computeIfAbsent(s2, key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        return new ArrayList<>(hashmap.values());\\n    }\\n}\\n```\\n\\n# Code2\\nRuntime 9ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        List<List<String>> list = new LinkedList<>();\\n\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char c1[] = s.toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1)\\n            {\\n                s2.append(c);\\n            }\\n            List<String> arr = hashmap.computeIfAbsent(s2.toString(), key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        for(Map.Entry<String, ArrayList<String>> entry : hashmap.entrySet()) {\\n            List<String> l1 = new LinkedList<>();\\n            for (String s : entry.getValue()){\\n                l1.add(s);\\n            }\\n            list.add(l1);\\n        }\\n\\n        return list;\\n    }\\n}\\n\\n```\\n\\n\\n# code3\\nRuntime 670ms\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n      List<List<String>> list = new LinkedList<>();\\n\\n        ArrayList<String> str1 = new ArrayList<>(strs.length);\\n\\n        for (int i = 0 ; i < strs.length ; i++)\\n        {\\n            char c1[] = strs[i].toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1) {\\n                s2.append(c);\\n            }\\n            str1.add(s2.toString());\\n        }\\n\\n        for (int i = 0; i < str1.size() ; i++)\\n        {\\n            List<String> l1 = new LinkedList<>();\\n            String temp = str1.get(i).toString();\\n            if (temp != \"-1\") {\\n                int index = i;\\n                while (index != -1) {\\n                    str1.set(index, \"-1\");\\n                    l1.add(strs[index]);\\n                    index = str1.indexOf(temp);\\n                }\\n\\n                list.add(l1);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/54abaa5f-db31-440b-9104-9e18facf6608_1693939907.7778165.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char chars[] = s.toCharArray();\\n            Arrays.sort(chars);\\n            String s2 = new String(chars);\\n            \\n            List<String> arr = hashmap.computeIfAbsent(s2, key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        return new ArrayList<>(hashmap.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n        List<List<String>> list = new LinkedList<>();\\n\\n        HashMap<String , ArrayList<String>> hashmap = new HashMap<>();\\n\\n        for (String s : strs)\\n        {\\n            char c1[] = s.toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1)\\n            {\\n                s2.append(c);\\n            }\\n            List<String> arr = hashmap.computeIfAbsent(s2.toString(), key -> new ArrayList<>());\\n            arr.add(s);\\n        }\\n\\n        for(Map.Entry<String, ArrayList<String>> entry : hashmap.entrySet()) {\\n            List<String> l1 = new LinkedList<>();\\n            for (String s : entry.getValue()){\\n                l1.add(s);\\n            }\\n            list.add(l1);\\n        }\\n\\n        return list;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs)\\n    {\\n      List<List<String>> list = new LinkedList<>();\\n\\n        ArrayList<String> str1 = new ArrayList<>(strs.length);\\n\\n        for (int i = 0 ; i < strs.length ; i++)\\n        {\\n            char c1[] = strs[i].toCharArray();\\n            Arrays.sort(c1);\\n            StringBuilder s2 = new StringBuilder();\\n            for (char c : c1) {\\n                s2.append(c);\\n            }\\n            str1.add(s2.toString());\\n        }\\n\\n        for (int i = 0; i < str1.size() ; i++)\\n        {\\n            List<String> l1 = new LinkedList<>();\\n            String temp = str1.get(i).toString();\\n            if (temp != \"-1\") {\\n                int index = i;\\n                while (index != -1) {\\n                    str1.set(index, \"-1\");\\n                    l1.add(strs[index]);\\n                    index = str1.indexOf(temp);\\n                }\\n\\n                list.add(l1);\\n            }\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566051,
                "title": "anagram-grouping-using-hash-table",
                "content": "# Intuition\\nThis one took a bit of time. I first though about counting characters in individual strings and then lifting them out of the vector one-by-one by matching the character counts. After some trial and error I got that to work but realized that that took too much time, so I needed a new plan. I thought about sorting the characters in the string and then would\\'ve only needed to compare the string, not the characters, but for this method I needed to change the character counting method to a map. This turned out to be very time and space efficient compared to others, being in the top 5% of LeetCode submissions.\\n\\n# Approach\\n1. Create an unordered map called **groups**, where the keys will represent the sorted versions of the anagrams, and the values will be vectors of strings that belong to the same anagram group.\\n2. Iterate through each string in the input vector **strs**.\\n3. For each string, create a copy called **sortedStr** and sort its characters in ascending order using the **sort** function. This step ensures that anagrams have the same sorted representation.\\n4. Use the sorted string **sortedStr** as the key in the **groups** map. If the key doesn\\'t exist in the map, a new entry is automatically created with an empty vector as the value. If the key already exists, the corresponding vector is accessed.\\n5. Push the original unsorted string **str** into the vector associated with the key **sortedStr**. This step groups the anagrams together.\\n6. After iterating through all the strings, create a **vector<vector<string>>** called **result** to store the grouped anagrams.\\n7. Iterate through each key-value pair in the **groups** map. For each pair, access the vector of anagrams (the value) and push it into the **result** vector.\\n8. Return the **result** vector, which contains the anagram groups.\\n\\nThe main idea behind this approach is to use the sorted representation of each string as the key in an unordered map. By grouping the original unsorted strings together based on their sorted versions, you can efficiently group the anagrams. The final result is a vector of vectors, where each inner vector represents a group of anagrams.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N * K log K)$$, where N is the total number of strings in the input vector **strs** and K is the average length of the strings\\n\\n- Space complexity:\\n$$O(N * K)$$, where N is the number of strings and K is the average length of the strings\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> groups;\\n        for (const string& str : strs) {\\n            string sortedStr = str;\\n            sort(sortedStr.begin(), sortedStr.end());\\n            groups[sortedStr].push_back(str);\\n        }\\n\\n        vector<vector<string>> result;\\n        for (const auto& pair : groups) {\\n            result.push_back(pair.second);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> groups;\\n        for (const string& str : strs) {\\n            string sortedStr = str;\\n            sort(sortedStr.begin(), sortedStr.end());\\n            groups[sortedStr].push_back(str);\\n        }\\n\\n        vector<vector<string>> result;\\n        for (const auto& pair : groups) {\\n            result.push_back(pair.second);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884408,
                "title": "o-nk-time-o-n-space",
                "content": "# Intuition\\nA couple potential solutions that came to mind:\\n1. Same concept as [Valid Anagram](https://leetcode.com/problems/valid-anagram). You can see my solution [here](https://leetcode.com/problems/valid-anagram/solutions/2881883/o-n-time-o-26-o-1-space/).\\n    - Admittedly, this felt like a performance problem after we mapped every string to it\\'s int[] of occurrences\\n2. Sort each string and compare if the sorted string has occurred before\\n\\nWent with the second approach. Also, easier to code up in interview. Initially, I went with the standard string sort that I know of:\\n```\\nprivate string Sort(string s) {\\n    char[] input = s.ToArray();\\n    Array.Sort(input);\\n    return new string(input);\\n}\\n```\\n\\nHowever, we can improve on this by using counting sort since we are limited to 26 potential characters in the lowercase english alphabet.\\n\\n# Approach\\n1. Sort each string\\n2. Check in hashmap if we have seen the sorted version of the string before\\n    1. If we have, add the original string to the value of the hashmap\\n    2. If we haven\\'t, add the original string to a new entry in the hashmap\\n\\n# Complexity\\n- Time complexity:\\n$$O(nk)$$, where $$n$$ is the length of $$strs$$ and $$k$$ is the length of the longest string in $$strs$$. Our counting sort algorithm uses $$O(26)$$ space and runs in $$O(k+26)$$~$$O(k)$$ time\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs.Length == 0) {\\n            return new List<IList<string>>();\\n        }\\n\\n        Dictionary<string, List<string>> anagrams = new Dictionary<string, List<string>>();\\n\\n        foreach (string str in strs) {\\n            string sortedStr = CountSort(str);\\n            if (!anagrams.ContainsKey(sortedStr)) {\\n                anagrams.Add(sortedStr, new List<string>());\\n            }\\n\\n            anagrams[sortedStr].Add(str);\\n        }\\n\\n        IList<IList<string>> result = new List<IList<string>>();\\n        foreach (KeyValuePair<string, List<string>> kvp in anagrams) {\\n            result.Add(kvp.Value);\\n        }\\n        return result;\\n    }\\n\\n    private string CountSort(string s) {\\n        int[] counts = new int[26];\\n        foreach (char c in s) {\\n            counts[c - \\'a\\'] += 1;\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        for (int i = 0; i < counts.Length; i++) {\\n            if (counts[i] > 0) {\\n                builder.Append((char)(\\'a\\' + i), counts[i]);\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate string Sort(string s) {\\n    char[] input = s.ToArray();\\n    Array.Sort(input);\\n    return new string(input);\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        if (strs.Length == 0) {\\n            return new List<IList<string>>();\\n        }\\n\\n        Dictionary<string, List<string>> anagrams = new Dictionary<string, List<string>>();\\n\\n        foreach (string str in strs) {\\n            string sortedStr = CountSort(str);\\n            if (!anagrams.ContainsKey(sortedStr)) {\\n                anagrams.Add(sortedStr, new List<string>());\\n            }\\n\\n            anagrams[sortedStr].Add(str);\\n        }\\n\\n        IList<IList<string>> result = new List<IList<string>>();\\n        foreach (KeyValuePair<string, List<string>> kvp in anagrams) {\\n            result.Add(kvp.Value);\\n        }\\n        return result;\\n    }\\n\\n    private string CountSort(string s) {\\n        int[] counts = new int[26];\\n        foreach (char c in s) {\\n            counts[c - \\'a\\'] += 1;\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n        for (int i = 0; i < counts.Length; i++) {\\n            if (counts[i] > 0) {\\n                builder.Append((char)(\\'a\\' + i), counts[i]);\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750799,
                "title": "simple-c-code-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n       vector<vector<string>>res;\\n        unordered_map<string,vector<string>>mp;\\n        for(auto&i: strs)\\n            {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0string t=i;//created a copy\\n\\t\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0sort(t.begin(),t.end());//sorted to get the key\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0mp[t].push_back(i);//pushed the initial string in map\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n        for(auto&i:mp)\\n            {\\n            res.push_back(i.second);\\n            }\\n        return res;\\n    }\\n};\\n```\\nWe created a map with string as key and vector of strings as value. As anagrams are just rearrangement of same set of letters , so if we sort them we will get a same string for all anagrams . So using that as a key we store the strings and then return them as answer.\\nAny suggestions are welcomed in the comments \\uD83D\\uDE03",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n       vector<vector<string>>res;\\n        unordered_map<string,vector<string>>mp;\\n        for(auto&i: strs)\\n            {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0string t=i;//created a copy\\n\\t\\t\\t\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0sort(t.begin(),t.end());//sorted to get the key\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0mp[t].push_back(i);//pushed the initial string in map\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n        for(auto&i:mp)\\n            {\\n            res.push_back(i.second);\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750647,
                "title": "3-different-approaches-to-single-problem-java",
                "content": "## UPVOTE THE SOLUTION IF YOU LIKE IT\\n## 1st Approach\\n![image](https://assets.leetcode.com/users/images/b0c486a4-e6f2-46bb-97a3-8b18258275ae_1666922365.7035868.png)\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] s) {\\n        //edge case\\n        if (s.length == 1) {\\n            List<String> list = new ArrayList<>(1);\\n            list.add(s[0]);\\n            List<List<String>> res = new ArrayList<>(1);\\n            res.add(list);\\n            return res;\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            byte[] alphabet = new byte[26];\\n            for (char c : word.toCharArray()) {\\n                alphabet[c - \\'a\\']++;\\n            }\\n            for (byte freq : alphabet) {\\n                sb.append(freq).append(\",\");\\n            }\\n            String key = sb.toString();\\n            if (map.containsKey(key)) {\\n                map.get(key).add(word);\\n            } else {\\n                List<String> list = new ArrayList<>();\\n                list.add(word);\\n                map.put(key,list);\\n            }\\n            sb.setLength(0);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n## 2nd Approach\\n![image](https://assets.leetcode.com/users/images/94dd7aa0-4153-495d-a65c-f3df3cb96a93_1666922593.1981628.png)\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>> output = new ArrayList<List<String>>();\\n        Map<String, List<String>> hashmap= new HashMap<String, List<String>>();\\n        List<String> sortedStrings = new ArrayList<>();\\n        for(String str: strs){\\n            char[] charArray = str.toCharArray();\\n            Arrays.sort(charArray);\\n            String sorted = String.valueOf(charArray);\\n            if(hashmap.containsKey(sorted)){\\n                List<String> temp1 = hashmap.get(sorted);\\n                temp1.add(str);\\n                hashmap.put(sorted,temp1);\\n            }\\n            else{\\n                List<String> temp = new ArrayList<>();\\n                temp.add(str);\\n                hashmap.put(sorted, temp);\\n            }\\n        }\\n        return new ArrayList<>( hashmap.values());\\n    }\\n}\\n```\\n## 3rd Approach\\n![image](https://assets.leetcode.com/users/images/0b3ad927-a64d-4f7a-9340-a6790344eaae_1666922547.2861967.png)\\n```\\nimport java.util.AbstractList;\\nclass Solution {\\n    private List<List<String>> result;\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        return new AbstractList<List<String>>() {\\n\\n            public List<String> get(int index) {\\n                if (result == null)\\n                    init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null)\\n                    init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s : strs) {\\n                    char[] count = new char[26];\\n                    \\n                    for (char c : s.toCharArray())\\n                        count[c - \\'a\\']++;\\n                    String key = String.valueOf(count);\\n                \\n                    if (!map.containsKey(key))\\n                        map.put(key, new ArrayList<String>());\\n                    \\n                    map.get(key).add(s);\\n                }\\n                \\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    }\\n}\\n```\\n\\n## IF OU REACHED TILL HERE KINDLY UPVOTE THE SOLUTION",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] s) {\\n        //edge case\\n        if (s.length == 1) {\\n            List<String> list = new ArrayList<>(1);\\n            list.add(s[0]);\\n            List<List<String>> res = new ArrayList<>(1);\\n            res.add(list);\\n            return res;\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            byte[] alphabet = new byte[26];\\n            for (char c : word.toCharArray()) {\\n                alphabet[c - \\'a\\']++;\\n            }\\n            for (byte freq : alphabet) {\\n                sb.append(freq).append(\",\");\\n            }\\n            String key = sb.toString();\\n            if (map.containsKey(key)) {\\n                map.get(key).add(word);\\n            } else {\\n                List<String> list = new ArrayList<>();\\n                list.add(word);\\n                map.put(key,list);\\n            }\\n            sb.setLength(0);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>> output = new ArrayList<List<String>>();\\n        Map<String, List<String>> hashmap= new HashMap<String, List<String>>();\\n        List<String> sortedStrings = new ArrayList<>();\\n        for(String str: strs){\\n            char[] charArray = str.toCharArray();\\n            Arrays.sort(charArray);\\n            String sorted = String.valueOf(charArray);\\n            if(hashmap.containsKey(sorted)){\\n                List<String> temp1 = hashmap.get(sorted);\\n                temp1.add(str);\\n                hashmap.put(sorted,temp1);\\n            }\\n            else{\\n                List<String> temp = new ArrayList<>();\\n                temp.add(str);\\n                hashmap.put(sorted, temp);\\n            }\\n        }\\n        return new ArrayList<>( hashmap.values());\\n    }\\n}\\n```\n```\\nimport java.util.AbstractList;\\nclass Solution {\\n    private List<List<String>> result;\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        return new AbstractList<List<String>>() {\\n\\n            public List<String> get(int index) {\\n                if (result == null)\\n                    init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null)\\n                    init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s : strs) {\\n                    char[] count = new char[26];\\n                    \\n                    for (char c : s.toCharArray())\\n                        count[c - \\'a\\']++;\\n                    String key = String.valueOf(count);\\n                \\n                    if (!map.containsKey(key))\\n                        map.put(key, new ArrayList<String>());\\n                    \\n                    map.get(key).add(s);\\n                }\\n                \\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225057,
                "title": "super-simple-6ms-java-solution-readable",
                "content": "```\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n\\tMap<String, List<String>> map = new HashMap<>();\\n\\tfor(String str : strs) {\\n\\t\\tchar[] chars = str.toCharArray();\\n\\t\\tArrays.sort(chars);\\n\\n\\t\\tString sortedStr = new String(chars);\\n\\t\\tmap.putIfAbsent(sortedStr, new ArrayList<>());\\n\\t\\tmap.get(sortedStr).add(str);\\n\\t}\\n\\n\\treturn new ArrayList<>(map.values());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n\\tMap<String, List<String>> map = new HashMap<>();\\n\\tfor(String str : strs) {\\n\\t\\tchar[] chars = str.toCharArray();\\n\\t\\tArrays.sort(chars);\\n\\n\\t\\tString sortedStr = new String(chars);\\n\\t\\tmap.putIfAbsent(sortedStr, new ArrayList<>());\\n\\t\\tmap.get(sortedStr).add(str);\\n\\t}\\n\\n\\treturn new ArrayList<>(map.values());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1384401,
                "title": "c-group-anagrams-sorting-and-hashmap",
                "content": "# **LeetCode + Todoist = Consistent Grind -- TRY [Code Task](https://codetask.vercel.app/)**\\n\\n**Using Sorting - Sort every string and push in appropriate bucket**\\n* **Time Complexcity : `O(n.klog(k))`** *where **k** is the length of string and **n** is total no. of strings*\\n* **Space Complexcity : `O(n)`** *if none of the strings are anagram*\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> sorted;\\n        \\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(strs[i].begin(), strs[i].end());\\n            sorted[strs[i]].push_back(temp);\\n        }\\n        \\n        for(auto it = sorted.begin(); it != sorted.end(); it++){\\n            ans.push_back(it->second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        unordered_map<string, vector<string>> sorted;\\n        \\n        for(int i = 0; i < strs.size(); i++){\\n            string temp = strs[i];\\n            sort(strs[i].begin(), strs[i].end());\\n            sorted[strs[i]].push_back(temp);\\n        }\\n        \\n        for(auto it = sorted.begin(); it != sorted.end(); it++){\\n            ans.push_back(it->second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566237,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut out = std::collections::HashMap::new();\\n        for v in strs {\\n            let mut k: Vec<u8> = v.bytes().collect();\\n            k.sort_unstable();\\n            out.entry(k).or_insert_with(|| vec![]).push(v)\\n        }\\n        out.into_iter().map(|(_, v)| v).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\\n        let mut out = std::collections::HashMap::new();\\n        for v in strs {\\n            let mut k: Vec<u8> = v.bytes().collect();\\n            k.sort_unstable();\\n            out.entry(k).or_insert_with(|| vec![]).push(v)\\n        }\\n        out.into_iter().map(|(_, v)| v).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 566236,
                "title": "javascript-5-lines-explained",
                "content": "The approach here is actually quite simple once accounted for.\\n- All we\\'re doing is creating a way to categorize each anagram.\\n- Which can easily be done by sorting in alphabetical order.\\n- Then as we loop through them, if they adhere to the sorted form, we know they belong.\\n- So, add them to the array under which their key or category exists, and finally we can...\\n- return these arrays by looping over the values for each category/key\\n```js\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n    \\n    for (let str of strs) {\\n        let key = [...str].sort()\\n        map[key] = map[key] ? [...map[key], str] : [str]\\n    }\\n    \\n    return Object.values(map)\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar groupAnagrams = function(strs) {\\n    let map = {}\\n    \\n    for (let str of strs) {\\n        let key = [...str].sort()\\n        map[key] = map[key] ? [...map[key], str] : [str]\\n    }\\n    \\n    return Object.values(map)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478474,
                "title": "javascript-most-common-technique-with-good-explanation",
                "content": "**Time complexity is 95.53%**\\n\\n**You can follow along with my numbered markers which are pointers to comments in the code block**\\n\\n1. Just general validations & checks\\n2. Using `Map()` because most of the operations I\\'ll be using are `O(1)`, you could opt for a dictionary using an object but you\\'ll see in step 5 we optimize for speed\\n3. We loop over every word\\n4. We create 2 variables, 1 is the word, 1 is the word but sorted alphabetically\\n\\t- worst `O(n^2)`\\n\\t- avg `O(n log(n))`\\n5. The magic of our `Map()` is here\\n\\t- If our sorted word matches any existing sorted word (which makes it an anagram) then we add it to our anagram list\\n\\t- If our sorted word doesn\\'t match anything, add a new entry to the map\\n\\t\\t- The key would be the sorted word\\n\\t\\t- The value would be an array of the word eg. `[\"word\"]`\\n\\t- `Map().size` is an `O(1)` solution of getting the length vs `Object.entries(...).length` is an `O(n)` because of converting an object to an array\\n\\t- `get()`, `has()`, `push()` and `set()` are all `O(1)`\\n\\t- The only added benefit of using this over a dictionary is readability and the `size` prototype from `Map()`\\n6. We\\'ll have all our results stored in our `Map()`, we just iterate over all our results and put them into 1 array then return that!\\n\\n```\\n// 1\\nif (strs.length === 0) return []\\nif (strs.length === 1) return [strs]\\n\\n// 2\\nconst words = new Map()\\n\\n// 3\\nfor (let i = 0; i < strs.length; i++) {\\n\\tconst word = strs[i]\\n\\tconst wordSorted = [...word].sort().join(\\'\\') // 4\\n\\n\\t// 5\\n\\tif (words.size > 0 && words.has(wordSorted)) {\\n\\t\\twords.get(wordSorted).push(word)\\n\\t} else {\\n\\t\\twords.set(wordSorted, [word])\\n\\t}\\n}\\n\\n// 6\\nconst result = []\\n\\nfor (const [_, list] of words.entries()) {\\n\\tresult.push(list)\\n}\\n\\nreturn result\\n```\\n\\nHope you guys enjoyed this!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 1\\nif (strs.length === 0) return []\\nif (strs.length === 1) return [strs]\\n\\n// 2\\nconst words = new Map()\\n\\n// 3\\nfor (let i = 0; i < strs.length; i++) {\\n\\tconst word = strs[i]\\n\\tconst wordSorted = [...word].sort().join(\\'\\') // 4\\n\\n\\t// 5\\n\\tif (words.size > 0 && words.has(wordSorted)) {\\n\\t\\twords.get(wordSorted).push(word)\\n\\t} else {\\n\\t\\twords.set(wordSorted, [word])\\n\\t}\\n}\\n\\n// 6\\nconst result = []\\n\\nfor (const [_, list] of words.entries()) {\\n\\tresult.push(list)\\n}\\n\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19394,
                "title": "another-approach-hash-by-prime-numbers-java-16ms-defeating-97-53",
                "content": "   The key for this problem is to find a way of hashing. In this solution, the basic idea is to calculate a hash value for each string using prime number. For example, the 1st letter, 'a', represent the 1st prime number, 2. The 2nd letter 'b' for the 2nd prime number 3......After calculating hash values for each word, group them by hash value.\\n```\\npublic class Solution {\\n    private static final int[] primetable = primes(26);\\n    // private static final int[] primetable = new int[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<Integer, List<String>> map = new HashMap<>(strs.length);\\n        for(String s:strs){\\n            int hashcode = hash(s);\\n            map.putIfAbsent(hashcode, new ArrayList<String>());\\n            map.get(hashcode).add(s);\\n        }\\n        List<List<String>> res= new ArrayList<>();\\n        res.addAll(map.values());\\n        return res;\\n    }\\n    private int hash(String s){\\n        int hashcode = 1;\\n        for(char c:s.toCharArray()){\\n            hashcode *= primetable[c-97];\\n        }\\n        return hashcode;\\n    }\\n    private static int[] primes(int n){\\n        if(n<1){\\n            return null;\\n        }\\n        int[] res = new int[n];\\n        res[0] = 2;\\n        int counter = 1, cur = 3;\\n        while(counter<n){\\n            for(int num:res){\\n                // if visited all previous prime numbers\\n                if(num==0 || num*num >cur){\\n                    res[counter++] = cur++; \\n                    break;\\n                }\\n                // not a prime number\\n                if(cur%num==0){\\n                    ++cur;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    private static final int[] primetable = primes(26);\\n    // private static final int[] primetable = new int[]{2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101};\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<Integer, List<String>> map = new HashMap<>(strs.length);\\n        for(String s:strs){\\n            int hashcode = hash(s);\\n            map.putIfAbsent(hashcode, new ArrayList<String>());\\n            map.get(hashcode).add(s);\\n        }\\n        List<List<String>> res= new ArrayList<>();\\n        res.addAll(map.values());\\n        return res;\\n    }\\n    private int hash(String s){\\n        int hashcode = 1;\\n        for(char c:s.toCharArray()){\\n            hashcode *= primetable[c-97];\\n        }\\n        return hashcode;\\n    }\\n    private static int[] primes(int n){\\n        if(n<1){\\n            return null;\\n        }\\n        int[] res = new int[n];\\n        res[0] = 2;\\n        int counter = 1, cur = 3;\\n        while(counter<n){\\n            for(int num:res){\\n                // if visited all previous prime numbers\\n                if(num==0 || num*num >cur){\\n                    res[counter++] = cur++; \\n                    break;\\n                }\\n                // not a prime number\\n                if(cur%num==0){\\n                    ++cur;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19443,
                "title": "i-solved-it-with-o-m-log-m-n-time-o-m-n-space-is-there-better-solution-accepted",
                "content": "m represents the mean length of String in strs. I sorted every String, and used HashMap to store the groups of strings that are anagrams.\\n\\n    public class Solution {\\n        public ArrayList<String> anagrams(String[] strs) {\\n            if(strs==null || strs.length==0) return null;\\n            ArrayList<String> ret = new ArrayList<String>();\\n            Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\\n            for(String s:strs)\\n            {\\n                char[] temp = s.toCharArray();\\n                Arrays.sort(temp);\\n                ArrayList<String> array = map.get(new String(temp));\\n                if(array==null)\\n                {\\n                    array = new ArrayList<String>();\\n                    array.add(s);\\n                    map.put(new String(temp), array);\\n                }\\n                else array.add(s);\\n            }\\n            for(String s:map.keySet())\\n            {\\n                ArrayList<String> array = map.get(s);\\n                if(array.size()!=1) ret.addAll(array);\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ArrayList<String> anagrams(String[] strs) {\\n            if(strs==null || strs.length==0) return null;\\n            ArrayList<String> ret = new ArrayList<String>();\\n            Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();\\n            for(String s:strs)\\n            {\\n                char[] temp = s.toCharArray();\\n                Arrays.sort(temp);\\n                ArrayList<String> array = map.get(new String(temp));\\n                if(array==null)\\n                {\\n                    array = new ArrayList<String>();\\n                    array.add(s);\\n                    map.put(new String(temp), array);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3140613,
                "title": "c-map-sorting-all-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is to sort every string present in str and keeping the sorted string as key push all the strings which will match this osrted key string. And thise will be actually anagrams .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse sorting and hashing.\\nAlso we can do count sort becuase we have only 26 charcaters so we can direclty locate values which are present in the string in `O(n)` time so need to sort in $$nlogn $$\\n# Complexity\\n- Time complexity:O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Using Normal Stl Sort [$$n*k*logk$$]**\\n```\\nvector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           sort(begin(s),end(s));\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n\\n        return res;\\n    }\\n```\\n**Using Count Sort**\\n```\\nclass Solution {\\npublic:\\n    void count_sort(string& s){\\n        int n=s.size();\\n        vector<int>mp(26,0);\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n          ans.append(mp[i],i+\\'a\\');\\n        }\\n        s=ans;\\n    }\\n    vector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           count_sort(s);\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           sort(begin(s),end(s));\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    void count_sort(string& s){\\n        int n=s.size();\\n        vector<int>mp(26,0);\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            mp[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n          ans.append(mp[i],i+\\'a\\');\\n        }\\n        s=ans;\\n    }\\n    vector<vector<string>> groupAnagrams(vector<string>& str) {\\n\\n        map<string,vector<string>>mp;\\n        int k=0;\\n        for(auto x:str){\\n           string s=x;\\n           count_sort(s);\\n           mp[s].push_back(x);\\n        }\\n        vector<vector<string>>res;\\n        for(auto x:mp)\\n         res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751160,
                "title": "simple-solution-with-explanation-tc-o-n-length-of-largest-word-sc-o-n",
                "content": "* We have to just count the occurrence of each word and store it in a map of array having same frequency pattern.\\n* Lastly return all the values of hashmap\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dct=defaultdict(list)\\n        for i in range(len(strs)):\\n            st=[0 for _ in range(26)]\\n            for j in strs[i]:\\n                xi=ord(j)-97\\n                st[xi]+=1\\n            st=tuple(st)\\n            dct[st].append(strs[i])\\n        return dct.values()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dct=defaultdict(list)\\n        for i in range(len(strs)):\\n            st=[0 for _ in range(26)]\\n            for j in strs[i]:\\n                xi=ord(j)-97\\n                st[xi]+=1\\n            st=tuple(st)\\n            dct[st].append(strs[i])\\n        return dct.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750484,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\nconst groupAnagrams = function(strs) {\\n    const groups = {};\\n    for(let str of strs) {\\n        const key = str.split(\"\").sort();\\n        if(key in groups) {\\n            groups[key].push(str);\\n        }\\n        else {\\n            groups[key] = [str];\\n        }\\n    }\\n    return Object.values(groups);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst groupAnagrams = function(strs) {\\n    const groups = {};\\n    for(let str of strs) {\\n        const key = str.split(\"\").sort();\\n        if(key in groups) {\\n            groups[key].push(str);\\n        }\\n        else {\\n            groups[key] = [str];\\n        }\\n    }\\n    return Object.values(groups);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1048422,
                "title": "2-solutions-in-c-one-using-sort-and-other-without-sort",
                "content": "1 . C++ Solution With Sort in O(N*KlogK) Time\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mpp;\\n        \\n        for(string str : strs)\\n        {\\n            string copy = str;\\n            sort(copy.begin(),copy.end());\\n            mpp[copy].push_back(str);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {     \\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n2 . C++ Solution Without Sort in O(N*K) Time\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map<map<char,int>,vector<string>>mpp;  \\n        for(string s : strs)\\n        {\\n            map<char,int>mpp2;\\n            for(char ch : s)\\n                mpp2[ch]++;\\n            mpp[mpp2].push_back(s);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mpp;\\n        \\n        for(string str : strs)\\n        {\\n            string copy = str;\\n            sort(copy.begin(),copy.end());\\n            mpp[copy].push_back(str);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {     \\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map<map<char,int>,vector<string>>mpp;  \\n        for(string s : strs)\\n        {\\n            map<char,int>mpp2;\\n            for(char ch : s)\\n                mpp2[ch]++;\\n            mpp[mpp2].push_back(s);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x : mpp)\\n        {\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717546,
                "title": "swift-one-line",
                "content": "```swift\\nclass Solution {\\n  func groupAnagrams(_ strs: [String]) -> [[String]] {\\n    return Array(Dictionary(grouping: strs) { $0.sorted() }.values)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n  func groupAnagrams(_ strs: [String]) -> [[String]] {\\n    return Array(Dictionary(grouping: strs) { $0.sorted() }.values)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548172,
                "title": "easy-python-solution-with-explanation",
                "content": "Basic Idea - If your sort anagrams they come same string. \\nUse this to create a disctionary with corted words as key and keep appending all anagrams to it. \\nIn the end, iterate over disctionary to get the answer in expected format. \\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        d = {}\\n        ans = []\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            if sorted_word not in d:\\n                d[sorted_word] = [word]\\n            else:\\n                d[sorted_word].append(word)\\n            \\n        for key in d:\\n            ans.append(d[key])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        d = {}\\n        ans = []\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            if sorted_word not in d:\\n                d[sorted_word] = [word]\\n            else:\\n                d[sorted_word].append(word)\\n            \\n        for key in d:\\n            ans.append(d[key])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391010,
                "title": "very-simple-c-solution-faster-than-99-92-submissions",
                "content": "A very simple C# soluton using a HashTable / Dictionary. Feel free to suggest improvements.\\n\\n**Time Complexity:** O(n * mlogm)\\nwhere n is the number of items in the array and m is the length of each anagram \\n**Space Complexity:** O(n) \\n\\nRuntime: 280 ms, faster than 99.92% of C# online submissions for Group Anagrams.\\nMemory Usage: 37.3 MB, less than 23.53% of C# online submissions for Group Anagrams.\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        IList<IList<string>> result = new List<IList<string>>();\\n        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();\\n        foreach(string anagram in strs){\\n            char[] tempArray = anagram.ToCharArray();\\n            Array.Sort(tempArray);\\n            string sorted = new string(tempArray);\\n            if(!map.ContainsKey(sorted)){\\n                map.Add(sorted, new List<string>(){ anagram });                \\n            }else{\\n                map[sorted].Add(anagram);   \\n            }\\n        }\\n        foreach(var pair in map){\\n            result.Add(pair.Value);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "A very simple C# soluton using a HashTable / Dictionary. Feel free to suggest improvements.\\n\\n**Time Complexity:** O(n * mlogm)\\nwhere n is the number of items in the array and m is the length of each anagram \\n**Space Complexity:** O(n) \\n\\nRuntime: 280 ms, faster than 99.92% of C# online submissions for Group Anagrams.\\nMemory Usage: 37.3 MB, less than 23.53% of C# online submissions for Group Anagrams.\\n\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        IList<IList<string>> result = new List<IList<string>>();\\n        Dictionary<string, List<string>> map = new Dictionary<string, List<string>>();\\n        foreach(string anagram in strs){\\n            char[] tempArray = anagram.ToCharArray();\\n            Array.Sort(tempArray);\\n            string sorted = new string(tempArray);\\n            if(!map.ContainsKey(sorted)){\\n                map.Add(sorted, new List<string>(){ anagram });                \\n            }else{\\n                map[sorted].Add(anagram);   \\n            }\\n        }\\n        foreach(var pair in map){\\n            result.Add(pair.Value);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 299592,
                "title": "go-beats-100",
                "content": "```\\nfunc groupAnagrams(words []string) [][]string {\\n\\tcache := make(map[[26]byte]int)\\n\\tresult := make([][]string, 0)\\n\\tfor i := range words {\\n\\t\\tlist := [26]byte{}\\n\\t\\tfor j := range words[i] {\\n\\t\\t\\tlist[words[i][j]-\\'a\\']++\\n\\t\\t}\\n\\t\\tif idx, ok := cache[list]; ok {\\n\\t\\t\\tresult[idx] = append(result[idx], words[i])\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, []string{words[i]})\\n\\t\\t\\tcache[list] = len(result) - 1\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc groupAnagrams(words []string) [][]string {\\n\\tcache := make(map[[26]byte]int)\\n\\tresult := make([][]string, 0)\\n\\tfor i := range words {\\n\\t\\tlist := [26]byte{}\\n\\t\\tfor j := range words[i] {\\n\\t\\t\\tlist[words[i][j]-\\'a\\']++\\n\\t\\t}\\n\\t\\tif idx, ok := cache[list]; ok {\\n\\t\\t\\tresult[idx] = append(result[idx], words[i])\\n\\t\\t} else {\\n\\t\\t\\tresult = append(result, []string{words[i]})\\n\\t\\t\\tcache[list] = len(result) - 1\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250264,
                "title": "java-solutions",
                "content": "**Solution 1: Group by Sorted String**\\n\\n> Two strings are `anagrams` if and only if their sorted strings are equal.\\n- We use `Map` to group the strings by their sorted counterparts. We use the sorted string as the key and List of anagram strings as the value. Each key `keyStr` is a sorted string, and each value is the list of strings from the initial input that when sorted, are equal to `keyStr`.\\n- The outer loop has complexity `O(n)` as we iterate through each string. Then, we sort each string in `O(k log k)` time.\\n\\nTime complexity: `O(n * k log k)` - where `n` is the length of input array `strs`, and `k` is the maximum length of a string in `strs` array. \\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`. \\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n\\t\\tMap<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n        for(String s : strs)\\n\\t\\t{\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n    \\t\\tmap.putIfAbsent(keyStr, new ArrayList<>());\\t\\t// If no mapping for a key, then map a new key with an empty list.\\n\\t\\t\\tmap.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\n**Solution 2: Group by Character Counts**\\n\\n> Two strings are `anagrams` if and only if their character counts are the same.\\n- We can transform each string `s` into an encoded string based on the its character counts.\\n- For example, string `abbccc` will be `a1b2c3d0e0...z0` where there are `26` entries for each character from `a` to `z`.\\n\\nTime complexity: `O(n * k)` - Encoding each string is linear in the size of the string which is `O(k)`, and we encode every string. So `O(n) * O(k) = O(n * k)`.\\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`.\\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            String keyStr = encodeString(s);\\n            map.putIfAbsent(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate String encodeString(String s)\\n\\t{\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint[] count = new int[26];\\n\\t\\tArrays.fill(count, 0);\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tsb.append(i + \\'a\\').append(count[i]);\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n}\\n```\\n\\n**Solution 3: Group by hashCode**\\n\\n- Here we compute the `hashCode` of an array of character counts of the string.\\n\\nTime complexity: `O(n * k)` - Computing a hashCode for each string is linear in the size of the string which is `O(k)`, and we do this for every string. So `O(n) * O(k) = O(n * k)`.\\nSpace complexity: `O(n * k)` - the total information content stored in a `Map`.\\n\\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<Integer, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            int hashCode = computeHashCode(s);\\n            map.putIfAbsent(hashCode, new ArrayList<>());\\n            map.get(hashCode).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate int computeHashCode(String s)\\n\\t{\\n\\t\\tint[] count = new int[26];\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\t\\treturn Arrays.hashCode(count);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n\\t\\tMap<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n        for(String s : strs)\\n\\t\\t{\\n            char[] ca = s.toCharArray();\\n            Arrays.sort(ca);\\n            String keyStr = String.valueOf(ca);\\n    \\t\\tmap.putIfAbsent(keyStr, new ArrayList<>());\\t\\t// If no mapping for a key, then map a new key with an empty list.\\n\\t\\t\\tmap.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<String, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            String keyStr = encodeString(s);\\n            map.putIfAbsent(keyStr, new ArrayList<>());\\n            map.get(keyStr).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate String encodeString(String s)\\n\\t{\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint[] count = new int[26];\\n\\t\\tArrays.fill(count, 0);\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0; i < 26; i++)\\n\\t\\t{\\n\\t\\t\\tsb.append(i + \\'a\\').append(count[i]);\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n}\\n```\n```\\nclass Solution\\n{\\n    public List<List<String>> groupAnagrams(String[] strs)\\n\\t{\\n        Map<Integer, List<String>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(String s : strs)\\n\\t\\t{\\n            int hashCode = computeHashCode(s);\\n            map.putIfAbsent(hashCode, new ArrayList<>());\\n            map.get(hashCode).add(s);\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n\\n\\tprivate int computeHashCode(String s)\\n\\t{\\n\\t\\tint[] count = new int[26];\\n\\n\\t\\tfor(char c : s.toCharArray())\\n\\t\\t{\\n\\t\\t\\tcount[c - \\'a\\'] += 1;\\n\\t\\t}\\n\\t\\treturn Arrays.hashCode(count);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19463,
                "title": "accept-java-solution",
                "content": "    public class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            Map <String,Integer>mp = new HashMap<String,Integer>();\\n            Arrays.sort(strs);\\n            for(String str : strs){\\n                char[] ch = str.toCharArray();\\n                Arrays.sort(ch);\\n                String s = new String(ch);\\n                if(mp.containsKey(s)){\\n                    List li = res.get(mp.get(s));\\n                    li.add(str);\\n                }else{\\n                    List li = new ArrayList();\\n                    li.add(str);\\n                    res.add(li);\\n                    mp.put(s,res.size()-1);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n\\nstep 1. sort the original array. Make sure the output order is correct.\\nstep 2. sort every string, check if it's in hash map. if is, add to the result, if not, add to the hashMap.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            Map <String,Integer>mp = new HashMap<String,Integer>();\\n            Arrays.sort(strs);\\n            for(String str : strs){\\n                char[] ch = str.toCharArray();\\n                Arrays.sort(ch);\\n                String s = new String(ch);\\n                if(mp.containsKey(s)){\\n                    List li = res.get(mp.get(s));\\n                    li.add(str);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3267924,
                "title": "c-solution-using-groupby-and-sorting",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        return strs\\n            .GroupBy(s => new string(s.OrderBy(c => c).ToArray()))\\n            .Select(g => g.ToList() as IList<string>)\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n        return strs\\n            .GroupBy(s => new string(s.OrderBy(c => c).ToArray()))\\n            .Select(g => g.ToList() as IList<string>)\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750508,
                "title": "js-javascript-solution-with-map",
                "content": "# Any feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nconst groupAnagrams = function(strs) {\\n  const map = new Map();\\n  \\n  for (let str of strs) {\\n    let curr = [...str].sort().join(\\'\\');\\n    if (!map.has(curr)) map.set(curr, []);\\n    map.get(curr).push(str);\\n  }\\n  return Array.from(map.values());\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst groupAnagrams = function(strs) {\\n  const map = new Map();\\n  \\n  for (let str of strs) {\\n    let curr = [...str].sort().join(\\'\\');\\n    if (!map.has(curr)) map.set(curr, []);\\n    map.get(curr).push(str);\\n  }\\n  return Array.from(map.values());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252670,
                "title": "solved-with-c",
                "content": "Simple and fast solution using c#\\n\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n\\n           if (strs == null || strs.Length == 0) return new List<IList<string>>();\\n            var countDict = new Dictionary<string, IList<string>>();\\n            foreach (string str in strs)\\n            {\\n                var charList = new char[26];\\n                foreach (char c in str)\\n                {\\n                    charList[c - \\'a\\']++;\\n                }\\n\\n                var key = new string(charList);\\n\\n                if (!countDict.ContainsKey(key))\\n                {\\n                    countDict.Add(key, new List<string> { str });\\n                }\\n                else\\n                {\\n                    countDict[key].Add(str);\\n                }\\n            }\\n\\n            return countDict.Values.ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n\\n           if (strs == null || strs.Length == 0) return new List<IList<string>>();\\n            var countDict = new Dictionary<string, IList<string>>();\\n            foreach (string str in strs)\\n            {\\n                var charList = new char[26];\\n                foreach (char c in str)\\n                {\\n                    charList[c - \\'a\\']++;\\n                }\\n\\n                var key = new string(charList);\\n\\n                if (!countDict.ContainsKey(key))\\n                {\\n                    countDict.Add(key, new List<string> { str });\\n                }\\n                else\\n                {\\n                    countDict[key].Add(str);\\n                }\\n            }\\n\\n            return countDict.Values.ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085008,
                "title": "error-incompatible-types-boolean-cannot-be-converted-to-list-string",
                "content": "Not sure why I am getting this error. Can someone please help me in understanding this.\\n![image](https://assets.leetcode.com/users/images/8851fbfc-88d5-46f8-b001-06a281427eb6_1653769454.915814.png)\\n\\ncode:\\n```\\nHashMap<String, List<String>> hm = new HashMap<>();\\nhm.put(temp, hm.get(temp).add(s));\\n```\\nHere temp and s are of type String\\n\\nBut below code snippet is working fine\\n\\n``` \\nList<String> list = hm.get(temp);  \\nlist.add(s);            \\nhm.put(temp,list); \\n```\\n\\n\\nFull code:\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        if(strs.length == 0)\\n            return new ArrayList();\\n        \\n        HashMap<String, List<String>> hm = new HashMap<>();\\n        \\n        for(String s : strs){   \\n            char[] ch = s.toCharArray();\\n            Arrays.sort(ch);   \\n\\n            String temp = new String(ch);\\n            \\n            if(hm.containsKey(temp)){   \\n                List<String> list = hm.get(temp);  \\n                list.add(s);           \\n                hm.put(temp,list);      \\n                //hm.put(temp, hm.get(temp).add(s));    // why it\\'s not working? --getting error here\\n            }\\n            else{\\n                List<String> list = new ArrayList<>(1);\\n                list.add(s);\\n                hm.put(temp,list);\\n            }\\n        }\\n \\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(Map.Entry entry : hm.entrySet()){   \\n            List list = (List)entry.getValue();\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nHashMap<String, List<String>> hm = new HashMap<>();\\nhm.put(temp, hm.get(temp).add(s));\\n```\n``` \\nList<String> list = hm.get(temp);  \\nlist.add(s);            \\nhm.put(temp,list); \\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        if(strs.length == 0)\\n            return new ArrayList();\\n        \\n        HashMap<String, List<String>> hm = new HashMap<>();\\n        \\n        for(String s : strs){   \\n            char[] ch = s.toCharArray();\\n            Arrays.sort(ch);   \\n\\n            String temp = new String(ch);\\n            \\n            if(hm.containsKey(temp)){   \\n                List<String> list = hm.get(temp);  \\n                list.add(s);           \\n                hm.put(temp,list);      \\n                //hm.put(temp, hm.get(temp).add(s));    // why it\\'s not working? --getting error here\\n            }\\n            else{\\n                List<String> list = new ArrayList<>(1);\\n                list.add(s);\\n                hm.put(temp,list);\\n            }\\n        }\\n \\n        List<List<String>> ans = new ArrayList<>();\\n        \\n        for(Map.Entry entry : hm.entrySet()){   \\n            List list = (List)entry.getValue();\\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442564,
                "title": "c-using-hashmap",
                "content": "**Please Upvote if you like the code!**\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs)\\n    {\\n        vector<vector<string>> res;\\n        unordered_map<string,vector<string>> m;\\n        string temp;\\n        \\n        for(int i=0;i<strs.size();i++)\\n        {\\n            temp=strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            m[strs[i]].push_back(temp);\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            res.push_back(it->second);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "**Please Upvote if you like the code!**\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs)\\n    {\\n        vector<vector<string>> res;\\n        unordered_map<string,vector<string>> m;\\n        string temp;\\n        \\n        for(int i=0;i<strs.size();i++)\\n        {\\n            temp=strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            m[strs[i]].push_back(temp);\\n        }\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            res.push_back(it->second);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 833858,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.isEmpty { return [] }\\n        \\n        var map = [String: [String]]()\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            map[sortedStr, default: []] += [str]\\n        }\\n                \\n        return Array(map.values)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.isEmpty { return [] }\\n        \\n        var map = [String: [String]]()\\n        for str in strs {\\n            let sortedStr = String(str.sorted())\\n            map[sortedStr, default: []] += [str]\\n        }\\n                \\n        return Array(map.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225669,
                "title": "scala-one-liner",
                "content": "```\\n  def groupAnagrams(strs: Array[String]): List[List[String]] = {\\n    strs.groupBy(_.sorted).values.map(_.toList).toList\\n  }\\n ```\\n",
                "solutionTags": [],
                "code": "```\\n  def groupAnagrams(strs: Array[String]): List[List[String]] = {\\n    strs.groupBy(_.sorted).values.map(_.toList).toList\\n  }\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 200240,
                "title": "neat-java-solution",
                "content": "```java\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Hashtable;\\nimport java.util.List;\\n\\npublic class Solution {\\n\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n    Hashtable<String, List<String>> ht = new Hashtable<>();\\n    for (String s : strs) {\\n      char[] temp = s.toCharArray();\\n      Arrays.sort(temp);\\n      String _s = String.valueOf(temp);\\n      ht.putIfAbsent(_s, new ArrayList<>());\\n      ht.get(_s).add(s);\\n    }\\n    return new ArrayList<>(ht.values());\\n  }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n  public List<List<String>> groupAnagrams(String[] strs) {\\n    Hashtable<String, List<String>> ht = new Hashtable<>();\\n    for (String s : strs) {\\n      char[] temp = s.toCharArray();\\n      Arrays.sort(temp);\\n      String _s = String.valueOf(temp);\\n      ht.putIfAbsent(_s, new ArrayList<>());\\n      ht.get(_s).add(s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 164186,
                "title": "python-solution",
                "content": "Hash map O(NK) time, O(N) space:\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def convert(s):\\n            res = [0]*26\\n            for char in s:\\n                res[ord(char)-ord(\\'a\\')] += 1\\n            return tuple(res)\\n        rec = {}\\n        res = []\\n        for s in strs:\\n            t = convert(s)\\n            if t in rec:\\n                res[rec[t]].append(s)\\n            else:\\n                res.append([s])\\n                rec[t] = len(res)-1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        def convert(s):\\n            res = [0]*26\\n            for char in s:\\n                res[ord(char)-ord(\\'a\\')] += 1\\n            return tuple(res)\\n        rec = {}\\n        res = []\\n        for s in strs:\\n            t = convert(s)\\n            if t in rec:\\n                res[rec[t]].append(s)\\n            else:\\n                res.append([s])\\n                rec[t] = len(res)-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19236,
                "title": "swift-solution-hash-table",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.count == 0 {\\n            return [[String]]()\\n        }\\n        \\n        var map = [String: [String]]()\\n        \\n        for str in strs {\\n            let key = String(Array(str.characters).sorted())\\n            if !map.keys.contains(key) {\\n                map[key] = [String]()\\n            }\\n            map[key]?.append(str)\\n        }\\n        \\n        return Array(map.values)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        if strs.count == 0 {\\n            return [[String]]()\\n        }\\n        \\n        var map = [String: [String]]()\\n        \\n        for str in strs {\\n            let key = String(Array(str.characters).sorted())\\n            if !map.keys.contains(key) {\\n                map[key] = [String]()\\n            }\\n            map[key]?.append(str)\\n        }\\n        \\n        return Array(map.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19330,
                "title": "share-my-simple-java-solution-pretty-easy-to-understand",
                "content": "I don't see this code needs any more explanation. Straightforward.\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n      Arrays.sort(strs);\\n      HashMap<String, List<String>> hm = new HashMap<>();\\n      for(int i = 0; i < strs.length; i++){\\n        String currString = strs[i];\\n        char[] charArr = strs[i].toCharArray();\\n        Arrays.sort(charArr);\\n        String sortString = new String(charArr);\\n        List<String > tempList = hm.getOrDefault(sortString, new ArrayList<String>());\\n        tempList.add(currString);\\n        hm.put(sortString, tempList);\\n      }\\n      return new ArrayList<>(hm.values());\\n    }",
                "solutionTags": [],
                "code": "I don't see this code needs any more explanation. Straightforward.\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n      Arrays.sort(strs);\\n      HashMap<String, List<String>> hm = new HashMap<>();\\n      for(int i = 0; i < strs.length; i++){\\n        String currString = strs[i];\\n        char[] charArr = strs[i].toCharArray();\\n        Arrays.sort(charArr);\\n        String sortString = new String(charArr);\\n        List<String > tempList = hm.getOrDefault(sortString, new ArrayList<String>());\\n        tempList.add(currString);\\n        hm.put(sortString, tempList);\\n      }\\n      return new ArrayList<>(hm.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4025789,
                "title": "easy-python-solution-briefly-explained",
                "content": "# Code Explanation\\nThe provided Python code defines a class `Solution` with a method `groupAnagrams`. This method takes a list of strings `strs` as input and is supposed to group the anagrams from the input list into lists of lists, where each inner list contains words that are anagrams of each other. Anagrams are words or phrases formed by rearranging the letters of another, such as \"listen\" and \"silent.\"\\n\\nLet\\'s break down the code step by step:\\n\\n1. **Initialize a Dictionary**: The code starts by initializing an empty dictionary called `ans`. This dictionary will be used to store groups of anagrams, with the keys being the character counts of the letters in the anagrams and the values being lists of strings that belong to each group.\\n\\n    ```python\\n    ans = collections.defaultdict(list)\\n    ```\\n\\n    Here, `collections.defaultdict(list)` creates a dictionary where the default value for each key is an empty list.\\n\\n2. **Iterate Through the Input List**: The code then enters a loop to iterate through each string `s` in the input list `strs`.\\n\\n    ```python\\n    for s in strs:\\n    ```\\n\\n3. **Initialize a Character Count List**: Inside the loop, a list called `count` is initialized with 26 zeros. This list will be used to count the occurrences of each letter in the current string `s`. Each index in the `count` list corresponds to a letter in the lowercase English alphabet.\\n\\n    ```python\\n    count = [0] * 26\\n    ```\\n\\n4. **Count the Occurrence of Letters in the String**: The code then enters another loop to iterate through each character `c` in the current string `s`.\\n\\n    ```python\\n    for c in s:\\n    ```\\n\\n5. **Increment the Count for Each Letter**: Inside the inner loop, the code calculates the position of the character `c` in the alphabet (by subtracting the ASCII value of \\'a\\' from the ASCII value of `c`) and increments the corresponding element in the `count` list. This effectively counts the occurrence of each letter in the current string `s`.\\n\\n    ```python\\n    count[ord(c) - ord(\"a\")] += 1\\n    ```\\n\\n6. **Group Anagrams Using Character Counts as Keys**: After counting the occurrences of letters in the current string `s`, the code converts the `count` list into a tuple. This tuple is used as a key in the `ans` dictionary. The value associated with this key is a list, and the current string `s` is appended to this list. This step groups strings with the same character count together.\\n\\n    ```python\\n    ans[tuple(count)].append(s)\\n    ```\\n\\n7. **Return Grouped Anagrams**: After processing all strings in the input list `strs`, the code returns the values of the `ans` dictionary. These values are lists of grouped anagrams.\\n\\n    ```python\\n    return ans.values()\\n    ```\\n\\nSo, in summary, this code efficiently groups anagrams by counting the occurrences of each letter in each string and using these counts as keys in a dictionary. It ensures that anagrams with the same character counts are grouped together, and it returns these groups as a list of lists.\\n\\n# Python Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = collections.defaultdict(list)\\n\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\"a\")] += 1                \\n            ans[tuple(count)].append(s)\\n\\n        return ans.values()\\n\\n```\\n\\n**Please upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```python\\n    ans = collections.defaultdict(list)\\n    ```\n```python\\n    for s in strs:\\n    ```\n```python\\n    count = [0] * 26\\n    ```\n```python\\n    for c in s:\\n    ```\n```python\\n    count[ord(c) - ord(\"a\")] += 1\\n    ```\n```python\\n    ans[tuple(count)].append(s)\\n    ```\n```python\\n    return ans.values()\\n    ```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        ans = collections.defaultdict(list)\\n\\n        for s in strs:\\n            count = [0] * 26\\n            for c in s:\\n                count[ord(c) - ord(\"a\")] += 1                \\n            ans[tuple(count)].append(s)\\n\\n        return ans.values()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752865,
                "title": "c-one-pass-hashmap-sorting-time-o-n",
                "content": "# Intuition\\nIn a HashMap, keep a track of where the string will go in the resultant array i.e., where that string\\'s anagrams were inserted before. Key will be the sorted string and value will be the index.\\n\\nFor every string $$s$$\\n- If its sorted key $$t$$ is present in the HashMap, that means $$s$$\\'s anagrams were found before too, and were inserted at some index $$map[t]$$. Insert $s$ at that index too.\\n- If its sorted key $$t$$ is not present in the HashMap, that means it is a new type of anagram never seen before. Create a new index for it in resultant array and store the new index in HashMap.\\n\\n# Code\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, int> index;\\n        vector<vector<string>> result;\\n        for (string& s: strs) {\\n            string t = s;\\n            sort(t.begin(), t.end());\\n            if (index.find(t) == index.end()) { // new anagram\\n                index[t] = result.size();\\n                result.push_back({});\\n            }\\n            result[index[t]].push_back(s);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time Complexity: $$O(n)$$\\n- Space Complexity: $$O(n)$$\\n\\nConsidering length of each string negligible as compared to number of strings.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, int> index;\\n        vector<vector<string>> result;\\n        for (string& s: strs) {\\n            string t = s;\\n            sort(t.begin(), t.end());\\n            if (index.find(t) == index.end()) { // new anagram\\n                index[t] = result.size();\\n                result.push_back({});\\n            }\\n            result[index[t]].push_back(s);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752816,
                "title": "simple-easy-to-understand-go-sol",
                "content": "Please Upvote if you found this helpful \\n\\n```\\nfunc groupAnagrams(strs []string) [][]string {\\n    mapS := make(map[string][]string, 0)\\n    \\n    for _, val := range strs {\\n        byteString := []byte(val)\\n        sort.Slice(byteString, func(i,j int) bool { return byteString[i] < byteString[j]})\\n        sortedString := string(byteString)\\n        \\n        mapS[sortedString] = append(mapS[sortedString], val)\\n    }\\n    \\n    ans := make([][]string,0)\\n\\n    for _,val := range mapS {\\n        ans = append(ans, val)\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    mapS := make(map[string][]string, 0)\\n    \\n    for _, val := range strs {\\n        byteString := []byte(val)\\n        sort.Slice(byteString, func(i,j int) bool { return byteString[i] < byteString[j]})\\n        sortedString := string(byteString)\\n        \\n        mapS[sortedString] = append(mapS[sortedString], val)\\n    }\\n    \\n    ans := make([][]string,0)\\n\\n    for _,val := range mapS {\\n        ans = append(ans, val)\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607029,
                "title": "python-95-faster-96-less-memory-use-easiest-solution-to-undertand",
                "content": "### ------ please upvote if it\\'s helpful ----#####\\n# we will be using dictionary to store which string has which characters and their frequencies \\n# dic => key = letters of words as sorted and in string form because we can\\'t use lists as key in dictionary // value = the string that question asks from us\\n\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic = {}\\n        for string in strs:\\n            current = sorted(string)\\n            current = \"\".join(current)\\n            if current in dic:\\n                dic[current].append(string)\\n                \\n            else:\\n                dic[current] = [string]\\n                \\n        ans = []\\n        for string in dic:\\n            ans.append(dic[string])\\n            \\n        return ans",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "### ------ please upvote if it\\'s helpful ----#####\\n# we will be using dictionary to store which string has which characters and their frequencies \\n# dic => key = letters of words as sorted and in string form because we can\\'t use lists as key in dictionary // value = the string that question asks from us\\n\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        dic = {}\\n        for string in strs:\\n            current = sorted(string)\\n            current = \"\".join(current)\\n            if current in dic:\\n                dic[current].append(string)\\n                \\n            else:\\n                dic[current] = [string]\\n                \\n        ans = []\\n        for string in dic:\\n            ans.append(dic[string])\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2184993,
                "title": "java-10ms-explained-with-comments-explained-for-kid-level",
                "content": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n//       Initialization of Hashmap Key is type of String and Value is type of List<String\\n        HashMap<String, List<String> > map = new HashMap<>(); \\n        \\n        \\n        for(String s : strs){ // Taking one by one String from strs array\\n            char[] chars = s.toCharArray(); //Converting String to Char Array\\n            Arrays.sort(chars); // Sorting The Char Array by using inbuilt Sorting Method\\n            String key = String.valueOf(chars); //Converting Sorted Char array to String. It will act as a Key for our hashmap\\n            if(map.containsKey(key))\\n                map.get(key).add(s); //If key exist then add the String or append the string to the end of the list\\n            else{\\n                map.put(key, new ArrayList<>()); // If key not present then initialize the ArrayList \\n                map.get(key).add(s); // and add the Perticular String to that key.\\n            } \\n        }\\n        \\n        List<List<String>> answer = new ArrayList<>(); // Initialize the Answer arraylist of arraylist\\n        for(String key : map.keySet()) // keySet will give you all the keys available for that Hashmap use it to get the keys and get the list out of it\\n            answer.add(map.get(key));  // Append the list of given key to the answer list\\n        \\n        \\n        return answer; // return the answer array\\n    }\\n}\\nTime Complexity  O(n mlogm) \\nO(n) for iterating to the whole string array\\no(mlogm) for converting to the char array and sorting the array\\n\\nSpace Complexity : O(n*m) \\nspace",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n//       Initialization of Hashmap Key is type of String and Value is type of List<String\\n        HashMap<String, List<String> > map = new HashMap<>(); \\n        \\n        \\n        for(String s : strs){ // Taking one by one String from strs array\\n            char[] chars = s.toCharArray(); //Converting String to Char Array\\n            Arrays.sort(chars); // Sorting The Char Array by using inbuilt Sorting Method\\n            String key = String.valueOf(chars); //Converting Sorted Char array to String. It will act as a Key for our hashmap\\n            if(map.containsKey(key))\\n                map.get(key).add(s); //If key exist then add the String or append the string to the end of the list\\n            else{\\n                map.put(key, new ArrayList<>()); // If key not present then initialize the ArrayList \\n                map.get(key).add(s); // and add the Perticular String to that key.\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1250146,
                "title": "python3-sorted-str-solution-o-n-klogk-time-o-nk-space",
                "content": "Please comment if you have any suggestions or need a clear explanation, I promise I will respond!\\n\\nAlso, please upvote if this was at all helpful :)\\n\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_dict = {}\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            strs_dict[sorted_word] = strs_dict.get(sorted_word, []) + [word]\\n        return strs_dict.values()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        strs_dict = {}\\n        for word in strs:\\n            sorted_word = \\'\\'.join(sorted(word))\\n            strs_dict[sorted_word] = strs_dict.get(sorted_word, []) + [word]\\n        return strs_dict.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070582,
                "title": "js-6-lines-of-code-99-9-faster-the-ultimate-solution",
                "content": "```\\nconst groupAnagrams = function (strs) {\\n    const map = new Map();\\n\\n    strs.forEach(v => {\\n        const key = v.split(\\'\\').sort().join(\\'\\');\\n        map.has(key) ? map.set(key, [...map.get(key), v]) : map.set(key, [v]);\\n    })\\n\\n    return [...map.values()];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst groupAnagrams = function (strs) {\\n    const map = new Map();\\n\\n    strs.forEach(v => {\\n        const key = v.split(\\'\\').sort().join(\\'\\');\\n        map.has(key) ? map.set(key, [...map.get(key), v]) : map.set(key, [v]);\\n    })\\n\\n    return [...map.values()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054435,
                "title": "kotlin",
                "content": "```\\n   fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        val map = mutableMapOf<String, MutableList<String>>()\\n        strs.forEach {\\n            val key = it.toCharArray().sorted().joinToString(\"\")\\n            if (!map.containsKey(key)) map[key] = mutableListOf()\\n            map[key]?.add(it)\\n        }\\n\\n        return map.values.toList()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n   fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        val map = mutableMapOf<String, MutableList<String>>()\\n        strs.forEach {\\n            val key = it.toCharArray().sorted().joinToString(\"\")\\n            if (!map.containsKey(key)) map[key] = mutableListOf()\\n            map[key]?.add(it)\\n        }\\n\\n        return map.values.toList()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442430,
                "title": "c-linq-solution",
                "content": "```\\n  public class Solution\\n    {\\n        public IList<IList<string>> GroupAnagrams(string[] strs)\\n        {\\n            return new List<IList<string>>(strs.GroupBy(x => x.Customehashcode()).Select(grp => grp.ToList()));\\n        }\\n    }\\n\\n    static class ExtensionMethods\\n    {\\n        public static string Customehashcode(this string s)\\n        {\\n            int[] hashset = new int[26];\\n            for (int i = 0; i < s.Length; i++) {\\n                hashset[s[i] - \\'a\\'] = hashset[s[i] - \\'a\\'] + 1;\\n            }\\n\\n            return string.Join(\"\", hashset);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public class Solution\\n    {\\n        public IList<IList<string>> GroupAnagrams(string[] strs)\\n        {\\n            return new List<IList<string>>(strs.GroupBy(x => x.Customehashcode()).Select(grp => grp.ToList()));\\n        }\\n    }\\n\\n    static class ExtensionMethods\\n    {\\n        public static string Customehashcode(this string s)\\n        {\\n            int[] hashset = new int[26];\\n            for (int i = 0; i < s.Length; i++) {\\n                hashset[s[i] - \\'a\\'] = hashset[s[i] - \\'a\\'] + 1;\\n            }\\n\\n            return string.Join(\"\", hashset);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376880,
                "title": "fast-and-clean-solution-python",
                "content": "The main ideas are:\\n- Use a dictionary type to create the resulting list of lists. Use as many keys as anagram groups there are.\\n- Intuitively, we will use the sorted words as the keys of our dictionary. Thus, all members of an anagram group will share the same key. \\n- As **keys must be of a hashable type** and the output of `sorted` is a list, we need to convert it to an immutable type. Joining the output before appending - **sorting splits the string into a list of individual characters** - will do just that by converting it to a string.\\n- By using `defaultdict`, whenever we try to append a value to an innexistent key it will return an empty list and concatenate it with the given value i.e. `[] + [w] = [w]`.\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]: \\n        d = collections.defaultdict(list)\\n        for w in strs:\\n            d[\\'\\'.join(sorted(w))].append(w)\\n        return d.values()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]: \\n        d = collections.defaultdict(list)\\n        for w in strs:\\n            d[\\'\\'.join(sorted(w))].append(w)\\n        return d.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152243,
                "title": "go-solution",
                "content": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    groups := make(map[string][]string)\\n    for _, str := range strs {\\n        b := []byte(str)\\n        sort.Slice(b, func(i, j int) bool {\\n            return b[i] < b[j]\\n        })\\n        key := string(b)\\n        groups[key] = append(groups[key], str)\\n    }\\n    \\n    ret := make([][]string, 0, len(groups))\\n    for _, v := range groups {\\n        ret = append(ret, v)        \\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc groupAnagrams(strs []string) [][]string {\\n    groups := make(map[string][]string)\\n    for _, str := range strs {\\n        b := []byte(str)\\n        sort.Slice(b, func(i, j int) bool {\\n            return b[i] < b[j]\\n        })\\n        key := string(b)\\n        groups[key] = append(groups[key], str)\\n    }\\n    \\n    ret := make([][]string, 0, len(groups))\\n    for _, v := range groups {\\n        ret = append(ret, v)        \\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19218,
                "title": "c-9-lines-28ms-92-35",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>>res;\\n        unordered_map<string, vector<string>>m;\\n        for(auto s: strs){\\n            string tmp = s;\\n            sort(tmp.begin(), tmp.end());\\n            m[tmp].push_back(s);\\n        }\\n        for(auto x: m) res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>>res;\\n        unordered_map<string, vector<string>>m;\\n        for(auto s: strs){\\n            string tmp = s;\\n            sort(tmp.begin(), tmp.end());\\n            m[tmp].push_back(s);\\n        }\\n        for(auto x: m) res.push_back(x.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19375,
                "title": "u3010python-u3011beating-86-solution-with-a-defaultdict",
                "content": "We build a dictionary to store the strings, where the key should be \"characters where order does not matter\". \\n\\nThe easiest way to achieve that is to use`''.join(sorted(my_string))`, where `sorted()` kills the order of charcters and `join()` hashable the list.\\n\\n\\n    from collections improt defaultdict\\n    def groupAnagrams(self, strs):\\n\\n        dic = defaultdict(list)\\n        for string in strs:\\n                dic[''.join(sorted(string))] += [string]\\n\\n        return [value for key, value in dic.items()]",
                "solutionTags": [
                    "Python"
                ],
                "code": "We build a dictionary to store the strings, where the key should be \"characters where order does not matter\". \\n\\nThe easiest way to achieve that is to use`''.join(sorted(my_string))`, where `sorted()` kills the order of charcters and `join()` hashable the list.\\n\\n\\n    from collections improt defaultdict\\n    def groupAnagrams(self, strs):\\n\\n        dic = defaultdict(list)\\n        for string in strs:\\n                dic[''.join(sorted(string))] += [string]\\n\\n        return [value for key, value in dic.items()]",
                "codeTag": "Python3"
            },
            {
                "id": 19398,
                "title": "49-group-anagrams-cpp-solution",
                "content": "    // 49. Group Anagrams\\n    // https://leetcode.com/problems/anagrams/\\n    class Solution {\\n    public:\\n    \\tvector<vector<string>> groupAnagrams(const vector<string>& strs) {\\n    \\t\\tvector<vector<string>> result;\\n    \\t\\tunordered_map<string, vector<string>> hashmap;\\n    \\t\\tfor(const auto& i : strs){\\n    \\t\\t\\tstring s = i;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\thashmap[s].push_back(i);\\n    \\t\\t}\\n    \\t\\tfor(const auto& i : hashmap){\\n    \\t\\t\\tvector<string> s = i.second;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t}\\n    \\t\\treturn result;\\t\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<string>> groupAnagrams(const vector<string>& strs) {\\n    \\t\\tvector<vector<string>> result;\\n    \\t\\tunordered_map<string, vector<string>> hashmap;\\n    \\t\\tfor(const auto& i : strs){\\n    \\t\\t\\tstring s = i;\\n    \\t\\t\\tsort(s.begin(), s.end());\\n    \\t\\t\\thashmap[s].push_back(i);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3862253,
                "title": "easy-java-solution-beats-95-with-explanation",
                "content": "# Approach\\n*This Java code is an implementation of a function groupAnagrams that takes an array of strings strs as input and groups the anagrams together. Anagrams are words that have the same characters but in a different order.*\\n\\n##### Let\\'s go through the code step by step:\\n\\n1. Create a HashMap called hm, where the key is a sorted string representation of each word (anagram), and the value is a list of strings representing the anagrams.\\n\\n2. Iterate through each string in the strs array.\\n\\n3. Convert the current string strs[i] to a character array arr.\\n\\n4. Sort the character array arr using Arrays.sort(arr). This will arrange the characters in ascending order, making anagrams have the same sorted representation.\\n\\n5. Convert the sorted character array arr back to a string ch using String.valueOf(arr).\\n\\n6. Check if the hm already contains the key ch. If yes, then it means we have already encountered an anagram of the current string. We get the corresponding list of anagrams using hm.get(ch) and add the current string strs[i] to that list. Then, we update the hm with the updated list.\\n\\n7. If the hm does not contain the key ch, it means we have not encountered this anagram before. In that case, we create a new list, add the current string strs[i] to it, and put it in the hm with the key ch.\\n\\n8. After processing all strings in the strs array, we have a hashmap hm with keys as sorted anagrams and values as lists of strings containing the anagrams.\\n\\n9. Create a new List called st to store the final result.\\n\\n10. Iterate through each entry in the hm using a for-each loop (for (Map.Entry<String,List<String>> mapElement : hm.entrySet())).\\n\\n11. Get the value (list of anagrams) corresponding to the current key (sorted anagram) using mapElement.getValue() and add it to the st list.\\n\\n12. After iterating through all entries in the hm, the st list will contain lists of anagrams grouped together.\\n\\n13. Return the st list, which contains the groups of anagrams.\\n\\nThe overall time complexity of this solution is O(N * K * log K), where N is the number of strings in the input array strs, and K is the maximum length of a string in strs. The reason for this complexity is that we are sorting each string, which takes O(K * log K) time, and we do this for each of the N strings in the array.\\n\\n# Complexity\\nLet\\'s analyze the time and space complexity of the given solution:\\n\\n**Time Complexity**:\\n\\n1. The first loop iterates through each string in the strs array. This loop has a time complexity of O(N), where N is the number of strings in the array.\\n2. Inside the loop, we convert each string to a character array and then sort it using Arrays.sort(arr). Sorting takes O(K * log K) time, where K is the maximum length of a string in the array.\\n3. For each iteration of the loop, we perform sorting, which contributes O(K * log K) time complexity.\\n4. The second loop iterates through the hm hashmap, which has at most N entries (N unique anagram keys).\\n5. Inside this loop, we add each list of anagrams to the final result list. This operation takes O(M) time, where M is the number of anagrams for each key (can vary but is overall bounded by N).\\nPutting it all together, the overall time complexity is:\\n\\nO(N) * (O(K * log K) + O(M)) = O(N * K * log K + N * M)\\n\\nIn the worst case, when all the strings in the array are anagrams of each other, M can be equal to N (each key in the hashmap has a list of N anagrams). In such cases, the time complexity simplifies to:\\n\\nO(N * K * log K + N * N) = O(N^2 + N * K * log K)\\n\\nHowever, it\\'s important to note that the average case time complexity can be much better since the distribution of anagrams and the lengths of strings can vary.\\n\\n**Space Complexity:**\\n\\nThe space complexity of the given code can be analyzed as follows:\\n\\n* **HashMap Storage**: The primary data structure used in the code is a HashMap (hm) to store the anagram groups. In the worst case, where there are no anagrams and each string is unique, the HashMap would store all the input strings. Therefore, the space complexity due to the HashMap is O(n), where n is the number of input strings.\\n\\n* **Lists in HashMap**: Each entry in the HashMap stores a list of strings. In the worst case, again when there are no anagrams and each string is unique, the total space used by all the lists would be O(n), as each string would be in its own list.\\n\\n* **Final List of Lists**: The st list of lists is created to store the grouped anagrams. In the worst case, where there are no anagrams and each string is unique, this list would also use O(n) space.\\n\\nCombining all these factors, the overall space complexity of the code is O(n), where n is the number of input strings. This is because the HashMap and the final list are the primary data structures that scale with the input size, and their combined space usage dominates the space complexity. \\n\\n\\n\\n\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>>hm = new HashMap<>();\\n        for(int i = 0;i<strs.length;i++){\\n            char[] arr = strs[i].toCharArray();\\n            Arrays.sort(arr);\\n            String ch = String.valueOf(arr);\\n            if(hm.containsKey(ch)){\\n                List<String>s = hm.get(ch);\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n            else{\\n                List<String>s = new ArrayList<String>();\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n\\n        }\\n        List<List<String>> st = new ArrayList<>();\\n        \\n        for (Map.Entry<String,List<String>> mapElement : hm.entrySet()) {\\n            \\n \\n            st.add(mapElement.getValue());\\n            \\n        }\\n        return st;\\n        \\n    }\\n}\\n```\\n\\n# please upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>>hm = new HashMap<>();\\n        for(int i = 0;i<strs.length;i++){\\n            char[] arr = strs[i].toCharArray();\\n            Arrays.sort(arr);\\n            String ch = String.valueOf(arr);\\n            if(hm.containsKey(ch)){\\n                List<String>s = hm.get(ch);\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n            else{\\n                List<String>s = new ArrayList<String>();\\n                s.add(strs[i]);\\n                hm.put(ch,s);\\n            }\\n\\n        }\\n        List<List<String>> st = new ArrayList<>();\\n        \\n        for (Map.Entry<String,List<String>> mapElement : hm.entrySet()) {\\n            \\n \\n            st.add(mapElement.getValue());\\n            \\n        }\\n        return st;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697942,
                "title": "python-beats-99-38",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        answer = defaultdict(list)\\n        for word in strs:\\n            answer[\"\".join(sorted(word))].append(word)\\n        return list(answer.values())\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        answer = defaultdict(list)\\n        for word in strs:\\n            answer[\"\".join(sorted(word))].append(word)\\n        return list(answer.values())\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520194,
                "title": "python-o-n-solution",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorted anagrams string will always be equal.\\nHence, create a hash_map where key will the sorted string.\\nAdd current string if its key is present, other wise create a new entry.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nAs, first we are traversing over the given list.\\nFor each list sorting and join operation will take constant time as its given string size will be max of 100 characters.\\n\\n- Space complexity:\\n$$O(n)$$\\nAs, in worst case all unique string in given list. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Hash Map\\n        hash_map = {}\\n        # Iterate over each string in given list\\n        for s in strs:\\n            # Hash function to get key\\n            key = \\'\\'.join(sorted(s))\\n            # CASE: If key is in hash map\\n            if key in hash_map:\\n                hash_map[key].append(s)\\n            # CASE: If key is not in hash map\\n            else:\\n                hash_map[key] = [s]\\n        return list(hash_map.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        # Hash Map\\n        hash_map = {}\\n        # Iterate over each string in given list\\n        for s in strs:\\n            # Hash function to get key\\n            key = \\'\\'.join(sorted(s))\\n            # CASE: If key is in hash map\\n            if key in hash_map:\\n                hash_map[key].append(s)\\n            # CASE: If key is not in hash map\\n            else:\\n                hash_map[key] = [s]\\n        return list(hash_map.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161171,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>>mp;\\n        vector<vector<string>>ans;\\n        for(int i=0;i<strs.size();i++){\\n                string t=strs[i];\\n                sort(t.begin(),t.end());\\n                mp[t].push_back(strs[i]);\\n            \\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nf = open(\\'user.out\\', \\'w\\'); [print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit(); \\n\\nf = open(\"user.out\", \"w\");[print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit()\\n```\\n\\n```Java []\\nimport java.util.AbstractList;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        return new AbstractList<List<String>>(){\\n            \\n            List<List<String>> result;\\n            public List<String> get(int index) {\\n                if (result == null) init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null) init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s: strs) {\\n                    char[] keys = new char[26];\\n                    for (int i = 0; i < s.length(); i++)\\n                        keys[s.charAt(i) - \\'a\\']++;\\n\\n                    String key = new String(keys);\\n                    System.out.println(key);\\n                    List<String> list = map.get(key);\\n                    if (list == null) map.put(key, new ArrayList<>());\\n                    map.get(key).add(s);\\n                }\\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>>mp;\\n        vector<vector<string>>ans;\\n        for(int i=0;i<strs.size();i++){\\n                string t=strs[i];\\n                sort(t.begin(),t.end());\\n                mp[t].push_back(strs[i]);\\n            \\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nf = open(\\'user.out\\', \\'w\\'); [print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit(); \\n\\nf = open(\"user.out\", \"w\");[print(json.dumps(list(reduce(lambda res, s: res[str(sorted(s))].append(s) or res, json.loads(line.rstrip()), defaultdict(list)).values())), file=f) for line in stdin];exit()\\n```\n```Java []\\nimport java.util.AbstractList;\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        \\n        Map<String, List<String>> map = new HashMap<>();\\n        \\n        return new AbstractList<List<String>>(){\\n            \\n            List<List<String>> result;\\n            public List<String> get(int index) {\\n                if (result == null) init();\\n                return result.get(index);\\n            }\\n\\n            public int size() {\\n                if (result == null) init();\\n                return result.size();\\n            }\\n\\n            private void init() {\\n                for (String s: strs) {\\n                    char[] keys = new char[26];\\n                    for (int i = 0; i < s.length(); i++)\\n                        keys[s.charAt(i) - \\'a\\']++;\\n\\n                    String key = new String(keys);\\n                    System.out.println(key);\\n                    List<String> list = map.get(key);\\n                    if (list == null) map.put(key, new ArrayList<>());\\n                    map.get(key).add(s);\\n                }\\n                result = new ArrayList<>(map.values());\\n            }\\n        };\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056211,
                "title": "typescript-solution-beats-98-on-execution-time-based-on-the-platform-results",
                "content": "# Code\\n```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n\\tconst map = new Map<string, string[]>();\\n\\tconst getKey = (s: string) => s.split(\"\").sort().join(\"\");\\n\\n\\tstrs.forEach((s) => {\\n\\t\\tconst k = getKey(s);\\n\\t\\tmap.set(k, [...(map.get(k) || []), s]);\\n\\t});\\n\\n\\treturn [...map.values()];\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction groupAnagrams(strs: string[]): string[][] {\\n\\tconst map = new Map<string, string[]>();\\n\\tconst getKey = (s: string) => s.split(\"\").sort().join(\"\");\\n\\n\\tstrs.forEach((s) => {\\n\\t\\tconst k = getKey(s);\\n\\t\\tmap.set(k, [...(map.get(k) || []), s]);\\n\\t});\\n\\n\\treturn [...map.values()];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994029,
                "title": "c-solution",
                "content": "# Intuition\\nHashing\\n\\n# Approach\\nUsing hashing and sorting of each string\\n\\n# Complexity\\n- Time complexity:\\nn*m*log(m) where m is size of each string and n is size of vector of string\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n=strs.size();\\n        unordered_map<string,vector<string> > mp;\\n        for(int i=0;i<n;i++){\\n            string str=strs[i];\\n            sort(str.begin(),str.end());\\n            mp[str].push_back(strs[i]);\\n\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it: mp){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        int n=strs.size();\\n        unordered_map<string,vector<string> > mp;\\n        for(int i=0;i<n;i++){\\n            string str=strs[i];\\n            sort(str.begin(),str.end());\\n            mp[str].push_back(strs[i]);\\n\\n        }\\n        vector<vector<string>> ans;\\n        for(auto it: mp){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845888,
                "title": "fully-explained-every-line-of-code-re-arrange-and-group-o-n-java",
                "content": "# Approach : Re-Arramging characters and grouping the anagrams\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)*O(k logk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *If you find this solution easy to understand and helpful, then please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D*\\n\\n# Code (Explained in Comments)\\n```\\nclass Solution \\n{\\n    public List<List<String>> groupAnagrams(String[] strs) \\n    {\\n        HashMap<String,List<String>> map=new HashMap<>();//declaring a HashMap\\n        for(String s:strs)//iterate over string\\n        {\\n            char[] c=s.toCharArray();//storing characters in array\\n            Arrays.sort(c);//sorting the characters\\n            String key=new String(c);//creating key\\n            map.computeIfAbsent(key,k ->new ArrayList()).add(s);\\n            //if key is not present then create new ArrayList and add string\\n        }\\n        return new ArrayList(map.values());//returning ArrayList of map values\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<List<String>> groupAnagrams(String[] strs) \\n    {\\n        HashMap<String,List<String>> map=new HashMap<>();//declaring a HashMap\\n        for(String s:strs)//iterate over string\\n        {\\n            char[] c=s.toCharArray();//storing characters in array\\n            Arrays.sort(c);//sorting the characters\\n            String key=new String(c);//creating key\\n            map.computeIfAbsent(key,k ->new ArrayList()).add(s);\\n            //if key is not present then create new ArrayList and add string\\n        }\\n        return new ArrayList(map.values());//returning ArrayList of map values\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289230,
                "title": "c-easy-solution-for-indians-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& s) {\\n       vector<vector<string>>ans; // edge cases\\n      if(s.size()==1)  return {{s[0]}};\\n      unordered_map<string,vector<string>>m; // key value is sorted string and vector store the anagrams\\n      for(auto i:s) {\\n        string str=i;\\n        sort(i.begin(),i.end());\\n        m[i].push_back(str);\\n      }\\n      for(auto i:m)\\n        ans.push_back(i.second); \\n    return ans;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& s) {\\n       vector<vector<string>>ans; // edge cases\\n      if(s.size()==1)  return {{s[0]}};\\n      unordered_map<string,vector<string>>m; // key value is sorted string and vector store the anagrams\\n      for(auto i:s) {\\n        string str=i;\\n        sort(i.begin(),i.end());\\n        m[i].push_back(str);\\n      }\\n      for(auto i:m)\\n        ans.push_back(i.second); \\n    return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990013,
                "title": "java-c-python-javascript-kotlin-swift-2line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\ndef anagrams(self, strs):\\n        count = collections.Counter([tuple(sorted(s)) for s in strs])\\n        return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n```\\n\\n***JavaScript***\\n```\\n  var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };\\n```\\n\\n***Kotlin***\\n```\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.map { it.value }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String,List<String>> map=new HashMap<>();\\n        \\n        for(int i=0;i<strs.length;i++){\\n            String s1=strs[i];\\n            char[] arr=s1.toCharArray();\\n            Arrays.sort(arr);\\n            String str=new String(arr);\\n            \\n            if(map.containsKey(str)){\\n                map.get(str).add(s1); \\n            }else{\\n                map.put(str,new ArrayList<>());\\n                map.get(str).add(s1);\\n            }\\n        }\\n        return new ArrayList<>(map.values());\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string, vector<string>> mp;\\n        for(auto i: strs){\\n            string temp = i;\\n            sort(temp.begin(), temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        \\n        vector<vector<string>> res;\\n        for(auto i: mp){\\n            res.push_back(i.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\ndef anagrams(self, strs):\\n        count = collections.Counter([tuple(sorted(s)) for s in strs])\\n        return filter(lambda x: count[tuple(sorted(x))]>1, strs)\\n```\n```\\n  var groupAnagrams = function (strs) {\\n      const map = {};\\n      const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\\n      strs.forEach(str => {\\n        let prod = str.split(\"\").reduce((r, c) => r * primes[c.charCodeAt() - 97], 1);\\n        map[prod] ? map[prod].push(str) : map[prod] = [str];\\n      });\\n      return Object.values(map);\\n    };\\n```\n```\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.map { it.value }\\n}\\n```\n```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var map: [String: [String]] = [:]\\n        var res: [[String]] = []\\n\\n        \\n        func sort(_ str: String) -> String {\\n            var chars = Array(str)\\n            let sorted = chars.sorted()\\n            var string = \"\"\\n            for c in sorted { string += String(c) }\\n            return string\\n        }\\n\\n        for str in strs {\\n            let sorted_str = sort(str)\\n            if let _ = map[sorted_str] {\\n                map[sorted_str]?.append(str)\\n            } else {\\n                map[sorted_str] = [str]\\n            }\\n        }\\n        for (_, value) in map { res.append(value) }        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967413,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mp;\\n        for(int i=0;i<strs.size();i++){\\n            string temp=strs[i];\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x:mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>> mp;\\n        for(int i=0;i<strs.size();i++){\\n            string temp=strs[i];\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(strs[i]);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto x:mp){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904401,
                "title": "kotlin-one-liner",
                "content": "```kotlin\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.values.toList()\\n}\\n```\\nExplanation:\\nit here is a String, `it.toCharArray().sorted()` gives us like a signature. `eat`, `tea`, `ate` will all have the same signature: `[a, e, t]`.\\nOnce we figure out the signatures then we can group words that have same signatures, using Kotlin\\'s `groupBy`.",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nfun groupAnagrams(strs: Array<String>): List<List<String>> {\\n    return strs.groupBy { it.toCharArray().sorted() }.values.toList()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799276,
                "title": "hash-map-sorting-c-easy-solution-with-well-explained-comments",
                "content": "***If you find it helpful, please do upvote <3***\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string> &strs)\\n    {\\n        unordered_map<string, vector<string>> hash; // hash[string] = {anagramic set of that string}\\n        vector<vector<string>> ans;\\n        for (auto str : strs)\\n        {\\n            string tmp = str;\\n            sort(begin(tmp), end(tmp));\\n            if (hash.find(tmp) != end(hash)) // If anagram of current string has been found previously\\n                hash[tmp].push_back(str); // Push current string into that anagramic set\\n            else\\n                hash.insert({tmp, {str}}); // Otherwise create a new entry into the hash map\\n        }\\n        for (auto [k, v] : hash)\\n            ans.push_back(v); // Push each anagramic set into the answer vector\\n        return ans;\\n    }\\n};\\n```\\n***Any suggestions are welcome into the comment section\\nThank you !!***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string> &strs)\\n    {\\n        unordered_map<string, vector<string>> hash; // hash[string] = {anagramic set of that string}\\n        vector<vector<string>> ans;\\n        for (auto str : strs)\\n        {\\n            string tmp = str;\\n            sort(begin(tmp), end(tmp));\\n            if (hash.find(tmp) != end(hash)) // If anagram of current string has been found previously\\n                hash[tmp].push_back(str); // Push current string into that anagramic set\\n            else\\n                hash.insert({tmp, {str}}); // Otherwise create a new entry into the hash map\\n        }\\n        for (auto [k, v] : hash)\\n            ans.push_back(v); // Push each anagramic set into the answer vector\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734998,
                "title": "c-solution-easy-to-understand-single-loop",
                "content": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& str) \\n    {\\n        unordered_map<string,vector<string>> mp;\\n        for(auto i:str)\\n        {\\n            string temp=i;\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        vector<vector<string>> res;\\n        for(auto j:mp)\\n            res.push_back(j.second);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<string>> groupAnagrams(vector<string>& str) \\n    {\\n        unordered_map<string,vector<string>> mp;\\n        for(auto i:str)\\n        {\\n            string temp=i;\\n            sort(temp.begin(),temp.end());\\n            mp[temp].push_back(i);\\n        }\\n        vector<vector<string>> res;\\n        for(auto j:mp)\\n            res.push_back(j.second);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398976,
                "title": "explanation-w-images-using-map-c-python-java",
                "content": "**Pre-requisite:**\\n*What is an Anagram?*\\nTwo strings are said to be anagrams of each other if they are made up of the same characters with same frequency. For example: the word `LISTEN` and `SILENT` are anagrams. They are composed of the letters `E, I, L, N, S, T`.\\n`Insight-` The input is only `lowercase aplhabets`\\n\\n\\n**Algorithm:**\\n`Technique` - Group By Sorting\\n*SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/9e9dee48-ad03-4047-8a66-b11e8dbcac7f_1628753485.5853918.png)\\n*SORTED SAMPLE CASE-*\\n![image](https://assets.leetcode.com/users/images/12e377a3-1779-4e7c-ba97-f19fb5d390db_1628753533.013706.png)\\n* Once we have made this observation, we create a map for the same where the `key` will be the sorted string, and the `value` would be the list of all the strings that are anagrams.\\n* After iteration over all the strings, we get the desired group of anagrams\\n* The time complexity of this approach depends on the sorting technique you use to sort the strings.\\n\\n**Solution:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```\\n**TIME COMPLEXITY - O(N*KlogK)**, where k is the length of the largest string. \\n* This is because we are sorting string in every iteration.\\n* It would be **different for different sorting techniques** for e.g. `O(N*K) for Counting Sort`\\n\\n**SPACE COMPLEXITY - O(N*K)**\\n\\n\\n**SCRAP APPROACH:**\\n`Brute Force-` Will give TLE on Large Testcases\\n* Iterate over each string in the input array.\\n* For each string, check with each element of the array if they are anagrams.\\n* If it is an anagram, add it to a group.\\n* Else, move the string to a different group\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans ;\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<string> temp = strs ;\\n        map<string, vector<string>> mp;\\n        for(int i=0; i < temp.size() ; i++)\\n\\t\\t{\\n            string t = temp[i];\\n            sort(temp[i].begin(), temp[i].end());\\n            mp[temp[i]].push_back(t);\\n        }\\n        for(auto i:mp) ans.push_back(i.second);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        map_dict = {}\\n        for i,string in enumerate(strs):\\n            tmp = (\"\").join(sorted(string))\\n            try:\\n                map_dict[tmp].append(strs[i])\\n            except:\\n                map_dict[tmp] = [strs[i]]\\n\\n        return list(map_dict.values())\\n```\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String ,List<String>> map = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char[] c = strs[i].toCharArray();\\n            Arrays.sort(c) ;\\n            String temp = String.valueOf(c);\\n            if(map.containsKey(temp))\\n            {\\n                List<String> list = map.get(temp);\\n                list.add(strs[i]);\\n                map.put(temp,list);\\n            }\\n            else\\n            { \\n                List<String> list = new ArrayList<>();\\n                list.add(strs[i]);\\n                map.put(temp, list);\\n            }            \\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        ans.addAll(map.values());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312470,
                "title": "quick-and-easy-solution-c-using-unordered-map",
                "content": "Intuition : Every anagram when sorted read the same word\\nSo, for every word we encounter, let\\'s sort it and see which bucket it belongs to \\nExamples ; {\"eat, \"tea\"}\\nIf we take, \"eat\" and sort it, we get \"aet\" and now we attach the word \"eat\" to \"aet\" as it is an anagram of it\\nWe keep repeating this process and once we are done iterating throught the array, we now iterate through the hashmap and push_back the vector that contains all the anagrams for all keys possible. \\nWe then return the answer. \\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> answer;\\n        unordered_map<string, vector<string>> mpp;\\n        for(string str:strs)\\n        {\\n            string s = str;\\n            sort(s.begin(), s.end());\\n            mpp[s].push_back(str);\\n        }\\n        for(auto const& it : mpp)\\n        {\\n            answer.push_back(it.second);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\nPro tip : the `auto const&` in the iteration step of the hashmap tends to increase the speed compared to a `auto it`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> answer;\\n        unordered_map<string, vector<string>> mpp;\\n        for(string str:strs)\\n        {\\n            string s = str;\\n            sort(s.begin(), s.end());\\n            mpp[s].push_back(str);\\n        }\\n        for(auto const& it : mpp)\\n        {\\n            answer.push_back(it.second);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294258,
                "title": "java-solution-99-02-faster-easy-code-explained-in-comments",
                "content": "# Please Upvote if you find it helpful :)\\nsubmit twice if you get slower run time\\n```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result =new ArrayList<>();\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<strs.length;i++){\\n            String s=sortStr(strs[i]);// sort the string |  every anagram will return same string\\n            if(!map.containsKey(s)){\\n                map.put(s,new ArrayList<String>()); // psuh that sorted string as key \\n            }\\n            map.get(s).add(strs[i]);// add in the list  \\n        }\\n        for(List<String> list : map.values()){\\n            result.add(list);\\n        }\\n        return result;\\n    }\\n    public String sortStr(String s){\\n        char c[]=s.toCharArray();\\n        Arrays.sort(c);\\n        String s1=new String(c);\\n        return s1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result =new ArrayList<>();\\n        HashMap<String,List<String>> map=new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<strs.length;i++){\\n            String s=sortStr(strs[i]);// sort the string |  every anagram will return same string\\n            if(!map.containsKey(s)){\\n                map.put(s,new ArrayList<String>()); // psuh that sorted string as key \\n            }\\n            map.get(s).add(strs[i]);// add in the list  \\n        }\\n        for(List<String> list : map.values()){\\n            result.add(list);\\n        }\\n        return result;\\n    }\\n    public String sortStr(String s){\\n        char c[]=s.toCharArray();\\n        Arrays.sort(c);\\n        String s1=new String(c);\\n        return s1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036740,
                "title": "swift-without-sort",
                "content": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var s = [[Character:Int]: [String]]()\\n        strs.forEach {\\n            var k = [Character: Int]()\\n            $0.forEach { c in\\n                k[c, default: 0] += 1\\n            }\\n            s[k, default: []].append($0)\\n        }\\n        return Array(s.values)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func groupAnagrams(_ strs: [String]) -> [[String]] {\\n        var s = [[Character:Int]: [String]]()\\n        strs.forEach {\\n            var k = [Character: Int]()\\n            $0.forEach { c in\\n                k[c, default: 0] += 1\\n            }\\n            s[k, default: []].append($0)\\n        }\\n        return Array(s.values)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027473,
                "title": "java-solution-with-customized-java-objects-o-m-n-beat-98-93",
                "content": "Two strings are anagrams when their character counts are the same, e.g., \"eat\" is `{e:1, a:1, t:1}` and \"tea\" is `{e:1, a:1, t:1}`, so they are in the same group\\n\\nHowever the leetcode standard final solution is not ideal, as  you may notice, it stores a count inside a string, so that to present hashkey checking, however in most real world application, we usually create some customized java objects to perform these checking instead of call `toString()`, because `string.equals()` checking is just too slow for real application.\\n\\nSo this is an example we create a 26 characters customized java object and use it as the key to do hashmap lookup. And it\\'s really fast!\\n\\n```\\nclass Solution {\\n    class BitKey {\\n        // should use a set and get\\n        public final int[] bits;\\n        \\n        public BitKey(int[] bits) {\\n            this.bits = bits;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            // If the object is compared with itself then return true  \\n            if (o == this) {\\n                return true;\\n            }\\n\\n            /* Check if o is an instance of Complex or not\\n              \"null instanceof [type]\" also returns false */\\n            if (!(o instanceof BitKey)) {\\n                return false;\\n            }\\n\\n            // typecast o to Complex so that we can compare data members \\n            BitKey c = (BitKey) o;\\n            \\n            if (this.bits.length != c.bits.length) {\\n                return false;\\n            } else {\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    if (this.bits[i] != c.bits[i]){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        \\n        private Integer hash = null;\\n        @Override\\n        public int hashCode() {\\n            if (hash == null) {\\n                hash = 1;\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    hash += (29 << i) * this.bits[i];\\n                }\\n            }\\n            return hash;\\n        }\\n    }\\n    \\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<BitKey, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            BitKey count = getCounts(s);\\n            \\n            List<String> data = map.get(count);\\n            if (data == null) {\\n                data = new LinkedList<>();\\n                map.put(count, data);\\n            }\\n            data.add(s);\\n        }\\n        \\n        // convert to result\\n        return new ArrayList<List<String>>(map.values());\\n        \\n    }\\n    \\n    public BitKey getCounts(String s) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            int offset = s.charAt(i) - \\'a\\';\\n            counts[offset]++;\\n        }\\n        BitKey bitKey = new BitKey(counts);\\n        return bitKey;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class BitKey {\\n        // should use a set and get\\n        public final int[] bits;\\n        \\n        public BitKey(int[] bits) {\\n            this.bits = bits;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            // If the object is compared with itself then return true  \\n            if (o == this) {\\n                return true;\\n            }\\n\\n            /* Check if o is an instance of Complex or not\\n              \"null instanceof [type]\" also returns false */\\n            if (!(o instanceof BitKey)) {\\n                return false;\\n            }\\n\\n            // typecast o to Complex so that we can compare data members \\n            BitKey c = (BitKey) o;\\n            \\n            if (this.bits.length != c.bits.length) {\\n                return false;\\n            } else {\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    if (this.bits[i] != c.bits[i]){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        \\n        private Integer hash = null;\\n        @Override\\n        public int hashCode() {\\n            if (hash == null) {\\n                hash = 1;\\n                for (int i = 0; i < this.bits.length; i++) {\\n                    hash += (29 << i) * this.bits[i];\\n                }\\n            }\\n            return hash;\\n        }\\n    }\\n    \\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<BitKey, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            BitKey count = getCounts(s);\\n            \\n            List<String> data = map.get(count);\\n            if (data == null) {\\n                data = new LinkedList<>();\\n                map.put(count, data);\\n            }\\n            data.add(s);\\n        }\\n        \\n        // convert to result\\n        return new ArrayList<List<String>>(map.values());\\n        \\n    }\\n    \\n    public BitKey getCounts(String s) {\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            int offset = s.charAt(i) - \\'a\\';\\n            counts[offset]++;\\n        }\\n        BitKey bitKey = new BitKey(counts);\\n        return bitKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620612,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map <string, vector<string>> m;\\n        for (auto word : strs) {\\n            string temp = word;\\n            sort(temp.begin(), temp.end());\\n            m[temp].push_back(word);\\n        }\\n        vector<vector<string>> ans;\\n        ans.resize(m.size(), {});\\n        int i = 0;\\n        for (auto ele : m) {\\n            for (auto words : ele.second) {\\n                ans[i].push_back(words);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        map <string, vector<string>> m;\\n        for (auto word : strs) {\\n            string temp = word;\\n            sort(temp.begin(), temp.end());\\n            m[temp].push_back(word);\\n        }\\n        vector<vector<string>> ans;\\n        ans.resize(m.size(), {});\\n        int i = 0;\\n        for (auto ele : m) {\\n            for (auto words : ele.second) {\\n                ans[i].push_back(words);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351121,
                "title": "python-no-sort-solution",
                "content": "Use count every character\\'s position and number to identify the anagrams.\\n\\n```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for word in strs:\\n            count = [0] * 26\\n            for ch in word:\\n                count[ord(ch) - ord(\\'a\\')] += 1\\n            d[tuple(count)] = d.get(tuple(count), []) + [word]\\n        return list(d.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for word in strs:\\n            count = [0] * 26\\n            for ch in word:\\n                count[ord(ch) - ord(\\'a\\')] += 1\\n            d[tuple(count)] = d.get(tuple(count), []) + [word]\\n        return list(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334633,
                "title": "c-sort-the-string-and-use-it-as-the-key-of-anagrams-practice",
                "content": "I like to share my C# practice using sorting and then save all anagrams with the same key - sorted string. \\nIt is easy to prove that all anagrams will be the same string if all chars in the string are sorted by alphabetically order. \\n\\n\\n```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n         if(strs == null || strs.Length == 0){\\n\\t\\t        return new List<IList<String>>();\\n\\t        }\\n\\n\\t        var map = new Dictionary<String, List<String>>();\\n\\t        \\n\\t        foreach (String s in strs) {\\n\\t\\t        char[] ca = s.ToCharArray();\\n\\t\\t        Array.Sort(ca);\\n\\n\\t\\t        String keyStr = new string(ca);\\n\\t\\t        if(!map.ContainsKey(keyStr))\\n                {\\n\\t\\t\\t        map.Add(keyStr, new List<String>());\\n                }\\n\\n\\t\\t        map[keyStr].Add(s);\\n\\t        }\\t       \\n\\n\\t        return new List<IList<String>>(map.Values);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> GroupAnagrams(string[] strs) {\\n         if(strs == null || strs.Length == 0){\\n\\t\\t        return new List<IList<String>>();\\n\\t        }\\n\\n\\t        var map = new Dictionary<String, List<String>>();\\n\\t        \\n\\t        foreach (String s in strs) {\\n\\t\\t        char[] ca = s.ToCharArray();\\n\\t\\t        Array.Sort(ca);\\n\\n\\t\\t        String keyStr = new string(ca);\\n\\t\\t        if(!map.ContainsKey(keyStr))\\n                {\\n\\t\\t\\t        map.Add(keyStr, new List<String>());\\n                }\\n\\n\\t\\t        map[keyStr].Add(s);\\n\\t        }\\t       \\n\\n\\t        return new List<IList<String>>(map.Values);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316008,
                "title": "single-line-kotlin-solution-because-we-can",
                "content": "```\\nclass Solution {\\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        return strs.groupBy{ it.groupingBy{ it }.eachCount() }.values.toList()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun groupAnagrams(strs: Array<String>): List<List<String>> {\\n        return strs.groupBy{ it.groupingBy{ it }.eachCount() }.values.toList()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190917,
                "title": "javascript-es6-beats-100",
                "content": "```\\nvar groupAnagrams = function(strs) {\\n    if(strs.length == 0) return [];\\n    const result = new Map();\\n    const primes = [2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107];\\n    const getKey = str => {\\n        let key = 1;\\n        for(let i = 0; i < str.length; i++){\\n            key =  primes[str.charCodeAt(i) - 97] * key;\\n        }\\n        return key;\\n    }\\n    strs.forEach(w => {\\n        let key = getKey(w);\\n        if(result.has(key)) {\\n            result.get(key).push(w);\\n        } else {\\n            result.set(key,  [w]);\\n        }\\n       \\n    });\\n    return [...result.values()];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar groupAnagrams = function(strs) {\\n    if(strs.length == 0) return [];\\n    const result = new Map();\\n    const primes = [2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107];\\n    const getKey = str => {\\n        let key = 1;\\n        for(let i = 0; i < str.length; i++){\\n            key =  primes[str.charCodeAt(i) - 97] * key;\\n        }\\n        return key;\\n    }\\n    strs.forEach(w => {\\n        let key = getKey(w);\\n        if(result.has(key)) {\\n            result.get(key).push(w);\\n        } else {\\n            result.set(key,  [w]);\\n        }\\n       \\n    });\\n    return [...result.values()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148319,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for st in strs:\\n            s = \\'\\'.join(sorted(st))\\n            d[s] = d.get(s, []) + [st]\\n        return list(d.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupAnagrams(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}\\n        for st in strs:\\n            s = \\'\\'.join(sorted(st))\\n            d[s] = d.get(s, []) + [st]\\n        return list(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19213,
                "title": "my-ruby-solution",
                "content": "```\\ndef group_anagrams(strs)\\n    anagrams = Hash.new {|h, k| h[k] = []}\\n    \\n    strs.each do |str|\\n        sorted = str.chars.sort\\n        anagrams[sorted] << str\\n    end\\n    \\n    anagrams.values\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef group_anagrams(strs)\\n    anagrams = Hash.new {|h, k| h[k] = []}\\n    \\n    strs.each do |str|\\n        sorted = str.chars.sort\\n        anagrams[sorted] << str\\n    end\\n    \\n    anagrams.values\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 19350,
                "title": "7-lines-java-solution",
                "content": "I have to say java stream is really inefficient and slow, you can replace **computeIfAbsent** with conventional java code, but I use it because it makes my code short and clean, but it is really really slow:\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String str : strs) {\\n            char[] chars = str.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\\n        }\\n        return new ArrayList<>(map.values());\\n    }",
                "solutionTags": [],
                "code": "I have to say java stream is really inefficient and slow, you can replace **computeIfAbsent** with conventional java code, but I use it because it makes my code short and clean, but it is really really slow:\\n```\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String str : strs) {\\n            char[] chars = str.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);\\n        }\\n        return new ArrayList<>(map.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19400,
                "title": "easy-to-understand-java-solution-using-hashmaps-edited",
                "content": "    public class Solution {\\n       public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>>result= new ArrayList<>();\\n           Map<String,List<String>> map = new HashMap<String,List<String>>();\\n     \\n           for(String s:strs)\\n         {\\n               char[]c= s.toCharArray(); \\n               Arrays.sort(c);                  \\n         \\n         //all Anagrams will be the same string if sorted  (tea,eat -->aet) , which serves as our key\\n             \\n             String keyStr= String.valueOf(c);\\n             if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<String>());\\n             map.get(keyStr).add(s);\\n          }\\n     \\n      //All the key value entries are stored in an entrySet which helps us return those values that have a key corresponding to it\\n     \\n         for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n          \\n               List<String> values = entry.getValue();\\n\\n               //since we want lexicographic order of the result, we sort the list\\n               Collections.sort(values);               \\n\\n               result.add(values);\\n          }\\n\\n         return result;   \\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n       public List<List<String>> groupAnagrams(String[] strs) {\\n           List<List<String>>result= new ArrayList<>();\\n           Map<String,List<String>> map = new HashMap<String,List<String>>();\\n     \\n           for(String s:strs)\\n         {\\n               char[]c= s.toCharArray(); \\n               Arrays.sort(c);                  \\n         \\n         //all Anagrams will be the same string if sorted  (tea,eat -->aet) , which serves as our key\\n             \\n             String keyStr= String.valueOf(c);\\n             if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList<String>());\\n             map.get(keyStr).add(s);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 19422,
                "title": "sharing-my-simple-76ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n            vector<vector<string>> result;\\n            unordered_map<string, vector<string>> myMap;\\n            string temp;\\n            for(int i=0; i<strs.size(); i++)\\n            {\\n                temp = strs[i];\\n                sort(temp.begin(), temp.end());\\n                myMap[temp].push_back(strs[i]);\\n            }\\n            \\n            for(auto x=myMap.begin(); x!=myMap.end(); x++)\\n            {\\n                vector<string> tmp = x->second;\\n                sort(tmp.begin(), tmp.end());\\n                result.push_back(tmp);\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n            vector<vector<string>> result;\\n            unordered_map<string, vector<string>> myMap;\\n            string temp;\\n            for(int i=0; i<strs.size(); i++)\\n            {\\n                temp = strs[i];\\n                sort(temp.begin(), temp.end());\\n                myMap[temp].push_back(strs[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 19424,
                "title": "24ms-short-java-solution",
                "content": "    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ar = s.toCharArray();\\n            Arrays.sort(ar);\\n            String sorted = String.valueOf(ar);\\n            List<String> list = map.get(sorted);\\n            if (list == null) list = new ArrayList<String>();\\n            list.add(s);\\n            map.put(sorted, list);\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (List<String> l : map.values()) {\\n            Collections.sort(l);\\n            res.add(l);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<String>> groupAnagrams(String[] strs) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] ar = s.toCharArray();\\n            Arrays.sort(ar);\\n            String sorted = String.valueOf(ar);\\n            List<String> list = map.get(sorted);\\n            if (list == null) list = new ArrayList<String>();\\n            list.add(s);\\n            map.put(sorted, list);\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (List<String> l : map.values()) {\\n            Collections.sort(l);\\n            res.add(l);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 19415,
                "title": "java-22-ms-and-20-lines-36-ms-and-11-lines-172-ms-and-9-lines-d",
                "content": "~22 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = new char[26];\\n            for (int i = 0; i < s.length(); i++)\\n                keyArr[s.charAt(i) - 'a']++;\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else {\\n                List<String> val = new ArrayList<>();\\n                val.add(s);\\n                map.put(key, val);\\n            }\\n        }\\n        for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n            List<String> val = entry.getValue();\\n            Collections.sort(val);\\n            res.add(val);\\n        }\\n        return res;\\n    }\\n\\n~36 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = s.toCharArray();\\n            Arrays.sort(keyArr);\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else map.put(key, new ArrayList<>(Arrays.asList(s)));\\n        }\\n        for (List<String> val : map.values())\\n            Collections.sort(val);\\n        return new ArrayList<List<String>>(map.values());\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "~22 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = new char[26];\\n            for (int i = 0; i < s.length(); i++)\\n                keyArr[s.charAt(i) - 'a']++;\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else {\\n                List<String> val = new ArrayList<>();\\n                val.add(s);\\n                map.put(key, val);\\n            }\\n        }\\n        for (Map.Entry<String, List<String>> entry : map.entrySet()) {\\n            List<String> val = entry.getValue();\\n            Collections.sort(val);\\n            res.add(val);\\n        }\\n        return res;\\n    }\\n\\n~36 ms\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for (String s : strs) {\\n            char[] keyArr = s.toCharArray();\\n            Arrays.sort(keyArr);\\n            String key = new String(keyArr);\\n            if (map.containsKey(key)) map.get(key).add(s);\\n            else map.put(key, new ArrayList<>(Arrays.asList(s)));\\n        }\\n        for (List<String> val : map.values())\\n            Collections.sort(val);\\n        return new ArrayList<List<String>>(map.values());\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564708,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565002,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1570544,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565940,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565941,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1841445,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1803102,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1576350,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571122,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1568872,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1564708,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565002,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1570544,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565940,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1565941,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1841445,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1803102,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1576350,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571122,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1568872,
                "content": [
                    {
                        "username": "htzfun",
                        "content": "What does it mean \"return all groups\"? But the return result is vector<string>? How can we return all groups? I mean, for example, we have such vector [\"dog\",\"cat\",\"god\",\"tac\"]. What should I return?"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "Return all groups means return a list of the groups, where each group is itself a list. So return a list of lists."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "you should return [ [\"dog\" , \"god\"] , [\"cat\", \"tac\"]]"
                    },
                    {
                        "username": "mahdy",
                        "content": "Why the output is list and not a list of list. What If there are multiple groups of anagrams?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Output is a 2D list"
                    },
                    {
                        "username": "goldsmithb",
                        "content": "The output is a list of lists."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "RUDOP"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of interview rounds of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "lance2k",
                        "content": "Hi francis, I\\'ve sent you a connection request on Linkedin. I just started leetcode, I want to join FAANG someday. I hope you could give me some advise. Thank you"
                    },
                    {
                        "username": "atul05kumar",
                        "content": "what will be the answer if there are more than one group of anagrams.\\neg: abc, cab, bca, dsa, asd, sad \\nhere there are two groups one is abc, cab, bca and the other one is dsa, asd, sad."
                    },
                    {
                        "username": "ranbir7",
                        "content": "Ummmm [[abc, cab,bca], [dsa, asd, sad]]"
                    },
                    {
                        "username": "SamMy89",
                        "content": "I found nice solution in Java in the internet, and it worked. **However**, I really don't understand the question. It says  \\n\\n> return all **groups** of strings that are anagrams.\\n\\ni.e. if we have two groups of strings that are anagrams we have to return two goups of strings, i.e. we need `List<List<String>>`. But in the problem description the method signature is given by `List<String>`. Does it mean that we always assume that we have only one group of string every time? Can someone please clarify this for me?"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@Swapnamoy45](/Swapnamoy45)   replying to old message feels like time travel. I hope he sees it\\n"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "Its updated now Brother. \\n\\nBut Hello, you posted this comment on 2014, How are you now? You sure did get some proper job right?\\n"
                    },
                    {
                        "username": "exemplles",
                        "content": "`\\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.`\\nInput:\\n`strs = [\"\",\"\"]`\\nExpected:\\n`[[\"\",\"\"]]`\\n\\nWhere are the letters or words?"
                    },
                    {
                        "username": "aryanraj24032002",
                        "content": "Well it\\'s a empty string(or word ) and two empty strings are always anagram of each other"
                    },
                    {
                        "username": "thewallandme",
                        "content": "lol I asked the exact same question, apparently it\\'s an empty word "
                    },
                    {
                        "username": "jwong93",
                        "content": "I got 118/118 testcases passed but time limit exceeded\\nLast executed input strs = \\nWhat is going on?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It means you got TLE after the last testCase. In other words, you\\'re code is slightly to inefficient. The fact that the failing testcase is empty is a known bug that LC is trying to solve. You should just treat it is any other TLE, but you don\\'t get the failing testCase."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@hbhutta](/hbhutta) This problem is very achievable in O(nlog(n)), and I believe this is required to pass all test cases. You have likely already solved this problem, but for anyone else struggling with this issue, it is because the time complexity is too high. \n\nTry looking for an O(nlog(n)) solution instead."
                    },
                    {
                        "username": "take87940",
                        "content": "have any answer for it ?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@HasanBasheerStudent](/HasanBasheerStudent) Me too, on 111. I have an $O(n^2)$ solution"
                    },
                    {
                        "username": "HasanBasheerStudent",
                        "content": "111/118 for myself"
                    },
                    {
                        "username": "leelgangineni",
                        "content": "![image](https://assets.leetcode.com/users/images/d9bcf291-770e-4cd5-b75a-05e55df8895a_1644209592.3317468.png)\\n"
                    },
                    {
                        "username": "akashdey1006",
                        "content": "[@saswatajiko](/saswatajiko) because k is a string here"
                    },
                    {
                        "username": "YgLK",
                        "content": "[@saswatajiko](/saswatajiko) sorted(word) returns list of elements in word which isn\\'t hashable (cannot be used as key in dict) so joining list of letters into string is a suitable solution "
                    },
                    {
                        "username": "HondaCivicTypeR",
                        "content": "What is the time complexity? n.nlogn?"
                    },
                    {
                        "username": "apengelly",
                        "content": "[@saswatajiko](/saswatajiko) Because sorted(word) splits the characters of the word into a list and then sorts them in the list.  The \\'\\'.join() statement makes the list into a string again."
                    },
                    {
                        "username": "HamAlam7",
                        "content": "[@saswatajiko](/saswatajiko) although your intuition is correct, if you look into the sorted function you will realize that it returns a list of the sorted word, so it\\'s a list of the characters in a sorted order. So in order to turn the list into a string, you use the .join() function which takes the list as is its parameter.\\nNote: If you did join on \" \" instead of \"\" you will get spaces in between each character which is not what we need here."
                    },
                    {
                        "username": "saswatajiko",
                        "content": "Why is it _k = ''.join(sorted(word))_ and not _k = sorted(word)_?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "My code gets \"Output limit exceeded\". It definitely does not happen for every test case, as I have tested it on my computer. Is there a way to get a test case for which this happens?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "Damn it\\'s been 10 years but it means you\\'re doing too many console logs, or prints, or system.out.printlns, or whatever it is in C++."
                    },
                    {
                        "username": "zartkims",
                        "content": "Input:\\n[\"\",\"b\"] \\n\\nOutput:\\n[[\"\",\"b\"]]\\n\\nExpected:\\n[[\"b\"],[\"\"]]\\n\\n==============\\n\\nwhat should i do?\\nwhat is the order?"
                    },
                    {
                        "username": "sarthak_joshi",
                        "content": "just put a condition that if the two strings differ in length then just return false that means they are not anagram.\\n"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) can u please tell me how to pass an empty vector in an vector .. it itself neglect the empty vector and pass only vector with string \"b\""
                    },
                    {
                        "username": "yuricaetano",
                        "content": "[@heremhd](/heremhd) toxic?"
                    },
                    {
                        "username": "heremhd",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal)  you responded to a 7 year old question lol..."
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "you are returning a vector of vector containing elements \"\" and b, but the answer two different vectors containing element b and \"\" respectively. You have to code it that way. Tell me if you want any help or if it was helpful.\\n"
                    }
                ]
            },
            {
                "id": 1571118,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1803676,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567824,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1571121,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1568873,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567825,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1567178,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 2047581,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1576794,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1575181,
                "content": [
                    {
                        "username": "cn-yezi",
                        "content": "No one is released javascript\\nSo look on the release\\nMy code is written is not very good\\nI hope that was a message written the best javascript\\n<pre>\\nvar groupAnagrams = function(strs){\\n&#9;var newArr = [];\\n&#9;strs.forEach((elem) =>{\\n&#9;&#9;key = elem.split('').sort();\\n&#9;&#9;newArr[key] instanceof Array ? newArr[key].push(elem) : newArr[key] = [elem];\\n&#9;});\\n&#9;return Object.keys(newArr).map(function(k){return newArr[k]});\\n}"
                    },
                    {
                        "username": "fauricio",
                        "content": "- why said `any order.` if must return in a specific order?\\n\\n- and do you know the size of each group?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "* They do not need to be returned in a specific order. The groups and all the strings in each group can be placed in any order in your output.\\n\\n* You will not know the size of each group until your method finishes running correctly."
                    },
                    {
                        "username": "nachtsky",
                        "content": "Should it returns an empty vector?"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "No!\\nBecause in constraints it is mentioned that:\\n1 <= strs.length <= 10^4\\nif given list atleast have an (empty/non-empty) string so your answer should not be empty list."
                    },
                    {
                        "username": "icecreambear",
                        "content": "I don't understand the following test cases:\\nInput: [\"a\"]\\nMy output: [\"a\"]\\nExpect: []\\n\\nInput: [\"\"]\\nMy output: []\\nExpect: []\\n\\nBUT\\n\\nInput: [\"\",\"\"]\\nMy output: []\\nExpect: [\"\", \"\"]\\n\\nThose just look strange to me. Are they correct?"
                    },
                    {
                        "username": "gavin_gao",
                        "content": "I donot understand why this is WA?\\n\\nthis is the test data:[\"hos\",\"boo\",\"nay\",\"deb\",\"wow\",\"bop\",\"bob\",\"brr\",\"hey\",\"rye\",\"eve\",\"elf\",\"pup\",\"bum\",\"iva\",\"lyx\",\"yap\",\"ugh\",\"hem\",\"rod\",\"aha\",\"nam\",\"gap\",\"yea\",\"doc\",\"pen\",\"job\",\"dis\",\"max\",\"oho\",\"jed\",\"lye\",\"ram\",\"pup\",\"qua\",\"ugh\",\"mir\",\"nap\",\"deb\",\"hog\",\"let\",\"gym\",\"bye\",\"lon\",\"aft\",\"eel\",\"sol\",\"jab\"]\\n\\nthis is my answer:\\n[[\"deb\",\"deb\"],[\"aha\"],[\"jab\"],[\"jed\"],[\"eel\"],[\"elf\"],[\"hem\"],[\"nam\"],[\"bob\",\"boo\"],[\"doc\"],[\"oho\"],[\"hog\"],[\"job\"],[\"lon\"],[\"gap\"],[\"nap\"],[\"pen\"],[\"bop\"],[\"brr\"],[\"ram\"],[\"mir\"],[\"rod\"],[\"dis\"],[\"hos\"],[\"sol\"],[\"aft\"],[\"let\"],[\"ugh\",\"ugh\"],[\"bum\"],[\"pup\",\"pup\"],[\"qua\"],[\"eve\"],[\"iva\"],[\"wow\"],[\"max\"],[\"yea\"],[\"bye\"],[\"hey\"],[\"lye\"],[\"gym\"],[\"nay\"],[\"yap\"],[\"rye\"],[\"lyx\"]]\\n\\nths is expected answer:\\n[[\"sol\"],[\"wow\"],[\"gap\"],[\"hem\"],[\"yap\"],[\"bum\"],[\"ugh\",\"ugh\"],[\"aha\"],[\"jab\"],[\"eve\"],[\"bop\"],[\"lyx\"],[\"jed\"],[\"iva\"],[\"rod\"],[\"boo\"],[\"brr\"],[\"hog\"],[\"nay\"],[\"mir\"],[\"deb\",\"deb\"],[\"aft\"],[\"dis\"],[\"yea\"],[\"hos\"],[\"rye\"],[\"hey\"],[\"doc\"],[\"bob\"],[\"eel\"],[\"pen\"],[\"job\"],[\"max\"],[\"oho\"],[\"lye\"],[\"ram\"],[\"nap\"],[\"elf\"],[\"qua\"],[\"pup\",\"pup\"],[\"let\"],[\"gym\"],[\"nam\"],[\"bye\"],[\"lon\"]]"
                    },
                    {
                        "username": "hbhutta",
                        "content": "bob and boo are not anagrams"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "Search bob in your answer, expected answer and input. Your answer paired it with boo, that is why it\\'s the wrong answer. I didn\\'t check it completely, so there may be other errors as well. Check for them, find the bug and code accordingly. tell me if this was helpful or if you need any other help."
                    },
                    {
                        "username": "thediesel",
                        "content": "I use Hashtable first, \\n      got TLE. \\n\\nThen tried HashMap, \\n      AC.\\n\\nOh, man."
                    },
                    {
                        "username": "hbhutta",
                        "content": "What is the difference between hashtable and hashmap? Are you using Java?"
                    },
                    {
                        "username": "dirty_valera",
                        "content": "Input:\\t[\"and\",\"dan\"]\\nOutput:\\t[]\\nExpected:\\t[\"and\",\"dan\"]\\n\\nOk now, how is it an anagram? It's either I don't get your definition or you guys got it wrong."
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "Here for \"and\" and \"dan\"; you can arrange one of the word to get another. and->dan(by moving d to first position), that\\'s how it is anagram."
                    },
                    {
                        "username": "hauron",
                        "content": "Hint: Two strings are an anagram, if hashes calculated on sorted strings are the same."
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "https://hecodesit.com/group-anagrams-leetcode-python-solutions/"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/5b1d2bbc-cfe4-4cc5-a5b9-d8d81c0503bf_1619347984.946951.png)\\n"
                    }
                ]
            },
            {
                "id": 1574673,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1573598,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1571119,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1571120,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2046371,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2043822,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2043809,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2038922,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2038700,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2030271,
                "content": [
                    {
                        "username": "Jsn667",
                        "content": "![image](https://assets.leetcode.com/users/images/91cc715c-d732-4642-97b9-47ae7590cdb3_1607641029.4643302.png)\\n"
                    },
                    {
                        "username": "rajkambo",
                        "content": "I hope to solve every problem in the 30-day challenge and do a write up explaining my thought process (as if I were at a coding interview). Hopefully some folks can benefit from seeing my perspective!\\n\\nIf you\\'re interested in a full explanation from how to solve the problem by hand, writing out an algorithm, analyzing time and space, and implementing cleanly (just like you\\'re expected to at a coding interview for the top firms) check it out: https://www.rajkambo.com/leetcoding-challenge-day-6/.\\n\\nThanks!"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@Rajdeep Kambo](/rajkambo) Hey you go to UBC? I notice the engineering block. I'm studying at UBC as well."
                    },
                    {
                        "username": "kcyy",
                        "content": "Just because the order is different, leetcode think it's wrong.\\n\\nSubmission Result: Wrong Answer \\n\\nInput:\\n[\"tea\",\"and\",\"ate\",\"eat\",\"den\"]\\n\\nOutput:\\n[[\"tea\",\"ate\",\"eat\"],[\"and\"],[\"den\"]]\\n\\nExpected:\\n[[\"den\"],[\"and\"],[\"ate\",\"eat\",\"tea\"]]"
                    },
                    {
                        "username": "naijil",
                        "content": "I don't understand the problem, any examples?"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "upvote if you think this problem is easy"
                    },
                    {
                        "username": "user6092GW",
                        "content": "is every string of the same length?"
                    },
                    {
                        "username": "rahulag1402",
                        "content": "can anyone tell me how to return an  empty vector in an vector\\nin the below case i need this\\ninput\\n[\"b\" , \"\"]\\noutput\\n[[\"b\"]]\\nexpected\\n[[\"\"],[\"b\"]]\\n\\nthe compiler automatically removes the empty vector and i alwalys geeting an wrong ans"
                    },
                    {
                        "username": "MrLebovsky",
                        "content": "It says: \" You can return the answer in any order\", but console result is:\\n\\nOutput\\n[[\"ddddddddddg\",\"dgggggggggg\"]]\\nExpected\\n[[\"dgggggggggg\"],[\"ddddddddddg\"]]\\n\\nWhy?"
                    },
                    {
                        "username": "apengelly",
                        "content": "Your error has nothing to do with order.  It has to do with your grouping of anagrams."
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Dawg why is one of the test case words \"negroes\" (Test case 118)"
                    },
                    {
                        "username": "tawalbeh21",
                        "content": "I\\'ve solved it in this code below, but it failed on one test case which doesn\\'t make sense, one of the expected outputs is \"null\", which it doesn\\'t existed in the test case at first hand!!! \\nhere the test case: \\n[\"vocabularies\",\"golden\",\"barking\",\"riviera\",\"helmsmen\",\"cavorting\",\"shrinks\",\"hangmen\",\"heliports\",\"salve\",\"assorting\",\"neuroses\",\"contribute\",\"triathlon\",\"adherents\",\"gismo\",\"sering\",\"pulsate\",\"hoarders\",\"vacating\",\"pulverization\",\"destabilize\",\"wore\",\"eureka\",\"gobs\",\"raiding\",\"valhalla\",\"aureole\",\"illustration\",\"null\",\"ageing\",\"umbrellaing\",\"characterize\",\"ethel\",\"bagging\",\"lucas\",\"nakedly\",\"rinded\",\"wainscottings\",\"through\",\"falter\",\"clearness\",\"smart\",\"overspecializes\",\"older\",\"entourage\",\"dawn\"]\\n\\n `class Solution {\\n        public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> result = new ArrayList();\\n        int index = -1;\\n        for(int i = 0; i < strs.length; i++){\\n            if(strs[i].equals(\"null\")){\\n                continue;\\n            }\\n            index++;\\n            result.add(new ArrayList());\\n            for(int j = i; j < strs.length; j++){\\n                if(distanceValidation(strs[i], strs[j])){\\n                    result.get(index).add(strs[j]);\\n                    if(j != i){\\n                        strs[j] = \"null\";\\n                    }\\n\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public Boolean distanceValidation(String str1, String str2){\\n        if(str1.length() != str2.length())\\n            return false;\\n        StringBuilder strb1 = new StringBuilder(str1);\\n        StringBuilder strb2 = new StringBuilder(str2);\\n        Set<Integer> hs = new HashSet<>();\\n        for(int i = 0; i < str1.length(); i++){\\n            if(strb1.indexOf(String.valueOf(strb2.charAt(i))) == -1){\\n                return false;\\n            } else {\\n                strb1.deleteCharAt(strb1.indexOf(String.valueOf(strb2.charAt(i))));\\n            }\\n        }\\n        return true;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2015389,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2014174,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2004090,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 2000575,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1999665,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1991383,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1984928,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1975723,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1963413,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1931709,
                "content": [
                    {
                        "username": "Dominating_",
                        "content": "cclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> m;\n        for(string s:strs){\n            vector<int> v(26,0);\n            for(char c:s){\n                v[c-'a']++;\n            }\n            m[v].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto p:m){\n            ans.push_back(p.second);\n        }\n        return ans;\n    }\n};\nIn the above code I am unable to use unordered map.\nThe above code runs properly"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yasash",
                        "content": "Why cant i use  a Integer array as a count array?\\nwhen i do \\nchar[] ca=new char[26]; \\n  ca[c-\\'a\\']++;\\nwhat am i incrementing in a empty char array?"
                    },
                    {
                        "username": "Amfibrachy",
                        "content": "What language do you use. In C++ for example when you increment on empty map it inserts the value by itself and it should work as you want. However in other languages you should do it by yourself (check for emptiness and insertion of new element)."
                    },
                    {
                        "username": "z3eg",
                        "content": "anyone with an int hashing function that works?"
                    },
                    {
                        "username": "user0887oM",
                        "content": "Why can\\'t my code pass the last use case. It\\'s always Time Limit Exceeded. \\nBut the time complexity seems O(n * m) (n is strs.length, m is the length of each string)to me, less than some other solutions passed.\\n\\n `class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> res = new ArrayList<>();\\n        for (String str : strs) {\\n            boolean findGroup = false;\\n            for (int i = 0; i < res.size(); i ++) {\\n                if (isAnagrams(res.get(i).get(0), str)) {\\n                    res.get(i).add(str);\\n                    findGroup = true;\\n                }\\n            }\\n            if (!findGroup) {\\n                res.add(new ArrayList<>());\\n                res.get(res.size() - 1).add(str);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public boolean isAnagrams(String str1, String str2) {\\n        int[] letters = new int[26];\\n        for (int i = 0; i < str1.length(); i++) {\\n            letters[str1.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < str2.length(); i++) {\\n            letters[str2.charAt(i) - \\'a\\']--;\\n        }\\n        for (int n : letters) {\\n            if (n != 0) return false;\\n        }\\n        return true;\\n    }\\n}`"
                    },
                    {
                        "username": "heremhd",
                        "content": "hard to tell you what\\'s wrong when the code you provided doesnt run"
                    },
                    {
                        "username": "surya_vamsi_kodeti",
                        "content": "For python folks who are looking for a clue: \\n\\nDictionary accepts tuple as a key :) "
                    },
                    {
                        "username": "ItProgrammist",
                        "content": "Can anyone recommend different task like this one, please? I love the realization"
                    },
                    {
                        "username": "BenLaden",
                        "content": "good problem with interesting solution"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "class Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>>ans=new ArrayList<>();\\n      for(int i=0;i<strs.length;i++)\\n        {\\n            char a[]=strs[i].toCharArray();\\n            Arrays.sort(a);\\n            String s=new String(a);\\n            List<String>h=new ArrayList<>();\\n            if(strs[i]!=\"0\")\\n            { \\n                h.add(strs[i]);\\n               for(int j=i+1;j<strs.length;j++)\\n               {\\n                 \\n                  char b[]=strs[j].toCharArray();\\n                  Arrays.sort(b);\\n                  String s1=new String(b);\\n                  if(s1.equals(s))\\n                  {\\n                      h.add(strs[j]);\\n                      strs[j]=\"0\";\\n                  }\\n                  \\n               }\\n               ans.add(h);\\n           }\\n        }\\n        return ans;\\n    }\\n}\\ncould anyone help me out to reduce the loop to eliminate \"time limit exceed \"?"
                    },
                    {
                        "username": "martellino",
                        "content": "Do all the input strings have the same length? It\\'s always true in the example, but it\\'s not clear if it\\'s a requirement too."
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "Input = `[\"\",\"\",\"\"]`\\nOutput = `[[\"\",\"\"],[\"\"]]`\\nExpected = `[[\"\",\"\",\"\"]]`\\n\\nCan someone tell me what\\'s wrong "
                    },
                    {
                        "username": "noobappo_99",
                        "content": "[@yashkolambekar](/yashkolambekar) i am getting the same issue .. what am i missing"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@yashkolambekar](/yashkolambekar) Great to hear it!"
                    },
                    {
                        "username": "yashkolambekar",
                        "content": "[@nikhila01](/nikhila01)  yessir, after 13 unsuccessfull submissions, finally got it right!"
                    },
                    {
                        "username": "nikhila01",
                        "content": "The string `\"\"` is an anagram of itself so all the strings have to be in the same group.\\n\\n Your output is `[[\"\",\"\"],[\"\"]]` which has two strings in one group, and one string in another group. Compare that to the expected output `[[\"\",\"\",\"\"]]` which has all of them in the same group."
                    }
                ]
            },
            {
                "id": 1922079,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1921191,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1919790,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1916978,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1912405,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1911672,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1909227,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1907310,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1905029,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1901183,
                "content": [
                    {
                        "username": "roman-pogorelov",
                        "content": "It\\'s an interesting task. What do you think in which language we\\'ll get the shortest solution?"
                    },
                    {
                        "username": "rp23",
                        "content": "How to comment my code in discussion forum?"
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": "Hi U can click the option \"choose a type\" in that u get three options to choose so choose question in that and write ur query there "
                    },
                    {
                        "username": "amulayauppal1999",
                        "content": " I am getting error as TLE Although all the test cases has been passed by me 118/118. What is this behaviour any one could explain me ?\\n "
                    },
                    {
                        "username": "nikhila01",
                        "content": "There\\'s a time limit for each test case, but also an overall time limit. Your solution passes each test case but is too slow to pass the overall time limit."
                    },
                    {
                        "username": "alexdodge",
                        "content": "> An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, **typically** using all the original letters exactly once.\n\nI feel like the word \"typically\" is distracting here.  I don't care about the traditional definition of an anagram, I care about the definition that this problem is asking for."
                    },
                    {
                        "username": "matthew106",
                        "content": "[\"\",\"\"]\\nHow is expected output going to be [[\"\",\"\"]]?\\n\\nIsn\\'t \"\" an anagram of \"\"?\\n\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, `\"\"` is an anagram of `\"\"`. That\\'s why the answer is `[[\"\",\"\"]]`. They\\'re in the same group.\\n\\nIf they weren\\'t in the same group, the answer would be `[[\"\"],[\"\"]]`"
                    },
                    {
                        "username": "nayanrabiul",
                        "content": "hints: map string to a array and stringify the array and use is a key of hashmap "
                    },
                    {
                        "username": "9dubs",
                        "content": "i must be so dumb to not know about defaultdict. in my approach, i raw coded what defaultdict literally does using stupid amount list initializations, comparisons, and for loops resulting into a time complexity of O(n^2 * m * logm). good thing i looked up how to optimize my code"
                    },
                    {
                        "username": "yxcntu",
                        "content": "Hi LC, is there something different in LC\\'s dart runtime?\\nIt says the error happened in this case, where expected output is a list of two 1-item lists, but my output is a list of two strings:\\n          Input\\n          strs =          [\"bdddddddddd\",\"bbbbbbbbbbc\"]\\n          Use Testcase\\n          Output        [[\"bdddddddddd\",\"bbbbbbbbbbc\"]]\\n          Expected    [[\"bbbbbbbbbbc\"],[\"bdddddddddd\"]]\\n          \\nHowever, the output in my dev terminate is correct:\\n         flutter/common/flutter/bin/cache/dart-sdk/bin/dart --enable-asserts /src/project/Dart/GroupAnagram.dart\\n         \\n         Result is Type List<List<String>>: true\\n         [[bdddddddddc], [bdddddddddd]]\\n\\nwhat could be wrong?"
                    },
                    {
                        "username": "Om-_-sd",
                        "content": "Why does it not take answer when the order of inner groups is different to expected"
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It\\'s definitely not a medium question, buy easy one"
                    }
                ]
            },
            {
                "id": 1898994,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1890843,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1849312,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1845504,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1811154,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1803454,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1802309,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1797307,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1783235,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1776933,
                "content": [
                    {
                        "username": "AlexanderDoktorov",
                        "content": "Input\\nstrs =\\n[\"ac\",\"c\"]\\nUse Testcase\\nOutput\\n[[\"ac\",\"c\"]]\\nExpected\\n[[\"c\"],[\"ac\"]]\\n\\n \"You can return the answer in any order.\" WTF???"
                    },
                    {
                        "username": "nikhila01",
                        "content": "You're not _grouping_ them because you're returning `\"ac\"` and `\"c\"` in the same list and they aren't anagrams. It doesn't have anything to do with the order.\n\nIf you return `[[\"ac\"],[\"c\"]]` instead of `[[\"ac\",\"c\"]]` it'll work."
                    },
                    {
                        "username": "uncleSlayer",
                        "content": "```\\nimport collections\\n\\nclass Solution:\\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\\n        \\n        ans = collections.defaultdict(list)\\n\\n        for string in strs:\\n\\n            count = [0] * 26\\n\\n            for character in string:\\n\\n                count[ord(character) - ord(\"a\")] += 1\\n\\n            ans[tuple(count)].append(string)\\n\\n        return ans.values()\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ReyhanPatria",
                        "content": "All test cases reported to have passed but still getting Time Limit Exceededd error, is this a Java problem or is my code still in correct?\\n\\n ```\\nclass Solution {\\n    public boolean isSameArray(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.length; i++) {\\n            if(arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int[] countAlphabets(String s) {\\n        int[] output = new int[26];\\n\\n        for (char c: s.toCharArray()) {\\n            output[c - \\'a\\']++;\\n        }\\n\\n        return output;\\n    }\\n\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Set<Integer> seenIndex = new HashSet<>();\\n        List<List<String>> output = new ArrayList<>();\\n\\n        for (int i = 0; i < strs.length; i++) {\\n            String s = strs[i];\\n\\n            if (seenIndex.contains(i)) {\\n                continue;\\n            }\\n\\n            List<String> anagramGroup = new ArrayList<>();\\n            anagramGroup.add(s);\\n            seenIndex.add(Integer.valueOf(i));\\n\\n            int parentAlphabets[] = countAlphabets(s);\\n\\n            for (int j = i + 1; j < strs.length; j++) {\\n                String s2 = strs[j];\\n\\n                int[] childAlphabets = countAlphabets(s2);\\n\\n                if (isSameArray(parentAlphabets, childAlphabets)) {\\n                    anagramGroup.add(s2);\\n                    seenIndex.add(Integer.valueOf(j));\\n                }\\n            }\\n\\n            output.add(anagramGroup);\\n        }\\n\\n        return output;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA Solution\\n\\n\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n        Map<String , List<String>> anagram = new HashMap<>();\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            char s[] = strs[i].toCharArray();\\n            Arrays.sort(s);\\n            String sortedString = String.valueOf(s);\\n            if(!anagram.containsKey(sortedString))\\n               anagram.put(sortedString,new ArrayList<String>());\\n                anagram.get(sortedString).add(strs[i]);\\n        }\\n        return new ArrayList<>(anagram.values());\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ath-coder17",
                        "content": "simple python3 solutiion using Defaultdicts,   o( M*N)\n\n `hashm = defaultdict(list)\n        for i in strs:\n            char  = [0]*26\n            for w in i:\n                char[ord(w) - ord('a')] +=1\n            hashm[tuple(char)].append(i)\n        return hashm.values()`\n"
                    },
                    {
                        "username": "duccanhole",
                        "content": "this should be a mark as easy tag"
                    },
                    {
                        "username": "Farkhan22",
                        "content": "Some one help me to Alter this solution so that i can pass all the test cases\\n\\nclass Solution {\\n    public List<List<String>> groupAnagrams(String[] strs) {\\n\\n        if(strs==null || strs.length==0) return null;\\n\\n        List<List<String>> res = new ArrayList<>();\\n        int[] nos={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101,103};\\n\\n        Map<Integer, List<String>> map=new HashMap<>();\\n\\n        for(String str: strs){\\n\\n            int prod=1;\\n\\n            for(int i=0; i<str.length(); i++){\\n                prod*=nos[str.charAt(i)-\\'a\\'];\\n            }\\n\\n            if(map.containsKey(prod)){\\n                map.get(prod).add(str);\\n            }\\n\\n            else{\\n                map.put(prod, new ArrayList<String>());\\n                map.get(prod).add(str);\\n            }\\n        }\\n         \\n        List<List<String>> result = new ArrayList<List<String>>();\\n\\n        for(List<String> val : map.values()) {\\n\\n            result.add(val);\\n\\n        }\\n\\n        return result;\\n\\n    }\\n}"
                    },
                    {
                        "username": "rm1",
                        "content": "For an interview, would a O(m*nlogn) solution work? This would be sorting the letters for the hashtable key."
                    },
                    {
                        "username": "bitkanga",
                        "content": "Hey, any way I could improve this solution? I\\'m not sure if there was a better way to update the anagrams map.\\n```\\nvar groupAnagrams = function(strs) {\\n    const anagrams = new Map();\\n    for (const str of strs) {\\n        let count = Array(26).fill(0);\\n        for (const char of str) {\\n            count[char.charCodeAt() - \\'a\\'.charCodeAt()] += 1\\n        }\\n        if (anagrams[count]) {\\n            anagrams[count].push(str)\\n        } else {\\n            anagrams[count] = [str]\\n        }\\n    }\\n    return Object.values(anagrams)\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Tyi77",
                        "content": "I’m trying to use some HASH FUNCTION (or ENCODING) methods without sorting every strings. It will makes the Time Complexity O(n * m) not O(n * mlogm). Could anyone give some tips to me? Thanks!"
                    }
                ]
            },
            {
                "id": 1770139,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1768446,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1752633,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1750256,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1749641,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1747849,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1723158,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1717608,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1708797,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            },
            {
                "id": 1707703,
                "content": [
                    {
                        "username": "mask73",
                        "content": "XD - my code beats 5.1% in runtime and 99.45% in memory -\\nclass Solution {\\npublic:\\n\\n    int isAnagram(string& A, string& B) {\\n        int n,n2,i;\\n    int C[91] = {0};\\n   \\n     n = A.size();n2 = B.size();\\n\\n    if( n!=n2) return 0;\\n\\n\\n    for( i = 0 ; i < n ; i++ ){\\n\\tC[A[i]-32]++;\\n    }\\n\\n    for(  i = 0 ; i < n ; i++){\\n\\tC[B[i]-32]--;\\n    }\\n\\n    for(  i = 0 ; i < 91 ; i++){\\n\\tif(C[i] != 0){\\n\\t    return 0;\\n\\t}\\n    }\\n\\n    return 1;\\n}\\n\\n\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        \\n        vector<vector<string>> ans;\\n        for(int i = 0 ; i < strs.size(); i++){\\n            if(strs[i]== \"=\")\\n                continue;\\n            vector<string> v;\\n            for(int j = i+1; j < strs.size(); j++){\\n                if(isAnagram(strs[i],strs[j])){\\n                    v.push_back(strs[j]);\\n                    strs[j] = \"=\";\\n                }\\n            }\\n            v.push_back(strs[i]);\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sharyu_marwadi",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        vector<vector<string>> ans;\\n        vector<string> strs1 = strs;\\n        unordered_map<string,vector<int>> table;\\n        for(int i=0;i<strs1.size();i++){\\n            sort(strs1[i].begin(), strs1[i].end());\\n            table[strs1[i]].push_back(i);\\n        }\\n        for(auto k :table){\\n            vector<string> a;\\n            for(int i=0;i<k.second.size();i++){\\n                a.push_back(strs[k.second[i]]);\\n            }\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};\\n ```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "aniketmotwani52",
                        "content": "class Solution {\\n\\n    private:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        if(s1==s2)\\n        return true;\\n\\n        else\\n        return false;\\n    }\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n\\n        \\n        int n=strs.size();\\n        vector<vector<string>> ans;\\n\\n        if(n==0)\\n        {\\n            vector<string> temp;\\n            ans.push_back(temp);\\n            return ans;\\n\\n        }\\n        \\n        vector<bool> hashMap(strs.size(),false);\\n\\n        vector<string> str;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            str.push_back(strs[i]);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(str[i].begin(),str[i].end());\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!hashMap[i])\\n            {\\n                vector<string> temp;\\n                temp.push_back(strs[i]);\\n                hashMap[i]=true;\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(i!=j && hashMap[j]==false)\\n                    {\\n                        bool check=isAnagram(str[i],str[j]);\\n                        if(check)\\n                        {\\n                            temp.push_back(strs[j]);\\n                            hashMap[j]=true;\\n                        }\\n                    }\\n                }\\n                ans.push_back(temp);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n \\nI am not getting ans when there is nothing as input i.e. keeipng strs blank \\nAny idea how to resolve it ?\\n"
                    },
                    {
                        "username": "aliasgar78600",
                        "content": "O(N) solution\\npublic List<List<String>> groupAnagrams(String[] strs) {\\n        List<List<String>> list=new ArrayList<>();\\n        Map<Long,List<String>> mp=new HashMap<>();\\n        for(String s:strs){\\n            long total=0;\\n            for(int i=0;i<s.length();i++){\\n                int temp=s.charAt(i)-\\'0\\';\\n                total+=temp*temp*temp*temp*temp;\\n            }\\n            if(mp.containsKey(total)){\\n                List<String> aa=mp.get(total);\\n                aa.add(s);\\n                mp.put(total,aa);\\n            }else{\\n                List<String> res=new ArrayList<>();\\n                res.add(s);\\n                mp.put(total,res);\\n            }\\n        }\\n        for(Map.Entry<Long,List<String>> m:mp.entrySet()){\\n            list.add(m.getValue());\\n        }\\n        return list;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n void sortString(string &str){\\n   sort(str.begin(), str.end());\\n   \\n}\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        //edge cases\\n       if(strs.empty())\\n            return{{\"\"}};\\n       if(strs.size()==1)\\n            return{{strs[0]}};\\n        //create a map with following structure\\n        //(sorted form of string)->(vector of strings in original order)\\n        vector<vector<string>>res;\\n        unordered_map<string,vector<string>>M;\\n        for(auto str:strs){\\n            string indexString = str;\\n            sort(indexString.begin(),indexString.end());\\n            M[indexString].push_back(str);\\n        }\\n        for(auto i:M){\\n            res.push_back(i.second);\\n        }\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "phantom0711",
                        "content": "Is `defaultdict(list)` necessary? What would the code look like if `defaultdict(list)` is not allowed?\\n"
                    },
                    {
                        "username": "leoknaw",
                        "content": "isn\\'t a blank string an anagram of another blank string??"
                    },
                    {
                        "username": "amiishhaa",
                        "content": "there are no letters to rearrange, so the two blank strings are considered to be anagrams of each other."
                    },
                    {
                        "username": "KarlAshnikov",
                        "content": "Shouldn\\'t the brute force solution be much faster for reasonable long strings where log(n)<<26?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Max Points on a Line",
        "question_content": "<p>Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,1],[2,2],[3,3]]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 300</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>All the <code>points</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 47113,
                "title": "a-java-solution-with-notes",
                "content": "  \\n\\n      /*\\n         *  A line is determined by two factors,say y=ax+b\\n         *  \\n         *  If two points(x1,y1) (x2,y2) are on the same line(Of course). \\n\\n         *  Consider the gap between two points.\\n\\n         *  We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant\\n\\n         *  If a third point (x3,y3) are on the same line. So we must have y3=ax3+b\\n\\n         *  Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a\\n\\n         *  Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a\\n\\n         *  So we can use y0&x0 to track a line;\\n         */\\n        \\n        public class Solution{\\n            public int maxPoints(Point[] points) {\\n            \\tif (points==null) return 0;\\n            \\tif (points.length<=2) return points.length;\\n            \\t\\n            \\tMap<Integer,Map<Integer,Integer>> map = new HashMap<Integer,Map<Integer,Integer>>();\\n            \\tint result=0;\\n            \\tfor (int i=0;i<points.length;i++){ \\n            \\t\\tmap.clear();\\n            \\t\\tint overlap=0,max=0;\\n            \\t\\tfor (int j=i+1;j<points.length;j++){\\n            \\t\\t\\tint x=points[j].x-points[i].x;\\n            \\t\\t\\tint y=points[j].y-points[i].y;\\n            \\t\\t\\tif (x==0&&y==0){\\n            \\t\\t\\t\\toverlap++;\\n            \\t\\t\\t\\tcontinue;\\n            \\t\\t\\t}\\n            \\t\\t\\tint gcd=generateGCD(x,y);\\n            \\t\\t\\tif (gcd!=0){\\n            \\t\\t\\t\\tx/=gcd;\\n            \\t\\t\\t\\ty/=gcd;\\n            \\t\\t\\t}\\n            \\t\\t\\t\\n            \\t\\t\\tif (map.containsKey(x)){\\n            \\t\\t\\t\\tif (map.get(x).containsKey(y)){\\n            \\t\\t\\t\\t\\tmap.get(x).put(y, map.get(x).get(y)+1);\\n            \\t\\t\\t\\t}else{\\n            \\t\\t\\t\\t\\tmap.get(x).put(y, 1);\\n            \\t\\t\\t\\t}   \\t\\t\\t\\t\\t\\n            \\t\\t\\t}else{\\n            \\t\\t\\t\\tMap<Integer,Integer> m = new HashMap<Integer,Integer>();\\n            \\t\\t\\t\\tm.put(y, 1);\\n            \\t\\t\\t\\tmap.put(x, m);\\n            \\t\\t\\t}\\n            \\t\\t\\tmax=Math.max(max, map.get(x).get(y));\\n            \\t\\t}\\n            \\t\\tresult=Math.max(result, max+overlap+1);\\n            \\t}\\n            \\treturn result;\\n            \\t\\n            \\t\\n            }\\n            private int generateGCD(int a,int b){\\n        \\n            \\tif (b==0) return a;\\n            \\telse return generateGCD(b,a%b);\\n            \\t\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution{\\n            public int maxPoints(Point[] points) {\\n            \\tif (points==null) return 0;\\n            \\tif (points.length<=2) return points.length;\\n            \\t\\n            \\tMap<Integer,Map<Integer,Integer>> map = new HashMap<Integer,Map<Integer,Integer>>();\\n            \\tint result=0;\\n            \\tfor (int i=0;i<points.length;i++){ \\n            \\t\\tmap.clear();\\n            \\t\\tint overlap=0,max=0;\\n            \\t\\tfor (int j=i+1;j<points.length;j++){\\n            \\t\\t\\tint x=points[j].x-points[i].x;\\n            \\t\\t\\tint y=points[j].y-points[i].y;\\n            \\t\\t\\tif (x==0&&y==0){\\n            \\t\\t\\t\\toverlap++;\\n            \\t\\t\\t\\tcontinue;\\n            \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 47117,
                "title": "sharing-my-simple-solution-with-explanation",
                "content": "    int maxPoints(vector<Point> &points) {\\n        int result = 0;\\n        for(int i = 0; i < points.size(); i++){\\n            int samePoint = 1;\\n            unordered_map<double, int> map;\\n            for(int j = i + 1; j < points.size(); j++){\\n                if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                    samePoint++;\\n                }\\n                else if(points[i].x == points[j].x){\\n                    map[INT_MAX]++;\\n                }\\n                else{\\n                    double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x);\\n                    map[slope]++;\\n                }\\n            }\\n            int localMax = 0;\\n            for(auto it = map.begin(); it != map.end(); it++){\\n                localMax = max(localMax, it->second);\\n            }\\n            localMax += samePoint;\\n            result = max(result, localMax);\\n        }\\n        return result;\\n    }\\n\\nFirst, let's talk about mathematics.\\n\\nHow to determine if three points are on the same line?\\n\\nThe answer is to see if slopes of arbitrary two pairs are the same.\\n\\nSecond, let's see what the minimum time complexity can be.\\n\\nDefinitely, O(n^2). It's because you have to calculate all slopes between any two points. \\n\\nThen let's go back to the solution of this problem.\\n\\nIn order to make this discussion simpler, let's pick a random point A as an example.\\n\\nGiven point A, we need to calculate all slopes between A and other points. There will be three cases:\\n\\n1. Some other point is the same as point A.\\n\\n2. Some other point has the same x coordinate as point A, which will result to a positive infinite slope.\\n\\n3. General case. We can calculate slope.\\n\\nWe can store all slopes in a hash table. And we find which slope shows up mostly. Then add the number of same points to it. Then we know the maximum number of points on the same line for point A.\\n\\nWe can do the same thing to point B, point C...\\n\\nFinally, just return the maximum result among point A, point B, point C...",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "    int maxPoints(vector<Point> &points) {\\n        int result = 0;\\n        for(int i = 0; i < points.size(); i++){\\n            int samePoint = 1;\\n            unordered_map<double, int> map;\\n            for(int j = i + 1; j < points.size(); j++){\\n                if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                    samePoint++;\\n                }\\n                else if(points[i].x == points[j].x){\\n                    map[INT_MAX]++;\\n                }\\n                else{\\n                    double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x);\\n                    map[slope]++;\\n                }\\n            }\\n            int localMax = 0;\\n            for(auto it = map.begin(); it != map.end(); it++){\\n                localMax = max(localMax, it->second);\\n            }\\n            localMax += samePoint;\\n            result = max(result, localMax);\\n        }\\n        return result;\\n    }\\n\\nFirst, let's talk about mathematics.\\n\\nHow to determine if three points are on the same line?\\n\\nThe answer is to see if slopes of arbitrary two pairs are the same.\\n\\nSecond, let's see what the minimum time complexity can be.\\n\\nDefinitely, O(n^2). It's because you have to calculate all slopes between any two points. \\n\\nThen let's go back to the solution of this problem.\\n\\nIn order to make this discussion simpler, let's pick a random point A as an example.\\n\\nGiven point A, we need to calculate all slopes between A and other points. There will be three cases:\\n\\n1. Some other point is the same as point A.\\n\\n2. Some other point has the same x coordinate as point A, which will result to a positive infinite slope.\\n\\n3. General case. We can calculate slope.\\n\\nWe can store all slopes in a hash table. And we find which slope shows up mostly. Then add the number of same points to it. Then we know the maximum number of points on the same line for point A.\\n\\nWe can do the same thing to point B, point C...\\n\\nFinally, just return the maximum result among point A, point B, point C...",
                "codeTag": "Unknown"
            },
            {
                "id": 47124,
                "title": "c-slope-counter",
                "content": "A simple idea is to traverse all possible pairs of points and see how many other points fall in the line determined by them, which gives an `O(n^3)` solution.\\n\\nTo improve the time complexity, we traverse all possible lines. We can determine a line by the slope and a point on it.\\n\\nGiven a point `p`, we compute the slopes of all lines connecting `p` and other points. Points corresponding to the same slope will fall on the same line. In this way, we can figure out the maximum number of points on lines containing `p`. We exhaust all possible `p`s and the largest maximum number is just the answer.\\n\\nTo represent a slope (`dy / dx`), we may simply use a `double`. A safer way is to store the pair `{dy, dx}`. However, since `pair` is not hashable, we need to use `map` instead of `unordered_map`, which increases the time complexity. Another way is to encode `dx` and `dy` into a string like `\"dx_dy\"`. Moreover, since `dy = 4, dx = 2` and `dy = 8, dx = 4` represents the same slope, we need to divide them by their gcd before the encoding.\\n\\nWe still need to handle the case of duplicate points simply by adding the number of duplicates to the result.\\n\\nThis is an `O(n^2)` solution given the nested `for` loops. All operations of `unordered_map` take `O(1)` time on average.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxPoints(vector<Point>& points) {\\n        int n = points.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            unordered_map<string, int> counter;\\n            int dup = 1;\\n            for (int j = i + 1; j < n; j++) {\\n                if (points[j].x == points[i].x && points[j].y == points[i].y) {\\n                    dup++;\\n                } else {\\n                    int dx = points[j].x - points[i].x, dy = points[j].y - points[i].y, g = gcd(dx, dy);\\n                    counter[to_string(dx / g) + \\'_\\' + to_string(dy / g)]++;\\n                }\\n            }\\n            ans = max(ans, dup);\\n            for (auto p : counter) {\\n                ans = max(ans, p.second + dup);\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int gcd(int a, int b) {\\n        while (b) {\\n            a = a % b;\\n            swap(a, b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxPoints(vector<Point>& points) {\\n        int n = points.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            unordered_map<string, int> counter;\\n            int dup = 1;\\n            for (int j = i + 1; j < n; j++) {\\n                if (points[j].x == points[i].x && points[j].y == points[i].y) {\\n                    dup++;\\n                } else {\\n                    int dx = points[j].x - points[i].x, dy = points[j].y - points[i].y, g = gcd(dx, dy);\\n                    counter[to_string(dx / g) + \\'_\\' + to_string(dy / g)]++;\\n                }\\n            }\\n            ans = max(ans, dup);\\n            for (auto p : counter) {\\n                ans = max(ans, p.second + dup);\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int gcd(int a, int b) {\\n        while (b) {\\n            a = a % b;\\n            swap(a, b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016390,
                "title": "c-easy-beats-approx-100-explanation",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\n- Here we will calculate the slope\\n\\n# Approach\\nIdea is very simple\\n1. We will select point and for every selected point we will calculate the slope wr.t to another point and store into the map\\n2. In map we will store <slope,that selected point>\\n- for example we have point :-[[1,1],[2,2],[3,3]......\\n   we pick point [1,1]and for that [1,1] we will calculate the slope\\n   w.r.t [2,2] ,[3,3]....... and store like this-\\n    for understanding purpose i\\'m writing\\n    mp[slope1,[1,1]]\\n    mp[slope2,[1,1]]\\n    mp[slope1,[1,1]].........\\n   This type we will store the slope for [2,2] , [3,3],....\\n3. Ater storing the slope into map we will calculate the max point for that slope\\n  For example after storing the slope map can look like this\\n[2/3,3]\\n[INF,1]//for perpendicular case\\n[1/3,2]...\\n4. find the max number of points having the same slope w.r.t. that selected point :-means which slope have maximum point\\n:- here 2/3 have 3 point so our answer will be 3+1(we are adding that point as well) \\n![maxpointupdate.png](https://assets.leetcode.com/users/images/ea135bbf-9a36-47e3-8e84-4db223742bbf_1673169518.2250805.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pt) {\\n        int ans=1; \\n        int n=pt.size();\\n       // slope of every point with selected point\\n        for(int i=0;i<n-1;i++){\\n            map<double,int> mp;\\n            for(int j=i+1;j<n;j++){\\n                //calculating the slope\\n                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);\\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line\\n                mp[abs(x)]++; \\n                else\\n               //storing the slop into map\\n                    mp[x]++;\\n            }\\n            // same slope w.r.t.that selected point\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\\n            ans = max(temp, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\n*Let me know in comment if i can do better.*\\nLets connect on [Linkdin](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/)",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pt) {\\n        int ans=1; \\n        int n=pt.size();\\n       // slope of every point with selected point\\n        for(int i=0;i<n-1;i++){\\n            map<double,int> mp;\\n            for(int j=i+1;j<n;j++){\\n                //calculating the slope\\n                double x = (double)(pt[j][1]-pt[i][1])/(double)(pt[j][0]-pt[i][0]);\\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) //infinite slop for Perpendicular line\\n                mp[abs(x)]++; \\n                else\\n               //storing the slop into map\\n                    mp[x]++;\\n            }\\n            // same slope w.r.t.that selected point\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\\n            ans = max(temp, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47106,
                "title": "c-o-n-2-solution-for-your-reference",
                "content": "Hint by @stellari\\n\\n\"For each point pi, calculate the slope of each line it forms with all other points with greater indices, i.e. pi+1, pi+2, ..., and use a map to record how many lines have the same slope (If two lines have the same slope and share a common point, then the two lines must be the same one). By doing so, you can easily find how many points are on the same line that ends at pi in O(n). Thus the amortized running time of the whole algorithm is O(n^2).\"\\n\\nIn order to avoid using double type(the slope k) as map key, I used pair (int a, int b) as the key where a=pj.x-pi.x, b=pj.y-pi.y, and k=b/a. Using greatest common divider of a and b to divide both a, b ensures that lines with same slope have the same key. \\n\\nI also handled two special cases: (1) when two points are on a vertical line (2) when two points are the same.\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            \\n            if(points.size()<2) return points.size();\\n            \\n            int result=0;\\n            \\n            for(int i=0; i<points.size(); i++) {\\n                \\n                map<pair<int, int>, int> lines;\\n                int localmax=0, overlap=0, vertical=0;\\n                \\n                for(int j=i+1; j<points.size(); j++) {\\n                    \\n                    if(points[j].x==points[i].x && points[j].y==points[i].y) {\\n                        \\n                        overlap++;\\n                        continue;\\n                    }\\n                    else if(points[j].x==points[i].x) vertical++;\\n                    else {\\n                        \\n                        int a=points[j].x-points[i].x, b=points[j].y-points[i].y;\\n                        int gcd=GCD(a, b);\\n                        \\n                        a/=gcd;\\n                        b/=gcd;\\n                        \\n                        lines[make_pair(a, b)]++;\\n                        localmax=max(lines[make_pair(a, b)], localmax);\\n                    }\\n    \\n                    localmax=max(vertical, localmax);\\n                }\\n                \\n                result=max(result, localmax+overlap+1);\\n            }\\n            \\n            return result;\\n        }\\n    \\n    private:\\n        int GCD(int a, int b) {\\n            \\n            if(b==0) return a;\\n            else return GCD(b, a%b);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            \\n            if(points.size()<2) return points.size();\\n            \\n            int result=0;\\n            \\n            for(int i=0; i<points.size(); i++) {\\n                \\n                map<pair<int, int>, int> lines;\\n                int localmax=0, overlap=0, vertical=0;\\n                \\n                for(int j=i+1; j<points.size(); j++) {\\n                    \\n                    if(points[j].x==points[i].x && points[j].y==points[i].y) {\\n                        \\n                        overlap++;\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3016360,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** We have to see straight line so we use geometry concept\\n\\n**Approach:**\\n* From the time constrains we can observe that solution having O(N^3) are also permitted.\\n* So we will simply apply the SLOPE concept from geometry.\\n* ![image](https://assets.leetcode.com/users/images/9d971e66-1da7-42ab-a2cb-b0614f6b9774_1673140806.3116992.png)\\n* If the points have same slope means they are in a straight line.\\n* We just counting them and take max of different slope count.\\n* Return the max count;\\n\\n**Brute Force Approach:**\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n<=2)\\n            return n;\\n        \\n        int maxi = 2;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                int count=2;\\n                for(int k=0; k<n; k++)\\n                {\\n                    if(k!=i && k!=j)\\n                    {\\n                        if((points[j][1]-points[i][1])*(points[i][0]-points[k][0])==(points[i][1]-points[k][1])*(points[j][0]-points[i][0]))\\n                            count++;\\n                    }\\n                }\\n                maxi = max(maxi,count);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n**Time Complexity** => `O(N^3)`\\n**Space Complexity** => `O(1)`\\n\\n**Optimised Approach:**\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2) return n;\\n        int ans = 0;\\n\\n        for(auto it1 : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it1[0], y1 = it1[1];\\n            for(auto it2 : points){   \\n                if(it2 == it1) continue;\\n                double x2 = it2[0], y2 = it2[1];\\n                double slope;\\n                if(x2-x1 == 0){\\n                    slope = INT_MAX; // slope is infinity for vertical line\\n                }else{\\n                    slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n        return ans+1; //including point i\\n    }\\n};\\n```\\n**Time Complexity** => `O(N^2)`\\n**Space Complexity** => `O(N)`\\n\\n![image](https://assets.leetcode.com/users/images/b4a29db6-fe84-4707-b565-c9200aaca31d_1673140967.8644767.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n<=2)\\n            return n;\\n        \\n        int maxi = 2;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                int count=2;\\n                for(int k=0; k<n; k++)\\n                {\\n                    if(k!=i && k!=j)\\n                    {\\n                        if((points[j][1]-points[i][1])*(points[i][0]-points[k][0])==(points[i][1]-points[k][1])*(points[j][0]-points[i][0]))\\n                            count++;\\n                    }\\n                }\\n                maxi = max(maxi,count);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2) return n;\\n        int ans = 0;\\n\\n        for(auto it1 : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it1[0], y1 = it1[1];\\n            for(auto it2 : points){   \\n                if(it2 == it1) continue;\\n                double x2 = it2[0], y2 = it2[1];\\n                double slope;\\n                if(x2-x1 == 0){\\n                    slope = INT_MAX; // slope is infinity for vertical line\\n                }else{\\n                    slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n        return ans+1; //including point i\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47098,
                "title": "accepted-java-solution-easy-to-understand",
                "content": "        /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points.length <= 0) return 0;\\n            if(points.length <= 2) return points.length;\\n            int result = 0;\\n            for(int i = 0; i < points.length; i++){\\n                HashMap<Double, Integer> hm = new HashMap<Double, Integer>();\\n                int samex = 1;\\n                int samep = 0;\\n                for(int j = 0; j < points.length; j++){\\n                    if(j != i){\\n                        if((points[j].x == points[i].x) && (points[j].y == points[i].y)){\\n                            samep++;\\n                        }\\n                        if(points[j].x == points[i].x){\\n                            samex++;\\n                            continue;\\n                        }\\n                        double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);\\n                        if(hm.containsKey(k)){\\n                            hm.put(k,hm.get(k) + 1);\\n                        }else{\\n                            hm.put(k, 2);\\n                        }\\n                        result = Math.max(result, hm.get(k) + samep);\\n                    }\\n                }\\n                result = Math.max(result, samex);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points.length <= 0) return 0;\\n            if(points.length <= 2) return points.length;\\n            int result = 0;\\n            for(int i = 0; i < points.length; i++){\\n                HashMap<Double, Integer> hm = new HashMap<Double, Integer>();\\n                int samex = 1;\\n                int samep = 0;\\n                for(int j = 0; j < points.length; j++){\\n                    if(j != i){\\n                        if((points[j].x == points[i].x) && (points[j].y == points[i].y)){\\n                            samep++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1983010,
                "title": "python-3-using-slopes-and-hash-tables-clean-python-solution",
                "content": "**Concept**: A set of points are on a line each of their pair-wise slopes has the same value.\\n\\nFor each point, we iterate through all the other points and find the slope with each of the other points and store the number of pairs which have the same slope and find the max of the number of points.\\n\\n**Time Complexity:** O(N^2)\\n**Space Complexity:** O(N) as we track only N-1 lines in total.\\n\\n**Do UPVOTE if you found it helpful**\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points) <= 2:\\n            return len(points)\\n        \\n        def find_slope(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            if x1-x2 == 0:\\n                return inf\\n            return (y1-y2)/(x1-x2)\\n        \\n        ans = 1\\n        for i, p1 in enumerate(points):\\n            slopes = defaultdict(int)\\n            for j, p2 in enumerate(points[i+1:]):\\n                slope = find_slope(p1, p2)\\n                slopes[slope] += 1\\n                ans = max(slopes[slope], ans)\\n        return ans+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points) <= 2:\\n            return len(points)\\n        \\n        def find_slope(p1, p2):\\n            x1, y1 = p1\\n            x2, y2 = p2\\n            if x1-x2 == 0:\\n                return inf\\n            return (y1-y2)/(x1-x2)\\n        \\n        ans = 1\\n        for i, p1 in enumerate(points):\\n            slopes = defaultdict(int)\\n            for j, p2 in enumerate(points[i+1:]):\\n                slope = find_slope(p1, p2)\\n                slopes[slope] += 1\\n                ans = max(slopes[slope], ans)\\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016432,
                "title": "python3-o-n-2-hash-map-with-line-equation-explained",
                "content": "- One thing that need to be solved is using something to represent a line formed by two points. For example, point A and point B form a line, and point C is on this line, then the representation of line AB and line AC should be the same. One way of doing this is using Equation of Straight Line: y = slope * x + b, so we use (slope, b).\\n - The second part is count the number of points in each unique line equation. This can be done by using each point as the start point, compute the line equation using other point as the end point, and increase the count of a line euqation if we see a new end point on it. We can use hashmap to count the points on each line euqation.\\n\\n```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        if len(points)<=2: return len(points)\\n        \\n        # Line equation: y = slope * x + b\\n        # Given two points, solve for slope and b\\n        # The slope of a vertical line is undefined, and the form is x = a, \\n        # Where a is the x-intercept, so return (x)\\n        def line(p1,p2):\\n            # Vertical line\\n            if p2[0]-p1[0] == 0:\\n                return (p1[0])\\n            slope = (p2[1]-p1[1]) / (p2[0]-p1[0])                \\n            b = p1[1] - slope * p1[0]\\n            return (slope,\"%.5f\" % b) #Floating Point has issues and limitations, using floating point as hash key isn\\'t a good iead, so round it up a little bit. Check the comment below for the issue.\\n\\n        res = 0\\n        # Let each point be the start point.\\n        # Check the lines formed using other points as the end point.\\n        # Only the distinct line equation matters here (Using hash map to count). \\n        # We want to count how many points are in each line euqation.\\n        # Update the result with the maximum number of points in a line euqation.\\n        for i in range(len(points)):\\n            count = defaultdict(int)\\n            for j in range(i+1,len(points)):\\n                count[line(points[i],points[j])] += 1\\n            if count:\\n                res = max(res,max(count.values()))\\n        \\n        # We didn\\'t count the start point, so +1 here.\\n        return res + 1\\n```\\n\\n**Actually, we don\\'t even need the line equation, and just using the slope will do the trick. Using the same example as before, point A and point B form a line, and point C is on this line, then the slope of line AB and line AC is the same.**\\n\\n```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        if len(points)<=2: return len(points)\\n\\n        def slope(p1,p2):\\n            # Vertical line\\n            if p2[0]-p1[0] == 0:\\n                return inf\\n            return (p2[1]-p1[1]) / (p2[0]-p1[0])                \\n\\n        res = 0\\n        for i in range(len(points)):\\n            count = defaultdict(int)\\n            for j in range(i+1,len(points)):\\n                count[slope(points[i],points[j])] += 1\\n            if count:\\n                res = max(res,max(count.values()))\\n        \\n        return res + 1\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        if len(points)<=2: return len(points)\\n        \\n        # Line equation: y = slope * x + b\\n        # Given two points, solve for slope and b\\n        # The slope of a vertical line is undefined, and the form is x = a, \\n        # Where a is the x-intercept, so return (x)\\n        def line(p1,p2):\\n            # Vertical line\\n            if p2[0]-p1[0] == 0:\\n                return (p1[0])\\n            slope = (p2[1]-p1[1]) / (p2[0]-p1[0])                \\n            b = p1[1] - slope * p1[0]\\n            return (slope,\"%.5f\" % b) #Floating Point has issues and limitations, using floating point as hash key isn\\'t a good iead, so round it up a little bit. Check the comment below for the issue.\\n\\n        res = 0\\n        # Let each point be the start point.\\n        # Check the lines formed using other points as the end point.\\n        # Only the distinct line equation matters here (Using hash map to count). \\n        # We want to count how many points are in each line euqation.\\n        # Update the result with the maximum number of points in a line euqation.\\n        for i in range(len(points)):\\n            count = defaultdict(int)\\n            for j in range(i+1,len(points)):\\n                count[line(points[i],points[j])] += 1\\n            if count:\\n                res = max(res,max(count.values()))\\n        \\n        # We didn\\'t count the start point, so +1 here.\\n        return res + 1\\n```\n```python\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        \\n        if len(points)<=2: return len(points)\\n\\n        def slope(p1,p2):\\n            # Vertical line\\n            if p2[0]-p1[0] == 0:\\n                return inf\\n            return (p2[1]-p1[1]) / (p2[0]-p1[0])                \\n\\n        res = 0\\n        for i in range(len(points)):\\n            count = defaultdict(int)\\n            for j in range(i+1,len(points)):\\n                count[slope(points[i],points[j])] += 1\\n            if count:\\n                res = max(res,max(count.values()))\\n        \\n        return res + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47108,
                "title": "python-68-ms-code",
                "content": "        def maxPoints(self, points):\\n            l = len(points)\\n            m = 0\\n            for i in range(l):\\n                dic = {'i': 1}\\n                same = 0\\n                for j in range(i+1, l):\\n                    tx, ty = points[j].x, points[j].y\\n                    if tx == points[i].x and ty == points[i].y: \\n                        same += 1\\n                        continue\\n                    if points[i].x == tx: slope = 'i'\\n                    else:slope = (points[i].y-ty) * 1.0 /(points[i].x-tx)\\n                    if slope not in dic: dic[slope] = 1\\n                    dic[slope] += 1\\n                m = max(m, max(dic.values()) + same)\\n        return m",
                "solutionTags": [
                    "Python"
                ],
                "code": "        def maxPoints(self, points):\\n            l = len(points)\\n            m = 0\\n            for i in range(l):\\n                dic = {'i': 1}\\n                same = 0\\n                for j in range(i+1, l):\\n                    tx, ty = points[j].x, points[j].y\\n                    if tx == points[i].x and ty == points[i].y: \\n                        same += 1\\n                        continue\\n                    if points[i].x == tx: slope = 'i'\\n                    else:slope = (points[i].y-ty) * 1.0 /(points[i].x-tx)\\n                    if slope not in dic: dic[slope] = 1\\n                    dic[slope] += 1\\n                m = max(m, max(dic.values()) + same)\\n        return m",
                "codeTag": "Python3"
            },
            {
                "id": 3017341,
                "title": "java-solution-with-explantation",
                "content": "\\n# Approach and Explantation\\n<!-- Describe your approach to solving the problem. -->\\n1. It does this by iterating through every combination of two points (i and j) in the input array of points and then checks every other point (k) to see if it is collinear with i and j.\\n\\n2. To determine if three points are collinear, the code calculates the slope between point i and point j, and then compares it to the slope between point i and point k. If the slopes are equal, then the three points are collinear.\\n\\n3. The slope between two points (x1, y1) and (x2, y2) is calculated as (y2 - y1) / (x2 - x1).Let suppose we have three points  (x1, y1),(x2, y2) and (x3, y3) and compare the two slopes then expression is written in this formet` (y2 - y1) * (x3 - x1) = (y3 - y1) * (x2 - x1) ` similarly In this code, this calculation is broken down into two separate parts: `(points[j][1] - points[i][1]) * (points[k][0] - points[i][0]) and (points[k][1] - points[i][1]) * (points[j][0] - points[i][0]).` The reason for this is to avoid a division by zero error in cases where the two points have the same x-coordinate.\\n\\n4. If the code determines that three points i, j, and k are collinear, it increments a temporary count variable temp. After checking every point k, the code compares temp to the current maximum number of collinear points found so far, ans, and updates ans if temp is larger.\\n\\n5. Finally, the code returns the maximum number of collinear points, ans.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    // This method returns the maximum number of points that lie on the same line\\n    // given a set of points represented by the 2D array points\\n    public int maxPoints(int[][] points) {\\n        // n is the number of points in the array\\n        int n = points.length;\\n        \\n        // If there are 0 or 1 points, there is at most one line that can be formed\\n        // (i.e., the line formed by the single point, or no line if there are no points)\\n        if(n <= 2) return n;\\n        \\n        // Initialize the maximum number of points on a line to 2, since there must be at least 2 points to form a line\\n        int ans = 2;\\n        \\n        // Iterate through all pairs of points\\n        for(int i = 0 ;i < n; i++){\\n            for(int j = i+1; j < n ; j++){\\n                // temp is the number of points on the line formed by point i and point j\\n                int temp = 2;\\n                // Check if any other points are on the same line as point i and point j\\n                for(int k = j+1 ; k<n ; k++ ){                   \\n                    // Check if point k is on the same line as point i and point j\\n                    // This is done by checking if the slope between point i and point k is equal to the slope between point i and point j\\n                    int x = (points[j][1] - points[i][1]) * (points[k][0] - points[i][0]);\\n                    int y = (points[k][1] - points[i][1]) * (points[j][0] - points[i][0]);\\n                    if(x == y){\\n                        // If the slopes are equal, point k is on the same line as point i and point j\\n                        temp++;\\n                    }\\n                }\\n                // Update the maximum number of points on a line if necessary\\n                if(temp > ans){\\n                    ans = temp;\\n                }\\n            }\\n        }   \\n        // Return the maximum number of points on a line\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // This method returns the maximum number of points that lie on the same line\\n    // given a set of points represented by the 2D array points\\n    public int maxPoints(int[][] points) {\\n        // n is the number of points in the array\\n        int n = points.length;\\n        \\n        // If there are 0 or 1 points, there is at most one line that can be formed\\n        // (i.e., the line formed by the single point, or no line if there are no points)\\n        if(n <= 2) return n;\\n        \\n        // Initialize the maximum number of points on a line to 2, since there must be at least 2 points to form a line\\n        int ans = 2;\\n        \\n        // Iterate through all pairs of points\\n        for(int i = 0 ;i < n; i++){\\n            for(int j = i+1; j < n ; j++){\\n                // temp is the number of points on the line formed by point i and point j\\n                int temp = 2;\\n                // Check if any other points are on the same line as point i and point j\\n                for(int k = j+1 ; k<n ; k++ ){                   \\n                    // Check if point k is on the same line as point i and point j\\n                    // This is done by checking if the slope between point i and point k is equal to the slope between point i and point j\\n                    int x = (points[j][1] - points[i][1]) * (points[k][0] - points[i][0]);\\n                    int y = (points[k][1] - points[i][1]) * (points[j][0] - points[i][0]);\\n                    if(x == y){\\n                        // If the slopes are equal, point k is on the same line as point i and point j\\n                        temp++;\\n                    }\\n                }\\n                // Update the maximum number of points on a line if necessary\\n                if(temp > ans){\\n                    ans = temp;\\n                }\\n            }\\n        }   \\n        // Return the maximum number of points on a line\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224773,
                "title": "python-easy-and-concise-with-detailed-explanation-algebra",
                "content": "```py\\n# Definition for a point.\\n# class Point(object):\\n#     def __init__(self, a=0, b=0):\\n#         self.x = a\\n#         self.y = b\\n\\nclass Solution(object):\\n\\tdef maxPoints(self, points):\\n\\t\\t\"\"\"\\n\\t\\t:type points: List[Point]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tdef gcd(a, b):\\n\\t\\t\\treturn gcd(b % a, a) if a != 0 else b\\n\\t\\tpointsInLine = {}\\n\\t\\t# idea:\\n\\t\\t# calculate the representation of the line between all pairs of points\\n\\t\\t# add points on the same line into a set\\n\\t\\t# pointsInLine[a, b, c] = set of all indices of points lying on the line ax + by + c = 0\\n\\t\\t# using indices to handle duplicates\\n\\t\\t# return the size of the largest set\\n\\t\\tfor i in xrange(len(points)):\\n\\t\\t\\tfor j in xrange(i + 1, len(points)):\\n\\t\\t\\t\\tx1, y1, x2, y2 = points[i].x, points[i].y, points[j].x, points[j].y\\n\\t\\t\\t\\t# line: ax + by + c = 0\\n\\t\\t\\t\\tif x1 == x2:\\n\\t\\t\\t\\t\\t# equation: x = x1\\n\\t\\t\\t\\t\\ta, b, c = 1, 0, -x1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# not using usual linear equation y = kx + b\\n\\t\\t\\t\\t\\t# because of the precision problem of float\\n\\t\\t\\t\\t\\t# we need to make sure all numbers are integer\\n\\t\\t\\t\\t\\t# so use ax + by + c = 0 instead\\n\\t\\t\\t\\t\\t# value of a, b, c can be deduced from the following\\n\\t\\t\\t\\t\\t# simultaneous equations:\\n\\t\\t\\t\\t\\t# 1) ax1 + by1 + c = 0\\n\\t\\t\\t\\t\\t#    ax2 + by2 + c = 0\\n\\t\\t\\t\\t\\t# using basic algebra, we get:\\n\\t\\t\\t\\t\\t# 2) a/b = -(y2-y1)/(x2-x1), set a to y2-y1, b to x1-x2\\n\\t\\t\\t\\t\\t# substitute a and b into the previous simultaneous equations\\n\\t\\t\\t\\t\\t# we get: 3) c = x2y1-x1y2\\n\\t\\t\\t\\t\\t# To make sure the same (a, b, c) are calculated for all\\n\\t\\t\\t\\t\\t# same lines. We need to set some rules. Because values of\\n\\t\\t\\t\\t\\t# a and b are only bounded by a ratio (eq 2), and a and b\\n\\t\\t\\t\\t\\t# are picked arbitrarily.\\n\\t\\t\\t\\t\\t# first: make sure a is positive\\n\\t\\t\\t\\t\\t# \\t\\treason: -ax - by - c = 0 represents the same line\\n\\t\\t\\t\\t\\t# \\t\\t\\t\\tas ax + by + c = 0\\n\\t\\t\\t\\t\\t# second: reduce fraction of a, b and c\\n\\t\\t\\t\\t\\t# \\t\\treason: 2ax + 2by + 2c = 0 represents the same line\\n\\t\\t\\t\\t\\t# \\t\\t\\t\\tas ax + by + c = 0\\n\\t\\t\\t\\t\\ta, b, c = y2 - y1, x1 - x2, x2 * y1 - x1 * y2\\n\\t\\t\\t\\t\\t# make sure a is positive\\n\\t\\t\\t\\t\\tif a < 0:\\n\\t\\t\\t\\t\\t\\ta, b, c = -a, -b, -c\\n\\t\\t\\t\\t\\t# get gcd of a, b and c\\n\\t\\t\\t\\t\\tg = reduce(gcd, (a, b, c))\\n\\t\\t\\t\\t\\t# reduce fraction\\n\\t\\t\\t\\t\\ta, b, c = a / g, b / g, c / g\\n\\t\\t\\t\\tline = (a, b, c)\\n\\t\\t\\t\\tpointsInLine.setdefault(line, set())\\n\\t\\t\\t\\tpointsInLine[line].add(i)\\n\\t\\t\\t\\tpointsInLine[line].add(j)\\n\\t\\t# edge case: return 0 for 0 point, 1 for 1 point\\n\\t\\treturn max(map(len, pointsInLine.itervalues())) if pointsInLine else len(points)\\n```",
                "solutionTags": [],
                "code": "```py\\n# Definition for a point.\\n# class Point(object):\\n#     def __init__(self, a=0, b=0):\\n#         self.x = a\\n#         self.y = b\\n\\nclass Solution(object):\\n\\tdef maxPoints(self, points):\\n\\t\\t\"\"\"\\n\\t\\t:type points: List[Point]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tdef gcd(a, b):\\n\\t\\t\\treturn gcd(b % a, a) if a != 0 else b\\n\\t\\tpointsInLine = {}\\n\\t\\t# idea:\\n\\t\\t# calculate the representation of the line between all pairs of points\\n\\t\\t# add points on the same line into a set\\n\\t\\t# pointsInLine[a, b, c] = set of all indices of points lying on the line ax + by + c = 0\\n\\t\\t# using indices to handle duplicates\\n\\t\\t# return the size of the largest set\\n\\t\\tfor i in xrange(len(points)):\\n\\t\\t\\tfor j in xrange(i + 1, len(points)):\\n\\t\\t\\t\\tx1, y1, x2, y2 = points[i].x, points[i].y, points[j].x, points[j].y\\n\\t\\t\\t\\t# line: ax + by + c = 0\\n\\t\\t\\t\\tif x1 == x2:\\n\\t\\t\\t\\t\\t# equation: x = x1\\n\\t\\t\\t\\t\\ta, b, c = 1, 0, -x1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t# not using usual linear equation y = kx + b\\n\\t\\t\\t\\t\\t# because of the precision problem of float\\n\\t\\t\\t\\t\\t# we need to make sure all numbers are integer\\n\\t\\t\\t\\t\\t# so use ax + by + c = 0 instead\\n\\t\\t\\t\\t\\t# value of a, b, c can be deduced from the following\\n\\t\\t\\t\\t\\t# simultaneous equations:\\n\\t\\t\\t\\t\\t# 1) ax1 + by1 + c = 0\\n\\t\\t\\t\\t\\t#    ax2 + by2 + c = 0\\n\\t\\t\\t\\t\\t# using basic algebra, we get:\\n\\t\\t\\t\\t\\t# 2) a/b = -(y2-y1)/(x2-x1), set a to y2-y1, b to x1-x2\\n\\t\\t\\t\\t\\t# substitute a and b into the previous simultaneous equations\\n\\t\\t\\t\\t\\t# we get: 3) c = x2y1-x1y2\\n\\t\\t\\t\\t\\t# To make sure the same (a, b, c) are calculated for all\\n\\t\\t\\t\\t\\t# same lines. We need to set some rules. Because values of\\n\\t\\t\\t\\t\\t# a and b are only bounded by a ratio (eq 2), and a and b\\n\\t\\t\\t\\t\\t# are picked arbitrarily.\\n\\t\\t\\t\\t\\t# first: make sure a is positive\\n\\t\\t\\t\\t\\t# \\t\\treason: -ax - by - c = 0 represents the same line\\n\\t\\t\\t\\t\\t# \\t\\t\\t\\tas ax + by + c = 0\\n\\t\\t\\t\\t\\t# second: reduce fraction of a, b and c\\n\\t\\t\\t\\t\\t# \\t\\treason: 2ax + 2by + 2c = 0 represents the same line\\n\\t\\t\\t\\t\\t# \\t\\t\\t\\tas ax + by + c = 0\\n\\t\\t\\t\\t\\ta, b, c = y2 - y1, x1 - x2, x2 * y1 - x1 * y2\\n\\t\\t\\t\\t\\t# make sure a is positive\\n\\t\\t\\t\\t\\tif a < 0:\\n\\t\\t\\t\\t\\t\\ta, b, c = -a, -b, -c\\n\\t\\t\\t\\t\\t# get gcd of a, b and c\\n\\t\\t\\t\\t\\tg = reduce(gcd, (a, b, c))\\n\\t\\t\\t\\t\\t# reduce fraction\\n\\t\\t\\t\\t\\ta, b, c = a / g, b / g, c / g\\n\\t\\t\\t\\tline = (a, b, c)\\n\\t\\t\\t\\tpointsInLine.setdefault(line, set())\\n\\t\\t\\t\\tpointsInLine[line].add(i)\\n\\t\\t\\t\\tpointsInLine[line].add(j)\\n\\t\\t# edge case: return 0 for 0 point, 1 for 1 point\\n\\t\\treturn max(map(len, pointsInLine.itervalues())) if pointsInLine else len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739295,
                "title": "simple-c-solution-2-approaches-brute-force-as-well-using-using-hashmap-16ms",
                "content": "**1.Brute force Approach:**\\nTime complexity : O(n^3)\\n**Runtime : 8ms**\\n![image](https://assets.leetcode.com/users/images/c46f254a-0f64-4e91-9245-22db6b75dd2a_1643805387.9644039.png)\\n\\n```\\nclass Solution{\\npublic :\\n    \\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2) return points.size();\\n        int res=0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++){\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                int x1 = points[i][0];\\n                int x2 = points[j][0];\\n                int y1 = points[i][1];\\n                int y2 = points[j][1];    \\n\\n                // double slope = double(y2 - y1)/double(x2 - x1);\\n                int total=2;\\n                for(int k=0;k<n && k!=i && k!=j;k++){\\n                    \\n                    int x = points[k][0];\\n                    int y = points[k][1];\\n                    // third point\\n                    // double(y - y1)/double(x1 - x1)\\n                    if((y2 - y1)*(x - x1) == (x2 - x1)*(y - y1))\\n                        total++;\\n                }\\n                res = max(res, total);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**2. using hashmap**\\nTime Complexity : O(n^2)\\n**Runtime : 20ms**\\n![image](https://assets.leetcode.com/users/images/1caabcb8-c0cc-4f16-8ce9-d4c778e1749d_1643805452.3230746.png)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // According to constraint we are allowed with maximum time complexity of O(n^3)\\n    // 1 <= points.length <= 300\\n    ///////   All the points are unique.\\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        if(points.size()<=2) return points.size(); // only two points are always on the same line, beacuse using 2 points\\n                                                    // line is made\\n        int res = 0;\\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            unordered_map<double, int> mp;\\n            int duplicate = 0;\\n            double slope = 0.0;\\n            for(int j = 0; j < points.size(); j++)\\n            {\\n                int x1 = points[i][0];\\n                int x2 = points[j][0];\\n                int y1 = points[i][1];\\n                int y2 = points[j][1];    \\n                \\n                // slope = dy/dx.\\n                int dy = y2 - y1;\\n                int dx = x2 - x1;\\n                if(dy == 0 && dx == 0){  // same overlapping point --> consider 2 same point as single point\\n                    duplicate++; \\n                    continue;\\n                }\\n                \\n                if(dx != 0)\\n                    slope = dy*1.0/dx; // store in double\\n                else // dx==0 means slope is infinity\\n                    slope = INT_MAX;\\n                \\n                mp[slope]++;\\n            }\\n\\n            if(mp.size() == 0)\\n                res = duplicate;\\n            else\\n            {\\n                for(auto slope : mp){\\n                    \\n                    res = max(res, slope.second + duplicate);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**if you like my approach please don\\'t forget to hit upvote button ! : )**\\n\\uD83D\\uDE07\\uD83D\\uDE07\\uD83D\\uDE07",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic :\\n    \\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2) return points.size();\\n        int res=0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++){\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                int x1 = points[i][0];\\n                int x2 = points[j][0];\\n                int y1 = points[i][1];\\n                int y2 = points[j][1];    \\n\\n                // double slope = double(y2 - y1)/double(x2 - x1);\\n                int total=2;\\n                for(int k=0;k<n && k!=i && k!=j;k++){\\n                    \\n                    int x = points[k][0];\\n                    int y = points[k][1];\\n                    // third point\\n                    // double(y - y1)/double(x1 - x1)\\n                    if((y2 - y1)*(x - x1) == (x2 - x1)*(y - y1))\\n                        total++;\\n                }\\n                res = max(res, total);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // According to constraint we are allowed with maximum time complexity of O(n^3)\\n    // 1 <= points.length <= 300\\n    ///////   All the points are unique.\\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        if(points.size()<=2) return points.size(); // only two points are always on the same line, beacuse using 2 points\\n                                                    // line is made\\n        int res = 0;\\n        for(int i = 0; i < points.size(); i++)\\n        {\\n            unordered_map<double, int> mp;\\n            int duplicate = 0;\\n            double slope = 0.0;\\n            for(int j = 0; j < points.size(); j++)\\n            {\\n                int x1 = points[i][0];\\n                int x2 = points[j][0];\\n                int y1 = points[i][1];\\n                int y2 = points[j][1];    \\n                \\n                // slope = dy/dx.\\n                int dy = y2 - y1;\\n                int dx = x2 - x1;\\n                if(dy == 0 && dx == 0){  // same overlapping point --> consider 2 same point as single point\\n                    duplicate++; \\n                    continue;\\n                }\\n                \\n                if(dx != 0)\\n                    slope = dy*1.0/dx; // store in double\\n                else // dx==0 means slope is infinity\\n                    slope = INT_MAX;\\n                \\n                mp[slope]++;\\n            }\\n\\n            if(mp.size() == 0)\\n                res = duplicate;\\n            else\\n            {\\n                for(auto slope : mp){\\n                    \\n                    res = max(res, slope.second + duplicate);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47102,
                "title": "20-line-c-o-n-2-hashing-solution",
                "content": "The idea is straight forward. Calculate each slope between two points and handle two special cases: 1. vertical, 2. duplicate. \\n\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) \\n        {\\n            if(points.size()<=2) return points.size();\\n            int res=0;\\n            for(int i=0;i<points.size()-1;i++) {\\n                int numVertical=1,local=1,duplicate=0;\\n                unordered_map<double,int> map;\\n                for(int j=i+1;j<points.size();j++) \\n                    if(points[i].x==points[j].x) // special cases\\n                        if(points[i].y==points[j].y) // duplicate \\n                            duplicate++;\\n                        else // vertical\\n                            numVertical++;\\n                    else {\\n                        double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x);\\n                        map[slope]==0?map[slope]=2:map[slope]++;\\n                        local=max(local,map[slope]);\\n                    }\\n                local=max(local+duplicate,numVertical+duplicate);\\n                res=max(res,local);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) \\n        {\\n            if(points.size()<=2) return points.size();\\n            int res=0;\\n            for(int i=0;i<points.size()-1;i++) {\\n                int numVertical=1,local=1,duplicate=0;\\n                unordered_map<double,int> map;\\n                for(int j=i+1;j<points.size();j++) \\n                    if(points[i].x==points[j].x) // special cases\\n                        if(points[i].y==points[j].y) // duplicate \\n                            duplicate++;\\n                        else // vertical\\n                            numVertical++;\\n                    else {\\n                        double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x);\\n                        map[slope]==0?map[slope]=2:map[slope]++;\\n                        local=max(local,map[slope]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 494635,
                "title": "come-on-in-correct-and-natural-solution-in-java",
                "content": "**Logic**\\nFor this problem, we can iterate each one of the points, scan the rest points after it, and find the number of points in the same line with that point. We update the global maximum one through the process.\\n\\nFor each point, there can be **unlimited lines** starting from it. So we need to a `Map` structure to keep track of each line and the number of points on it. **How to describe each line then?** It is the **slope**. **How to represent slope?** It is **`dy / dx`**, delta of `y` coordinate devided by delta of `x` coordinate. **How to store slope?** Possible optioanls are:\\n- `double slope` \\u274C\\n- `BigDecimal slope` \\u274C\\n- `int[] slope = new int[2];` \\u274C\\n- `List<Integer> slope = new List<>();` \\u2705\\n- `String slope` \\u2705\\uD83D\\uDC4D\\n\\n\\n`double` can be an option, but this is not gonna work actually \\u274C. Using decimal points causes 2 issues:\\n1. `/ by zero`. When `dx = 0`, the slope is `dy / 0` which will cause `java.lang.ArithmeticException: / by zero` in Java\\n2. Precision issue. We cannot compare the 2 slopes whose value are extreme close because `decimal` number in programming language can only have limited digits to represent fraction part. Java for example:\\n\\t> The `double` data type is a double-precision 64-bit IEEE 754 floating point.(From https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html),  A double variable can provide precision up to **15 to 16 decimal points** as compared to float precision of **6 to 7 decimal digits**. \\n\\t\\n\\tIf we look the following extreme example, the first 15 decimal points are exactly the same but the slope are not the same even really close.\\n\\n\\t```\\n\\t[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\t94911151 / 94911150 = 1.000000010536169  8809886931092922\\n\\t94911152 / 94911151 = 1.000000010536169  7699778185178684\\n\\t\\t\\t\\t\\t\\t    first 15 digits \\n\\t```\\n\\n`BigDecimal` will still have the same issue. \\u274C\\n\\n`int[] slope = new int[2]`: i.e. `Map<int[], Integer> map = new HashMap<>()`. But `int[]` actually **cannot** be the key of hashMap, bbecause hashCode() and equals() methods are not overriden. Its members only have `length` field and `clone()` method(referred from https://docs.oracle.com/javase/specs/jls/se7/html/jls-10.html#jls-10.7) \\u274C\\n\\n`List<Integer>`: i.e. `Map<List<Integer>, Integer> = new HashMap<>()`, it works compared with `int[]` as the key, since hashCode is element-wise for list. Check official document [here](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/List.html#hashCode%28%29). However, set an mutable data type as the key is really **a bad idea**, because if it is modified after insertion, it will result in undefined behavior in the `Map`. (However, even it is not recommended, it can still work) \\u2705\\n\\n`String`: `Map<String, Integer> = new HashMap<>()`, it is immutable compared to `List<Integer>`, so `String` should the best option. \\u2705\\uD83D\\uDC4D\\n\\n---\\nFor the `List<Integer>` and `String` options, we need to think about **Fraction Number**\\nAbove 2 options can be seen that we are using the fraction number form to represent the slope, **`numerator / denominator`**. To group the points together with same slope together, we need to store the fraction number `dy / dx` to its **the simplest form**(think about `2/4` and `3/6`). This can be done by deviding the numerator and denominator by their **greatest common devisor(gcd)**. GCD can be donw using **Euclidean algorithm**, it is nothing but a simple recursion method(remember to reverse the parameters!)\\n```java\\npublic int gcd(int num1, int num2){\\n    if(num1 == 0) return num1;\\n    return gcd(num2, num1 % num2);\\n}\\n```\\n\\n---\\n**Code**: `List<Integer>` as slope\\n```java\\nclass Solution {\\n    public int maxPoints(Point[] points) {\\n        // corner case\\n        if(points == null || points.length == 0) return 0;\\n        \\n        // key: slope<dy, dx>, value: freq\\n        Map<List<Integer>, Integer> map = new HashMap<>();\\n        int res = 0;\\n        \\n        int m = points.length;\\n        for(int i = 0; i < m; i++){\\n            int sameCount = 0;\\n            int max = 0;\\n            for(int j = i + 1; j < m; j++){\\n                int dy = points[j].y - points[i].y;\\n                int dx = points[j].x - points[i].x;\\n                if(dx == 0 && dy == 0){\\n                    sameCount++;\\n                }else{\\n                    List<Integer> slope = getSlope(dy, dx);\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                    max = Math.max(max, map.get(slope));\\n                }\\n            }\\n            res = Math.max(res, sameCount + max + 1);\\n            map.clear();\\n        }\\n        \\n        return res;\\n    }\\n    \\n\\t// return the irreducible slope by reducing dy and dx\\n    public List<Integer> getSlope(int dy, int dx){\\n        if(dx == 0) return Arrays.asList(1, 0);\\n        if(dy == 0) return Arrays.asList(0, 1);\\n        \\n        int d = gcd(dy, dx);\\n        return Arrays.asList(dy/d, dx/d);\\n    }\\n    \\n\\t// return the most common divisor of m and n using Euclidean algorithm\\n    public int gcd(int m, int n){\\n        if(n == 0) return m;\\n        return gcd(n, m % n);\\n    }\\n}\\n```\\n\\n---\\n**Code** with `String` as slope\\n**Updated:** Added code with more comment\\n```java\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points == null || points.length == 0 || points[0].length == 0) return 0;\\n        \\n        int res = 1;\\n        int n = points.length;\\n        \\n        // For this problem, we can iterate each one of the points, we scan the rest points, and find \\n\\t\\t// the number of points in the same line with that point\\n        for(int i = 0; i < n - 1; i++) {\\n            // because there can be unlimited lines starting from a single point we need a map to keep \\n\\t\\t\\t// track of the number points in different lines\\n            Map<String, Integer> slopeCountMap = new HashMap<>(); // <slope, count>\\n            // we are not using double to represent slope, because of the precision issue, and if the 2 \\n\\t\\t\\t// points have same x coordinates, then we will be deviding a number by 0 because the \\n\\t\\t\\t// denominator will be 0. \\n            \\n            // Fractions consist of two numbers: a numerator (which is above the line) and a denominator (which is below the line).\\n            \\n            // so instead we will use fraction to represent slope, and to help identify the same slope, \\n            // we will store fraction in simplest form in the map.\\n            \\n            // To find the slope in fraction in simplest form, we need to find the greatest common divisor, \\n            // short as gcd. And divide the numberator and denominator by gcd\\n            \\n            // we will iterate the points after this point\\n            for(int j = i + 1; j  < n; j++) {\\n                String slope = getSlope(points[i], points[j]);\\n                slopeCountMap.put(slope, slopeCountMap.getOrDefault(slope, 0) + 1);\\n                res = Math.max(res, slopeCountMap.get(slope) + 1);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n        \\n    public String getSlope(int[] point1, int[] point2) {\\n        int dx = point1[0] - point2[0];\\n        int dy = point1[1] - point2[1];\\n\\n        // The greatest common divisor (GCD) of two nonzero integers a and b is the greatest positive \\n        // integer d such that d is a divisor of both a and b; \\n        if(dx == 0 && dy == 0) return \"0/0\";\\n        if(dx == 0 && dy != 0) return \"1/0\";\\n        if(dx != 0 && dy == 0) return \"0/1\";\\n\\n        int gcd = getGCD(dx, dy);\\n        // we do not need to care abour the sign, because the gcd is already the same sign as \\n        // denominator, so the denominator is already positive. So the slope will be the same\\n        dx /= gcd;\\n        dy /= gcd;\\n        \\n        return dx + \"/\" + dy;\\n    }\\n\\n    public int getGCD(int num1, int num2) {\\n        if(num2 == 0) return num1;\\n\\n        return getGCD(num2, num1 % num2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\t94911151 / 94911150 = 1.000000010536169  8809886931092922\\n\\t94911152 / 94911151 = 1.000000010536169  7699778185178684\\n\\t\\t\\t\\t\\t\\t    first 15 digits \\n\\t```\n```java\\npublic int gcd(int num1, int num2){\\n    if(num1 == 0) return num1;\\n    return gcd(num2, num1 % num2);\\n}\\n```\n```java\\nclass Solution {\\n    public int maxPoints(Point[] points) {\\n        // corner case\\n        if(points == null || points.length == 0) return 0;\\n        \\n        // key: slope<dy, dx>, value: freq\\n        Map<List<Integer>, Integer> map = new HashMap<>();\\n        int res = 0;\\n        \\n        int m = points.length;\\n        for(int i = 0; i < m; i++){\\n            int sameCount = 0;\\n            int max = 0;\\n            for(int j = i + 1; j < m; j++){\\n                int dy = points[j].y - points[i].y;\\n                int dx = points[j].x - points[i].x;\\n                if(dx == 0 && dy == 0){\\n                    sameCount++;\\n                }else{\\n                    List<Integer> slope = getSlope(dy, dx);\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                    max = Math.max(max, map.get(slope));\\n                }\\n            }\\n            res = Math.max(res, sameCount + max + 1);\\n            map.clear();\\n        }\\n        \\n        return res;\\n    }\\n    \\n\\t// return the irreducible slope by reducing dy and dx\\n    public List<Integer> getSlope(int dy, int dx){\\n        if(dx == 0) return Arrays.asList(1, 0);\\n        if(dy == 0) return Arrays.asList(0, 1);\\n        \\n        int d = gcd(dy, dx);\\n        return Arrays.asList(dy/d, dx/d);\\n    }\\n    \\n\\t// return the most common divisor of m and n using Euclidean algorithm\\n    public int gcd(int m, int n){\\n        if(n == 0) return m;\\n        return gcd(n, m % n);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points == null || points.length == 0 || points[0].length == 0) return 0;\\n        \\n        int res = 1;\\n        int n = points.length;\\n        \\n        // For this problem, we can iterate each one of the points, we scan the rest points, and find \\n\\t\\t// the number of points in the same line with that point\\n        for(int i = 0; i < n - 1; i++) {\\n            // because there can be unlimited lines starting from a single point we need a map to keep \\n\\t\\t\\t// track of the number points in different lines\\n            Map<String, Integer> slopeCountMap = new HashMap<>(); // <slope, count>\\n            // we are not using double to represent slope, because of the precision issue, and if the 2 \\n\\t\\t\\t// points have same x coordinates, then we will be deviding a number by 0 because the \\n\\t\\t\\t// denominator will be 0. \\n            \\n            // Fractions consist of two numbers: a numerator (which is above the line) and a denominator (which is below the line).\\n            \\n            // so instead we will use fraction to represent slope, and to help identify the same slope, \\n            // we will store fraction in simplest form in the map.\\n            \\n            // To find the slope in fraction in simplest form, we need to find the greatest common divisor, \\n            // short as gcd. And divide the numberator and denominator by gcd\\n            \\n            // we will iterate the points after this point\\n            for(int j = i + 1; j  < n; j++) {\\n                String slope = getSlope(points[i], points[j]);\\n                slopeCountMap.put(slope, slopeCountMap.getOrDefault(slope, 0) + 1);\\n                res = Math.max(res, slopeCountMap.get(slope) + 1);\\n            }\\n        }\\n\\t\\t\\n        return res;\\n    }\\n        \\n    public String getSlope(int[] point1, int[] point2) {\\n        int dx = point1[0] - point2[0];\\n        int dy = point1[1] - point2[1];\\n\\n        // The greatest common divisor (GCD) of two nonzero integers a and b is the greatest positive \\n        // integer d such that d is a divisor of both a and b; \\n        if(dx == 0 && dy == 0) return \"0/0\";\\n        if(dx == 0 && dy != 0) return \"1/0\";\\n        if(dx != 0 && dy == 0) return \"0/1\";\\n\\n        int gcd = getGCD(dx, dy);\\n        // we do not need to care abour the sign, because the gcd is already the same sign as \\n        // denominator, so the denominator is already positive. So the slope will be the same\\n        dx /= gcd;\\n        dy /= gcd;\\n        \\n        return dx + \"/\" + dy;\\n    }\\n\\n    public int getGCD(int num1, int num2) {\\n        if(num2 == 0) return num1;\\n\\n        return getGCD(num2, num1 % num2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47268,
                "title": "two-concise-python-solutions",
                "content": "The first solution uses slope directly as the key for the dictionary. Python can handle it. The second solution uses a tuple of integer (dx, dy) as the key.\\n\\nSolution 1:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # slope : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap, curmax = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx, dy = points[j].x - points[i].x, points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                slope = dy * 1.0 / dx if dx != 0 else 'infinity'\\n                d[slope] += 1\\n                curmax = max(curmax, d[slope])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n\\n\\nSolution 2:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # (x,y) : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap = 0\\n            curmax = 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j].x - points[i].x\\n                dy = points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                gcd = self.getGcd(dx, dy)\\n                dx //= gcd\\n                dy //= gcd\\n                d[(dx,dy)] += 1\\n                curmax = max(curmax, d[(dx,dy)])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n    \\n    def getGcd(self, a, b):\\n        if b == 0: return a\\n        return self.getGcd(b, a%b)",
                "solutionTags": [],
                "code": "The first solution uses slope directly as the key for the dictionary. Python can handle it. The second solution uses a tuple of integer (dx, dy) as the key.\\n\\nSolution 1:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # slope : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap, curmax = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx, dy = points[j].x - points[i].x, points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                slope = dy * 1.0 / dx if dx != 0 else 'infinity'\\n                d[slope] += 1\\n                curmax = max(curmax, d[slope])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n\\n\\nSolution 2:\\n\\n    def maxPoints(self, points):\\n        if len(points) <= 2: return len(points)\\n        d = collections.defaultdict(int) # (x,y) : count\\n        result = 0\\n        for i in range(len(points)):\\n            d.clear()\\n            overlap = 0\\n            curmax = 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j].x - points[i].x\\n                dy = points[j].y - points[i].y\\n                if dx == 0 and dy == 0:\\n                    overlap += 1\\n                    continue\\n                gcd = self.getGcd(dx, dy)\\n                dx //= gcd\\n                dy //= gcd\\n                d[(dx,dy)] += 1\\n                curmax = max(curmax, d[(dx,dy)])\\n            result = max(result, curmax+overlap+1)\\n        return result\\n    \\n    def getGcd(self, a, b):\\n        if b == 0: return a\\n        return self.getGcd(b, a%b)",
                "codeTag": "Python3"
            },
            {
                "id": 3016632,
                "title": "python-3-11-lines-w-explanation-and-example-t-m-95-97",
                "content": "Here\\'s the plan:\\n- We compute `dx` and `dy`, the changes of`x`and`y`,respectively, for each pair in`points`.\\n- We keep track of the slopes of each line segment formed by such a pair. Instead of computing the ratio`dy/dx`, we divide each quantity by their common gcd (much like reducing a fraction) and express the slope as a tuple`(dx,dy)`.\\n- We count the line segments with the dict `slope`, using their tuples as the key. The endpoints of any two or more line segments with the same key are on the same line, and the number of points on the line is one greater than the number of line segments.\\n```\\nclass Solution:\\n    def maxPoints(self, points: list[list[int]]) -> int:\\n                                                #   points = [[1,0],[2,1],[3,4], [5,4]]\\n\\n        points.sort()                           #   point1 point2 (dx,dy)    m     slope                M\\n        slope, M = defaultdict(int), 0          #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                #   [1,0]  [2,1]   (1,1)   (1,1)   {(1,1):1}            1\\n        for i, (x1, y1) in enumerate(points):   #          [3,4]   (2,4)   (1,2)   {(1,1):1,(1,2):1}    1\\n                                                #          [5,4]   (4,4)   (1,1)   {(1,1):2,(1,2):1}    2\\n            slope.clear()                       #   [2,1]  [3,4]   (1,3)   (1,3)   {(1,3):1}            2\\n                                                #          [5,4]   (3,3)   (1,1)   {(1,3):1,(1,1):1}    2\\n            for x2, y2 in points[i + 1:]:       #   [3,4]  [5,4]   (3,0)   (1,0)   {(1,0):1}            2\\n                dx, dy = x2 - x1, y2 - y1\\n                                                #  M + 1 = 2 + 1 = 3 <-- return\\n                G = gcd(dx, dy)                 \\n                m = (dx//G,dy//G)\\n                \\n                slope[m] += 1\\n                if slope[m] > M: M = slope[m]\\n    \\n        return M + 1\\n\\n```\\n[https://leetcode.com/problems/max-points-on-a-line/submissions/873726776/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: list[list[int]]) -> int:\\n                                                #   points = [[1,0],[2,1],[3,4], [5,4]]\\n\\n        points.sort()                           #   point1 point2 (dx,dy)    m     slope                M\\n        slope, M = defaultdict(int), 0          #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013        \\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                #   [1,0]  [2,1]   (1,1)   (1,1)   {(1,1):1}            1\\n        for i, (x1, y1) in enumerate(points):   #          [3,4]   (2,4)   (1,2)   {(1,1):1,(1,2):1}    1\\n                                                #          [5,4]   (4,4)   (1,1)   {(1,1):2,(1,2):1}    2\\n            slope.clear()                       #   [2,1]  [3,4]   (1,3)   (1,3)   {(1,3):1}            2\\n                                                #          [5,4]   (3,3)   (1,1)   {(1,3):1,(1,1):1}    2\\n            for x2, y2 in points[i + 1:]:       #   [3,4]  [5,4]   (3,0)   (1,0)   {(1,0):1}            2\\n                dx, dy = x2 - x1, y2 - y1\\n                                                #  M + 1 = 2 + 1 = 3 <-- return\\n                G = gcd(dx, dy)                 \\n                m = (dx//G,dy//G)\\n                \\n                slope[m] += 1\\n                if slope[m] > M: M = slope[m]\\n    \\n        return M + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018587,
                "title": "explanation-with-simulation-images-from-high-school-to-leetcode-easy-geometry",
                "content": "# Simulation and Understanding:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose, we have input = [[1, 1], [2, 2], [3, 3]]. We need to find the maximum number of points that are on a line. If you have some idea of the slope of tangent, you will catch that this must be done using the slope of tangent method. All points on a line have the same slope. Therefore, the tangent will be equal.\\n\\n![image.png](https://assets.leetcode.com/users/images/b28fedc7-7854-42ab-be4b-519f26fb78ab_1673167992.4192362.png)\\n\\n\\n- Behind the Scene Geometry: \\n\\n![image.png](https://assets.leetcode.com/users/images/ce44647b-5a6e-4cee-8c28-03b1fc65bd6e_1673168043.211971.png)\\n\\nTo calcualte the tangent of single point, we need another reference point. \\nIn the above case, $$[0, 0]$$ is our reference point. Using the above formula we can calculate the tangent of point $$[1, 1]$$.\\n\\n## Let\\'s get into the understanding with simulation:\\n\\n### Approach: \\n\\n- For each point, we will calculate the tangent with other points. \\n- We will store them into a tangent map.\\n- After it is done, we will calculate the max points that have the same tangent from the `tangentMap`.\\n- Finally, return the `max`.\\n\\nSo, for point $$[1, 1]$$ our simulation will look like this:\\n\\n![image.png](https://assets.leetcode.com/users/images/d606a478-2916-4d7f-8596-090f2e7d8f3e_1673168181.3943129.png)\\n\\n\\nWe can see that points $$[2,2]$$ and $$[3,3]$$ have the same tangent with point $$[1,1]$$. So, all these 3 points (including point $$[1,1]$$ itself) are on the same line.\\n\\nSimilarly, we will iterate the loop using point $$[2, 2]$$ and so on.\\n\\n\\n\\n# Complexity:\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we have used nested **for** loops. It will require $$n^2$$ time.\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we have used a hashMap and it\\'s size depends on the length of the points array, in worst case, we will need a hashmap of size $$n$$. So, the space complexity is $$O(n)$$.\\n\\n# Code:\\nSimilar in other languages. Just change of some syntax.\\n``` java []\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        // if there is only one point, the max points will be 1\\n        if( n == 1) return 1;\\n        // if there are more points, the max will be at least 2\\n        int max = 2;\\n        for(int i=0; i<n-1; i++){\\n            Map<Double, Integer> tangentMap = new HashMap<>();\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                \\n                int[] p1 = points[i];\\n                int[] p2 = points[j];\\n                int x1 = p1[0];\\n                int y1 = p1[1];\\n                int x2 = p2[0];\\n                int y2 = p2[1];\\n                \\n                // calculate the tangent..\\n                double tangent = Math.atan2((y2-y1),(x2-x1));\\n                int c = tangentMap.getOrDefault(tangent, 0);\\n                // increase the count..\\n                tangentMap.put(tangent, c+1);\\n            }\\n\\n            // calculate the max points from the tangentMap.\\n            // To include the point points[i] itself \\n            // we added +1 to the values\\n            max = Math.max(max, Collections.max(tangentMap.values())+1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        // if there is only one point, the max points will be 1\\n        if( n == 1) return 1;\\n        // if there are more points, the max will be at least 2\\n        int maxAns = 2;\\n        for(int i=0; i<n-1; i++){\\n            map<double, int> tangentMap;\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                \\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                \\n                // calculate the tangent..\\n                double tangent = atan2((y2-y1),(x2-x1));\\n                // increase the count..\\n                tangentMap[tangent]++;\\n                // calculate the max points from the tangentMap.\\n                // To include the point points[i] itself \\n                // we added +1 to the values\\n                maxAns = max(maxAns, tangentMap[tangent]+1);\\n            }\\n        }\\n        \\n        return maxAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        // if there is only one point, the max points will be 1\\n        if( n == 1) return 1;\\n        // if there are more points, the max will be at least 2\\n        int max = 2;\\n        for(int i=0; i<n-1; i++){\\n            Map<Double, Integer> tangentMap = new HashMap<>();\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                \\n                int[] p1 = points[i];\\n                int[] p2 = points[j];\\n                int x1 = p1[0];\\n                int y1 = p1[1];\\n                int x2 = p2[0];\\n                int y2 = p2[1];\\n                \\n                // calculate the tangent..\\n                double tangent = Math.atan2((y2-y1),(x2-x1));\\n                int c = tangentMap.getOrDefault(tangent, 0);\\n                // increase the count..\\n                tangentMap.put(tangent, c+1);\\n            }\\n\\n            // calculate the max points from the tangentMap.\\n            // To include the point points[i] itself \\n            // we added +1 to the values\\n            max = Math.max(max, Collections.max(tangentMap.values())+1);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        // if there is only one point, the max points will be 1\\n        if( n == 1) return 1;\\n        // if there are more points, the max will be at least 2\\n        int maxAns = 2;\\n        for(int i=0; i<n-1; i++){\\n            map<double, int> tangentMap;\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                \\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                \\n                // calculate the tangent..\\n                double tangent = atan2((y2-y1),(x2-x1));\\n                // increase the count..\\n                tangentMap[tangent]++;\\n                // calculate the max points from the tangentMap.\\n                // To include the point points[i] itself \\n                // we added +1 to the values\\n                maxAns = max(maxAns, tangentMap[tangent]+1);\\n            }\\n        }\\n        \\n        return maxAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019363,
                "title": "my-accepted-solution-98-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n      public int maxPoints(int[][] arr) {\\n        int max = 1;\\n        for (int i = 0; i < arr.length; i++) {\\n            HashMap<Double, Integer> map = new HashMap<>();\\n            for (int j = 0; j < arr.length; j++) {\\n                if (i == j) continue;\\n                double slope = (arr[j][0] - arr[i][0]) != 0 ? (arr[j][1] - arr[i][1]) * 1.0 / (arr[j][0] - arr[i][0]) : Integer.MAX_VALUE;\\n                map.put(slope, map.getOrDefault(slope, 1) + 1);\\n                max = Math.max(max, map.get(slope));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public int maxPoints(int[][] arr) {\\n        int max = 1;\\n        for (int i = 0; i < arr.length; i++) {\\n            HashMap<Double, Integer> map = new HashMap<>();\\n            for (int j = 0; j < arr.length; j++) {\\n                if (i == j) continue;\\n                double slope = (arr[j][0] - arr[i][0]) != 0 ? (arr[j][1] - arr[i][1]) * 1.0 / (arr[j][0] - arr[i][0]) : Integer.MAX_VALUE;\\n                map.put(slope, map.getOrDefault(slope, 1) + 1);\\n                max = Math.max(max, map.get(slope));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47330,
                "title": "does-anyone-use-the-idea-of-hough-transform-o-n",
                "content": "When I first read the question, the idea of \"hough transform\" pops out. I wrote my solution using this idea, but I get a TLE. As you may see, the complexity of Hough transform is only O(180N), which is much lower than those O(N^2) solutions in this discussion board.\\n\\nI expected to see a \"wrong answer\" error, because \"hough transform\" has the parameter theta ( in polar coordinates ): you may have to sample the entire theta space and thus get an approximate result instead of an accurate one. Anyway, I guess some of you might be interested in knowing this classic pattern recognition algorithm. \\n\\n\\n    #define computeRho( pt, T ) ( ( pt.x * cos( T ) ) + ( pt.y * sin( T ) ) ) \\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            if ( points.size() <= 2 ) {\\n                return points.size();\\n            }\\n            int max_points = 0;\\n            for ( int i = 0; i < 180; i++ ) {\\n                double theta = double( i ) / 180.0 * 3.141592657;\\n                map<int,int> accumulator;\\n                for ( int j = 0; j < points.size(); j++ ) {\\n                    int rho = round( computeRho( points[j], theta ) );\\n                    accumulator[ rho ]++;\\n                    if ( accumulator[ rho ] > max_points ) {\\n                        max_points = accumulator[ rho ];\\n                    }\\n                }\\n            }\\n            return max_points;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            if ( points.size() <= 2 ) {\\n                return points.size();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3016367,
                "title": "c-hashmap-slope-faster-easy-to-understand",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // take every point and find the slope with other points\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // declare a map which will store the frequency of each slope\\n            \\n            unordered_map<double, int> mp;\\n            \\n            int temp_max = 0;\\n            \\n            int x1 = arr[i][0];\\n            \\n            int y1 = arr[i][1];\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                {\\n                    continue;\\n                }\\n                \\n                int x2 = arr[j][0];\\n                \\n                int y2 = arr[j][1];\\n                \\n                double nume = y2 - y1;\\n                \\n                double deno = x2 - x1;\\n                \\n                // if denominator will be zero then slope will be INT_MAX\\n                \\n                if(deno == 0)\\n                {\\n                    mp[INT_MAX]++;\\n                    \\n                    // update temp_max\\n                    \\n                    temp_max = max(temp_max, mp[INT_MAX]);\\n                    \\n                    continue;\\n                }\\n                \\n                // find the slope and update frequency\\n                \\n                double slope = nume / deno;\\n                \\n                mp[slope]++;\\n                \\n                temp_max = max(temp_max, mp[slope]);\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, temp_max + 1);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // take every point and find the slope with other points\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // declare a map which will store the frequency of each slope\\n            \\n            unordered_map<double, int> mp;\\n            \\n            int temp_max = 0;\\n            \\n            int x1 = arr[i][0];\\n            \\n            int y1 = arr[i][1];\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                {\\n                    continue;\\n                }\\n                \\n                int x2 = arr[j][0];\\n                \\n                int y2 = arr[j][1];\\n                \\n                double nume = y2 - y1;\\n                \\n                double deno = x2 - x1;\\n                \\n                // if denominator will be zero then slope will be INT_MAX\\n                \\n                if(deno == 0)\\n                {\\n                    mp[INT_MAX]++;\\n                    \\n                    // update temp_max\\n                    \\n                    temp_max = max(temp_max, mp[INT_MAX]);\\n                    \\n                    continue;\\n                }\\n                \\n                // find the slope and update frequency\\n                \\n                double slope = nume / deno;\\n                \\n                mp[slope]++;\\n                \\n                temp_max = max(temp_max, mp[slope]);\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, temp_max + 1);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005591,
                "title": "c-simple-beats-99-99-no-need-complicated-magic-for-slope",
                "content": "The trick is to use long double instad of double to adjust the precision.\\nEnjoy!\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int result = 0;\\n        for(int i=0; i<points.size();++i){\\n            unordered_map<long double,int> h;\\n            int same = 1;\\n            int localmax = 0;\\n            for(int j=i+1;j<points.size();++j){\\n                if(points[i][0] == points[j][0] && points[i][1]==points[j][1]){\\n                    same++;\\n                }\\n                else if(points[i][0]==points[j][0]){\\n                    h[INT_MAX]++;\\n                }\\n                else{\\n                    long double slope = (long double)(points[i][1] - points[j][1])/(long double)(points[i][0] - points[j][0]);\\n                    h[slope]++;\\n                }\\n            }\\n            for(auto i : h){\\n                localmax = max(localmax,i.second);\\n            }\\n            localmax +=same;\\n            result = max(result,localmax);\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int result = 0;\\n        for(int i=0; i<points.size();++i){\\n            unordered_map<long double,int> h;\\n            int same = 1;\\n            int localmax = 0;\\n            for(int j=i+1;j<points.size();++j){\\n                if(points[i][0] == points[j][0] && points[i][1]==points[j][1]){\\n                    same++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 47101,
                "title": "7-line-c-concise-solution-no-double-hash-key-or-gcd-for-slope",
                "content": "The key to this problem is how to characterize \"slope\" determined by two points. I see many posts here using either a ```double```to represent slope or ```pair<int,int>```with GCD process to make it unique. But this either has issues with numerical accuracy or having to do the recursive calculation.\\n\\nThe idea here is to simply define an order of slope in the representation of ```pair<int,int>```: \\n\\n**Define slope `a:=(a.x, a.y)`is *less than* slope `b:=(b.x, b.y)` if**\\n* **`(a.y*b.y > 0)? a.x*b.y < a.y*b.x : a.x*b.y > a.y*b.x`**. \\n\\nNote that this formulation is actually an extension to the traditional slope calculation `x/y` which not only needs to deal with `y == 0`as corner case but also unavoidably involves floating point numerical comparison. \\n\\nOnce the order is defined, it can be used as a key in ```std::map``` for counting purpose to gather points along the same line with a reference point, i.e., \\n* define `map<Point, int> count` with `count[Point(x,y)]` being the number of points with slope `(x,y)` to the reference point. \\n\\nNote that we count singular slope `(0,0)` (i.e., duplicated points) separately since this \"special\" slope is essentially undefined.\\n\\nSince an ordered container ```std::map```is used, the time complexity is ```O(N^2*logN)```. The space complexity is ```O(N)```to store `map<Point, int> count`.\\n```cpp\\n    int maxPoints(vector<Point>& pts) {\\n        int maxPts = 0;\\n        for (auto& i:pts) {\\n          map<Point, int, Comp> count; int dup = 0;\\n          for (auto& j:pts) {\\n              int curMax = (i.x==j.x && i.y==j.y)? ++dup : ++count[Point(i.x-j.x,i.y-j.y)]+dup;\\n              maxPts = max(maxPts, curMax);\\n          }\\n        }\\n        return maxPts;\\n    }\\n        \\n    struct Comp { // comparator for key (slope) in map\\n        bool operator()(const Point& a, const Point& b) \\n        { \\n          int64_t diff = (int64_t)a.x*b.y - (int64_t)a.y*b.x; // convert to 64bit int for int overflow\\n          return (int64_t)a.y*b.y>0? diff > 0 : diff < 0;\\n        } \\n    };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```double```\n```pair<int,int>```\n```pair<int,int>```\n```std::map```\n```std::map```\n```O(N^2*logN)```\n```O(N)```\n```cpp\\n    int maxPoints(vector<Point>& pts) {\\n        int maxPts = 0;\\n        for (auto& i:pts) {\\n          map<Point, int, Comp> count; int dup = 0;\\n          for (auto& j:pts) {\\n              int curMax = (i.x==j.x && i.y==j.y)? ++dup : ++count[Point(i.x-j.x,i.y-j.y)]+dup;\\n              maxPts = max(maxPts, curMax);\\n          }\\n        }\\n        return maxPts;\\n    }\\n        \\n    struct Comp { // comparator for key (slope) in map\\n        bool operator()(const Point& a, const Point& b) \\n        { \\n          int64_t diff = (int64_t)a.x*b.y - (int64_t)a.y*b.x; // convert to 64bit int for int overflow\\n          return (int64_t)a.y*b.y>0? diff > 0 : diff < 0;\\n        } \\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1941855,
                "title": "100-fastest-swift-solution-hashmap-o-n-2",
                "content": "```\\nclass Solution {\\n\\t// - Complexity:\\n    //   - HashMap O(n ^ 2)\\n\\n\\tfunc maxPoints(_ points: [[Int]]) -> Int {\\n\\t\\tguard points.count > 2 else { return points.count }\\n\\t\\t\\n        var map: [String: Set<Int>] = [:]\\n\\t\\tvar max = 0\\n\\t\\t\\n        for i in 0..<points.count {\\n\\t\\t\\tif i + 1 >= points.count { break }\\n\\t\\t\\t\\n            for j in i+1..<points.count {\\n\\t\\t\\t\\tlet line = lineOfTwoPoint(i, j, points)\\n\\t\\t\\t\\tlet key = \"\\\\(line.0)-\\\\(line.1)\"\\n                var indexs = map[key] != nil ? map[key]! : Set<Int>()\\n                \\n                indexs.insert(i)\\n                indexs.insert(j)\\n                map[key] = indexs\\n\\t\\t\\t\\tmax = max > map[key]!.count ? max : map[key]!.count\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn max\\n\\t}\\n\\n\\t// y = kx + a, idx0, idx1\\n\\tfunc lineOfTwoPoint(_ idx0: Int, _ idx1: Int, _ points: [[Int]]) -> (Double, Double) {\\n\\t\\tlet p0 = points[idx0]\\n\\t\\tlet p1 = points[idx1]\\n\\t\\tvar k, a: Double\\n\\t\\t\\n        if p0[1] == p1[1] {\\n\\t\\t\\tk = 0\\n\\t\\t\\ta = Double(p0[1])\\n\\t\\t\\n        } else if p0[0] == p1[0] {\\n\\t\\t\\tk = Double(Int.max)\\n\\t\\t\\ta = Double(p0[0])\\n\\t\\t\\n        } else {\\n\\t\\t\\n            k = Double(p0[1] - p1[1]) / Double(p0[0] - p1[0])\\n\\t\\t\\ta = Double(p0[1]) - k * Double(p0[0])\\n\\t\\t}\\n        \\n\\t\\treturn (k, a)\\n\\t}\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\t// - Complexity:\\n    //   - HashMap O(n ^ 2)\\n\\n\\tfunc maxPoints(_ points: [[Int]]) -> Int {\\n\\t\\tguard points.count > 2 else { return points.count }\\n\\t\\t\\n        var map: [String: Set<Int>] = [:]\\n\\t\\tvar max = 0\\n\\t\\t\\n        for i in 0..<points.count {\\n\\t\\t\\tif i + 1 >= points.count { break }\\n\\t\\t\\t\\n            for j in i+1..<points.count {\\n\\t\\t\\t\\tlet line = lineOfTwoPoint(i, j, points)\\n\\t\\t\\t\\tlet key = \"\\\\(line.0)-\\\\(line.1)\"\\n                var indexs = map[key] != nil ? map[key]! : Set<Int>()\\n                \\n                indexs.insert(i)\\n                indexs.insert(j)\\n                map[key] = indexs\\n\\t\\t\\t\\tmax = max > map[key]!.count ? max : map[key]!.count\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn max\\n\\t}\\n\\n\\t// y = kx + a, idx0, idx1\\n\\tfunc lineOfTwoPoint(_ idx0: Int, _ idx1: Int, _ points: [[Int]]) -> (Double, Double) {\\n\\t\\tlet p0 = points[idx0]\\n\\t\\tlet p1 = points[idx1]\\n\\t\\tvar k, a: Double\\n\\t\\t\\n        if p0[1] == p1[1] {\\n\\t\\t\\tk = 0\\n\\t\\t\\ta = Double(p0[1])\\n\\t\\t\\n        } else if p0[0] == p1[0] {\\n\\t\\t\\tk = Double(Int.max)\\n\\t\\t\\ta = Double(p0[0])\\n\\t\\t\\n        } else {\\n\\t\\t\\n            k = Double(p0[1] - p1[1]) / Double(p0[0] - p1[0])\\n\\t\\t\\ta = Double(p0[1]) - k * Double(p0[0])\\n\\t\\t}\\n        \\n\\t\\treturn (k, a)\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47169,
                "title": "my-java-accepted-solution-for-your-reference-only-using-array",
                "content": "        public class Solution \\n        {\\n            public int maxPoints(Point[] points) \\n            {\\n                int n=points.length;\\n                if (n<2) return n;\\n                int currentL=0,maxL=2,x=0,y=0,dx=0,dy=0,overlap=0,upperB=n;\\n                for(int i=0; i<upperB; i++)\\n                {\\n                    for(int j=i+1; j<n; j++)\\n                    {\\n                        currentL=1; \\n    /*\\n     * Given two points: (a,b) and (c,d), the corresponding normal vector is (b-d,c-a)\\n     * If another point (s,t) is in the same line uniquely defined by (a,b) and (c,d),\\n     * then (s-a,t-b) dot (b-d,c-a) = 0\\n     */\\n                        x=points[i].y-points[j].y;\\n                        y=points[j].x-points[i].x;\\n    \\n    /* If two points are the same, there is no need to check further, \\n     * since a line has to be defined by exactly two distinct points.\\n     */\\n                        if(x==0 && y==0) \\n                            overlap++;\\n    \\n    /* Well, it might be the case that duplicates are not consecutive, \\n     * but as long as we can have a non-trivial normal vector, it won't matter.\\n     */ \\n                        else \\n                        {\\n                            currentL++;\\n    \\n    /*  Explaining (currentL+n-k>maxL):\\n     *  no further checking is necessary when there isn't enough left to make it surpass maxL. \\n     */ \\n                            for(int k=j+1; k<n && currentL+n-k>maxL; k++)\\n                            {\\n                                dx=points[k].x-points[i].x;\\n                                dy=points[k].y-points[i].y;\\n                                if(x*dx+y*dy==0)\\n                                    currentL++;\\n                            }\\n                        }\\n                        maxL=Math.max(currentL+overlap,maxL);\\n                    }\\n    \\n    /* Explaining (upperB=n-maxL): \\n     * it would be crystal clear as soon as you draw a table for combinations of case n>3.\\n     */\\n                    upperB=n-maxL;\\n                    overlap=0;\\n                }\\n                return maxL;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution \\n        {\\n            public int maxPoints(Point[] points) \\n            {\\n                int n=points.length;\\n                if (n<2) return n;\\n                int currentL=0,maxL=2,x=0,y=0,dx=0,dy=0,overlap=0,upperB=n;\\n                for(int i=0; i<upperB; i++)\\n                {\\n                    for(int j=i+1; j<n; j++)\\n                    {\\n                        currentL=1; \\n    /*\\n     * Given two points: (a,b) and (c,d), the corresponding normal vector is (b-d,c-a)\\n     * If another point (s,t) is in the same line uniquely defined by (a,b) and (c,d),\\n     * then (s-a,t-b) dot (b-d,c-a) = 0\\n     */\\n                        x=points[i].y-points[j].y;\\n                        y=points[j].x-points[i].x;\\n    \\n    /* If two points are the same, there is no need to check further, \\n     * since a line has to be defined by exactly two distinct points.\\n     */\\n                        if(x==0 && y==0) \\n                            overlap++;\\n    \\n    /* Well, it might be the case that duplicates are not consecutive, \\n     * but as long as we can have a non-trivial normal vector, it won't matter.\\n     */ \\n                        else \\n                        {\\n                            currentL++;\\n    \\n    /*  Explaining (currentL+n-k>maxL):\\n     *  no further checking is necessary when there isn't enough left to make it surpass maxL. \\n     */ \\n                            for(int k=j+1; k<n && currentL+n-k>maxL; k++)\\n                            {\\n                                dx=points[k].x-points[i].x;\\n                                dy=points[k].y-points[i].y;\\n                                if(x*dx+y*dy==0)\\n                                    currentL++;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 3016303,
                "title": "java-c-javascript-beats-90-map-o-n-2-time",
                "content": "```java []\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int max=0;\\n        // x -> x[0],x[1]  (x1,y1)\\n        for(int[] x:points)\\n        {\\n            Map<Double,Integer> map= new HashMap<>();\\n            // y -> y[0],y[1]  (x2,y2)\\n            for(int[] y:points){\\n                if(x==y)\\n                  continue;\\n                \\n                double slope=0;\\n                // if (x2 - x1 == 0) \\n                if(y[0]-x[0]==0)\\n                   slope=Double.POSITIVE_INFINITY; \\n                else\\n                   // slope = (y2 - y1) / (x2 - x1)\\n                   slope = (y[1]-x[1])/(double)(y[0]-x[0]);\\n                \\n                map.put(slope,map.getOrDefault(slope,0)+1);\\n                max=Math.max(max,map.get(slope));\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi = 0;\\n        // x -> x[0],x[1]  (x1,y1)\\n        for (auto& x : points) {\\n            map<double, int> slopes;\\n            // y -> y[0],y[1]  (x2,y2)\\n            for (auto& y : points) {\\n                if (x == y) continue;\\n                double slope = numeric_limits<double>::infinity();\\n                // if (x2 - x1 != 0)\\n                if (y[0] - x[0] != 0) {\\n                    // slope = (y2 - y1) / (x2 - x1)\\n                    slope = (double)(y[1] - x[1]) / (y[0] - x[0]);\\n                }\\n                ++slopes[slope];\\n                maxi = max(maxi, slopes[slope]);\\n            }\\n        }\\n        return maxi + 1;\\n    }\\n};\\n```\\n```javascript []\\nvar maxPoints = function(points) {\\n  let max = 0;\\n    // x -> x[0],x[1]  (x1,y1)\\n    for (const x of points) {\\n      const slopes = new Map();\\n    // y -> y[0],y[1]  (x2,y2)\\n    for (const y of points) {\\n      if (x === y) continue;\\n      let slope = Infinity;\\n      // if (x2 - x1 != 0)\\n      if (y[0] - x[0] !== 0) {\\n        // slope = (y2 - y1) / (x2 - x1)\\n        slope = (y[1] - x[1]) / (y[0] - x[0]);\\n      }\\n      if (slopes.has(slope)) {\\n        slopes.set(slope, slopes.get(slope) + 1);\\n      } else {\\n        slopes.set(slope, 1);\\n      }\\n      max = Math.max(max, slopes.get(slope));\\n    }\\n  }\\n  return max + 1;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Math",
                    "Geometry"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int max=0;\\n        // x -> x[0],x[1]  (x1,y1)\\n        for(int[] x:points)\\n        {\\n            Map<Double,Integer> map= new HashMap<>();\\n            // y -> y[0],y[1]  (x2,y2)\\n            for(int[] y:points){\\n                if(x==y)\\n                  continue;\\n                \\n                double slope=0;\\n                // if (x2 - x1 == 0) \\n                if(y[0]-x[0]==0)\\n                   slope=Double.POSITIVE_INFINITY; \\n                else\\n                   // slope = (y2 - y1) / (x2 - x1)\\n                   slope = (y[1]-x[1])/(double)(y[0]-x[0]);\\n                \\n                map.put(slope,map.getOrDefault(slope,0)+1);\\n                max=Math.max(max,map.get(slope));\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi = 0;\\n        // x -> x[0],x[1]  (x1,y1)\\n        for (auto& x : points) {\\n            map<double, int> slopes;\\n            // y -> y[0],y[1]  (x2,y2)\\n            for (auto& y : points) {\\n                if (x == y) continue;\\n                double slope = numeric_limits<double>::infinity();\\n                // if (x2 - x1 != 0)\\n                if (y[0] - x[0] != 0) {\\n                    // slope = (y2 - y1) / (x2 - x1)\\n                    slope = (double)(y[1] - x[1]) / (y[0] - x[0]);\\n                }\\n                ++slopes[slope];\\n                maxi = max(maxi, slopes[slope]);\\n            }\\n        }\\n        return maxi + 1;\\n    }\\n};\\n```\n```javascript []\\nvar maxPoints = function(points) {\\n  let max = 0;\\n    // x -> x[0],x[1]  (x1,y1)\\n    for (const x of points) {\\n      const slopes = new Map();\\n    // y -> y[0],y[1]  (x2,y2)\\n    for (const y of points) {\\n      if (x === y) continue;\\n      let slope = Infinity;\\n      // if (x2 - x1 != 0)\\n      if (y[0] - x[0] !== 0) {\\n        // slope = (y2 - y1) / (x2 - x1)\\n        slope = (y[1] - x[1]) / (y[0] - x[0]);\\n      }\\n      if (slopes.has(slope)) {\\n        slopes.set(slope, slopes.get(slope) + 1);\\n      } else {\\n        slopes.set(slope, 1);\\n      }\\n      max = Math.max(max, slopes.get(slope));\\n    }\\n  }\\n  return max + 1;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016349,
                "title": "explained-java-solution",
                "content": "We compare the slopes for different 2nd points keeping the first point same. Points are on the same line if they have the same m (slope) and c (intercept). So when we keep the first point same , we dont need to compare the intercept hence only slope variable is used. \\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) \\n    {\\n        int max = 0;\\n        for(int[] point_1 : points)\\n        {\\n            Map<Double,Integer> map= new HashMap<>();\\n            for(int[] point_2 : points)\\n            {\\n                if(point_1 == point_2) continue;\\n                \\n                double slope=0;\\n                // if x2 - x1 are equal then line is vertical\\n                if(point_2[0] == point_1[0])\\n                   slope=Double.POSITIVE_INFINITY; \\n                else\\n                {\\n                    // slope (m) = (y2 - y1) / (x2 - x1) \\n                    slope = (point_2[1] - point_1[1]) / (double)(point_2[0] - point_1[0]);\\n                }\\n                map.put( slope , map.getOrDefault(slope,0)+1 );\\n                if(map.get(slope)>max)\\n                    max=map.get(slope);\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) \\n    {\\n        int max = 0;\\n        for(int[] point_1 : points)\\n        {\\n            Map<Double,Integer> map= new HashMap<>();\\n            for(int[] point_2 : points)\\n            {\\n                if(point_1 == point_2) continue;\\n                \\n                double slope=0;\\n                // if x2 - x1 are equal then line is vertical\\n                if(point_2[0] == point_1[0])\\n                   slope=Double.POSITIVE_INFINITY; \\n                else\\n                {\\n                    // slope (m) = (y2 - y1) / (x2 - x1) \\n                    slope = (point_2[1] - point_1[1]) / (double)(point_2[0] - point_1[0]);\\n                }\\n                map.put( slope , map.getOrDefault(slope,0)+1 );\\n                if(map.get(slope)>max)\\n                    max=map.get(slope);\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015881,
                "title": "easiest-soln-goldman-sachs-well-explained",
                "content": "# If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ1. Max Points on a Line**\\n\\n## Approach\\nfloating point arithmetic, alt integer arithemetic which is comparatively faster. O(n^2)(cross-product)\\n\\n![1.max-points-on-a-line.jpg](https://assets.leetcode.com/users/images/d8221a32-5dc9-43a8-93b8-eb5efc6ebdd2_1673126558.9596267.jpeg)\\n\\n## Complexity\\nThe **time complexity** of this solution is O(n^3), as we need to iterate through each pair of points and check the slope between that pair and every other point.\\n\\nThe **space complexity** is O(1), as we only use a constant amount of space to store the variables ans and total\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    // Function to find the maximum number of points that lie on the same straight line\\n    int maxPoints(vector<vector<int>>& points) {\\n        // Get the number of points\\n        int n = points.size();\\n\\n        // Edge case: 0 or 1 points\\n        if (n <= 1) return n;\\n\\n        // Initialize the maximum number of points to 2 (the minimum possible)\\n        int ans = 2;\\n\\n        // Iterate through all pairs of points\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                // Initialize the total number of points on the same straight line as points[i] and points[j] to 2 (points[i] and points[j])\\n                int total = 2;\\n\\n                // Iterate through all other points\\n                for (int k = 0; k < n; k++) {\\n                    // Skip points i and j\\n                    if (k == i || k == j) continue;\\n\\n                    // Check if point k lies on the same straight line as points i and j\\n                    if ((points[j][1] - points[i][1]) * (points[i][0] - points[k][0]) == (points[i][1] - points[k][1]) * (points[j][0] - points[i][0])) {\\n                        // Point k lies on the same straight line as points i and j, increment the total\\n                        total++;\\n                    }\\n                }\\n                // Update the maximum number of points\\n                ans = max(ans, total);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to find the maximum number of points that lie on the same straight line\\n    int maxPoints(vector<vector<int>>& points) {\\n        // Get the number of points\\n        int n = points.size();\\n\\n        // Edge case: 0 or 1 points\\n        if (n <= 1) return n;\\n\\n        // Initialize the maximum number of points to 2 (the minimum possible)\\n        int ans = 2;\\n\\n        // Iterate through all pairs of points\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                // Initialize the total number of points on the same straight line as points[i] and points[j] to 2 (points[i] and points[j])\\n                int total = 2;\\n\\n                // Iterate through all other points\\n                for (int k = 0; k < n; k++) {\\n                    // Skip points i and j\\n                    if (k == i || k == j) continue;\\n\\n                    // Check if point k lies on the same straight line as points i and j\\n                    if ((points[j][1] - points[i][1]) * (points[i][0] - points[k][0]) == (points[i][1] - points[k][1]) * (points[j][0] - points[i][0])) {\\n                        // Point k lies on the same straight line as points i and j, increment the total\\n                        total++;\\n                    }\\n                }\\n                // Update the maximum number of points\\n                ans = max(ans, total);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47243,
                "title": "have-an-o-n-2-accepted-solution-but-feel-terrible-about-it-what-do-others-think",
                "content": "My submission:\\n\\n    import java.util.Map;\\n    import java.util.HashMap;\\n    \\n    /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            int maxLine = 0;\\n            \\n            for (int i=0; i<(points.length-maxLine); i++) {\\n                int coincident = 0;\\n                Map<Double, Integer> pointCounts = new HashMap<Double, Integer>();\\n                for (int j=i+1; j<points.length; j++) {\\n                    Double slope;\\n                    if (points[i].x==points[j].x && points[i].y==points[j].y) {\\n                        coincident++;\\n                        continue;\\n                    } else if (points[i].x == points[j].x) {\\n                        slope = Math.PI;\\n                    } else if (points[i].y == points[j].y) {\\n                        slope = 0.0; // logically we don't need this, but in practice i find that we do\\n                    } else {\\n                        slope = new Double((double)(points[i].y-points[j].y) / (double)(points[i].x-points[j].x));\\n                    }\\n                    \\n                    if (pointCounts.containsKey(slope))\\n                        pointCounts.put(slope, pointCounts.get(slope)+1);\\n                    else\\n                        pointCounts.put(slope, new Integer(1));\\n                }\\n                maxLine = Math.max(maxLine, 1+coincident+maxValue(pointCounts));\\n            }\\n            \\n            return maxLine;\\n        }\\n        \\n        private int maxValue(Map<Double, Integer> doubleIntMap) {\\n            int max = 0;\\n            Set<Double> keys = doubleIntMap.keySet();\\n            Iterator iter = keys.iterator();\\n            while (iter.hasNext())\\n                max = Math.max(max, doubleIntMap.get(iter.next()));\\n            return max;\\n        }\\n    }\\nMy Algorithm was the following:\\n\\n    for every point i from 0 to points.length - maxColinearPointsFoundSoFar {\\n        for every j from i+1 to points.length-1 {\\n            ithPointHashTable[slope] += 1;\\n        } \\n        find max value in ithPointHashTable and update maxColinearPointsFoundSoFar;\\n    }\\n\\nHere are the reasons that combine to make me feel terrible:\\n\\nWhenever I use a hash table to achieve O(some runtime) having to assume hash table insertion is O(1), I don't feel great. hash tables also use extra memory which we are also watching our algorithms for.\\n\\nThis might've been the first time ever for me attempting to use a Double as a map key. Through this exercise I've discovered that its not a good idea. For instance (double) (0/1) and (double) (0/-1) evaluates to two different things. That's one thing the test cases uncovered. There might be more cases where mathematically expressions should evaluate to the same thing but in above code they don't.\\n\\nMore along those lines, for two points that have infinite slope, I inesrt them into the hashMap with a key of Math.PI. Mathematically no two points with integer coordinates should have an irrational slope, however in practice because of computer precision. But could there be a case where two points with integer coordinates have a slope between them that creates an equivalent map key as Math.PI? Although its not very likely, the probability might not be 0.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPoints(Point[] points) {\\n            int maxLine = 0;\\n            \\n            for (int i=0; i<(points.length-maxLine); i++) {\\n                int coincident = 0;\\n                Map<Double, Integer> pointCounts = new HashMap<Double, Integer>();\\n                for (int j=i+1; j<points.length; j++) {\\n                    Double slope;\\n                    if (points[i].x==points[j].x && points[i].y==points[j].y) {\\n                        coincident++;\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 431375,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Basically brutal force, given a point, find all the points that lie on the same line\\n2. Beware that duplicate points are counted as well\\n3. Beware that JS\\'s problem when calculating big decimal numbers, use hack `1000000.0 *`\\n``` javascript\\nvar maxPoints = function(points) {\\n    if (points.length <2|| points == null) return points.length;\\n    let max = 2;\\n    for (let i=0;i<points.length;i++) {\\n        let [p1x, p1y] = points[i];\\n        let samePoint = 1, map = {\\'base\\':0}; // to avoid when map = {}, the max value is -Infinity\\n        for (let j=i+1;j<points.length;j++) {\\n            if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\\n                samePoint++;\\n            } else {\\n                let [p2x, p2y] = points[j];\\n                let slope = 1000000.0 * (p2y - p1y)/(p2x - p1x);\\n                if (!Number.isFinite(slope)) slope = \"v\";\\n                else if (Number.isNaN(slope)) slope = \"h\";\\n                map[slope] = map[slope]+1||1;\\n            }   \\n        }\\n        max = Math.max(Math.max(...Object.values(map))+samePoint, max);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar maxPoints = function(points) {\\n    if (points.length <2|| points == null) return points.length;\\n    let max = 2;\\n    for (let i=0;i<points.length;i++) {\\n        let [p1x, p1y] = points[i];\\n        let samePoint = 1, map = {\\'base\\':0}; // to avoid when map = {}, the max value is -Infinity\\n        for (let j=i+1;j<points.length;j++) {\\n            if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\\n                samePoint++;\\n            } else {\\n                let [p2x, p2y] = points[j];\\n                let slope = 1000000.0 * (p2y - p1y)/(p2x - p1x);\\n                if (!Number.isFinite(slope)) slope = \"v\";\\n                else if (Number.isNaN(slope)) slope = \"h\";\\n                map[slope] = map[slope]+1||1;\\n            }   \\n        }\\n        max = Math.max(Math.max(...Object.values(map))+samePoint, max);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 47256,
                "title": "java-solution-with-no-double-if-you-are-concerned-with-using-doubles-floats-fear-not-there-is-a-way-around",
                "content": "This solution is somewhat slower than the standard solution which uses doubles to store slopes. It, however, guarantees that there will not be any precision error, as long as we are dealing with integers as point coordinates.\\n\\nYou can read here about the pairing functions that uniquely represent any pair of integers. [https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function][1]\\n\\n    /**\\n     * We can use a pairing function to represent two integers uniquely.\\n     * In our case we use a pairing function to represent a fraction, \\n     * with first integer being the numerator and second integer being the denominator.\\n     * Hence, we avoid precision concerns that may come up if we use floats / doubles.\\n     */\\n    public int maxPoints(Point[] points) {\\n        if (points.length < 2) return points.length;\\n        int max = 2;\\n        for (Point p1 : points) {\\n            Map<Integer, Integer> slopes = new HashMap<>(points.length);\\n            int localMax = 0;\\n            for (Point p2 : points) {\\n                int num = p2.y - p1.y;\\n                int den = p2.x - p1.x;\\n                \\n                // pairing functions only work with non-negative integers\\n                // we store the sign in a separate variable\\n                int sign = 1;\\n                if ((num > 0 && den < 0) || (num < 0 && den > 0)) sign = -1;\\n                num = Math.abs(num);\\n                den = Math.abs(den);\\n                \\n                // pairing functions represent a pair of any two integers uniquely;\\n                // they can be used as hash functions for any sequence of integers;\\n                // therefore, a pairing function from 1/2 doesn't equal to that from 3/6\\n                // even though the slope 1/2 and 3/6 is the same.\\n                // => we need to convert each fraction to its simplest form, i.e. 3/6 => 1/2\\n                int gcd = GCD(num, den);\\n                num = gcd == 0 ? num : num / gcd;\\n                den = gcd == 0 ? den : den / gcd;\\n                \\n                // We can use Cantor pairing function pi(k1, k2) = 1/2(k1 + k2)(k1 + k2 + 1) + k2\\n                // and include the sign\\n                int m = sign * (num + den) * (num + den + 1) / 2 + den;\\n                if (slopes.containsKey(m)) slopes.put(m, slopes.get(m)+1);\\n                else slopes.put(m, 1);\\n                if (m == 0) continue;\\n                \\n                localMax = Math.max(slopes.get(m),localMax);\\n            }\\n            max = Math.max(max, localMax + slopes.get(0));\\n        }\\n        return max;\\n    }\\n    \\n    public int GCD(int a, int b) {\\n       if (b == 0) return a;\\n       return GCD(b,a % b);\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function",
                "solutionTags": [
                    "Java"
                ],
                "code": "This solution is somewhat slower than the standard solution which uses doubles to store slopes. It, however, guarantees that there will not be any precision error, as long as we are dealing with integers as point coordinates.\\n\\nYou can read here about the pairing functions that uniquely represent any pair of integers. [https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function][1]\\n\\n    /**\\n     * We can use a pairing function to represent two integers uniquely.\\n     * In our case we use a pairing function to represent a fraction, \\n     * with first integer being the numerator and second integer being the denominator.\\n     * Hence, we avoid precision concerns that may come up if we use floats / doubles.\\n     */\\n    public int maxPoints(Point[] points) {\\n        if (points.length < 2) return points.length;\\n        int max = 2;\\n        for (Point p1 : points) {\\n            Map<Integer, Integer> slopes = new HashMap<>(points.length);\\n            int localMax = 0;\\n            for (Point p2 : points) {\\n                int num = p2.y - p1.y;\\n                int den = p2.x - p1.x;\\n                \\n                // pairing functions only work with non-negative integers\\n                // we store the sign in a separate variable\\n                int sign = 1;\\n                if ((num > 0 && den < 0) || (num < 0 && den > 0)) sign = -1;\\n                num = Math.abs(num);\\n                den = Math.abs(den);\\n                \\n                // pairing functions represent a pair of any two integers uniquely;\\n                // they can be used as hash functions for any sequence of integers;\\n                // therefore, a pairing function from 1/2 doesn't equal to that from 3/6\\n                // even though the slope 1/2 and 3/6 is the same.\\n                // => we need to convert each fraction to its simplest form, i.e. 3/6 => 1/2\\n                int gcd = GCD(num, den);\\n                num = gcd == 0 ? num : num / gcd;\\n                den = gcd == 0 ? den : den / gcd;\\n                \\n                // We can use Cantor pairing function pi(k1, k2) = 1/2(k1 + k2)(k1 + k2 + 1) + k2\\n                // and include the sign\\n                int m = sign * (num + den) * (num + den + 1) / 2 + den;\\n                if (slopes.containsKey(m)) slopes.put(m, slopes.get(m)+1);\\n                else slopes.put(m, 1);\\n                if (m == 0) continue;\\n                \\n                localMax = Math.max(slopes.get(m),localMax);\\n            }\\n            max = Math.max(max, localMax + slopes.get(0));\\n        }\\n        return max;\\n    }\\n    \\n    public int GCD(int a, int b) {\\n       if (b == 0) return a;\\n       return GCD(b,a % b);\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function",
                "codeTag": "Unknown"
            },
            {
                "id": 1133281,
                "title": "java-using-hashmap-explained",
                "content": "```\\n  public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        int out = 0;\\n        if(n==1)\\n            return n;\\n        Map<Double, Integer> map = new HashMap<>(); // count pairs of points having same slops\\n       for(int i=0;i<n;i++){\\n           for(int j=i+1;j<n;j++){\\n               // if(i==j)\\n               //     continue;\\n               Double m = null; // null values as key is for vertical lines having slop = 90degree\\n                if(points[i][1]==points[j][1]){ // straight horizontal line\\n                    m = 0.0;\\n                } else \\n                if(points[i][0]!=points[j][0]){\\n                    m = ((points[i][1]-points[j][1])*1.0)/(points[i][0]-points[j][0]);\\n                }\\n\\n               \\n               int val = map.getOrDefault(m,1);\\n               map.put(m, val+1);\\n           }\\n           for(Integer val : map.values()){\\n               out = Math.max(out, val);\\n           }\\n           map = new HashMap<>();\\n       }\\n        return out;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        int out = 0;\\n        if(n==1)\\n            return n;\\n        Map<Double, Integer> map = new HashMap<>(); // count pairs of points having same slops\\n       for(int i=0;i<n;i++){\\n           for(int j=i+1;j<n;j++){\\n               // if(i==j)\\n               //     continue;\\n               Double m = null; // null values as key is for vertical lines having slop = 90degree\\n                if(points[i][1]==points[j][1]){ // straight horizontal line\\n                    m = 0.0;\\n                } else \\n                if(points[i][0]!=points[j][0]){\\n                    m = ((points[i][1]-points[j][1])*1.0)/(points[i][0]-points[j][0]);\\n                }\\n\\n               \\n               int val = map.getOrDefault(m,1);\\n               map.put(m, val+1);\\n           }\\n           for(Integer val : map.values()){\\n               out = Math.max(out, val);\\n           }\\n           map = new HashMap<>();\\n       }\\n        return out;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018023,
                "title": "java-c-100-solution-with-hashing-max-points-on-a-line",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 0;\\n        for (int i = 0; i<points.length; ++i){\\n            Map<Double, Integer> check = new HashMap<>();\\n            for (int  j = i+1; j<points.length; ++j){\\n                double slope;\\n                if (points[i][0] == points[j][0])\\n                    slope = Double.MAX_VALUE;\\n                else{\\n                    slope = (points[i][1] - points[j][1]) / ((double) (points[i][0] - points[j][0]));\\n                    if (slope == -0.0)\\n                        slope = 0.0;\\n                }\\n                check.put(slope, check.getOrDefault(slope, 0) + 1);\\n                ans = Math.max(ans, check.get(slope));\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n       int ans = 0;\\n        for (int i = 0; i<points.size(); ++i){\\n            map<double,int> check;\\n            for (int  j = i+1; j<points.size(); ++j){\\n                double slope;\\n                if (points[i][0] == points[j][0])\\n                    slope = DBL_MAX;\\n                else{\\n                    slope = (points[i][1] - points[j][1]) / ((double) (points[i][0] - points[j][0]));\\n                }\\n                check[slope]++;\\n                ans = max(ans, check[slope]);\\n            }\\n        }\\n        return ans+1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 0;\\n        for (int i = 0; i<points.length; ++i){\\n            Map<Double, Integer> check = new HashMap<>();\\n            for (int  j = i+1; j<points.length; ++j){\\n                double slope;\\n                if (points[i][0] == points[j][0])\\n                    slope = Double.MAX_VALUE;\\n                else{\\n                    slope = (points[i][1] - points[j][1]) / ((double) (points[i][0] - points[j][0]));\\n                    if (slope == -0.0)\\n                        slope = 0.0;\\n                }\\n                check.put(slope, check.getOrDefault(slope, 0) + 1);\\n                ans = Math.max(ans, check.get(slope));\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n       int ans = 0;\\n        for (int i = 0; i<points.size(); ++i){\\n            map<double,int> check;\\n            for (int  j = i+1; j<points.size(); ++j){\\n                double slope;\\n                if (points[i][0] == points[j][0])\\n                    slope = DBL_MAX;\\n                else{\\n                    slope = (points[i][1] - points[j][1]) / ((double) (points[i][0] - points[j][0]));\\n                }\\n                check[slope]++;\\n                ans = max(ans, check[slope]);\\n            }\\n        }\\n        return ans+1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017375,
                "title": "python-simple-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> It was a simple intuition that to check if the line equation formed from combinations of any two points in the given array satisfies with the number points in the given points array. i.e return the maximum points that satisfies the line equation. :)\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nC2 * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ll = len(points) \\n        if ll == 1: return 1\\n        elif ll == 2: return 2\\n        else:\\n            ans = 0\\n            for i in list(combinations(points,2)):\\n                cnt = 0\\n                for j in points:\\n                    if (j[1] - i[0][1]) * (i[1][0] - i[0][0]) == (j[0] - i[0][0]) * (i[1][1] - i[0][1]):\\n                        cnt += 1\\n                ans = max(ans, cnt)\\n            return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ll = len(points) \\n        if ll == 1: return 1\\n        elif ll == 2: return 2\\n        else:\\n            ans = 0\\n            for i in list(combinations(points,2)):\\n                cnt = 0\\n                for j in points:\\n                    if (j[1] - i[0][1]) * (i[1][0] - i[0][0]) == (j[0] - i[0][0]) * (i[1][1] - i[0][1]):\\n                        cnt += 1\\n                ans = max(ans, cnt)\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328705,
                "title": "c-85-beat-o-n-2-solution-exploit-gcd-cool-bros-solution",
                "content": "The idea is pretty straight forward. For any point, all points with the same slope with respect to the point are on the same line. We use CGD to avoid floating point errors.\\n\\nFor example, take the point (2, 2)\\n\\nTake (3, 3) - the xdiff = -1, ydiff = -1, the gcd is -1: and the slope is 1 for \"intercept\" of 1.\\nTake (4, 4) - the xdiff is -2, ydiff is -2, the gcd is -2: and the slope is 1 for \"intercept\" of 1.\\nTake (-2, -2) - the xdiff = 4, ydiff = 4, the gcd is 4: and the slope is 1 for \"intercept\" of 1.\\n(Note, this is not actually in y-intercept form. The \"slope\" and \"intercept\" here are just the x_diff and y_diff divided by the gcd. So what that really means is that you must advance x by 1 when y is at 1. This is a way to define a line... lul... \\n\\nSo, ((2,2), (3,3)) and ((2,2), (4,4)) and ((2,2), (-2,-2)) are on the same line...\\n\\nThe only corner cases are vertical or horizontal lines, which we can easily count separately for each point. (We are visiting the points in a triangular loop)\\n\\nFinally, any points equal to our candidate point (2,2) we simply add to the max of the possible solutions, horizontal, vertical, or \"slope buddies\"\\n\\nThe other funny thing for C++, I noticed that you can use pairs in a map, but not in an unordered_set or unordered_map. Alternatively you could use a set of sets. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int gcd(int pSmall, int pLarge) {\\n        int aRemainder = 0;\\n        while (pSmall != 0) {\\n            aRemainder = pLarge % pSmall;\\n            pLarge = pSmall;\\n            pSmall = aRemainder;\\n        }\\n        return pLarge;\\n    }\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        int aResult = 0;\\n        int aPointCount = points.size();\\n        \\n        int aX1, aY1, aX2, aY2;\\n        int aDiffX, aDiffY, aGCD;\\n        int aHorCount, aVerCount, aEqualCount, aSlopeCount, aIterationCount;\\n        \\n        pair<int, int> aPair;\\n        \\n        for (int i=0;i<aPointCount;i++) {\\n            \\n            map<pair<int, int>, int> aLUT;\\n            \\n            aX1 = points[i][0];\\n            aY1 = points[i][1];\\n            \\n            aHorCount = 0;\\n            aVerCount = 0;\\n            aEqualCount = 0;\\n            aSlopeCount = 0;\\n            \\n            for (int j=i-1;j>=0;j--) {\\n                aX2 = points[j][0];\\n                aY2 = points[j][1];\\n                \\n                aDiffX = aX1 - aX2;\\n                aDiffY = aY1 - aY2;\\n                \\n                if (aDiffX == 0 && aDiffY == 0) {\\n                    aEqualCount++;\\n                } else if (aDiffX == 0) {\\n                    ++aHorCount;\\n                } else if (aDiffY == 0) {\\n                    ++aVerCount;\\n                } else {\\n                    aGCD = gcd(aDiffX, aDiffY);\\n                    \\n                    aPair.first = aDiffX /= aGCD;\\n                    aPair.second = aDiffY /= aGCD;\\n                    \\n                    aLUT[aPair]++;\\n                    \\n                    aSlopeCount = max(aSlopeCount, aLUT[aPair]);\\n                }\\n            }\\n            \\n            aIterationCount = max(max(aSlopeCount, aHorCount), aVerCount) + aEqualCount + 1;\\n            aResult = max(aResult, aIterationCount);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int gcd(int pSmall, int pLarge) {\\n        int aRemainder = 0;\\n        while (pSmall != 0) {\\n            aRemainder = pLarge % pSmall;\\n            pLarge = pSmall;\\n            pSmall = aRemainder;\\n        }\\n        return pLarge;\\n    }\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        int aResult = 0;\\n        int aPointCount = points.size();\\n        \\n        int aX1, aY1, aX2, aY2;\\n        int aDiffX, aDiffY, aGCD;\\n        int aHorCount, aVerCount, aEqualCount, aSlopeCount, aIterationCount;\\n        \\n        pair<int, int> aPair;\\n        \\n        for (int i=0;i<aPointCount;i++) {\\n            \\n            map<pair<int, int>, int> aLUT;\\n            \\n            aX1 = points[i][0];\\n            aY1 = points[i][1];\\n            \\n            aHorCount = 0;\\n            aVerCount = 0;\\n            aEqualCount = 0;\\n            aSlopeCount = 0;\\n            \\n            for (int j=i-1;j>=0;j--) {\\n                aX2 = points[j][0];\\n                aY2 = points[j][1];\\n                \\n                aDiffX = aX1 - aX2;\\n                aDiffY = aY1 - aY2;\\n                \\n                if (aDiffX == 0 && aDiffY == 0) {\\n                    aEqualCount++;\\n                } else if (aDiffX == 0) {\\n                    ++aHorCount;\\n                } else if (aDiffY == 0) {\\n                    ++aVerCount;\\n                } else {\\n                    aGCD = gcd(aDiffX, aDiffY);\\n                    \\n                    aPair.first = aDiffX /= aGCD;\\n                    aPair.second = aDiffY /= aGCD;\\n                    \\n                    aLUT[aPair]++;\\n                    \\n                    aSlopeCount = max(aSlopeCount, aLUT[aPair]);\\n                }\\n            }\\n            \\n            aIterationCount = max(max(aSlopeCount, aHorCount), aVerCount) + aEqualCount + 1;\\n            aResult = max(aResult, aIterationCount);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328269,
                "title": "a-java-solution-with-my-understanding",
                "content": "The major algorithm is from:\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/discuss/47113/A-java-solution-with-notes\\n\\nThe basic approach:\\n\\n1. Use a HashMap to save the **slope** and relevant point count. e.g. if there is an entry of the map as (1.5, 3), it means 5 points having slope 1.5.\\n1. Go though the points array, compare each pair of the points, and calculate the slope/count.\\n1. Return the max value of the points with the same slope.\\n\\n**How to calculate the slope?**\\n\\nAssume `dx = (x2 - x1), dy = (y2 = y1)`. A straightforward way is to use a double: `slope = (float)(dy) / dx`. However, we cannot simply use a double to indicate the slope, which might lose precision for very big numbers. e.g. for (2 ^ 32) / (2 ^ 32) and (2 ^ 32 - 1) / (2 ^ 32), the results are the same, but in fact they are not. A better way is to use **fraction**: use a long type slope, with the first 32 bits indicating dy and the last 32 bits indicating dx.\\n\\nNotes that we need to save the slope in **irreducible fraction**, so divide dx/dy with the great common divisor (GCD) before saving them.\\n\\nIn addition, remember to cast (dy / gcd) to **long** before move the result by 32 bits, otherwise we will get 0 finally since it\\'s an **int** with 32 bits:\\n\\n`slope = ((long)(dy / gcd) << 32) + (dx / gcd);`\\n\\nA complete rule for calculating the slope:\\n\\n1. If both dx and dy are 0, it means the two points are duplicated. Increase `dup` to remember duplicated points.\\n2. Otherwise, save the slope in fraction.\\n\\n**How to get the GCD?**\\n\\nIt\\'s implemented in function getGCD(): if b == 0, return a directly; otherwise, call getGCD() recursively by b and (a % b). \\n\\n**How to handle the duplicated points?**\\n\\nUse `dup` to remember how many duplicated points we have gotten. Initialize `dup = 1` because we need to account the original point as well, e.g if the count 1, we have two duplicated points. Then go through the entire hashmap to find the max value of count. \\n\\nNote that the count should be `entry.getValue() + dup` because we need to account the original point plus all duplicated points. e.g. for slope = 1.5, count = 3, and dup = 2, it means 1 original point, 1 duplicated point (with the same position to original point), from where there are 3 points with the same slope (1.5). So the number of points that lie on the same straight line is `(2 + 3) = 5`.\\n\\nComplete code:\\n\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length < 3)return points.length;\\n        int max = 0;\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        for(int i = 0;i < points.length;i++) {\\n            int dup = 1;\\n            map.clear();\\n            for(int j = i + 1;j < points.length;j++) {\\n                int dx = points[j][0] - points[i][0], dy = points[j][1] - points[i][1];\\n                if(dx == 0 && dy == 0)dup++;\\n                else {\\n                    int gcd = getGcd(dx, dy);\\n                    long slope = ((long)(dy / gcd) << 32) + (dx / gcd);\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                }               \\n            }\\n            max = Math.max(max, dup);\\n            for(Map.Entry<Long, Integer> entry : map.entrySet())\\n                max = Math.max(max, entry.getValue() + dup);\\n        }\\n        return max;\\n    }\\n    \\n    int getGcd(int a, int b) {\\n        return b == 0 ? a : getGcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length < 3)return points.length;\\n        int max = 0;\\n        HashMap<Long, Integer> map = new HashMap<Long, Integer>();\\n        for(int i = 0;i < points.length;i++) {\\n            int dup = 1;\\n            map.clear();\\n            for(int j = i + 1;j < points.length;j++) {\\n                int dx = points[j][0] - points[i][0], dy = points[j][1] - points[i][1];\\n                if(dx == 0 && dy == 0)dup++;\\n                else {\\n                    int gcd = getGcd(dx, dy);\\n                    long slope = ((long)(dy / gcd) << 32) + (dx / gcd);\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                }               \\n            }\\n            max = Math.max(max, dup);\\n            for(Map.Entry<Long, Integer> entry : map.entrySet())\\n                max = Math.max(max, entry.getValue() + dup);\\n        }\\n        return max;\\n    }\\n    \\n    int getGcd(int a, int b) {\\n        return b == 0 ? a : getGcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47111,
                "title": "16ms-c-easy-understanding-solution",
                "content": "    class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) {\\n            int n = (int)points.size();\\n            unordered_map<float, int> map;\\n            int res = 0;\\n            for(int i = 0; i < n; i++){\\n                int same = 1;\\n                int vertical = 0;\\n                int tmp = 0;\\n                map.clear();\\n                for(int j = i + 1; j < n; j++){\\n                    Point a = points[i];\\n                    Point b = points[j];\\n                    if(a.x == b.x){\\n                        if(a.y != b.y){\\n                            vertical++;\\n                        }\\n                        else{\\n                            same++;\\n                        }\\n                    }\\n                    else{\\n                         tmp = max(++map[(float)(b.y - a.y) / (b.x - a.x)], tmp);\\n                    }\\n                }\\n                res = max(res, same + max(vertical, tmp));\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point>& points) {\\n            int n = (int)points.size();\\n            unordered_map<float, int> map;\\n            int res = 0;\\n            for(int i = 0; i < n; i++){\\n                int same = 1;\\n                int vertical = 0;\\n                int tmp = 0;\\n                map.clear();\\n                for(int j = i + 1; j < n; j++){\\n                    Point a = points[i];\\n                    Point b = points[j];\\n                    if(a.x == b.x){\\n                        if(a.y != b.y){\\n                            vertical++;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 47204,
                "title": "easy-java-solution",
                "content": "Using double as the `HashMap` key is a bad practice. \\n\\nBut for this problem, as long as we handle the case of gradient `0.0`, it's fine to use `Double`. This is because Double `+0.0` and `-0.0` is treated as  different key.\\n\\n> Note that in most cases, for two instances of class Double, d1 and d2,\\n> the value of d1.equals(d2) is true if and only if `d1.doubleValue() == d2.doubleValue()` also has the value true. However,\\n> there are two exceptions:\\n> \\n> If d1 and d2 both represent Double.NaN, then the equals method returns\\n> true, even though `Double.NaN==Double.NaN` has the value false. If d1\\n> represents +0.0 while d2 represents -0.0, or vice versa, the equal\\n> test has the value false, even though `+0.0==-0.0` has the value true.\\n> This definition allows hash tables to operate properly.\\n\\nBy adding the following line, it's ok to use `Double` as the key.\\n\\n    double k =  (p2.y == p1.y) ? 0.0 :((double) (p2.y - p1.y) / (p2.x - p1.x));\\n\\nThis is an my Java AC solution:\\n\\n    public int maxPoints(Point[] points) {\\n        int result = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            Map<Double, Integer> map = new HashMap<>();\\n            int dups = 0, verticals = 0;\\n            \\n            for (int j = i + 1; j < points.length; j++) {\\n                Point p1 = points[i], p2 = points[j];\\n                \\n                if (p1.x == p2.x && p1.y == p2.y) {\\n                    dups++;\\n                } else if (p1.x == p2.x) {\\n                    verticals++;\\n                } else if (p1.y == p2.y) {\\n                    map.put(0.0, map.getOrDefault(0.0, 0) + 1);\\n                } else {\\n                    double k = (double) (p2.y - p1.y) / (p2.x - p1.x);    \\n                    map.put(k, map.getOrDefault(k, 0) + 1);\\n                }\\n            }\\n            \\n            int max = 0;\\n            for (Map.Entry<Double, Integer> entry: map.entrySet()) {\\n                max = Math.max(max, entry.getValue() + dups + 1);\\n            }\\n            \\n            max = Math.max(max, verticals + dups + 1);\\n            result = Math.max(max, result);\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Using double as the `HashMap` key is a bad practice. \\n\\nBut for this problem, as long as we handle the case of gradient `0.0`, it's fine to use `Double`. This is because Double `+0.0` and `-0.0` is treated as  different key.\\n\\n> Note that in most cases, for two instances of class Double, d1 and d2,\\n> the value of d1.equals(d2) is true if and only if `d1.doubleValue() == d2.doubleValue()` also has the value true. However,\\n> there are two exceptions:\\n> \\n> If d1 and d2 both represent Double.NaN, then the equals method returns\\n> true, even though `Double.NaN==Double.NaN` has the value false. If d1\\n> represents +0.0 while d2 represents -0.0, or vice versa, the equal\\n> test has the value false, even though `+0.0==-0.0` has the value true.\\n> This definition allows hash tables to operate properly.\\n\\nBy adding the following line, it's ok to use `Double` as the key.\\n\\n    double k =  (p2.y == p1.y) ? 0.0 :((double) (p2.y - p1.y) / (p2.x - p1.x));\\n\\nThis is an my Java AC solution:\\n\\n    public int maxPoints(Point[] points) {\\n        int result = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            Map<Double, Integer> map = new HashMap<>();\\n            int dups = 0, verticals = 0;\\n            \\n            for (int j = i + 1; j < points.length; j++) {\\n                Point p1 = points[i], p2 = points[j];\\n                \\n                if (p1.x == p2.x && p1.y == p2.y) {\\n                    dups++;\\n                } else if (p1.x == p2.x) {\\n                    verticals++;\\n                } else if (p1.y == p2.y) {\\n                    map.put(0.0, map.getOrDefault(0.0, 0) + 1);\\n                } else {\\n                    double k = (double) (p2.y - p1.y) / (p2.x - p1.x);    \\n                    map.put(k, map.getOrDefault(k, 0) + 1);\\n                }\\n            }\\n            \\n            int max = 0;\\n            for (Map.Entry<Double, Integer> entry: map.entrySet()) {\\n                max = Math.max(max, entry.getValue() + dups + 1);\\n            }\\n            \\n            max = Math.max(max, verticals + dups + 1);\\n            result = Math.max(max, result);\\n        }\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 47147,
                "title": "11-lines-python",
                "content": "    def maxPoints(self, points):\\n        answer = 0\\n        for p in points:\\n            pctr = 0\\n            ctr = collections.Counter()\\n            for q in points:\\n                x, y = q.x - p.x, q.y - p.y\\n                pctr += x == y == 0\\n                ctr[float(y)/x if x else 'inf'] += 1\\n            ctr['inf'] -= pctr\\n            answer = max(answer, pctr + max(ctr.values()))\\n        return answer\\n\\nFor each point p...\\n\\n 1. Count how often p itself appears.\\n 2. Count how often each slope through p appears (use 'inf' for vertical lines).\\n 3. The p-counter plus the largest slope-counter tell the largest number of points on a line through p.\\n\\nMaximize the latter over all points p.\\n\\n---\\n\\nImplementation detail: I count every p towards `ctr['inf']` and subtract them afterwards because that's slightly simpler/shorter and because this way, `ctr` can't be empty (which would give me trouble when asking `max(ctr.values())`).",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def maxPoints(self, points):\\n        answer = 0\\n        for p in points:\\n            pctr = 0\\n            ctr = collections.Counter()\\n            for q in points:\\n                x, y = q.x - p.x, q.y - p.y\\n                pctr += x == y == 0\\n                ctr[float(y)/x if x else 'inf'] += 1\\n            ctr['inf'] -= pctr\\n            answer = max(answer, pctr + max(ctr.values()))\\n        return answer\\n\\nFor each point p...\\n\\n 1. Count how often p itself appears.\\n 2. Count how often each slope through p appears (use 'inf' for vertical lines).\\n 3. The p-counter plus the largest slope-counter tell the largest number of points on a line through p.\\n\\nMaximize the latter over all points p.\\n\\n---\\n\\nImplementation detail: I count every p towards `ctr['inf']` and subtract them afterwards because that's slightly simpler/shorter and because this way, `ctr` can't be empty (which would give me trouble when asking `max(ctr.values())`).",
                "codeTag": "Python3"
            },
            {
                "id": 3018635,
                "title": "python-solution-explained-o-n-2-97",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first iterate through the points and find the `slop` from the curent point to all preceding point.\\n\\n$$slop = (y2-y1)/(x2-x1)$$\\n\\nThen we add that `slop`as `key` to our hash and the point-count as its `value`.\\n\\nThen we update our `maxlen` if our current `slop` count is greater.\\n\\nFinaly we return `maxlen`\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # check for edge case\\n        if len(points)<3:\\n            return len(points)\\n        \\n        maxlen = 0\\n        for i in range(len(points)):\\n            line = {}\\n            for j in range(i+1,len(points)):\\n                y = points[i][1] - points[j][1]\\n                x = points[i][0] - points[j][0]\\n                \\n                # for finding the y-intercept (b)\\n                # b = points[i][0] if x == 0  else points[i][1] - ((y/x) * points[i][0])\\n                \\n                # use the slop as the hash map key\\n                slop = y/x if x!=0 else inf\\n                \\n                if slop in line:\\n                    line[slop]+= 1\\n                else:\\n                    line[slop] = 2 \\n                maxlen = max(line[slop] , maxlen)\\n        return maxlen\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # check for edge case\\n        if len(points)<3:\\n            return len(points)\\n        \\n        maxlen = 0\\n        for i in range(len(points)):\\n            line = {}\\n            for j in range(i+1,len(points)):\\n                y = points[i][1] - points[j][1]\\n                x = points[i][0] - points[j][0]\\n                \\n                # for finding the y-intercept (b)\\n                # b = points[i][0] if x == 0  else points[i][1] - ((y/x) * points[i][0])\\n                \\n                # use the slop as the hash map key\\n                slop = y/x if x!=0 else inf\\n                \\n                if slop in line:\\n                    line[slop]+= 1\\n                else:\\n                    line[slop] = 2 \\n                maxlen = max(line[slop] , maxlen)\\n        return maxlen\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017515,
                "title": "c-begineer-friendly-easy-understanding-heap-video-solution",
                "content": "# Intuition && Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=TGRl2dJzL64/\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017376,
                "title": "easy-to-understand-c-solution-with-explaination",
                "content": "# Approach\\nWe use property of coordinate geometry. We calculate slope and store its frequency in map. Now for every pair possible there are 3 cases to consider:\\n\\n1) If the second point is same as the first then we will have overlapping points. So to tackle this we will maintain the count of same points and then add then to our answer.\\n2) If the difference between x coordinates become ```zero``` then slope becomes infinity. So to tackle this we will store their frequencies at ```INT_MAX```.\\n3) Then all that left is general case where we calculate slope and count its frequency. \\n\\nFor each point we maintain a ```currMax``` which will store result for current point. And at the end of each iteration we will take maximum with previous result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int res=0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int samePnt=1;\\n            unordered_map<double,int>mp;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(points[i][0]==points[j][0] and points[i][1]==points[j][1])\\n                {\\n                    samePnt++;\\n                }\\n                else if(points[i][0]==points[j][0])\\n                {\\n                    mp[INT_MAX]++;\\n                }\\n                else\\n                {\\n                    double slope=(double)(points[i][1]-points[j][1])/(double)(points[i][0]-points[j][0]);\\n                    mp[slope]++;\\n                }\\n            }\\n            int currMax=0;\\n            for(auto &i:mp)\\n            {\\n                currMax=max(currMax,i.second);\\n            }\\n            currMax+=samePnt;\\n            res=max(res,currMax);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n### Upvote or I will steal your badges \\uD83D\\uDE0B",
                "solutionTags": [
                    "C++",
                    "Geometry"
                ],
                "code": "```zero```\n```INT_MAX```\n```currMax```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int res=0;\\n        int n=points.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int samePnt=1;\\n            unordered_map<double,int>mp;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(points[i][0]==points[j][0] and points[i][1]==points[j][1])\\n                {\\n                    samePnt++;\\n                }\\n                else if(points[i][0]==points[j][0])\\n                {\\n                    mp[INT_MAX]++;\\n                }\\n                else\\n                {\\n                    double slope=(double)(points[i][1]-points[j][1])/(double)(points[i][0]-points[j][0]);\\n                    mp[slope]++;\\n                }\\n            }\\n            int currMax=0;\\n            for(auto &i:mp)\\n            {\\n                currMax=max(currMax,i.second);\\n            }\\n            currMax+=samePnt;\\n            res=max(res,currMax);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779318,
                "title": "python-9-lines-using-equivalence-classes-for-hashing-slopes-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashing of slopes using their equivalence classes with respect to signed GCD. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** The idea of this solution is to compute counts for slopes of lines coming from each point and then take the maximum of them (plus one for the point itself). However, hashing slopes is error-prone because they\\'re real numbers in general. Thus, to hash safely, we compute for each point its equivalence class, namely a pair of coordinates `(x,y)` with `GCD(x,y) = 1` and `x >= 0`. This trick allows to use \"integer slopes\", i.e., pairs of coordinates on a lattice which serve as some sort of unit vectors that uniquely describe lines on a lattice.\\n\\n**Python.**\\n```\\nfrom math import gcd\\nfrom numpy import sign\\n\\nclass Solution:\\n    def maxPoints(self, p: List[List[int]], m=1, i=0) -> int:\\n        \\n        for rx, ry in p:\\n            i, slopes = i+1, defaultdict(lambda : 1)\\n            for px, py in p[i:]:\\n                vx, vy = px-rx, py-ry\\n                g = gcd(vx, vy) * sign(vx)\\n                s = (vx//g, vy//g)\\n                slopes[s] += 1\\n                m = max(m, slopes[s])\\n        \\n        return m             \\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nfrom numpy import sign\\n\\nclass Solution:\\n    def maxPoints(self, p: List[List[int]], m=1, i=0) -> int:\\n        \\n        for rx, ry in p:\\n            i, slopes = i+1, defaultdict(lambda : 1)\\n            for px, py in p[i:]:\\n                vx, vy = px-rx, py-ry\\n                g = gcd(vx, vy) * sign(vx)\\n                s = (vx//g, vy//g)\\n                slopes[s] += 1\\n                m = max(m, slopes[s])\\n        \\n        return m             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 641492,
                "title": "javascript-solution-beats-91-with-readable-code",
                "content": "```js\\n/*\\n * @lc app=leetcode id=149 lang=javascript\\n *\\n * [149] Max Points on a Line\\n */\\n\\n// @lc code=start\\n\\nvar getGCD = function(a, b) {\\n    return b === 0 ? a : getGCD(b, a % b);\\n}\\n\\nvar getSlope = function (p1, p2) {\\n    var xDiff = p1[0] - p2[0];\\n    var yDiff = p1[1] - p2[1];\\n    if (xDiff === 0) return \\'y\\';\\n    if (yDiff === 0) return \\'x\\';\\n    var gcd = getGCD(xDiff, yDiff);\\n    xDiff /= gcd;\\n    yDiff /= gcd;\\n    return `${xDiff}/${yDiff}`;\\n}\\n\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar maxPoints = function(points) {\\n    var len = points.length;\\n    if (len < 3) return len;\\n    var max = 0;\\n    for (var i = 0; i < len; i++) {\\n        var map = new Map();\\n        var sameCount = 0;\\n        var curMax = 0;\\n        for (var j = i + 1; j < len; j++) {\\n            if (points[j][0] === points[i][0] && points[j][1] === points[i][1]) {\\n                sameCount++;\\n                continue;\\n            }\\n            var slope = getSlope(points[i], points[j]);\\n            if (!map.has(slope)) map.set(slope, 1);\\n            else map.set(slope, map.get(slope) + 1);\\n            curMax = Math.max(curMax, map.get(slope));\\n        }\\n        max = Math.max(max, curMax + sameCount + 1);\\n    }\\n    return max;\\n};\\n\\n\\n// console.log(maxPoints([[0,0],[1,1],[0,0]]))\\n// console.log(maxPoints([[1,1],[1,1],[1,1]]))\\n// console.log(maxPoints([[4,0],[4,-1],[4,5]]))\\n// console.log(maxPoints([[1,1],[2,2],[3,3]]))\\n// console.log(maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]))\\n// console.log(maxPoints([[0,0],[94911151,94911150],[94911152,94911151]]))\\n\\n\\n// @lc code=end\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/*\\n * @lc app=leetcode id=149 lang=javascript\\n *\\n * [149] Max Points on a Line\\n */\\n\\n// @lc code=start\\n\\nvar getGCD = function(a, b) {\\n    return b === 0 ? a : getGCD(b, a % b);\\n}\\n\\nvar getSlope = function (p1, p2) {\\n    var xDiff = p1[0] - p2[0];\\n    var yDiff = p1[1] - p2[1];\\n    if (xDiff === 0) return \\'y\\';\\n    if (yDiff === 0) return \\'x\\';\\n    var gcd = getGCD(xDiff, yDiff);\\n    xDiff /= gcd;\\n    yDiff /= gcd;\\n    return `${xDiff}/${yDiff}`;\\n}\\n\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar maxPoints = function(points) {\\n    var len = points.length;\\n    if (len < 3) return len;\\n    var max = 0;\\n    for (var i = 0; i < len; i++) {\\n        var map = new Map();\\n        var sameCount = 0;\\n        var curMax = 0;\\n        for (var j = i + 1; j < len; j++) {\\n            if (points[j][0] === points[i][0] && points[j][1] === points[i][1]) {\\n                sameCount++;\\n                continue;\\n            }\\n            var slope = getSlope(points[i], points[j]);\\n            if (!map.has(slope)) map.set(slope, 1);\\n            else map.set(slope, map.get(slope) + 1);\\n            curMax = Math.max(curMax, map.get(slope));\\n        }\\n        max = Math.max(max, curMax + sameCount + 1);\\n    }\\n    return max;\\n};\\n\\n\\n// console.log(maxPoints([[0,0],[1,1],[0,0]]))\\n// console.log(maxPoints([[1,1],[1,1],[1,1]]))\\n// console.log(maxPoints([[4,0],[4,-1],[4,5]]))\\n// console.log(maxPoints([[1,1],[2,2],[3,3]]))\\n// console.log(maxPoints([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]))\\n// console.log(maxPoints([[0,0],[94911151,94911150],[94911152,94911151]]))\\n\\n\\n// @lc code=end\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450896,
                "title": "python-slope-counter-with-gcd",
                "content": "The intuition of this problem is quite straightforward: just iterate over each pair `(x1, y1), (x2, y2)`, store the slope into a slope counter. The tricky point is just how to represent the slope.\\n\\nDue to the precison of float point number, one cannot directly use `(y2 - y1) / (x2 - x1)` to store the slope; thus, we must store the slope as a fraction of `(dy, dx)`, and we need to make sure the fraction with common factor can be simplified, which is done by `gcd`.\\n\\n``` python \\nclass Solution:\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[Point]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n\\t\\t# We first remove duplicate points to make life easier\\n        point_counter = collections.Counter(map(tuple, points))\\n        points = list(point_counter.keys())\\n        \\n        maxpoint = 0\\n        for i, (x1, y1) in enumerate(points):\\n            slope_counter = collections.Counter({(0, 0): 0})\\n            for j in range(i + 1, len(points)):\\n                x2, y2 = points[j]\\n\\t\\t\\t\\t# for each pair of (x1, y1) and (x2, y2), compute slope as (dx // gcd, dy // gcd)\\n                slope_counter[_slope(x2 - x1, y2 - y1)] += point_counter[(x2, y2)]\\n            \\n            maxpoint = max(maxpoint, max(slope_counter.values()) + point_counter[(x1, y1)])\\n        \\n        return maxpoint\\n\\ndef _gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n    \\ndef _slope(dx, dy):\\n    gcd = _gcd(dx, dy)\\n    return (dx // gcd, dy // gcd)\\n```",
                "solutionTags": [],
                "code": "``` python \\nclass Solution:\\n    def maxPoints(self, points):\\n        \"\"\"\\n        :type points: List[Point]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n\\t\\t# We first remove duplicate points to make life easier\\n        point_counter = collections.Counter(map(tuple, points))\\n        points = list(point_counter.keys())\\n        \\n        maxpoint = 0\\n        for i, (x1, y1) in enumerate(points):\\n            slope_counter = collections.Counter({(0, 0): 0})\\n            for j in range(i + 1, len(points)):\\n                x2, y2 = points[j]\\n\\t\\t\\t\\t# for each pair of (x1, y1) and (x2, y2), compute slope as (dx // gcd, dy // gcd)\\n                slope_counter[_slope(x2 - x1, y2 - y1)] += point_counter[(x2, y2)]\\n            \\n            maxpoint = max(maxpoint, max(slope_counter.values()) + point_counter[(x1, y1)])\\n        \\n        return maxpoint\\n\\ndef _gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n    \\ndef _slope(dx, dy):\\n    gcd = _gcd(dx, dy)\\n    return (dx // gcd, dy // gcd)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47137,
                "title": "clean-python-code",
                "content": "This problem has two points to note:\\n\\n - point in `points` may be duplicate.\\n - use `a*y + b*x + c = 0` to represent a line, not `y = k*x + b`, because `k` and `b` may be float number, and float numbers can't be compared with `=`.  Two equal `key` in hash table representing `line` may differ.\\n\\n.\\n\\n    class Solution(object):\\n        def gcd(self, a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n    \\n        def maxPoints(self, points):\\n            if not points:\\n                return 0\\n    \\n            points = map(lambda p: (p.x, p.y), points)\\n    \\n            counter, points, lines = (\\n                collections.Counter(points), list(set(points)),\\n                collections.defaultdict(set))\\n    \\n            for i in xrange(len(points)):\\n                for j in xrange(i + 1, len(points)):\\n                    (x1, y1), (x2, y2) = points[i], points[j]\\n    \\n                    a, b, c = x1 - x2, y2 - y1, x2 * y1 - x1 * y2\\n                    if a < 0 or a == 0 and b < 0:\\n                        a, b, c = -a, -b, -c\\n    \\n                    gcd = self.gcd(self.gcd(abs(a), abs(b)), abs(c))\\n                    lines[(a / gcd, b / gcd, c / gcd)] |= {points[i], points[j]}\\n    \\n            return max([\\n                sum([counter[p] for p in ps])\\n                for ps in lines.values()\\n            ] + counter.values())",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        def gcd(self, a, b):\\n            while b:\\n                a, b = b, a % b\\n            return a\\n    \\n        def maxPoints(self, points):\\n            if not points:\\n                return 0\\n    \\n            points = map(lambda p: (p.x, p.y), points)\\n    \\n            counter, points, lines = (\\n                collections.Counter(points), list(set(points)),\\n                collections.defaultdict(set))\\n    \\n            for i in xrange(len(points)):\\n                for j in xrange(i + 1, len(points)):\\n                    (x1, y1), (x2, y2) = points[i], points[j]\\n    \\n                    a, b, c = x1 - x2, y2 - y1, x2 * y1 - x1 * y2\\n                    if a < 0 or a == 0 and b < 0:\\n                        a, b, c = -a, -b, -c\\n    \\n                    gcd = self.gcd(self.gcd(abs(a), abs(b)), abs(c))\\n                    lines[(a / gcd, b / gcd, c / gcd)] |= {points[i], points[j]}",
                "codeTag": "Java"
            },
            {
                "id": 47253,
                "title": "52ms-python-solution-o-n-2-with-point-dedup",
                "content": "Basically the same N square solution. Used a map to merge identical points to speed up the double loop.\\n\\nRunning time 52 ms above 100% rest submissions in Python category (I know the float key in hash sucks :-)).\\n\\n    # Definition for a point.\\n    # class Point(object):\\n    #     def __init__(self, a=0, b=0):\\n    #         self.x = a\\n    #         self.y = b\\n    \\n    class Solution(object):\\n        def maxPoints(self, points):\\n            \"\"\"\\n            :type points: List[Point]\\n            :rtype: int\\n            \"\"\"\\n            if len(points) == 0:\\n                return 0\\n            mm = {}\\n            for p in points:\\n                mm[(p.x,p.y)] = mm.get((p.x,p.y), 0) + 1\\n            P = mm.keys()    \\n            if len(P) == 1:\\n                return mm[P[0]]\\n            maxP = 0\\n            for i in xrange(len(P)-1):\\n                slopes,repCnt = {},1\\n                for j in xrange(i+1,len(P)):\\n                    dx,dy = P[i][0]-P[j][0],P[i][1]-P[j][1]\\n                    if dx == 0:\\n                        slope = \"#\"\\n                    elif dy == 0:\\n                        slope = 0\\n                    else:\\n                        slope = float(dy) / dx\\n                    slopes[slope] = slopes.get(slope,0) + mm[P[j]]\\n                maxP = max(maxP, mm[P[i]] + max(slopes.values()))\\n            return maxP",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def maxPoints(self, points):\\n            \"\"\"\\n            :type points: List[Point]\\n            :rtype: int\\n            \"\"\"\\n            if len(points) == 0:\\n                return 0\\n            mm = {}",
                "codeTag": "Java"
            },
            {
                "id": 3016317,
                "title": "implementation-using-c",
                "content": "\\n\\n```\\npublic class Solution {\\n    public int MaxPoints(int[][] points) {\\n        int n = points.Length;\\n        if (n == 1) {\\n            return 1;\\n        }\\n        int result = 2;\\n        for (int i = 0; i < n; ++i) {\\n            var cnt = new Dictionary<double, int>();\\n            for (int j = 0; j < n; ++j) {\\n                if (j != i) {\\n                    var angle = Math.Atan2(points[j][1] - points[i][1], points[j][0] - points[i][0]);\\n                    cnt[angle] = cnt.GetValueOrDefault(angle, 0) + 1;\\n                }\\n            }\\n            result = Math.Max(result, cnt.Values.Max() + 1);\\n        }\\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxPoints(int[][] points) {\\n        int n = points.Length;\\n        if (n == 1) {\\n            return 1;\\n        }\\n        int result = 2;\\n        for (int i = 0; i < n; ++i) {\\n            var cnt = new Dictionary<double, int>();\\n            for (int j = 0; j < n; ++j) {\\n                if (j != i) {\\n                    var angle = Math.Atan2(points[j][1] - points[i][1], points[j][0] - points[i][0]);\\n                    cnt[angle] = cnt.GetValueOrDefault(angle, 0) + 1;\\n                }\\n            }\\n            result = Math.Max(result, cnt.Values.Max() + 1);\\n        }\\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016275,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Prerequisites: Basic Coordinate Geometry\\nclass point{\\n    public:\\n    double x,y;\\n    point(double x,double y){\\n        this->x=x;\\n        this->y=y;\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool isCollinear(point a,point b,point c){//checks if three given points lie on a same line\\n        double m1=(b.y-a.y)/(b.x-a.x);\\n        double m2=(c.y-b.y)/(c.x-b.x);\\n        return m1==m2;\\n    }\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2){//2 or less than two points are always collinear\\n            return n;\\n        }\\n        vector<point> coordinates;\\n        for(auto& i:points){\\n            point k=point((double)i[0],(double)i[1]);\\n            coordinates.push_back(k);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int cnt=0;\\n                for(int k=0;k<n;k++){\\n                    if(i!=j&&j!=k&&i!=k){\\n                        if(isCollinear(coordinates[i],coordinates[j],coordinates[k])){\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n                ans=max(cnt+2,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n//Prerequisites: Basic Coordinate Geometry\\nclass point{\\n    public:\\n    double x,y;\\n    point(double x,double y){\\n        this->x=x;\\n        this->y=y;\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool isCollinear(point a,point b,point c){//checks if three given points lie on a same line\\n        double m1=(b.y-a.y)/(b.x-a.x);\\n        double m2=(c.y-b.y)/(c.x-b.x);\\n        return m1==m2;\\n    }\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2){//2 or less than two points are always collinear\\n            return n;\\n        }\\n        vector<point> coordinates;\\n        for(auto& i:points){\\n            point k=point((double)i[0],(double)i[1]);\\n            coordinates.push_back(k);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int cnt=0;\\n                for(int k=0;k<n;k++){\\n                    if(i!=j&&j!=k&&i!=k){\\n                        if(isCollinear(coordinates[i],coordinates[j],coordinates[k])){\\n                            cnt++;\\n                        }\\n                    }\\n                }\\n                ans=max(cnt+2,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585883,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // take every point and find the slope with other points\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // declare a map which will store the frequency of each slope\\n            \\n            unordered_map<double, int> mp;\\n            \\n            int temp_max = 0;\\n            \\n            int x1 = arr[i][0];\\n            \\n            int y1 = arr[i][1];\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                {\\n                    continue;\\n                }\\n                \\n                int x2 = arr[j][0];\\n                \\n                int y2 = arr[j][1];\\n                \\n                double nume = y2 - y1;\\n                \\n                double deno = x2 - x1;\\n                \\n                // if denominator will be zero then slope will be INT_MAX\\n                \\n                if(deno == 0)\\n                {\\n                    mp[INT_MAX]++;\\n                    \\n                    // update temp_max\\n                    \\n                    temp_max = max(temp_max, mp[INT_MAX]);\\n                    \\n                    continue;\\n                }\\n                \\n                // find the slope and update frequency\\n                \\n                double slope = nume / deno;\\n                \\n                mp[slope]++;\\n                \\n                temp_max = max(temp_max, mp[slope]);\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, temp_max + 1);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        // take every point and find the slope with other points\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // declare a map which will store the frequency of each slope\\n            \\n            unordered_map<double, int> mp;\\n            \\n            int temp_max = 0;\\n            \\n            int x1 = arr[i][0];\\n            \\n            int y1 = arr[i][1];\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(j == i)\\n                {\\n                    continue;\\n                }\\n                \\n                int x2 = arr[j][0];\\n                \\n                int y2 = arr[j][1];\\n                \\n                double nume = y2 - y1;\\n                \\n                double deno = x2 - x1;\\n                \\n                // if denominator will be zero then slope will be INT_MAX\\n                \\n                if(deno == 0)\\n                {\\n                    mp[INT_MAX]++;\\n                    \\n                    // update temp_max\\n                    \\n                    temp_max = max(temp_max, mp[INT_MAX]);\\n                    \\n                    continue;\\n                }\\n                \\n                // find the slope and update frequency\\n                \\n                double slope = nume / deno;\\n                \\n                mp[slope]++;\\n                \\n                temp_max = max(temp_max, mp[slope]);\\n            }\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, temp_max + 1);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418570,
                "title": "c-solution-beats-96-slope-in-the-form-of-p-q",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<pair<int, int>, int> mp;\\n        sort(points.begin(), points.end());\\n        int n = points.size();\\n        if (n == 0) return 0;\\n        int ans = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int p = 0, m = 0;\\n            for (int j = i + 1; j < n; ++j) {\\n                if (points[j] == points[i])\\n                    p++;\\n                int x = points[j][0] - points[i][0];\\n                int y = points[j][1] - points[i][1];\\n                if ( x == 0 and y == 0)\\n                    continue;\\n                int g = __gcd(x, y);\\n                pair<int, int> a = {x / g, y / g};\\n                mp[a]++;\\n                m = max(m, mp[a]);\\n                \\n                    \\n            }\\n            ans = max(ans, m + p + 1);\\n            mp.clear();\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<pair<int, int>, int> mp;\\n        sort(points.begin(), points.end());\\n        int n = points.size();\\n        if (n == 0) return 0;\\n        int ans = 1;\\n        for (int i = 0; i < n; ++i) {\\n            int p = 0, m = 0;\\n            for (int j = i + 1; j < n; ++j) {\\n                if (points[j] == points[i])\\n                    p++;\\n                int x = points[j][0] - points[i][0];\\n                int y = points[j][1] - points[i][1];\\n                if ( x == 0 and y == 0)\\n                    continue;\\n                int g = __gcd(x, y);\\n                pair<int, int> a = {x / g, y / g};\\n                mp[a]++;\\n                m = max(m, mp[a]);\\n                \\n                    \\n            }\\n            ans = max(ans, m + p + 1);\\n            mp.clear();\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47205,
                "title": "11ms-java-solution-without-any-map-structure",
                "content": "         public int maxPoints(Point[] points){\\n      if(points == null || points.length == 0){\\n          return 0;\\n      }\\n      \\n      if(points.length <= 2){\\n          return points.length;\\n      }\\n      \\n      int ret = 0;\\n      \\n      int n = points.length;\\n      int count = 0; \\n      int duplicates = 0;\\n      \\n      for(int i = 0; i < n; i++){\\n          Point p = points[i];\\n          count = 0;\\n          duplicates = 0;\\n          \\n          for(int j = i + 1; j < n; j++){\\n              Point q = points[j];\\n              if(q.x == p.x && q.y == p.y){\\n                  duplicates++;\\n                  ret = Math.max(ret, duplicates + 1);\\n                  continue;\\n              }\\n              \\n              //count point q\\n              count = 1;\\n              \\n              for(int k = j + 1; k < n; k++){\\n                  Point r = points[k];\\n                  count += isCoLinear(p, q, r)? 1: 0;\\n              }\\n              \\n              //count point p\\n              ret = Math.max(ret, count + duplicates + 1);\\n          }\\n          \\n      }\\n      \\n      return ret;\\n  }\\n\\n     private boolean isCoLinear(Point p, Point q, Point r){\\n      int val = (q.y - p.y) *(r.x - q.x) - (r.y - q.y)*(q.x - p.x);\\n\\t  return val == 0;\\n  }",
                "solutionTags": [],
                "code": "         public int maxPoints(Point[] points){\\n      if(points == null || points.length == 0){\\n          return 0;\\n      }\\n      \\n      if(points.length <= 2){\\n          return points.length;\\n      }\\n      \\n      int ret = 0;\\n      \\n      int n = points.length;\\n      int count = 0; \\n      int duplicates = 0;\\n      \\n      for(int i = 0; i < n; i++){\\n          Point p = points[i];\\n          count = 0;\\n          duplicates = 0;\\n          \\n          for(int j = i + 1; j < n; j++){\\n              Point q = points[j];\\n              if(q.x == p.x && q.y == p.y){\\n                  duplicates++;\\n                  ret = Math.max(ret, duplicates + 1);\\n                  continue;\\n              }\\n              \\n              //count point q\\n              count = 1;\\n              \\n              for(int k = j + 1; k < n; k++){\\n                  Point r = points[k];\\n                  count += isCoLinear(p, q, r)? 1: 0;\\n              }\\n              \\n              //count point p\\n              ret = Math.max(ret, count + duplicates + 1);\\n          }\\n          \\n      }\\n      \\n      return ret;\\n  }\\n\\n     private boolean isCoLinear(Point p, Point q, Point r){\\n      int val = (q.y - p.y) *(r.x - q.x) - (r.y - q.y)*(q.x - p.x);\\n\\t  return val == 0;\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 3021777,
                "title": "python-3-o-n-2-logically-explained",
                "content": "**Intuition**\\n\\nThere are nC2 ways in which we can select two points to form a line, we\\'re just hashing that line and finding how many pairs of points form the same unique line. Which can be done easiliy in O(nc2) ~ O(n^2)\\n\\n**Simple step by step solution -**\\n\\ni. Iterate through all points in the array, and for each point, store its slope with respect to every other point in a dictionary. The slope between two points (x1, y1) and (x2, y2) is given by (y2 - y1) / (x2 - x1).\\n\\nii. For each point, find the maximum number of points that have the same slope with respect to that point. This can be done by finding the maximum value in the dictionary of slopes for that point.\\n\\niii. Return the maximum number of points found in step 2. This will be the maximum number of points that lie on the same straight line.\\n\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        max_points = 0\\n        for i in range(len(points)):\\n            slopes = defaultdict(int)\\n            slopes[\\'a\\'] = 0\\n            same_points = 1\\n            for j in range(i + 1, len(points)):\\n                if points[i] == points[j]:\\n                    same_points += 1\\n                    continue\\n                slope = float(\\'inf\\') if points[i][0] == points[j][0] else (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\\n                slopes[slope] += 1\\n            a = max(slopes.values())\\n            max_points = max(max_points, a + same_points)\\n        return max_points\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        max_points = 0\\n        for i in range(len(points)):\\n            slopes = defaultdict(int)\\n            slopes[\\'a\\'] = 0\\n            same_points = 1\\n            for j in range(i + 1, len(points)):\\n                if points[i] == points[j]:\\n                    same_points += 1\\n                    continue\\n                slope = float(\\'inf\\') if points[i][0] == points[j][0] else (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\\n                slopes[slope] += 1\\n            a = max(slopes.values())\\n            max_points = max(max_points, a + same_points)\\n        return max_points\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019658,
                "title": "c-using-hash-pair-unordered-map-pair-int-int-int-must-watch",
                "content": "* **M1** \\n```c++\\nstruct hash_pair {\\n    template <class T1, class T2>\\n    size_t operator()(const pair<T1, T2>& p) const{\\n        auto hash1 = hash<T1>{}(p.first);\\n        auto hash2 = hash<T2>{}(p.second);\\n        return hash1 ^ hash2 ;\\n    }\\n};\\n\\nclass Solution {\\n    typedef pair<int,int> pii;\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(), mx,my,x2,y2 ,ans = 0;\\n        for(int i = 0;i<n;i++){\\n            unordered_map<pii,int, hash_pair> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i==j) continue;\\n                my = p[j][1]-p[i][1], mx = p[j][0]-p[i][0];\\n                int x = __gcd(my,mx);\\n                ans = max(ans,++mp[{my/x,mx/x}]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```\\n* **M2** \\n* EASY VERSION OF M1\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(), mx,my,x2,y2 ,ans = 0;\\n        for(int i = 0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i==j) continue;\\n                ans = max(ans,++mp[(p[j][1]-p[i][1])*1.0/(p[j][0]-p[i][0])]);\\n            }\\n        }\\n        // cout<<((4*1.00)/0);  outputs inf. \\n        return ans+1;\\n    }\\n};\\n```\\n* **M3** \\n* **TLE**\\n* **LINE Method**\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(),my,mx,x1,y1,ans = 1;\\n        for(int i = 0;i<n;i++){\\n            x1 = p[i][0], y1 = p[i][1];\\n            for(int k = i+1;k<n;k++){\\n                my = p[k][1]-p[i][1], mx = p[k][0]-p[i][0];\\n                int temp = 0;\\n                for(auto it:p) mx*(it[1]-y1) == my*(it[0]-x1)? temp++ :0;\\n                ans = max(ans,temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nstruct hash_pair {\\n    template <class T1, class T2>\\n    size_t operator()(const pair<T1, T2>& p) const{\\n        auto hash1 = hash<T1>{}(p.first);\\n        auto hash2 = hash<T2>{}(p.second);\\n        return hash1 ^ hash2 ;\\n    }\\n};\\n\\nclass Solution {\\n    typedef pair<int,int> pii;\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(), mx,my,x2,y2 ,ans = 0;\\n        for(int i = 0;i<n;i++){\\n            unordered_map<pii,int, hash_pair> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i==j) continue;\\n                my = p[j][1]-p[i][1], mx = p[j][0]-p[i][0];\\n                int x = __gcd(my,mx);\\n                ans = max(ans,++mp[{my/x,mx/x}]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(), mx,my,x2,y2 ,ans = 0;\\n        for(int i = 0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            for(int j = 0;j<n;j++){\\n                if(i==j) continue;\\n                ans = max(ans,++mp[(p[j][1]-p[i][1])*1.0/(p[j][0]-p[i][0])]);\\n            }\\n        }\\n        // cout<<((4*1.00)/0);  outputs inf. \\n        return ans+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size(),my,mx,x1,y1,ans = 1;\\n        for(int i = 0;i<n;i++){\\n            x1 = p[i][0], y1 = p[i][1];\\n            for(int k = i+1;k<n;k++){\\n                my = p[k][1]-p[i][1], mx = p[k][0]-p[i][0];\\n                int temp = 0;\\n                for(auto it:p) mx*(it[1]-y1) == my*(it[0]-x1)? temp++ :0;\\n                ans = max(ans,temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3019411,
                "title": "simple-c-beats-100-slope-approach-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Simple maths find the slope of lines and then store the slopes the one having max occurences will be our answer if many lines are correspondig to a  slope then answer is just its ocurrneces +1 beacuse we have to return points .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple check all the combinations using two loops and count the slopes in a map store all the occurences of a slope and at last that slope which has maximum occurences will be answer just do +1 is answer because slope is between two points so  first point is not counted as we compare *(x1,y1) with (x2,y2) with (x3,y3).*.. and so on but on first comparison count is 1 but those are two points so we have to return *ans+1* .\\n***Formula for slope : (y2-y1)/(x2-x1)***\\n**Note:** Only in Case there is infinity slope take absloute of infinity because -inf and +inf is same thing here because no mater what y1 and y2 is if x1==x2 denominator is zero so it will be just infinity but compiler will take it as +inf and -inf as per y1 and y2 so take abs(inf)\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pt) {\\n         int ans=1; \\n        int n=pt.size();\\n        for(int i=0;i<n-1;i++){\\n            map<double,int> mp;\\n            for(int j=i+1;j<n;j++){\\n                double x2=pt[j][0],x1=pt[i][0];\\n                double y2=pt[j][1],y1=pt[i][1];\\n                double slope =(y2-y1)/(x2-x1);\\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) \\n                mp[abs(slope)]++; \\n                else\\n                    mp[slope]++;\\n            }\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second); \\n            ans = max(temp+1, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pt) {\\n         int ans=1; \\n        int n=pt.size();\\n        for(int i=0;i<n-1;i++){\\n            map<double,int> mp;\\n            for(int j=i+1;j<n;j++){\\n                double x2=pt[j][0],x1=pt[i][0];\\n                double y2=pt[j][1],y1=pt[i][1];\\n                double slope =(y2-y1)/(x2-x1);\\n                if(pt[j][1]-pt[i][1]<0 &&(pt[j][0]-pt[i][0])==0 ) \\n                mp[abs(slope)]++; \\n                else\\n                    mp[slope]++;\\n            }\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second); \\n            ans = max(temp+1, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018879,
                "title": "c-beats-approx-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Solve using calculating Slopes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will select point and for every selected point we will calculate the slope with respect to another point and store into the map.\\n- Then, find the max number of points having the same slope with respect to that selected point :-means which slope have maximum point\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int ans=1; \\n        int n=points.size();\\n        sort(points.begin(),points.end());\\n       // slope of every point with selected point\\n       for(int i=0;i<n-1;i++)\\n       {\\n           map<double,int> slope;\\n           for(int j=i+1;j<n;j++)\\n           {\\n               if(points[i][1]==points[j][1])\\n                    slope[INT_MAX]++;// for perpendicular line\\n               else\\n               {\\n                   double x=(double)(points[j][0]-points[i][0])/(double)(points[j][1]-points[i][1]);\\n                   slope[x]++;\\n               }\\n           }\\n           // same slope w.r.t.that selected point\\n            int temp = 0;\\n            for(auto it:slope)\\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\\n            ans = max(temp, ans);\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int ans=1; \\n        int n=points.size();\\n        sort(points.begin(),points.end());\\n       // slope of every point with selected point\\n       for(int i=0;i<n-1;i++)\\n       {\\n           map<double,int> slope;\\n           for(int j=i+1;j<n;j++)\\n           {\\n               if(points[i][1]==points[j][1])\\n                    slope[INT_MAX]++;// for perpendicular line\\n               else\\n               {\\n                   double x=(double)(points[j][0]-points[i][0])/(double)(points[j][1]-points[i][1]);\\n                   slope[x]++;\\n               }\\n           }\\n           // same slope w.r.t.that selected point\\n            int temp = 0;\\n            for(auto it:slope)\\n                temp = max(temp, it.second+1);    // +1 for the current point(point itself)\\n            ans = max(temp, ans);\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016188,
                "title": "daily-leetcoding-challenge-january-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/max-points-on-a-line/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/max-points-on-a-line/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2994261,
                "title": "easiest-solution-using-map-and-slope-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Two points lie on a line when their slope is equal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- To find the maximum number of points that lie on a single line, check lines of all points.\\n- Starting from point 1 count how many points can lie on the line between point 1 and all others.\\n- Similarly repeat this process for all points.\\n- To know if they lie on same line or not, calculate slope and store it in map.\\n- So for every point maintain map and count of points having differnt slopes.\\n- Finally return max points that lie on a line. \\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2) return n;\\n        int ans = 0;\\n\\n        for(auto it1 : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it1[0], y1 = it1[1];\\n            for(auto it2 : points){   \\n                if(it2 == it1) continue;\\n                double x2 = it2[0], y2 = it2[1];\\n                double slope;\\n                if(x2-x1 == 0){\\n                    slope = INT_MAX; // slope is infinity for vertical line\\n                }else{\\n                    slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n        return ans+1; //including point i\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=2) return n;\\n        int ans = 0;\\n\\n        for(auto it1 : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it1[0], y1 = it1[1];\\n            for(auto it2 : points){   \\n                if(it2 == it1) continue;\\n                double x2 = it2[0], y2 = it2[1];\\n                double slope;\\n                if(x2-x1 == 0){\\n                    slope = INT_MAX; // slope is infinity for vertical line\\n                }else{\\n                    slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n        return ans+1; //including point i\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419909,
                "title": "simple-and-efficient-solution",
                "content": "Just calculate the slope of every point with selected point and store it in the map then  find the max number of points having the same slope w.r.t. that selected point.\\n\\nPlease upvote...\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int mx = 1, n=points.size();\\n        \\n        for(int i=0;i<n-1;i++){\\n            map<double, int> mp;\\n            for(int j=i+1;j<n;j++){\\n                if(points[j][1]==points[i][1])      mp[-3000]++;    // just random slope to avoid slope of 90 degree\\n                else{ \\n                    double x = (double)(points[j][0]-points[i][0])/(double)(points[j][1]-points[i][1]);\\n                    mp[x]++;\\n                }\\n            }\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second+1);    // +1 for the point[i]\\n            mx = max(temp, mx);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int mx = 1, n=points.size();\\n        \\n        for(int i=0;i<n-1;i++){\\n            map<double, int> mp;\\n            for(int j=i+1;j<n;j++){\\n                if(points[j][1]==points[i][1])      mp[-3000]++;    // just random slope to avoid slope of 90 degree\\n                else{ \\n                    double x = (double)(points[j][0]-points[i][0])/(double)(points[j][1]-points[i][1]);\\n                    mp[x]++;\\n                }\\n            }\\n            int temp = 0;\\n            for(auto it:mp)\\n                temp = max(temp, it.second+1);    // +1 for the point[i]\\n            mx = max(temp, mx);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152319,
                "title": "easy-c-solution-hashmap-slope-formula-90-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==2)\\n            return 2;\\n        int max_points = 0;\\n        \\n        for(int i=0; i<points.size(); i++){\\n            unordered_map <float, int> map;\\n            for(int j=i+1; j<points.size(); j++){\\n                if((points[i][0] - points[j][0]) != 0){\\n                    float m = (float(points[i][1] - points[j][1]) / float(points[i][0] - points[j][0]));\\n                    map[m]++; \\n                    if(map[m]>max_points)\\n                        max_points = map[m];\\n                }\\n                else{\\n                    map[INT_MAX]++;\\n                    if(map[INT_MAX]>max_points)\\n                        max_points = map[INT_MAX];\\n                }\\n            }\\n        }\\n        \\n        return max_points+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==2)\\n            return 2;\\n        int max_points = 0;\\n        \\n        for(int i=0; i<points.size(); i++){\\n            unordered_map <float, int> map;\\n            for(int j=i+1; j<points.size(); j++){\\n                if((points[i][0] - points[j][0]) != 0){\\n                    float m = (float(points[i][1] - points[j][1]) / float(points[i][0] - points[j][0]));\\n                    map[m]++; \\n                    if(map[m]>max_points)\\n                        max_points = map[m];\\n                }\\n                else{\\n                    map[INT_MAX]++;\\n                    if(map[INT_MAX]>max_points)\\n                        max_points = map[INT_MAX];\\n                }\\n            }\\n        }\\n        \\n        return max_points+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886185,
                "title": "c-slope-y2-y1-x2-x1-keep-note-of-vertical-line-also",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size() == 1) return 1;\\n        int ans = 0;\\n        for(auto &it : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it[0], y1 = it[1];\\n            for(auto &i : points){\\n                if(i == it) continue;\\n                double x2 = i[0], y2 = i[1];\\n                double curr_slope;\\n                if(x2-x1 == 0){\\n                    curr_slope = 1e9; // if line is vertical \\n                }else{\\n                    curr_slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[curr_slope]++;\\n                ans = max(ans,mp[curr_slope]);\\n            }\\n        }\\n        return ans+1; // ans + 1 is becuase the first point of line was not counted before\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size() == 1) return 1;\\n        int ans = 0;\\n        for(auto &it : points){\\n            unordered_map<double,int> mp;\\n            double x1 = it[0], y1 = it[1];\\n            for(auto &i : points){\\n                if(i == it) continue;\\n                double x2 = i[0], y2 = i[1];\\n                double curr_slope;\\n                if(x2-x1 == 0){\\n                    curr_slope = 1e9; // if line is vertical \\n                }else{\\n                    curr_slope = (y2-y1)/(x2-x1);   \\n                }\\n                mp[curr_slope]++;\\n                ans = max(ans,mp[curr_slope]);\\n            }\\n        }\\n        return ans+1; // ans + 1 is becuase the first point of line was not counted before\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672166,
                "title": "simple-c-solution-with-comments",
                "content": "Approach:\\ni) If the no of points is less than or equal to 2, then that particular no is the answer.\\nii) For each point, we find out \\n\\t\\ta) how many duplicates it have\\n\\t\\tb) how many points lie on the same x-axis as that point\\n\\t\\tc) which slope of that point has the maximum no of points in it\\n\\tFor these reasons, every point has its own map and other variables.\\niii) After checking all other points from i+1 to n-1 for i-th point, the answer is compared\\n\\twith previous maximum ans and if the new localAns is maximum, it is stored in the ans.\\n```\\nint maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n <= 2)\\n            return n;\\n        int ans = 0;\\n        for(int i=0; i< n; i++){\\n            int local = 1;          //To hold the local result\\n            int vertical = 1;      // To check if both points are on the same line on x axis\\n            int duplicate = 0;     //To keep count of duplicates\\n            unordered_map<long double,int> um;\\n            for(int j=i+1;j<n; j++){\\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                if(x2 == x1 && y2 == y1)\\n                    duplicate++;\\n                else if(x2 - x1 == 0)\\n                    vertical++;\\n                else{\\n                    long double numerator = (y2-y1);\\n                    long double denominator = (x2-x1);\\n                    long double slope = numerator/denominator; //Formula to find out slope\\n                    if(um[slope] == 0)\\n                        um[slope] = 2;\\n                    else\\n                        um[slope]++;\\n                    \\n                    local = max(local,um[slope]);     // Check if the current slope has max no of points\\n                                                     //or the previous slope had the most no of points\\n                }\\n            }\\n            local = max(local+duplicate,vertical+duplicate);  //Adding the duplicates while checking as those will fetch similar results\\n            ans = max(ans,local);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n <= 2)\\n            return n;\\n        int ans = 0;\\n        for(int i=0; i< n; i++){\\n            int local = 1;          //To hold the local result\\n            int vertical = 1;      // To check if both points are on the same line on x axis\\n            int duplicate = 0;     //To keep count of duplicates\\n            unordered_map<long double,int> um;\\n            for(int j=i+1;j<n; j++){\\n                int x1 = points[i][0];\\n                int y1 = points[i][1];\\n                int x2 = points[j][0];\\n                int y2 = points[j][1];\\n                if(x2 == x1 && y2 == y1)\\n                    duplicate++;\\n                else if(x2 - x1 == 0)\\n                    vertical++;\\n                else{\\n                    long double numerator = (y2-y1);\\n                    long double denominator = (x2-x1);\\n                    long double slope = numerator/denominator; //Formula to find out slope\\n                    if(um[slope] == 0)\\n                        um[slope] = 2;\\n                    else\\n                        um[slope]++;\\n                    \\n                    local = max(local,um[slope]);     // Check if the current slope has max no of points\\n                                                     //or the previous slope had the most no of points\\n                }\\n            }\\n            local = max(local+duplicate,vertical+duplicate);  //Adding the duplicates while checking as those will fetch similar results\\n            ans = max(ans,local);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375601,
                "title": "one-point-doesn-t-make-a-line",
                "content": "The test case of \\n```Input\\n[[0,0]]\\nOutput\\n0\\nExpected\\n1\\n```\\nis incorrect. As one point doesn\\'t make a line! \\n",
                "solutionTags": [],
                "code": "```Input\\n[[0,0]]\\nOutput\\n0\\nExpected\\n1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328729,
                "title": "swift-o-n-2-85-beat-clever-stuff-doesn-t-work-with-slope-haxor",
                "content": "```\\nclass Solution {\\n    \\n    struct LineType: Hashable, Equatable {\\n        \\n        var x: Int = 0\\n        var y: Int = 0\\n        \\n        var hashValue : Int {\\n          get {\\n              return x.hashValue ^ y.hashValue\\n          }\\n        }\\n        \\n        //Note: this doesn\\'t appear to be necessary.\\n        static func == (lhs: LineType, rhs: LineType) -> Bool {\\n            return lhs.x == rhs.x && lhs.y == rhs.y\\n        }\\n    }\\n    \\n    func maxPoints(_ points: [[Int]]) -> Int {\\n        \\n        var result = 0\\n        \\n        for i in 0..<points.count {\\n            \\n            var j = i - 1\\n            \\n            var horCount = 0\\n            var verCount = 0\\n            var sameCount = 0\\n            var slopeCount = 0\\n            \\n            var slopeMap = [LineType: Int]()\\n            \\n            while j >= 0 {\\n                \\n                var dx = points[i][0] - points[j][0]\\n                var dy = points[i][1] - points[j][1]\\n                \\n                if dx == 0 && dy == 0 {\\n                    sameCount += 1\\n                } else if dx == 0 {\\n                    verCount += 1\\n                } else if dy == 0 {\\n                    horCount += 1\\n                } else {\\n                    \\n                    var gcd = 0\\n                    var num1 = dx\\n                    var num2 = dy\\n                    var remainder = 0\\n                    while num1 != 0 {\\n                        remainder = num2 % num1\\n                        num2 = num1\\n                        num1 = remainder\\n                    }\\n                    gcd = num2\\n                    \\n                    var slopeClassification = LineType(x: dx / gcd, y: dy / gcd)\\n                    \\n                    if var count = slopeMap[slopeClassification] {\\n                        count += 1\\n                        slopeMap[slopeClassification] = count\\n                    } else {\\n                        slopeMap[slopeClassification] = 1\\n                    }\\n                    \\n                    if var count = slopeMap[slopeClassification] {\\n                        slopeCount = max(slopeCount, count)\\n                    }\\n                }\\n                j -= 1\\n            }\\n            \\n            var checkResult = max(max(horCount, verCount), slopeCount)\\n            result = max(result, checkResult + sameCount + 1)\\n        }\\n        return result\\n    }\\n}\\n```\\n\\nPlease see C++ result for more detailed explanation. This was a valuable learning experience. I\\'ve learned that tuples are not hashable and not able to be used in dictionaries.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    struct LineType: Hashable, Equatable {\\n        \\n        var x: Int = 0\\n        var y: Int = 0\\n        \\n        var hashValue : Int {\\n          get {\\n              return x.hashValue ^ y.hashValue\\n          }\\n        }\\n        \\n        //Note: this doesn\\'t appear to be necessary.\\n        static func == (lhs: LineType, rhs: LineType) -> Bool {\\n            return lhs.x == rhs.x && lhs.y == rhs.y\\n        }\\n    }\\n    \\n    func maxPoints(_ points: [[Int]]) -> Int {\\n        \\n        var result = 0\\n        \\n        for i in 0..<points.count {\\n            \\n            var j = i - 1\\n            \\n            var horCount = 0\\n            var verCount = 0\\n            var sameCount = 0\\n            var slopeCount = 0\\n            \\n            var slopeMap = [LineType: Int]()\\n            \\n            while j >= 0 {\\n                \\n                var dx = points[i][0] - points[j][0]\\n                var dy = points[i][1] - points[j][1]\\n                \\n                if dx == 0 && dy == 0 {\\n                    sameCount += 1\\n                } else if dx == 0 {\\n                    verCount += 1\\n                } else if dy == 0 {\\n                    horCount += 1\\n                } else {\\n                    \\n                    var gcd = 0\\n                    var num1 = dx\\n                    var num2 = dy\\n                    var remainder = 0\\n                    while num1 != 0 {\\n                        remainder = num2 % num1\\n                        num2 = num1\\n                        num1 = remainder\\n                    }\\n                    gcd = num2\\n                    \\n                    var slopeClassification = LineType(x: dx / gcd, y: dy / gcd)\\n                    \\n                    if var count = slopeMap[slopeClassification] {\\n                        count += 1\\n                        slopeMap[slopeClassification] = count\\n                    } else {\\n                        slopeMap[slopeClassification] = 1\\n                    }\\n                    \\n                    if var count = slopeMap[slopeClassification] {\\n                        slopeCount = max(slopeCount, count)\\n                    }\\n                }\\n                j -= 1\\n            }\\n            \\n            var checkResult = max(max(horCount, verCount), slopeCount)\\n            result = max(result, checkResult + sameCount + 1)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47274,
                "title": "another-accepted-java-solution",
                "content": "A line can be represented as y = k * x + d, it can also be represented as k = (y - d) / x, d = y - k * x. The idea is to find all the possible line representation and count the max one.\\n\\n\\n\\n    public int maxPoints(Point[] points) {\\n      if (points == null || points.length == 0)\\n        return 0;\\n          \\n      int n = points.length, max = 1;\\n      \\n      Map<String, Set<Point>> map = new HashMap<String, Set<Point>>();\\n      \\n      // sort the points by x to avoid -0.0 slope issue!\\n      Collections.sort(Arrays.asList(points), new Comparator<Point>() {\\n        public int compare(Point a, Point b) { return a.x - b.x; }\\n      });\\n      \\n      for (int i = 0; i < n; i++) {\\n        for (int j = i + 1; j < n; j++) {\\n          Point p1 = points[i];\\n          Point p2 = points[j];\\n          \\n          StringBuilder sb = new StringBuilder();\\n          \\n          if (p1.x == p2.x) {\\n            sb.append(\"inf\").append(p1.x);\\n          } else {\\n            // y = k * x + d\\n            double k = (double)(p1.y - p2.y) / (p1.x - p2.x);\\n            double d = p1.y - k * p1.x;\\n            sb.append(\"k\").append(k).append(\"d\").append(d);\\n          }\\n          \\n          String key = sb.toString();\\n          Set<Point> set = map.containsKey(key) ? map.get(key) : new HashSet<Point>();\\n          \\n          set.add(p1);\\n          set.add(p2);\\n          \\n          map.put(key, set);\\n          max = Math.max(max, set.size());\\n        }\\n      }\\n      \\n      return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "A line can be represented as y = k * x + d, it can also be represented as k = (y - d) / x, d = y - k * x. The idea is to find all the possible line representation and count the max one.\\n\\n\\n\\n    public int maxPoints(Point[] points) {\\n      if (points == null || points.length == 0)\\n        return 0;\\n          \\n      int n = points.length, max = 1;\\n      \\n      Map<String, Set<Point>> map = new HashMap<String, Set<Point>>();\\n      \\n      // sort the points by x to avoid -0.0 slope issue!\\n      Collections.sort(Arrays.asList(points), new Comparator<Point>() {\\n        public int compare(Point a, Point b) { return a.x - b.x; }\\n      });\\n      \\n      for (int i = 0; i < n; i++) {\\n        for (int j = i + 1; j < n; j++) {\\n          Point p1 = points[i];\\n          Point p2 = points[j];\\n          \\n          StringBuilder sb = new StringBuilder();\\n          \\n          if (p1.x == p2.x) {\\n            sb.append(\"inf\").append(p1.x);\\n          } else {\\n            // y = k * x + d\\n            double k = (double)(p1.y - p2.y) / (p1.x - p2.x);\\n            double d = p1.y - k * p1.x;\\n            sb.append(\"k\").append(k).append(\"d\").append(d);\\n          }\\n          \\n          String key = sb.toString();\\n          Set<Point> set = map.containsKey(key) ? map.get(key) : new HashSet<Point>();\\n          \\n          set.add(p1);\\n          set.add(p2);\\n          \\n          map.put(key, set);\\n          max = Math.max(max, set.size());\\n        }\\n      }\\n      \\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 47273,
                "title": "solution-in-java-without-hashing-and-floats",
                "content": "The idea is to get two points and than find other points on the line. See comments.\\n\\n    public int maxPoints(Point[] points) {\\n\\t\\tif (points.length < 3) {\\n\\t\\t\\treturn points.length;\\n\\t\\t}\\n\\t\\tint max = 0;\\n\\t\\tfor (int a = 0; a<points.length-2; a++) {\\n\\t\\t\\tboolean[] checked = new boolean[points.length];\\n\\t\\t\\tfor (int b = a+1; b<points.length; b++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Do not check the same line\\n\\t\\t\\t\\tif (checked[b]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// The point-b should differ from point-a\\n\\t\\t\\t\\twhile (b < points.length && points[b].x == points[a].x && points[b].y == points[a].y) {\\n\\t\\t\\t\\t\\tb++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Count all point between point-a and point-b \\n\\t\\t\\t\\t// witch have the same coordinates as point-a\\n\\t\\t\\t\\tint count = b == points.length ? 1 : 2;\\n\\t\\t\\t\\tfor (int i=a+1; i<b; i++) {\\n\\t\\t\\t\\t\\tif (points[i].x == points[a].x && points[i].y == points[a].y) {\\n\\t\\t\\t\\t\\t\\tcount++ ;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Count point-c if it lies on the point-a-point-b-line.\\n\\t\\t\\t\\tfor (int c = b+1; c<points.length; c++) {\\n\\t\\t\\t\\t\\tif (isOnLine(points[a], points[b], points[c])) {\\n\\t\\t\\t\\t\\t\\tcount++ ;\\n\\t\\t\\t\\t\\t\\tchecked[c] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (count > max) {\\n\\t\\t\\t\\t\\tmax = count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return max;\\n    }\\n\\t\\n\\tprivate boolean isOnLine(Point a, Point b, Point c) {\\n\\t\\treturn (b.y - a.y)*(c.x - a.x) == (c.y - a.y)*(b.x - a.x);\\n\\t}",
                "solutionTags": [],
                "code": "The idea is to get two points and than find other points on the line. See comments.\\n\\n    public int maxPoints(Point[] points) {\\n\\t\\tif (points.length < 3) {\\n\\t\\t\\treturn points.length;\\n\\t\\t}\\n\\t\\tint max = 0;\\n\\t\\tfor (int a = 0; a<points.length-2; a++) {\\n\\t\\t\\tboolean[] checked = new boolean[points.length];\\n\\t\\t\\tfor (int b = a+1; b<points.length; b++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Do not check the same line\\n\\t\\t\\t\\tif (checked[b]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// The point-b should differ from point-a\\n\\t\\t\\t\\twhile (b < points.length && points[b].x == points[a].x && points[b].y == points[a].y) {\\n\\t\\t\\t\\t\\tb++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Count all point between point-a and point-b \\n\\t\\t\\t\\t// witch have the same coordinates as point-a\\n\\t\\t\\t\\tint count = b == points.length ? 1 : 2;\\n\\t\\t\\t\\tfor (int i=a+1; i<b; i++) {\\n\\t\\t\\t\\t\\tif (points[i].x == points[a].x && points[i].y == points[a].y) {\\n\\t\\t\\t\\t\\t\\tcount++ ;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Count point-c if it lies on the point-a-point-b-line.\\n\\t\\t\\t\\tfor (int c = b+1; c<points.length; c++) {\\n\\t\\t\\t\\t\\tif (isOnLine(points[a], points[b], points[c])) {\\n\\t\\t\\t\\t\\t\\tcount++ ;\\n\\t\\t\\t\\t\\t\\tchecked[c] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (count > max) {\\n\\t\\t\\t\\t\\tmax = count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        return max;\\n    }\\n\\t\\n\\tprivate boolean isOnLine(Point a, Point b, Point c) {\\n\\t\\treturn (b.y - a.y)*(c.x - a.x) == (c.y - a.y)*(b.x - a.x);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 47313,
                "title": "o-n-3-solution-can-still-pass-test",
                "content": "Admin,\\n\\nFollowing code, O(n ^ 3), can still pass test. Please add more test cases. Thanks!\\n\\n----------\\n\\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n    \\t\\tint ans = 0;\\n    \\t\\tint n = points.size();\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\tint dup = 0;\\n    \\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n    \\t\\t\\t\\tif (points[i].x == points[j].x && points[i].y == points[j].y) {\\n    \\t\\t\\t\\t\\t++dup;\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tint cnt = 2;\\n    \\t\\t\\t\\tfor (int k = j + 1; k < n; ++k) {\\n    \\t\\t\\t\\t\\tif ((points[k].y - points[i].y) * (points[j].x - points[i].x) ==\\n    \\t\\t\\t\\t\\t\\t(points[j].y - points[i].y) * (points[k].x - points[i].x)) {\\n    \\t\\t\\t\\t\\t\\t++cnt;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tans = max(ans, cnt + dup);\\n    \\t\\t\\t}\\n    \\t\\t\\tans = max(ans, dup + 1);\\n    \\t\\t}\\n    \\n    \\t\\treturn ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n    \\t\\tint ans = 0;\\n    \\t\\tint n = points.size();\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\tint dup = 0;\\n    \\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n    \\t\\t\\t\\tif (points[i].x == points[j].x && points[i].y == points[j].y) {\\n    \\t\\t\\t\\t\\t++dup;\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 47312,
                "title": "a-neat-solution-in-c-for-ur-information",
                "content": "use slope and translation for each line as the key in map;\\n\\noverload < and == for map. set for counting.\\n\\nmap and set may be little bit slower but the code is clear\\n\\n    #include <map>\\n    #include <set>\\n    #include <algorithm>\\n    using namespace std;\\n    \\n    struct Line {\\n        double r;  // ratio ; slope\\n        double t;  // translation\\n        \\n        Line(Point p, Point q) { // math\\n            if (q.x == p.x) r = 1e20, t = p.x;\\n            else \\n            {\\n                r = (double) (q.y-p.y) / (double) (q.x-p.x);\\n                t = p.y - p.x * r;\\n            }\\n        }\\n    };\\n    \\n    bool operator < (const Line& a, const Line& b) {\\n        return a.r == b.r ? a.t < b.t : a.r < b.r;\\n    }\\n    \\n    bool operator == (const Line& a, const Line& b) {\\n        return a.r == b.r && a.t == b.t;\\n    }\\n    \\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            if (points.empty()) return 0;\\n            \\n            map<Line, set<Point*> > line_map;\\n            for (auto & a : points)\\n            for (auto & b : points)\\n            {\\n                Line line(a,b);\\n                line_map[line].insert(&a);\\n                line_map[line].insert(&b);\\n            }\\n            \\n            int ret = 1;\\n            for (auto & pr : line_map) ret = max(ret,(int)pr.second.size());\\n            \\n            return ret;\\n        }\\n    };\\n\\n\\n----------\\n\\nNov. 20\\n\\nWell, actually shiyan2 raised a very interesting question. I tried to make it faster by add\\n\\n     for (auto & a : points)\\n           for (auto & b : points)\\n           {\\n               if ( (&a) >= (&b) ) continue;\\n               Line line(a,b);\\n               line_map[line].insert(&a);\\n               line_map[line].insert(&b);\\n           }\\n\\nsuppose it will be two times faster than the prev 1.  but it failed on case \\n \\n\\n     [(3,10),(0,2),(0,2),(3,10)]\\n\\nit said the output it 3 rather than 4. And I test on my machine it's 4.\\n\\nAnyone have any clue about this ?\\n\\n\\n----------\\n\\nNov. 25\\n\\nFinally I got answer for the problems on Nov 20. It is due to the type \"double\" accuracy.\\n\\nnow I changed the == and <  to \\n\\n    inline bool double_equal(double a, double b) { return abs(a-b) < 1e-10; }\\n    inline bool double_less (double a, double b) { return a-b < -1e-10; }\\n\\nand it just works well.\\n\\nbut the time is still high, due to the func calling.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            if (points.empty()) return 0;\\n            \\n            map<Line, set<Point*> > line_map;\\n            for (auto & a : points)\\n            for (auto & b : points)\\n            {\\n                Line line(a,b);\\n                line_map[line].insert(&a);\\n                line_map[line].insert(&b);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 47125,
                "title": "share-my-accepted-java-code-with-explanation",
                "content": "        /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    import java.util.HashMap;\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            if (points.length <= 2){\\n                return points.length;\\n            }\\n            int result=1;\\n         \\n          //A line is defined y=a/bx+c, so (a, b, c) will represent a unique line\\n         // run through each point and calculate (a, b, c) that defines the lines of itself \\n         //with all the the remaining points \\n            for (int i=0; i<points.length; i++){\\n                int max=0, countSame=0;\\n                HashMap<String, Integer> hm = new HashMap<String, Integer>();\\n                for (int j=i+1; j<points.length; j++){\\n                    if (points[i].x == points[j].x && points[i].y == points[j].y){\\n                        countSame++;       //same points will just add to the result\\n                    }\\n                    else{\\n                        String key = normalize(points[i],points[j]);\\n                        if(hm.get(key) == null){\\n                            hm.put(key, 1);\\n                            if(max ==0){\\n                                max++;\\n                            }\\n                        }\\n                        else {\\n                           int count = hm.get(key)+1;\\n                           hm.put(key, count);\\n                         \\n                            if (count > max)\\n                                max = count;\\n                        }\\n                    }\\n                    \\n                }\\n                result = Math.max(result, max+countSame+1);\\n            }\\n    \\n            \\n            return result;\\n        }\\n        \\n        //ax+by+c=0 or y=a/b x + c\\n        private String normalize(Point p1, Point p2){\\n            int a, b;\\n            float c;\\n            \\n            if (p1.x == p2.x){  //a line parallel to y axis\\n                a = 1;\\n                b = 0;\\n                c = -1 * p1.x;\\n            }\\n            else if (p1.y == p2.y){ //a line parallel to x axis\\n                a = 0;\\n                b = 1;\\n                c = p1.y;\\n            }\\n            else{\\n                int gcd = gcd(Math.abs(p1.x-p2.x), Math.abs(p1.y-p2.y));\\n                b = (p2.x-p1.x)/gcd;\\n                a = (p2.y-p1.y)/gcd;\\n                if (a*b<0){                   //if the slope<0, always put (-) in front of a \\n                    a = -1 * Math.abs(a);\\n                    b = Math.abs(b); \\n                }\\n                else {\\n                    a = Math.abs(a);\\n                    b = Math.abs(b); \\n                }\\n                c = (float)(b*p1.y - a*p1.x)/(float)b;\\n            }\\n            return \"\"+a+\"||\"+b+\"||\"+c;     //use this presentation as a key\\n            \\n        }\\n        \\n        private int gcd(int x, int y) {\\n            if (y == 0) {\\n              return x;\\n            }\\n            return gcd(y, x % y);\\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPoints(Point[] points) {\\n            if (points.length <= 2){\\n                return points.length;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3725736,
                "title": "c-python-math-explanation-using-unordered-set-with-custom-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnly use integer computations. I reguard this question as a Diophantine problem.\\n\\nSince all points are with integer coefficients, it is very crucial how to parametize such linear equations\\n$$\\nax+by=c\\n$$\\nwhere $a, b, c \\\\in Z$ with $\\\\gcd( a, b, c)=1\\\\ &  \\\\ c>0$. \\nIf the constraint is changed, a linear equation has the following form:\\n$$\\ny=mx+c\\n$$\\nwhere $m\\\\in R\\\\cup\\\\{\\\\infty\\\\}, c\\\\in R$. note that when $m=\\\\infty$, it means $x=d$ for some $d\\\\in R$. Use this approach, there is no need for computation for gcds but using float computation.\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n![binary_line0.png](https://assets.leetcode.com/users/images/afecb0bb-e83d-41af-91e6-c8cf4cbefc64_1688826474.8209305.png)\\nSome modififications should be made! 2 different tuples $(a, b, c)$ and $(a\\', b\\', c\\')$ represent the same line and are similar $\\\\iff$\\n$$ \\\\exists d\\\\in Z \\\\ & \\\\ d\\\\not= 0 : (a, b, c)=(da\\', db\\', dc\\')\\n$$\\nOne way to find the representative for all similar tuples is to choose $(a, b, c)$ such tat $\\\\gcd(a, b,c)=1$ with the following conditions: (It should be noticed that it may happen that c=0 what is not to ignore! )\\n```\\nint d = gcd(a, b); //c is an integer linear combination of a & b therefore d|c\\na /= d, b /= d, c /= d;\\nif (c < 0) {\\n      a = -a, b = -b, c = -c;\\n}\\nelse if (c==0){ // This can occur!\\n    if (b<0 || (a<0 && b==0)) a=-a, b=-b;\\n}\\n```\\n\\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n   struct Myhash {\\n        size_t operator()(const vector<int>& vec) const {\\n            size_t digest = 0;\\n            auto f=hash<int>();\\n            for (const auto& v : vec) {\\n                digest = f(digest^v);\\n            }\\n            return digest;\\n        }\\n    };\\n    unordered_map<vector<int>, unordered_set<int>, Myhash> L;\\n\\n    void line(vector<vector<int>>& points, int i, int j) {\\n        int x0 = points[i][0], y0 = points[i][1];\\n        int x1 = points[j][0], y1 = points[j][1];\\n        int a = y1 - y0;\\n        int b = x0 - x1;\\n        int c = x0 * a + y0 * b;\\n        int d = gcd(a, b); //c is an integer linear combination of a & b therefore d|c\\n        a /= d, b /= d, c /= d;\\n        if (c < 0) {\\n            a = -a, b = -b, c = -c;\\n        }\\n        else if (c==0){ // This can occur!\\n            if (b<0 || (a<0 && b==0)) a=-a, b=-b;\\n        }\\n    //    cout<<\"(\"<<x0<<\",\"<<y0<<\"),(\"<<x1<<\",\"<<y1<<\")\\\\n\";\\n        vector<int> lineKey={a, b, c};\\n    //    cout<<lineKey<<endl;\\n        L[lineKey].insert(i);\\n        L[lineKey].insert(j);\\n    //    cout<<L[lineKey].size()<<\"\\\\n----\\\\n\";\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n==1) return 1;// edge case;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                line(points, i, j);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (auto& [_, set] : L) {\\n            int v = set.size();\\n            ans = max(ans, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n```python []\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        L = defaultdict(set)\\n        def line(points, i, j):\\n            x0, y0 = points[i]\\n            x1, y1 = points[j]\\n            a , b = y1 - y0, x0 - x1\\n            c = x0 * a + y0 * b\\n            d = gcd(gcd(a, b), c)\\n            a, b, c = a // d, b // d, c // d\\n            if c < 0:\\n                a, b, c=-a, -b, -c\\n            elif c==0:# This can occur!\\n                if b<0 or (a<0 and b==0): \\n                    a=-a \\n                    b=-b\\n            line_key = (a, b, c)\\n            L[line_key].add(i)\\n            L[line_key].add(j)\\n\\n        n = len(points)\\n        if n == 1:\\n            return 1  # edge case\\n\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                line(points, i, j)\\n\\n        max_points_on_line = 0\\n\\n        for _, point_set in L.items():\\n            max_points_on_line = max(max_points_on_line, len(point_set))\\n\\n        return max_points_on_line\\n```\\n# Code for 2nd Approach\\n```\\n//Use y=mx+c\\nclass Solution {\\npublic:\\n    struct Myhash {\\n        size_t operator()(const vector<double>& vec) const {\\n            size_t digest = 0;\\n            auto f = hash<double>();\\n            for (const auto& v : vec) {\\n                size_t v_hash = f(v);\\n                digest ^= v_hash + 0x9e3779b9 + (digest << 6) + (digest >> 2);\\n            }\\n            return digest;\\n        }\\n    };\\n    unordered_map<vector<double>, unordered_set<int>, Myhash> L;\\n\\n    void line(vector<vector<int>>& points, int i, int j) {\\n        double x0 = points[i][0], y0 = points[i][1];\\n        double x1 = points[j][0], y1 = points[j][1];\\n        double dy = y1 - y0;\\n        double dx = x1 - x0;\\n        const double inf=1.0/0;//new version C++ spports\\n        double m, c;\\n        if (dx==0){//x=d\\n            m=inf;\\n            c=x0;\\n        }\\n        else{//dx!=0\\n            m = dy/dx;\\n            c = (x0 * dy - y0 * dx)/dx;\\n        }       \\n        \\n    //    cout<<\"(\"<<x0<<\",\"<<y0<<\"),(\"<<x1<<\",\"<<y1<<\")\\\\n\";\\n        vector<double> lineKey={m, c};\\n    //    cout<<lineKey<<endl;\\n        L[lineKey].insert(i);\\n        L[lineKey].insert(j);\\n    //    cout<<L[lineKey].size()<<\"\\\\n----\\\\n\";\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n<=2) return n;// edge case;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                line(points, i, j);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (auto& [_, set] : L) {\\n            int v = set.size();\\n            ans = max(ans, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nint d = gcd(a, b); //c is an integer linear combination of a & b therefore d|c\\na /= d, b /= d, c /= d;\\nif (c < 0) {\\n      a = -a, b = -b, c = -c;\\n}\\nelse if (c==0){ // This can occur!\\n    if (b<0 || (a<0 && b==0)) a=-a, b=-b;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n   struct Myhash {\\n        size_t operator()(const vector<int>& vec) const {\\n            size_t digest = 0;\\n            auto f=hash<int>();\\n            for (const auto& v : vec) {\\n                digest = f(digest^v);\\n            }\\n            return digest;\\n        }\\n    };\\n    unordered_map<vector<int>, unordered_set<int>, Myhash> L;\\n\\n    void line(vector<vector<int>>& points, int i, int j) {\\n        int x0 = points[i][0], y0 = points[i][1];\\n        int x1 = points[j][0], y1 = points[j][1];\\n        int a = y1 - y0;\\n        int b = x0 - x1;\\n        int c = x0 * a + y0 * b;\\n        int d = gcd(a, b); //c is an integer linear combination of a & b therefore d|c\\n        a /= d, b /= d, c /= d;\\n        if (c < 0) {\\n            a = -a, b = -b, c = -c;\\n        }\\n        else if (c==0){ // This can occur!\\n            if (b<0 || (a<0 && b==0)) a=-a, b=-b;\\n        }\\n    //    cout<<\"(\"<<x0<<\",\"<<y0<<\"),(\"<<x1<<\",\"<<y1<<\")\\\\n\";\\n        vector<int> lineKey={a, b, c};\\n    //    cout<<lineKey<<endl;\\n        L[lineKey].insert(i);\\n        L[lineKey].insert(j);\\n    //    cout<<L[lineKey].size()<<\"\\\\n----\\\\n\";\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n==1) return 1;// edge case;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                line(points, i, j);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (auto& [_, set] : L) {\\n            int v = set.size();\\n            ans = max(ans, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\n```python []\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        L = defaultdict(set)\\n        def line(points, i, j):\\n            x0, y0 = points[i]\\n            x1, y1 = points[j]\\n            a , b = y1 - y0, x0 - x1\\n            c = x0 * a + y0 * b\\n            d = gcd(gcd(a, b), c)\\n            a, b, c = a // d, b // d, c // d\\n            if c < 0:\\n                a, b, c=-a, -b, -c\\n            elif c==0:# This can occur!\\n                if b<0 or (a<0 and b==0): \\n                    a=-a \\n                    b=-b\\n            line_key = (a, b, c)\\n            L[line_key].add(i)\\n            L[line_key].add(j)\\n\\n        n = len(points)\\n        if n == 1:\\n            return 1  # edge case\\n\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                line(points, i, j)\\n\\n        max_points_on_line = 0\\n\\n        for _, point_set in L.items():\\n            max_points_on_line = max(max_points_on_line, len(point_set))\\n\\n        return max_points_on_line\\n```\n```\\n//Use y=mx+c\\nclass Solution {\\npublic:\\n    struct Myhash {\\n        size_t operator()(const vector<double>& vec) const {\\n            size_t digest = 0;\\n            auto f = hash<double>();\\n            for (const auto& v : vec) {\\n                size_t v_hash = f(v);\\n                digest ^= v_hash + 0x9e3779b9 + (digest << 6) + (digest >> 2);\\n            }\\n            return digest;\\n        }\\n    };\\n    unordered_map<vector<double>, unordered_set<int>, Myhash> L;\\n\\n    void line(vector<vector<int>>& points, int i, int j) {\\n        double x0 = points[i][0], y0 = points[i][1];\\n        double x1 = points[j][0], y1 = points[j][1];\\n        double dy = y1 - y0;\\n        double dx = x1 - x0;\\n        const double inf=1.0/0;//new version C++ spports\\n        double m, c;\\n        if (dx==0){//x=d\\n            m=inf;\\n            c=x0;\\n        }\\n        else{//dx!=0\\n            m = dy/dx;\\n            c = (x0 * dy - y0 * dx)/dx;\\n        }       \\n        \\n    //    cout<<\"(\"<<x0<<\",\"<<y0<<\"),(\"<<x1<<\",\"<<y1<<\")\\\\n\";\\n        vector<double> lineKey={m, c};\\n    //    cout<<lineKey<<endl;\\n        L[lineKey].insert(i);\\n        L[lineKey].insert(j);\\n    //    cout<<L[lineKey].size()<<\"\\\\n----\\\\n\";\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if (n<=2) return n;// edge case;\\n        for (int i = 0; i < n-1; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                line(points, i, j);\\n            }\\n        }\\n\\n        int ans = 0;\\n        for (auto& [_, set] : L) {\\n            int v = set.size();\\n            ans = max(ans, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3337644,
                "title": "javascript-149-max-points-on-a-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCheck 3 points on same line\\nMake smallest of all 3, as key to count others on same line\\n\\nTests\\n```\\n[[0,0]]\\n[[4,5],[4,-1],[4,0]]\\n[[0,0],[1,-1],[1,1]]\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n[[0,1],[0,0],[0,4],[0,-2],[0,-1],[0,3],[0,-4]]\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar maxPoints = function (ps) {\\n    if (ps.length <= 2) return ps.length; // 1 length\\n\\n    const key = (x1, y1) => x1 + \",\" + y1;\\n\\n    ps.sort(([x1, y1], [x2, y2]) => x1 - x2 || y1 - y2); // we could void? for [[0,0],[5,0]] like\\n\\n    let n = ps.length;\\n    let o = {};\\n    for (let i = 0; i < n; i++) {\\n        let [x1, y1] = ps[i];\\n\\n        for (let j = i + 1; j < n; j++) {\\n            let [x2, y2] = ps[j];\\n            let sl = (y2 - y1) / (x2 - x1); // slope1\\n\\n            for (let k = j + 1; k < n; k++) {\\n                let [x3, y3] = ps[k];\\n                let sl2 = (y3 - y1) / (x3 - x1); // slope2\\n\\n                if (sl === sl2) {\\n                    if (sl === 0) {\\n                        // some padding to make key1 in o[key1] distinct\\n                        sl += \"slopeIsZero\"; // on x & y axis\\n                        if (y1 === y2 && y1 === y3) sl += y1;\\n                        if (x1 === x2 && x1 === x3) sl += x1;\\n                    }\\n                    sl += x1 + \",\" + y1;\\n\\n                    o[sl] = o[sl] || new Set();\\n                    o[sl]\\n                        .add(key(x1, y1)) //\\n                        .add(key(x2, y2))\\n                        .add(key(x3, y3));\\n                }\\n            }\\n        }\\n    }\\n\\n    let max = -Infinity;\\n    for (let k in o) {\\n        max = Math.max(max, o[k].size);\\n    }\\n    return max === -Infinity ? 2 : max; // 2 length & more\\n};\\n```\\n\\n2\\n```\\nvar maxPoints = function (ps) {\\n    function areSameLine([x1, y1], [x2, y2], [x3, y3]) {\\n        if (\\n            (x1 == x2 && x2 == x3) || //\\n            (y1 == y2 && y2 == y3)\\n        )\\n            return true;\\n\\n        if (\\n            x1 == x2 || //\\n            x2 == x3 ||\\n            y1 == y2 ||\\n            y2 == y3\\n        )\\n            return false;\\n\\n        const s1 = (y1 - y2) / (x1 - x2);\\n        const s2 = (y2 - y3) / (x2 - x3);\\n        return s1 === s2;\\n    }\\n\\n    let max = 1;\\n    for (let i = 0; i < ps.length; i++)\\n        for (let j = i + 1; j < ps.length; j++) {\\n            let count = 2;\\n            for (let k = j + 1; k < ps.length; k++)\\n                if (areSameLine(ps[i], ps[j], ps[k])) {\\n                    count++;\\n                }\\n            max = Math.max(max, count);\\n        }\\n    return max;\\n};\\n```\\n\\n3\\n```\\nvar maxPoints = function (ps) {\\n    const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\\n\\n    const getSlopeKey = ([x1, y1], [x2, y2]) => {\\n        const [dx, dy] = [x1 - x2, y1 - y2];\\n        const g = gcd(dx, dy);\\n        return `${dy / g}, ${dx / g}`;\\n    };\\n\\n    let max = 1;\\n    for (let i = 0; i < ps.length; i++) {\\n        const o = {};\\n        for (let j = i + 1; j < ps.length; j++) {\\n            const key = getSlopeKey(ps[i], ps[j]);\\n            o[key] = (o[key] || 0) + 1;\\n        }\\n        const count = Math.max(...Object.values(o)) + 1;\\n        max = Math.max(count, max);\\n    }\\n    return max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[[0,0]]\\n[[4,5],[4,-1],[4,0]]\\n[[0,0],[1,-1],[1,1]]\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n[[0,1],[0,0],[0,4],[0,-2],[0,-1],[0,3],[0,-4]]\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\n```\\nvar maxPoints = function (ps) {\\n    if (ps.length <= 2) return ps.length; // 1 length\\n\\n    const key = (x1, y1) => x1 + \",\" + y1;\\n\\n    ps.sort(([x1, y1], [x2, y2]) => x1 - x2 || y1 - y2); // we could void? for [[0,0],[5,0]] like\\n\\n    let n = ps.length;\\n    let o = {};\\n    for (let i = 0; i < n; i++) {\\n        let [x1, y1] = ps[i];\\n\\n        for (let j = i + 1; j < n; j++) {\\n            let [x2, y2] = ps[j];\\n            let sl = (y2 - y1) / (x2 - x1); // slope1\\n\\n            for (let k = j + 1; k < n; k++) {\\n                let [x3, y3] = ps[k];\\n                let sl2 = (y3 - y1) / (x3 - x1); // slope2\\n\\n                if (sl === sl2) {\\n                    if (sl === 0) {\\n                        // some padding to make key1 in o[key1] distinct\\n                        sl += \"slopeIsZero\"; // on x & y axis\\n                        if (y1 === y2 && y1 === y3) sl += y1;\\n                        if (x1 === x2 && x1 === x3) sl += x1;\\n                    }\\n                    sl += x1 + \",\" + y1;\\n\\n                    o[sl] = o[sl] || new Set();\\n                    o[sl]\\n                        .add(key(x1, y1)) //\\n                        .add(key(x2, y2))\\n                        .add(key(x3, y3));\\n                }\\n            }\\n        }\\n    }\\n\\n    let max = -Infinity;\\n    for (let k in o) {\\n        max = Math.max(max, o[k].size);\\n    }\\n    return max === -Infinity ? 2 : max; // 2 length & more\\n};\\n```\n```\\nvar maxPoints = function (ps) {\\n    function areSameLine([x1, y1], [x2, y2], [x3, y3]) {\\n        if (\\n            (x1 == x2 && x2 == x3) || //\\n            (y1 == y2 && y2 == y3)\\n        )\\n            return true;\\n\\n        if (\\n            x1 == x2 || //\\n            x2 == x3 ||\\n            y1 == y2 ||\\n            y2 == y3\\n        )\\n            return false;\\n\\n        const s1 = (y1 - y2) / (x1 - x2);\\n        const s2 = (y2 - y3) / (x2 - x3);\\n        return s1 === s2;\\n    }\\n\\n    let max = 1;\\n    for (let i = 0; i < ps.length; i++)\\n        for (let j = i + 1; j < ps.length; j++) {\\n            let count = 2;\\n            for (let k = j + 1; k < ps.length; k++)\\n                if (areSameLine(ps[i], ps[j], ps[k])) {\\n                    count++;\\n                }\\n            max = Math.max(max, count);\\n        }\\n    return max;\\n};\\n```\n```\\nvar maxPoints = function (ps) {\\n    const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\\n\\n    const getSlopeKey = ([x1, y1], [x2, y2]) => {\\n        const [dx, dy] = [x1 - x2, y1 - y2];\\n        const g = gcd(dx, dy);\\n        return `${dy / g}, ${dx / g}`;\\n    };\\n\\n    let max = 1;\\n    for (let i = 0; i < ps.length; i++) {\\n        const o = {};\\n        for (let j = i + 1; j < ps.length; j++) {\\n            const key = getSlopeKey(ps[i], ps[j]);\\n            o[key] = (o[key] || 0) + 1;\\n        }\\n        const count = Math.max(...Object.values(o)) + 1;\\n        max = Math.max(count, max);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206816,
                "title": "149-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also uses a dictionary to store the number of points that share the same slope with respect to the current point. It starts by iterating over each point in the array, and for each point, it creates a new dictionary slopes to store the number of points that share the same slope with respect to the current point, as well as a variable same to count the number of points that are the same as the current point. Then, it iterates over the remaining points, calculates the slope with respect to the current point, and updates the slopes dictionary accordingly. Finally, it computes the maximum number of points that share the same slope, adds the same variable, and compares it to the current maximum number of points max_points.\\n\\nNote that this solution also includes a special case when the remaining points have the same x-coordinate as the current point, in which case the slope is set to infinity. This is necessary to avoid a division by zero error.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n90.13%\\n\\n- Space complexity:\\nBeats\\n89.81%\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        if n < 2:\\n            return n\\n        \\n        max_points = 0\\n        for i in range(n):\\n            slopes = {}\\n            same = 1\\n            for j in range(i+1, n):\\n                if points[i][0] == points[j][0] and points[i][1] == points[j][1]:\\n                    same += 1\\n                elif points[i][0] == points[j][0]:\\n                    slope = float(\\'inf\\')\\n                    if slope in slopes:\\n                        slopes[slope] += 1\\n                    else:\\n                        slopes[slope] = 1\\n                else:\\n                    slope = (points[j][1]-points[i][1])/(points[j][0]-points[i][0])\\n                    if slope in slopes:\\n                        slopes[slope] += 1\\n                    else:\\n                        slopes[slope] = 1\\n            if not slopes:\\n                max_points = max(max_points, same)\\n            else:\\n                max_points = max(max_points, max(slopes.values())+same)\\n                \\n        return max_points\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        n = len(points)\\n        if n < 2:\\n            return n\\n        \\n        max_points = 0\\n        for i in range(n):\\n            slopes = {}\\n            same = 1\\n            for j in range(i+1, n):\\n                if points[i][0] == points[j][0] and points[i][1] == points[j][1]:\\n                    same += 1\\n                elif points[i][0] == points[j][0]:\\n                    slope = float(\\'inf\\')\\n                    if slope in slopes:\\n                        slopes[slope] += 1\\n                    else:\\n                        slopes[slope] = 1\\n                else:\\n                    slope = (points[j][1]-points[i][1])/(points[j][0]-points[i][0])\\n                    if slope in slopes:\\n                        slopes[slope] += 1\\n                    else:\\n                        slopes[slope] = 1\\n            if not slopes:\\n                max_points = max(max_points, same)\\n            else:\\n                max_points = max(max_points, max(slopes.values())+same)\\n                \\n        return max_points\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047929,
                "title": "c-java-very-intuitive-sorting-map-for-slope",
                "content": "\\uD83D\\uDE80 We just need to find a [slope](https://en.wikipedia.org/wiki/Slope) which has max number of points on it. \\n\\n\\u2714 C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        // find a slope having max number of points\\n        int ans = 1;\\n        sort(begin(points), end(points), [&] (auto x, auto y) { \\n            if(x[0] == y[0]) return x[1] < y[1];\\n            return x[0] < y[0];\\n        });\\n        for(int i = 0; i < size(points); ++i) {\\n            unordered_map<double, int> m;\\n            for(int j = i + 1; j < size(points); ++j) {\\n                double x = ((double)(points[j][1] - points[i][1]) / (points[j][0] - points[i][0]));\\n                double theta = atan(x);\\n                m[theta]++;\\n                ans = max(ans, m[theta] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\u2714 Java:\\n\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 1;\\n        Arrays.sort(points, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] x, int[] y) {\\n                if(x[0] == y[0]) return x[1] - y[1];\\n                return x[0] - y[0];\\n            }\\n        });\\n        for(int i = 0; i < points.length; ++i) {\\n            var m = new HashMap<Double, Integer>();\\n            for(int j = i + 1; j < points.length; ++j) {\\n                double x = ((double) (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]));\\n                double theta = Math.atan(x);\\n                m.put(theta, m.getOrDefault(theta, 0) + 1);\\n                ans = Math.max(ans, m.get(theta) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**TC: O(n^2), SC: O(n)**\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "Java",
                    "C",
                    "Hash Table",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        // find a slope having max number of points\\n        int ans = 1;\\n        sort(begin(points), end(points), [&] (auto x, auto y) { \\n            if(x[0] == y[0]) return x[1] < y[1];\\n            return x[0] < y[0];\\n        });\\n        for(int i = 0; i < size(points); ++i) {\\n            unordered_map<double, int> m;\\n            for(int j = i + 1; j < size(points); ++j) {\\n                double x = ((double)(points[j][1] - points[i][1]) / (points[j][0] - points[i][0]));\\n                double theta = atan(x);\\n                m[theta]++;\\n                ans = max(ans, m[theta] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 1;\\n        Arrays.sort(points, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] x, int[] y) {\\n                if(x[0] == y[0]) return x[1] - y[1];\\n                return x[0] - y[0];\\n            }\\n        });\\n        for(int i = 0; i < points.length; ++i) {\\n            var m = new HashMap<Double, Integer>();\\n            for(int j = i + 1; j < points.length; ++j) {\\n                double x = ((double) (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]));\\n                double theta = Math.atan(x);\\n                m.put(theta, m.getOrDefault(theta, 0) + 1);\\n                ans = Math.max(ans, m.get(theta) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020487,
                "title": "c-python-faster-than-97-53-commented-simple-approach",
                "content": "# Intuition\\nAs this question is based on geometry (i.e. concept of straight line). The first intuition came in my mind to find slope of each point relative to other points and count the number of point having same slope. The maximum times the given slope will appear will define the number of points lies on the same straight line.\\n\\n# Approach\\nSo, to convert the above intution into code first we need to find the slope of each point with respect to others and use **dictionary(hashmap)** to keep the count of each slope (i.e. number of points lies on same straight line). To find the slope we will be using **Two-Point form** :\\nLet there be two points [x1,y2] and [x2,y2] so to find the slope (i.e.: m) we will be using the formula:<br> \\n### **m = y2-y1 / x2-x1** \\n\\nAfter finding the slope and storing its counts in dictionary we will check which slope value occured most of the time and that will be our answer to the question.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\nint maxPoints(vector<vector<int>>& points) {\\n        int size=points.size(), count=1;\\n        for(int i=0;i<size;i++){\\n            unordered_map<double,int>um; // Cretaing HashMap\\n            double slope;\\n            for(int j=i+1;j<size;j++){\\n                if(points[j][0]-points[i][0]==0) //Checking if the slope is perpendicular or not as the x2-x1 == 0 defines slope is at 90 degree\\n                    slope=10001.00;\\n                else{\\n                    slope=double(points[j][1]-points[i][1])/double(points[j][0]-points[i][0]); // Using two-point form\\n                }\\n                um[slope]++; //  Using map to store the slope count with respect to a single point\\n            }\\n            for(auto k:um){ //Counting the maximum count of slope\\n                count=max(count,k.second+1); // Here we\\'re adding 1 to include the point points[i] itself.\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\n# Python Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        count = 1 # Store the count\\n        for i in range(0,len(points)):\\n            dict_slope = {}  # Creating a dictionary(hashmap) \\n            for j in range(i+1,len(points)):\\n                if points[j][0] - points[i][0] == 0: # Checking if the slope is perpendicular or not as the x2-x1 == 0 defines slope is at 90 degree\\n                    slope = \\'INF\\'\\n                else:\\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]) # Using two-point form\\n                if slope in dict_slope: # using map to store the slope count with respect to a single point\\n                    dict_slope[slope] += 1\\n                else:\\n                    dict_slope[slope] = 1\\n            for i in dict_slope: # Counting the maximum count of slope\\n                count = max(count,dict_slope[i]+1) # Here we\\'re adding 1 to include the point points[i] itself.\\n        return count\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxPoints(vector<vector<int>>& points) {\\n        int size=points.size(), count=1;\\n        for(int i=0;i<size;i++){\\n            unordered_map<double,int>um; // Cretaing HashMap\\n            double slope;\\n            for(int j=i+1;j<size;j++){\\n                if(points[j][0]-points[i][0]==0) //Checking if the slope is perpendicular or not as the x2-x1 == 0 defines slope is at 90 degree\\n                    slope=10001.00;\\n                else{\\n                    slope=double(points[j][1]-points[i][1])/double(points[j][0]-points[i][0]); // Using two-point form\\n                }\\n                um[slope]++; //  Using map to store the slope count with respect to a single point\\n            }\\n            for(auto k:um){ //Counting the maximum count of slope\\n                count=max(count,k.second+1); // Here we\\'re adding 1 to include the point points[i] itself.\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        count = 1 # Store the count\\n        for i in range(0,len(points)):\\n            dict_slope = {}  # Creating a dictionary(hashmap) \\n            for j in range(i+1,len(points)):\\n                if points[j][0] - points[i][0] == 0: # Checking if the slope is perpendicular or not as the x2-x1 == 0 defines slope is at 90 degree\\n                    slope = \\'INF\\'\\n                else:\\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0]) # Using two-point form\\n                if slope in dict_slope: # using map to store the slope count with respect to a single point\\n                    dict_slope[slope] += 1\\n                else:\\n                    dict_slope[slope] = 1\\n            for i in dict_slope: # Counting the maximum count of slope\\n                count = max(count,dict_slope[i]+1) # Here we\\'re adding 1 to include the point points[i] itself.\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020072,
                "title": "easy-solution-with-atan-and-hashmap-java-o-n-2",
                "content": "**Approach:**\\n* We will use the tan iinverse function to find the theta angle between all the points.\\n* For that we will run two nested loop (n^2).\\n* if (i==j) then we will continue, because it\\'ll be the same point\\n* Else we will find the value of `dy=(arr[j][1]-arr[i][1])` and `dx=(arr[j][0]-arr[i][0])`.\\n* This will give us the theta angle by atan function.\\n* Now we will put this into a map of angle to count\\n* And for each point we will find the max count of the theta angle and store res as max angle.\\n\\n**TC:** O(n^2)\\n**SC:** O(n)\\n\\n\\n**PLEASE UPVOTE !!**\\n\\n```\\nclass Solution {\\n    public int maxPoints(int[][] arr) {\\n        int n=arr.length;\\n        if(n==1)\\n            return n; // if there is only one point\\n        int res=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            HashMap<Double,Integer> uwu=new HashMap<>(); //to store angle to its count\\n            int max=0; // max angle of the point\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j) // if the point is same we will continue\\n                    continue;\\n                double dy=(double)(arr[j][1]-arr[i][1]);\\n                double dx=(double)(arr[j][0]-arr[i][0]);\\n                double theta=Math.atan(dy/dx); //theta angle by atan function\\n                uwu.put(theta,uwu.getOrDefault(theta,0)+1); //store the count\\n                max=Math.max(max,uwu.getOrDefault(theta,0)); //also keep checking the max angle\\n            }\\n            res=Math.max(res,max+1); //for res count max+1 (+1 because we were not counting the angle at ith index in the loop)\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] arr) {\\n        int n=arr.length;\\n        if(n==1)\\n            return n; // if there is only one point\\n        int res=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            HashMap<Double,Integer> uwu=new HashMap<>(); //to store angle to its count\\n            int max=0; // max angle of the point\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j) // if the point is same we will continue\\n                    continue;\\n                double dy=(double)(arr[j][1]-arr[i][1]);\\n                double dx=(double)(arr[j][0]-arr[i][0]);\\n                double theta=Math.atan(dy/dx); //theta angle by atan function\\n                uwu.put(theta,uwu.getOrDefault(theta,0)+1); //store the count\\n                max=Math.max(max,uwu.getOrDefault(theta,0)); //also keep checking the max angle\\n            }\\n            res=Math.max(res,max+1); //for res count max+1 (+1 because we were not counting the angle at ith index in the loop)\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018430,
                "title": "a-fast-and-simple-approach-using-a-hashmap",
                "content": "# Intuition\\nThe main idea behind this solution is to use the slope between each pair of points as a way to determine whether the points are on the same line. To do this, the code first iterates through each point and considers it as a starting point for a line. Then, for each starting point, the code looks at all of the other points and calculates the slope between the starting point and each of the other points. If the slope is the same for any two points, it means that they are on the same line.\\n\\nThe code uses a HashMap to store the number of points that have the same slope with respect to the starting point. The key of the HashMap is the slope value, and the value is the number of points with that slope. By storing the slopes and their frequencies in this way, the code can easily keep track of the maximum number of points on the same line for each starting point.\\n\\nFinally, the code returns the maximum number of points on the same line among all of the starting points. This gives us the overall maximum number of points on the same line for the entire set of points.\\n\\n# Approach\\n1. Initialize a variable ans to 1. This variable will be used to store the maximum number of points on the same line.\\n2. Check if the number of points is less than or equal to 2. If it is, return the number of points. This is because it is not possible to have more than 2 points on the same line if there are 2 or fewer points in total.\\n3. Iterate through each point in the points array. For each point, do the following:\\n4.  Initialize a HashMap to store the slopes and their frequencies\\n5. Consider the current point as the starting point for a line\\n6. Iterate through the other points in the array and calculate the slope between the starting point and each other point.\\n7. If the slope is the same for any two points, it means that they are on the same line. So, store the slope in the HashMap and increment the frequency count for that slope.\\n8. If the x-coordinates of the two points are the same, then the slope is infinity. In this case, store the slope as -90 in the HashMap.\\n9. If the y-coordinates of the two points are the same, then the slope is 0. In this case, store the slope as 0 in the HashMap. **This special case is needed because Java treats 0.0 and -0.0 as unequal.(This had me frustrated.)**\\n10. After iterating through all of the other points, find the maximum frequency count in the HashMap. This gives the maximum number of points on the same line for the current starting point.\\n11. Update the ans variable with the maximum number of points on the same line for the current starting point.\\n12. Repeat steps 3-11 for each point in the points array.\\n13. Return the ans variable as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), because the code performs a nested loop over all pairs of points. The inner loop processes each point and calculates the slope with respect to the current starting point, which takes O(1) time. The outer loop iterates over all points, so the total time complexity is **O(n * O(1)) = O(n)**.\\n\\n- Space complexity:\\nThe space complexity of this solution is **O(n)**, because the size of the HashMap used to store the slopes and their frequencies is proportional to the number of points.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 1;\\n        int n = points.length;\\n        if(n <= 2){\\n            return n;\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n            HashMap<Double, Integer> map = new HashMap<>();\\n            for(int j = i + 1; j < n; j++){\\n                if(points[j][0] == points[i][0]){\\n                    map.put(-90.0, map.getOrDefault(-90.0, 0) + 1);\\n                }else if(points[j][1] == points[i][1]){\\n                    map.put(0.0, map.getOrDefault(0.0, 0) + 1);\\n                }\\n                else{\\n                    double slope = ((double)(points[j][1] - points[i][1]))/((double)(points[j][0] - points[i][0]));\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                }\\n            }\\n            int temp_max = 0;\\n            for(Map.Entry<Double, Integer> slope : map.entrySet()){\\n                temp_max =  Math.max(temp_max, slope.getValue() + 1);\\n               \\n            }\\n            ans = Math.max(ans, temp_max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int ans = 1;\\n        int n = points.length;\\n        if(n <= 2){\\n            return n;\\n        }\\n        for(int i = 0; i < n - 1; i++){\\n            HashMap<Double, Integer> map = new HashMap<>();\\n            for(int j = i + 1; j < n; j++){\\n                if(points[j][0] == points[i][0]){\\n                    map.put(-90.0, map.getOrDefault(-90.0, 0) + 1);\\n                }else if(points[j][1] == points[i][1]){\\n                    map.put(0.0, map.getOrDefault(0.0, 0) + 1);\\n                }\\n                else{\\n                    double slope = ((double)(points[j][1] - points[i][1]))/((double)(points[j][0] - points[i][0]));\\n                    map.put(slope, map.getOrDefault(slope, 0) + 1);\\n                }\\n            }\\n            int temp_max = 0;\\n            for(Map.Entry<Double, Integer> slope : map.entrySet()){\\n                temp_max =  Math.max(temp_max, slope.getValue() + 1);\\n               \\n            }\\n            ans = Math.max(ans, temp_max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018339,
                "title": "a-different-solution-with-x-and-y-intercepts",
                "content": "![image](https://assets.leetcode.com/users/images/5c8bd0af-fe2e-493a-af5f-0038cab30b6c_1673165422.149452.png)\\n\\n**Intuition**: Two lines can have same slopes. To determin if given points can be projected on same line we need **2 points on the line** or **1 point and slope**. Given solution contains 2 points on the line approach. We\\'re using X and Y intercepts to represent the line.\\n\\n**Edge case:**  [[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]].\\n\\n```\\nclass Solution {\\n    public int infinity = Integer.MAX_VALUE;\\n    public double[] getXandYintercept(int P[],\\n                                  int Q[])\\n    {\\n        int a = P[1] - Q[1];\\n        int b = P[0] - Q[0];\\n        double[] intercepts = new double[2];\\n        // if line is parallel to y axis\\n        if (b == 0) {\\n            intercepts[0] = P[0];\\n            intercepts[1] = infinity;\\n            return intercepts;\\n        }\\n \\n        // if line is parallel to x axis\\n        if (a == 0) {\\n            intercepts[0] = infinity;\\n            intercepts[1] = P[1];\\n            return intercepts;\\n        }\\n        \\n        double m = a / (b * 1.0);\\n        int x = P[0];\\n        int y = P[1];\\n        double c = y - m * x;\\n        y = 0;\\n        double r = (y - c) / (m * 1.0);\\n        x = 0;\\n        y = (int)(m * x + c);\\n        intercepts[0] = r;\\n        intercepts[1] = c;\\n        return intercepts;\\n    }\\n    \\n    public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        int m = 2;\\n        double[][][] intercepts = new double[n][n][2];\\n        if(n == 1) return 1;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                intercepts[i][j] = getXandYintercept(points[i], points[j]);\\n                intercepts[j][i] = intercepts[i][j];\\n            }    \\n            intercepts[i][i] = new double[]{infinity, infinity};\\n        }\\n        int ans = 0;\\n        boolean containsOrigin = false;\\n        String origin = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(points[i][0] == 0 && points[i][1] == 0){\\n                origin = (double) 0 + \" \" + (double) 0;\\n                containsOrigin = true;\\n                continue;\\n            } \\n            HashMap<String, Integer> set =  new HashMap<>();\\n            int cnt = 1;\\n            for(int j = i + 1; j < n; j++){\\n                double xint = intercepts[j][i][0];\\n                double yint = intercepts[i][j][1];\\n                String pair = xint + \" \"  + yint;\\n                int pairCnt = set.getOrDefault(pair, 0) + 1;\\n                cnt = Math.max(cnt, pairCnt);\\n                set.put(pair, pairCnt);\\n            }\\n            if(containsOrigin){\\n                String pair = origin;\\n                int pairCnt = set.getOrDefault(pair, 0) + 1;\\n                cnt = Math.max(cnt, pairCnt);  \\n            }\\n            ans = Math.max(ans, cnt + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int infinity = Integer.MAX_VALUE;\\n    public double[] getXandYintercept(int P[],\\n                                  int Q[])\\n    {\\n        int a = P[1] - Q[1];\\n        int b = P[0] - Q[0];\\n        double[] intercepts = new double[2];\\n        // if line is parallel to y axis\\n        if (b == 0) {\\n            intercepts[0] = P[0];\\n            intercepts[1] = infinity;\\n            return intercepts;\\n        }\\n \\n        // if line is parallel to x axis\\n        if (a == 0) {\\n            intercepts[0] = infinity;\\n            intercepts[1] = P[1];\\n            return intercepts;\\n        }\\n        \\n        double m = a / (b * 1.0);\\n        int x = P[0];\\n        int y = P[1];\\n        double c = y - m * x;\\n        y = 0;\\n        double r = (y - c) / (m * 1.0);\\n        x = 0;\\n        y = (int)(m * x + c);\\n        intercepts[0] = r;\\n        intercepts[1] = c;\\n        return intercepts;\\n    }\\n    \\n    public int maxPoints(int[][] points) {\\n        int n = points.length;\\n        int m = 2;\\n        double[][][] intercepts = new double[n][n][2];\\n        if(n == 1) return 1;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                intercepts[i][j] = getXandYintercept(points[i], points[j]);\\n                intercepts[j][i] = intercepts[i][j];\\n            }    \\n            intercepts[i][i] = new double[]{infinity, infinity};\\n        }\\n        int ans = 0;\\n        boolean containsOrigin = false;\\n        String origin = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(points[i][0] == 0 && points[i][1] == 0){\\n                origin = (double) 0 + \" \" + (double) 0;\\n                containsOrigin = true;\\n                continue;\\n            } \\n            HashMap<String, Integer> set =  new HashMap<>();\\n            int cnt = 1;\\n            for(int j = i + 1; j < n; j++){\\n                double xint = intercepts[j][i][0];\\n                double yint = intercepts[i][j][1];\\n                String pair = xint + \" \"  + yint;\\n                int pairCnt = set.getOrDefault(pair, 0) + 1;\\n                cnt = Math.max(cnt, pairCnt);\\n                set.put(pair, pairCnt);\\n            }\\n            if(containsOrigin){\\n                String pair = origin;\\n                int pairCnt = set.getOrDefault(pair, 0) + 1;\\n                cnt = Math.max(cnt, pairCnt);  \\n            }\\n            ans = Math.max(ans, cnt + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017952,
                "title": "c-98-32-faster-easy-detailed-solution",
                "content": "\\n# Explanation:\\n    \\n###### I have used double loop to check the maximum possible count of any slope with all combination of <B>i</B>th point.\\n- Return `size` if the vector\\'s size is `less than` 3, i.e. 1 point will contain itself with a line & 2 points will make a line with their own pair.\\n- I\\'ve initialized a map `mp` inside the first loop, and it has a count of every slope that might possibly have an `i`th point and also handles the `self` point and `infinite slope` separately.\\n- After ending inside loop I have updated my final answer with `mx+self` points\\n- returned `ans`\\n\\n\\n#### Go through code once you will understand completely\\uD83D\\uDC47\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n =points.size();\\n        if(n<3)\\n        return n;\\n\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            int self = 1;\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0] == points[j][0] && points[j][1] == points[i][1])\\n                self++;\\n                else if(points[i][0] == points[j][0])\\n                mp[INT_MAX]++;\\n                else{\\n                    double slope = double(points[i][1]-points[j][1])/double(points[i][0]-points[j][0]);\\n                    mp[slope]++;\\n                }\\n            }\\n            int mx = 0;\\n            for(auto ele : mp){\\n                mx = max(mx,ele.second);\\n            }\\n            ans = max(ans,mx+self);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please upvote if you find this solution helpful\\uD83D\\uDE4F\\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n =points.size();\\n        if(n<3)\\n        return n;\\n\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            int self = 1;\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0] == points[j][0] && points[j][1] == points[i][1])\\n                self++;\\n                else if(points[i][0] == points[j][0])\\n                mp[INT_MAX]++;\\n                else{\\n                    double slope = double(points[i][1]-points[j][1])/double(points[i][0]-points[j][0]);\\n                    mp[slope]++;\\n                }\\n            }\\n            int mx = 0;\\n            for(auto ele : mp){\\n                mx = max(mx,ele.second);\\n            }\\n            ans = max(ans,mx+self);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017843,
                "title": "simple-hashmap-geometry-95-beats-in-time",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        int ans = 0;\\n        unordered_map<float, int>mp;\\n        \\n        for(int i = 0 ; i < points.size(); i++)\\n        {\\n              for(int j = i+1 ; j < points.size(); j++)\\n              {\\n                  float y2 = points[j][1], y1 = points[i][1];\\n                  float x2 = points[j][0], x1 = points[i][0];\\n                  float slope = (y2-y1)/(x2-x1);\\n                    if( (y2-y1) < 0 && (x2-x1) == 0) //infinite slope\\n                         mp[abs(slope)]++;\\n                    else\\n                        mp[slope]++;\\n              }\\n            for(auto e : mp)\\n            {\\n               int temp = e.second;\\n               ans = max(ans, temp);\\n            }\\n        mp.clear();\\n        }\\n           \\n        return ans+1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        int ans = 0;\\n        unordered_map<float, int>mp;\\n        \\n        for(int i = 0 ; i < points.size(); i++)\\n        {\\n              for(int j = i+1 ; j < points.size(); j++)\\n              {\\n                  float y2 = points[j][1], y1 = points[i][1];\\n                  float x2 = points[j][0], x1 = points[i][0];\\n                  float slope = (y2-y1)/(x2-x1);\\n                    if( (y2-y1) < 0 && (x2-x1) == 0) //infinite slope\\n                         mp[abs(slope)]++;\\n                    else\\n                        mp[slope]++;\\n              }\\n            for(auto e : mp)\\n            {\\n               int temp = e.second;\\n               ans = max(ans, temp);\\n            }\\n        mp.clear();\\n        }\\n           \\n        return ans+1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017194,
                "title": "python-using-slope-90-runtime",
                "content": "# Intuition\\nWe loop over every point and find its slope with other points and put those slope in a hashmap\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n\\n        if len(points) == 1:\\n            return 1\\n\\n        res = 2\\n\\n        for i in range(len(points)):\\n            dic = defaultdict(int)\\n\\n            for j in range(i+1,len(points)):\\n\\n                    if points[j][0] - points[i] [0] == 0:\\n                        dic[float(\\'inf\\')] += 1\\n                    else:\\n                        dic[((points[j][1]- points[i][1])/ (points[j][0]-points[i][0]))] += 1\\n            if dic.values():\\n             res = max(res, max(dic.values())+1)\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n\\n        if len(points) == 1:\\n            return 1\\n\\n        res = 2\\n\\n        for i in range(len(points)):\\n            dic = defaultdict(int)\\n\\n            for j in range(i+1,len(points)):\\n\\n                    if points[j][0] - points[i] [0] == 0:\\n                        dic[float(\\'inf\\')] += 1\\n                    else:\\n                        dic[((points[j][1]- points[i][1])/ (points[j][0]-points[i][0]))] += 1\\n            if dic.values():\\n             res = max(res, max(dic.values())+1)\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017084,
                "title": "very-easy-intuitive-js-solution-98-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nComing back to basic concept of points lying on a line. Two points lie on same line if and only if their slope is equal to the slope of line. So get the slopes of all pairs of points.\\n> ***Slope Formula :*** ( y2 - y1 ) / ( x2 - x1 )\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initially the maximum points lying on a line will be 1 ( the point itself ). \\n- Another point to notice is that if the denominator of the fraction becomes 0 ( i.e points having same x coordinates ), then the slope becomes infinity. So we handle this situation separately. Else just calculate the slope and insert into the map.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\n// author : Sourav Kumar Dubey\\n// My 1st submission in JavaScript! Enjoyed it!!!!\\nvar maxPoints = function(points) {\\n    \\n    let maxi = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        \\n        const mp = new Map();\\n        const [x1, y1] = points[i]; // ... JS spread operator\\n        let currMax = 1, slope = 0;\\n\\n        for (let j = i + 1; j < points.length; j++) { \\n            \\n            const [x2, y2] = points[j];\\n            \\n            if (x1 === x2) slope = Number.MAX_VALUE; // if the denominator is 0, then the slope will become infinity\\n            else slope = (y2 - y1) / (x2 - x1);\\n            \\n            if (!mp.has(slope)) mp.set(slope, 2); // 2 coz we have got the new slope using 2 points.\\n            else mp.set(slope, mp.get(slope) + 1); // if slope already exits then just increment the number of frequencies\\n            \\n            currMax = Math.max(currMax, mp.get(slope));\\n\\n        }\\n        \\n        maxi = Math.max(maxi, currMax);\\n        \\n    }\\n\\n    return maxi;\\n\\n};\\n    \\n    \\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\n// author : Sourav Kumar Dubey\\n// My 1st submission in JavaScript! Enjoyed it!!!!\\nvar maxPoints = function(points) {\\n    \\n    let maxi = 0;\\n    \\n    for (let i = 0; i < points.length; i++) {\\n        \\n        const mp = new Map();\\n        const [x1, y1] = points[i]; // ... JS spread operator\\n        let currMax = 1, slope = 0;\\n\\n        for (let j = i + 1; j < points.length; j++) { \\n            \\n            const [x2, y2] = points[j];\\n            \\n            if (x1 === x2) slope = Number.MAX_VALUE; // if the denominator is 0, then the slope will become infinity\\n            else slope = (y2 - y1) / (x2 - x1);\\n            \\n            if (!mp.has(slope)) mp.set(slope, 2); // 2 coz we have got the new slope using 2 points.\\n            else mp.set(slope, mp.get(slope) + 1); // if slope already exits then just increment the number of frequencies\\n            \\n            currMax = Math.max(currMax, mp.get(slope));\\n\\n        }\\n        \\n        maxi = Math.max(maxi, currMax);\\n        \\n    }\\n\\n    return maxi;\\n\\n};\\n    \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016973,
                "title": "c-solution",
                "content": "C++ code:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi = 0;\\n        for (const auto& x : points) {\\n            unordered_map<double, int> slopes;\\n            for (const auto& y : points) {\\n            if (x == y) continue;\\n            double slope = numeric_limits<double>::infinity();\\n            if (y[0] - x[0] != 0) {\\n                slope = (double) (y[1] - x[1]) / (y[0] - x[0]);\\n            }\\n\\n            if (slopes.count(slope)) {\\n                slopes[slope]++;\\n            } else {\\n                slopes[slope] = 1;\\n            }\\n            maxi = std::max(maxi, slopes[slope]);\\n            }\\n        }\\n        return maxi + 1;\\n    }\\n};\\n```\\n\\n\\n*Upvote if helped*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi = 0;\\n        for (const auto& x : points) {\\n            unordered_map<double, int> slopes;\\n            for (const auto& y : points) {\\n            if (x == y) continue;\\n            double slope = numeric_limits<double>::infinity();\\n            if (y[0] - x[0] != 0) {\\n                slope = (double) (y[1] - x[1]) / (y[0] - x[0]);\\n            }\\n\\n            if (slopes.count(slope)) {\\n                slopes[slope]++;\\n            } else {\\n                slopes[slope] = 1;\\n            }\\n            maxi = std::max(maxi, slopes[slope]);\\n            }\\n        }\\n        return maxi + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016637,
                "title": "equation-of-line-in-2-point-form-o-n-2-simple-and-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn first glance, while looking at the constraints, I concluded that nlogn comparisons for each point is possible. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### Two Point Form: Formula\\n\\n    y\\u2212y1 =y2-y1/x2-x1(x\\u2212x1)\\nwhere,\\n(x, y) is an arbitrary point on the line.\\n(x1, y1) and (x2, y2) are coordinates of points lying on the line.\\nand y2-y1/x2-x1 is the slope of the line. \\n\\nUsing this I stored all the points having the same slope in a map. \\nHere it is important to consider the case where the denominator is 0. In that case the slope is undefined. I set the slope to 10 for that case. \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nlogn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1;\\n        int ans = 0;\\n        for(int i =1;i<points.size();++i){\\n            map<float,set<pair<int,int>>> m;\\n            for(int j =0;j<i;++j){\\n                float x1 = points[i][0];\\n                float y1 = points[i][1];\\n                float x2 = points[j][0];\\n                float y2 = points[j][1];\\n                float slope;\\n                if(x2-x1==0){\\n                    slope = 10;\\n                }else slope  = (y2-y1)/(x2-x1);\\n                m[slope].insert({x1,y1});\\n                m[slope].insert({x2,y2});\\n                // cout << \"slope : \" << slope << \" \" << x1 << \" \" << y1 << \" \"<< x2 << \" \" << y2 <<endl; \\n            }\\n            for(auto p : m){\\n            // cout << \"slope is : \" << p.first <<endl;\\n            //for(auto elem : p.second){\\n            //    cout << elem.first << \" \"<< elem.second << endl;\\n            //}\\n            //cout << endl;\\n           int val = p.second.size();\\n        //    if(p.first==10)continue;\\n           ans = max(ans,val);\\n        }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1;\\n        int ans = 0;\\n        for(int i =1;i<points.size();++i){\\n            map<float,set<pair<int,int>>> m;\\n            for(int j =0;j<i;++j){\\n                float x1 = points[i][0];\\n                float y1 = points[i][1];\\n                float x2 = points[j][0];\\n                float y2 = points[j][1];\\n                float slope;\\n                if(x2-x1==0){\\n                    slope = 10;\\n                }else slope  = (y2-y1)/(x2-x1);\\n                m[slope].insert({x1,y1});\\n                m[slope].insert({x2,y2});\\n                // cout << \"slope : \" << slope << \" \" << x1 << \" \" << y1 << \" \"<< x2 << \" \" << y2 <<endl; \\n            }\\n            for(auto p : m){\\n            // cout << \"slope is : \" << p.first <<endl;\\n            //for(auto elem : p.second){\\n            //    cout << elem.first << \" \"<< elem.second << endl;\\n            //}\\n            //cout << endl;\\n           int val = p.second.size();\\n        //    if(p.first==10)continue;\\n           ans = max(ans,val);\\n        }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2507803,
                "title": "c-math-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end());\\n        int n = points.size(), cnt = 0;\\n        for(int i=0; i<n; ++i){\\n            unordered_map<double, int> mp;\\n            int yAxis = 0;\\n            for(int j=i+1; j<n; ++j){\\n                int dy = points[j][1] - points[i][1];\\n                int dx = points[j][0] - points[i][0];\\n                if(dx==0){\\n                    yAxis++;\\n                }else{\\n                    double slope = (double)dy/dx;\\n                    mp[slope]++;\\n                }\\n            }\\n            for(auto &m : mp){\\n                cnt = max(cnt, m.second);\\n            }\\n            cnt = max(cnt, yAxis);\\n        }\\n        return cnt+1;\\n    }\\n\\t\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end());\\n        int n = points.size(), cnt = 0;\\n        for(int i=0; i<n; ++i){\\n            unordered_map<double, int> mp;\\n            int yAxis = 0;\\n            for(int j=i+1; j<n; ++j){\\n                int dy = points[j][1] - points[i][1];\\n                int dx = points[j][0] - points[i][0];\\n                if(dx==0){\\n                    yAxis++;\\n                }else{\\n                    double slope = (double)dy/dx;\\n                    mp[slope]++;\\n                }\\n            }\\n            for(auto &m : mp){\\n                cnt = max(cnt, m.second);\\n            }\\n            cnt = max(cnt, yAxis);\\n        }\\n        return cnt+1;\\n    }\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297988,
                "title": "line-equation-y-mx-c-n-n-1-2-pairs-maths",
                "content": "This is pretty standard lines and points problem.\\n1. If there are two points (x1, y1) and (x2, y2), equation is `y = mx + c`. M is slope and c is constant, telling you how much offset it is from base.\\n2. `m = dy / dx` where `dy = y2 - y1` and `dx = x2 - x1`. When dx is zero, it is vertical line. So, handle vertical lines seperately \\n3. Using 2 points, create an equation, as we have `m` calculated using above formula, we can derive `c` using any one point\\'s value.\\n4. Make sure to truncate `m` and `c` to upto 4 or 5 floating points to have same equation.\\n5. Make a dictionary of all equations \\n6. Final max frequency of any equation is `number of pairs` formed by `n` number of points.\\n7. For e.g., 2 points => 2 pairs, 3 points => 4 pairs, 4 points => 6 pairs. `n x (n - 1) / 2 => pairs` \\n8. To get `n`, either solve it or use brute force approach using loop from 1 to 300\\n\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\nvar maxPoints = function(points) {\\n    if (points.length === 1) {\\n        return 1;\\n    }\\n    \\n    const slopes = {};\\n    let dx, dy;\\n    let xbase, ybase;\\n    let xref, yref, key;\\n    const INFINITE_SLOPE = \\'infinite\\';\\n    \\n    for(let i = 0; i < points.length; i++) {\\n        [xbase, ybase] = points[i];\\n        \\n        for(let j = i + 1; j < points.length; j++) {                       \\n            \\n            [xref, yref] = points[j];\\n            \\n            if (xref === xbase) {\\n                key = `x = ${xref}`;\\n                \\n            } else {\\n                dx = xref - xbase;\\n                dy = yref - ybase;\\n                \\n                let m = dy / dx;\\n                let c = yref - m * xref;\\n                \\n                m = m.toFixed(4);\\n                c = c.toFixed(4);\\n                \\n                key = `y = ${m}x + ${c}`;                \\n            }\\n            \\n            slopes[key] || (slopes[key] = 0);\\n            slopes[key]++;\\n        }\\n    }\\n    \\n    const maxPairs = Math.max(...Object.values(slopes));\\n    \\n    if (maxPairs === 2) {\\n        return 2;\\n    }\\n    \\n    for(let i = 1; i <= 300; i++) {\\n        if (i * (i - 1) / 2 === maxPairs) {\\n            return i;\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\nvar maxPoints = function(points) {\\n    if (points.length === 1) {\\n        return 1;\\n    }\\n    \\n    const slopes = {};\\n    let dx, dy;\\n    let xbase, ybase;\\n    let xref, yref, key;\\n    const INFINITE_SLOPE = \\'infinite\\';\\n    \\n    for(let i = 0; i < points.length; i++) {\\n        [xbase, ybase] = points[i];\\n        \\n        for(let j = i + 1; j < points.length; j++) {                       \\n            \\n            [xref, yref] = points[j];\\n            \\n            if (xref === xbase) {\\n                key = `x = ${xref}`;\\n                \\n            } else {\\n                dx = xref - xbase;\\n                dy = yref - ybase;\\n                \\n                let m = dy / dx;\\n                let c = yref - m * xref;\\n                \\n                m = m.toFixed(4);\\n                c = c.toFixed(4);\\n                \\n                key = `y = ${m}x + ${c}`;                \\n            }\\n            \\n            slopes[key] || (slopes[key] = 0);\\n            slopes[key]++;\\n        }\\n    }\\n    \\n    const maxPairs = Math.max(...Object.values(slopes));\\n    \\n    if (maxPairs === 2) {\\n        return 2;\\n    }\\n    \\n    for(let i = 1; i <= 300; i++) {\\n        if (i * (i - 1) / 2 === maxPairs) {\\n            return i;\\n        }\\n    }\\n    \\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1572659,
                "title": "easy-java-5ms-faster-than-94",
                "content": "\\n```\\n // Time: O(N^2) \\n // Use a map to store <slope, points for lines with same slope>\\n // HashMap<Double, Set<Integer>> countSlopes ; \\n // Set<Integer> should store indices of the points (multiple indices with same coorsinates)\\n \\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length == 1)\\n            return 1;\\n        \\n        HashMap<Double, HashSet<Integer>> countSlopes = new HashMap<Double, HashSet<Integer>>();\\n        int maxpoints = 0;\\n        for(int i = 0; i < points.length;i++)\\n        {\\n            countSlopes.clear();\\n            \\n            for(int j =  i+1; j < points.length; j++)\\n            {\\n                double slope = getSlope(points[i],points[j]);\\n                HashSet<Integer> pointSet = countSlopes.getOrDefault(slope, new HashSet<Integer>());\\n                pointSet.add(i);\\n                pointSet.add(j);\\n                countSlopes.put(slope,pointSet);\\n                maxpoints = Math.max(maxpoints, pointSet.size());\\n            }\\n        }\\n        \\n        return maxpoints;\\n    }\\n    \\n\\t// Y= m*X + C. return m.\\n    public double getSlope(int[] pointA, int[] pointB)\\n    {\\n        int Y = pointA[1]-pointB[1];\\n        int X = pointA[0]- pointB[0];\\n        \\n        return X == 0 ? Double.MIN_VALUE : (double)(Y)/(double)X + 0.0; // +0.0 to get rid of -0.0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n // Time: O(N^2) \\n // Use a map to store <slope, points for lines with same slope>\\n // HashMap<Double, Set<Integer>> countSlopes ; \\n // Set<Integer> should store indices of the points (multiple indices with same coorsinates)\\n \\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length == 1)\\n            return 1;\\n        \\n        HashMap<Double, HashSet<Integer>> countSlopes = new HashMap<Double, HashSet<Integer>>();\\n        int maxpoints = 0;\\n        for(int i = 0; i < points.length;i++)\\n        {\\n            countSlopes.clear();\\n            \\n            for(int j =  i+1; j < points.length; j++)\\n            {\\n                double slope = getSlope(points[i],points[j]);\\n                HashSet<Integer> pointSet = countSlopes.getOrDefault(slope, new HashSet<Integer>());\\n                pointSet.add(i);\\n                pointSet.add(j);\\n                countSlopes.put(slope,pointSet);\\n                maxpoints = Math.max(maxpoints, pointSet.size());\\n            }\\n        }\\n        \\n        return maxpoints;\\n    }\\n    \\n\\t// Y= m*X + C. return m.\\n    public double getSlope(int[] pointA, int[] pointB)\\n    {\\n        int Y = pointA[1]-pointB[1];\\n        int X = pointA[0]- pointB[0];\\n        \\n        return X == 0 ? Double.MIN_VALUE : (double)(Y)/(double)X + 0.0; // +0.0 to get rid of -0.0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532303,
                "title": "java-simple-and-clean-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n      \\n        int maxPoints = -1;\\n        \\n        for(int i = 0; i < points.length; i++)\\n        {\\n            Map<Double, Integer> map = new HashMap<>();\\n            int sameX = 1, samePoints = 0;\\n            \\n            for(int j = 0; j < points.length; j++)\\n            {\\n                if(i == j) continue;\\n\\n                int x1 = points[i][0], y1 = points[i][1];\\n                int x2 = points[j][0], y2 = points[j][1];\\n\\n                if(x1 == x2 && y1 == y2) samePoints++;\\n                \\n                if(x1 == x2) \\n                {\\n                    sameX++; \\n                    continue;\\n                }\\n                \\n                double slope = (double) (y2 - y1) / (double) (x2 - x1);\\n                \\n                if(map.containsKey(slope))\\n                {\\n                    map.put(slope,map.get(slope) + 1);\\n                }\\n                else\\n                {\\n                    map.put(slope, 2);\\n                }\\n                \\n                maxPoints = Math.max(maxPoints, map.get(slope) + samePoints);\\n            }\\n            \\n            maxPoints = Math.max(maxPoints, sameX);\\n        }\\n        \\n        \\n        return maxPoints;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n      \\n        int maxPoints = -1;\\n        \\n        for(int i = 0; i < points.length; i++)\\n        {\\n            Map<Double, Integer> map = new HashMap<>();\\n            int sameX = 1, samePoints = 0;\\n            \\n            for(int j = 0; j < points.length; j++)\\n            {\\n                if(i == j) continue;\\n\\n                int x1 = points[i][0], y1 = points[i][1];\\n                int x2 = points[j][0], y2 = points[j][1];\\n\\n                if(x1 == x2 && y1 == y2) samePoints++;\\n                \\n                if(x1 == x2) \\n                {\\n                    sameX++; \\n                    continue;\\n                }\\n                \\n                double slope = (double) (y2 - y1) / (double) (x2 - x1);\\n                \\n                if(map.containsKey(slope))\\n                {\\n                    map.put(slope,map.get(slope) + 1);\\n                }\\n                else\\n                {\\n                    map.put(slope, 2);\\n                }\\n                \\n                maxPoints = Math.max(maxPoints, map.get(slope) + samePoints);\\n            }\\n            \\n            maxPoints = Math.max(maxPoints, sameX);\\n        }\\n        \\n        \\n        return maxPoints;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612420,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if (points.size()<=2){\\n            return points.size();\\n        }\\n        int overlap = 0, result = 0, cur = 0;\\n        int x, y, gcd;\\n        map<int, map<int, int>> freq;\\n        for (int i=0; i<points.size()-1; i++){\\n            overlap = 0; cur = 0; freq.clear();\\n            for (int j=i+1; j<points.size(); j++){\\n                x = points[j][0] - points[i][0];\\n                y = points[j][1] - points[i][1];\\n                if (x==0 && y==0){\\n                    overlap++; continue;\\n                }\\n                gcd = generateGCD(x, y);\\n                if (gcd != 0){\\n                    x /= gcd; y /= gcd;\\n                }\\n                freq[x][y]++;\\n                cur = max(cur, freq[x][y]);\\n            }\\n            result = max(result, cur + overlap + 1);\\n        }\\n        return result;\\n    }\\n    \\n    int generateGCD(int a, int b) {\\n        if (b == 0) return a;\\n        \\n        return generateGCD(b, a % b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if (points.size()<=2){\\n            return points.size();\\n        }\\n        int overlap = 0, result = 0, cur = 0;\\n        int x, y, gcd;\\n        map<int, map<int, int>> freq;\\n        for (int i=0; i<points.size()-1; i++){\\n            overlap = 0; cur = 0; freq.clear();\\n            for (int j=i+1; j<points.size(); j++){\\n                x = points[j][0] - points[i][0];\\n                y = points[j][1] - points[i][1];\\n                if (x==0 && y==0){\\n                    overlap++; continue;\\n                }\\n                gcd = generateGCD(x, y);\\n                if (gcd != 0){\\n                    x /= gcd; y /= gcd;\\n                }\\n                freq[x][y]++;\\n                cur = max(cur, freq[x][y]);\\n            }\\n            result = max(result, cur + overlap + 1);\\n        }\\n        return result;\\n    }\\n    \\n    int generateGCD(int a, int b) {\\n        if (b == 0) return a;\\n        \\n        return generateGCD(b, a % b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412945,
                "title": "python3-with-explanation",
                "content": "```\\nimport collections\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # Question stem: we need to find all lines and return the maximum count of points in a line\\n        # Idea: Use a dictionary to store \\'slope\\' and \\'count\\'. \\n\\t\\t# We need to traverse all points and each time we will calculate the slope between two points \\n\\t\\t# and store it in string type (That\\'s why we need to calculate GCD. We need to simplify the fraction)\\n        \\n        if len(points) <= 2:\\n            return len(points)\\n\\n        def getGCD(a, b):\\n            if a == 0:\\n                return b\\n            return getGCD(b % a, a)\\n        \\n        max_n = 0\\n        for i in range(len(points)):\\n            dic = collections.defaultdict(int)\\n            line_n, same_n = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j][0] - points[i][0]\\n                dy = points[j][1] - points[i][1]\\n                if dx== 0 and dy == 0: # Case: [[0,0],[0,0]], the result should be 2. So we should count the number of same points.\\n                    same_n += 1\\n                    continue\\n                gcd = getGCD(dx, dy)\\n                slope = str(dx//gcd) + \\' \\' + str(dy//gcd) # If use /, there will be \\'-0.0\\'\\n                dic[slope] += 1\\n                line_n = max(line_n, dic[slope])\\n            max_n = max(max_n, line_n+same_n+1)\\n        return max_n\\n                \\n                \\n    \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        # Question stem: we need to find all lines and return the maximum count of points in a line\\n        # Idea: Use a dictionary to store \\'slope\\' and \\'count\\'. \\n\\t\\t# We need to traverse all points and each time we will calculate the slope between two points \\n\\t\\t# and store it in string type (That\\'s why we need to calculate GCD. We need to simplify the fraction)\\n        \\n        if len(points) <= 2:\\n            return len(points)\\n\\n        def getGCD(a, b):\\n            if a == 0:\\n                return b\\n            return getGCD(b % a, a)\\n        \\n        max_n = 0\\n        for i in range(len(points)):\\n            dic = collections.defaultdict(int)\\n            line_n, same_n = 0, 0\\n            for j in range(i+1, len(points)):\\n                dx = points[j][0] - points[i][0]\\n                dy = points[j][1] - points[i][1]\\n                if dx== 0 and dy == 0: # Case: [[0,0],[0,0]], the result should be 2. So we should count the number of same points.\\n                    same_n += 1\\n                    continue\\n                gcd = getGCD(dx, dy)\\n                slope = str(dx//gcd) + \\' \\' + str(dy//gcd) # If use /, there will be \\'-0.0\\'\\n                dic[slope] += 1\\n                line_n = max(line_n, dic[slope])\\n            max_n = max(max_n, line_n+same_n+1)\\n        return max_n\\n                \\n                \\n    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 111269,
                "title": "easy-to-understand-accepted-python-code-with-detailed-explanation",
                "content": "To find maximum points that are collinear (lie on a line), we need to understand when are more than two points collinear.\\n\\nTwo points are trivially collinear since two points determine a line.\\n\\nThree points $x_i=(x_i,y_i,z_i)$ for $i=1, 2, 3$ are collinear iff the ratios of distances satisfy\\n$$ x_2-x_1:y_2-y_1:z_2-z_1=x_3-x_1:y_3-y_1:z_3-z_1. $$\\n\\n<h4>Basic Idea</h4>\\nWe can just maintain a HashMap / Dictionary of slope values and increment its count for every similar value of the slope found as we iterate over the pair of points. For each point we update the maximum number of point count we have seen so far.\\n\\nBefore we do this, we just need to keep three things in mind:\\n1. Points might be vertical in which case calculating the slope would throw DivisionByZero exception. So for such cases, we can just keep a count of verticalPoints separately.\\n2. There might be overlapping points. We need to count them separately as well.\\n3. Even for the points which are neither vertical, nor overlapping, we will have to deal with fractional quantities and precision might become an issue. Thus, it'd be better to store the fraction $p/q$ in its a HashMap as a tuple. There's another problem in doing so. It isn't necessary that the ratio will always be in its reduced form. So instead of using ratio we reduce pair by their gcd before inserting into the HashMap. Since python does not allow list as a key of dictionary, we will resort to str.\\n\\n```\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a%b\\n    return a\\n\\ndef maxPoints(points):\\n    slopeMap = dict()\\n    num_points = len(points)\\n    maxPoint = 0\\n    for i in xrange(num_points):\\n        verticalPoints = overlapPoints = currMax = 0\\n        for j in xrange(i + 1, num_points):\\n            print \"(\" + str(points[i].x) + \",\" + str(points[i].y) + \") and (\" + str(points[j].x) + \",\" + str(\\n                points[j].y) + \")\",\\n            if (points[i].x == points[j].x and points[i].y == points[j].y):\\n                overlapPoints += 1\\n                print \"| OVERLAP |\",\\n            elif points[i].x == points[j].x:\\n                verticalPoints += 1\\n                print \"| VERT |\",\\n            else:\\n                print \"| NORM |\",\\n                slope = [(points[i].y - points[j].y), (points[i].x - points[j].x)]\\n                temp = gcd(slope[0], slope[1])\\n                slope = [slope[0] / temp, slope[1] / temp]\\n                try:\\n                    slopeMap[str(slope)] += 1\\n                except:\\n                    slopeMap[str(slope)] = 1\\n                # update the current max - has the current slope value risen to the top?\\n                print \"currMax =\", currMax, \"but slopeMap[slope] = \", slopeMap[str(slope)],\\n                currMax = max(currMax, slopeMap[str(slope)])\\n\\n            # has number of vertical points risen even more?\\n            currMax = max(currMax, verticalPoints)\\n            print \"currMax =\", currMax\\n\\n        # maxpoint - the maximum number of collinear points with this point\\n        maxPoint = max(maxPoint, currMax + overlapPoints + 1)\\n        print \" - Max number of points collinear at this stage are\", maxPoint\\n        slopeMap.clear()\\n    return maxPoint\\n```\\n\\n<h4>Testing</h4>\\nTo test our code, lets write a small test case generator.\\n\\n```\\ndef generateNPoints(N):\\n    return [Point(random.randint(0,12), random.randint(0,12)) for _ in xrange(N)]\\n\\ndef printPoints(NPoints):\\n    for point in NPoints:\\n        print \"[\" + str(point.x) + \",\" + str(point.y) + \"],\",\\n    print \"\"\\n```\\n\\n<h4>Example</h4>\\n\\nTest Case:\\n<pre>\\n[7,4], [5,7], [7,4], [8,6], [0,3], [1,6]\\n</pre>\\n\\nOutput\\n<pre>\\n(7,4) and (5,7) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (7,4) | OVERLAP | currMax = 1\\n(7,4) and (8,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (0,3) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (1,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 1\\n(5,7) and (7,4) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n(5,7) and (8,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(5,7) and (0,3) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(5,7) and (1,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 0\\n(7,4) and (8,6) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (0,3) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n(7,4) and (1,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 0\\n(8,6) and (0,3) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n(8,6) and (1,6) | NORM | currMax = 1 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 0\\n(0,3) and (1,6) | NORM | currMax = 0 but slopeMap[slope] =  1 currMax = 1\\n - Max number of points collinear at this stage are 3 0 0\\n - Max number of points collinear at this stage are 3 0 0\\n3\\n</pre>",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a%b\\n    return a\\n\\ndef maxPoints(points):\\n    slopeMap = dict()\\n    num_points = len(points)\\n    maxPoint = 0\\n    for i in xrange(num_points):\\n        verticalPoints = overlapPoints = currMax = 0\\n        for j in xrange(i + 1, num_points):\\n            print \"(\" + str(points[i].x) + \",\" + str(points[i].y) + \") and (\" + str(points[j].x) + \",\" + str(\\n                points[j].y) + \")\",\\n            if (points[i].x == points[j].x and points[i].y == points[j].y):\\n                overlapPoints += 1\\n                print \"| OVERLAP |\",\\n            elif points[i].x == points[j].x:\\n                verticalPoints += 1\\n                print \"| VERT |\",\\n            else:\\n                print \"| NORM |\",\\n                slope = [(points[i].y - points[j].y), (points[i].x - points[j].x)]\\n                temp = gcd(slope[0], slope[1])\\n                slope = [slope[0] / temp, slope[1] / temp]\\n                try:\\n                    slopeMap[str(slope)] += 1\\n                except:\\n                    slopeMap[str(slope)] = 1\\n                # update the current max - has the current slope value risen to the top?\\n                print \"currMax =\", currMax, \"but slopeMap[slope] = \", slopeMap[str(slope)],\\n                currMax = max(currMax, slopeMap[str(slope)])\\n\\n            # has number of vertical points risen even more?\\n            currMax = max(currMax, verticalPoints)\\n            print \"currMax =\", currMax\\n\\n        # maxpoint - the maximum number of collinear points with this point\\n        maxPoint = max(maxPoint, currMax + overlapPoints + 1)\\n        print \" - Max number of points collinear at this stage are\", maxPoint\\n        slopeMap.clear()\\n    return maxPoint\\n```\n```\\ndef generateNPoints(N):\\n    return [Point(random.randint(0,12), random.randint(0,12)) for _ in xrange(N)]\\n\\ndef printPoints(NPoints):\\n    for point in NPoints:\\n        print \"[\" + str(point.x) + \",\" + str(point.y) + \"],\",\\n    print \"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 47164,
                "title": "2-liner-in-python-complex-solution-without-gcd",
                "content": "Motivated by @o_sharp's [solution](https://discuss.leetcode.com/topic/53632/6-liner-in-python-simple-solution-without-gcd) (and I pretty much stole the title :-P).\\n```\\nfrom collections import Counter\\nfrom cmath import phase\\n\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        P = [complex(p.x, p.y) for p in points]\\n        return max([P.count(p) + max(Counter(phase(q - p) for q in P if q != p).values() or [0]) for p in P] or [0])\\n```\\nGranted, it's three lines if I count the `cmath` import (LeetCode does import `collections` for us, but not `cmath`).",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nfrom cmath import phase\\n\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        P = [complex(p.x, p.y) for p in points]\\n        return max([P.count(p) + max(Counter(phase(q - p) for q in P if q != p).values() or [0]) for p in P] or [0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47278,
                "title": "simple-c-solution",
                "content": "    int maxPoints(vector<Point>& points) {\\n        int n = (int)points.size();\\n        if(n<3) return n;\\n        int result = 0;\\n        for(int i=0;i<n;i++) {\\n            int duplicate = 1;\\n            int localMax = 0;\\n            unordered_map<float,int> m;\\n            for (int j=i+1; j<n; j++) {\\n                if(points[j].x==points[i].x && points[j].y==points[i].y) duplicate++;\\n                else if(points[j].x==points[i].x) m[INFINITY]++;\\n                else {\\n                    float k = (float)(points[j].y-points[i].y)/(points[j].x-points[i].x);\\n                    m[k]++;\\n                }\\n            }\\n            for(auto i=m.begin();i!=m.end();i++)\\n                localMax = max(localMax,i->second);\\n            result = max(result,localMax+duplicate);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    int maxPoints(vector<Point>& points) {\\n        int n = (int)points.size();\\n        if(n<3) return n;\\n        int result = 0;\\n        for(int i=0;i<n;i++) {\\n            int duplicate = 1;\\n            int localMax = 0;\\n            unordered_map<float,int> m;\\n            for (int j=i+1; j<n; j++) {\\n                if(points[j].x==points[i].x && points[j].y==points[i].y) duplicate++;\\n                else if(points[j].x==points[i].x) m[INFINITY]++;\\n                else {\\n                    float k = (float)(points[j].y-points[i].y)/(points[j].x-points[i].x);\\n                    m[k]++;\\n                }\\n            }\\n            for(auto i=m.begin();i!=m.end();i++)\\n                localMax = max(localMax,i->second);\\n            result = max(result,localMax+duplicate);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 47277,
                "title": "30-ms-c-solution-with-explaination",
                "content": "    // LOGIC : sort the points based on x value. Now, calculate the slopes with points after the current \\n    // point. Keep on adding to points with same slope. Once done with current points, we ll have a set of slopes m\\n    // with the number of points with those slopes. Any possible slope having current point is already in the set of slopes.\\n    // If we take another point say j after i, then we have already calculated points with slope that is between j and i. thus we just need\\n    // to look after i. \\n    class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            auto comp = [] (Point& a, Point& b) { return a.x < b.x; };\\n            int n = points.size();\\n            int max_count = 0;\\n            std::sort(points.begin(), points.end(), comp);\\n            for (int i = 0; i < n; ++i) {\\n                unordered_map<double, int> slope_map;\\n                Point& p1 = points[i];\\n                int same_point = 1;\\n                int local_max = 1; // local max to get the number of points passing through max slope line starting at i\\n                \\n                // only look for points after the current one since ,\\n                // we have taken care of line segments before i with j when\\n                // running iteration for previous values of i\\n                for (int j = i+1; j < n; ++j) {\\n                    double m = 0.0;\\n                    Point& p2 = points[j];\\n                    if (p1.x == p2.x && p1.y == p2.y) {\\n                        same_point++;\\n                        local_max = max(local_max, same_point);\\n                        continue;\\n                    } else if (p1.x == p2.x) {\\n                        m = INT_MAX;\\n                    } else {\\n                        m = ((double)(p2.y-p1.y))/(p2.x-p1.x);\\n                    }\\n                    if (slope_map.find(m) == slope_map.end()) {\\n                        slope_map[m] = same_point;\\n                    }\\n                    slope_map[m]++;\\n                    local_max = max(local_max, slope_map[m]);\\n                }\\n                max_count = max(local_max, max_count);\\n            }\\n            return max_count;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxPoints(vector<Point> &points) {\\n            auto comp = [] (Point& a, Point& b) { return a.x < b.x; }",
                "codeTag": "Java"
            },
            {
                "id": 47341,
                "title": "why-my-output-on-my-own-computer-is-correct-but-the-output-on-the-web-is-wrong",
                "content": "    class Solution:\\n    # @param points, a list of Points\\n    # @return an integer\\n    def maxPoints(self, points):\\n        if len(points) <= 1:\\n            return len(points)\\n        infinity = 100.34 #some number that's not likely to appear\\n        result = 0\\n        \\n        for i in range(len(points)):\\n            diction = dict({infinity:0})\\n            samepoint = 1\\n            for j in range(i + 1, len(points)):\\n                #print ('i',i,'j', j)\\n                if (points[i].x == points[j].x and points[i].y == points[j].y):\\n                    samepoint += 1\\n                elif (points[i].x == points[j].x):\\n                    diction[infinity] += 1\\n                else:\\n                    k = (points[j].y - points[i].y) /(points[j].x - points[i].x)\\n                    if (k in diction):\\n                        diction[k]+= 1\\n                    else:\\n                        diction.update({k: 1})\\n            #print (diction)\\n            Max = 0\\n            for i in diction:\\n                Max = max(Max, diction[i])\\n            thisresult = Max + samepoint\\n            \\n            result = max(result, thisresult)\\n        return result\\n\\nThe input of my wrong answer is [(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)].\\n\\nI copy the input in the wrong answer, then run on my IDLE, it outputs 6, which is the correct answer. But when I run this code, they told me my output is 8. Are there something wrong?",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param points, a list of Points\\n    # @return an integer\\n    def maxPoints(self, points):\\n        if len(points) <= 1:\\n            return len(points)\\n        infinity = 100.34 #some number that's not likely to appear\\n        result = 0\\n        \\n        for i in range(len(points)):\\n            diction = dict({infinity:0}",
                "codeTag": "Java"
            },
            {
                "id": 3050679,
                "title": "c-explained-o-n-2-solution-using-map",
                "content": "# Intuition\\nTake a point and calculate slope between that point and other points. The slope may be infinite or finite.\\nCheck for all the points and update answer as per the number of points with the same slope.\\n\\n# Approach\\nConsider a map to store number of points with a given slope.\\nTake a varibale named infinite and increment it for the points whose slope is infinite, otherwise update map for non infinite slopes and update answer accordingly.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()<=2){return points.size();}//two or less points are always in a straight line\\n        int infinite=0;//to handle points with infinite slope\\n        int ans=0;//to store the number of maxpoints in a line\\n        double slope;\\n    \\n    for(int i=0;i<points.size()-1;i++){//iterating over points\\n        unordered_map<double,int> mp;//to store the occurance of a slope\\n        for(int j=i;j<points.size();j++){//checking slope of the point with other points\\n            \\n            if(points[j][0]==points[i][0]){//if x coordinates are same\\n                infinite++; //increment for infinite slope\\n                ans=max({ans,infinite});//update answer\\n            }\\n            else{//if slope is not infinite\\n                slope=(double)(points[j][1]-points[i][1])/(double)(points[j][0]-points[i][0]);//calculate slope\\n                mp[slope]++;//update map\\n                ans=max({ans,mp[slope]+1});//update answer\\n            }   \\n        }\\n        infinite=0;//make it zero after iterating\\n    }    \\n    return ans;\\n    }\\n};\\n```\\n**Please upvote if it helps. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()<=2){return points.size();}//two or less points are always in a straight line\\n        int infinite=0;//to handle points with infinite slope\\n        int ans=0;//to store the number of maxpoints in a line\\n        double slope;\\n    \\n    for(int i=0;i<points.size()-1;i++){//iterating over points\\n        unordered_map<double,int> mp;//to store the occurance of a slope\\n        for(int j=i;j<points.size();j++){//checking slope of the point with other points\\n            \\n            if(points[j][0]==points[i][0]){//if x coordinates are same\\n                infinite++; //increment for infinite slope\\n                ans=max({ans,infinite});//update answer\\n            }\\n            else{//if slope is not infinite\\n                slope=(double)(points[j][1]-points[i][1])/(double)(points[j][0]-points[i][0]);//calculate slope\\n                mp[slope]++;//update map\\n                ans=max({ans,mp[slope]+1});//update answer\\n            }   \\n        }\\n        infinite=0;//make it zero after iterating\\n    }    \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020084,
                "title": "optimization-using-sorting-faster-than-official-solution-clean-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake cluster of points having same angle with respect to x-axis and return maximum cluster size.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to sort the points first which allows us to just go through next points from current point instead of checking all possible pair of points.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pts) {\\n        if(pts.size() == 1) return 1;\\n        sort(pts.begin(), pts.end());\\n        int res = 2;\\n        for(int i = 0; i < pts.size()-1; i++) {\\n            unordered_map<double, int> mp;\\n            for(int j = i+1; j < pts.size(); j++) {\\n                double num = pts[j][1] - pts[i][1];\\n                double den = pts[j][0] - pts[i][0];\\n                if(j != i) mp[atan2(num, den)]++;\\n            } for(auto [k, v]: mp) res = max(res, v+1);\\n        } return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& pts) {\\n        if(pts.size() == 1) return 1;\\n        sort(pts.begin(), pts.end());\\n        int res = 2;\\n        for(int i = 0; i < pts.size()-1; i++) {\\n            unordered_map<double, int> mp;\\n            for(int j = i+1; j < pts.size(); j++) {\\n                double num = pts[j][1] - pts[i][1];\\n                double den = pts[j][0] - pts[i][0];\\n                if(j != i) mp[atan2(num, den)]++;\\n            } for(auto [k, v]: mp) res = max(res, v+1);\\n        } return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019999,
                "title": "line-slopes-c-good-code-quality-solution-short-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs learnt in school if some set of points have a common slope then they are on the same line. The only condition is one point should be common which originates that line which have the same slope.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we used brute force way of solving the problem since the constraints are low.\\nWe basically tried every set of points and use a map to store how many points have same slope.\\nFinally we calculate maximum points having same slope and updated the result accordingly.\\n\\n```\\nCalculating slope for points (x1,y1) and (x2,y2)\\nSlope = (y2-y1)/(x2-x1)\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$ where N is number of points maximum 300 points\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1;\\n        int result=0;\\n        unordered_map<double,int> slopes;\\n        double slope = 0;\\n        for(int i=0;i<points.size();++i){\\n            for(int j=i+1;j<points.size();++j){\\n                slope = ((double)(points[j][1]-points[i][1])/(double)(points[j][0]-points[i][0]));\\n                cout<<slope<<\"\\\\n\";\\n                if((points[j][0]-points[i][0])==0){\\n                    slope=DBL_MAX;\\n                }\\n                slopes[slope]++;\\n            }\\n            for(auto [slope,cnt]:slopes){\\n                result = max(result,cnt+1);\\n            }\\n            slopes.clear();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nCalculating slope for points (x1,y1) and (x2,y2)\\nSlope = (y2-y1)/(x2-x1)\\n```\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1;\\n        int result=0;\\n        unordered_map<double,int> slopes;\\n        double slope = 0;\\n        for(int i=0;i<points.size();++i){\\n            for(int j=i+1;j<points.size();++j){\\n                slope = ((double)(points[j][1]-points[i][1])/(double)(points[j][0]-points[i][0]));\\n                cout<<slope<<\"\\\\n\";\\n                if((points[j][0]-points[i][0])==0){\\n                    slope=DBL_MAX;\\n                }\\n                slopes[slope]++;\\n            }\\n            for(auto [slope,cnt]:slopes){\\n                result = max(result,cnt+1);\\n            }\\n            slopes.clear();\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3019734,
                "title": "typescript-beats-100-easy-to-understand-commented-solution",
                "content": "# Complexity\\n- Time complexity:\\n- O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxPoints(points: number[][]): number {\\n    if (points.length <= 2) return points.length;\\n\\n    const map = new Map<number, number>();\\n    let result: number = 0;\\n\\n    // y = mx + c\\n    for (let i = 0; i < points.length; i++) {\\n        const [x0, y0] = points[i];\\n\\n        // we will count each point with each and determine the largest number that can be put on one line (slope m)\\n        for (let j = i + 1; j < points.length; j++) {\\n            const [x1, y1] = points[j];\\n\\n            let m: number;\\n\\n            // => horizontal line\\n            if (x0 === x1) {\\n                m = Number.MAX_VALUE;\\n            // => vertical line\\n            } else if (y0 === y1) {\\n                m = 0;\\n            } else {\\n                m = (y0 - y1) / (x0 - x1);\\n            }\\n\\n            // new slope ? 2 points : +1 point to what we had\\n            const nextM: number = map.has(m) ? map.get(m) + 1 : 2;\\n            map.set(m, nextM);\\n            result = Math.max(result, nextM);\\n        }\\n        // we have finished counting the results relative to the point i and should clean up this trash\\n        map.clear();\\n        \\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction maxPoints(points: number[][]): number {\\n    if (points.length <= 2) return points.length;\\n\\n    const map = new Map<number, number>();\\n    let result: number = 0;\\n\\n    // y = mx + c\\n    for (let i = 0; i < points.length; i++) {\\n        const [x0, y0] = points[i];\\n\\n        // we will count each point with each and determine the largest number that can be put on one line (slope m)\\n        for (let j = i + 1; j < points.length; j++) {\\n            const [x1, y1] = points[j];\\n\\n            let m: number;\\n\\n            // => horizontal line\\n            if (x0 === x1) {\\n                m = Number.MAX_VALUE;\\n            // => vertical line\\n            } else if (y0 === y1) {\\n                m = 0;\\n            } else {\\n                m = (y0 - y1) / (x0 - x1);\\n            }\\n\\n            // new slope ? 2 points : +1 point to what we had\\n            const nextM: number = map.has(m) ? map.get(m) + 1 : 2;\\n            map.set(m, nextM);\\n            result = Math.max(result, nextM);\\n        }\\n        // we have finished counting the results relative to the point i and should clean up this trash\\n        map.clear();\\n        \\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019565,
                "title": "c-solution-easy-and-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we use the slope method of geometry\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the slope of every pair and store the number of pair for a particular slope using hash map.\\n2. Also check everytime if denominator is zero then assume the slope to be maximum value and store it. \\n3. For every pair find the number of points whose slope is same and update the mx variable. \\n\\n# Complexity\\n- Time complexity : O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if (points.size() == 1)\\n        return 1;\\n        int n = points.size();\\n        int mx = INT_MIN;\\n        for (int i = 0 ; i < n ; i++)\\n        {\\n            unordered_map<float ,int> slope;\\n            for (int j = i+1; j < n ; j++)\\n            {\\n                // if denominator is zero \\n                if (points[j][0]-points[i][0] == 0)\\n                {\\n                    slope[INT_MAX]++;\\n                }\\n                else\\n                {\\n                    float s = (points[j][1] - points[i][1])/((points[j][0]- points[i][0])*1.0);\\n                    slope[s]++;\\n                }\\n            }\\n            for (auto i : slope)\\n            mx = max(mx,i.second);      \\n        }\\n        // line is formed by two points and we increase the value by 1 only \\n        return mx+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if (points.size() == 1)\\n        return 1;\\n        int n = points.size();\\n        int mx = INT_MIN;\\n        for (int i = 0 ; i < n ; i++)\\n        {\\n            unordered_map<float ,int> slope;\\n            for (int j = i+1; j < n ; j++)\\n            {\\n                // if denominator is zero \\n                if (points[j][0]-points[i][0] == 0)\\n                {\\n                    slope[INT_MAX]++;\\n                }\\n                else\\n                {\\n                    float s = (points[j][1] - points[i][1])/((points[j][0]- points[i][0])*1.0);\\n                    slope[s]++;\\n                }\\n            }\\n            for (auto i : slope)\\n            mx = max(mx,i.second);      \\n        }\\n        // line is formed by two points and we increase the value by 1 only \\n        return mx+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018495,
                "title": "max-points-on-a-line-c-easy-code",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Slope - Two points : (x1,y1)  (x2,y2) slope : (y2-y1/x2-x1 )\\nunordered_map for storing number of pair of points having same slope.\\nCASE : where slope is infinite we have to store value INT_MAX and increase its frequency by one.\\n\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1||points.size()==2)\\n        return points.size();\\n        int mx=0;\\n        for(int i=0;i<points.size();i++){\\n        unordered_map<float,int> mp;\\n        for(int j=i+1;j<points.size();j++){\\n            if((points[j][0]-points[i][0])==0){\\n            mp[INT_MAX]++;\\n             mx=max(mx,mp[INT_MAX]+1);\\n            }\\n            else{\\n            float x=((points[j][1]-points[i][1])*1.0/(points[j][0]-points[i][0]));\\n            mp[x]++;\\n            mx=max(mx,mp[x]+1);\\n            }\\n        }\\n        }\\n        return mx;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1||points.size()==2)\\n        return points.size();\\n        int mx=0;\\n        for(int i=0;i<points.size();i++){\\n        unordered_map<float,int> mp;\\n        for(int j=i+1;j<points.size();j++){\\n            if((points[j][0]-points[i][0])==0){\\n            mp[INT_MAX]++;\\n             mx=max(mx,mp[INT_MAX]+1);\\n            }\\n            else{\\n            float x=((points[j][1]-points[i][1])*1.0/(points[j][0]-points[i][0]));\\n            mp[x]++;\\n            mx=max(mx,mp[x]+1);\\n            }\\n        }\\n        }\\n        return mx;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017961,
                "title": "c-overengineered-solution-no-floating-point-numbers",
                "content": "# Approach\\n- For each point `points[i]`:\\n- Initialise a hashmap\\n- For every subsequent point `points[j]` where `i < j`:\\n    - Calculate the gradient of the line from `points[i]` to `points[j]`\\n    - With the gradient as the key in the hashmap increment its value\\n    - Update the result as the maximum of its previous value and the count for the current gradient\\n- Return the max count\\n\\nSince the calculations are always done from one point to every subsequent point only the gradient is required as parallel lines cannot be created.\\n\\n# Implementation\\nOriginally I started with a Python3 implementation using the `fractions` library as a clean way to avoid floating point aritmetic and implementation of the GCD calculation:\\n```\\nfrom collections import defaultdict\\nfrom fractions import Fraction\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        r = 0\\n        for i in range(len(points)):\\n            # Count the number of lines with the same gradient\\n            lines = defaultdict(int)\\n            for j in range(i+1, len(points)):\\n                x1,x2 = points[i][0], points[j][0]\\n                y1,y2 = points[i][1], points[j][1]\\n                if x1-x2 == 0:\\n                    line_grad = float(\"inf\")\\n                else:\\n                    line_grad = Fraction((y1-y2), (x1-x2))\\n                lines[line_grad] += 1\\n                # track the max number of lines with the same gradient\\n                r = max(r, lines[line_grad])\\n        return r+1\\n```\\n\\nI decided to port this across to C++ and retain the use of a Fraction object as an exercise. I created my own `Fraction` structure with methods for determining the greatest common denominator and for comparison of two Fractions. \\n\\nThe GCD function is a simple implementation of [Stein\\'s Algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm).\\n\\nTo hash `Fraction` objects for use as a key in a `std::unordered_map` a bitwise XOR of the `int` hash outputs for the numerator and denominator is done.\\n\\nThe logic is the same as the above Python3 code. \\n\\nRuntime is around 20-40ms.\\n\\n# Code\\n```\\nstruct Fraction {\\n    int a;\\n    int b;\\n    Fraction(int a, int b) {\\n        if (a==0) {\\n            this->a = 0;\\n            this->b = 0;\\n            return;\\n        } else if (b==0) {\\n            this->a = INT_MAX;\\n            this->b = INT_MAX;\\n            return;\\n        }\\n        int divisor = this->gcd(abs(a),abs(b));\\n        this->a = a/divisor;\\n        this->b = b/divisor;\\n        if ((this->a > 0 && this->b < 0) || (this->a < 0 && this->b < 0)) {\\n            this->a *= -1;\\n            this->b *= -1;\\n        }\\n    }\\n    int gcd(int a, int b) {\\n        // Stein\\'s algorithm\\n        if (a==0) {\\n            return b;\\n        } else if (b==0) {\\n            return a;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while (a&1 == 0) {\\n            a >>= 1;\\n            i++;\\n        }\\n        while (b&1 == 0) {\\n            b >>= 1;\\n            j++;\\n        }\\n        int k = min(i,j);\\n        while (b!=0) {\\n            if (a > b) {\\n                swap(a,b);\\n            }\\n            b -= a;\\n            while (b&1 == 0) {\\n                b >>= 1;\\n            }\\n        }\\n        return a<<k;\\n    }\\n    bool operator==(const Fraction &other) const { \\n        return (this->a == other.a && this->b == other.b);\\n    }\\n};\\n\\nnamespace std {\\n    template <>\\n    struct hash<Fraction> {\\n        std::size_t operator()(const Fraction& k) const {\\n            using std::size_t;\\n            using std::hash;\\n            return hash<int>()(k.a) ^ hash<int>()(k.b);\\n        }\\n    };\\n}\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& ps) {\\n        int r = 0;\\n        unordered_map<Fraction, int> eq_cntr;\\n        for (int i = 0; i < ps.size(); i++) {\\n            eq_cntr.clear();\\n            for (int j = i+1; j < ps.size(); j++) {\\n                Fraction grad = Fraction(ps[i][1]-ps[j][1], ps[i][0]-ps[j][0]);\\n                eq_cntr[grad]++;\\n                r = max(r, eq_cntr[grad]);\\n            }\\n        }\\n        return r+1;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom fractions import Fraction\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        r = 0\\n        for i in range(len(points)):\\n            # Count the number of lines with the same gradient\\n            lines = defaultdict(int)\\n            for j in range(i+1, len(points)):\\n                x1,x2 = points[i][0], points[j][0]\\n                y1,y2 = points[i][1], points[j][1]\\n                if x1-x2 == 0:\\n                    line_grad = float(\"inf\")\\n                else:\\n                    line_grad = Fraction((y1-y2), (x1-x2))\\n                lines[line_grad] += 1\\n                # track the max number of lines with the same gradient\\n                r = max(r, lines[line_grad])\\n        return r+1\\n```\n```\\nstruct Fraction {\\n    int a;\\n    int b;\\n    Fraction(int a, int b) {\\n        if (a==0) {\\n            this->a = 0;\\n            this->b = 0;\\n            return;\\n        } else if (b==0) {\\n            this->a = INT_MAX;\\n            this->b = INT_MAX;\\n            return;\\n        }\\n        int divisor = this->gcd(abs(a),abs(b));\\n        this->a = a/divisor;\\n        this->b = b/divisor;\\n        if ((this->a > 0 && this->b < 0) || (this->a < 0 && this->b < 0)) {\\n            this->a *= -1;\\n            this->b *= -1;\\n        }\\n    }\\n    int gcd(int a, int b) {\\n        // Stein\\'s algorithm\\n        if (a==0) {\\n            return b;\\n        } else if (b==0) {\\n            return a;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        while (a&1 == 0) {\\n            a >>= 1;\\n            i++;\\n        }\\n        while (b&1 == 0) {\\n            b >>= 1;\\n            j++;\\n        }\\n        int k = min(i,j);\\n        while (b!=0) {\\n            if (a > b) {\\n                swap(a,b);\\n            }\\n            b -= a;\\n            while (b&1 == 0) {\\n                b >>= 1;\\n            }\\n        }\\n        return a<<k;\\n    }\\n    bool operator==(const Fraction &other) const { \\n        return (this->a == other.a && this->b == other.b);\\n    }\\n};\\n\\nnamespace std {\\n    template <>\\n    struct hash<Fraction> {\\n        std::size_t operator()(const Fraction& k) const {\\n            using std::size_t;\\n            using std::hash;\\n            return hash<int>()(k.a) ^ hash<int>()(k.b);\\n        }\\n    };\\n}\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& ps) {\\n        int r = 0;\\n        unordered_map<Fraction, int> eq_cntr;\\n        for (int i = 0; i < ps.size(); i++) {\\n            eq_cntr.clear();\\n            for (int j = i+1; j < ps.size(); j++) {\\n                Fraction grad = Fraction(ps[i][1]-ps[j][1], ps[i][0]-ps[j][0]);\\n                eq_cntr[grad]++;\\n                r = max(r, eq_cntr[grad]);\\n            }\\n        }\\n        return r+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017945,
                "title": "c-hashing-mathematics-slope-of-a-line",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        int n=points.size();\\n        int ans=0;\\n        \\n        double d;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            for(int j=0;j<n;j++){\\n                if(i==j)continue;\\n                if(points[i][0]==points[j][0]){\\n                    d=INT_MAX;// here slope is infinite \\n                }\\n                else{\\n                    d=(double)(points[i][1]-points[j][1])/(points[i][0]-points[j][0]);//slope of the line\\n                }\\n                mp[d]++;\\n                ans=max(ans,mp[d]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        \\n        int n=points.size();\\n        int ans=0;\\n        \\n        double d;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> mp;\\n            for(int j=0;j<n;j++){\\n                if(i==j)continue;\\n                if(points[i][0]==points[j][0]){\\n                    d=INT_MAX;// here slope is infinite \\n                }\\n                else{\\n                    d=(double)(points[i][1]-points[j][1])/(points[i][0]-points[j][0]);//slope of the line\\n                }\\n                mp[d]++;\\n                ans=max(ans,mp[d]);\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017845,
                "title": "explained-with-figures-c-code",
                "content": "* In this problem we have been asked about points on same line\\n* so we can use concept of slop here\\n* Let\\'s see what is slop when two points are on same line:\\n\\n![image](https://assets.leetcode.com/users/images/0c0cf5f3-2273-4b32-b4b7-137ca3054355_1673158155.5956109.png)\\n\\n* Now if we assume that one other point that is b(x3, y3) that is also lies on this line, but when it should be true??\\n\\t* It can be on this line when line xy only``` if slop of xb == slop of xy```\\n\\n![image](https://assets.leetcode.com/users/images/d8955fb8-4f94-404a-9e41-8e6b764fffb1_1673159850.7514677.png)\\n\\n\\n\\n\\n* Note\\n\\t* if there is only one pont then answer is 1\\n\\t* if there is only two points then one line can be drawn\\n\\nSo that\\'s our intution\\n```\\nwe will fix two points  and check for all other remaining points, is they are on same line or not\\n```\\n\\n### Algorithm\\n\\n```\\nn = points.size()\\nif(n <= 2) return n\\n\\nans = 2\\n\\nfor i = 0 to i < n\\n\\tfor j = i+1 to j < n\\n\\t\\tint curr = 2\\n\\t\\tfor k = 0 to k < n\\n\\t\\t\\tif k != i and k != j\\n\\t\\t\\t\\tint x1 = points[i][0]\\n\\t\\t\\t\\tint y1 = points[i][1]\\n\\t\\t\\t\\tint x2 = points[j][0]\\n\\t\\t\\t\\tint y2 = points[j][1]\\n\\t\\t\\t\\tint x3 = points[k][0]\\n\\t\\t\\t\\tint y3 = points[k][1]\\n\\t\\t\\t\\t////for decimal comparion issue we are doing cross multiplication\\n\\t\\t\\t\\tif((x2-x1)*(y3-y1) == (y2-y1)*(x3-x1))  \\n\\t\\t\\t\\t\\tcurr = curr + 1\\n\\t\\tans = max(ans, curr)\\n\\nreturn ans\\n```\\n\\n\\n### C++ Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) { \\n        int n = points.size();\\n        \\n        if(n <= 2) return n;\\n        \\n        int ans = 2; //we will fix two point and then check about other points to be on their line or not by slop concept\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                int curr = 2; //two point are fixed so\\n                for(int k = 0; k < n; k++){\\n                    if(k != i and k != j){ //i and j are fixed points so\\n                        int x1 = points[i][0];\\n                        int y1 = points[i][1];\\n                        int x2 = points[j][0];\\n                        int y2 = points[j][1];\\n                        int x3 = points[k][0];\\n                        int y3 = points[k][1];\\n                        if((x2-x1)*(y3-y1) == (y2-y1)*(x3-x1)) curr++;\\n                    }\\n                }\\n                ans = max(ans, curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n#### Upvote if you find it helpfull\\n\\nFollow me on [twitter](https://twitter.com/c_vipul_r)",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` if slop of xb == slop of xy```\n```\\nwe will fix two points  and check for all other remaining points, is they are on same line or not\\n```\n```\\nn = points.size()\\nif(n <= 2) return n\\n\\nans = 2\\n\\nfor i = 0 to i < n\\n\\tfor j = i+1 to j < n\\n\\t\\tint curr = 2\\n\\t\\tfor k = 0 to k < n\\n\\t\\t\\tif k != i and k != j\\n\\t\\t\\t\\tint x1 = points[i][0]\\n\\t\\t\\t\\tint y1 = points[i][1]\\n\\t\\t\\t\\tint x2 = points[j][0]\\n\\t\\t\\t\\tint y2 = points[j][1]\\n\\t\\t\\t\\tint x3 = points[k][0]\\n\\t\\t\\t\\tint y3 = points[k][1]\\n\\t\\t\\t\\t////for decimal comparion issue we are doing cross multiplication\\n\\t\\t\\t\\tif((x2-x1)*(y3-y1) == (y2-y1)*(x3-x1))  \\n\\t\\t\\t\\t\\tcurr = curr + 1\\n\\t\\tans = max(ans, curr)\\n\\nreturn ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) { \\n        int n = points.size();\\n        \\n        if(n <= 2) return n;\\n        \\n        int ans = 2; //we will fix two point and then check about other points to be on their line or not by slop concept\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                int curr = 2; //two point are fixed so\\n                for(int k = 0; k < n; k++){\\n                    if(k != i and k != j){ //i and j are fixed points so\\n                        int x1 = points[i][0];\\n                        int y1 = points[i][1];\\n                        int x2 = points[j][0];\\n                        int y2 = points[j][1];\\n                        int x3 = points[k][0];\\n                        int y3 = points[k][1];\\n                        if((x2-x1)*(y3-y1) == (y2-y1)*(x3-x1)) curr++;\\n                    }\\n                }\\n                ans = max(ans, curr);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017601,
                "title": "python3-itertools-combinations",
                "content": "https://leetcode.com/submissions/detail/873852672/  \\nRuntime: 111 ms, faster than 79.92% of Python3 online submissions for Max Points on a Line.  \\nMemory Usage: 38.4 MB, less than 6.75% of Python3 online submissions for Max Points on a Line.  \\n```\\nfrom itertools import combinations\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)==1: return 1\\n        lines = dict()\\n        for (x1,y1),(x2,y2) in combinations(points, 2):\\n            if x1==x2:\\n                line = (x1, None)\\n            elif y1==y2:\\n                line = (None, y1)\\n            else:\\n                slope = (y1-y2)/(x1-x2)\\n                intercept = y1-slope*x1\\n                line = (slope, intercept) \\n            if line in lines:\\n                lines[line].add((x1,y1))\\n                lines[line].add((x2,y2))\\n            else:\\n                lines[line] = {(x1,y1),(x2,y2)}\\n        return sorted([len(v) for v in lines.values()])[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)==1: return 1\\n        lines = dict()\\n        for (x1,y1),(x2,y2) in combinations(points, 2):\\n            if x1==x2:\\n                line = (x1, None)\\n            elif y1==y2:\\n                line = (None, y1)\\n            else:\\n                slope = (y1-y2)/(x1-x2)\\n                intercept = y1-slope*x1\\n                line = (slope, intercept) \\n            if line in lines:\\n                lines[line].add((x1,y1))\\n                lines[line].add((x2,y2))\\n            else:\\n                lines[line] = {(x1,y1),(x2,y2)}\\n        return sorted([len(v) for v in lines.values()])[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017503,
                "title": "2-solutions-9-ms-27-ms-2-different-approaches-explained-super-easy-java",
                "content": "# Explaination for Approach 1 :\\n```\\nFor each point p, calculate its slope with other points and use a \\nmap to record how many points have same slope, by which we can find \\nout how many points are on same line with p as their one point. \\nFor each point keep doing the same thing and update the maximum \\nnumber of point count found so far.\\n\\n1.if two point are (x1, y1) and (x2, y2) then their slope will \\nbe (y2 \\u2013 y1) / (x2 \\u2013 x1) which can be a double value and can cause \\nprecision problems. To get rid of the precision problems, we treat \\nslope as pair ((y2 \\u2013 y1), (x2 \\u2013 x1)) instead of ratio and reduce pair \\nby their gcd before inserting into map. In below code points which \\nare vertical or repeated are treated separately.\\n\\n2.If we use unordered_map in c++ or HashMap in Java for storing \\nthe slope pair, then total time complexity of solution will be \\nO(n^2) and space complexity will be O(n)\\n```\\n# Explaination for Approach 2 :\\n```\\n1.Find the line which two points create and store the points in \\nthe line as key in Hashtable\\n\\n2.After each iteration find and store the maximum size of the\\n points in that line\\n\\n3.getLine() creates a line by the form <slope, y-intercept> which\\n is actually means y=slope*x + (y-intercept). For slope = Infinity,\\n we store <null,x-intercept> which actually means x = (x-intercept).\\n```\\n# Request \\uD83D\\uDE0A :\\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [9 ms] approach).\\n```\\n# Approach 1 : 27 ms Solution\\n```\\nclass Solution \\n{\\n   public int maxPoints(int[][] points) \\n   {\\n        if (points.length <= 2) return points.length;\\n        int n = points.length;\\n        int maxPoint  = 0;//maxpoint\\n        int curMax, overlapPoints, verticalPoints;\\n        for (int i = 0; i < n - 1; i++) \\n        {\\n            curMax = overlapPoints = verticalPoints = 0;\\n            Map<String, Integer> slopeMap = new HashMap<>();\\n            for (int j = i + 1; j < n; j++) \\n            {\\n                if (points[i][0] == points[j][0]\\n                    && points[i][1] == points[j][1])\\n                    overlapPoints++;\\n \\n                // If x co-ordinate is same, then both\\n                // point are vertical to each other\\n                else if (points[i][0] == points[j][0])\\n                    verticalPoints++;\\n \\n                else {\\n                    int yDif = points[j][1] - points[i][1];\\n                    int xDif = points[j][0] - points[i][0];\\n                    int g = gcd(xDif, yDif);\\n                // divide by gcd to reduce the factor in slope\\n                \\n                xDif /= g;//for slope\\n                yDif /= g;//for slope\\n\\n                // Convert the pair into a string to use\\n                    // as dictionary key\\n                    String pair = (yDif) + \" \" + (xDif);\\n                    if (!slopeMap.containsKey(pair))\\n                        slopeMap.put(pair, 0);\\n \\n                    // increasing the frequency of current\\n                    // slope in map\\n                    slopeMap.put(pair,\\n                                 slopeMap.get(pair) + 1);\\n                    curMax = Math.max(curMax,\\n                                      slopeMap.get(pair));\\n                }\\n \\n                curMax = Math.max(curMax, verticalPoints);\\n            }\\n \\n            // updating global maximum by current point\\'s\\n            // maximum\\n            maxPoint = Math.max(maxPoint,\\n                                curMax + overlapPoints + 1);\\n            slopeMap.clear();\\n        }\\n \\n        return maxPoint;\\n    }\\n\\n    static int gcd(int x, int y) \\n    {\\n        if (y == 0) return x;\\n        return gcd(y, x % y);\\n    }\\n}\\n```\\n# Approach 2 : 9 ms Solution [Fastest]\\n```\\nclass Solution \\n{    \\n    Pair getLine(int[] a, int[] b)\\n    {//creates the <slope,y-intercept> pair for valid lines and creates <null, x-intercept> for vertical lines\\n        if(a[0]==b[0]) \\n            return new Pair<>(null,(double)a[0]);\\n        return new Pair<>((double)(a[1]-b[1])/(double)(a[0]-b[0]), a[1]-((double)(a[1]-b[1])/(double)(a[0]-b[0]))*a[0]);\\n    }\\n    \\n    public int maxPoints(int[][] points) \\n    {\\n        int len=points.length,i,j,maxSize=1;\\n        HashMap<Pair,HashSet<Integer>> map = new HashMap<Pair,HashSet<Integer>>();\\n        Pair<Double,Double> line;        \\n        for(i=0;i<len;i++)\\n        {\\n            for(j=i+1;j<len;j++)\\n            {\\n                line=getLine(points[i],points[j]);\\n                HashSet<Integer> set;\\n                set=map.containsKey(line)? map.get(line) : new HashSet<Integer>();\\n                set.add(i);\\n                set.add(j);\\n                map.put(line,set);//adding points to the line \\n                maxSize=Math.max(maxSize,set.size());//finding the maximum points in the same line\\n            }\\n        }        \\n        return maxSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nFor each point p, calculate its slope with other points and use a \\nmap to record how many points have same slope, by which we can find \\nout how many points are on same line with p as their one point. \\nFor each point keep doing the same thing and update the maximum \\nnumber of point count found so far.\\n\\n1.if two point are (x1, y1) and (x2, y2) then their slope will \\nbe (y2 \\u2013 y1) / (x2 \\u2013 x1) which can be a double value and can cause \\nprecision problems. To get rid of the precision problems, we treat \\nslope as pair ((y2 \\u2013 y1), (x2 \\u2013 x1)) instead of ratio and reduce pair \\nby their gcd before inserting into map. In below code points which \\nare vertical or repeated are treated separately.\\n\\n2.If we use unordered_map in c++ or HashMap in Java for storing \\nthe slope pair, then total time complexity of solution will be \\nO(n^2) and space complexity will be O(n)\\n```\n```\\n1.Find the line which two points create and store the points in \\nthe line as key in Hashtable\\n\\n2.After each iteration find and store the maximum size of the\\n points in that line\\n\\n3.getLine() creates a line by the form <slope, y-intercept> which\\n is actually means y=slope*x + (y-intercept). For slope = Infinity,\\n we store <null,x-intercept> which actually means x = (x-intercept).\\n```\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D (Scroll Down for fastest [9 ms] approach).\\n```\n```\\nclass Solution \\n{\\n   public int maxPoints(int[][] points) \\n   {\\n        if (points.length <= 2) return points.length;\\n        int n = points.length;\\n        int maxPoint  = 0;//maxpoint\\n        int curMax, overlapPoints, verticalPoints;\\n        for (int i = 0; i < n - 1; i++) \\n        {\\n            curMax = overlapPoints = verticalPoints = 0;\\n            Map<String, Integer> slopeMap = new HashMap<>();\\n            for (int j = i + 1; j < n; j++) \\n            {\\n                if (points[i][0] == points[j][0]\\n                    && points[i][1] == points[j][1])\\n                    overlapPoints++;\\n \\n                // If x co-ordinate is same, then both\\n                // point are vertical to each other\\n                else if (points[i][0] == points[j][0])\\n                    verticalPoints++;\\n \\n                else {\\n                    int yDif = points[j][1] - points[i][1];\\n                    int xDif = points[j][0] - points[i][0];\\n                    int g = gcd(xDif, yDif);\\n                // divide by gcd to reduce the factor in slope\\n                \\n                xDif /= g;//for slope\\n                yDif /= g;//for slope\\n\\n                // Convert the pair into a string to use\\n                    // as dictionary key\\n                    String pair = (yDif) + \" \" + (xDif);\\n                    if (!slopeMap.containsKey(pair))\\n                        slopeMap.put(pair, 0);\\n \\n                    // increasing the frequency of current\\n                    // slope in map\\n                    slopeMap.put(pair,\\n                                 slopeMap.get(pair) + 1);\\n                    curMax = Math.max(curMax,\\n                                      slopeMap.get(pair));\\n                }\\n \\n                curMax = Math.max(curMax, verticalPoints);\\n            }\\n \\n            // updating global maximum by current point\\'s\\n            // maximum\\n            maxPoint = Math.max(maxPoint,\\n                                curMax + overlapPoints + 1);\\n            slopeMap.clear();\\n        }\\n \\n        return maxPoint;\\n    }\\n\\n    static int gcd(int x, int y) \\n    {\\n        if (y == 0) return x;\\n        return gcd(y, x % y);\\n    }\\n}\\n```\n```\\nclass Solution \\n{    \\n    Pair getLine(int[] a, int[] b)\\n    {//creates the <slope,y-intercept> pair for valid lines and creates <null, x-intercept> for vertical lines\\n        if(a[0]==b[0]) \\n            return new Pair<>(null,(double)a[0]);\\n        return new Pair<>((double)(a[1]-b[1])/(double)(a[0]-b[0]), a[1]-((double)(a[1]-b[1])/(double)(a[0]-b[0]))*a[0]);\\n    }\\n    \\n    public int maxPoints(int[][] points) \\n    {\\n        int len=points.length,i,j,maxSize=1;\\n        HashMap<Pair,HashSet<Integer>> map = new HashMap<Pair,HashSet<Integer>>();\\n        Pair<Double,Double> line;        \\n        for(i=0;i<len;i++)\\n        {\\n            for(j=i+1;j<len;j++)\\n            {\\n                line=getLine(points[i],points[j]);\\n                HashSet<Integer> set;\\n                set=map.containsKey(line)? map.get(line) : new HashSet<Integer>();\\n                set.add(i);\\n                set.add(j);\\n                map.put(line,set);//adding points to the line \\n                maxSize=Math.max(maxSize,set.size());//finding the maximum points in the same line\\n            }\\n        }        \\n        return maxSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017433,
                "title": "c-97-faster-explained-with-edge-case",
                "content": "# Upvote if helpful.\\n# Intuition\\nSimple Geometry: (y2-y1)/(x2-x1)= slope of line passing two points.\\n\\n# Approach\\n```\\nFor every point we will calculate the slope of line which \\npasses through other points one by one and add the slope in the \\nmap to keep count of the max points of same slope.\\nhere slope will be key, count of slope points will be value.\\nEdge Case: if x2-x1 is 0 then it doesn\\'t matter what are the\\nvalues of y2 and y1 as slope will be INFINITY because we are\\ndividing by zero. \\nAt last return the mx+1 as we have to include the point for which\\nwe are calculating the slope counts.\\nDry run once You Will Understand Clearly.\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        int mx=0;\\n        for(int i=0; i<points.size(); i++){\\n            unordered_map<float, int>mp;\\n            int x1= points[i][0];\\n            int y1= points[i][1];\\n            \\n            for(int j=0; j<points.size()&& j!=i; j++){\\n                 int x2= points[j][0];\\n                 int y2= points[j][1];\\n                 float slp;\\n                 if(x2-x1!=0){\\n                    slp= (float)(y2-y1)/(x2-x1);\\n                 }else{\\n                    slp=INT_MAX;\\n                 }\\n                 \\n                 mp[slp]++;\\n                 mx= max(mp[slp], mx);\\n            }\\n        }\\n        return mx+1;\\n    }\\n};\\n```\\n# Thank You.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Ordered Map",
                    "Geometry"
                ],
                "code": "```\\nFor every point we will calculate the slope of line which \\npasses through other points one by one and add the slope in the \\nmap to keep count of the max points of same slope.\\nhere slope will be key, count of slope points will be value.\\nEdge Case: if x2-x1 is 0 then it doesn\\'t matter what are the\\nvalues of y2 and y1 as slope will be INFINITY because we are\\ndividing by zero. \\nAt last return the mx+1 as we have to include the point for which\\nwe are calculating the slope counts.\\nDry run once You Will Understand Clearly.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        int mx=0;\\n        for(int i=0; i<points.size(); i++){\\n            unordered_map<float, int>mp;\\n            int x1= points[i][0];\\n            int y1= points[i][1];\\n            \\n            for(int j=0; j<points.size()&& j!=i; j++){\\n                 int x2= points[j][0];\\n                 int y2= points[j][1];\\n                 float slp;\\n                 if(x2-x1!=0){\\n                    slp= (float)(y2-y1)/(x2-x1);\\n                 }else{\\n                    slp=INT_MAX;\\n                 }\\n                 \\n                 mp[slp]++;\\n                 mx= max(mp[slp], mx);\\n            }\\n        }\\n        return mx+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017021,
                "title": "straight-forward-solution-using-point-slope-and-y-intercept-eq",
                "content": "# Intuition\\n\\nWe can draw a line connecting any two points. If two or more points share the same slope and \"y intercept\" it should be on the same line. We can brute force by adding points to a set that maps to `${slope}, ${b}`. Although this answer doesn\\'t provide a great space complexity, it provides an alternative to finding angles. \\n\\nAs a specific edge-case we *need* to consider, if we have two points with the same x value, the slope will be messed up because we will have to divide by 0. Therefore I make sure to catch this and simply set b to be the x value (since any value with that x value will be on our vertical line). The same logic applies vertical lines, but can be handled by our normal logic.\\n\\nThe second code submission \"hacks\" the previous one by removing sets and increments an integer representing the number that should be in a given set, providing us with a slightly better time complexity.\\n\\nPlease let me know on best ways to optimize. \\uD83D\\uDE42\\n\\n\\n# Code\\n```\\nvar maxPoints = function(points) {\\n    if (points.length === 1) return 1 // edge case\\n    const slopes = {} // hashmap - {string: set}\\n    let maxSet = 0\\n\\n    for (let i = 0; i < points.length - 1; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            const [x1, y1] = points[i]\\n            const [x2, y2] = points[j]\\n\\n            let slope, b\\n\\n            if (x2 - x1 === 0) {\\n                slope = \\'undefined\\'\\n                b = x1 // or x2, the x values are the same\\n            } else { \\n                slope = (y2 - y1) / (x2 - x1)\\n                b = y1 - x1 * slope\\n            }\\n            const str = `${slope},${b}`\\n            if (str in slopes) {\\n                slopes[str].add(`${x1},${y1}`)\\n                slopes[str].add(`${x2},${y2}`)\\n                maxSet = Math.max(maxSet, slopes[str].size)\\n            } else {\\n                slopes[str] = new Set()\\n                slopes[str].add(`${x1},${y1}`)\\n                slopes[str].add(`${x2},${y2}`)\\n                maxSet = Math.max(maxSet, slopes[str].size)\\n            }\\n        }\\n    }\\n\\n    return maxSet\\n};\\n```\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\nvar maxPoints = function(points) {\\n    if (points.length === 1) return 1 // edge case\\n    let max = 0\\n\\n    for (let i = 0; i < points.length - 1; i++) {\\n        let slopes = {}\\n        for (let j = i + 1; j < points.length; j++) {\\n            let [x1, y1] = points[i]\\n            let [x2, y2] = points[j]\\n\\n            let slope, b\\n            if (x2 - x1 === 0) {\\n                slope = \\'undefined\\'\\n                b = x1 // or x2, the x values are the same\\n            } else { \\n                slope = (y2 - y1) / (x2 - x1)\\n                b = y1 - x1 * slope\\n            }\\n\\n            let str = `${slope},${b}`\\n            if (str in slopes) {\\n                // since we are only examining one new point\\n                // we can increment by just one\\n                slopes[str]++\\n                max = Math.max(max, slopes[str])\\n            } else {\\n                // initialized to 2 since two points make a line\\n                slopes[str] = 2\\n                max = Math.max(max, slopes[str])\\n            }\\n        }\\n    }\\n\\n\\n    return max\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxPoints = function(points) {\\n    if (points.length === 1) return 1 // edge case\\n    const slopes = {} // hashmap - {string: set}\\n    let maxSet = 0\\n\\n    for (let i = 0; i < points.length - 1; i++) {\\n        for (let j = i + 1; j < points.length; j++) {\\n            const [x1, y1] = points[i]\\n            const [x2, y2] = points[j]\\n\\n            let slope, b\\n\\n            if (x2 - x1 === 0) {\\n                slope = \\'undefined\\'\\n                b = x1 // or x2, the x values are the same\\n            } else { \\n                slope = (y2 - y1) / (x2 - x1)\\n                b = y1 - x1 * slope\\n            }\\n            const str = `${slope},${b}`\\n            if (str in slopes) {\\n                slopes[str].add(`${x1},${y1}`)\\n                slopes[str].add(`${x2},${y2}`)\\n                maxSet = Math.max(maxSet, slopes[str].size)\\n            } else {\\n                slopes[str] = new Set()\\n                slopes[str].add(`${x1},${y1}`)\\n                slopes[str].add(`${x2},${y2}`)\\n                maxSet = Math.max(maxSet, slopes[str].size)\\n            }\\n        }\\n    }\\n\\n    return maxSet\\n};\\n```\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\n\\nvar maxPoints = function(points) {\\n    if (points.length === 1) return 1 // edge case\\n    let max = 0\\n\\n    for (let i = 0; i < points.length - 1; i++) {\\n        let slopes = {}\\n        for (let j = i + 1; j < points.length; j++) {\\n            let [x1, y1] = points[i]\\n            let [x2, y2] = points[j]\\n\\n            let slope, b\\n            if (x2 - x1 === 0) {\\n                slope = \\'undefined\\'\\n                b = x1 // or x2, the x values are the same\\n            } else { \\n                slope = (y2 - y1) / (x2 - x1)\\n                b = y1 - x1 * slope\\n            }\\n\\n            let str = `${slope},${b}`\\n            if (str in slopes) {\\n                // since we are only examining one new point\\n                // we can increment by just one\\n                slopes[str]++\\n                max = Math.max(max, slopes[str])\\n            } else {\\n                // initialized to 2 since two points make a line\\n                slopes[str] = 2\\n                max = Math.max(max, slopes[str])\\n            }\\n        }\\n    }\\n\\n\\n    return max\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2894265,
                "title": "beats-99-99-submissions-fastest-easy-approach-loop-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSIMPLE TRAVERSAL OF GRID USING 3 LOOPS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCALCULATE THE SLOPE FOR EACH POINT ,KEEP A TRACK OF THE COUNT.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int m=points.length;\\n        if (m<2)\\n        {\\n            return m;\\n        }\\n        int max=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=i+1;j<m;j++)\\n            {\\n                int x1=points[i][0],y1=points[i][1],x2=points[j][0],y2=points[j][1];\\n                int count=2;\\n                for(int k=j+1;k<m;k++)\\n                {\\n                    int x3=points[k][0],y3=points[k][1];\\n                    if ((x2-x1)*(y3-y1)==(x3-x1)*(y2-y1))\\n                    {\\n                        count ++;\\n                    }\\n                }\\n                max=Math.max(count,max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int m=points.length;\\n        if (m<2)\\n        {\\n            return m;\\n        }\\n        int max=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=i+1;j<m;j++)\\n            {\\n                int x1=points[i][0],y1=points[i][1],x2=points[j][0],y2=points[j][1];\\n                int count=2;\\n                for(int k=j+1;k<m;k++)\\n                {\\n                    int x3=points[k][0],y3=points[k][1];\\n                    if ((x2-x1)*(y3-y1)==(x3-x1)*(y2-y1))\\n                    {\\n                        count ++;\\n                    }\\n                }\\n                max=Math.max(count,max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773865,
                "title": "java-math-solution",
                "content": "```\\nclass Solution {\\n//AvazbekYusupov \\n    public int maxPoints(int[][] points) {\\n    int maxPoints=0;\\n    if(points.length<=2){return points.length;}\\n    //HashMap<Double,Integer> map=new HashMap<>();\\n    for(int i=0;i<points.length;i++){\\n        HashMap<Double,Integer> map=new HashMap<>();\\n        \\n        for(int j=0;j<points.length;j++){\\n            if(i==j){continue;}\\n    \\n            int x1=points[i][0];\\n            int y1=points[i][1];\\n            \\n            int x2=points[j][0];\\n            int y2=points[j][1];\\n            \\n            \\n            double k=(double)(y2 - y1)/(double)(x2 - x1);\\n            \\n            map.put(k,map.getOrDefault(k,1) + 1);\\n            \\n            maxPoints=Math.max(maxPoints,map.get(k));\\n        }\\n    }\\n    return maxPoints;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n//AvazbekYusupov \\n    public int maxPoints(int[][] points) {\\n    int maxPoints=0;\\n    if(points.length<=2){return points.length;}\\n    //HashMap<Double,Integer> map=new HashMap<>();\\n    for(int i=0;i<points.length;i++){\\n        HashMap<Double,Integer> map=new HashMap<>();\\n        \\n        for(int j=0;j<points.length;j++){\\n            if(i==j){continue;}\\n    \\n            int x1=points[i][0];\\n            int y1=points[i][1];\\n            \\n            int x2=points[j][0];\\n            int y2=points[j][1];\\n            \\n            \\n            double k=(double)(y2 - y1)/(double)(x2 - x1);\\n            \\n            map.put(k,map.getOrDefault(k,1) + 1);\\n            \\n            maxPoints=Math.max(maxPoints,map.get(k));\\n        }\\n    }\\n    return maxPoints;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768312,
                "title": "python-easy-explanation-o-n-2",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        #if two pairs of points are on the same line they must have the same slope and intercept\\n        #we can calculate the slope and intercept for all pairs of points \\n        #we can keep track of points who belong to the same line (slope and intercept keys in dictionary)\\n        \\n        def calc_slope_interc(p1,p2): #return slope and intercept\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            \\n            #edge cases for horizontal and vertical lines\\n            \\n            if y1==y2: #horizontal\\n                return 0,y1\\n            if x1==x2: #vertical\\n                return None,x1 #slope not defined \\n            \\n            slope = (y2-y1)/(x2-x1)\\n            intercept = y2-slope*x2\\n            \\n            return (slope,intercept)\\n          \\n        #edge case one point\\n        if len(points)==1:\\n            return 1\\n        \\n        #dictionary that will keep track of the number of points that belong to the same line\\n        from collections import defaultdict\\n        tracker = defaultdict(lambda:set())#set of points (since same point can appear twice for different pairs)\\n                \\n        for i in range(len(points)-1):#calculate all pairs\\n            for j in range(i+1,len(points)):\\n                p1 = points[i]\\n                p2 = points[j]\\n                \\n                sl_int = calc_slope_interc(p1,p2)#slope and intercept for the line of the two points\\n                \\n                #add points to the set corresponding to line found\\n                #we add the index location of each datapoint\\n                tracker[sl_int].add(i)\\n                tracker[sl_int].add(j)\\n                \\n                \\n        #calculate no points per line\\n        #print(dict(tracker))\\n        no_points = [len(v) for k,v in tracker.items()] #len(v) give us the number of points for each line\\n        return max(no_points)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        #if two pairs of points are on the same line they must have the same slope and intercept\\n        #we can calculate the slope and intercept for all pairs of points \\n        #we can keep track of points who belong to the same line (slope and intercept keys in dictionary)\\n        \\n        def calc_slope_interc(p1,p2): #return slope and intercept\\n            x1,y1 = p1\\n            x2,y2 = p2\\n            \\n            #edge cases for horizontal and vertical lines\\n            \\n            if y1==y2: #horizontal\\n                return 0,y1\\n            if x1==x2: #vertical\\n                return None,x1 #slope not defined \\n            \\n            slope = (y2-y1)/(x2-x1)\\n            intercept = y2-slope*x2\\n            \\n            return (slope,intercept)\\n          \\n        #edge case one point\\n        if len(points)==1:\\n            return 1\\n        \\n        #dictionary that will keep track of the number of points that belong to the same line\\n        from collections import defaultdict\\n        tracker = defaultdict(lambda:set())#set of points (since same point can appear twice for different pairs)\\n                \\n        for i in range(len(points)-1):#calculate all pairs\\n            for j in range(i+1,len(points)):\\n                p1 = points[i]\\n                p2 = points[j]\\n                \\n                sl_int = calc_slope_interc(p1,p2)#slope and intercept for the line of the two points\\n                \\n                #add points to the set corresponding to line found\\n                #we add the index location of each datapoint\\n                tracker[sl_int].add(i)\\n                tracker[sl_int].add(j)\\n                \\n                \\n        #calculate no points per line\\n        #print(dict(tracker))\\n        no_points = [len(v) for k,v in tracker.items()] #len(v) give us the number of points for each line\\n        return max(no_points)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351664,
                "title": "cpp-simple-geometry-solution-using-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n            if(points.size()<=2)\\n                    return points.size();\\n            \\n            int ans=INT_MIN;\\n            \\n        for(int i=0;i<points.size();i++)\\n        {\\n                for(int j=i+1;j<points.size();j++)\\n                {\\n                        int dy=points[j][1]-points[i][1];\\n                        int dx=points[j][0]-points[i][0];\\n                                int count=0;\\n                        \\n                        //count from index 0 to size-1 of vector similar slope\\n                        for(int k=0;k<points.size();k++)\\n                        {\\n                                // here we do product due to errors in precision after decimal\\n                                // for example, here in int when we divide two large number \\n                                // then we got 0.00003 and 0.00004 but in (int) both are equal \\n                                // so we use multiplication instead of divide\\n                                \\n                                // (y-y1)(x1-x2)==(x-x1)(y1-y2)\\n                                \\n                                int a=dx*(points[k][1]-points[i][1]);\\n                                int b=dy*(points[k][0]-points[i][0]);\\n                                if(a==b)\\n                                        count++;\\n                        }\\n                                ans=max(ans,count);\\n                }\\n        }\\n                                return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n            if(points.size()<=2)\\n                    return points.size();\\n            \\n            int ans=INT_MIN;\\n            \\n        for(int i=0;i<points.size();i++)\\n        {\\n                for(int j=i+1;j<points.size();j++)\\n                {\\n                        int dy=points[j][1]-points[i][1];\\n                        int dx=points[j][0]-points[i][0];\\n                                int count=0;\\n                        \\n                        //count from index 0 to size-1 of vector similar slope\\n                        for(int k=0;k<points.size();k++)\\n                        {\\n                                // here we do product due to errors in precision after decimal\\n                                // for example, here in int when we divide two large number \\n                                // then we got 0.00003 and 0.00004 but in (int) both are equal \\n                                // so we use multiplication instead of divide\\n                                \\n                                // (y-y1)(x1-x2)==(x-x1)(y1-y2)\\n                                \\n                                int a=dx*(points[k][1]-points[i][1]);\\n                                int b=dy*(points[k][0]-points[i][0]);\\n                                if(a==b)\\n                                        count++;\\n                        }\\n                                ans=max(ans,count);\\n                }\\n        }\\n                                return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283775,
                "title": "java-easy-to-understand-with-explanation",
                "content": "Time Complexity : **O(N^2)**\\n**Logic:** \\n* Find the line which two points create and store the points in the line as key in Hashtable\\n* After each iteration find and store the maximum size of the points in that line\\n* `getLine()` creates a line by the form <slope, y-intercept> which is actually means y=slope*x + (y-intercept). For slope = Infinity, we store <null,x-intercept> which actually means x = (x-intercept).\\n\\n```\\nclass Solution {    \\n    Pair getLine(int[] a, int[] b){//creates the <slope,y-intercept> pair for valid lines and creates <null, x-intercept> for vertical lines\\n        if(a[0]==b[0]) \\n            return new Pair<>(null,(double)a[0]);\\n        return new Pair<>((double)(a[1]-b[1])/(double)(a[0]-b[0]), a[1]-((double)(a[1]-b[1])/(double)(a[0]-b[0]))*a[0]);\\n    }\\n    \\n    public int maxPoints(int[][] points) {\\n        int len=points.length,i,j,maxSize=1;\\n        HashMap<Pair,HashSet<Integer>> map = new HashMap<Pair,HashSet<Integer>>();\\n        Pair<Double,Double> line;        \\n        for(i=0;i<len;i++){\\n            for(j=i+1;j<len;j++){\\n                line=getLine(points[i],points[j]);\\n                HashSet<Integer> set;\\n                set=map.containsKey(line)? map.get(line) : new HashSet<Integer>();\\n                set.add(i);\\n                set.add(j);\\n                map.put(line,set);//adding points to the line \\n                maxSize=Math.max(maxSize,set.size());//finding the maximum points in the same line\\n            }\\n        }        \\n        return maxSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {    \\n    Pair getLine(int[] a, int[] b){//creates the <slope,y-intercept> pair for valid lines and creates <null, x-intercept> for vertical lines\\n        if(a[0]==b[0]) \\n            return new Pair<>(null,(double)a[0]);\\n        return new Pair<>((double)(a[1]-b[1])/(double)(a[0]-b[0]), a[1]-((double)(a[1]-b[1])/(double)(a[0]-b[0]))*a[0]);\\n    }\\n    \\n    public int maxPoints(int[][] points) {\\n        int len=points.length,i,j,maxSize=1;\\n        HashMap<Pair,HashSet<Integer>> map = new HashMap<Pair,HashSet<Integer>>();\\n        Pair<Double,Double> line;        \\n        for(i=0;i<len;i++){\\n            for(j=i+1;j<len;j++){\\n                line=getLine(points[i],points[j]);\\n                HashSet<Integer> set;\\n                set=map.containsKey(line)? map.get(line) : new HashSet<Integer>();\\n                set.add(i);\\n                set.add(j);\\n                map.put(line,set);//adding points to the line \\n                maxSize=Math.max(maxSize,set.size());//finding the maximum points in the same line\\n            }\\n        }        \\n        return maxSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229950,
                "title": "c-optimal-easy-solution-o-n-2",
                "content": "The Idea is to go to every point and see how many other points form same slope with this particular point, becuase if a set of points form same slope with this point all these lie on same line. As the constraints are low we can brute force our procedure by iterating withing O(N^2). But dont forget to handle the case where slope is 90, there the fraction becomes inf.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi=INT_MIN;\\n        \\n        \\n        for(vector<int>x:points){\\n            map<double,int>mp;\\n            int f=0;\\n            for(vector<int>y:points){\\n                if(x!=y){\\n                    if(y[0]==x[0]){\\n                        f++;\\n                    }else{\\n                        double g=(double)(y[1]-x[1]);\\n                        g/=(double)(y[0]-x[0]);\\n                        g/=1.0;\\n                        // cout<<g<<\" \";\\n                        mp[g]++;\\n                    }\\n                }\\n            }\\n            // cout<<endl;\\n            \\n            maxi=max(maxi,f+1);\\n            for(auto p:mp){\\n                maxi=max(maxi,p.second+1);\\n            }\\n            \\n            // cout<<maxi<<x[0]<<x[1]<<\" \";\\n            mp.clear();\\n            \\n        }\\n        \\n        return maxi;\\n        // cout<<endl;\\n        \\n    }\\n};\\n```\\nPls Upvote if you liked the Solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int maxi=INT_MIN;\\n        \\n        \\n        for(vector<int>x:points){\\n            map<double,int>mp;\\n            int f=0;\\n            for(vector<int>y:points){\\n                if(x!=y){\\n                    if(y[0]==x[0]){\\n                        f++;\\n                    }else{\\n                        double g=(double)(y[1]-x[1]);\\n                        g/=(double)(y[0]-x[0]);\\n                        g/=1.0;\\n                        // cout<<g<<\" \";\\n                        mp[g]++;\\n                    }\\n                }\\n            }\\n            // cout<<endl;\\n            \\n            maxi=max(maxi,f+1);\\n            for(auto p:mp){\\n                maxi=max(maxi,p.second+1);\\n            }\\n            \\n            // cout<<maxi<<x[0]<<x[1]<<\" \";\\n            mp.clear();\\n            \\n        }\\n        \\n        return maxi;\\n        // cout<<endl;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2114360,
                "title": "c-simple-solution-using-slope-concepts-hashmap",
                "content": "For each points calcuting the slope with all remaing point and using a Hashmap to store the count of the slope in form of pair {y2-y1,x2-x1} \\nAfter scanning the hashmap to calculate the maximun count of a slope for the current points \\nAnd return the max+1\\n```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        \\n        int ans=0;\\n        // sort all the value to make sure x2-x1 of the slope will all >=0\\n        sort(p.begin(),p.end());\\n        int n=p.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            // for each points calculating the slope and storing the\\n            // in form of pair {numrator,denomrator}\\n            map<pair<int,int>,int>m; \\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)  // continue the loop for same point\\n                    continue;\\n                \\n                \\n                // calculating the numrator and denomator\\n                int num=p[j][1]-p[i][1];\\n                int deno=p[j][0]-p[i][0];\\n                \\n                // taking the hcf of the value and dividing each with hcf so as to reduce \\n                int hcf=__gcd(deno,num); \\n                \\n                // if hcf is one makign hcf as 1 so as to deal with the edges cases\\n                if(hcf==0)\\n                    hcf=1;\\n                deno/=hcf;\\n                num/=hcf; \\n                \\n                // increamenting the slope which is stored in for of pair {numm,demo}\\n                m[{num,deno}]++;\\n                \\n            }\\n            \\n            // checking the map for the maximun repetaive slope \\n            for(auto i:m)\\n                ans=max(ans,i.second);\\n                \\n            \\n        }\\n        // return ans+1 so as to count the point itself \\n        return ans+1;\\n    }\\n};\\n```\\n\\nconsider upvote if you like it",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        \\n        int ans=0;\\n        // sort all the value to make sure x2-x1 of the slope will all >=0\\n        sort(p.begin(),p.end());\\n        int n=p.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            // for each points calculating the slope and storing the\\n            // in form of pair {numrator,denomrator}\\n            map<pair<int,int>,int>m; \\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)  // continue the loop for same point\\n                    continue;\\n                \\n                \\n                // calculating the numrator and denomator\\n                int num=p[j][1]-p[i][1];\\n                int deno=p[j][0]-p[i][0];\\n                \\n                // taking the hcf of the value and dividing each with hcf so as to reduce \\n                int hcf=__gcd(deno,num); \\n                \\n                // if hcf is one makign hcf as 1 so as to deal with the edges cases\\n                if(hcf==0)\\n                    hcf=1;\\n                deno/=hcf;\\n                num/=hcf; \\n                \\n                // increamenting the slope which is stored in for of pair {numm,demo}\\n                m[{num,deno}]++;\\n                \\n            }\\n            \\n            // checking the map for the maximun repetaive slope \\n            for(auto i:m)\\n                ans=max(ans,i.second);\\n                \\n            \\n        }\\n        // return ans+1 so as to count the point itself \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970670,
                "title": "c-using-slope-directly-gcd-is-not-needed",
                "content": "```\\npublic class Solution {\\n    //\\u7528\\u659C\\u7387\\u6765\\u505A\\n    //\\u9700\\u8981\\u6CE8\\u610Fx\\u4E3A0\\u7684\\u60C5\\u51B5\\n    public int MaxPoints(int[][] points) {\\n        int result = 0;\\n        for(int i = 0; i < points.Length; i++)\\n        {\\n            Dictionary<double, int> dic = new Dictionary<double, int>();\\n            int max = 0;\\n            for(int j = i + 1; j < points.Length; j++)\\n            {\\n                double slope = this.GetSlope(points[i], points[j]);\\n                if(!dic.ContainsKey(slope))\\n                {\\n                    dic[slope] = 0;\\n                }\\n\\n                dic[slope]++;\\n                max = Math.Max(max, dic[slope]);\\n            }\\n            \\n            result = Math.Max(result, max + 1);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private double GetSlope(int[] point1, int[] point2)\\n    {\\n        double dx = point2[0] - point1[0];\\n        double dy = point2[1] - point1[1];\\n        \\n        if (dx == 0)\\n        {\\n            return Double.MaxValue;\\n        }\\n        \\n        return dy/dx;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    //\\u7528\\u659C\\u7387\\u6765\\u505A\\n    //\\u9700\\u8981\\u6CE8\\u610Fx\\u4E3A0\\u7684\\u60C5\\u51B5\\n    public int MaxPoints(int[][] points) {\\n        int result = 0;\\n        for(int i = 0; i < points.Length; i++)\\n        {\\n            Dictionary<double, int> dic = new Dictionary<double, int>();\\n            int max = 0;\\n            for(int j = i + 1; j < points.Length; j++)\\n            {\\n                double slope = this.GetSlope(points[i], points[j]);\\n                if(!dic.ContainsKey(slope))\\n                {\\n                    dic[slope] = 0;\\n                }\\n\\n                dic[slope]++;\\n                max = Math.Max(max, dic[slope]);\\n            }\\n            \\n            result = Math.Max(result, max + 1);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private double GetSlope(int[] point1, int[] point2)\\n    {\\n        double dx = point2[0] - point1[0];\\n        double dy = point2[1] - point1[1];\\n        \\n        if (dx == 0)\\n        {\\n            return Double.MaxValue;\\n        }\\n        \\n        return dy/dx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946802,
                "title": "sharing-my-simple-solution-with-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            map<pair<int,int>, int> mp;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int x = points[j][0] - points[i][0];\\n                    int y = points[j][1] - points[i][1];\\n                    int  p =__gcd(x,y);\\n                    x/=p;\\n                    y/=p;\\n                    mp[{x,y}]+=1;\\n                }\\n            }\\n            int cnt = 0;\\n            for(auto it: mp)\\n            {\\n                cnt = max(cnt , it.second);\\n            }\\n            ans = max(ans,1+cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            map<pair<int,int>, int> mp;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    int x = points[j][0] - points[i][0];\\n                    int y = points[j][1] - points[i][1];\\n                    int  p =__gcd(x,y);\\n                    x/=p;\\n                    y/=p;\\n                    mp[{x,y}]+=1;\\n                }\\n            }\\n            int cnt = 0;\\n            for(auto it: mp)\\n            {\\n                cnt = max(cnt , it.second);\\n            }\\n            ans = max(ans,1+cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734310,
                "title": "golang-solution-with-illustration",
                "content": "The idea of this solution is that we start off with a point and then use all the other points to make a line from the start point to one of the other points. Then we can find the slope of the line. Then we can find which slope has the highest number of points.\\n\\n<iframe src=\"https://giphy.com/embed/up5IJe4uhceN2rlkCg\" width=\"480\" height=\"270\" frameBorder=\"0\" class=\"giphy-embed\" allowFullScreen></iframe><p><a href=\"https://giphy.com/gifs/up5IJe4uhceN2rlkCg\">GIF via GIPHY</a></p>\\n\\nIn the GIF above I only have shown one point as the start point, but we can do this with all the other points to get the maximum number of points on a line.\\n\\n``` go\\nfunc maxPoints(points [][]int) int {\\n    max := 0\\n    \\n    for i := 0; i < len(points); i++ {\\n        m := make(map[float64] int) // slope : number of points on the slope\\n        for j := 0; j < len(points); j++ {\\n            x1, x2, y1, y2 := points[i][0], points[j][0], points[i][1], points[j][1]\\n            \\n            slope := float64(y2 - y1) / float64(x2 - x1)\\n            m[slope]++\\n        }\\n        \\n        for _, b := range m {\\n            newB := (b + 1)\\n            if newB > max { max = newB }\\n        }\\n    }\\n    \\n    if len(points) == 1 { return 1 }\\n    \\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc maxPoints(points [][]int) int {\\n    max := 0\\n    \\n    for i := 0; i < len(points); i++ {\\n        m := make(map[float64] int) // slope : number of points on the slope\\n        for j := 0; j < len(points); j++ {\\n            x1, x2, y1, y2 := points[i][0], points[j][0], points[i][1], points[j][1]\\n            \\n            slope := float64(y2 - y1) / float64(x2 - x1)\\n            m[slope]++\\n        }\\n        \\n        for _, b := range m {\\n            newB := (b + 1)\\n            if newB > max { max = newB }\\n        }\\n    }\\n    \\n    if len(points) == 1 { return 1 }\\n    \\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723868,
                "title": "c-solution-with-explanation-and-edge-cases-pointed-out",
                "content": "* **F**rom mathematics we know that formula of slope is (y2-y1)/(x2-x1) \\n*  so we can use double to store slope of the elements with respect to a particular point , but the problem is (x2-x1) can be 0 and not possible in denominator \\n*   so we use string \"dx_dy\" (dx = (x2-x1)/g , dy=(y2-y1)/g)\\n* g is the gcd , ex (2,4),(3,5) have same slope with (1,3) , but differences (dx,dy) are (1,1) & (2,2) so we need to divide with gcd , then both with become (1,1)\\n* the point that i want to mention is (1/2 == 2/4 ) gcd(1,2)=1 , gcd(2,4)=2 , but we get same nums on both side when divided with gcd\\n* note gcd(0,a) = a;\\n\\n\\n**Approach**\\n1) we will take one index i and tries to find max nums of index j lying in the same line by checking slope , we store the slope in map;\\n2) when dx=0 && dy=0 gcd will be 0 and cannot be in denominator so we will deal with it individually , dx=0 & dy=0 means these points are lying on same position as i , they will contribute to max points wrt i irrespective of slope, when this happens we will increase duplicate count\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<string,int> m;\\n            int dup = 1;\\n            int temp = 0;\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0]==points[j][0] && points[i][1]==points[j][1]){\\n                    dup++;\\n                }\\n                else{\\n                int dx = points[j][0]-points[i][0];\\n                int dy = points[j][1]-points[i][1];\\n                int g = __gcd(dx,dy);\\n                m[to_string(dx/g)+\\'_\\'+to_string(dy/g)]++;\\n                temp = max(temp,m[to_string(dx/g)+\\'_\\'+to_string(dy/g)]);\\n                }\\n            }\\n            ans = max(ans,temp+dup);\\n        }\\n        return ans;    \\n    }\\n};```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            unordered_map<string,int> m;\\n            int dup = 1;\\n            int temp = 0;\\n            for(int j=i+1;j<n;j++){\\n                if(points[i][0]==points[j][0] && points[i][1]==points[j][1]){\\n                    dup++;\\n                }\\n                else{\\n                int dx = points[j][0]-points[i][0];\\n                int dy = points[j][1]-points[i][1];\\n                int g = __gcd(dx,dy);\\n                m[to_string(dx/g)+\\'_\\'+to_string(dy/g)]++;\\n                temp = max(temp,m[to_string(dx/g)+\\'_\\'+to_string(dy/g)]);\\n                }\\n            }\\n            ans = max(ans,temp+dup);\\n        }\\n        return ans;    \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1705701,
                "title": "c-custom-class-as-key-for-unordered-map",
                "content": "As two points would inevitably form a line, we can put lines of all pairs into a hashmap, and count the number of pairs that form the same line.\\nTo do this, we have to come up with a representation of a line, and use it as the key to hashmap. I think the most intuitive approach of representing a line in 2D space is ```Ax+By+C=0```. For this problem, we have to make sure that the same line always have the same key, so we have some constraint for the coefficients. First, all coefficients are divided by their greatest common divisor as previous posts point out. Second, we should make sure that ```A>=0```. With these constraints, the same line will have the same coefficients. Then we can hash the coefficients to generate key.\\nI write a custom class Line to represent line, also the overload operator ```==``` and hash function is also needed.\\n```\\n#include <unordered_map>\\n#include <math.h>\\nclass Line { // Ax+By+C=0 to represent a line\\npublic:\\n    int A;\\n    int B;\\n    int C;\\n    Line(int a,int b,int c) : A(a), B(b), C(c) {}\\n    bool operator==(const Line &l) const {\\n        return A==l.A && B==l.B && C==l.C;\\n    }\\n};\\nclass LineHasher { // used the method of boost::combined_hash\\npublic:\\n    std::size_t operator() (const Line& a) const {\\n        std::size_t h = 0;\\n        h ^= std::hash<int>{}(a.A) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        h ^= std::hash<int>{}(a.B) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        h ^= std::hash<int>{}(a.C) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        return h;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    Line line(vector<int>& p1, vector<int>& p2){\\n        // might overflow when testcase range becomes larger\\n        int A = p2[1] - p1[1];\\n        int B = p1[0] - p2[0];\\n        int C = p1[0]*p2[1] - p2[0]*p1[1];\\n        int div = gcd(gcd(A,B),C);\\n        if((A<0) || (A==0 && B<0)){\\n            A = -A; B = -B; C = -C;\\n        }\\n        return Line(A/div,B/div,C/div);\\n    }\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        unordered_map<Line,int,LineHasher> lines;\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=i+1; j<points.size(); j++){\\n                Line curline = line(points[i],points[j]);\\n                lines[curline] ++;\\n            }\\n        }\\n        int maxPair = 0;\\n        for(auto it=lines.begin(); it!=lines.end(); it++){\\n            maxPair = max(maxPair,it->second);\\n        }\\n        return sqrt(2*maxPair)+1; // pointNum*(pointNum-1)/2=pairNum\\n    }\\n};\\n```\\nThis method beat over 98%.\\nFollowing is a O(N^3) brute force intuitive method that turns out to be not very slow.\\n```\\n// check all 3 point group\\nclass Solution {\\nprivate:\\n    bool isLine(vector<int> &a, vector<int> &b, vector<int> &c){\\n        return (b[1]-a[1])*(c[0]-b[0])==(c[1]-b[1])*(b[0]-a[0]);\\n    }\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n==1) {return 1;}\\n        int maxP = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                int curP = 2;\\n                for(int k=j+1; k<n; k++){\\n                    if(isLine(points[i],points[j],points[k])){\\n                        curP ++;\\n                    }\\n                }\\n                maxP = max(maxP,curP);\\n            }\\n        }\\n        return maxP;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```Ax+By+C=0```\n```A>=0```\n```==```\n```\\n#include <unordered_map>\\n#include <math.h>\\nclass Line { // Ax+By+C=0 to represent a line\\npublic:\\n    int A;\\n    int B;\\n    int C;\\n    Line(int a,int b,int c) : A(a), B(b), C(c) {}\\n    bool operator==(const Line &l) const {\\n        return A==l.A && B==l.B && C==l.C;\\n    }\\n};\\nclass LineHasher { // used the method of boost::combined_hash\\npublic:\\n    std::size_t operator() (const Line& a) const {\\n        std::size_t h = 0;\\n        h ^= std::hash<int>{}(a.A) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        h ^= std::hash<int>{}(a.B) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        h ^= std::hash<int>{}(a.C) + 0x9e3779b9 + (h << 6) + (h >> 2);\\n        return h;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    Line line(vector<int>& p1, vector<int>& p2){\\n        // might overflow when testcase range becomes larger\\n        int A = p2[1] - p1[1];\\n        int B = p1[0] - p2[0];\\n        int C = p1[0]*p2[1] - p2[0]*p1[1];\\n        int div = gcd(gcd(A,B),C);\\n        if((A<0) || (A==0 && B<0)){\\n            A = -A; B = -B; C = -C;\\n        }\\n        return Line(A/div,B/div,C/div);\\n    }\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        unordered_map<Line,int,LineHasher> lines;\\n        for(int i=0; i<points.size(); i++){\\n            for(int j=i+1; j<points.size(); j++){\\n                Line curline = line(points[i],points[j]);\\n                lines[curline] ++;\\n            }\\n        }\\n        int maxPair = 0;\\n        for(auto it=lines.begin(); it!=lines.end(); it++){\\n            maxPair = max(maxPair,it->second);\\n        }\\n        return sqrt(2*maxPair)+1; // pointNum*(pointNum-1)/2=pairNum\\n    }\\n};\\n```\n```\\n// check all 3 point group\\nclass Solution {\\nprivate:\\n    bool isLine(vector<int> &a, vector<int> &b, vector<int> &c){\\n        return (b[1]-a[1])*(c[0]-b[0])==(c[1]-b[1])*(b[0]-a[0]);\\n    }\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size();\\n        if(n==1) {return 1;}\\n        int maxP = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                int curP = 2;\\n                for(int k=j+1; k<n; k++){\\n                    if(isLine(points[i],points[j],points[k])){\\n                        curP ++;\\n                    }\\n                }\\n                maxP = max(maxP,curP);\\n            }\\n        }\\n        return maxP;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1664049,
                "title": "java-comment-explanation",
                "content": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if (points == null) return 0;\\n        int length = points.length;\\n        if (length <= 2) return length;\\n        int result = 0;\\n        for (int i = 0;i<points.length;i++){\\n            Map<Double, Integer> map = new HashMap<>();\\n            int count = 1;\\n            int same = 0;\\n            for (int j = 0;j<points.length;j++){\\n                //pick non matching points\\n                if(j != i){\\n                    //first point\\n                    int firstX = points[i][0];\\n                    int firstY = points[i][1];\\n                    \\n                    //second point\\n                    int secondX = points[j][0];\\n                    int secondY = points[j][1];\\n                    \\n                    //if both points are same, increment same points\\n                    if (firstX == secondX && firstY == secondY){ \\n                        same++;\\n                        continue;\\n                    }\\n                    //if only x is different increment count\\n                    if (firstX == secondX) {\\n                        count++;                    \\n                        continue;\\n                    }\\n                    //for different points put in map the y/x\\n                    double k = (double)(secondY - firstY) / (double)(secondX - firstX);\\n                    map.put(k, map.getOrDefault(k, 1)+1);\\n                    //compute max with map value with number of same points\\n                    result = Math.max(result, map.get(k) + same);\\n                }\\n            }\\n            //update the result\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if (points == null) return 0;\\n        int length = points.length;\\n        if (length <= 2) return length;\\n        int result = 0;\\n        for (int i = 0;i<points.length;i++){\\n            Map<Double, Integer> map = new HashMap<>();\\n            int count = 1;\\n            int same = 0;\\n            for (int j = 0;j<points.length;j++){\\n                //pick non matching points\\n                if(j != i){\\n                    //first point\\n                    int firstX = points[i][0];\\n                    int firstY = points[i][1];\\n                    \\n                    //second point\\n                    int secondX = points[j][0];\\n                    int secondY = points[j][1];\\n                    \\n                    //if both points are same, increment same points\\n                    if (firstX == secondX && firstY == secondY){ \\n                        same++;\\n                        continue;\\n                    }\\n                    //if only x is different increment count\\n                    if (firstX == secondX) {\\n                        count++;                    \\n                        continue;\\n                    }\\n                    //for different points put in map the y/x\\n                    double k = (double)(secondY - firstY) / (double)(secondX - firstX);\\n                    map.put(k, map.getOrDefault(k, 1)+1);\\n                    //compute max with map value with number of same points\\n                    result = Math.max(result, map.get(k) + same);\\n                }\\n            }\\n            //update the result\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520467,
                "title": "java-easy-solution-with-explanation",
                "content": "```\\n/*\\n \\n1. Here are going calcluate slopes of each index with all other next elements and storing them in to hashmap and each index has own hashmap of slopes\\n2. After calculation of each index\\'s slopes we taking maximum number of slopes occur for each index\\n3.   Finally we will have max count of slopes \\n4.  and we are returning with +1 because =max no. of connected points + 1(that node itslef).\\n \\n Math formula for slope = (y2-y1)/(x2-x1)\\n \\n*/\\n\\n\\n\\nclass Solution {\\n    \\n   public  int maxPoints(int[][] points) {\\n\\n        int pLen = points.length;\\n        if (pLen < 3) {\\n            return pLen;\\n        }\\n\\n        HashMap<Double, Integer> hm;\\n\\n        int maxNoOfPoints = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < pLen; i++) {\\n\\n            hm = new HashMap<>();\\n            \\n            for (int j = i + 1; j < pLen; j++) {\\n                \\n                double slope = getSlope(points[i], points[j]);\\n                \\n                hm.put(slope,hm.getOrDefault(slope,0)+1);\\n\\n            }\\n\\n            for (Map.Entry<Double, Integer> entry : hm.entrySet()) {\\n                maxNoOfPoints = Math.max(maxNoOfPoints, entry.getValue());\\n\\n            }\\n                    \\n        }\\n\\n        return maxNoOfPoints+1;\\n\\n    }\\n\\n\\n     public static double getSlope(int[] cord1, int[] cord2) {\\n\\n        double mY = cord2[1] - cord1[1];\\n        double mX = cord2[0] - cord1[0];\\n        if (mY == 0) return 0; // edge case\\n        if (mX == 0) return Double.POSITIVE_INFINITY; // edge case\\n        return mY/mX;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n \\n1. Here are going calcluate slopes of each index with all other next elements and storing them in to hashmap and each index has own hashmap of slopes\\n2. After calculation of each index\\'s slopes we taking maximum number of slopes occur for each index\\n3.   Finally we will have max count of slopes \\n4.  and we are returning with +1 because =max no. of connected points + 1(that node itslef).\\n \\n Math formula for slope = (y2-y1)/(x2-x1)\\n \\n*/\\n\\n\\n\\nclass Solution {\\n    \\n   public  int maxPoints(int[][] points) {\\n\\n        int pLen = points.length;\\n        if (pLen < 3) {\\n            return pLen;\\n        }\\n\\n        HashMap<Double, Integer> hm;\\n\\n        int maxNoOfPoints = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < pLen; i++) {\\n\\n            hm = new HashMap<>();\\n            \\n            for (int j = i + 1; j < pLen; j++) {\\n                \\n                double slope = getSlope(points[i], points[j]);\\n                \\n                hm.put(slope,hm.getOrDefault(slope,0)+1);\\n\\n            }\\n\\n            for (Map.Entry<Double, Integer> entry : hm.entrySet()) {\\n                maxNoOfPoints = Math.max(maxNoOfPoints, entry.getValue());\\n\\n            }\\n                    \\n        }\\n\\n        return maxNoOfPoints+1;\\n\\n    }\\n\\n\\n     public static double getSlope(int[] cord1, int[] cord2) {\\n\\n        double mY = cord2[1] - cord1[1];\\n        double mX = cord2[0] - cord1[0];\\n        if (mY == 0) return 0; // edge case\\n        if (mX == 0) return Double.POSITIVE_INFINITY; // edge case\\n        return mY/mX;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324084,
                "title": "c-beats-95-on-runtime-and-81-on-memory-explanation",
                "content": "The main idea in my solution is that we iterate over points and create all possible pairs. For each pair we calculate parameters **k** and **b** of a linear function: *y = kx + b*. We store all possible lines (defined by pair **k**, **b**) and calculate how many pairs of points had those  **k** and **b**. At last, we return how many points were in those pairs.\\n\\nMain loop. To avoid taking the same point twice `i = 1..N-1`, but **j** starts from **i+1**: `j = i+1..N`\\n```\\n    for (std::size_t i=0; i<points.size()-1; ++i) {\\n        for (std::size_t j=i+1; j<points.size(); ++j) {\\n            auto line = makeLine(points[i], points[j]);\\n```\\n\\nIf the current line exists in a map, we\\'ll increase counter, otherwise - insert new line.\\nAt the same time we calculate `max` number of pairs, to avoid second loop after this one.\\n```\\n            auto lineIt = lines.find(line);\\n            if (lineIt == lines.end()) {\\n                lines.emplace(line, 1);\\n            } else {\\n                ++(lineIt->second);\\n                if (lineIt->second > max) {\\n                    max = lineIt->second;\\n                }\\n            }\\n```\\nAt the end of a loop we have a number of pairs. The formula for all possible pairs from **n** numbers is\\n*pairs = n (n-1) / 2*\\nHence **pairs** and **n** are >0 in our case, the reverse formula will be\\n*n = (1 + sqrt(1 + 8 * pairs)) / 2*\\n\\nOther notes.\\nTo be able to insert user-defined class **Line** into map, we must define **less** (operator < ) for this type.\\n```\\ntemplate<> struct less<Line>\\n{\\n    bool operator() (const Line& lhs, const Line& rhs) const\\n    {\\n        if (not lessFloat(lhs.k, rhs.k) and not lessFloat(rhs.k, lhs.k)) {\\n            return lessFloat(lhs.b, rhs.b);\\n        } else {\\n            return lessFloat(lhs.k, rhs.k);\\n        }\\n    }\\n};\\n```\\nTo compare two floating point values we must not use operator < , but instead compare them with a precision:\\n```\\ninline bool lessFloat(float a, float b) \\n{\\n    return (b - a) > ( (fabs(a) < fabs(b) ? abs(b) : fabs(a)) * 0.0001f);\\n}\\n``` \\n**makeLine** function calculates **k** with formula *k = (y2 - y1) / (x2 - x1)* and then calculates **b** : *b = y1 - kx1*.\\nThere\\'s a little edge case though: lines, that parallel to y-axis. According to math, they are not linear functions and we have a problem with a division by zero, because x1 == x2. We will store those lines with *k=infinity*. It\\'s okay with math and our sollution too.\\n```\\nLine makeLine(const vector<int>& lhs, const vector<int>& rhs)\\n{\\n    Line result;\\n    // x1 == x2\\n    if (lhs[0] == rhs[0]) {\\n        result.k = std::numeric_limits<float>::infinity();\\n        result.b = lhs[0]; // == x\\n    } else {\\n        // k = (y2 - y1) / (x2 - x1)\\n        result.k = (rhs[1] - lhs[1]) / float(rhs[0] - lhs[0]);\\n        // y1 - k * x1\\n        result.b = lhs[1] - result.k * lhs[0];        \\n    }\\n    return result;\\n}\\n```\\n \\n\\nPutting all together:\\n\\n```\\n#include <iostream>\\n#include <map>\\n#include <algorithm>\\n\\nstruct Line \\n{\\n    float k;\\n    float b;\\n};\\n\\ninline bool lessFloat(float a, float b) \\n{\\n    return (b - a) > ( (fabs(a) < fabs(b) ? abs(b) : fabs(a)) * 0.0001f);\\n}\\n\\ntemplate<> struct less<Line>\\n{\\n    bool operator() (const Line& lhs, const Line& rhs) const\\n    {\\n        if (not lessFloat(lhs.k, rhs.k) and not lessFloat(rhs.k, lhs.k)) {\\n            return lessFloat(lhs.b, rhs.b);\\n        } else {\\n            return lessFloat(lhs.k, rhs.k);\\n        }\\n    }\\n};\\n\\nusing Lines = std::map<Line, int>;\\n\\nLine makeLine(const vector<int>& lhs, const vector<int>& rhs)\\n{\\n    Line result;\\n    // x1 == x2\\n    if (lhs[0] == rhs[0]) {\\n        result.k = std::numeric_limits<float>::infinity();\\n        result.b = lhs[0]; // == x\\n    } else {\\n        // k = (y2 - y1) / (x2 - x1)\\n        result.k = (rhs[1] - lhs[1]) / float(rhs[0] - lhs[0]);\\n        // y1 - k * x1\\n        result.b = lhs[1] - result.k * lhs[0];        \\n    }\\n    return result;\\n}\\n\\nint maxPointsLine(const vector<vector<int>>& points) {\\n    if (points.size() == 1) {\\n        return 1;\\n    }\\n        \\n    Lines lines;\\n    auto max = 1;\\n    for (std::size_t i=0; i<points.size()-1; ++i) {\\n        for (std::size_t j=i+1; j<points.size(); ++j) {\\n            auto line = makeLine(points[i], points[j]);\\n            \\n            auto lineIt = lines.find(line);\\n            if (lineIt == lines.end()) {\\n                lines.emplace(line, 1);\\n            } else {\\n                ++(lineIt->second);\\n                if (lineIt->second > max) {\\n                    max = lineIt->second;\\n                }\\n            }\\n            \\n        }       \\n    }\\n    \\n    // x = (1 + sqrt(1 + 8 * pairs)) / 2\\n    return (1 + pow(1 + 8 * max, 0.5)) / 2;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        return maxPointsLine(points);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n    for (std::size_t i=0; i<points.size()-1; ++i) {\\n        for (std::size_t j=i+1; j<points.size(); ++j) {\\n            auto line = makeLine(points[i], points[j]);\\n```\n```\\n            auto lineIt = lines.find(line);\\n            if (lineIt == lines.end()) {\\n                lines.emplace(line, 1);\\n            } else {\\n                ++(lineIt->second);\\n                if (lineIt->second > max) {\\n                    max = lineIt->second;\\n                }\\n            }\\n```\n```\\ntemplate<> struct less<Line>\\n{\\n    bool operator() (const Line& lhs, const Line& rhs) const\\n    {\\n        if (not lessFloat(lhs.k, rhs.k) and not lessFloat(rhs.k, lhs.k)) {\\n            return lessFloat(lhs.b, rhs.b);\\n        } else {\\n            return lessFloat(lhs.k, rhs.k);\\n        }\\n    }\\n};\\n```\n```\\ninline bool lessFloat(float a, float b) \\n{\\n    return (b - a) > ( (fabs(a) < fabs(b) ? abs(b) : fabs(a)) * 0.0001f);\\n}\\n```\n```\\nLine makeLine(const vector<int>& lhs, const vector<int>& rhs)\\n{\\n    Line result;\\n    // x1 == x2\\n    if (lhs[0] == rhs[0]) {\\n        result.k = std::numeric_limits<float>::infinity();\\n        result.b = lhs[0]; // == x\\n    } else {\\n        // k = (y2 - y1) / (x2 - x1)\\n        result.k = (rhs[1] - lhs[1]) / float(rhs[0] - lhs[0]);\\n        // y1 - k * x1\\n        result.b = lhs[1] - result.k * lhs[0];        \\n    }\\n    return result;\\n}\\n```\n```\\n#include <iostream>\\n#include <map>\\n#include <algorithm>\\n\\nstruct Line \\n{\\n    float k;\\n    float b;\\n};\\n\\ninline bool lessFloat(float a, float b) \\n{\\n    return (b - a) > ( (fabs(a) < fabs(b) ? abs(b) : fabs(a)) * 0.0001f);\\n}\\n\\ntemplate<> struct less<Line>\\n{\\n    bool operator() (const Line& lhs, const Line& rhs) const\\n    {\\n        if (not lessFloat(lhs.k, rhs.k) and not lessFloat(rhs.k, lhs.k)) {\\n            return lessFloat(lhs.b, rhs.b);\\n        } else {\\n            return lessFloat(lhs.k, rhs.k);\\n        }\\n    }\\n};\\n\\nusing Lines = std::map<Line, int>;\\n\\nLine makeLine(const vector<int>& lhs, const vector<int>& rhs)\\n{\\n    Line result;\\n    // x1 == x2\\n    if (lhs[0] == rhs[0]) {\\n        result.k = std::numeric_limits<float>::infinity();\\n        result.b = lhs[0]; // == x\\n    } else {\\n        // k = (y2 - y1) / (x2 - x1)\\n        result.k = (rhs[1] - lhs[1]) / float(rhs[0] - lhs[0]);\\n        // y1 - k * x1\\n        result.b = lhs[1] - result.k * lhs[0];        \\n    }\\n    return result;\\n}\\n\\nint maxPointsLine(const vector<vector<int>>& points) {\\n    if (points.size() == 1) {\\n        return 1;\\n    }\\n        \\n    Lines lines;\\n    auto max = 1;\\n    for (std::size_t i=0; i<points.size()-1; ++i) {\\n        for (std::size_t j=i+1; j<points.size(); ++j) {\\n            auto line = makeLine(points[i], points[j]);\\n            \\n            auto lineIt = lines.find(line);\\n            if (lineIt == lines.end()) {\\n                lines.emplace(line, 1);\\n            } else {\\n                ++(lineIt->second);\\n                if (lineIt->second > max) {\\n                    max = lineIt->second;\\n                }\\n            }\\n            \\n        }       \\n    }\\n    \\n    // x = (1 + sqrt(1 + 8 * pairs)) / 2\\n    return (1 + pow(1 + 8 * max, 0.5)) / 2;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        return maxPointsLine(points);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1320314,
                "title": "python-44ms-with-hashtable",
                "content": "```\\ndef maxPoints(points):\\n    p_num = len(points)\\n    slope_dict = [{} for p in range(p_num)]\\n    \\n    max_points = 0\\n    for i in range(p_num-1):\\n        for j in range(i+1, p_num):\\n            x_dis = points[j][0]-points[i][0]\\n            if x_dis != 0:\\n                curr_slope = (points[j][1]-points[i][1])/x_dis\\n            else:\\n                curr_slope = float(\\'inf\\')\\n            \\n            if curr_slope not in slope_dict[i].keys():\\n                slope_dict[i][curr_slope] = 1\\n            else:\\n                slope_dict[i][curr_slope] += 1\\n        \\n        max_points = max(max_points, max(slope_dict[i].values()))\\n        \\n    return max_points+1\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\ndef maxPoints(points):\\n    p_num = len(points)\\n    slope_dict = [{} for p in range(p_num)]\\n    \\n    max_points = 0\\n    for i in range(p_num-1):\\n        for j in range(i+1, p_num):\\n            x_dis = points[j][0]-points[i][0]\\n            if x_dis != 0:\\n                curr_slope = (points[j][1]-points[i][1])/x_dis\\n            else:\\n                curr_slope = float(\\'inf\\')\\n            \\n            if curr_slope not in slope_dict[i].keys():\\n                slope_dict[i][curr_slope] = 1\\n            else:\\n                slope_dict[i][curr_slope] += 1\\n        \\n        max_points = max(max_points, max(slope_dict[i].values()))\\n        \\n    return max_points+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1100560,
                "title": "swift-solution-y-mx-c",
                "content": "```\\nclass Solution {\\n    func maxPoints(_ points: [[Int]]) -> Int {\\n        if points.count < 2 {\\n            return 1\\n        }\\n        \\n        var bySlop: [Double: Int] = [:]\\n        var result = 0\\n        \\n        for i in 0..<points.count {\\n            let p1 = points[i]\\n            bySlop = [:]\\n            for j in 0..<points.count {\\n                if i == j { continue }\\n\\n                let p2 = points[j] \\n                \\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tStraight line formula\\n\\t\\t\\t\\t======================\\n\\t\\t\\t\\ty = mx + c\\n\\t\\t\\t\\tm = (y2 - y1)/(x2 - x1)\\n\\t\\t\\t\\t*/\\n                let yDiff = (p2[1] - p1[1])\\n                let xDiff = (p2[0] - p1[0])\\n\\n                let m: Double\\n                if xDiff == 0 && yDiff > 0 {\\n                    m = Double(Int.max)\\n                } else {\\n                    m = Double(yDiff)/Double(xDiff)\\n                }\\n\\n                var slopPoints = bySlop[m] ?? 0\\n                if slopPoints == 0 {\\n                    slopPoints = 2\\n                } else {\\n                    slopPoints += 1\\n                }\\n\\n                bySlop[m] = slopPoints\\n\\n                result = max(result, slopPoints)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```\\n\\nTime = O(n^2)\\nSpace = O(s) - where `s` is maximum number of different slops\\n// I think i got it right with the complexities. Please correct me if im wrong.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxPoints(_ points: [[Int]]) -> Int {\\n        if points.count < 2 {\\n            return 1\\n        }\\n        \\n        var bySlop: [Double: Int] = [:]\\n        var result = 0\\n        \\n        for i in 0..<points.count {\\n            let p1 = points[i]\\n            bySlop = [:]\\n            for j in 0..<points.count {\\n                if i == j { continue }\\n\\n                let p2 = points[j] \\n                \\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tStraight line formula\\n\\t\\t\\t\\t======================\\n\\t\\t\\t\\ty = mx + c\\n\\t\\t\\t\\tm = (y2 - y1)/(x2 - x1)\\n\\t\\t\\t\\t*/\\n                let yDiff = (p2[1] - p1[1])\\n                let xDiff = (p2[0] - p1[0])\\n\\n                let m: Double\\n                if xDiff == 0 && yDiff > 0 {\\n                    m = Double(Int.max)\\n                } else {\\n                    m = Double(yDiff)/Double(xDiff)\\n                }\\n\\n                var slopPoints = bySlop[m] ?? 0\\n                if slopPoints == 0 {\\n                    slopPoints = 2\\n                } else {\\n                    slopPoints += 1\\n                }\\n\\n                bySlop[m] = slopPoints\\n\\n                result = max(result, slopPoints)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963351,
                "title": "python-short-easy-o-n-2-time-o-n-space-using-fraction",
                "content": "Idea: For each point, calculate the num of points that make same slope with this point. Input also contains duplicates so handle them seperately.\\n```\\ndef maxPoints(self, points: List[List[int]]) -> int:\\n\\tans, INF = 0, 10**10\\n\\tfor x1, y1 in points:\\n\\t\\tslopes = defaultdict(int)\\n\\t\\tduplicates = 0\\n\\t\\tfor x2, y2 in points:\\n\\t\\t\\tif x1 == x2 and y1 == y2:\\n\\t\\t\\t\\tduplicates += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdy, dx = y2 - y1, x2 - x1\\n\\t\\t\\t\\tslope = Fraction(dy, dx) if dx else INF\\n\\t\\t\\t\\tslopes[slope] += 1\\n\\n\\t\\tpoints_on_line = max(slopes.values()) if slopes.values() else 0\\n\\t\\tans = max(points_on_line + duplicates, ans)\\n\\t\\t\\n\\treturn ans\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxPoints(self, points: List[List[int]]) -> int:\\n\\tans, INF = 0, 10**10\\n\\tfor x1, y1 in points:\\n\\t\\tslopes = defaultdict(int)\\n\\t\\tduplicates = 0\\n\\t\\tfor x2, y2 in points:\\n\\t\\t\\tif x1 == x2 and y1 == y2:\\n\\t\\t\\t\\tduplicates += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdy, dx = y2 - y1, x2 - x1\\n\\t\\t\\t\\tslope = Fraction(dy, dx) if dx else INF\\n\\t\\t\\t\\tslopes[slope] += 1\\n\\n\\t\\tpoints_on_line = max(slopes.values()) if slopes.values() else 0\\n\\t\\tans = max(points_on_line + duplicates, ans)\\n\\t\\t\\n\\treturn ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 928801,
                "title": "go-solution-with-notes",
                "content": "```\\n// y = kx + b\\n// for 2 points: (x1, y1), (x2, y2) we have a system:\\n// y1 = kx1 + b\\n// y2 = kx2 + b\\n// y1 - y2 = kx1 + b - (kx2 + b) = k*(x1 - x2)\\n\\n// k = (y1 - y2) / (x1 - x2) = p / q\\n//\\n// y = kx + b => b = y - kx\\n// b = y1 - k * x1 = y1 - p/q * x1 = (q*y1 - x1*p) / q\\n\\n// So in order to identify a line we must have:\\n// k and b where k = p/q, b = (q*y1 - x1*p) / q. \\n//\\n// in our case it is enough to store: [p, q, (q*y1-x1*p)]\\n\\ntype Line struct {\\n    p, q, b int64\\n}\\n\\nfunc maxPoints(points [][]int) int {\\n    xGroup := make(map[int]int)\\n    yGroup := make(map[int]int)\\n    res := 0\\n    \\n    for i := 0; i < len(points); i++ {\\n        x, y := points[i][0], points[i][1]\\n        xGroup[x]++\\n        yGroup[y]++\\n        \\n        res = max(max(res, xGroup[x]), yGroup[y])\\n    }\\n    \\n    for i := 0; i < len(points); i++ {\\n        // we reserve self point as a duplicate\\n        lines := map[Line]int{}\\n        duplicates := 1\\n        \\n        for j := i + 1; j < len(points); j++ {\\n            a, b := points[i], points[j]\\n            \\n            if a[0] == b[0] && a[1] == b[1] {\\n                duplicates++\\n            }\\n        }\\n        \\n        for j := i + 1; j < len(points); j++ {\\n            a, b := points[i], points[j]\\n            \\n            if a[0] == b[0] || a[1] == b[1] {\\n                continue\\n            }\\n            \\n            p, q := getSlope(a, b)\\n            line := Line{p: p, q: q, b: q * int64(a[1]) - p * int64(a[0])}\\n            \\n            lines[line]++\\n            res = max(res, lines[line] + duplicates)\\n        }\\n    }\\n    \\n    return res\\n}\\n\\n// y = kx + b\\n// for 2 points: (x1, y1), (x2, y2) we have a system:\\n// y1 = kx1 + b\\n// y2 = kx2 + b\\n// y1 - y2 = kx1 + b - (kx2 + b) = k*(x1 - x2)\\n// k = (y1 - y2) / (x1 - x2)\\n// \\n// we return the numerator and denominator of the p/q = ((y1 - y2) / gcd) / ((x1 - x2) / gcd)\\n// we do this in order to normalize the fraction: here is an example\\n// 2/3 and 10/15, gcd(2,3) = 1, gcd(10,15) = 5\\n// 2/3 = 10/5 = 10/5/15/5 = 2/3\\nfunc getSlope(a, b []int) (int64, int64) {\\n    deltaX, deltaY := int64(a[0] - b[0]), int64(a[1] - b[1])\\n\\n    if deltaX < 0 {\\n        deltaX = -deltaX\\n        deltaY = -deltaY\\n    }\\n\\n    g := gcd(deltaX, deltaY)\\n    return deltaX / g, deltaY / g\\n}\\n\\nfunc gcd(a, b int64) int64 {\\n    for b != 0 {\\n        a, b = b, a%b\\n    }\\n    \\n    return a\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    \\n    return a\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// y = kx + b\\n// for 2 points: (x1, y1), (x2, y2) we have a system:\\n// y1 = kx1 + b\\n// y2 = kx2 + b\\n// y1 - y2 = kx1 + b - (kx2 + b) = k*(x1 - x2)\\n\\n// k = (y1 - y2) / (x1 - x2) = p / q\\n//\\n// y = kx + b => b = y - kx\\n// b = y1 - k * x1 = y1 - p/q * x1 = (q*y1 - x1*p) / q\\n\\n// So in order to identify a line we must have:\\n// k and b where k = p/q, b = (q*y1 - x1*p) / q. \\n//\\n// in our case it is enough to store: [p, q, (q*y1-x1*p)]\\n\\ntype Line struct {\\n    p, q, b int64\\n}\\n\\nfunc maxPoints(points [][]int) int {\\n    xGroup := make(map[int]int)\\n    yGroup := make(map[int]int)\\n    res := 0\\n    \\n    for i := 0; i < len(points); i++ {\\n        x, y := points[i][0], points[i][1]\\n        xGroup[x]++\\n        yGroup[y]++\\n        \\n        res = max(max(res, xGroup[x]), yGroup[y])\\n    }\\n    \\n    for i := 0; i < len(points); i++ {\\n        // we reserve self point as a duplicate\\n        lines := map[Line]int{}\\n        duplicates := 1\\n        \\n        for j := i + 1; j < len(points); j++ {\\n            a, b := points[i], points[j]\\n            \\n            if a[0] == b[0] && a[1] == b[1] {\\n                duplicates++\\n            }\\n        }\\n        \\n        for j := i + 1; j < len(points); j++ {\\n            a, b := points[i], points[j]\\n            \\n            if a[0] == b[0] || a[1] == b[1] {\\n                continue\\n            }\\n            \\n            p, q := getSlope(a, b)\\n            line := Line{p: p, q: q, b: q * int64(a[1]) - p * int64(a[0])}\\n            \\n            lines[line]++\\n            res = max(res, lines[line] + duplicates)\\n        }\\n    }\\n    \\n    return res\\n}\\n\\n// y = kx + b\\n// for 2 points: (x1, y1), (x2, y2) we have a system:\\n// y1 = kx1 + b\\n// y2 = kx2 + b\\n// y1 - y2 = kx1 + b - (kx2 + b) = k*(x1 - x2)\\n// k = (y1 - y2) / (x1 - x2)\\n// \\n// we return the numerator and denominator of the p/q = ((y1 - y2) / gcd) / ((x1 - x2) / gcd)\\n// we do this in order to normalize the fraction: here is an example\\n// 2/3 and 10/15, gcd(2,3) = 1, gcd(10,15) = 5\\n// 2/3 = 10/5 = 10/5/15/5 = 2/3\\nfunc getSlope(a, b []int) (int64, int64) {\\n    deltaX, deltaY := int64(a[0] - b[0]), int64(a[1] - b[1])\\n\\n    if deltaX < 0 {\\n        deltaX = -deltaX\\n        deltaY = -deltaY\\n    }\\n\\n    g := gcd(deltaX, deltaY)\\n    return deltaX / g, deltaY / g\\n}\\n\\nfunc gcd(a, b int64) int64 {\\n    for b != 0 {\\n        a, b = b, a%b\\n    }\\n    \\n    return a\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    \\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 901512,
                "title": "java-easy-solution",
                "content": "# class Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points == null )  return  0;\\n        int n= points.length;\\n         if(n <=2)  return  n;\\n         int res=0;\\n         Map<String,Integer> map = new HashMap<>();\\n         for(int i=0;i<n;i++){\\n             map.clear();\\n             int overlap =0,max=0;\\n             for(int  j=i+1;j<n;j++){\\n               int dx = points[j][0] - points[i][0];\\n               int dy = points[j][1]- points[i][1];\\n                if(dx ==0 && dy ==0){\\n                    overlap++;\\n                    continue;\\n                }\\n               int hcf = gcd (dx,dy);\\n               dx = dx/hcf;\\n               dy = dy/hcf;\\n               String key = dx+ \":\"+dy;\\n               map.put(key,map.getOrDefault(key,0)+1);\\n               max= Math.max(max,map.get(key));\\n             }\\n            res = Math.max(res,max+overlap+1);\\n         }\\n         return res;\\n    }\\n    private  static  int gcd(int a, int b ){\\n        if (b==0)\\n              return a;\\n        return  gcd(b,a%b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points == null )  return  0;\\n        int n= points.length;\\n         if(n <=2)  return  n;\\n         int res=0;\\n         Map<String,Integer> map = new HashMap<>();\\n         for(int i=0;i<n;i++){\\n             map.clear();\\n             int overlap =0,max=0;\\n             for(int  j=i+1;j<n;j++){\\n               int dx = points[j][0] - points[i][0];\\n               int dy = points[j][1]- points[i][1];\\n                if(dx ==0 && dy ==0){\\n                    overlap++;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 732420,
                "title": "cpp-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b)\\n    {\\n        if(b==0) return a;\\n        else return gcd(b,a%b);\\n    }\\n    int maxPoints(vector<vector<int>>& points) {\\n         int res=0,res2=0;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            int overlap=0,yaxis=0,curr=0;\\n            map<pair<int,int>,int> mp;\\n            for(int j=i+1;j<points.size();j++)\\n            {\\n                if(points[i]==points[j]) overlap++;\\n                else if(points[i][0]==points[j][0]) \\n                    yaxis++;\\n                else\\n                {\\n                    int x=(points[i][0]-points[j][0]);\\n                    int y=(points[i][1]-points[j][1]);\\n                    int g=__gcd(x,y); \\n                    mp[{x/g,y/g}]++;\\n                    curr=max(curr,mp[{x/g,y/g}]);\\n                    \\n                }\\n                curr=max(curr,yaxis);\\n                \\n            }\\n            \\n            res=max(res,curr+overlap+1);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b)\\n    {\\n        if(b==0) return a;\\n        else return gcd(b,a%b);\\n    }\\n    int maxPoints(vector<vector<int>>& points) {\\n         int res=0,res2=0;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            int overlap=0,yaxis=0,curr=0;\\n            map<pair<int,int>,int> mp;\\n            for(int j=i+1;j<points.size();j++)\\n            {\\n                if(points[i]==points[j]) overlap++;\\n                else if(points[i][0]==points[j][0]) \\n                    yaxis++;\\n                else\\n                {\\n                    int x=(points[i][0]-points[j][0]);\\n                    int y=(points[i][1]-points[j][1]);\\n                    int g=__gcd(x,y); \\n                    mp[{x/g,y/g}]++;\\n                    curr=max(curr,mp[{x/g,y/g}]);\\n                    \\n                }\\n                curr=max(curr,yaxis);\\n                \\n            }\\n            \\n            res=max(res,curr+overlap+1);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707099,
                "title": "java-sol",
                "content": "```\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length<3) return points.length;\\n        int maxres =0;\\n        //\\u904D\\u5386\\u6BCF\\u4E2A\\u70B9\\uFF0C\\u6C42\\u5176\\u548C\\u5176\\u4ED6\\u70B9\\u7EC4\\u6210\\u7684\\u76F4\\u7EBF\\u659C\\u7387\\n        for(int i =0; i< points.length; i++){\\n            int same = 0;//\\u662F\\u91CD\\u590D\\u7684\\u70B9\\n            int temp_max =0;//\\u5728\\u67D0\\u6761\\u76F4\\u7EBF\\u4E0A\\u7684\\u6700\\u591A\\u70B9\\u6570\\uFF08\\u5C40\\u90E8\\u6700\\u5927\\u503C\\uFF09;\\u6BCF\\u6362\\u4E00\\u4E2A\\u70B9\\uFF0C\\u5C31\\u5F52\\u96F6\\n            HashMap<String,Integer> map = new HashMap<>();//\\u5B58\\u8BE5\\u6761\\u7EBF\\u4E0A\\u7684\\u659C\\u7387\\u548C\\u4E2A\\u6570\\n            for(int j= 0; j< points.length; j++){\\n                if(i!=j){//\\u4E0D\\u80FD\\u81EA\\u5DF1\\u548C\\u81EA\\u5DF1\\n                    int dx = points[i][0] - points[j][0];//points[i][0]\\u7B2Ci\\u4E2A\\u70B9\\u7684\\uFF0Cindex\\u4E3A0\\u7684\\u6570\\u503C\\uFF0C\\u5373x\\u503C\\u3002\\n                    int dy = points[i][1] - points[j][1];\\n                    if(dx==0 && dy==0){\\n                        same++;\\n                        continue;\\n                    }\\n                    //\\u82E5\\u6709\\u659C\\u7387\\uFF0C\\u8FDB\\u884C\\u7EA6\\u5206\\n                    int gcd = gcd(dx,dy);\\n                    String key = dx/gcd +\"/\" + dy/gcd;\\n                    map.put(key,map.getOrDefault(key,0)+1);\\n                    temp_max = Math.max(temp_max, map.get(key));\\n                }               \\n            }\\n            //same \\u4EE3\\u8868\\u548C\\u5F53\\u524D\\u7684\\u70B9\\u91CD\\u590D\\u7684\\u70B9, 1\\u4EE3\\u8868\\u5F53\\u524D\\u70B9\\n            maxres = Math.max(maxres,temp_max+same+1);\\n        }\\n        return maxres;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        while(b!=0){\\n            int temp = a%b;\\n            a=b;\\n            b=temp;\\n        }\\n        return a;\\n    } \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if(points.length<3) return points.length;\\n        int maxres =0;\\n        //\\u904D\\u5386\\u6BCF\\u4E2A\\u70B9\\uFF0C\\u6C42\\u5176\\u548C\\u5176\\u4ED6\\u70B9\\u7EC4\\u6210\\u7684\\u76F4\\u7EBF\\u659C\\u7387\\n        for(int i =0; i< points.length; i++){\\n            int same = 0;//\\u662F\\u91CD\\u590D\\u7684\\u70B9\\n            int temp_max =0;//\\u5728\\u67D0\\u6761\\u76F4\\u7EBF\\u4E0A\\u7684\\u6700\\u591A\\u70B9\\u6570\\uFF08\\u5C40\\u90E8\\u6700\\u5927\\u503C\\uFF09;\\u6BCF\\u6362\\u4E00\\u4E2A\\u70B9\\uFF0C\\u5C31\\u5F52\\u96F6\\n            HashMap<String,Integer> map = new HashMap<>();//\\u5B58\\u8BE5\\u6761\\u7EBF\\u4E0A\\u7684\\u659C\\u7387\\u548C\\u4E2A\\u6570\\n            for(int j= 0; j< points.length; j++){\\n                if(i!=j){//\\u4E0D\\u80FD\\u81EA\\u5DF1\\u548C\\u81EA\\u5DF1\\n                    int dx = points[i][0] - points[j][0];//points[i][0]\\u7B2Ci\\u4E2A\\u70B9\\u7684\\uFF0Cindex\\u4E3A0\\u7684\\u6570\\u503C\\uFF0C\\u5373x\\u503C\\u3002\\n                    int dy = points[i][1] - points[j][1];\\n                    if(dx==0 && dy==0){\\n                        same++;\\n                        continue;\\n                    }\\n                    //\\u82E5\\u6709\\u659C\\u7387\\uFF0C\\u8FDB\\u884C\\u7EA6\\u5206\\n                    int gcd = gcd(dx,dy);\\n                    String key = dx/gcd +\"/\" + dy/gcd;\\n                    map.put(key,map.getOrDefault(key,0)+1);\\n                    temp_max = Math.max(temp_max, map.get(key));\\n                }               \\n            }\\n            //same \\u4EE3\\u8868\\u548C\\u5F53\\u524D\\u7684\\u70B9\\u91CD\\u590D\\u7684\\u70B9, 1\\u4EE3\\u8868\\u5F53\\u524D\\u70B9\\n            maxres = Math.max(maxres,temp_max+same+1);\\n        }\\n        return maxres;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        while(b!=0){\\n            int temp = a%b;\\n            a=b;\\n            b=temp;\\n        }\\n        return a;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699380,
                "title": "the-question-is-problematic-duplicate-points",
                "content": "I believe I solved the problem but failed on this test case: [[0,0],[1,1],[0,0]]\\n\\nMy algorithm didn\\'t consider the situation that duplicate point exists. Duplicate points don\\'t make any sense.\\n\\n\\'\\'\\'\\n\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)<=2:\\n            return len(points)\\n\\n        points = [(p[0],p[1]) for p in points]\\n\\n        def calcSlop(p1, p2):\\n            if p1[0]==p2[0]:\\n                return None\\n            else:\\n                return (p1[1]-p2[1])/(p1[0]-p2[0])\\n            \\n        lines = {calcSlop(points[0],points[1]):[{points[0],points[1]}]} # {slop: [line {points}]}\\n        visited = {points[0],points[1]}\\n\\n        for p in points[2:]:\\n            _visited = set()\\n            for pv in visited:\\n                if pv in _visited:\\n                    continue\\n                slop = calcSlop(p,pv)\\n                _processed = False\\n                if slop in lines:\\n                    for line in lines[slop]:\\n                        if pv in line:\\n                            line.add(p)\\n                            _visited = _visited.union(line)\\n                            _processed = True\\n                            break\\n                if not _processed:\\n                    if slop in lines:\\n                        lines[slop].append({p, pv})\\n                    else:\\n                        lines[slop] = [{p, pv}]\\n                _visited.add(pv)\\n            visited.add(p)\\n            \\n        max_lines = 0\\n        for lns in lines.values():\\n            for l in lns:\\n                if len(l) > max_lines:\\n                    max_lines = len(l)\\n        return max_lines\\n        \\n\\'\\'\\'",
                "solutionTags": [],
                "code": "I believe I solved the problem but failed on this test case: [[0,0],[1,1],[0,0]]\\n\\nMy algorithm didn\\'t consider the situation that duplicate point exists. Duplicate points don\\'t make any sense.\\n\\n\\'\\'\\'\\n\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)<=2:\\n            return len(points)\\n\\n        points = [(p[0],p[1]) for p in points]\\n\\n        def calcSlop(p1, p2):\\n            if p1[0]==p2[0]:\\n                return None\\n            else:\\n                return (p1[1]-p2[1])/(p1[0]-p2[0])\\n            \\n        lines = {calcSlop(points[0],points[1]):[{points[0],points[1]}]} # {slop: [line {points}]}\\n        visited = {points[0],points[1]}\\n\\n        for p in points[2:]:\\n            _visited = set()\\n            for pv in visited:\\n                if pv in _visited:\\n                    continue\\n                slop = calcSlop(p,pv)\\n                _processed = False\\n                if slop in lines:\\n                    for line in lines[slop]:\\n                        if pv in line:\\n                            line.add(p)\\n                            _visited = _visited.union(line)\\n                            _processed = True\\n                            break\\n                if not _processed:\\n                    if slop in lines:\\n                        lines[slop].append({p, pv})\\n                    else:\\n                        lines[slop] = [{p, pv}]\\n                _visited.add(pv)\\n            visited.add(p)\\n            \\n        max_lines = 0\\n        for lns in lines.values():\\n            for l in lns:\\n                if len(l) > max_lines:\\n                    max_lines = len(l)\\n        return max_lines\\n        \\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 620863,
                "title": "java-clean-code-for-a-horrible-question",
                "content": "```java\\npublic int maxPoints(int[][] points) {\\n\\tif (points == null || points.length == 0) return 0;\\n\\n\\tint n = points.length;\\n\\tif (n < 2) return n;\\n\\n\\tSet<String> seen = new HashSet<>();\\n\\tint max = 1;\\n\\n\\tfor (int i = 0; i < n && !seen.contains(points[i][0] + \"-\" + points[i][1]); i++) {\\n\\n\\t\\tint[] a = points[i];\\n\\n\\t\\tint same = 0;\\n\\t\\tMap<Double, Integer> map = new HashMap<>();\\n\\t\\tint localMax = 1;\\n\\n\\t\\tfor (int j = i + 1; j < n; j++) {\\n\\t\\t\\tif (isSame(a, points[j])) {\\n\\t\\t\\t\\tsame++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdouble slope = getSlope(a, points[j]);\\n\\t\\t\\tmap.put(slope, map.getOrDefault(slope, 1) + 1);\\n\\t\\t\\tlocalMax = Math.max(localMax, map.get(slope));\\n\\t\\t}\\n\\n\\t\\tseen.add(a[0] + \"-\" + a[1]);\\n\\t\\tmax = Math.max(max, localMax + same);\\n\\t}\\n\\n\\treturn max;\\n}\\n\\nprivate boolean isSame(int[] a, int[] b) {\\n\\treturn a[0] == b[0] && a[1] == b[1];\\n}\\n\\nprivate double getSlope(int[] a, int[] b) {\\n\\tif (a[0] == b[0]) return Double.MAX_VALUE;\\n\\tif (a[1] == b[1]) return 0;\\n\\treturn ((double) b[0] - a[0]) / ((double) b[1] - a[1]);\\n}",
                "solutionTags": [],
                "code": "```java\\npublic int maxPoints(int[][] points) {\\n\\tif (points == null || points.length == 0) return 0;\\n\\n\\tint n = points.length;\\n\\tif (n < 2) return n;\\n\\n\\tSet<String> seen = new HashSet<>();\\n\\tint max = 1;\\n\\n\\tfor (int i = 0; i < n && !seen.contains(points[i][0] + \"-\" + points[i][1]); i++) {\\n\\n\\t\\tint[] a = points[i];\\n\\n\\t\\tint same = 0;\\n\\t\\tMap<Double, Integer> map = new HashMap<>();\\n\\t\\tint localMax = 1;\\n\\n\\t\\tfor (int j = i + 1; j < n; j++) {\\n\\t\\t\\tif (isSame(a, points[j])) {\\n\\t\\t\\t\\tsame++;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdouble slope = getSlope(a, points[j]);\\n\\t\\t\\tmap.put(slope, map.getOrDefault(slope, 1) + 1);\\n\\t\\t\\tlocalMax = Math.max(localMax, map.get(slope));\\n\\t\\t}\\n\\n\\t\\tseen.add(a[0] + \"-\" + a[1]);\\n\\t\\tmax = Math.max(max, localMax + same);\\n\\t}\\n\\n\\treturn max;\\n}\\n\\nprivate boolean isSame(int[] a, int[] b) {\\n\\treturn a[0] == b[0] && a[1] == b[1];\\n}\\n\\nprivate double getSlope(int[] a, int[] b) {\\n\\tif (a[0] == b[0]) return Double.MAX_VALUE;\\n\\tif (a[1] == b[1]) return 0;\\n\\treturn ((double) b[0] - a[0]) / ((double) b[1] - a[1]);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 522413,
                "title": "simple-python-solution-100-memory-efficent",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def helper(currentPoint, points):\\n            slopes,duplicates,ans = {},0,0\\n            x1, y1 = currentPoint\\n            for x2, y2 in points:\\n                # If the points are same inc duplicate counter\\n                if x1 == x2 and y1 == y2:\\n                    duplicates += 1\\n                # else find the slop and add in dic\\n                else:\\n                    slope = (x2 - x1) / (y2 - y1) if y2 != y1 else \\'inf\\'\\n                    count = slopes.get(slope, 0) + 1\\n                    slopes[slope] = count\\n                    ans = max(ans, count)\\n            return ans + 1 + duplicates\\n        ans = 0\\n        while points:\\n            currentPoint = points.pop()\\n            ans = max(ans, helper(currentPoint, points))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def helper(currentPoint, points):\\n            slopes,duplicates,ans = {},0,0\\n            x1, y1 = currentPoint\\n            for x2, y2 in points:\\n                # If the points are same inc duplicate counter\\n                if x1 == x2 and y1 == y2:\\n                    duplicates += 1\\n                # else find the slop and add in dic\\n                else:\\n                    slope = (x2 - x1) / (y2 - y1) if y2 != y1 else \\'inf\\'\\n                    count = slopes.get(slope, 0) + 1\\n                    slopes[slope] = count\\n                    ans = max(ans, count)\\n            return ans + 1 + duplicates\\n        ans = 0\\n        while points:\\n            currentPoint = points.pop()\\n            ans = max(ans, helper(currentPoint, points))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486725,
                "title": "python-3-fourteen-lines-beats-94",
                "content": "```\\nclass Solution:\\n    def maxPoints(self, P: List[List[int]]) -> int:\\n        L, M, gcd = len(P), 1, math.gcd\\n        for i,(x1,y1) in enumerate(P):\\n            s, D = 1, collections.defaultdict(int, {0:0})\\n            for (x2,y2) in P[i+1:]:\\n                g = gcd(y2-y1, x2-x1)\\n                if g == 0:\\n                    s += 1\\n                    continue\\n                m = ((y2-y1)//g, (x2-x1)//g)\\n                if m[1] == 0: m = (1,0)\\n                if m[1] < 0: m = (-m[0],-m[1])\\n                D[m] += 1\\n            M = max(M, s + max(D.values()))\\n        return M if P else 0\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def maxPoints(self, P: List[List[int]]) -> int:\\n        L, M, gcd = len(P), 1, math.gcd\\n        for i,(x1,y1) in enumerate(P):\\n            s, D = 1, collections.defaultdict(int, {0:0}",
                "codeTag": "Java"
            },
            {
                "id": 312508,
                "title": "python3-clean-solution",
                "content": "```\\nfrom math import gcd\\nfrom collections import Counter\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points) < 2: return len(points)\\n        points = [tuple(x) for x in points]\\n        P = Counter(points)\\n        def slop(p1, p2):\\n            dx, dy = p2[0]-p1[0], p2[1]-p1[1]\\n            if dx == 0: return (0, 1)\\n            if dy == 0: return (1, 0)\\n            if dx < 0:\\n                dx = -dx\\n                dy = -dy\\n            g = gcd(dx, dy)\\n            return (dx//g, dy//g)\\n        lines = [Counter() for _ in range(len(points))]\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                if points[j] == points[i]: continue\\n                k = slop(points[j], points[i])\\n                lines[i][k] += 1\\n                lines[j][k] += 1\\n        ans = 0\\n        for i, l in enumerate(lines):\\n            ans = max(ans, max(l.values(), default = 0) + P[points[i]])\\n        return ans\\n                \\n        \\n            \\n            \\n",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nfrom collections import Counter\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points) < 2: return len(points)\\n        points = [tuple(x) for x in points]\\n        P = Counter(points)\\n        def slop(p1, p2):\\n            dx, dy = p2[0]-p1[0], p2[1]-p1[1]\\n            if dx == 0: return (0, 1)\\n            if dy == 0: return (1, 0)\\n            if dx < 0:\\n                dx = -dx\\n                dy = -dy\\n            g = gcd(dx, dy)\\n            return (dx//g, dy//g)\\n        lines = [Counter() for _ in range(len(points))]\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                if points[j] == points[i]: continue\\n                k = slop(points[j], points[i])\\n                lines[i][k] += 1\\n                lines[j][k] += 1\\n        ans = 0\\n        for i, l in enumerate(lines):\\n            ans = max(ans, max(l.values(), default = 0) + P[points[i]])\\n        return ans\\n                \\n        \\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 309382,
                "title": "wrong-bad-test-case-why-should-0-0-1-1-0-0-return-3",
                "content": "as per the submission result\\n```\\n[[0,0],[1,1],[0,0]]\\n```\\nshould result 3, but isnt point 0,0 is duplicated, how does it even make sense to output 3?",
                "solutionTags": [],
                "code": "```\\n[[0,0],[1,1],[0,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299085,
                "title": "explanation",
                "content": "> What are points `lie on the same straight line` like?\\n> \\n>The ratio of the \"vertical change\" to the \"horizontal change\" between (any) two distinct points on a line is identical, which is called **slope**. \\n\\n> For each point i, itself and another point j can identify a line, resulting in a slope. \\n> We map a slope to its frequency. Finally, frequency + 1 is the number of points on the line with the `slope`.\\n> \\n> As for the slope, we need to transfer it to a fraction in lowest terms.\\n\\n> Since `from point i to j`, and `from point j to i` is the same line. We can start j from i + 1.\\n\\n> There may be points overlapping with i. We maintain `overlap` and add it to total points at last.\\n```\\n    public int maxPoints(int[][] points) {\\n        if (points.length == 0) {\\n            return 0;\\n        }\\n        \\n        // Maximum points among slopes\\n        int max = 0;\\n        // Map slope to its frequency\\n        Map<String, Integer> kToFreq;\\n        \\n        for (int i = 0; i < points.length; i++) { // For each point i\\n            kToFreq = new HashMap<>(); \\n            int overlap = 0; // The number of points overlap with i\\n            \\n            for (int j = i + 1; j < points.length; j++) { // For each point j\\n                \\n                int yDiff = points[j][1] - points[i][1];\\n                int xDiff = points[j][0] - points[i][0];\\n                \\n                if (xDiff == 0 && yDiff == 0) { // Point j overlaps point i\\n                    overlap++;\\n                } else if (xDiff == 0) { // Point j and i are parallel\\n                    kToFreq.put(\"Max\", kToFreq.getOrDefault(\"Max\", 0) + 1);\\n                } else {\\n                    int sign = \\n                        ((xDiff > 0 && yDiff > 0) || (xDiff < 0 && yDiff < 0)) ? 1 : -1;\\n                    xDiff = Math.abs(xDiff);\\n                    yDiff = Math.abs(yDiff);\\n                    int gcd = getGCD(xDiff, yDiff);\\n                    String k = sign + \" \" + xDiff / gcd  + \"/\" + yDiff / gcd;\\n                    kToFreq.put(k, kToFreq.getOrDefault(k, 0) + 1);\\n                }\\n            }\\n            \\n            // Update max with max value in current map\\n            int curMax = 0;\\n            for (int freq : kToFreq.values()) {\\n                curMax = Math.max(curMax, freq);\\n            }\\n            max = Math.max(curMax + overlap + 1, max);\\n        }\\n        \\n        return max;\\n    }\\n\\n    private int getGCD(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return getGCD(b, a % b);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxPoints(int[][] points) {\\n        if (points.length == 0) {\\n            return 0;\\n        }\\n        \\n        // Maximum points among slopes\\n        int max = 0;\\n        // Map slope to its frequency\\n        Map<String, Integer> kToFreq;\\n        \\n        for (int i = 0; i < points.length; i++) { // For each point i\\n            kToFreq = new HashMap<>(); \\n            int overlap = 0; // The number of points overlap with i\\n            \\n            for (int j = i + 1; j < points.length; j++) { // For each point j\\n                \\n                int yDiff = points[j][1] - points[i][1];\\n                int xDiff = points[j][0] - points[i][0];\\n                \\n                if (xDiff == 0 && yDiff == 0) { // Point j overlaps point i\\n                    overlap++;\\n                } else if (xDiff == 0) { // Point j and i are parallel\\n                    kToFreq.put(\"Max\", kToFreq.getOrDefault(\"Max\", 0) + 1);\\n                } else {\\n                    int sign = \\n                        ((xDiff > 0 && yDiff > 0) || (xDiff < 0 && yDiff < 0)) ? 1 : -1;\\n                    xDiff = Math.abs(xDiff);\\n                    yDiff = Math.abs(yDiff);\\n                    int gcd = getGCD(xDiff, yDiff);\\n                    String k = sign + \" \" + xDiff / gcd  + \"/\" + yDiff / gcd;\\n                    kToFreq.put(k, kToFreq.getOrDefault(k, 0) + 1);\\n                }\\n            }\\n            \\n            // Update max with max value in current map\\n            int curMax = 0;\\n            for (int freq : kToFreq.values()) {\\n                curMax = Math.max(curMax, freq);\\n            }\\n            max = Math.max(curMax + overlap + 1, max);\\n        }\\n        \\n        return max;\\n    }\\n\\n    private int getGCD(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return getGCD(b, a % b);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275997,
                "title": "java-o-n-2-solution",
                "content": "Explanation: For each line (of the form y=Ax+B) delimited by two points, use the A and B as indexes of a Map<String,Set<int[]>>. Their numerator and denominator are used to avoid precision loss, they are also simplified with GCD. At the end, go through every set count the max number of points in a line. \\n\\nEdge cases: when two points are on the same X, a key of the form \"x-<value>\" is used.\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        Map<String,Set<int[]>> count = new HashMap<String,Set<int[]>>();\\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i+1; j < points.length; j++) {\\n                if (points[i][0] == points[j][0]) {\\n                    String key = String.format(\"x-%d\",points[j][0]);\\n                    if(!count.containsKey(key)) {\\n                        count.put(key, new HashSet<int[]>());\\n                    }\\n                    count.get(key).add(points[i]);\\n                    count.get(key).add(points[j]);\\n                } else {\\n                    String key = getFunc(points[i],points[j]);\\n                    if(!count.containsKey(key)) {\\n                        count.put(key, new HashSet<int[]>());\\n                    }\\n                    count.get(key).add(points[i]);\\n                    count.get(key).add(points[j]);\\n                }\\n            }\\n        }\\n        int max = points.length > 0 ? 1 : 0;\\n        for(Set<int[]> values : count.values()) {\\n            max = Math.max(max,values.size());\\n        }\\n        return max;\\n    }\\n    private String getFunc(int[] p1, int[] p2) {\\n        int aNum = p1[1]-p2[1];\\n        int aDen = p1[0]-p2[0];\\n        int gcdA = gcd(aNum,aDen);\\n        aNum /= gcdA;\\n        aDen /= gcdA;\\n        int bNum = (aDen*p1[1]) - (aNum*p1[0]);\\n        int bDen = aDen;\\n        int gcdB = gcd(bNum,bDen);\\n        bNum /= gcdB;\\n        bDen /= gcdB;\\n        return String.format(\"%d/%d-%d/%d\",aNum,aDen,bNum,bDen);\\n    }\\n    private int gcd(int a, int b) {\\n        if (b==0) return a;\\n        else return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        Map<String,Set<int[]>> count = new HashMap<String,Set<int[]>>();\\n        for(int i = 0; i < points.length; i++) {\\n            for(int j = i+1; j < points.length; j++) {\\n                if (points[i][0] == points[j][0]) {\\n                    String key = String.format(\"x-%d\",points[j][0]);\\n                    if(!count.containsKey(key)) {\\n                        count.put(key, new HashSet<int[]>());\\n                    }\\n                    count.get(key).add(points[i]);\\n                    count.get(key).add(points[j]);\\n                } else {\\n                    String key = getFunc(points[i],points[j]);\\n                    if(!count.containsKey(key)) {\\n                        count.put(key, new HashSet<int[]>());\\n                    }\\n                    count.get(key).add(points[i]);\\n                    count.get(key).add(points[j]);\\n                }\\n            }\\n        }\\n        int max = points.length > 0 ? 1 : 0;\\n        for(Set<int[]> values : count.values()) {\\n            max = Math.max(max,values.size());\\n        }\\n        return max;\\n    }\\n    private String getFunc(int[] p1, int[] p2) {\\n        int aNum = p1[1]-p2[1];\\n        int aDen = p1[0]-p2[0];\\n        int gcdA = gcd(aNum,aDen);\\n        aNum /= gcdA;\\n        aDen /= gcdA;\\n        int bNum = (aDen*p1[1]) - (aNum*p1[0]);\\n        int bDen = aDen;\\n        int gcdB = gcd(bNum,bDen);\\n        bNum /= gcdB;\\n        bDen /= gcdB;\\n        return String.format(\"%d/%d-%d/%d\",aNum,aDen,bNum,bDen);\\n    }\\n    private int gcd(int a, int b) {\\n        if (b==0) return a;\\n        else return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247110,
                "title": "rust-concise-o-n-2-solution-0-ms-with-explanation",
                "content": "```rust\\n/*\\n   straight-line expression: Ax + By + C = 0, given two points (x1,y1) and (x2,y2), then,\\n      A = y2 - y1, B = x1 - x2, C = x2y1 - x1y2\\n   (notice that A == 0 && B == 0 indicated that the given points is same)\\n   \\n   With this expression, We can express any straight-line using a 3-Tuple, this basic idea is \\n   for each points pair consists a line, we test if rest points are in this line, then we get an O(N^3)\\n   algorithm (Brute force). \\n   \\n   To optimize, introduce a HashSet to record the evaluated expressions, we get the O(N^2) solution.\\n   \\n   Moreover, take care of the following caveats in the test cases:\\n   \\n   1. some test cases cause i32 calucation overflow, so the code use i64 for line expression;\\n   2. some points contains same points, if we solve them in the loop, the worse case will be O(N^3), so we fold the same points before the main loop;\\n   3. Point do not implement the Hash trait, use 2-Tuple as intermidate data-structure during folding.\\n */\\n#[derive(PartialEq,Hash,Eq,Debug)]\\nstruct Line(i64, i64, i64);\\n\\nimpl Line {\\n    // Assumes that there is no same point\\n    fn new(p1: &Point, p2: &Point) -> Self {\\n        let x1 = p1.x as i64;\\n        let x2 = p2.x as i64;\\n        let y1 = p1.y as i64;\\n        let y2 = p2.y as i64;\\n        Line(y2-y1, x1-x2,  x2*y1 - x1*y2)\\n    }\\n    fn contains(&self, p: &Point) -> bool {\\n        self.0 * p.x as i64 + self.1 * p.y as i64 + self.2 == 0_i64\\n    }\\n}\\n\\nuse std::collections::HashSet;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn max_points(points: Vec<Point>) -> i32 {\\n        // fold same point, record the point count\\n        let points: Vec<(Point, i32)> = points.into_iter()\\n            .fold(HashMap::new(), |mut map, v| {\\n                *map.entry((v.x, v.y)).or_insert(0) += 1; map\\n            })\\n            .into_iter()\\n            .map(|(k,v)| { (Point::new(k.0, k.1), v) }) // Point did not implement Hash trait\\n            .collect();\\n\\n        // any two points in a straight-line, return quickly\\n        if points.len() < 3 {\\n            return points.into_iter().fold(0, |acc, v| { acc + v.1 });\\n        }\\n        let mut max = 2;\\n        let mut set: HashSet<Line> = HashSet::new();\\n        for i in 0..(points.len()-1) {\\n            for j in i+1..points.len() {\\n                let line = Line::new(&points[i].0, &points[j].0);\\n                if set.contains(&line) {\\n                    continue;\\n                }\\n                let mut curr = points[i].1 + points[j].1;\\n                for k in j+1..points.len() {\\n                    if line.contains(&points[k].0) {\\n                        curr += points[k].1;\\n                    }\\n                }\\n                max = i32::max(max, curr);\\n            }\\n        }\\n        max\\n    }\\n}\\n```\\n\\n\\u4E2D\\u6587\\uFF1A\\n\\u8981\\u56DE\\u987E\\u4E0B\\u9AD8\\u4E2D\\u6570\\u5B66\\uFF1A\\u5DF2\\u77E5\\u4E24\\u70B9, \\u6C42\\u89E3\\u4E00\\u822C\\u5F0F:\\n  \\n   * Ax + By + C = 0\\n   * A = y2 - y1, B = x1 - x2, C = x2y1 - x1y2\\n\\n \\u6709\\u8FD9\\u4E2A\\u77E5\\u8BC6\\u4E4B\\u540E\\uFF0C\\u5316\\u4E3A\\u4E00\\u822C\\u5F0F\\uFF0C\\u505A\\u4E09\\u5C42\\u904D\\u5386\\u5C31\\u884C\\uFF0C\\u518D\\u52A0\\u4E0A\\u4E00\\u4E2A HashSet\\uFF0C\\u907F\\u514D\\u5BF9\\u540C\\u4E00\\u76F4\\u7EBF\\u4E0A\\u70B9\\u7684\\u91CD\\u590D\\u8BA1\\u7B97\\uFF0C\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u53EF\\u4EE5\\u662F O(N^2)\\n \\n \\u6709\\u4E24\\u4E2A\\u5751\\u8981\\u6CE8\\u610F\\u907F\\u514D\\uFF1A\\n \\n   * \\u7ED9\\u7684 case \\u4F1A\\u5BFC\\u81F4 i32 \\u6EA2\\u51FA\\uFF0C\\u8FD9\\u91CC\\u76F4\\u63A5\\u7528\\u4E86 i64 \\u8868\\u793A\\n   * \\u7ED9\\u7684 case \\u91CC\\u6709\\u76F8\\u540C\\u7684\\u70B9\\uFF0C\\u76F4\\u63A5\\u5904\\u7406\\u76F8\\u540C\\u70B9\\u7684\\u8BDD\\u4F1A\\u5BFC\\u81F4\\u6700\\u574F\\u60C5\\u51B5\\u590D\\u6742\\u5EA6\\u5230 O(N^3)\\uFF0C\\u56E0\\u6B64\\u8981\\u5148\\u505A\\u4E00\\u6B21\\u8F6C\\u5316\\uFF0C\\u5F52\\u5E76\\u76F8\\u540C\\u7684\\u70B9\\n\\n \\u7528 Rust \\u5B9E\\u73B0\\u6709\\u53E6\\u4E00\\u70B9\\u6CE8\\u610F\\u7684\\uFF0C\\u7ED9\\u7684 Point \\u6CA1\\u6709\\u5B9E\\u73B0 Hash Trait\\uFF0C\\u8981\\u81EA\\u5DF1\\u8F6C\\u5316\\u4E00\\u4E0B",
                "solutionTags": [],
                "code": "```rust\\n/*\\n   straight-line expression: Ax + By + C = 0, given two points (x1,y1) and (x2,y2), then,\\n      A = y2 - y1, B = x1 - x2, C = x2y1 - x1y2\\n   (notice that A == 0 && B == 0 indicated that the given points is same)\\n   \\n   With this expression, We can express any straight-line using a 3-Tuple, this basic idea is \\n   for each points pair consists a line, we test if rest points are in this line, then we get an O(N^3)\\n   algorithm (Brute force). \\n   \\n   To optimize, introduce a HashSet to record the evaluated expressions, we get the O(N^2) solution.\\n   \\n   Moreover, take care of the following caveats in the test cases:\\n   \\n   1. some test cases cause i32 calucation overflow, so the code use i64 for line expression;\\n   2. some points contains same points, if we solve them in the loop, the worse case will be O(N^3), so we fold the same points before the main loop;\\n   3. Point do not implement the Hash trait, use 2-Tuple as intermidate data-structure during folding.\\n */\\n#[derive(PartialEq,Hash,Eq,Debug)]\\nstruct Line(i64, i64, i64);\\n\\nimpl Line {\\n    // Assumes that there is no same point\\n    fn new(p1: &Point, p2: &Point) -> Self {\\n        let x1 = p1.x as i64;\\n        let x2 = p2.x as i64;\\n        let y1 = p1.y as i64;\\n        let y2 = p2.y as i64;\\n        Line(y2-y1, x1-x2,  x2*y1 - x1*y2)\\n    }\\n    fn contains(&self, p: &Point) -> bool {\\n        self.0 * p.x as i64 + self.1 * p.y as i64 + self.2 == 0_i64\\n    }\\n}\\n\\nuse std::collections::HashSet;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn max_points(points: Vec<Point>) -> i32 {\\n        // fold same point, record the point count\\n        let points: Vec<(Point, i32)> = points.into_iter()\\n            .fold(HashMap::new(), |mut map, v| {\\n                *map.entry((v.x, v.y)).or_insert(0) += 1; map\\n            })\\n            .into_iter()\\n            .map(|(k,v)| { (Point::new(k.0, k.1), v) }) // Point did not implement Hash trait\\n            .collect();\\n\\n        // any two points in a straight-line, return quickly\\n        if points.len() < 3 {\\n            return points.into_iter().fold(0, |acc, v| { acc + v.1 });\\n        }\\n        let mut max = 2;\\n        let mut set: HashSet<Line> = HashSet::new();\\n        for i in 0..(points.len()-1) {\\n            for j in i+1..points.len() {\\n                let line = Line::new(&points[i].0, &points[j].0);\\n                if set.contains(&line) {\\n                    continue;\\n                }\\n                let mut curr = points[i].1 + points[j].1;\\n                for k in j+1..points.len() {\\n                    if line.contains(&points[k].0) {\\n                        curr += points[k].1;\\n                    }\\n                }\\n                max = i32::max(max, curr);\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192288,
                "title": "very-easy-to-understand-java-code-with-a-lot-of-documentation",
                "content": "# Intro\\nIn order to get the count of points on the same line we\\'ll go through all points and compare them with the rest.\\n - We\\'ll refer to our point that will be compared to all others the **basePoint**\\n - We\\'ll every other point **secondPoint**\\n\\n# How does it work?\\n - in case the point is identical (same x and same y), then it\\'s also on the same vertical, horizontal and the same slope.\\n - remember when comparing to include the **basePoint** in your total, and include it **only once** in comparison \\n - for each basePoint create a Map to collect other points that lay on the same slope.\\n - don\\'t forget to reset the slopes map after each iteration.\\n\\n# Big O\\nfor each point in **N Points** you need to do **(N - 1) iterations ~= O(N)**\\ntime: **O(N^2)**  \\nyou need to create a map of worst case size O(N - 1) ~= O(N)\\nspace: **O(N)** \\n\\n```\\n    public int maxPoints(Point[] points) {\\n        if (points.length < 2) return points.length;\\n        int maxPoints = 0;\\n        HashMap<Double,Integer> slopes = new HashMap<>();\\n        double slope;\\n        int horizontal, vertical, identical;\\n        int count;\\n        int basePoint = 1; // just helper to understand the code below\\n        for (Point base: points) {\\n          identical = 0;\\n          vertical = 0;\\n          horizontal = 0;\\n          for (Point second: points) {\\n              if (base == second) continue;\\n              // identical point\\n              if (base.x == second.x && base.y == second.y) {\\n                identical++; // remember identical is horiz. vertical. and same slope (count it in all cases)\\n              // on the same vertical line\\n              } else if (base.x == second.x) {\\n                vertical++;\\n              // on the same horizontal line\\n              } else if (base.y == second.y) {\\n                horizontal++;\\n              // on a specific slope\\n              } else {\\n                slope = (double)(base.x - second.x)/(base.y - second.y); // calculate the slope\\n                count = slopes.getOrDefault(slope, 0) + 1; // get old count in addition to this one\\n                slopes.put(slope, count); // save the new slope\\n                maxPoints = Math.max(maxPoints, count + basePoint + identical); // compare the count + the base point + all identicals\\n              }              \\n          }\\n          maxPoints = Math.max(maxPoints, basePoint + horizontal + identical); // compare all horiz. + all identicals\\n          maxPoints = Math.max(maxPoints, basePoint + vertical + identical); // compare all vert. + all identicals\\n          slopes.clear();\\n        }\\n        \\n        return maxPoints;\\n    }\\n```\\n\\n# Follow up:\\nIn case of anything incorrectly mentioned here, please comment and I\\'ll adjust it.",
                "solutionTags": [],
                "code": "```\\n    public int maxPoints(Point[] points) {\\n        if (points.length < 2) return points.length;\\n        int maxPoints = 0;\\n        HashMap<Double,Integer> slopes = new HashMap<>();\\n        double slope;\\n        int horizontal, vertical, identical;\\n        int count;\\n        int basePoint = 1; // just helper to understand the code below\\n        for (Point base: points) {\\n          identical = 0;\\n          vertical = 0;\\n          horizontal = 0;\\n          for (Point second: points) {\\n              if (base == second) continue;\\n              // identical point\\n              if (base.x == second.x && base.y == second.y) {\\n                identical++; // remember identical is horiz. vertical. and same slope (count it in all cases)\\n              // on the same vertical line\\n              } else if (base.x == second.x) {\\n                vertical++;\\n              // on the same horizontal line\\n              } else if (base.y == second.y) {\\n                horizontal++;\\n              // on a specific slope\\n              } else {\\n                slope = (double)(base.x - second.x)/(base.y - second.y); // calculate the slope\\n                count = slopes.getOrDefault(slope, 0) + 1; // get old count in addition to this one\\n                slopes.put(slope, count); // save the new slope\\n                maxPoints = Math.max(maxPoints, count + basePoint + identical); // compare the count + the base point + all identicals\\n              }              \\n          }\\n          maxPoints = Math.max(maxPoints, basePoint + horizontal + identical); // compare all horiz. + all identicals\\n          maxPoints = Math.max(maxPoints, basePoint + vertical + identical); // compare all vert. + all identicals\\n          slopes.clear();\\n        }\\n        \\n        return maxPoints;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183843,
                "title": "strange-c-o-n-3-but-beats-99-75",
                "content": "Idea is just check every point triplet whether they form a 0 area triangle. As a result, no float introduced. It is O(n^3) but still beats 99.75% which is quite strange...\\n\\n```\\nstruct myHash {\\n    size_t operator()(const Point& p) const {\\n        return hash<int>()(p.x)^hash<int>()(p.y);\\n    }\\n};\\n\\nstruct myEq {\\n    bool operator()(const Point& p1, const Point& p2) const {\\n        return p1.x == p2.x && p1.y == p2.y;\\n    }\\n};\\n\\nclass Solution {\\n    inline long long area2(int i, int j, int k, vector<pair<Point,int>>& points) {\\n        return static_cast<long long>(points[i].first.x)*static_cast<long long>(points[j].first.y)\\n              -static_cast<long long>(points[i].first.y)*static_cast<long long>(points[j].first.x)\\n              +static_cast<long long>(points[j].first.x)*static_cast<long long>(points[k].first.y)\\n              -static_cast<long long>(points[j].first.y)*static_cast<long long>(points[k].first.x)\\n              +static_cast<long long>(points[k].first.x)*static_cast<long long>(points[i].first.y)\\n              -static_cast<long long>(points[k].first.y)*static_cast<long long>(points[i].first.x);\\n    }\\npublic:\\n    int maxPoints(vector<Point>& pts) {\\n        unordered_map<Point, int, myHash, myEq> ps;\\n        for (auto& p : pts) ps[p]++;\\n        int res = 0, n = ps.size();\\n        if (n < 3) return pts.size();\\n        vector<pair<Point, int>> points(ps.begin(), ps.end());\\n        for (int i = 0; i < n-2; ++i)\\n            for (int j = i+1; j < n-1; ++j) {\\n                int count = points[i].second+points[j].second;\\n                res = max(res, count);\\n                for (int k = j+1; k < n; ++k) \\n                    if (area2(i, j, k, points) == 0) {\\n                        count += points[k].second;\\n                        res = max(res, count);\\n                    }\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct myHash {\\n    size_t operator()(const Point& p) const {\\n        return hash<int>()(p.x)^hash<int>()(p.y);\\n    }\\n};\\n\\nstruct myEq {\\n    bool operator()(const Point& p1, const Point& p2) const {\\n        return p1.x == p2.x && p1.y == p2.y;\\n    }\\n};\\n\\nclass Solution {\\n    inline long long area2(int i, int j, int k, vector<pair<Point,int>>& points) {\\n        return static_cast<long long>(points[i].first.x)*static_cast<long long>(points[j].first.y)\\n              -static_cast<long long>(points[i].first.y)*static_cast<long long>(points[j].first.x)\\n              +static_cast<long long>(points[j].first.x)*static_cast<long long>(points[k].first.y)\\n              -static_cast<long long>(points[j].first.y)*static_cast<long long>(points[k].first.x)\\n              +static_cast<long long>(points[k].first.x)*static_cast<long long>(points[i].first.y)\\n              -static_cast<long long>(points[k].first.y)*static_cast<long long>(points[i].first.x);\\n    }\\npublic:\\n    int maxPoints(vector<Point>& pts) {\\n        unordered_map<Point, int, myHash, myEq> ps;\\n        for (auto& p : pts) ps[p]++;\\n        int res = 0, n = ps.size();\\n        if (n < 3) return pts.size();\\n        vector<pair<Point, int>> points(ps.begin(), ps.end());\\n        for (int i = 0; i < n-2; ++i)\\n            for (int j = i+1; j < n-1; ++j) {\\n                int count = points[i].second+points[j].second;\\n                res = max(res, count);\\n                for (int k = j+1; k < n; ++k) \\n                    if (area2(i, j, k, points) == 0) {\\n                        count += points[k].second;\\n                        res = max(res, count);\\n                    }\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47099,
                "title": "o-n-2-solution-with-explanation-of-all-steps",
                "content": "A simpler version of previous solutions given below. \\n\\n```\\n// https://leetcode.com/problems/max-points-on-a-line/description/\\n\\n/**\\n * Definition for a point.\\n * class Point {\\n *     int x;\\n *     int y;\\n *     Point() { x = 0; y = 0; }\\n *     Point(int a, int b) { x = a; y = b; }\\n * }\\n */\\nclass Solution {\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    private String getSlope(Point a, Point b) {\\n        int Y = b.y - a.y;\\n        int X = b.x - a.x;\\n        \\n        // Ensure a != b for below hacks to work\\n        // basically either it should be a vertical\\n        // line or a horizontal line and a and b\\n        // should be distinct points\\n        \\n        // hack for horizontal line point\\n        if (Y == 0)\\n            X = 1;\\n        \\n        // hack for vertical line point\\n        if (X == 0)\\n            Y = 1;\\n        \\n        // follow convention of -ve numerator\\n        // and +ve denominator so that -1/2 is same as 1/-2\\n        // for considering lines with same slopes\\n        if ((X < 0 && Y > 0) || (X < 0 && Y < 0)) {\\n            X = -X;\\n            Y = -Y;\\n        }\\n        \\n        // gcd can be calculated only for +ve numbers\\n        int g = gcd(Math.abs(X), Math.abs(Y));\\n        Y /= g;\\n        X /= g;\\n        \\n        return Y + \" \" + X;     // return slope as a pair of numerator, denominator\\n    }\\n    \\n    public int maxPoints(Point[] points) {\\n        if (points == null)\\n            return 0;\\n        if (points.length <= 2)\\n            return points.length;\\n        \\n        // track line segements in hashmap\\n        Map<String, Integer> map = new HashMap<>();\\n        int maxpt = 2;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            int samePoint = 0;\\n            int currMax = 0;\\n        \\n            for (int j = i + 1; j < points.length; j++) {\\n                \\n                if (points[i].x == points[j].x && points[i].y == points[j].y)\\n                    samePoint++;\\n                \\n                else {\\n                    String coeff = getSlope(points[i], points[j]);\\n                    System.out.println(coeff);\\n                    map.put(coeff, 1 + map.getOrDefault(coeff, 0));\\n                    currMax = Math.max(currMax, map.get(coeff));\\n                }\\n            }\\n            \\n            // currMax is count of maximum points[j] on a line passing through\\n            // points[i]. We still need to account for points[j] = points[i]\\n            // Also, up to this point we have take count of points[j] but the actual\\n            // number of points on a line should also include point[i] hence + 1\\n            maxpt = Math.max(maxpt, currMax + samePoint + 1);\\n            map.clear();    // clear slope->count map\\n        }\\n        return maxpt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// https://leetcode.com/problems/max-points-on-a-line/description/\\n\\n/**\\n * Definition for a point.\\n * class Point {\\n *     int x;\\n *     int y;\\n *     Point() { x = 0; y = 0; }\\n *     Point(int a, int b) { x = a; y = b; }\\n * }\\n */\\nclass Solution {\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    private String getSlope(Point a, Point b) {\\n        int Y = b.y - a.y;\\n        int X = b.x - a.x;\\n        \\n        // Ensure a != b for below hacks to work\\n        // basically either it should be a vertical\\n        // line or a horizontal line and a and b\\n        // should be distinct points\\n        \\n        // hack for horizontal line point\\n        if (Y == 0)\\n            X = 1;\\n        \\n        // hack for vertical line point\\n        if (X == 0)\\n            Y = 1;\\n        \\n        // follow convention of -ve numerator\\n        // and +ve denominator so that -1/2 is same as 1/-2\\n        // for considering lines with same slopes\\n        if ((X < 0 && Y > 0) || (X < 0 && Y < 0)) {\\n            X = -X;\\n            Y = -Y;\\n        }\\n        \\n        // gcd can be calculated only for +ve numbers\\n        int g = gcd(Math.abs(X), Math.abs(Y));\\n        Y /= g;\\n        X /= g;\\n        \\n        return Y + \" \" + X;     // return slope as a pair of numerator, denominator\\n    }\\n    \\n    public int maxPoints(Point[] points) {\\n        if (points == null)\\n            return 0;\\n        if (points.length <= 2)\\n            return points.length;\\n        \\n        // track line segements in hashmap\\n        Map<String, Integer> map = new HashMap<>();\\n        int maxpt = 2;\\n        \\n        for (int i = 0; i < points.length; i++) {\\n            int samePoint = 0;\\n            int currMax = 0;\\n        \\n            for (int j = i + 1; j < points.length; j++) {\\n                \\n                if (points[i].x == points[j].x && points[i].y == points[j].y)\\n                    samePoint++;\\n                \\n                else {\\n                    String coeff = getSlope(points[i], points[j]);\\n                    System.out.println(coeff);\\n                    map.put(coeff, 1 + map.getOrDefault(coeff, 0));\\n                    currMax = Math.max(currMax, map.get(coeff));\\n                }\\n            }\\n            \\n            // currMax is count of maximum points[j] on a line passing through\\n            // points[i]. We still need to account for points[j] = points[i]\\n            // Also, up to this point we have take count of points[j] but the actual\\n            // number of points on a line should also include point[i] hence + 1\\n            maxpt = Math.max(maxpt, currMax + samePoint + 1);\\n            map.clear();    // clear slope->count map\\n        }\\n        return maxpt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47105,
                "title": "c-solution-using-greatest-common-denominator",
                "content": "I have a solution but a few notes ported from the Java Solution by R:\\n\\n* I still don't quite understand while they allow duplicate points?  For that, I down-voted this one, because it needs to be fixed in my opinion.  Duplicate points don't exist in the 2D plane so this is a little weird.  In fact, there is an **infinite set** of points in the 2D plane, but it is a **set** which implies each point is unique.  To deal with this oddity, I labelled the variable \"undefined\" and just incremented it to pass the test cases (but, in reality, I wouldn't do that, but throw an InvalidOperationException or ArgumentException)\\n\\n* We are try to find points on a line (**y = mx + c**), where **m** is the **slope** and **c** is constant.  **m** is defined as deltaY/deltaX; **c** is derived from (y-y1=mx-x1) [e.g. (0,3) ==> c = 3]\\n\\n* The GCD was a very clever work-around from tracking the **slope**.  Any point on the same line will reduce down to the CGD (nice).  Giving credit to the Java Solution by R (nice).\\n\\n* The constant **c** was cleverly addressed, as well, by GCD for the same reason as above.\\n***\\n    /// <summary>\\n    /// Given a finite list (set would imply uniqueness) of points,\\n    /// compute the max number of points that lie on a straight \\n    /// line produced by the finite list; otherwise, max = infinity\\n    /// </summary>\\n    /// <example>\\n    /// {{0,0},{0,0}} produces 2\\n    /// {{0,0},{1,1},{1,-1}} = 2\\n    /// </example>\\n    public class Solution\\n    {\\n        private int GreatestCommonDenominator(int a, int b)\\n        {\\n            if (b == 0) return a;\\n            else\\n                return GreatestCommonDenominator(b, a % b);\\n        }\\n\\n        public int MaxPoints(Point[] points)\\n        {\\n            //Track from x0 and y0 \\n            Dictionary<int, Dictionary<int, int>> slopeMap = new Dictionary<int, Dictionary<int, int>>();\\n            int maxPoints = points.Length > 0 ? 1 : 0;\\n            \\n            for(int i = 0; i < points.Length; i++)\\n            {\\n                slopeMap.Clear();\\n                int localMax = 0, undefined = 0;\\n                for (int j = i + 1; j < points.Length; j++)\\n                {\\n                    int deltaX = points[j].x - points[i].x;\\n                    int deltaY = points[j].y - points[i].y;\\n\\n                    if(deltaX == 0 && deltaY == 0)\\n                    {\\n                        undefined++;\\n                        continue;\\n                    }\\n\\n                    int gcd = GreatestCommonDenominator(deltaY, deltaX);\\n\\n                    if (gcd != 0)\\n                    {\\n                        deltaX /= gcd;\\n                        deltaY /= gcd;\\n                    }\\n\\n                    if (!slopeMap.ContainsKey(deltaX))\\n                    {\\n                        slopeMap[deltaX] = new Dictionary<int, int>();\\n                    }\\n\\n                    if (!slopeMap[deltaX].ContainsKey(deltaY))\\n                    {\\n                        slopeMap[deltaX][deltaY] = 1;\\n                    }\\n                    else\\n                    {\\n                        slopeMap[deltaX][deltaY]++;\\n                    }\\n\\n                    localMax = Math.Max(localMax, slopeMap[deltaX][deltaY]);\\n                }\\n                maxPoints = Math.Max(maxPoints, localMax + undefined + 1);//+1 because I never added the initial point (x0,y0)\\n            }\\n\\n            return maxPoints;\\n        }\\n    }\\n***",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        private int GreatestCommonDenominator(int a, int b)\\n        {\\n            if (b == 0) return a;\\n            else\\n                return GreatestCommonDenominator(b, a % b);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 47188,
                "title": "6-liner-in-python-simple-solution-without-gcd",
                "content": "Simple math: a line can be uniquely represented by ```y=ax+b``` or ```x=c``` (vertical-line case).\\n\\nWe can iterate through all pairs of points and find the line that the 2 points are forming. The hash key tuple for the line is either ```(a, b)``` or ```(float('inf'), c)```.\\n\\nBy doing that, all points are grouped by unique lines.\\n\\nThen we count the number of unique points for each line and return the maximum.\\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        d = collections.defaultdict(set)\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                p1, p2 = points[i], points[j]\\n                d[(float('inf'), p1.x) if p1.x==p2.x else ((p1.y-p2.y)/float(p1.x-p2.x), (p1.x*p2.y-p2.x*p1.y)/float(p1.x-p2.x))] |= set([p1, p2])\\n        return max(len(s) for s in d.values()) if len(points)>1 else len(points)\\n```\\nOr the longer but easier-to-read version:\\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        d = collections.defaultdict(list)\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                p1, p2 = points[i], points[j]\\n                if p1.x == p2.x:\\n                    t = (float('inf'), p1.x)\\n                else:\\n                    t = ((p1.y-p2.y)/float(p1.x-p2.x), (p1.x*p2.y-p2.x*p1.y)/float(p1.x-p2.x))\\n                d[t] += [p1, p2]\\n        return max(len(set(l)) for l in d.values()) if len(points)>1 else len(points)\\n```",
                "solutionTags": [],
                "code": "```y=ax+b```\n```x=c```\n```(a, b)```\n```(float('inf'), c)```\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        d = collections.defaultdict(set)\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                p1, p2 = points[i], points[j]\\n                d[(float('inf'), p1.x) if p1.x==p2.x else ((p1.y-p2.y)/float(p1.x-p2.x), (p1.x*p2.y-p2.x*p1.y)/float(p1.x-p2.x))] |= set([p1, p2])\\n        return max(len(s) for s in d.values()) if len(points)>1 else len(points)\\n```\n```\\nclass Solution(object):\\n    def maxPoints(self, points):\\n        d = collections.defaultdict(list)\\n        for i in range(1, len(points)):\\n            for j in range(i):\\n                p1, p2 = points[i], points[j]\\n                if p1.x == p2.x:\\n                    t = (float('inf'), p1.x)\\n                else:\\n                    t = ((p1.y-p2.y)/float(p1.x-p2.x), (p1.x*p2.y-p2.x*p1.y)/float(p1.x-p2.x))\\n                d[t] += [p1, p2]\\n        return max(len(set(l)) for l in d.values()) if len(points)>1 else len(points)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47258,
                "title": "c-code-with-hashmap-beating-96-others",
                "content": "    int maxPoints(vector<Point>& points) {\\n            int len = points.size(), ans = 0;\\n            if(len <= 2) return len;\\n            unordered_map<double, int> mp;\\n            for(int i = 0; i < len; i++){\\n                int dup = 1;    // To count the points exactly same with point i, including i itself.\\n                mp.clear();\\n                for(int j = i+1; j < len; j++){   // we start with j = i +1, because lines from i to k (k = 0,1,...,i-1) has already been considered in the previous steps.\\n                    if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                            dup++;\\n                            continue;\\n                    }\\n                    else{\\n                        float slope = (points[i].x == points[j].x) ? INT_MAX : (float(points[i].y-points[j].y)/(points[i].x-points[j].x));\\n                        mp[slope]++;\\n                    }\\n                }\\n                ans = max(dup , ans);  // in case no element in the map.\\n                for (auto slope : mp)\\n                    if (slope.second + dup > ans) \\n                        ans = slope.second + dup; \\n            }\\n             return ans;\\n    }\\n\\nIdea: For one single point, we calculate the slopes to each of others and store them in a hash map. Take care of the case INT_MAX and duplicate.",
                "solutionTags": [],
                "code": "    int maxPoints(vector<Point>& points) {\\n            int len = points.size(), ans = 0;\\n            if(len <= 2) return len;\\n            unordered_map<double, int> mp;\\n            for(int i = 0; i < len; i++){\\n                int dup = 1;    // To count the points exactly same with point i, including i itself.\\n                mp.clear();\\n                for(int j = i+1; j < len; j++){   // we start with j = i +1, because lines from i to k (k = 0,1,...,i-1) has already been considered in the previous steps.\\n                    if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                            dup++;\\n                            continue;\\n                    }\\n                    else{\\n                        float slope = (points[i].x == points[j].x) ? INT_MAX : (float(points[i].y-points[j].y)/(points[i].x-points[j].x));\\n                        mp[slope]++;\\n                    }\\n                }\\n                ans = max(dup , ans);  // in case no element in the map.\\n                for (auto slope : mp)\\n                    if (slope.second + dup > ans) \\n                        ans = slope.second + dup; \\n            }\\n             return ans;\\n    }\\n\\nIdea: For one single point, we calculate the slopes to each of others and store them in a hash map. Take care of the case INT_MAX and duplicate.",
                "codeTag": "Unknown"
            },
            {
                "id": 47297,
                "title": "my-java-solutions-for-your-reference-using-type-long-int-int-as-slope",
                "content": "    /**\\n     * Definition for a point.\\n     * class Point {\\n     *     int x;\\n     *     int y;\\n     *     Point() { x = 0; y = 0; }\\n     *     Point(int a, int b) { x = a; y = b; }\\n     * }\\n     */\\n    public class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points == null) return 0;\\n            int n = points.length;\\n            if(n <= 2) return n;\\n            Map<Long, Integer> map = new HashMap<>();\\n            int result = 0;\\n            for(int i = 0; i < n - 1; ++i){\\n                int localMax = 0, overlap = 0;\\n                map.clear();\\n                for(int j = i + 1; j < n; ++j){\\n                    if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                        overlap++;\\n                    }else{`enter code here`\\n                        long k = slope(points[i].x - points[j].x, points[i].y - points[j].y);\\n                        int t = map.containsKey(k) ? map.get(k) + 1 : 1;\\n                        map.put(k, t);\\n                        localMax = t > localMax ? t : localMax;\\n                    }\\n                }\\n                localMax += overlap + 1;\\n                result = result < localMax ? localMax : result;\\n            }\\n            return result;\\n        }\\n        long slope(int a, int b){\\n            int c = gcd(a, b);\\n            if(c != 0){\\n                a /= c;\\n                b /= c;\\n            }\\n            long r = a;\\n            r = (r << 32) | b;\\n            return r;\\n        }\\n        int gcd(int a, int b){\\n            int r;\\n            while(b != 0){\\n                r = a % b;\\n                a = b;\\n                b = r;\\n            }\\n            return a;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPoints(Point[] points) {\\n            if(points == null) return 0;\\n            int n = points.length;\\n            if(n <= 2) return n;\\n            Map<Long, Integer> map = new HashMap<>();\\n            int result = 0;\\n            for(int i = 0; i < n - 1; ++i){\\n                int localMax = 0, overlap = 0;\\n                map.clear();\\n                for(int j = i + 1; j < n; ++j){\\n                    if(points[i].x == points[j].x && points[i].y == points[j].y){\\n                        overlap++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 47344,
                "title": "why-y-kx-b-is-not-a-good-idea",
                "content": "How about define Line:\\n\\n    struct Line{\\n       double k;\\n       double b;\\n       bool isVerticalLine;\\n    }\\n\\nThen the problem is how to override the compare function for \"==\"? I used compare for sort before, but not for '=='.\\n\\n    struct lineComp{\\n        bool operator()(const Line &line1, const Line &line2){\\n            double eplison = 0.000001;\\n            if (line1.vLine && line2.vLine){\\n                return fabs(line1.b-line2.b) < eplison;\\n            }else if (line1.vLine || line2.vLine){\\n                return 1;\\n            }else\\n                return (fabs(line1.k - line2.k) < eplison ) && (fabs(line1.b - line2.b) < eplison) ;\\n        }\\n        \\n    };",
                "solutionTags": [],
                "code": "How about define Line:\\n\\n    struct Line{\\n       double k;\\n       double b;\\n       bool isVerticalLine;\\n    }\\n\\nThen the problem is how to override the compare function for \"==\"? I used compare for sort before, but not for '=='.\\n\\n    struct lineComp{\\n        bool operator()(const Line &line1, const Line &line2){\\n            double eplison = 0.000001;\\n            if (line1.vLine && line2.vLine){\\n                return fabs(line1.b-line2.b) < eplison;\\n            }else if (line1.vLine || line2.vLine){\\n                return 1;\\n            }else\\n                return (fabs(line1.k - line2.k) < eplison ) && (fabs(line1.b - line2.b) < eplison) ;\\n        }\\n        \\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3306665,
                "title": "python-o-n-2-solution-for-your-reference",
                "content": "```\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def dic():\\n            return defaultdict(int);\\n        ans = 0;\\n        hmap = defaultdict(dic) \\n        n = len(points)\\n        for i in range(0,n):\\n            print(\"------------\")\\n            print(f\\'i:{i} point[i]:{points[i]} \\')\\n            hmap.clear();\\n            for j in range(i+1,n):\\n                x = points[i][0] - points[j][0]\\n                y = points[i][1] - points[j][1]\\n\\n                if(  y == 0 ):\\n                    hmap[0][0] += 1\\n                    if( hmap[0][0] > ans ):\\n                        ans = hmap[0][0];\\n                    continue;\\n                \\n                g = gcd(x,y);\\n\\n                x //= g\\n                y //= g\\n                # in case of negative slope one value can be negative (eg)\\n                # eg (1,-1) and (-1,1) will result in slop m = -1 but here \\n                if( y < 0 ):\\n                    x = -x \\n                    y = -y \\n                \\n                hmap[x][y] += 1\\n                print(f\\'j:{j} point[j]:{points[j]} x:{x} y:{y} hmap[{x}][{y}]:{hmap[x][y]}\\')\\n                if( hmap[x][y] > ans ):\\n                    ans = hmap[x][y];\\n            \\n        return ans+1;\\n\\n\\n                    \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        def dic():\\n            return defaultdict(int);\\n        ans = 0;\\n        hmap = defaultdict(dic) \\n        n = len(points)\\n        for i in range(0,n):\\n            print(\"------------\")\\n            print(f\\'i:{i} point[i]:{points[i]} \\')\\n            hmap.clear();\\n            for j in range(i+1,n):\\n                x = points[i][0] - points[j][0]\\n                y = points[i][1] - points[j][1]\\n\\n                if(  y == 0 ):\\n                    hmap[0][0] += 1\\n                    if( hmap[0][0] > ans ):\\n                        ans = hmap[0][0];\\n                    continue;\\n                \\n                g = gcd(x,y);\\n\\n                x //= g\\n                y //= g\\n                # in case of negative slope one value can be negative (eg)\\n                # eg (1,-1) and (-1,1) will result in slop m = -1 but here \\n                if( y < 0 ):\\n                    x = -x \\n                    y = -y \\n                \\n                hmap[x][y] += 1\\n                print(f\\'j:{j} point[j]:{points[j]} x:{x} y:{y} hmap[{x}][{y}]:{hmap[x][y]}\\')\\n                if( hmap[x][y] > ans ):\\n                    ans = hmap[x][y];\\n            \\n        return ans+1;\\n\\n\\n                    \\n\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3223792,
                "title": "java-easy-and-simple-o-n-2-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We loop all points and skip `i == j`\\n- calculate slope\\n- increment count for points that have same slope\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ Double for loop comparing all points\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ up to N number of points as slopes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if (points.length <= 2) { // if we have less than 2 points\\n            return points.length;\\n        }  \\n        int res = 0; \\n\\n        for (int i = 0; i < points.length; i++) {\\n            int[] p1 = points[i];\\n            Map<Double, Integer> map = new HashMap<>(); // <slope, count>\\n\\n            for (int j = 0; j < points.length; j++) {\\n                int[] p2 = points[j];\\n                if (p2 == p1) { // skip same points\\n                  continue;  \\n                }\\n                double slope = 0;\\n                if (p2[0] == p1[0]) { // vertical line\\n                    slope = Double.POSITIVE_INFINITY;\\n                } else {\\n                    slope = (p2[1] - p1[1]) / (double) (p2[0] - p1[0]);\\n                }\\n                map.put(slope, map.getOrDefault(slope, 1) + 1); // must have at least 1 + other number of points\\n                res = Math.max(res, map.get(slope));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        if (points.length <= 2) { // if we have less than 2 points\\n            return points.length;\\n        }  \\n        int res = 0; \\n\\n        for (int i = 0; i < points.length; i++) {\\n            int[] p1 = points[i];\\n            Map<Double, Integer> map = new HashMap<>(); // <slope, count>\\n\\n            for (int j = 0; j < points.length; j++) {\\n                int[] p2 = points[j];\\n                if (p2 == p1) { // skip same points\\n                  continue;  \\n                }\\n                double slope = 0;\\n                if (p2[0] == p1[0]) { // vertical line\\n                    slope = Double.POSITIVE_INFINITY;\\n                } else {\\n                    slope = (p2[1] - p1[1]) / (double) (p2[0] - p1[0]);\\n                }\\n                map.put(slope, map.getOrDefault(slope, 1) + 1); // must have at least 1 + other number of points\\n                res = Math.max(res, map.get(slope));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047198,
                "title": "explained-java-tc-o-n2-sc-o-n",
                "content": "*Upvote if found helpful, comment for feedback or question.*\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any 3 points to be in same line, or collinear, the slope of line formed between (point 1, point 2) should be equal to slope of line formed b/w (point 2, point 3) or (point 1, point 3).\\n\\nLet say there are 2 points (x1, y1), (x2, y2) respectively, then formula of slope - \\n\\n$$Slope, m = (y2 - y1) / (x2 - x1)$$\\n\\nWe can use this idea to maintain all the possible slopes forming from any given point, and maintain the counter for how many points lie in the respective slope.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if number of points given is equal to 1, if so, the answer can only be 1, hence return 1.\\n\\nVisualizing before step 2 - Let say we are charting the points that we are traversing (in  a graph) and first point has already been charted. From the 2nd point onwards, we will find the slope of current point with the existing points in graph. For example, \\n    For point 2, find slope with point 1.\\n    For point 3, find slope with point 1 and point 2, and so on.\\n\\n2.  Traverse from 2nd point to last, i,\\n\\n    2.1. Create a map which maintains all the slopes found and corresponding number of points in that slope.\\n\\n    *Note: Here we are maintaining local set of slopes, i.e., slopes that are forming from current point only, and not universal set of slopes found throughout. Universal set of slopes will cause problems in case of parallel lines.\\nFor example, consider points [[1,1],[2,3],[3,5],[4,1],[5,3]]. Slope b/w point 1, 2 and 3 is 2, number of points will be 3. But slope b/w point 4 and 5 is also 2 but they are not is same line. Maintaining a universal set of slopes will take counter for slope 2 to 5.\\nMaintaining a local set of slopes for every point allows us to consider only those points for counter that have same slope from current point.*\\n\\n    2.2. Calculate slope, from current point to all existing points,\\n    - Calculate slope keeping in mind divisibility with 0.\\n    - If slope already exists in map, increase its counter, else add slope to map with counter as 1.\\n    - Update max points if number of points for current slope is greater.\\n    \\n\\n3. Return max+1. This +1 is for the point with respect to which slopes were calculated. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int max = 1;\\n\\n        if(points.length<=1){\\n            return max;\\n        }\\n\\n        for(int i=1; i<points.length; i++){\\n            Map<Double, Integer> slopes = new HashMap();\\n            for(int j=0; j<i; j++){\\n                double slope = Double.MIN_VALUE;\\n                int denom = points[i][0] - points[j][0];\\n                int numer = points[i][1] - points[j][1];\\n                if(numer == 0){\\n                    slope = 0.0;\\n                }\\n                else if(denom != 0){\\n                    slope = numer / (double) denom ;\\n                }\\n                slopes.put(slope, slopes.getOrDefault(slope, 0) + 1);\\n                max = Math.max(max, slopes.get(slope));\\n            }\\n        }\\n\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int max = 1;\\n\\n        if(points.length<=1){\\n            return max;\\n        }\\n\\n        for(int i=1; i<points.length; i++){\\n            Map<Double, Integer> slopes = new HashMap();\\n            for(int j=0; j<i; j++){\\n                double slope = Double.MIN_VALUE;\\n                int denom = points[i][0] - points[j][0];\\n                int numer = points[i][1] - points[j][1];\\n                if(numer == 0){\\n                    slope = 0.0;\\n                }\\n                else if(denom != 0){\\n                    slope = numer / (double) denom ;\\n                }\\n                slopes.put(slope, slopes.getOrDefault(slope, 0) + 1);\\n                max = Math.max(max, slopes.get(slope));\\n            }\\n        }\\n\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029586,
                "title": "python-3-solution-using-hashmap-tc-o-n-2-sc-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each point, we need to find the slope of the line with all other points and maximum of points having same slope is the answer. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Return 1 if length of the points is 1.\\n- I have created a hashmap(i.e. cache in the code).\\n- For every point i\\'ve calculated the slope of the line that connects two points and stored in the cache with key in the form of key = (x-coordinate, y-coordinate, slope= $$(y2-y1/x2-x1)$$).\\n- If $$(x2-x1 = 0)$$ we get divide by zero error so, we store $$\"i\"$$ as our value. since the slope is infinity.\\n- If any other points make same slope with our point. we increment the value that the slope(key) represents in the cache.\\n- Finally, answer is the maximum of all the values in the dictionary +1 (Our first point and all the other points it has same slope with).\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)==1:\\n            return 1\\n        cache = {}\\n        n = len(points)\\n        for i in range(n):\\n            point = points[i]\\n            for j in points:\\n                if point != j:\\n                    if (j[0]-point[0])==0:\\n                        slope = \"i\"\\n                    else:\\n                        slope = (j[1]-point[1])/(j[0]-point[0])\\n                    key = (point[0],point[1], slope)\\n                    if key in cache:\\n                        cache[key] += 1\\n                    else:\\n                        cache[key] = 1\\n        return max(cache.values()) + 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        if len(points)==1:\\n            return 1\\n        cache = {}\\n        n = len(points)\\n        for i in range(n):\\n            point = points[i]\\n            for j in points:\\n                if point != j:\\n                    if (j[0]-point[0])==0:\\n                        slope = \"i\"\\n                    else:\\n                        slope = (j[1]-point[1])/(j[0]-point[0])\\n                    key = (point[0],point[1], slope)\\n                    if key in cache:\\n                        cache[key] += 1\\n                    else:\\n                        cache[key] = 1\\n        return max(cache.values()) + 1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1747022,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1566134,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568114,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747154,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1573923,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1566076,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747026,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1567383,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1567216,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568980,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747022,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1566134,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568114,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747154,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1573923,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1566076,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1747026,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1567383,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1567216,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568980,
                "content": [
                    {
                        "username": "pieceofpie",
                        "content": "One week of easy problems, then one week of extremely hard brain damage problems, starting with this one. Prepare for the worst guys."
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "Was prepared for the worst and then LC said \"Naah, I will let you heal\"."
                    },
                    {
                        "username": "leonyhenn",
                        "content": "I\\'d say it\\'s an easy one among all hard problems. basically junior high geometry."
                    },
                    {
                        "username": "VinayV9",
                        "content": "May becuase of Sunday "
                    },
                    {
                        "username": "debug_04",
                        "content": "[@ikorpse](/ikorpse) Yes, right!"
                    },
                    {
                        "username": "debug_04",
                        "content": "[@suhaanbhandary1](/suhaanbhandary1)  Yup brute force approach works on it, I am facing problem in finding accurate slope values because C+ + rounds off the number automatically in fraction values. Can I avoid auto rounding off the values in C++?"
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "i was shocked when its got accepted using simple bruteforce. i should be an easy problem if u know about slope."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Simple brute force works on it!!, only taking care of slope is the issue!!"
                    },
                    {
                        "username": "ikorpse",
                        "content": "not hard if you remember the course of school geometry, I had to google and recollect hard"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "[@pratik-2707](/pratik-2707) i totally agree because i managed to solve in one attempt that\\'s totally unnatural for me "
                    },
                    {
                        "username": "pratik-2707",
                        "content": "this one is not hard"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Its not that hard"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Not that hard you thinking : \nhttps://leetcode.com/problems/max-points-on-a-line/discussion/comments/1747154"
                    },
                    {
                        "username": "yliu8949",
                        "content": "whoever put in the test case that contains points of the same coordinates is pure evil. It\\'s making the problem unnessarily complicated"
                    },
                    {
                        "username": "Vijay_Katta",
                        "content": "All the points are unique. says the problem"
                    },
                    {
                        "username": "Ayush6944",
                        "content": "but it is in integer\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Huh. I didnt even consider copies of the same point, yet my solution seems to handle them just fine? An oversight on my part, should have reduced the list to a set to begin with as it may improve runtime. "
                    },
                    {
                        "username": "hieu1022003",
                        "content": "[@spartex007](/spartex007) we can use x1*y2==x2*y1 instead of x1/y1==x2/y2, it\\'ll work for every cases "
                    },
                    {
                        "username": "spartex007",
                        "content": "even if they are equal check if x2- x1 is zero before calculating the slope."
                    },
                    {
                        "username": "cursydd",
                        "content": "its no big deal, sort and remove all same points first. "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "[@nishant7372](/nishant7372) \\nYes, we are lucky"
                    },
                    {
                        "username": "nishant7372",
                        "content": "This problem doesn't exists anymore.\nNow all the points of each testcase are unique."
                    },
                    {
                        "username": "neunzehn",
                        "content": "Input: [[0,0]]\\nOutput: 0\\nExpected: 1\\nThe questions asks \"Given n points on a 2D plane, find the maximum number of points that lie on the same straight line\". Now one can maybe make a case that a single point does lie on the same straight line IF AND ONLY IF ONE PROVIDES SUCH A LINE."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I too was like \"well, I GUESS\".\nAdded a base case test:\n```\nif len(points) < 3:\n    return len(points)\n```\n\nwhich also catches if there are just two points, as the answer will necessarily be 2"
                    },
                    {
                        "username": "WOAS",
                        "content": "technically a single point can define an infinite amount of lines, but ALL of them only contain that one point"
                    },
                    {
                        "username": "Msey",
                        "content": "makes sense"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Points on a same line means I need to find out the slope.\\nslope for any two points = `slope= y2-y1/x2-x1`\\nfor every `x[i],y[i]` I need to find out the slope, if the same slope exists I\\'ll increment the count.\\n**NOTE** : the result of slope will be a double, so for ease lets take `x = x2-x1, y =y2-y1`\\nand we can store this slope as a String  `key = x + \"-\" + y`\\n**Edge Case 1 for Storing Values** = 12/6 == 2/1 to resolve this issue I will :\\n`x /= gcd(x,y), y /= gcd(x,y)`\\n**Edge Case 2 for storing values** = negative values \\nif `both x and y are negative, store as +ve values`\\nelse : if one of them is negative for ease `make x as negative and y positive` to get same slope of all points\\n**Edge Case 3 for repeated points** = if `x2 == x1 and y2==y1` handle a `count` for repeated values and add into your answer\\n**Don\\'t jump to solution directly** : [solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3016695/easy-java-solution//)"
                    },
                    {
                        "username": "Kaltu",
                        "content": "edge case 3 is a direct violation for the final constraint: All the `points` are **unique**."
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "You dont need all of this, just calculate slope simply keeping in mind that  division is done on double values so that slope will be in double and that denominator should not be zero..check if(y1-y2 != 0) then go ahead and else take a variable which stores the number of infinite slopes. \n\n[solution](https://leetcode.com/problems/max-points-on-a-line/solutions/3027161/simple-mathematical-approach/)\n"
                    },
                    {
                        "username": "clawfinger",
                        "content": "Thank you, very good explanation"
                    },
                    {
                        "username": "MrZydeco",
                        "content": "It\\'s **INFURIATING** how imprecise computer scientists are at stating problems.\\nWho is to know that [0,0] at index 0 in the list points is a DIFFERENT point from [0, 0] in the list points with index 1. unless they submit their code and get \"Wrong Answer\".\\n\\nThe reason that I\\'m objecting so vehemenly is that this materially affects the approach to the problem.  Yopu shouldn\\'t have to discover the requirements by submitting your code and getting it marked wrong.\\n\\nA better way to word this problem is:\\n\\nGiven a sequence of points of 2D lattice* points, find the maximum length of a subsequence all of whose points lie on the same straight line.\\n\\nThis allows for duplicates in the sequence -- the problem as stated really does not.\\n(A lattice point is one whose coordinates are integers)"
                    },
                    {
                        "username": "vansh_11",
                        "content": "but if you read constraints it is clearly mentioned all points are unique"
                    },
                    {
                        "username": "yjiang01",
                        "content": "obviously, two parallel lines have the same slope but they are DIFFERENT straight lines.I don't understand. any help? thanks."
                    },
                    {
                        "username": "didibus",
                        "content": "You can tell if two lines of the same slope are different by comparing their y-intercept or x-intercept, that is do they cross the x or y axis at the same point?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I just solved for both the slope AND the y intercept, and used a tuple with both as keys to my dict. Ran in ok time (like 80%) so I didnt bother optimizing."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "But a point lies on the line."
                    },
                    {
                        "username": "abhay_jo23",
                        "content": "Yes, your understanding is correct. Two lines with same slopes may or may not be same. But when we are calculating the slope w.r.t. a specific point (x1,y1) then not just slopes but also intercepts will be common. \\nHint: Try understanding it by 2-point form (or point intercept form) of straight lines. "
                    },
                    {
                        "username": "kikya_hi",
                        "content": "reset the slope dictionary for every point. "
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Take a point as pivot and find the slope and check how many same slope exits\\n\\nDo it for every point, and now you can be sure that no two lines are parallel with same slope as for each iteration there is a pivot "
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "The way I solved is by calculating slope of a point with respect to every other point.\\n\\nNow lets say A,B are on same line and C,D are on another line which is parallel.\\nSlope of AB will not be same as AC or AD. \\nHence parallel line points will be differentiated from current line."
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "because their intercepts are diffrent on coordinate axis ."
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "For me I use like per point slope, so I check point by point, and get the Maximum, then move on to the next point.\\n\\nthe same m/gradient will not store together, but per-point\\neven though the gradient is the same.\\np1=[1,1] and p2=[2,2]\\np3= [10,2] and p4=[11,3]\\n\\neach have the same slope, but rather putting it on a same list or dict, I reset the dict and only get the max so it wont overlapping"
                    },
                    {
                        "username": "AshutoshSingh10",
                        "content": "You may have stored the slope in a variable I assume (say sl).\\nWhen you will be comparing sl with the with the slope of the other point (say point 4), you actually comparing the slope between point 4 and initial point(say point1 ) i.e.\\np1[y]-p4[y]/(p1[x]-p4[x])."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is supposed to be testing someone\\'s coding ability, not their math/geometry knowledge - so it would be more considerate to provide more relevant context information, which is how to determine if 3 points are co-linear."
                    },
                    {
                        "username": "EtherWei",
                        "content": "Now I understand why there are so many downvotes on this problem."
                    },
                    {
                        "username": "ashokchhilar",
                        "content": "It\\'s not a hard problem, the geometry needed is very basic and really there weren\\'t many trick cases. I believe the test cases may have been cleaned up since the hue and cry from 2019."
                    },
                    {
                        "username": "KershKersh",
                        "content": "[@mayank_pant](/mayank_pant) I\\'m pretty sure it\\'s test case [[0,0]]. Or, I\\'ve heard that in the past, there were duplicate points in the test cases. This was 2019, so it\\'s likely."
                    },
                    {
                        "username": "mayank_pant",
                        "content": "maybe its because its a bit math heavy and a lot of guys hate that. I on the other hand am intrigued by it. "
                    },
                    {
                        "username": "kylinzhuo",
                        "content": "![0_1501735549057_2aac80da-23ca-49d9-85f1-f934c1908e5d-image.png](/assets/uploads/files/1501735549965-2aac80da-23ca-49d9-85f1-f934c1908e5d-image-resized.png) \\n\\nI've tried calculating the slopes and count them using map, but was failing a test case all the time. No matter how many digits I set for the float it just seemed that 94911150/94911151 equals 94911151/94911152. \\n\\n???!\\n\\n![0_1501735572971_119030a3-7f7e-40fb-99e0-0307d01bd99b-image.png](/assets/uploads/files/1501735573552-119030a3-7f7e-40fb-99e0-0307d01bd99b-image-resized.png) \\n\\nIt was crazy. Anyone could help me?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "It\\'s a precision problem, generally computers are bad with floating point numbers!!\\nMost of the time it is advised to avoid division in computer algorithms, since two same divisions can be off as suggested by [@Abhi Titty](/abhititty)\\n\\nA nice trick is to convert slope in more general way or a hash:\\nMy solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint maxPoints(vector<vector<int>>& points) {\\n\\t\\t// For every point find the slope with other and find the common slopes\\n\\n\\t\\tint result = 1;\\n\\t\\tfor (auto point : points) {\\n\\t\\t\\tint x0 = point[0], y0 = point[1];\\n\\n\\t\\t\\tunordered_map<string, int> m;\\n\\t\\t\\tfor (auto other : points) {\\n\\t\\t\\t\\tdouble x = other[0], y = other[1];\\n\\t\\t\\t\\tif (x == x0 && y == y0) continue;\\n\\n\\t\\t\\t\\tint dx = (x - x0);\\n\\t\\t\\t\\tint dy = (y - y0);\\n\\n\\t\\t\\t\\tint gcd = __gcd(dx, dy);\\n\\t\\t\\t\\tstring slope = to_string(dx / gcd) + \"#\" + to_string(dy / gcd);\\n\\t\\t\\t\\tm[slope]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (auto p : m) {\\n\\t\\t\\t\\tresult = max(result, p.second + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```"
                    },
                    {
                        "username": "Trojanhorse_",
                        "content": "[@anuraggcodes](/anuraggcodes) but two parallel lines containing a common point must be a single line !! think!!"
                    },
                    {
                        "username": "abhititty",
                        "content": "94911150/94911151 is not equal to 94911151/94911152 just like how 3/4 is not equal to 4/5. To put it more generally, for n/(n+1) = (n+1)/(n+2) has no solution."
                    },
                    {
                        "username": "vlasenkodmytroi",
                        "content": "[@drash99](/drash99) According to problem statement: -10_000 <= xi, yi <= 10_000. This test should be removed as one that does not meet the conditions of the task. "
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "Two lines having same slope may not necessarily be same line, they can be parallel too!"
                    },
                    {
                        "username": "Kshitij_Dwivedi",
                        "content": "Though [@drash99](/drash99) has told one way. But still if you want to compare two floating numbers (float or double), for example here let\\'s say slope m1 and m2 to be equal. Try this - \\nif (abs(m1 - m2) < 1e-9)\\n{\\n      // m1  and m2 are equal\\n}"
                    },
                    {
                        "username": "drash99",
                        "content": "save both numerator and denominator together. Do not use float calculation for all, use only integer calculation (change division to multiplication on other side ...)"
                    },
                    {
                        "username": "zzzdevil",
                        "content": "I have checked all the posts and found there are two ways to represent a line:\\n\\n 1. ax + by = c, which can cover all cases but requires a gcd\\n    function for normalization. \\n 2. y = kx + d, which is simple but cannot cover the lines parallel to x-axis.\\n\\nI think it is hard to say which is better. However, I prefer the latter...Anybody knows a better way?\\n\\nIn my submission code, I take the dynamic programming idea and use the y=kx+d representation. Due to the divide-and-conquer, we only need the slope k (d is not necessary any more) as the unique key for each line. This approach is much clear and only one value as hash key. The time complexity is still O(n^2) but the average time cost should be better.\\n\\nYou can also review my code in my blog: http://www.cnblogs.com/zzzdevil/p/3513294.html\\n\\nIt is a blog hosting in Chinese, but the post is in English...\\n\\nSorry for the ugly English..."
                    }
                ]
            },
            {
                "id": 1568033,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1567889,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1574589,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1568109,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1567890,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1570237,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1958361,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1747722,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1574165,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1569488,
                "content": [
                    {
                        "username": "jucherek",
                        "content": "Input:\\n[[0,0],[1,1],[0,0]]\\nOutput:\\n2\\nExpected:\\n3\\n\\nThe problem should be updated to clarify that duplicate points should actually count, although fundamentally I disagree with that premise altogether. "
                    },
                    {
                        "username": "kensparby",
                        "content": "By the fourth constraint this is now an invalid test case. All points should be unique now."
                    },
                    {
                        "username": "Ujjawal_Sharma452",
                        "content": "The question expected to count maximum number of points on the straight line so, you need to count all the points on the line."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "3 is correct, because all three given points are on the same line, even though two points are the same"
                    },
                    {
                        "username": "Twins",
                        "content": "So for the testcase `{[0,0],[0,0]}`. They are the same point and should be considered as one point. But the expected answer is `2`"
                    },
                    {
                        "username": "stzfao",
                        "content": "[@ayushidixitme](/ayushidixitme) Some test cases have duplicate points."
                    },
                    {
                        "username": "ayushidixitme",
                        "content": "it is given that all the points are unique in the array\\n"
                    },
                    {
                        "username": "mohammad_reza",
                        "content": "Implemented the O(N^3) bruteforce solution in C++ and it was accepted!"
                    },
                    {
                        "username": "dingopark",
                        "content": "as the title says"
                    },
                    {
                        "username": "priya3",
                        "content": "Input:\\t[(0,0),(0,0)]\\nOutput:\\t1\\nExpected:\\t2\\n\\n(0.0) is a single point. IMO, the other duplicate must be removed and only one point must be returned. And with a single point in the list, the output is 1."
                    },
                    {
                        "username": "achalv18",
                        "content": "[[0,0],[1,1],[0,0]]\\nOutput: 2\\nExpected: 3 \\n\\nHow in the world there are 3 points in this given input."
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to solve this problem mathematically?\n\n[binary_line0.png](https://assets.leetcode.com/users/images/afed75b7-b68b-4411-a9c0-3598b3f04d9d_1688625403.28748.png)\n\n![binary_line.png](https://assets.leetcode.com/users/images/981dc598-6df1-48be-8283-c81a844a28c0_1688625420.8643475.png)"
                    },
                    {
                        "username": "noob-pika",
                        "content": "First solve it in paper. Then try it in code.\\nAlso first try to eliminate duplicates in the array.\\nGood thing I saw some people complaining about it in Discussion page.\\nMy code got accepted very quickly in first try, and I\\'m a nub coder. So I hope anyone can solve it."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s a good a good idea to solve it on paper first, but there shouldn\\'t be any duplicates in the array anymore, I think they fixed that after people complained about it in 2019 (although I think it\\'s pretty straightforward to solve even if there are duplicates)"
                    },
                    {
                        "username": "leetcodesalamander",
                        "content": "For input [[0,0]] the expected answer is 1. One point doesn\\'t make a line. You need 2 or more points."
                    },
                    {
                        "username": "melodytzhou",
                        "content": "![image](https://assets.leetcode.com/users/melodytzhou/image_1555818679.png)\\n"
                    }
                ]
            },
            {
                "id": 1572576,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1568978,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1568979,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1571330,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1568056,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1748784,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1748449,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1748245,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1747094,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1747067,
                "content": [
                    {
                        "username": "jay-tc-yang",
                        "content": "when i finally realized what this question wants me to do, i\\'ve already got three wrong submissions\\n"
                    },
                    {
                        "username": "thelogical012",
                        "content": "(1.0 * 94911150.to_f/94911151.to_f) = 0.9999999894638303\\n(1.0 * 94911151.to_f/94911152.to_f)  = 0.9999999894638303\\nit s so close to 1 that my program output result 3?\\nwhat's wrong"
                    },
                    {
                        "username": "jason_xxr",
                        "content": "This set should have max 2 points in a line:\\n\\n    [[0,0],[1073741822,2147483645],[1073741823,2147483647]]\\n\\nBut judge gives out 3, due to float precision."
                    },
                    {
                        "username": "samoshka",
                        "content": "I see solutions being posted where slopes are used as a manner to distinguish lines. \\nBut the line equation is generally y=ax+b, and different values of b would give different lines.\\nFor example, given points (0,0), (1,2), (2,4),(3,6),(4,0),(5,2),(6,4),(7,6) would give 2 lines with 4 points each:\\n\\n 1. y=2x :  (0,0), (1,2), (2,4),(3,6)\\n 2. y=2x-8  :   (4,0),(5,2),(6,4),(7,6)\\n\\nIf we only look at the slopes, we still continue adding for slope 2 the points (5,2), (6,4),(7,6) - and get the answer 7.\\nAm I missing something???"
                    },
                    {
                        "username": "jl4930",
                        "content": "Are you testing something related to an aircraft orbit so that the digit should be in a line so strict?"
                    },
                    {
                        "username": "ustadji",
                        "content": "lmao I was asked this in an interview for an intern level position at a startup. \\xAF\\\\_\\u0CA0_\\u0CA0_/\\xAF"
                    },
                    {
                        "username": "DixitSom",
                        "content": "use dictionary and sets to solve this one. use slop m and constant c as keys of maps and store sets as values which contains points indexes then at the last count the maximum length of set and return"
                    },
                    {
                        "username": "prashantghi8",
                        "content": "Can anyone give me hints or anthing on where did i go wrong in my below mentioned approach???\\nTried for whole day, 30/35 testcases passed. Hoping i will be able to solve this task in the future.\\nGave up for now. :(\\nMy today\\'s approach was:\\n- Kept slope and the points used to get the slope in a dictionary: defaultdict\\n- If the values(points) from each of the key(slope) did not made a straight line, removed it (Used slope to check straight line)\\n- Now, length of total points for each unique slopes are appended in new list\\n- Maximum value of that list was returned."
                    },
                    {
                        "username": "didibus",
                        "content": "Are you sure you can handle the edge case of a vertical line (undefined slope) and of horizontal line (slope of 0) as well as handle the case of parallel lines (equal in slope but not same line)?"
                    },
                    {
                        "username": "ajesk",
                        "content": "Jeez what a frustrating problem. Simple to initially solve, but horrendous in dealing with the floating point issue. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I just multiply by ten billion then round, then divide again, so you get points that are very close as well"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Aaron](/ajesk) I realized in first minute itself that there is going to be issue with floating points since we cannot compare them effectively. So maintained fraction in form of numerator and denominator and then simplified that by dividing both by gcd"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "We can solve above problem by following approach \\u2013 For each point p, calculate its slope with other points and use a map to record how many points have same slope, by which we can find out how many points are on same line with p as their one point. For each point keep doing the same thing and update the maximum number of point count found so far."
                    }
                ]
            },
            {
                "id": 1574346,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1573306,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1573046,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1572851,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1572623,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1572299,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571936,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571325,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571326,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571328,
                "content": [
                    {
                        "username": "prerngup",
                        "content": "In this test case :\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\n\\nslope of (0,0) (94911151,94911150) = 0.9999999895\\nslope of (0,0) (94911152,94911151) = 0.9999999895\\n\\nSince slopes are equal these points should lie on same straight line as per my understanding.\\nSo, the answer should come as 3 but it is coming equal to 2.\\n\\nCna anybody explain the reason please."
                    },
                    {
                        "username": "withbreeze",
                        "content": "![image](https://assets.leetcode.com/users/withbreeze/image_1577828406.png)\\n\\nThis is clearly a bug. Please fix."
                    },
                    {
                        "username": "apsolutely",
                        "content": "My code is failing on test case `[[1,1],[1,1],[2,3]]`, which expects 3. Shouldn\\'t it be 2?"
                    },
                    {
                        "username": "ravikumar2",
                        "content": "for input [[0,0]] the expected out it 1. \\nfor [[0,0],[1,1],[0,0]] the expected output is 3; this is clearly bug. duplicate points. \\n\\n"
                    },
                    {
                        "username": "HarishGonna",
                        "content": "For the test case [[0,0],[94911151,94911150],[94911152,94911151]] if we use slope as the HashMap key we end up getting the same value for [0,0] [94911151,94911150] && [0,0] [94911152,94911151] but it isnt so. \\n\\n94911150/94911151 != 94911151/94911152.\\n\\nAny thoughts on how to handle this scenario?\\n\\nThanks"
                    },
                    {
                        "username": "yingsxu",
                        "content": "Why have same point in list? \\n"
                    },
                    {
                        "username": "bob31",
                        "content": "some of the top fast codes will fail this test case\\n\\n[[1,1],[4,9],[2,2],[7,8],[3,3]]"
                    },
                    {
                        "username": "csy1000",
                        "content": "Should we consider all 3 points on the same line since their differences are less than \"0.00001\"? I see most of the solutions provided are failing for this case.\\n\\nInput:\\n[[0,0],[94911151,94911150],[94911152,94911151]]\\nOutput:\\n3\\nExpected:\\n2"
                    },
                    {
                        "username": "Catherine_W_Z",
                        "content": "for input [[0,0],[0,0]], should the result be one?\\nHowever, got this instead\\nInput:\\n[[0,0],[0,0]]\\nOutput:\\n1\\nExpected:\\n2"
                    },
                    {
                        "username": "babaduredi",
                        "content": "Does it make sense to have test cases like [[0,0],[0,0]] or [[0,0],[0,0],[1,0],[1,0]] ?"
                    }
                ]
            },
            {
                "id": 1571329,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571331,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571332,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571333,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571334,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571335,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571336,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1571921,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 2030851,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 2010854,
                "content": [
                    {
                        "username": "edward.lu",
                        "content": "I think it is reasonable.\\n\\nBecause the the point is defined by integer, so the max line slope is  maxint / 1, the min slope is 1/maxint, if I multiply above slope by 100000000, then the result is still in the range of long long, and the precision won't be worse than float.\\n\\nWhat do you think?\\n\\nBTW: long long key solution( 16 ms)  is  20 ms faster than string key solution (36ms)"
                    },
                    {
                        "username": "zzhao010",
                        "content": "this is is this problem out put :\\n\\n**Input:\\t[(84,250),(0,0),(1,0),(0,-70),(0,-70),(1,-1),(21,10),(42,90),(-42,-230)]\\n\\nOutput:\\t5\\n\\nExpected:\\t6**\\n\\ni think 5 is right answer (84,250),(0,-70),(0,-70),(42,90),(-42,-230) !  who can found the sixth point ??"
                    },
                    {
                        "username": "zzhao010",
                        "content": "   When I write my code for problem \\u201cMax Points on a Line\\u201d , I found the some wrong test case result for this problem! \\nThis is output for my result:\\nSubmission Result: Wrong Answer\\nInput:\\t[(0,0),(1,1),(0,0)]\\nOutput:\\t2\\nExpected:\\t3\\n\\n   U can see the input [(0,0),(1,1),(0,0)] has same (0,0) points  ,so u can\\u2019t count them for twice .in fact this the result for max points in same line should be 2((0,0) (1,1)) and not 3 !   \\n\\n   Because u will never found diffrent (0,0) points in same line !"
                    },
                    {
                        "username": "sathish",
                        "content": "Expected output says \"3\". can someone help me out , How it is 3 for the above mentioned input."
                    },
                    {
                        "username": "madhero",
                        "content": "Failed here:\\n\\nInput:\\t[(560,248),(0,16),(30,250),(950,187),(630,277),(950,187),(-212,-268),(-287,-222),(53,37),(-280,-100),(-1,-14),(-5,4),(-35,-387),(-95,11),(-70,-13),(-700,-274),(-95,11),(-2,-33),(3,62),(-4,-47),(106,98),(-7,-65),(-8,-71),(-8,-147),(5,5),(-5,-90),(-420,-158),(-420,-158),(-350,-129),(-475,-53),(-4,-47),(-380,-37),(0,-24),(35,299),(-8,-71),(-2,-6),(8,25),(6,13),(-106,-146),(53,37),(-7,-128),(-5,-1),(-318,-390),(-15,-191),(-665,-85),(318,342),(7,138),(-570,-69),(-9,-4),(0,-9),(1,-7),(-51,23),(4,1),(-7,5),(-280,-100),(700,306),(0,-23),(-7,-4),(-246,-184),(350,161),(-424,-512),(35,299),(0,-24),(-140,-42),(-760,-101),(-9,-9),(140,74),(-285,-21),(-350,-129),(-6,9),(-630,-245),(700,306),(1,-17),(0,16),(-70,-13),(1,24),(-328,-260),(-34,26),(7,-5),(-371,-451),(-570,-69),(0,27),(-7,-65),(-9,-166),(-475,-53),(-68,20),(210,103),(700,306),(7,-6),(-3,-52),(-106,-146),(560,248),(10,6),(6,119),(0,2),(-41,6),(7,19),(30,250)]\\nOutput:\\t21\\nExpected:\\t22\\n\\nIn my local laptop, I used decimal module and it produced the correct result. But in leetcode it complaint \"Runtime Error\" if I use decimal module. How to solve this problem?"
                    },
                    {
                        "username": "fei3",
                        "content": "I submit my solution and the OJ give the Wrong Answer,show the result is\\n\\nInput:[(0, 0)]\\nOutput : 0\\nExpected : 1\\n\\nquestion is the input:[(0,0)],if only one point,how could get the maximum number of points that lie on the same straight line?"
                    },
                    {
                        "username": "wulongict",
                        "content": "I write the code to the problem Max Points On A Line. I find there is such a case:\\n\\n[(0,0),(0,1),(0,0)].\\n\\nThe expected answer is 3, while my output is 2, because there are two (0,0) points in the case.\\n\\nIs this a wrong case in Max Points On A Line?"
                    },
                    {
                        "username": "user9716",
                        "content": "In 2D plane, [1,1] and [1,1] are the same point, not 2 points.\\nHowever, in the test case, it iscounted as 2 points on the line.\\nI don\\'t think this fits the description."
                    },
                    {
                        "username": "donmakaveli",
                        "content": "THis is not taking my solution  please check test case no 29 \\n if len(points)<=2:\\n            return len(points)\\n        M = 0\\n        for i in range(len(points)-1):\\n            d = {}\\n            for j in range(i+1 ,len(points)):\\n                m = 2\\n                x  = points[i][0]-points[j][0]\\n                if x==0: \\n                    slope = 10000\\n                else:\\n                    slope = (points[i][1] - points[j][1]) /x\\n                if slope not in d :\\n                    d[slope]=2\\n                else:\\n                    d[slope]+=1\\n                print(d , points[i] ,  points[j],slope)\\n                M = max(d[slope] , M)\\n        return M"
                    },
                    {
                        "username": "user2075nF",
                        "content": "after submission i went to the top runtime submission for python3. someone just added all test cases in if else condition"
                    }
                ]
            },
            {
                "id": 1980876,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1977646,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1963336,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1957297,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1873843,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1867591,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1804723,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1773680,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1770475,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1769740,
                "content": [
                    {
                        "username": "ayushanand18",
                        "content": "How is this even hard? It should be below LC easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have been thinking something like:\n```\ndistinct_numbers_difference = {}  #to hash map the sublist and the sum. like if they are diffrent numbers the sum should be equal: coordinate_x + coordinate_y = constant\n\nsame_coordinates = None  # to  +=1 for each item. like: coordinate_x  = coordinate_y \n```\n\nBut now I see `[[2,3],[3,3],[-5,3]]` and literally going to copy and paste the solution, I have no wish to mess with this, to modify the code that if the amount of items in `points` is even so it can contain up to `len(points)/2` equal cordinates, otherwise `len(points)//2` or whatever should be, to lose 30 more minutes. thanks, no\n\n17 / 41 testcases passed, I did the task, I don't care"
                    },
                    {
                        "username": "Zomack270",
                        "content": "I\\'ve got issue with python interpreter and division, the problem was that division were always round e.g. 5/4 give 1 my solution to get rid of this was to convert 5 and 4 to 5.0 and 4.0 (floats)"
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "Making only the slope same will work? cos similar slope can be possible for two lines where the points may not lie on the same line"
                    },
                    {
                        "username": "knaxelbaby",
                        "content": "what even is the use case for this lol"
                    },
                    {
                        "username": "mohfarouk",
                        "content": "Hard? "
                    },
                    {
                        "username": "grovre",
                        "content": "There are an unbounded amount of points on a line segment and an infinite amount of points on a line. This is the true answer"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "this solution is wrong but why???\\n\\n\\nclass Solution \\n{\\npublic:\\n    int maxPoints(vector<vector<int>>& points) \\n    {\\n        if(points.size()<=2)\\n            return points.size();\\n        map<float,int>slope;\\n        int n=points.size();\\n        float sl=0;\\n        int pre=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                float s;\\n                if(points[j][0]-points[i][0]!=0)\\n                    s=(1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0]);\\n                else\\n                    s=1000000000;\\n                // cout<<s<<\" \";\\n                slope[s]++;\\n                if(slope[s]>pre)\\n                {\\n                    pre=slope[s];\\n                    sl=s;\\n                }\\n            }\\n        }\\n        // cout<<sl;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                if(points[j][0]-points[i][0]!=0 && abs((1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])-sl)<=1e-9)\\n                    val++;\\n                else if(points[j][0]-points[i][0]==0 && sl==1000000000)\\n                    val++;\\n                cout<< (1.0*(points[j][1]-points[i][1]))/(points[j][0]-points[i][0])<<\" \"<<sl<<endl;\\n            }\\n            ans=max(ans,val);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "821346",
                        "content": "is it possible to solve this without a hashmap?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. For each pair of points you can count the points that are on the same line (e.g. with the [cross product](https://en.wikipedia.org/wiki/Cross_product#Computational_geometry)). That has a runtime complexity of O(n^3) which is worse than the O(n^2) when using a hashmap but it's still fast enough for this specific problem."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1766921,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1756362,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1751210,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1751020,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1749310,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1749196,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748901,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748838,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748774,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748759,
                "content": [
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "DSA buddy Explanatory video :https://www.youtube.com/watch?v=Oe0nSS7XWY8"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Can anyone pls help me finding what\\'s wrong with my solution?\\nI have tried to solve it by calculating the slope but not getting the expected output.\\n\\n int maxPoints(vector<vector<int>>& points) {\\n        map<double,int>mp;\\n        int ans = 0;\\n        for(int i = 0; i < points.size()-1; i++){\\n            for(int j = i+1; j < points.size(); j++){\\n                double slope,x1,x2,y1,y2;\\n                x1 = points[i][0], x2 = points[j][0];\\n                y1 = points[i][1], y2 = points[j][1];\\n                if(x2 - x1 == 0){\\n                    slope = INT_MAX;\\n                }\\n                else{\\n                    slope = (y2-y1)/(x2-x1);\\n                }\\n                mp[slope]++;\\n                ans = max(ans,mp[slope]);\\n            }\\n        }\\n         \\n        return ans;\\n    }"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  Thanks I got it."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The slope alone won't do. Take this test for example: `[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]`. Here's a visualization:\n\n    4 | 5\n    3 |   4     2\n    2 |     1\n    1 | 0     3\n      +----------\n        1 2 3 4 5\n\nThere are six pairs with a slope of `-1`: `(1,1)`, `(1,3)`, `(1,4)`, `(1,5)`, `(3,4)`, `(3,5)`, and `(4,5)`. But the six points are not on the same line.\n\nAnother problem are parallel lines: `[[0, 0], [4, 5], [7, 8], [8, 9], [5, 6], [3, 4], [1, 1]]`\n\n    9 |                 3\n    8 |               2\n    7 |\n    6 |           4\n    5 |         1\n    4 |       5\n    3 |\n    2 |\n    1 |   1\n    0 | 0\n      +------------------\n        0 1 2 3 4 5 6 7 8\n\n`0`, `1` and `5`,`1`,`4`,`2`,`3` are on two parallel lines with the exact same slope.\n\nAnd a third problem is this: This solution counts *pairs* with the same slope. If there are just two points on a line then `mp[slope]` is `1` because there's one pair: `(idx0,idx1)`. If there are five points on a line then there are `10` pairs with the same slope: `(idx0,idx1)`,`(idx0,idx2)`,`(idx0,idx3)`,`(idx0,idx4)`,`(idx1,idx2)`,`(idx1,idx3)`,`(idx1,idx4)`,`(idx2,idx3)`,`(idx2,idx4)`,`(idx3,idx4)`.\n\nBut you're actually pretty close: For each point you could count the trailing points with the same slope. That means clearing the `std::map` before the inner loop, and adding `1` to `mp[slope]` when calling `std::max()`."
                    },
                    {
                        "username": "sddhantjaiii",
                        "content": "fuck leet code my test case are working in visual studio ad other interpreter but its showing complete different output here\\n\\n\\nclass Solution(object):\\n    pool = {}\\n\\n    def maxPoints(self,points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        print(self,points)\\n        l=len(points)\\n        if l==1 or l ==2:\\n            return l\\n        i=0\\n        t=0\\n        o=[]\\n        mn=0\\n        f=0\\n        k=0\\n        for i in range (l-1):\\n            x=points[i][0]\\n            y=points[i][1]\\n            k=i+1\\n            x1=points[k][0]\\n            y1=points[k][1]\\n            print(x,x1,y,y1)\\n            if x1-x==0:\\n                print(\\'inside first if\\')\\n                f+=1\\n                continue\\n            m=(y1-y)/(x1-x)\\n            for j in points:\\n                xx=j[0]\\n                yy=j[1]\\n                if xx-x==0:\\n                    print(\\'inside 2nd if\\')\\n                    continue\\n                m1=(yy-y)/(xx-x)\\n                if m1==m:\\n                    t+=1\\n                    mn=5\\n            o.append(t)\\n            print(o,t)\\n\\n            t=0\\n        f+=1\\n        print(o)\\n        if mn==5:\\n            print((max(o)+1))\\n            return max((max(o)+1),f)\\n        else:\\n            return(f)\\n\\n   "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "The idea behind the solution I came up with is :\\n\\n1. You fix a point and you traverse all other points and find their slope with this fixed point. The number of points which have common slope will lie on the same straight line.\\n2. You do this for all the points given in the array.\\n3. For each point, you store slope and their frequency in a hashtable and then retrieve the one with the maximum number of values in each iteration.\\n4. Store the maximum number of values in a separate variable after each iteration.\\n5. Return this variable, which contains maximum number of points on a straight line (or points that have same slope with a fixed point)\\n\\nSo, you figure out the slope and try to see how many other points will form the same slope."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Looking into the problem `constraints` made it easily possible for me to solve it.\\nHint: slope formula applied over all combinations of possible lines. "
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Area of triangle of collinear points is zero . so use determinant form of area of triangle and put it zero . this will be the condition for 3 points to be on the same line'\n\nprivate  boolean collinearCheck(int x1 , int y1 , int x2 , int y2 , int x3 , int y3){\n        int determinant = x1*(y2-y3) - y1*(x2 -x3) + 1*(x2*y3 - x3*y2 );\n        return determinant==0;\n }\n\nUse some loops to get the required answer."
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "[@siebenschlaefer](/siebenschlaefer) Yes bro i did a brute force. But this colllinearCheck()  is one way to check the collinearity. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "With this `collinearCheck()` don\\'t you need three nested loops and therefore get a runtime complexity of O(n^3)?  \\nAll the fast solutions I\\'ve seen so far use two nested loops and get a runtime complexity of O(n^2)."
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "Really hate that case of [[5151,5150],[0,0],[5152,5151]] as when i ran the code on vs code it outputted 2 but somehow leetcode was outputting 3 ,then i had to use stringstream instead of to_string()"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Destroyed my mental peace because of one misplaced closing parenthesis [ \")\" ] in this question !\\njust where I had to write (y2-y1)/(x2-x1)...\\nI wrote -> ((y2)-(y1)/((x2)-(x1)))). "
                    },
                    {
                        "username": "serhankars",
                        "content": "This problem showed me that sometimes brute force solution can be an option too."
                    }
                ]
            },
            {
                "id": 1748747,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748706,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748616,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748575,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748564,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748536,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748498,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748480,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748473,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748367,
                "content": [
                    {
                        "username": "audianu",
                        "content": "If I changes the coordinates I got the wrong ans but if i vice versa it  i got correct ans.  \\nWrong One`if( (points[j][1]-points[i][1])*(points[k][0]-points[i][0]) == (points[k][1]-points[i][1])*(points[j][0]-points[i][0]) )`\\n\\nCorrect One\\n ` if( (points[j][1]-points[i][1])*(points[i][0]-points[k][0]) == (points[i][1]-points[k][1])*(points[j][0]-points[i][0]) )`\\n\\nI just replace the i and k in their positions.\\nCan anybody help?\\n"
                    },
                    {
                        "username": "audianu",
                        "content": "[@calm27](/calm27) k is just the variable in for loop."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "I cannot reproduce the issue. Your solution (https://leetcode.com/problems/max-points-on-a-line/submissions/874272571/) passes the tests with both `if` statements."
                    },
                    {
                        "username": "calm27",
                        "content": "what is k? O_o"
                    },
                    {
                        "username": "Kirti_Goyal_39",
                        "content": "Hint: we can find biggest line for each point and then check for which point we get the most biggest line.\\n\\nSolution: to find the biggest line for each point,  start iterating all points and store all (slope, count) in an unordered map from that point. Then just find the slope which has maximum value of count. It shows that particular points has biggest line of slope \"slope\" and points on that line are equals to count+1.\\nin the same way you can find pair of (slope, count) for each point and just take maximum of counts.\\n\\nTime complexity : O(N^2)\\nSpace complexity: O(N)"
                    },
                    {
                        "username": "vijay_2_5",
                        "content": "step 1: sort the points\\nstep 2:  from first points select the all other points and evaluate the slop;\\nstep 3: create the static integer  and store the maximun no. of points with  same slop;\\nstep 4: continue step 2 for all element \\nstep 5: for every loop store the maximum value from step 4 in a vector\\nstep 6: get the maximum value from that vector."
                    },
                    {
                        "username": "AKR_2610",
                        "content": "Those who are confused with the floating point precision, try to round it up to 2 decimal places.\n\neg: c=123.123456\n\nc=c*100;\nc=round(c);\nc=c/100;\n\nwill work"
                    },
                    {
                        "username": "amine-by",
                        "content": "Either I am stupid, or the test cases don\\'t make sense."
                    },
                    {
                        "username": "prabhat8952",
                        "content": "why my code failed at this test case?\\ninput:[[9,-25],[-4,1],[-1,5],[-7,7]]\\nOUTPUT: Expected-[3] but Obtained-[2].\\nclass Solution {\\npublic:\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.size()==1)\\n        {\\n            return 1;\\n        }\\n        // map :for calculating perpendicular line\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<points.size();i++)\\n        {\\n            mp[points[i][0]]++;\\n        }\\n        //max_xx will store maximum points in a perpendicular line\\n        int max_xx=INT_MIN;\\n        for(auto it:mp)\\n        {\\n            if(it.second>max_xx)\\n            max_xx=it.second;\\n        }\\n        //sort :for getting all points in increasing order by x-axis\\n        sort(points.begin(),points.end());\\n        int count=1;\\n        //calculate slope for non perpendicular line\\n        int slope;\\n        //intial slope will be slope of first non perpendicular line\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            else{\\n            slope=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            break;\\n            }\\n        }\\n        //slope2 is for comparison of other\\'s slope to check whether they lies in same line.\\n        int slope2;\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]-points[i][0]==0)\\n            continue;\\n            slope2=(points[i+1][1]-points[i][1])/(points[i+1][0]-points[i][0]);\\n            if(slope2!=slope)\\n            {\\n                slope=slope2;\\n            }\\n            //if both consecutive slopes are same increase the count\\n           else if(slope2==slope)\\n            {\\n\\n                count++;\\n            }\\n        }\\n        //return maximum of perpendicular lines or normal lines(count)\\n        return max(max_xx,count);\\n    }\\n};\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The core idea of this solution is sorting the points and then counting adjacent points that have the same slope as the current value of `slope`. If they have a different slope the variable `slope` get updated.  \\nThat doesn\\'t work: Each \"run\" of points contributes to the `count`, even if they belong to different lines. Also, imagine there are four points on a line: For `[[0,0],[2,2],[4,4],[6,6]]` this solution would correctly return `4`. But when another point gets added in the middle that is not on the line things fall apart. For `[[0,0],[2,2],[3,0],[4,4],[6,6]]` this solution would incorrectly return `2` although the same four points are on a line."
                    },
                    {
                        "username": "hubertwo",
                        "content": "I\\'ve started with `y = ax + b`\\nCan anyone explain why the fastest answers  do not need to calculate `b`? \\n\\n"
                    },
                    {
                        "username": "CraigC51",
                        "content": "I had to look at this too... They start with point A and then calculate all lines A,A+1, A,A+2 etc. Since each of these lines is calculate through A the offset is already factored in. So any line through A with the same gradient must be the same line."
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Never trust comparision of two divisions!!\\nIn previous Google kickstart, It made me cost a whole problem!!\\n\\nSo try to avoid divisions:\\n1. Try converting division comparision into multiplication by moving denominators around\\n2. Get the dx and dy and divide by gcd to reduce the division to its simplest form, now you can compare them "
                    },
                    {
                        "username": "medhatjachour",
                        "content": "why when i\\'m trying to do something like (-1/-2) the result is 0 !!! in python !!!!!!"
                    },
                    {
                        "username": "kevv96",
                        "content": "You should avoid dividing, I got wrong answer two times because of division.\\ntry this instead ```y*(x1-x0) == (x-x0)*(y1-y0) + y0*(x1-x0)```\\n\\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3020236/check-all-combinations-brute-force-ac/"
                    },
                    {
                        "username": "AOAli77",
                        "content": "Can someone help? :) My Solution is not working because or some rounding issues.\\n\\nhttps://leetcode.com/playground/hx4FvegN"
                    }
                ]
            },
            {
                "id": 1748325,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748265,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748260,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748252,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748251,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748207,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748182,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748162,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748125,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748096,
                "content": [
                    {
                        "username": "piyush_chhawachharia",
                        "content": "Somebody Please help me out\\n-\\n\\nIt\\'s failing for 34/35  test case\\n[[2,3],[3,3],[-5,3]]\\nExpected-3\\nOutput-2\\n\\nPlease Help.\\n.\\n\\nclass Solution {\\n    public int maxPoints(int[][] points) {\\n        int n=points.length;\\n        if(n==1){\\n            return 1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            HashMap<Double,Integer> map=new HashMap<>();\\n            for(int j=i+1;j<n;j++){\\n                int x1=points[i][0];\\n                int y1=points[i][1];\\n                int x2=points[j][0];\\n                int y2=points[j][1];\\n                double slope;\\n                double dx=(x2-x1);\\n                double dy=(y2-y1);\\n\\n                if(dx==0){\\n                    slope=Integer.MAX_VALUE;\\n                }\\n                else{\\n                    slope=dy/dx;\\n                }\\n\\n                if(map.containsKey(slope)){\\n                    int val=map.get(slope);\\n                    val+=1;\\n                    map.put(slope,val);\\n                }\\n                else{\\n                    map.put(slope,1);\\n                }\\n            }\\n            for(Double key:map.keySet()){\\n                int val=map.get(key);\\n                max=Math.max(max,val+1);\\n            }\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "ajesk",
                        "content": "tip: -0.0 vs 0.0"
                    },
                    {
                        "username": "qiushile",
                        "content": "This is not that hard, cuz Constraints:\\n\\n1 <= points.length <= 300\\n"
                    },
                    {
                        "username": "darkenigma",
                        "content": "Input: [[0,0]]\\nExpected: 1\\n how we can make a line with single point???\\nbut the quetion is:\\n** Given n points on a 2D plane, find the maximum number of points that lie on the same straight line..\\nthere are infinite lines which passes through [0,0]. but we have return the maximum no. of points(from the given set of points) on the same line.so only one point is given and that can lie on any line. so, ans is 1.\\n "
                    },
                    {
                        "username": "Ujjawal_sheldoor",
                        "content": "Not satisfied with the test cases . As it do not consider the case of parallel line . by comparing just slope not by slope and intercept it excludes the case of parallel lines.  Earlier i was solving it by making \\nclass line\\n{\\nint slope ;\\nint intercept ;\\npublic line(int m , int c)\\n{\\nslope =m;\\nintercept =c;\\n}\\n}\\nfew test case were failed then by just comparing with slope all are passed.\\n"
                    },
                    {
                        "username": "pi-kashu",
                        "content": "People using C++, how is simple division more precise than atan2? "
                    },
                    {
                        "username": "sidcr7",
                        "content": "This one should be marked easy. Basic Geometry problem."
                    },
                    {
                        "username": "ChillingOtter",
                        "content": "Input\npoints = [[2,3], [3,3], [-5,3]]\n34 / 35 testcases passed\nOutput: 2\nExpected: 3\n\nMy only test case that is failing, weird behavior with mapping Double in java. Tried every practice of type casting int to double..."
                    },
                    {
                        "username": "zacyang",
                        "content": "I seriously question the test case quality , could someone tell me how came this \\ntest case 32\\n```\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n```\\ntest case help anyone verify what it is testing? Not time exceed, I got wrong answer."
                    },
                    {
                        "username": "xeniawann",
                        "content": "**A brute-force would just work, since input size is at most 300.**\nPay attention to where multiple vertical lines exist, you need to count them as different from each other. \nSo instead of recording their slope and y-intercept, you need to rethink how to differentiate them (because all of their `slopes = inf`, and `y-intersept = -inf`), maybe record their `x-intercept` instead of `y-intercept`?"
                    },
                    {
                        "username": "aka773",
                        "content": "is there only one line exist or multiple"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Multiple lines. You have to find the longest."
                    }
                ]
            },
            {
                "id": 1748083,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1748067,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1748039,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1748023,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1748021,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747941,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747940,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747935,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747923,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747762,
                "content": [
                    {
                        "username": "Firebelias12",
                        "content": "I was today years old that I realized there\\'s -0.0 in Java."
                    },
                    {
                        "username": "Vashudev2001",
                        "content": "class Solution {\\npublic:\\n int maxPoints(vector<vector<int>>& points) {\\n        int ans = 1;\\n\\n        for(int i=0;i<points.size()-1;i++){\\n        // mp of <slope,point> for each point we want new map to declare.\\n        unordered_map<double,int>mp;\\n            for(int j=i+1;j<points.size();j++){\\n                // if x cordinates are same then slope will be infinite as bottom will be 0.\\n                if(points[i][0] == points[j][0]){mp[1000001]++;}\\n                else{\\n                    double slope = (double)(points[j][1]-points[i][1])/(double)(points[i][0]-points[j][0]);\\n                    // store in map\\n                    mp[slope]++;\\n                }\\n            }\\n            // now we have slopes for each points store in map.\\n            // count the maximum points .\\n            int temp=0;\\n            for(auto x:mp){\\n                temp = max(temp,x.second);\\n            }\\n            // temp store max points with same slope with respect to point i.\\n            // store the maximum value in ans.\\n            // total points in line will be temp+1 as 1 for the ith point also.\\n            ans = max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "haris_rashid",
                        "content": "i tried to solve in 0(n3) time but two test cases are not passing \"help\";\\n\\'\\'\\'\\nc plus plus\\nclass Solution {\\nint getAns(int p1,int p2,double M,double C,vector<vector<int>> &points){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(points[i][1] == M*points[i][0] + C)\\n            count++;\\n    }\\n    return count;\\n}\\nint getAns2(int p1,int p2,double C,vector<vector<int>> &points,int x){\\n    int n = points.size();\\n    int count = 2;\\n    for(int i = 0 ;i<n;i++){\\n        if(i == p1 || i == p2)\\n             continue;\\n        if(x == points[i][0])\\n            count++;\\n       \\n    }\\n    return count;\\n}\\n\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n = points.size(),ans = 1;\\n        double M,C;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)\\n                    continue;\\n                if((points[i][0] - points[j][0]) != 0){\\n                     M = double(points[i][1] - points[j][1])/(points[i][0] - points[j][0]);\\n                    C = double(points[i][1] - M*points[i][0]);\\n                    ans = max(ans,getAns(i,j,M,C,points));\\n                }\\n                else\\n                {\\n                    ans = max(ans,getAns2(i,j,C,points,points[i][0]));\\n                }\\n               \\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "santanusen",
                        "content": "If you are brute-forcing or counting slopes, and find that more than half the points belong to the same line (and the rest, if any, do not) you can break early."
                    },
                    {
                        "username": "anoyash",
                        "content": "# Float Vs Double : Uncertainity :(\\n\\n\\tfloat m1;\\n\\tdouble m2;\\n\\t\\n\\tm1 = atan2(5152,5151);\\n\\tm2 = atan2(5152,5151);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\t\\n\\tm1 = atan2(5151,5150);\\n\\tm2 = atan2(5151,5150);\\n\\tcout<<setprecision(12)<<m1<<\"\\\\n\";\\n\\tcout<<setprecision(12)<<m2<<\"\\\\n\";\\n\\noutput : \\n0.785495221615\\n0.785495222506\\n0.785495221615\\n0.785495241351"
                    },
                    {
                        "username": "hcn1519",
                        "content": "You can find the answer by extracting a linear equation through two points and checking if the other points satisfy the equation. (In this case, you need to think about [floating-point problem](https://stackoverflow.com/questions/588004/is-floating-point-math-broken)).\n\nBut what if we only care about the slope of two points? Should we really need to evaluate equation?"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ solution..\\nclass Solution {\\n     public: \\n     int maxPoints(vector<vector<int>>& p) { \\n         int n = p.size(); \\n         if(n<=2) return n; \\n         int inf_slope = 0; \\n         int ans = 2; \\n         for(int i=0;i<n;i++){ \\n             unordered_map<double,int> m; \\n             for(int j=0;j<n;j++){ if(i!=j) {\\n                  m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++; } \\n                  } \\n                  for(auto x : m){ \\n                      ans = max(ans, x.second + 1); }\\n                       } \\n                       return ans;\\n            }\\n        };"
                    },
                    {
                        "username": "rambabu135",
                        "content": "A very easy problem.\\nas the input size is small.\\n"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "just a little maths and knowledge of map and u get the solution "
                    },
                    {
                        "username": "madiii",
                        "content": "Think this way, if a point A(x1,y1) lie on a straight line y=mx+c, then for every other point K(x2,y2) on that line the slope of A and K should be same.\\nSlope can be calculated but this formula: m = y2-y1/x2-x1"
                    }
                ]
            },
            {
                "id": 1747754,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747748,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747725,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747712,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747690,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747684,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747674,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747644,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747640,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747632,
                "content": [
                    {
                        "username": "Panda_2397",
                        "content": "hint: Points are on the same line if they have same slope and same starting point "
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "we can just map the key with some large value such as m[100001]++\\nwhenever the slope between points is infinite \\n(points[i][0]==points[j][0])\\nfor code : \\nhttps://leetcode.com/problems/max-points-on-a-line/solutions/3018198/easy-c-solution-with-detailed-explanation-code-with-sky-code-0-n-2-solution/\\n"
                    },
                    {
                        "username": "nishank007",
                        "content": "BRAIN DAMAGE\\n\\nThis one gets rejected\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    int delta_x = p[j][0] - p[i][0];\\n                    int delta_y = p[j][1] = p[i][1];\\n                    double slope = atan2(delta_y, delta_x);\\n                    cout << i << \" \" << j << \" \" << slope << endl;\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`\\n\\n\\nThis one gets approved\\n\\n `class Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& p) {\\n        int n = p.size();\\n        if(n<=2) return n;\\n        int inf_slope = 0;\\n        int ans = 2;\\n        for(int i=0;i<n;i++){\\n            unordered_map<double,int> m;\\n            for(int j=0;j<n;j++){\\n                if(i!=j) {\\n                    m[atan2(p[j][1]-p[i][1], p[j][0]-p[i][0])]++;\\n                }\\n            }\\n            for(auto x : m){\\n                ans = max(ans, x.second + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nishank](/nishank007)buddy please use triple backticks for opening and closing code blocks, this way code will show multiline in comment"
                    },
                    {
                        "username": "dikshant25",
                        "content": "My Approach :\nfirst stores Slopes in a ditionary and then finding points which lies on same line by staisfyting line cordinates\n\nwhy it is giving WA\n\n `your inline code...your inline code...`\nimport itertools\nclass Solution:\n    def maxPoints(self,points):\n        d = {}\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if points[j][0] - points[i][0] != 0:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                else:\n                    slope = 0\n                if slope not in d:\n                    d[slope] = []\n                d[slope] += ([points[j]])\n                d[slope] += ([points[i]])\n\n        ans = 1\n\n        for item in d:\n\n            a = d[item]\n            a = sorted(a)\n            a = list(a for a, _ in itertools.groupby(a))\n\n            if item != 0:\n                m = item\n\n                for it in a:\n                    cache = 1\n                    for ite in a:\n                        if ite != it:\n                            y = ite[1]\n                            x = ite[0]\n                            if  it[1] == (m * it[0]) - (m * x) + y:\n                                cache += 1\n\n                    ans = max(ans, cache)\n            else:\n\n                x = {}\n                y = {}\n                for it in a:\n\n                    if it[0] in x:\n                        x[it[0]] += 1\n                    else:\n                        x[it[0]] = 1\n                    if it[1] in y:\n                        y[it[1]] += 1\n                    else:\n                        y[it[1]] = 1\n                x = list(x.values())\n                y = list(y.values())\n                x = sorted(x, reverse=True)\n                y = sorted(y, reverse=True)\n                c = max(y[0], x[0])\n                ans = max(ans, c)\n        return ans\n\n\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Dikshant Parasar](/dikshant25) buddy you are doing most common mistake, two lines can have same slope and yet be different (parallel lines), one more data point is required to be stored... line equation is not y = mx where m is slope, line equation is y = mx + c"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Can someone suggest resources for learning geometry problems"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers: https://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Use complex numbers as a trick to solve problems like this\\nhttps://youtu.be/6WL5ZxqYI-g"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[[1,0],[0,0]] why this is supposed to give? : expected : 2\\nwhere as : from (0,0) the distance will be (1,0) and other than that there is nothing!"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "[@sarpalmadhav](/sarpalmadhav) oh so we just have to answer the points! thanks you are live saver"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@VINAY CHAURASIYA](/Vinay-Chaurasiya) it is not about distance, we have to return number of points on a line, since these two points form a line, the answer is 2"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "The idea is to find the slope of line between every pair of points in the array and if the slope of every pair of point is same, then these points together forms a straight line"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "xhsfeto",
                        "content": "why does [[0,0]] expect to return 1?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Because any line starting (or ending, or crossing through) [0,0] has a single point on it.... [0,0]"
                    }
                ]
            },
            {
                "id": 1747580,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747566,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747512,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747438,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747423,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747373,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747345,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747314,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747260,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747223,
                "content": [
                    {
                        "username": "Amarsanaa",
                        "content": "A Trick to solve problems on XY plane. Level up your coding skill with Complex numbers! Explains well in under three minutes. https://www.youtube.com/watch?v=6WL5ZxqYI-g"
                    },
                    {
                        "username": "omi23",
                        "content": "And here comes a strike breaker"
                    },
                    {
                        "username": "user4851h",
                        "content": "This is my approach,However facing error\\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n\\n\\nclass Solution {\\npublic:\\nint slope(vector<int> a,vector<int> b){\\n    int x1=a[0],y1=a[1],x2=b[0],y2=b[1];\\n    if((x2-x1)!=0) return (y2-y1)/(x2-x1);\\n    else return INT_MAX;\\n}\\n    int maxPoints(vector<vector<int>>& points) {\\n        int n=points.size(),res=INT_MIN;\\n        // sort(points.begin(),points.end());\\n        for(int i=0;i<n-1;i++){\\n            int c=0;\\n            unordered_map<int,int> m;\\n           for(int j=i+1;j<n;i++)\\n               {if(slope(points[i],points[j])==INT_MAX) continue;\\n                m[slope(points[i],points[j])]++;\\n                if(c<m[slope(points[i],points[j])])\\n                    c=m[slope(points[i],points[j])];\\n               }\\n            m.clear();\\n            res=max(res,c+1); \\n        }\\n    return res;}\\n};"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "Seems like Leetcode easy days are over."
                    },
                    {
                        "username": "mrunfunny",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I was just lacking off a little. Wasn\\'t too tough."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Mohit Singh](/mrunfunny) this prob is not hard, it is weird: if you have issues try reading discussion section where you will get hints on line slope and how two lines with same slope can be different . Then it should be easy. Even if you don\\'t get these, read solution and try to do it. Today is Sunday. Don\\'t break the streak buddy. YOU CAN DO IT!!"
                    },
                    {
                        "username": "Downstream",
                        "content": "If you want to calculate slopes, I recommend to write your own `Rational` class, and **DO NOT USE** double division, it\\'s full of pitfalls."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Someone plz give me adrenaline shot T_T"
                    },
                    {
                        "username": "rjalali",
                        "content": "What is the reason that the inner loop is looking over all points, aren\\'t we double checking certain combinations?"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "you can exclude the checked points by using ids, enumerate for python3:\\n\\nfor example:\\nfor idx1, point1 in enumerate(points):\\nfor idx2, point2 in enumerate(points[idx1+1:)):\\n\\nby doing this, you will not get any duplicates combination\\nit will go like this Ex: [0,1,2,3] : 6 times (3 on 0, 2 on 1, and 1 on 3)\\n0 1\\n0 2 \\n0 3\\n1 2\\n1 3\\n2 3\\n\\n"
                    },
                    {
                        "username": "AryanShri",
                        "content": "Easy Easy Easy..\\n\\nOkay two medium..\\n\\nhard on its way..\\n\\nThough completed after one hour brain storming"
                    },
                    {
                        "username": "namanchandak",
                        "content": "my code is failing in \\ncan someone please let me know?\\n\\n[[7,3],[19,19],[-16,3],[13,17],[-18,1],[-18,-17],[13,-3],[3,7],[-11,12],[7,19],[19,-12],[20,-18],[-16,-15],[-10,-15],[-16,-18],[-14,-1],[18,10],[-13,8],[7,-5],[-4,-9],[-11,2],[-9,-9],[-5,-16],[10,14],[-3,4],[1,-20],[2,16],[0,14],[-14,5],[15,-11],[3,11],[11,-10],[-1,-7],[16,7],[1,-11],[-8,-3],[1,-6],[19,7],[3,6],[-1,-2],[7,-3],[-6,-8],[7,1],[-15,12],[-17,9],[19,-9],[1,0],[9,-10],[6,20],[-12,-4],[-16,-17],[14,3],[0,-1],[-18,9],[-15,15],[-3,-15],[-5,20],[15,-14],[9,-17],[10,-14],[-7,-11],[14,9],[1,-1],[15,12],[-5,-1],[-17,-5],[15,-2],[-12,11],[19,-18],[8,7],[-5,-3],[-17,-1],[-18,13],[15,-3],[4,18],[-14,-15],[15,8],[-18,-12],[-15,19],[-9,16],[-9,14],[-12,-14],[-2,-20],[-3,-13],[10,-7],[-2,-10],[9,10],[-1,7],[-17,-6],[-15,20],[5,-17],[6,-6],[-11,-8]]\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxPoints(vector<vector<int>>& points) {\\n        map<double,double>st;\\n        int n=points.size();\\n        double infi=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double y=points[i][1]-points[j][1]; \\n                double x=points[i][0]-points[j][0]; \\n                if(x==0)\\n                {\\n                    infi++;\\n\\n                    continue;\\n                }\\n                x=double(y/x);\\n                st[x]++;\\n\\n            }\\n        }\\n        double maxi=0;\\n        \\n\\n        for(auto it:st)\\n        {\\n            maxi=max(maxi,it.second);\\n            // if(it.second==inf || it.second==-inf)\\n            // infi++;\\n            cout<<it.first<<\"\\\\t\"<<it.second<<endl;\\n        }\\n\\n        maxi=1+sqrt(1+8*maxi);\\n        maxi=maxi/2;\\n\\n        cout<<infi;\\n        return max(maxi,infi);\\n\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "You are storing it based on its gradient/m\\n\\nFor Ex:\\n[0,0] and [1,1] have the same gradient with [1,0] and [2,1] \\nhowever, it is not in the same straight line, it is parrarel on each other\\n\\ntry only get the maximum value of a line per point, so the parrarel won\\'t be count together"
                    },
                    {
                        "username": "sukanta_chowdhury",
                        "content": "Wrong Answer\\n\\nInput\\npoints =\\n[[0,0],[4,5],[7,8],[8,9],[5,6],[3,4],[1,1]]\\n\\n24 / 35 testcases passed\\n\\nOutput\\n7\\nExpected\\n5"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "It is indeed correct\\n[4,5],[7,8],[8,9],[5,6],[3,4] have the same straight line\\nand [0,0] and [1,1] are also in the straight line\\n\\nit have the same gradient, however it is not the same straight line, it is parrarel to each other\\n\\nTry not based on the gradient itself, because same gradient not always the same line"
                    }
                ]
            },
            {
                "id": 1747111,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747101,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747077,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747052,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747024,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1747004,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1746970,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1714333,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1687704,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            },
            {
                "id": 1629653,
                "content": [
                    {
                        "username": "cosmin1490",
                        "content": "O(N^2) seems to be what you want. \\n\\nCouldn\\'t be bothered to deal with floating point math and line equations. \\n\\nSo you could, at every step, fix one point, translate all the other points as if the fixed point was the origin (0, 0) and compute the normalized coordinates of every other point and then count duplicates. \\n "
                    },
                    {
                        "username": "ZacharyZYH",
                        "content": "Is it safe to get slope using float calculation? In my understanding float calculation is never 100% accurate."
                    },
                    {
                        "username": "ajesk",
                        "content": "it is not, I am trying to solve how to store the slope in a safe way. The only thing holding up my solution. 33/35 cases"
                    },
                    {
                        "username": "nhebb",
                        "content": "Clarification: It's Max Points ON a Line, not Max Points that FORM a line.\n\n[[0,0]] - 1 point on any y = mx line.\n[[0,0], [0,0]] - 2 points on any y = mx line.\n[[0,0], [1,1],[0,0]] - 3 points on the y = x line.\n\nSadly, that's the only thing I've figured out so far about this problem.\n"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Just Bruteforce -_-"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Tip for those attempting: Don't use floating point for storing slope as it will give incorrect results, also consider cases where slope is INFINITY."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ajesk](/ajesk) use two nums, numerator and denominator, and then reduce them by dividing them both with gcd"
                    },
                    {
                        "username": "ajesk",
                        "content": "What do you use instead of float. I am looking for alternatives, but am hitting a wall on this one detail. Otherwise my solution seems to be valid."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I can see that this problem is going to have a lot of haters because this is low on logic, and high on unnecessary things to take care of!!"
                    },
                    {
                        "username": "ToHe-Mt",
                        "content": "it is math, gradient\\nMany people do not notice because same on gradients do not mean it is the same line"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "A Hard !! Finally Jan challenge has picked Up!! \\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1\\uD83C\\uDFC1"
                    },
                    {
                        "username": "ravikumar950832",
                        "content": "this question onlt on base in dsa"
                    },
                    {
                        "username": "alex49",
                        "content": "I am trying to use the triangle inequality to solve this problem. However can\\'t overcome the precision issue.\\n\\nAny suggestion how to overcome this issue?\\n\\n `class Solution {\\npublic:      \\n    struct point{\\n        int x;\\n        int y;\\n    };\\n\\n    float distance(point lhs, point rhs) const {\\n        float dx = (lhs.x - rhs.x);\\n        float dy = (lhs.y - rhs.y);\\n        return std::sqrt(dx*dx + dy*dy);\\n    }\\n\\n    struct line{\\n        point begin;\\n        point end;\\n    };\\n\\n    bool equals(float lhs, float rhs) const {\\n         return std::abs(lhs - rhs) < \\n                std::numeric_limits<float>::epsilon();\\n    }\\n    \\n    bool belongs(line l, point p) const {\\n        std::array<float, 3> v{distance(l.begin, p), distance(l.begin, l.end), distance(l.end, p)};\\n        std::sort(begin(v), end(v));\\n        return equals(v.back(), v.front() + v[1]);\\n    }\\n\\n    int maxPoints(vector<vector<int>>& points) {\\n        if(points.empty()) return 0;\\n        if(points.size() == 1) return 1;\\n        std::vector<std::pair<line, int>> lines;\\n        for(int i = 0; i < points.size(); i++){\\n            for(int j = i + 1; j < points.size(); j++){\\n                point p1{points[i][0], points[i][1]};\\n                point p2{points[j][0], points[j][1]};\\n                lines.push_back({{p1, p2}, 0});\\n            }\\n        }\\n\\n        for(auto& e : lines){\\n            for(int i = 0; i < points.size(); i++){\\n                point p{points[i][0], points[i][1]};\\n                if(belongs(e.first, p)){\\n                    e.second++;\\n                }\\n            }\\n        }\\n\\n        auto max_el = std::max_element(begin(lines), end(lines), [](auto lhs, auto rhs){\\n            return lhs.second < rhs.second;\\n        });\\n        \\n        return max_el->second;\\n    }\\n};`\\n\\n"
                    },
                    {
                        "username": "gursewak22",
                        "content": "for precision issue i used like   slope =a/b   intercept=d/e   so four different number a b c d  \nbut change fraction to its lowest form before\n"
                    },
                    {
                        "username": "adjoint",
                        "content": "input =  [[1,0],[0,0]]\n\nshouldn't  the expected output is 1?!  ANY two points can be connected by EXACTLY ONE line (in euclidean geom, that is).  This answer makes ZERO sense; even lesser sense than 'single point' lines!\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The question is about the maximal number of points on a line.  \\nIn this case there is a line that contains both points, so the answer is `2`."
                    }
                ]
            }
        ]
    },
    {
        "title": "Group Shifted Strings",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564974,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 1566490,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 1567932,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 1958856,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 1571492,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            },
            {
                "id": 2004946,
                "content": [
                    {
                        "username": "sherryxmhe",
                        "content": "I don't quite understand the question. Successive letter means in alphabet order or the next letter in the string. And is \"ba\" the result of shifting \"az\" to the right? And we can't shift \"az\" to the left because z is the last letter in the alphabet?"
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\\n\"b\"->\"a\" which is 1 step.  \\n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\\n\\nright now the question isn\\'t well phrased."
                    },
                    {
                        "username": "dav1de24",
                        "content": "There is no requirement to sort or order in any way the answers, yet you flag incorrect answers with a different order. Please make sure you ask the question correctly."
                    },
                    {
                        "username": "forgetboy",
                        "content": "Input:\\n[\"ab\",\"ba\"]\\n\\nOutput:\\n[[\"ab\",\"ba\"]]\\n\\nExpected:\\n[[\"ba\"],[\"ab\"]]\\n\\n\\nMy code submission is failing with the message above. As far as I can see, the expected result is incorrect. If not, can someone please explain to me why that's the case. Thanks."
                    },
                    {
                        "username": "dev78",
                        "content": "The transition for \"ba\" -> \"az\"  is the following:\n\"b\"->\"a\" which is 1 step.  \n\"a\"->\"z\" is also one step, but in this case it loops around since z is the last character.\n\n\nThis is why \"ba\" and \"ab\" are not part of the shifting sequence.\nThe transition for \"b\" -> \"a\" is is 25 shifts  i.e. b to z and then a to b.\nThe transition for \"a\" -> \"b\" is 1 step.\n\nright now the question isn't well phrased."
                    },
                    {
                        "username": "housj1228",
                        "content": "You cannot get \\'ba\\' by simply shifting \\'ab\\'"
                    },
                    {
                        "username": "ybn4aq",
                        "content": "You guys really need to do a better job at properly describing the problem. In a real interview, the interviewee would be able to ask clarifying questions about the setup of the problem. This description is way too short, and doesn\\'t really explain that you\\'re able to shift backwards."
                    },
                    {
                        "username": "yanggao",
                        "content": "do we have to follow the ascending or descending sequence? \"acef\" is not continuous."
                    },
                    {
                        "username": "lanzhuoqin",
                        "content": "I got this failling:\\nInput\\nstrings =\\n[\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\\nOutput\\n[[\"abc\",\"bcd\",\"xyz\"],[\"acef\"],[\"az\"],[\"ba\"],[\"a\",\"z\"]]\\nExpected\\n[[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\\n\\n\\nCan you tell me why [\"az\",\"ba\"] is right?\\n\\'a\\' -> \\'z\\' seems reverse sequence of \\'b\\' -> \\'a\\'"
                    },
                    {
                        "username": "dealth",
                        "content": "The 25th char after ```a``` is ```z```, and the 25th char after ```b``` is ```a``` noting that implicitly each word in the string is cyclic from this ```We can keep shifting the string to form a sequence.``` "
                    }
                ]
            }
        ]
    },
    {
        "title": "Intersection of Two Arrays",
        "question_content": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [9,4]\n<strong>Explanation:</strong> [4,9] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 81969,
                "title": "three-java-solutions",
                "content": "Use two hash sets\\n\\nTime complexity: O(n)\\n\\n    public class Solution {\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n            Set<Integer> set = new HashSet<>();\\n            Set<Integer> intersect = new HashSet<>();\\n            for (int i = 0; i < nums1.length; i++) {\\n                set.add(nums1[i]);\\n            }\\n            for (int i = 0; i < nums2.length; i++) {\\n                if (set.contains(nums2[i])) {\\n                    intersect.add(nums2[i]);\\n                }\\n            }\\n            int[] result = new int[intersect.size()];\\n            int i = 0;\\n            for (Integer num : intersect) {\\n                result[i++] = num;\\n            }\\n            return result;\\n        }\\n    }\\n\\n\\nSort both arrays, use two pointers\\n\\nTime complexity: O(nlogn)\\n\\n    public class Solution {\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n            Set<Integer> set = new HashSet<>();\\n            Arrays.sort(nums1);\\n            Arrays.sort(nums2);\\n            int i = 0;\\n            int j = 0;\\n            while (i < nums1.length && j < nums2.length) {\\n                if (nums1[i] < nums2[j]) {\\n                    i++;\\n                } else if (nums1[i] > nums2[j]) {\\n                    j++;\\n                } else {\\n                    set.add(nums1[i]);\\n                    i++;\\n                    j++;\\n                }\\n            }\\n            int[] result = new int[set.size()];\\n            int k = 0;\\n            for (Integer num : set) {\\n                result[k++] = num;\\n            }\\n            return result;\\n        }\\n    }\\n\\nBinary search\\n\\nTime complexity: O(nlogn)\\n\\n    public class Solution {\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n            Set<Integer> set = new HashSet<>();\\n            Arrays.sort(nums2);\\n            for (Integer num : nums1) {\\n                if (binarySearch(nums2, num)) {\\n                    set.add(num);\\n                }\\n            }\\n            int i = 0;\\n            int[] result = new int[set.size()];\\n            for (Integer num : set) {\\n                result[i++] = num;\\n            }\\n            return result;\\n        }\\n        \\n        public boolean binarySearch(int[] nums, int target) {\\n            int low = 0;\\n            int high = nums.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target) {\\n                    return true;\\n                }\\n                if (nums[mid] > target) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Hash Table",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n            Set<Integer> set = new HashSet<>();\\n            Set<Integer> intersect = new HashSet<>();\\n            for (int i = 0; i < nums1.length; i++) {\\n                set.add(nums1[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 82001,
                "title": "8ms-concise-c-using-unordered-set",
                "content": "    class Solution {\\n    public:\\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n            unordered_set<int> m(nums1.begin(), nums1.end());\\n            vector<int> res;\\n            for (auto a : nums2)\\n                if (m.count(a)) {\\n                    res.push_back(a);\\n                    m.erase(a);\\n                }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n            unordered_set<int> m(nums1.begin(), nums1.end());\\n            vector<int> res;\\n            for (auto a : nums2)\\n                if (m.count(a)) {\\n                    res.push_back(a);\\n                    m.erase(a);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 82006,
                "title": "four-python-solutions-with-simple-explanation",
                "content": "Solution 1:\\n\\nuse set operation in python, one-line solution.\\n\\n    class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return list(set(nums1) & set(nums2))\\n\\n\\nSolution 2:\\n\\nbrute-force searching, search each element of the first list in the second list. (to be more efficient, you can sort the second list and use binary search to accelerate)\\n\\n    class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in nums1:\\n            if i not in res and i in nums2:\\n                res.append(i)\\n        \\n        return res\\n\\nSolution 3:\\n\\nuse dict/hashmap to record all nums appeared in the first list, and then check if there are nums in the second list have appeared in the map.\\n\\n    class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        map = {}\\n        for i in nums1:\\n            map[i] = map[i]+1 if i in map else 1\\n        for j in nums2:\\n            if j in map and map[j] > 0:\\n                res.append(j)\\n                map[j] = 0\\n        \\n        return res\\n\\nSolution 4:\\n\\nsort the two list, and use two pointer to search in the lists to find common elements.\\n\\n    class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        nums1.sort()\\n        nums2.sort()\\n        i = j = 0\\n        while (i < len(nums1) and j < len(nums2)):\\n            if nums1[i] > nums2[j]:\\n                j += 1\\n            elif nums1[i] < nums2[j]:\\n                i += 1\\n            else:\\n                if not (len(res) and nums1[i] == res[len(res)-1]):\\n                    res.append(nums1[i])\\n                i += 1\\n                j += 1\\n        \\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        return list(set(nums1) & set(nums2))\\n\\n\\nSolution 2:\\n\\nbrute-force searching, search each element of the first list in the second list. (to be more efficient, you can sort the second list and use binary search to accelerate)\\n\\n    class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in nums1:\\n            if i not in res and i in nums2:\\n                res.append(i)\\n        \\n        return res\\n\\nSolution 3:\\n\\nuse dict/hashmap to record all nums appeared in the first list, and then check if there are nums in the second list have appeared in the map.\\n\\n    class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        map = {}",
                "codeTag": "Java"
            },
            {
                "id": 81966,
                "title": "small-c-solution",
                "content": "    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s(nums1.begin(), nums1.end());\\n        vector<int> out;\\n        for (int x : nums2)\\n            if (s.erase(x))\\n                out.push_back(x);\\n        return out;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s(nums1.begin(), nums1.end());\\n        vector<int> out;\\n        for (int x : nums2)\\n            if (s.erase(x))\\n                out.push_back(x);\\n        return out;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 81974,
                "title": "5ms-java-using-1-hashset-and-time-complexity-of-o-m-n",
                "content": "    HashSet<Integer> set = new HashSet<Integer>();\\n            ArrayList<Integer> res = new ArrayList<Integer>();\\n            //Add all elements to set from array 1\\n            for(int i =0; i< nums1.length; i++) set.add(nums1[i]);\\n            for(int j = 0; j < nums2.length; j++) {\\n               // If present in array 2 then add to res and remove from set \\n               if(set.contains(nums2[j])) {\\n                    res.add(nums2[j]);\\n                    set.remove(nums2[j]);\\n                }\\n            }\\n            // Convert ArrayList to array\\n            int[] arr = new int[res.size()];\\n            for (int i= 0; i < res.size(); i++) arr[i] = res.get(i);\\n            return arr;",
                "solutionTags": [
                    "Java"
                ],
                "code": "    HashSet<Integer> set = new HashSet<Integer>();\\n            ArrayList<Integer> res = new ArrayList<Integer>();\\n            //Add all elements to set from array 1\\n            for(int i =0; i< nums1.length; i++) set.add(nums1[i]);\\n            for(int j = 0; j < nums2.length; j++) {\\n               // If present in array 2 then add to res and remove from set \\n               if(set.contains(nums2[j])) {\\n                    res.add(nums2[j]);\\n                    set.remove(nums2[j]);\\n                }\\n            }\\n            // Convert ArrayList to array\\n            int[] arr = new int[res.size()];\\n            for (int i= 0; i < res.size(); i++) arr[i] = res.get(i);\\n            return arr;",
                "codeTag": "Unknown"
            },
            {
                "id": 3104940,
                "title": "java-best-solution-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni have used HashSet to solve the Question.\\n- First i have copied the array to the Sets to Remove Duplicates.\\n- Then i checked whether Elements of 1st Hashset is present in the 2nd Hashset or not by using .contains() Function.\\n- Then Add to a new Set And then copied to the integer array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Set;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        for (int i : nums1) {\\n            set1.add(i);\\n        }\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int i : nums2) {\\n            set2.add(i);\\n        }\\n        //Removed Duplicates using Hashset\\n        Set<Integer> Main_Set = new HashSet<>();\\n        for (Integer var : set1) {\\n            if (set2.contains(var)) {\\n                Main_Set.add(var);\\n            }\\n        }\\n        int[] arr = new int[Main_Set.size()];\\n        int j = 0;\\n        for (Integer val : Main_Set) {\\n            arr[j] = val.intValue();\\n            j++;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e4f1e2a8-b10b-46db-9ce6-9c2562a1a933_1674945307.2145095.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Set;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        for (int i : nums1) {\\n            set1.add(i);\\n        }\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int i : nums2) {\\n            set2.add(i);\\n        }\\n        //Removed Duplicates using Hashset\\n        Set<Integer> Main_Set = new HashSet<>();\\n        for (Integer var : set1) {\\n            if (set2.contains(var)) {\\n                Main_Set.add(var);\\n            }\\n        }\\n        int[] arr = new int[Main_Set.size()];\\n        int j = 0;\\n        for (Integer val : Main_Set) {\\n            arr[j] = val.intValue();\\n            j++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82187,
                "title": "javascript-solution-with-set",
                "content": "    function intersection(nums1, nums2) {\\n        const set = new Set(nums1);\\n        return [...new Set(nums2.filter(n => set.has(n)))];\\n    }",
                "solutionTags": [],
                "code": "    function intersection(nums1, nums2) {\\n        const set = new Set(nums1);\\n        return [...new Set(nums2.filter(n => set.has(n)))];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1265039,
                "title": "c-basic-set-and-find",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n      // put the values in set to remove duplicate\\n        set<int>s1,s2;\\n        vector<int>out;\\n        for(auto val:nums1)\\n            s1.insert(val);\\n        for(auto val:nums2)\\n            s2.insert(val);\\n        \\n        //find if we can get the value from first set in second set\\n        for(auto val:s1)\\n        {\\n           if(s2.find(val)!=s2.end()) //if found push it into output vector\\n               out.push_back(val);\\n        }\\n        return out;\\n    }\\n};\\n\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n      // put the values in set to remove duplicate\\n        set<int>s1,s2;\\n        vector<int>out;\\n        for(auto val:nums1)\\n            s1.insert(val);\\n        for(auto val:nums2)\\n            s2.insert(val);\\n        \\n        //find if we can get the value from first set in second set\\n        for(auto val:s1)\\n        {\\n           if(s2.find(val)!=s2.end()) //if found push it into output vector\\n               out.push_back(val);\\n        }\\n        return out;\\n    }\\n};\\n\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82118,
                "title": "c-two-pointer-easy-understand-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n            sort(nums1.begin(), nums1.end());\\n            sort(nums2.begin(), nums2.end());\\n            int n1 = (int)nums1.size(), n2 = (int)nums2.size();\\n            int i1 = 0, i2 = 0;\\n            vector<int> res;\\n            while(i1 < n1 && i2 < n2){\\n                if(nums1[i1] == nums2[i2]) {\\n                    res.push_back(nums1[i1]);\\n                    i1++;\\n                    i2++;\\n                }\\n                else if(nums1[i1] > nums2[i2]){\\n                    i2++;\\n                }\\n                else{\\n                    i1++;\\n                }\\n                while(i1 > 0 && i1 < n1 && nums1[i1] == nums1[i1 - 1]) i1++;\\n                while(i2 > 0 && i2 < n2 && nums2[i2] == nums2[i2 - 1]) i2++;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n            sort(nums1.begin(), nums1.end());\\n            sort(nums2.begin(), nums2.end());\\n            int n1 = (int)nums1.size(), n2 = (int)nums2.size();\\n            int i1 = 0, i2 = 0;\\n            vector<int> res;\\n            while(i1 < n1 && i2 < n2){\\n                if(nums1[i1] == nums2[i2]) {\\n                    res.push_back(nums1[i1]);\\n                    i1++;\\n                    i2++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 81999,
                "title": "python-code-3-lines-using-set",
                "content": "    class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums1=set(nums1)\\n        nums2=set(nums2)\\n        return list(nums1&nums2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums1=set(nums1)\\n        nums2=set(nums2)\\n        return list(nums1&nums2)",
                "codeTag": "Java"
            },
            {
                "id": 285818,
                "title": "javascript-solutions-brute-force-hashmap-set",
                "content": "//Brute Force Solution: O(n logn)\\n\\n```\\nfunction intersect(nums1, nums2){\\nlet sortedNums1 = nums1.sort((a , b) => a - b);\\n    let sortedNums2 = nums2.sort((a , b) => a - b);\\n    let result = [];\\n    let i = 0;\\n    let j = 0;\\n    \\n    while(i < sortedNums1.length && j < sortedNums2.length){\\n        if(sortedNums1[i] === sortedNums2[j]){\\n            if(!result.includes(sortedNums1[i])) result.push(sortedNums1[i]);\\n            i++;\\n            j++;\\n        }\\n        else if(sortedNums1[i] < sortedNums2[j]) i++;\\n        else j++;\\n    }\\n    return result;\\n}\\n```\\n\\n//HashMap Solution: O(n)\\n```\\nfunction intersect(nums1, nums2){\\n    let map = new Map();\\n    for(let num of nums1){\\n        if(!map.has(num))\\n            map.set(num, 1);\\n    }\\n    \\n    return nums2.filter(n => {\\n        if(map.has(n)){\\n            map.delete(n);\\n            return true;\\n        }\\n        else return false;\\n    });\\n}\\n```\\n\\n//Solutions using Set\\n\\n//Solution 1: O(n)\\n```\\nfunction intersect(nums1, nums2){\\n    let result = [];\\n    let setNum1 = new Set(nums1);\\n    let setNum2 = new Set(nums2);\\n\\n    let [smallSet , largeSet] = (setNum1.length < setNum2.length) ? [setNum1 , setNum2] : [setNum2 , setNum1];\\n\\n    smallSet.forEach( num => {\\n        largeSet.has(num) && result.push(num);\\n    });\\n\\n    return result;\\n}\\n```\\n\\n//Solution 2: O(n)\\n```\\nfunction intersect(nums1 , nums2){\\n    let setNum1 = new Set(nums1);\\n\\n    return [...new Set(nums2.filter(num => setNum1.has(num)))];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nfunction intersect(nums1, nums2){\\nlet sortedNums1 = nums1.sort((a , b) => a - b);\\n    let sortedNums2 = nums2.sort((a , b) => a - b);\\n    let result = [];\\n    let i = 0;\\n    let j = 0;\\n    \\n    while(i < sortedNums1.length && j < sortedNums2.length){\\n        if(sortedNums1[i] === sortedNums2[j]){\\n            if(!result.includes(sortedNums1[i])) result.push(sortedNums1[i]);\\n            i++;\\n            j++;\\n        }\\n        else if(sortedNums1[i] < sortedNums2[j]) i++;\\n        else j++;\\n    }\\n    return result;\\n}\\n```\n```\\nfunction intersect(nums1, nums2){\\n    let map = new Map();\\n    for(let num of nums1){\\n        if(!map.has(num))\\n            map.set(num, 1);\\n    }\\n    \\n    return nums2.filter(n => {\\n        if(map.has(n)){\\n            map.delete(n);\\n            return true;\\n        }\\n        else return false;\\n    });\\n}\\n```\n```\\nfunction intersect(nums1, nums2){\\n    let result = [];\\n    let setNum1 = new Set(nums1);\\n    let setNum2 = new Set(nums2);\\n\\n    let [smallSet , largeSet] = (setNum1.length < setNum2.length) ? [setNum1 , setNum2] : [setNum2 , setNum1];\\n\\n    smallSet.forEach( num => {\\n        largeSet.has(num) && result.push(num);\\n    });\\n\\n    return result;\\n}\\n```\n```\\nfunction intersect(nums1 , nums2){\\n    let setNum1 = new Set(nums1);\\n\\n    return [...new Set(nums2.filter(num => setNum1.has(num)))];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1288881,
                "title": "easy-and-concise-c-solution-o-n",
                "content": "```\\nPlease upvote if it helped :) \\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int l1=nums1.size(),l2=nums2.size();\\n        vector<int> ans;\\n        \\n            int arr[1001]={-1};\\n            for(int i=0;i<l1;i++){\\n                arr[nums1[i]]=1;\\n            }\\n            for(int i=0;i<l2;i++){\\n                //if element is present in array1 push to ans and make it -1 \\n                if(arr[nums2[i]]==1) {\\n                    ans.push_back(nums2[i]); \\n                    arr[nums2[i]]=-1;\\n                }\\n            }\\n            return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nPlease upvote if it helped :) \\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int l1=nums1.size(),l2=nums2.size();\\n        vector<int> ans;\\n        \\n            int arr[1001]={-1};\\n            for(int i=0;i<l1;i++){\\n                arr[nums1[i]]=1;\\n            }\\n            for(int i=0;i<l2;i++){\\n                //if element is present in array1 push to ans and make it -1 \\n                if(arr[nums2[i]]==1) {\\n                    ans.push_back(nums2[i]); \\n                    arr[nums2[i]]=-1;\\n                }\\n            }\\n            return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015238,
                "title": "4-approaches-o-n-easy-to-understand-c-java",
                "content": "\\n**Implementation**\\n\\n**1st Approach in C++**\\nTime Complexity = O(N*M), Space Complexity = O(N)\\nWhere N = nums1.size(), M = nums2.size()\\n-> Using Set & Vector \\n```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n    set<int> st;        \\n    for(int itr = 0; itr < nums1.size(); itr++){\\n        for(int jtr = 0; jtr < nums2.size(); jtr++){\\n            if(nums1[itr] == nums2[jtr]){\\n                st.insert(nums1[itr]);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    vector<int> vt;\\n    for(auto itr = st.begin(); itr != st.end(); itr++){\\n        vt.push_back(*itr);\\n    }\\n    return vt;\\n}\\n```\\n\\n\\n**2nd Approach in C++**\\nTime Complexity = O(N), Space Complexity = O(N)\\n-> Using Set & Vector\\n```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> st(nums1.begin(), nums1.end());\\n        vector<int> res;\\n        for(int itr = 0; itr < nums2.size(); itr++){\\n            if(st.find(nums2[itr]) != st.end()){\\n                res.emplace_back(nums2[itr]);\\n                st.erase(nums2[itr]);\\n            }            \\n        }\\n        return res;\\n    }\\n```\\n\\n\\n**3rd Approach in Java**\\nTime Complexity = O(N*M), Space Complexity = O(N)\\nwhere N = nums1.length, M = nums2.length\\n-> Using HashSet and Array\\n\\n```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n    HashSet<Integer> set = new HashSet();  \\n    \\n    for(int itr = 0; itr < nums1.length; itr++){\\n        for(int jtr = 0; jtr < nums2.length; jtr++){\\n            if(nums1[itr] == nums2[jtr]){\\n                set.add(nums1[itr]);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    int[] arr = new int[set.size()];        \\n    int jtr = 0;\\n    for (int itr : set)  \\n        arr[jtr++] = itr; \\n    \\n    return arr;\\n}\\n```\\n\\n\\n**4th Approach in Java**\\nTime Complexity = O(N), Space Complexity = O(N)\\n-> Using two HashSet & one Array\\n\\n```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n    HashSet<Integer> set = new HashSet(); \\n    HashSet<Integer> res = new HashSet(); \\n    \\n    for(int itr = 0; itr < nums1.length; itr++){\\n        set.add(nums1[itr]);\\n    }\\n    \\n    for(int itr = 0; itr < nums2.length; itr++){\\n        if(set.contains(nums2[itr])) res.add(nums2[itr]);\\n    }\\n    \\n    int[] arr = new int[res.size()];        \\n    int jtr = 0;\\n    for (int itr : res)  \\n        arr[jtr++] = itr; \\n    \\n    return arr;\\n}\\n```\\n\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array"
                ],
                "code": "```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n    set<int> st;        \\n    for(int itr = 0; itr < nums1.size(); itr++){\\n        for(int jtr = 0; jtr < nums2.size(); jtr++){\\n            if(nums1[itr] == nums2[jtr]){\\n                st.insert(nums1[itr]);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    vector<int> vt;\\n    for(auto itr = st.begin(); itr != st.end(); itr++){\\n        vt.push_back(*itr);\\n    }\\n    return vt;\\n}\\n```\n```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> st(nums1.begin(), nums1.end());\\n        vector<int> res;\\n        for(int itr = 0; itr < nums2.size(); itr++){\\n            if(st.find(nums2[itr]) != st.end()){\\n                res.emplace_back(nums2[itr]);\\n                st.erase(nums2[itr]);\\n            }            \\n        }\\n        return res;\\n    }\\n```\n```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n    HashSet<Integer> set = new HashSet();  \\n    \\n    for(int itr = 0; itr < nums1.length; itr++){\\n        for(int jtr = 0; jtr < nums2.length; jtr++){\\n            if(nums1[itr] == nums2[jtr]){\\n                set.add(nums1[itr]);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    int[] arr = new int[set.size()];        \\n    int jtr = 0;\\n    for (int itr : set)  \\n        arr[jtr++] = itr; \\n    \\n    return arr;\\n}\\n```\n```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n    HashSet<Integer> set = new HashSet(); \\n    HashSet<Integer> res = new HashSet(); \\n    \\n    for(int itr = 0; itr < nums1.length; itr++){\\n        set.add(nums1[itr]);\\n    }\\n    \\n    for(int itr = 0; itr < nums2.length; itr++){\\n        if(set.contains(nums2[itr])) res.add(nums2[itr]);\\n    }\\n    \\n    int[] arr = new int[res.size()];        \\n    int jtr = 0;\\n    for (int itr : res)  \\n        arr[jtr++] = itr; \\n    \\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3075714,
                "title": "simple-c-code-beats-95-98-and-81-17",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed vector and count() for checking if the number present in \"nums1\" is also present in \"nums2\", also for checking if the number present in both \"nums1\" and \"nums2\" is already in \"result\" vector or not.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        for(auto i : nums1){\\n            if(count(nums2.begin(),nums2.end(),i)>0){//checks if the number present in \"nums1\" is also present in \"nums2\" \\n                if(count(result.begin(),result.end(),i)==0){//checks if the number present in both \"nums1\" and \"nums2\" is already in \"result\" vector or not\\n                result.push_back(i);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        for(auto i : nums1){\\n            if(count(nums2.begin(),nums2.end(),i)>0){//checks if the number present in \"nums1\" is also present in \"nums2\" \\n                if(count(result.begin(),result.end(),i)==0){//checks if the number present in both \"nums1\" and \"nums2\" is already in \"result\" vector or not\\n                result.push_back(i);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532271,
                "title": "c-best-easiest-fully-optimised-solution-2-pointer-beats-100-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 Pointer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolution class and intersection function that takes two integer vectors as input and returns a vector containing the common elements between them.\\n\\nInitialize l1 and l2 to sizes of nums1 and nums2, and i and j to 0.\\n\\nInitialize an empty vector called ans.\\n\\nSort both vectors in ascending order.\\n\\nWhile loop that checks if the current element in nums1 is less than, equal to, or greater than the current element in nums2. Increments pointers accordingly.\\n\\nRemove duplicates from the ans vector.\\n\\nReturn the ans vector containing all common elements between both vectors.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(m log m + n log n + m + n), \\n\\nwhere m and n are the sizes of nums1 and nums2 respectively.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(min(m, n)),\\n\\n which is the size of the ans vector.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int l1=nums1.size(),l2=nums2.size(),i=0,j=0;\\n        vector<int>ans;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        while(i<l1&&j<l2)\\n        {\\n            if(nums1[i]<nums2[j]) i++;\\n            else if(nums1[i]==nums2[j]) \\n            {\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]>nums2[j]) j++;\\n        }\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/b4ca06f5-81ec-4818-95b9-93319e245945_1684272814.3293145.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int l1=nums1.size(),l2=nums2.size(),i=0,j=0;\\n        vector<int>ans;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        while(i<l1&&j<l2)\\n        {\\n            if(nums1[i]<nums2[j]) i++;\\n            else if(nums1[i]==nums2[j]) \\n            {\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]>nums2[j]) j++;\\n        }\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181851,
                "title": "java-solution-easy-to-understand",
                "content": "# Kindly upvote if you like it.\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i: nums1){\\n            set.add(i);\\n        }\\n        \\n        HashSet<Integer> intersection = new HashSet<Integer>();\\n        for(int i: nums2){\\n            if(set.contains(i)){\\n                intersection.add(i);\\n            }\\n        }\\n        int[] result = new int[intersection.size()];\\n        int index = 0;\\n        for(int i: intersection){\\n            result[index++] = i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i: nums1){\\n            set.add(i);\\n        }\\n        \\n        HashSet<Integer> intersection = new HashSet<Integer>();\\n        for(int i: nums2){\\n            if(set.contains(i)){\\n                intersection.add(i);\\n            }\\n        }\\n        int[] result = new int[intersection.size()];\\n        int index = 0;\\n        for(int i: intersection){\\n            result[index++] = i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82003,
                "title": "1-line-in-python",
                "content": "    class Solution(object):\\n        def intersection(self, nums1, nums2):\\n            return list(set(nums1) & set(nums2))",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def intersection(self, nums1, nums2):\\n            return list(set(nums1) & set(nums2))",
                "codeTag": "Java"
            },
            {
                "id": 3972623,
                "title": "java-simple-solution-runtime-2ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public static int[] intersection(int[] nums1, int[] nums2)\\n    {\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n\\n        for (int n : nums1) {\\n            set1.add(n);\\n        }\\n\\n        for (int n : nums2) {\\n            if (set1.contains(n))\\n                set2.add(n);\\n        }\\n\\n        int [] result = new int[set2.size()];\\n            int index = 0;\\n        for (int n : set2){\\n            result[index++] = n;\\n        }\\n        \\n        return result;\\n    }\\n\\n}\\n\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/e241932a-8bf6-464e-b84e-60a94ba6cb05_1693240497.4174669.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public static int[] intersection(int[] nums1, int[] nums2)\\n    {\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n\\n        for (int n : nums1) {\\n            set1.add(n);\\n        }\\n\\n        for (int n : nums2) {\\n            if (set1.contains(n))\\n                set2.add(n);\\n        }\\n\\n        int [] result = new int[set2.size()];\\n            int index = 0;\\n        for (int n : set2){\\n            result[index++] = n;\\n        }\\n        \\n        return result;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457033,
                "title": "python-solution-using-one-dictionary",
                "content": "n -> length of nums1\\nm -> length of nums2\\nTime Complexity: O(n+m)\\nSpace Complexity: O(n)\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        d = {}\\n        res = []\\n        for n in nums1:\\n          d[n] = 1\\n          \\n        for n in nums2:\\n\\t\\t  # Check if n is in dictionary and not in the result\\n          if n in d and d[n]:\\n            res.append(n)\\n            d[n] -= 1 # It will set the value of d[n] = 0 which will indicate we already added n in result\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        d = {}\\n        res = []\\n        for n in nums1:\\n          d[n] = 1\\n          \\n        for n in nums2:\\n\\t\\t  # Check if n is in dictionary and not in the result\\n          if n in d and d[n]:\\n            res.append(n)\\n            d[n] -= 1 # It will set the value of d[n] = 0 which will indicate we already added n in result\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185214,
                "title": "faster-than-100-very-simple-and-explained-and-clean-solution-in-c-using-visited-array-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n      vector<bool>vis(1000);//to keep record of the visited number to avoid duplicates\\n      unordered_map<int,int>mymap;//to count the number so that we can match it with other set of vector given\\n      vector<int>ans;\\n      for(int i=0;i<nums1.size();i++)\\n        mymap[nums1[i]]++;\\n      for(int i=0;i<nums2.size();i++)\\n      {\\n        if(mymap.find(nums2[i])!=mymap.end()&&!vis[nums2[i]])// if we found nums2 element in map that means it is present in nums1. then we have to check if it is visited then we have to skip it to avoid duplicates otherwise add to the vector ans turn visited to be true.\\n          ans.push_back(nums2[i]),vis[nums2[i]]=true;\\n      }return ans;\\n    }\\n};\\ndo upvote if you find it useful..........\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n      vector<bool>vis(1000);//to keep record of the visited number to avoid duplicates\\n      unordered_map<int,int>mymap;//to count the number so that we can match it with other set of vector given\\n      vector<int>ans;\\n      for(int i=0;i<nums1.size();i++)\\n        mymap[nums1[i]]++;\\n      for(int i=0;i<nums2.size();i++)\\n      {\\n        if(mymap.find(nums2[i])!=mymap.end()&&!vis[nums2[i]])// if we found nums2 element in map that means it is present in nums1. then we have to check if it is visited then we have to skip it to avoid duplicates otherwise add to the vector ans turn visited to be true.\\n          ans.push_back(nums2[i]),vis[nums2[i]]=true;\\n      }return ans;\\n    }\\n};\\ndo upvote if you find it useful..........\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618386,
                "title": "easiest-c-soln-with-binary-search",
                "content": "**Time Complexity: O(NlogN)**\\n\\n```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int>ans;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int lb=0,ub=nums2.size()-1,mid=0;\\n            while(lb<=ub)\\n            {\\n                mid=lb+(ub-lb)/2;\\n                if(nums2[mid]==nums1[i])\\n                {\\n                    if(find(ans.begin(),ans.end(),nums2[mid])!=ans.end())\\n                        break;\\n                    ans.push_back(nums2[mid]);\\n                    break;\\n                }\\n                else if(nums2[mid]<nums1[i])\\n                    lb=mid+1;\\n                else\\n                    ub=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nIf you liked my soln, please hit an upvote.\\nIf you got a query with the soln, drop a comment and lets discuss!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int>ans;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int lb=0,ub=nums2.size()-1,mid=0;\\n            while(lb<=ub)\\n            {\\n                mid=lb+(ub-lb)/2;\\n                if(nums2[mid]==nums1[i])\\n                {\\n                    if(find(ans.begin(),ans.end(),nums2[mid])!=ans.end())\\n                        break;\\n                    ans.push_back(nums2[mid]);\\n                    break;\\n                }\\n                else if(nums2[mid]<nums1[i])\\n                    lb=mid+1;\\n                else\\n                    ub=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3028898,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans.push_back(nums1[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());//Erasing all the duplicate elements.\\n        return ans;\\n    }\\n};\\n```\\n# Upvote if this helped!~\\n![upvote5.jpeg](https://assets.leetcode.com/users/images/3aeeed89-dcf4-4035-94f3-ff155b9ea8df_1674373210.2596724.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans.push_back(nums1[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());//Erasing all the duplicate elements.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180949,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> result;\\n        int i=0,j=0;\\n        while(i<nums1.size()&&j<nums2.size()){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else if(nums2[j]>nums1[i]){\\n                i++;\\n            }\\n            else{\\n                if(!count(result.begin(),result.end(),nums1[i]))\\n                    result.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n       return result; \\n    }\\n};\\n```\\n***Please upvote if you find it helpful***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> result;\\n        int i=0,j=0;\\n        while(i<nums1.size()&&j<nums2.size()){\\n            if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else if(nums2[j]>nums1[i]){\\n                i++;\\n            }\\n            else{\\n                if(!count(result.begin(),result.end(),nums1[i]))\\n                    result.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n       return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507780,
                "title": "easy-solution-with-set",
                "content": "```\\nvar intersection = function(nums1, nums2) {\\n  const num1Set = new Set(nums1);\\n  const num2Set = new Set(nums2);\\n  \\n  const result = [];\\n  \\n  for (var value of num1Set) {\\n    if (num2Set.has(value)) {\\n      result.push(value);\\n    }\\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intersection = function(nums1, nums2) {\\n  const num1Set = new Set(nums1);\\n  const num2Set = new Set(nums2);\\n  \\n  const result = [];\\n  \\n  for (var value of num1Set) {\\n    if (num2Set.has(value)) {\\n      result.push(value);\\n    }\\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500206,
                "title": "python3-dictionary-with-comments-faster-than-90-88-less-than-100",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        dictionary = {}\\n        \\n        \"\"\"\\n        Traverse nums1 to see which numbers are not in dictionary,\\n        if not in dictionary we add it to the dictionary with value 1.\\n        \"\"\"\\n        for index in nums1:\\n            if index not in dictionary:\\n                dictionary[index] = 1\\n                \\n        \"\"\"\\n        Traverse nums2 to see which numbers are already in dictionary. Also \\n        make sure that we stop at value 2 so we do not add the number (key) \\n        more than once. \\n        \"\"\"\\n        for index in nums2:\\n            if index in dictionary and dictionary[index] != 2:\\n                dictionary[index] += 1\\n        \\n        \"\"\"\\n        Check which keys have a value of 2, this means that they appear in\\n        both lists at least once. Add those keys to a new list then output\\n        the new list.\\n        \"\"\"\\n        newList = []\\n        for key, value in dictionary.items():\\n            if value == 2:\\n                newList.append(key)\\n                \\n        return newList\\n```\\n\\n![image](https://assets.leetcode.com/users/clxu/image_1580928729.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        dictionary = {}\\n        \\n        \"\"\"\\n        Traverse nums1 to see which numbers are not in dictionary,\\n        if not in dictionary we add it to the dictionary with value 1.\\n        \"\"\"\\n        for index in nums1:\\n            if index not in dictionary:\\n                dictionary[index] = 1\\n                \\n        \"\"\"\\n        Traverse nums2 to see which numbers are already in dictionary. Also \\n        make sure that we stop at value 2 so we do not add the number (key) \\n        more than once. \\n        \"\"\"\\n        for index in nums2:\\n            if index in dictionary and dictionary[index] != 2:\\n                dictionary[index] += 1\\n        \\n        \"\"\"\\n        Check which keys have a value of 2, this means that they appear in\\n        both lists at least once. Add those keys to a new list then output\\n        the new list.\\n        \"\"\"\\n        newList = []\\n        for key, value in dictionary.items():\\n            if value == 2:\\n                newList.append(key)\\n                \\n        return newList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82222,
                "title": "several-java-solutions-with-explanation",
                "content": "Solution using Java Collections\\n\\n 1. Convert first array to the set\\n 2. Convert second array to the set\\n 3. Use retainAll to find set intersection\\n 4. Convert intersection set to array\\n\\n        // O(max(n, m)) time, O(n + m) space\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n          Set<Integer> a = new HashSet<>(Arrays.stream(nums1).boxed().collect(Collectors.toList()));\\n          Set<Integer> b = new HashSet<>(Arrays.stream(nums2).boxed().collect(Collectors.toList()));\\n          a.retainAll(b);\\n          return a.stream().mapToInt(Integer::intValue).toArray();\\n        }\\n\\n\\nSolution sing sorting\\n\\n 1. Sort first array\\n 2. Sort second array\\n 3. Use two pointers to traverse first and second sorted arrays\\n 4. If first pointer points to bigger value - move the second pointer\\n 5. If second pointer points to bigger value - move the first pointer\\n 6. If pointers point to equal values add it to result array and move both pointers to the next distinct value\\n 7. Repeate 4-6 until any pointer reaches the end of array\\n 8. Shrink the size of intersection array to remove unused space\\n\\n        // O(max(n, m) log max(n, m)) time, O(min(n, m)) space\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n          Arrays.sort(nums1);\\n          Arrays.sort(nums2);\\n          int[] intersect = new int[Math.min(nums1.length, nums2.length)];\\n          int i = 0;\\n          for (int p1 = 0, p2 = 0; p1 < nums1.length && p2 < nums2.length;) {\\n            while (p1 < nums1.length && nums1[p1] < nums2[p2]) {\\n              p1++;\\n            }\\n            while (p1 < nums1.length && p2 < nums2.length && nums1[p1] > nums2[p2]) {\\n              p2++;\\n            }\\n            if (p1 < nums1.length && p2 < nums2.length && nums1[p1] == nums2[p2]) {\\n              intersect[i++] = nums1[p1];\\n              while (p1 < nums1.length && nums1[p1] == intersect[i-1]) {\\n                  p1++;\\n              }\\n              while (p2 < nums2.length && nums2[p2] == intersect[i-1]) {\\n                  p2++;\\n              }\\n            }\\n          }                \\n          int[] result = new int[i];\\n          for (; i-1 >= 0; i--) {\\n            result[i-1] = intersect[i-1];\\n          }\\n          return result;\\n        }\\n\\nBrute-force solution\\n\\n 1. For each element in first array traverse second array\\n 2. While traversing second array check for values match\\n 3. If there is a match check if it is unique by traversing intersection array\\n 4. If match is unique add it to intersection array.\\n 5. Shrink intersection array\\n\\n        // nums1.length = n, nums2.length = m\\n        // O (n * m * min(n, m)) time, O(min(n, m)) space\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n          int[] intersect = new int[Math.min(nums1.length, nums2.length)];\\n          int index = 0;\\n          for (int i = 0; i < nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n              if (nums1[i] == nums2[j]) {\\n                boolean isUnique = true;\\n                for (int k = 0; k < index; k++) {\\n                  if (nums1[i] == intersect[k]) {\\n                    isUnique = false;\\n                  }\\n                }\\n                if (isUnique) {\\n                  intersect[index++] = nums1[i];   \\n                }\\n              }\\n            }\\n          }\\n          int[] result = new int[index];\\n          for (; index-1 >= 0; index--) {\\n            result[index-1] = intersect[index-1];\\n          }\\n          return result;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Solution using Java Collections\\n\\n 1. Convert first array to the set\\n 2. Convert second array to the set\\n 3. Use retainAll to find set intersection\\n 4. Convert intersection set to array\\n\\n        // O(max(n, m)) time, O(n + m) space\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n          Set<Integer> a = new HashSet<>(Arrays.stream(nums1).boxed().collect(Collectors.toList()));\\n          Set<Integer> b = new HashSet<>(Arrays.stream(nums2).boxed().collect(Collectors.toList()));\\n          a.retainAll(b);\\n          return a.stream().mapToInt(Integer::intValue).toArray();\\n        }\\n\\n\\nSolution sing sorting\\n\\n 1. Sort first array\\n 2. Sort second array\\n 3. Use two pointers to traverse first and second sorted arrays\\n 4. If first pointer points to bigger value - move the second pointer\\n 5. If second pointer points to bigger value - move the first pointer\\n 6. If pointers point to equal values add it to result array and move both pointers to the next distinct value\\n 7. Repeate 4-6 until any pointer reaches the end of array\\n 8. Shrink the size of intersection array to remove unused space\\n\\n        // O(max(n, m) log max(n, m)) time, O(min(n, m)) space\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n          Arrays.sort(nums1);\\n          Arrays.sort(nums2);\\n          int[] intersect = new int[Math.min(nums1.length, nums2.length)];\\n          int i = 0;\\n          for (int p1 = 0, p2 = 0; p1 < nums1.length && p2 < nums2.length;) {\\n            while (p1 < nums1.length && nums1[p1] < nums2[p2]) {\\n              p1++;\\n            }\\n            while (p1 < nums1.length && p2 < nums2.length && nums1[p1] > nums2[p2]) {\\n              p2++;\\n            }\\n            if (p1 < nums1.length && p2 < nums2.length && nums1[p1] == nums2[p2]) {\\n              intersect[i++] = nums1[p1];\\n              while (p1 < nums1.length && nums1[p1] == intersect[i-1]) {\\n                  p1++;\\n              }\\n              while (p2 < nums2.length && nums2[p2] == intersect[i-1]) {\\n                  p2++;\\n              }\\n            }\\n          }                \\n          int[] result = new int[i];\\n          for (; i-1 >= 0; i--) {\\n            result[i-1] = intersect[i-1];\\n          }\\n          return result;\\n        }\\n\\nBrute-force solution\\n\\n 1. For each element in first array traverse second array\\n 2. While traversing second array check for values match\\n 3. If there is a match check if it is unique by traversing intersection array\\n 4. If match is unique add it to intersection array.\\n 5. Shrink intersection array\\n\\n        // nums1.length = n, nums2.length = m\\n        // O (n * m * min(n, m)) time, O(min(n, m)) space\\n        public int[] intersection(int[] nums1, int[] nums2) {\\n          int[] intersect = new int[Math.min(nums1.length, nums2.length)];\\n          int index = 0;\\n          for (int i = 0; i < nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n              if (nums1[i] == nums2[j]) {\\n                boolean isUnique = true;\\n                for (int k = 0; k < index; k++) {\\n                  if (nums1[i] == intersect[k]) {\\n                    isUnique = false;\\n                  }\\n                }\\n                if (isUnique) {\\n                  intersect[index++] = nums1[i];   \\n                }\\n              }\\n            }\\n          }\\n          int[] result = new int[index];\\n          for (; index-1 >= 0; index--) {\\n            result[index-1] = intersect[index-1];\\n          }\\n          return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1878666,
                "title": "java-without-using-hashset",
                "content": "**Note:** *This is not so optimised solution. The only reason for posting this solution is for those who don\\'t have a knowledge of Hashset and I\\'ll recommend learning Hashset but for now you can also solve it using Brute force technique.*\\n\\n**Java Solution:**\\n\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        int[] temp = new int[1001];\\n        int count = 0;\\n        for (int num : nums1) {\\n            if (temp[num] != 1) {\\n                temp[num] = 1;\\n            }\\n        }\\n        for (int num : nums2) {\\n            if (temp[num] == 1) {\\n                temp[num] = 2;\\n                count++;\\n            }\\n        }\\n        \\n        int[] res = new int[count];\\n        int index = 0;\\n        for (int i = 0; i < temp.length; i++) {\\n            if (temp[i] == 2) {\\n                res[index++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nI hope it helps!\\nAn **upvote** would be really motivating for me, thanks :)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        int[] temp = new int[1001];\\n        int count = 0;\\n        for (int num : nums1) {\\n            if (temp[num] != 1) {\\n                temp[num] = 1;\\n            }\\n        }\\n        for (int num : nums2) {\\n            if (temp[num] == 1) {\\n                temp[num] = 2;\\n                count++;\\n            }\\n        }\\n        \\n        int[] res = new int[count];\\n        int index = 0;\\n        for (int i = 0; i < temp.length; i++) {\\n            if (temp[i] == 2) {\\n                res[index++] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588036,
                "title": "java-three-approaches",
                "content": "Kindly upvote, if it helps you!\\n```\\n\\tSolution no.1 - Using HashSet\\n\\tpublic int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        Set<Integer> intersection = new HashSet<>();\\n        for(int num: nums1){\\n            set.add(num);\\n        }\\n        for(int num: nums2){\\n            if(set.contains(num)){\\n                intersection.add(num);\\n            }\\n        }\\n        int[] result = new int[intersection.size()];\\n        int i = 0;\\n        for(int num: intersection){\\n            result[i] = num;\\n            i++;\\n        }\\n        return result;\\n    }\\n\\t\\n\\tSolution no.2 - Using BinarySearch\\n\\tpublic int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Set<Integer> intersection = new HashSet<>();\\n        for(int num: nums2){\\n            if(binarySearch(num, nums1))\\n                intersection.add(num);\\n        }\\n        int[] result = new int[intersection.size()];\\n        int i = 0;\\n        for(int num: intersection){\\n            result[i] = num;\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    public boolean binarySearch(int target, int[] nums){\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] == target)\\n                return true;\\n            else if(nums[mid] > target){\\n                end = mid - 1;\\n            }else \\n                start = mid + 1;\\n        }\\n        return false;\\n    }\\n\\n\\tSolution no.3 - Using Two Pointer Approach\\n\\tpublic int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        Set<Integer> intersect = new HashSet<>();\\n        int i = 0;\\n        int j = 0;\\n        while(i< nums1.length && j<nums2.length){\\n            if(nums1[i] == nums2[j]){\\n                intersect.add(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n        int[] result = new int[intersect.size()];\\n        int k = 0;\\n        for(int num: intersect){\\n            result[k] = num;\\n            k++;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\n\\tSolution no.1 - Using HashSet\\n\\tpublic int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        Set<Integer> intersection = new HashSet<>();\\n        for(int num: nums1){\\n            set.add(num);\\n        }\\n        for(int num: nums2){\\n            if(set.contains(num)){\\n                intersection.add(num);\\n            }\\n        }\\n        int[] result = new int[intersection.size()];\\n        int i = 0;\\n        for(int num: intersection){\\n            result[i] = num;\\n            i++;\\n        }\\n        return result;\\n    }\\n\\t\\n\\tSolution no.2 - Using BinarySearch\\n\\tpublic int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Set<Integer> intersection = new HashSet<>();\\n        for(int num: nums2){\\n            if(binarySearch(num, nums1))\\n                intersection.add(num);\\n        }\\n        int[] result = new int[intersection.size()];\\n        int i = 0;\\n        for(int num: intersection){\\n            result[i] = num;\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    public boolean binarySearch(int target, int[] nums){\\n        int start = 0;\\n        int end = nums.length-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] == target)\\n                return true;\\n            else if(nums[mid] > target){\\n                end = mid - 1;\\n            }else \\n                start = mid + 1;\\n        }\\n        return false;\\n    }\\n\\n\\tSolution no.3 - Using Two Pointer Approach\\n\\tpublic int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        Set<Integer> intersect = new HashSet<>();\\n        int i = 0;\\n        int j = 0;\\n        while(i< nums1.length && j<nums2.length){\\n            if(nums1[i] == nums2[j]){\\n                intersect.add(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n        int[] result = new int[intersect.size()];\\n        int k = 0;\\n        for(int num: intersect){\\n            result[k] = num;\\n            k++;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 405483,
                "title": "go-solution",
                "content": "```\\nfunc intersection(nums1 []int, nums2 []int) []int {\\n    var count = map[int]bool{}\\n    var result = []int{}\\n    for _,num := range nums1{\\n        count[num]=true\\n    }\\n    for _, num := range nums2{\\n        if(count[num]==true){\\n            result=append(result,num)\\n            count[num]=false\\n        }\\n    } \\n    return result    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc intersection(nums1 []int, nums2 []int) []int {\\n    var count = map[int]bool{}\\n    var result = []int{}\\n    for _,num := range nums1{\\n        count[num]=true\\n    }\\n    for _, num := range nums2{\\n        if(count[num]==true){\\n            result=append(result,num)\\n            count[num]=false\\n        }\\n    } \\n    return result    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619669,
                "title": "beginner-level-solution-o-n-beats-100-solutions-without-using-collection-framework",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is the naive approach where we solve the problem with time optimization at beginner level without using any collection framework (HashSet, etc.).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### Steps:\\n- We will make an extra array \"temp[]\" of size equal to range of nums array (given in constraint).\\n- Now we will set nums1[i] position in temp[] array as 1 (which means a number is occurred in first array).\\n- Next, we will iterate over second array i.e. nums2[] with a condition that checks whether the number already occurred in nums1[] or not with the help of temp[] array.\\n- If condition becomes true we will make temp[nums2[i]] as 2 i.e. it occured twice and is the intersection between nums1 & nums2\\n- Also, a counter variable will store the number of intersection elements\\n- Make an ans[] array of size of counter variable to store the intersection variable as index of temp;\\n- return the ans[] array.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n******Bold******)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        int[] temp = new int[1001];\\n        int count = 0;\\n        for(int i = 0; i < nums1.length; i++) {\\n            temp[nums1[i]] = 1;\\n        }\\n        for(int i = 0; i < nums2.length; i++) {\\n            if(temp[nums2[i]] == 1) {\\n                temp[nums2[i]] = 2;\\n                count++;\\n            }\\n        }\\n        int[] ans = new int[count];\\n        for(int i = 0, j = 0; i < temp.length && j < count; i++) {\\n            if(temp[i] == 2) {\\n                ans[j] = i;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        int[] temp = new int[1001];\\n        int count = 0;\\n        for(int i = 0; i < nums1.length; i++) {\\n            temp[nums1[i]] = 1;\\n        }\\n        for(int i = 0; i < nums2.length; i++) {\\n            if(temp[nums2[i]] == 1) {\\n                temp[nums2[i]] = 2;\\n                count++;\\n            }\\n        }\\n        int[] ans = new int[count];\\n        for(int i = 0, j = 0; i < temp.length && j < count; i++) {\\n            if(temp[i] == 2) {\\n                ans[j] = i;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269294,
                "title": "o-n-solution-by-using-hash-map-beginner-friendly-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n          Firstly, I declare one map storing all numbers which is inside the nums1 but I set frequency of all numbers are 1 because my paln is after it traversing second vector and if my frequency is already 1 then first we increment frequency by 1 and it is also number of second vector then I simply push into vector.\\n          After looping over return vector.\\n\\n# Complexity\\n- **Time complexity: O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int> m;\\n        vector<int> ans;\\n        for(auto i : nums1)\\n        {\\n            m[i]=1;\\n        }\\n        for(auto i : nums2)\\n        {\\n            if(m[i]==1)\\n            {\\n                m[i]++;\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/bb6873b2-e531-4eec-bdad-66878d0aca76_1678205142.2113938.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int> m;\\n        vector<int> ans;\\n        for(auto i : nums1)\\n        {\\n            m[i]=1;\\n        }\\n        for(auto i : nums2)\\n        {\\n            if(m[i]==1)\\n            {\\n                m[i]++;\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086383,
                "title": "java-runtime-beats-100",
                "content": "I would appreciate your vote for the solution \\uD83C\\uDFA9\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        boolean[] exist = new boolean[1001];\\n        for(int v : nums1) exist[v] = true;\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int idx = 0;\\n        for(int v : nums2) {\\n            if(exist[v]) {\\n                result[idx++] = v;\\n                exist[v] = false;\\n            }\\n        }\\n        return Arrays.copyOfRange(result, 0, idx);\\n    }\\n}\\n```\\n# Complexisy\\n**Time complexity**: `O(n)`;\\n**Space complexity**: `O(1001)`;\\n\\n# Explanation\\nThis solution uses a boolean array called \"exist\" of size `1001` to keep track of the elements in the first array `nums1`. It assumes that the elements in the array are in the range of `0` to `1000`, this is important because the size of the boolean array exist is determined by this restriction.\\n\\nFor each element in `nums1`, it sets the corresponding index in the boolean array to `true`. As the elements are in the range of `0` to `1000`, it can use the value of the element as the index in the boolean array.\\n\\nIt then initializes an empty array result with the minimum length of `nums1` and `nums2`. And a variable `idx` which will keep track of the number of elements in the intersection.\\n\\nIt then iterates through the second array `nums2` and checks if the element is present in the boolean array exist by checking if the index corresponding to that element is `true`. As the elements are in the range of `0` to `1000`, it can use the value of the element as the index in the boolean array.\\nIf it is, then it is an intersection and it sets the corresponding index to `false` in exist array, and adds the element in the output array result and increases the `idx` variable.\\n\\nFinally it returns a new array created by `Arrays.copyOfRange()` method which contains a copy of a range of the original array result. It takes two parameters: the original array and the starting and ending indexes of the range to be copied. In this case, it is used to copy the range from index `0` to `idx`, which is the number of intersection elements.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        boolean[] exist = new boolean[1001];\\n        for(int v : nums1) exist[v] = true;\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int idx = 0;\\n        for(int v : nums2) {\\n            if(exist[v]) {\\n                result[idx++] = v;\\n                exist[v] = false;\\n            }\\n        }\\n        return Arrays.copyOfRange(result, 0, idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961733,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310832,
                "title": "c-hashset",
                "content": "```\\npublic class Solution {\\n    public int[] Intersection(int[] nums1, int[] nums2) {\\n        var nums1Set = new HashSet<int>(nums1);\\n\\n        var result = new HashSet<int>();\\n\\n        foreach (var num in nums2) {\\n            if (nums1Set.Contains(num)) {\\n                result.Add(num);\\n            }\\n        }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] Intersection(int[] nums1, int[] nums2) {\\n        var nums1Set = new HashSet<int>(nums1);\\n\\n        var result = new HashSet<int>();\\n\\n        foreach (var num in nums2) {\\n            if (nums1Set.Contains(num)) {\\n                result.Add(num);\\n            }\\n        }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213605,
                "title": "java-1ms-beats-99-85",
                "content": "```\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        int[] ans = new int[nums1.length];\\n        int idx = 0;\\n        for (int i: nums1) {\\n            if (i > max) max = i;\\n            if (i < min) min = i;\\n        }\\n        for (int i: nums2) {\\n            if (i > max) max = i;\\n            if (i < min) min = i;\\n        }\\n        boolean[] map = new boolean[max - min + 1];\\n        for (int i : nums1) map[i - min] = true;\\n        for (int i : nums2) {\\n            if (map[i - min]) {\\n                ans[idx++] = i;\\n                map[i - min] = false;\\n            }\\n        }\\n        return Arrays.copyOf(ans, idx);\\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        int[] ans = new int[nums1.length];\\n        int idx = 0;\\n        for (int i: nums1) {\\n            if (i > max) max = i;\\n            if (i < min) min = i;\\n        }\\n        for (int i: nums2) {\\n            if (i > max) max = i;\\n            if (i < min) min = i;\\n        }\\n        boolean[] map = new boolean[max - min + 1];\\n        for (int i : nums1) map[i - min] = true;\\n        for (int i : nums2) {\\n            if (map[i - min]) {\\n                ans[idx++] = i;\\n                map[i - min] = false;\\n            }\\n        }\\n        return Arrays.copyOf(ans, idx);\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82097,
                "title": "python-2-pointers",
                "content": "```\\nclass Solution(object):\\n    def intersection(self, nums1, nums2):\\n        res = []\\n        nums1.sort()\\n        nums2.sort()\\n        i = j = 0\\n        \\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] > nums2[j]:\\n                j += 1\\n            elif nums1[i] < nums2[j]:\\n                i += 1\\n            else:\\n                if nums1[i] not in res:\\n                    res.append(nums1[i])\\n                i += 1\\n                j += 1\\n        \\n        return res\\n```\\n:levitate:",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def intersection(self, nums1, nums2):\\n        res = []\\n        nums1.sort()\\n        nums2.sort()\\n        i = j = 0\\n        \\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] > nums2[j]:\\n                j += 1\\n            elif nums1[i] < nums2[j]:\\n                i += 1\\n            else:\\n                if nums1[i] not in res:\\n                    res.append(nums1[i])\\n                i += 1\\n                j += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424189,
                "title": "beats-100-easiest-approach-to-understand-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of this solution is to **sort both arrays first**. Then, **use two pointers**, one for each array, to iterate through the arrays and compare the elements. At each iteration, **compare the elements at the current positions of both pointers**. If the elements are equal, add the element to the output vector and advance both pointers. If the element in nums1 is greater than the element in nums2, advance the pointer for nums2. If the element in nums1 is less than the element in nums2, advance the pointer for nums1.\\n![image.png](https://assets.leetcode.com/users/images/ed013ceb-f1ef-4991-8a0d-6fce415ed367_1681663844.6457553.png)\\n\\n\\nTo avoid duplicates, we add a check for the current element in nums1 against the previous element in nums1. If they are the same, advance the pointer for nums1 without adding the element to the output vector.\\n\\nThis approach takes advantage of the fact that the arrays are sorted to efficiently compare the elements and avoid duplicates.\\n\\n# Complexity\\n- Time complexity: O(mlogm + nlogn + m + n)=O(nlogn) this is because we are using the built-in sort function.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) As we are creating a vector to push the elements.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int i=0;\\n        int j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n && j<m){\\n            //this will help to remove the duplicate entries\\n            if(i > 0 && nums1[i]==nums1[i-1]){\\n                i++;\\n                continue;\\n            }\\n            //helps to push the elements in the array\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            //increments if element of the other array is smaller\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        int i=0;\\n        int j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n && j<m){\\n            //this will help to remove the duplicate entries\\n            if(i > 0 && nums1[i]==nums1[i-1]){\\n                i++;\\n                continue;\\n            }\\n            //helps to push the elements in the array\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            //increments if element of the other array is smaller\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345995,
                "title": "easy-c-faang-code",
                "content": "# **Please Upvote the Solution if it helps  \\u2763**\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> st(nums1.begin(),nums1.end()); //O(n)\\n        vector<int> vec;\\n        for(int i=0;i<nums2.size();i++){            //O(n)\\n            if(st.count(nums2[i])){\\n                vec.emplace_back(nums2[i]);\\n                st.erase(nums2[i]);\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n// Total time complexity = O(n)\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> st(nums1.begin(),nums1.end()); //O(n)\\n        vector<int> vec;\\n        for(int i=0;i<nums2.size();i++){            //O(n)\\n            if(st.count(nums2[i])){\\n                vec.emplace_back(nums2[i]);\\n                st.erase(nums2[i]);\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n// Total time complexity = O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764966,
                "title": "c-solution-using-set-a-set-does-not-contain-duplicates",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s1 , s2;\\n        int i;\\n        for( i=0 ; i<nums1.size() ; i++)\\n            s1.insert( nums1[i] );\\n        for( i=0 ; i<nums2.size() ; i++ )\\n            s2.insert( nums2[i] );\\n        vector<int> vec;   //for copying all common element \\n        for ( auto i : s1)\\n        {   if( s2.find(i) != s2.end() )   //if element \\'i\\' of s1 is found in s2 then copy it to vector \\'vec\\'\\n            vec.push_back( i ) ;\\n        }\\n        return vec ;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s1 , s2;\\n        int i;\\n        for( i=0 ; i<nums1.size() ; i++)\\n            s1.insert( nums1[i] );\\n        for( i=0 ; i<nums2.size() ; i++ )\\n            s2.insert( nums2[i] );\\n        vector<int> vec;   //for copying all common element \\n        for ( auto i : s1)\\n        {   if( s2.find(i) != s2.end() )   //if element \\'i\\' of s1 is found in s2 then copy it to vector \\'vec\\'\\n            vec.push_back( i ) ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 271311,
                "title": "javascript-solution",
                "content": "```javascript\\nvar intersection = function(nums1, nums2) {\\n  const set1 = new Set(nums1)\\n  const set2 = new Set(nums2)\\n  return [...set1].filter(n => set2.has(n))\\n};\\n```\\n**Runtime: 60 ms, faster than 98.75%** of JavaScript online submissions for Intersection of Two Arrays.\\n**Memory Usage: 34.8 MB, less than 56.82%** of JavaScript online submissions for Intersection of Two Arrays.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar intersection = function(nums1, nums2) {\\n  const set1 = new Set(nums1)\\n  const set2 = new Set(nums2)\\n  return [...set1].filter(n => set2.has(n))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3549063,
                "title": "best-java-solution-100-beginner-friendly",
                "content": "# Approach\\nLet\\'s break down the code step by step to explain it in a beginner-friendly manner:\\n\\n1. The code defines a class named `Solution` which contains a method called `intersection` that takes two integer arrays, `nums1` and `nums2`, as input and returns an array that represents their intersection.\\n\\n2. The code creates two `HashSet` objects named `container` and `output`. A `HashSet` is a collection that stores unique elements and provides fast retrieval operations.\\n\\n3. In the next step, the code iterates over each element in the `nums1` array using an enhanced for loop. Inside the loop, each element (`num`) is added to the `container` set using the `add` method. This creates a set that contains all unique elements from `nums1`.\\n\\n4. Next, the code iterates over each element in the `nums2` array using the enhanced for loop. Inside the loop, it checks if the `container` set contains the current element (`num`) using the `contains` method. If it does, the element is added to the `output` set using the `add` method.\\n\\n5. After iterating through all elements of `nums2`, the `output` set will contain the common elements between `nums1` and `nums2`.\\n\\n6. To convert the `output` set into an array, the code creates a new integer array called `outputArray` with the size equal to the size of the `output` set.\\n\\n7. The code then declares an `index` variable and initializes it to 0. This variable will be used to keep track of the current index in the `outputArray` during the next loop.\\n\\n8. Finally, the code uses another enhanced for loop to iterate over each element (`x`) in the `output` set. Inside the loop, the current element is assigned to the `outputArray` at the `index` position, and the `index` is incremented.\\n\\n9. Once the loop finishes, the `outputArray` array contains all the common elements between `nums1` and `nums2`. It is then returned as the result of the `intersection` method.\\n\\nIn summary, the code creates two sets (`container` and `output`) to store unique elements. It first adds all elements from `nums1` to `container`, and then checks each element in `nums2` to see if it exists in `container`. The common elements are added to the `output` set. Finally, the `output` set is converted into an array and returned as the result.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> container = new HashSet<>();\\n        HashSet<Integer> output = new HashSet<>();        \\n\\n        for (int num:nums1){\\n            container.add(num);\\n        }\\n        for (int num:nums2){\\n            if (container.contains(num)){\\n                output.add(num);\\n            }\\n        }\\n\\n        int[] outputArray = new int[output.size()];\\n        int index = 0;\\n        for (int x:output){\\n            outputArray[index] = x;\\n            index++;\\n        }\\n\\n        return outputArray;\\n    }\\n}\\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> container = new HashSet<>();\\n        HashSet<Integer> output = new HashSet<>();        \\n\\n        for (int num:nums1){\\n            container.add(num);\\n        }\\n        for (int num:nums2){\\n            if (container.contains(num)){\\n                output.add(num);\\n            }\\n        }\\n\\n        int[] outputArray = new int[output.size()];\\n        int index = 0;\\n        for (int x:output){\\n            outputArray[index] = x;\\n            index++;\\n        }\\n\\n        return outputArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029223,
                "title": "349-intersection-of-two-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int m = nums1.size();\\n        int n = nums2.size();\\n\\n        vector<int> ans;\\n        for(int i=0;i<m;i++){\\n            if(i>0&& nums1[i-1]==nums1[i])\\n             continue;\\n            for(int j=0;j<n;j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans.push_back(nums1[i]);\\n                    break;\\n                }\\n            }\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int m = nums1.size();\\n        int n = nums2.size();\\n\\n        vector<int> ans;\\n        for(int i=0;i<m;i++){\\n            if(i>0&& nums1[i-1]==nums1[i])\\n             continue;\\n            for(int j=0;j<n;j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans.push_back(nums1[i]);\\n                    break;\\n                }\\n            }\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009873,
                "title": "c-beats-98-10-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int>mp;\\n        for(auto x:nums1)\\n        mp[x]=1;\\n        vector<int>ans;\\n        for(auto x:nums2)\\n        {\\n            if(mp[x]==1)\\n            {\\n                ans.push_back(x);\\n                mp[x]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int>mp;\\n        for(auto x:nums1)\\n        mp[x]=1;\\n        vector<int>ans;\\n        for(auto x:nums2)\\n        {\\n            if(mp[x]==1)\\n            {\\n                ans.push_back(x);\\n                mp[x]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025474,
                "title": "java-easy-solution-with-explanation",
                "content": "**if you have any question please comment below**\\n```\\n/*\\nThe intitution is \\n1. sort both the array \\n2.here we will use two pointer to check element from both the array \\nas both the array are sorted so we will adjust the array index by comparing the array values \\n\\n*/\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int i = 0;\\n        int j = 0;\\n        while(i < nums1.length && j < nums2.length){\\n            if(i > 0 && nums1[i] == nums1[i-1]){ //condition for remove the duplicate element \\n                i++;\\n                continue;\\n            }\\n            if(nums1[i] == nums2[j]){ // if both the array has same element then put that element in the list \\n                list.add(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] > nums2[j]){ // as both the array is sorted, so adjust the index by comparing the element\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n        }\\n        \\n        int[] ans = new int[list.size()]; // store the list value in an array \\n        for(int k = 0; k < ans.length; k++){\\n            ans[k] = list.get(k);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**if you find the solution helpfull please upvote it**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/*\\nThe intitution is \\n1. sort both the array \\n2.here we will use two pointer to check element from both the array \\nas both the array are sorted so we will adjust the array index by comparing the array values \\n\\n*/\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int i = 0;\\n        int j = 0;\\n        while(i < nums1.length && j < nums2.length){\\n            if(i > 0 && nums1[i] == nums1[i-1]){ //condition for remove the duplicate element \\n                i++;\\n                continue;\\n            }\\n            if(nums1[i] == nums2[j]){ // if both the array has same element then put that element in the list \\n                list.add(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] > nums2[j]){ // as both the array is sorted, so adjust the index by comparing the element\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n        }\\n        \\n        int[] ans = new int[list.size()]; // store the list value in an array \\n        for(int k = 0; k < ans.length; k++){\\n            ans[k] = list.get(k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662007,
                "title": "javascript-2-line-set-solution-easy-optimal",
                "content": "```\\nvar intersection = function(nums1, nums2) {\\n    nums1 = new Set(nums1);\\n    // Delete returns true if successfully deleted element otherwise false\\n    return nums2.filter(num => nums1.delete(num));\\n\\t// We have to remove the element from the original set otherwise it would match multiple times and we only want the elem a single time\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar intersection = function(nums1, nums2) {\\n    nums1 = new Set(nums1);\\n    // Delete returns true if successfully deleted element otherwise false\\n    return nums2.filter(num => nums1.delete(num));\\n\\t// We have to remove the element from the original set otherwise it would match multiple times and we only want the elem a single time\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513745,
                "title": "easy-explanation-of-100-faster-c-solution-using-set-data-structure",
                "content": "Easy explanation of 100% faster C++ solution using Set Data Structure\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans; // Initialize an empty vector to hold the result\\n        set s = set(nums1.begin(), nums1.end()); // Storing elements of first array into a set, so we can get rid of duplicacy\\n        \\n        for(int x: nums2) // Iterate through the elements of second array\\n\\t\\t{\\n            if(s.find(x) != s.end()) // Check if the element of second array is present in the set created from first array\\n\\t\\t\\t{\\n                ans.push_back(x); // push matched element into result\\n                s.erase(x); // remove element from the set, so we will not face any duplicacy in the next iteration\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nI hope you like the explanation.\\nKindly upvote this so others can also find easily : )",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans; // Initialize an empty vector to hold the result\\n        set s = set(nums1.begin(), nums1.end()); // Storing elements of first array into a set, so we can get rid of duplicacy\\n        \\n        for(int x: nums2) // Iterate through the elements of second array\\n\\t\\t{\\n            if(s.find(x) != s.end()) // Check if the element of second array is present in the set created from first array\\n\\t\\t\\t{\\n                ans.push_back(x); // push matched element into result\\n                s.erase(x); // remove element from the set, so we will not face any duplicacy in the next iteration\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699254,
                "title": "python-2-pointer-solution",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : 2 POINTER ##\\n        i = 0\\n        j = 0\\n        res = set()\\n        nums1.sort()\\n        nums2.sort()\\n        while( i < len(nums1) and j < len(nums2) ):\\n            if nums1[i] < nums2[j]:\\n                i += 1\\n                continue\\n            if nums1[i] > nums2[j]:\\n                j += 1\\n                continue\\n            res.add(nums1[i])\\n            i += 1\\n            j += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : 2 POINTER ##\\n        i = 0\\n        j = 0\\n        res = set()\\n        nums1.sort()\\n        nums2.sort()\\n        while( i < len(nums1) and j < len(nums2) ):\\n            if nums1[i] < nums2[j]:\\n                i += 1\\n                continue\\n            if nums1[i] > nums2[j]:\\n                j += 1\\n                continue\\n            res.add(nums1[i])\\n            i += 1\\n            j += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352219,
                "title": "cpp-solution-faster-than-99-of-submissions-for-beginners",
                "content": "Cpp Solution using unordered set, easy to understand, hope this helps\\n\\n\\tclass Solution {\\n\\tpublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        unordered_set<int> m(nums1.begin(), nums1.end()); //This sets the first list in an unordered set\\n        vector<int> res;\\n        \\n        for(int a:nums2)\\n        {\\n            if(m.count(a)) //If a exists in nums1\\n            {\\n                res.push_back(a); //Push variable in result vector\\n                m.erase(a); //Remove that digit from the set that contains nums1\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\t};\\n\\t\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        unordered_set<int> m(nums1.begin(), nums1.end()); //This sets the first list in an unordered set\\n        vector<int> res;\\n        \\n        for(int a:nums2)\\n        {\\n            if(m.count(a)) //If a exists in nums1\\n            {\\n                res.push_back(a); //Push variable in result vector\\n                m.erase(a); //Remove that digit from the set that contains nums1\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 345766,
                "title": "python3-binary-search-method-and-dictionary-method",
                "content": "* Binary search method\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        if len(nums1) < len(nums2):\\n            nums1,nums2 = nums2,nums1\\n        res = []\\n        nums1 = sorted(nums1)\\n        nums2 = set(nums2)\\n        for i in nums2:\\n            l,r = 0,len(nums1)-1\\n            while l <=r:\\n                m = (l+r)>>1\\n                if nums1[m] == i:\\n                    res.append(i)\\n                    break\\n                else:\\n                    if nums1[m] < i:\\n                        l = m + 1\\n                    else:\\n                        r = m - 1\\n        return res\\n```\\n* Dicionary to count\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        if len(nums1) < len(nums2):\\n            nums1,nums2 = nums2, nums1\\n        d = {}\\n        for i in nums1:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        res = []\\n        for i in nums2:\\n            if i in d:\\n                res.append(i)\\n            else:\\n                continue\\n        return set(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        if len(nums1) < len(nums2):\\n            nums1,nums2 = nums2,nums1\\n        res = []\\n        nums1 = sorted(nums1)\\n        nums2 = set(nums2)\\n        for i in nums2:\\n            l,r = 0,len(nums1)-1\\n            while l <=r:\\n                m = (l+r)>>1\\n                if nums1[m] == i:\\n                    res.append(i)\\n                    break\\n                else:\\n                    if nums1[m] < i:\\n                        l = m + 1\\n                    else:\\n                        r = m - 1\\n        return res\\n```\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        if len(nums1) < len(nums2):\\n            nums1,nums2 = nums2, nums1\\n        d = {}\\n        for i in nums1:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        res = []\\n        for i in nums2:\\n            if i in d:\\n                res.append(i)\\n            else:\\n                continue\\n        return set(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82138,
                "title": "my-c-solution-with-sort",
                "content": "    class Solution {\\n    public:\\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n            std::sort(nums1.begin(), nums1.end());\\n            std::sort(nums2.begin(), nums2.end());\\n            vector<int> ans;\\n            int i = 0, j = 0;\\n            while (i < nums1.size() && j < nums2.size())\\n            {\\n                if (nums1[i] < nums2[j])\\n                    i++;\\n                else if (nums1[i] > nums2[j])\\n                    j++;\\n                else\\n                {\\n                    if (!ans.size() || ans.back() != nums1[i])\\n                        ans.push_back(nums1[i]);\\n                    i++;\\n                    j++;\\n                }\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n            std::sort(nums1.begin(), nums1.end());\\n            std::sort(nums2.begin(), nums2.end());\\n            vector<int> ans;\\n            int i = 0, j = 0;\\n            while (i < nums1.size() && j < nums2.size())\\n            {\\n                if (nums1[i] < nums2[j])\\n                    i++;\\n                else if (nums1[i] > nums2[j])\\n                    j++;\\n                else\\n                {\\n                    if (!ans.size() || ans.back() != nums1[i])\\n                        ans.push_back(nums1[i]);\\n                    i++;\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3945663,
                "title": "easiest-two-pointer-approach-with-o-nlogn-c",
                "content": "# Intuition\\nThis question can be solved using mutliple ways such as map , set and two pointers.\\n\\n# Approach\\n- sort both the vectors\\n- use two pointers ,for both the vectors\\n- increase second pointer if the element of first vector is greater\\n- increase first pointer if the element of second vector is greater\\n- if both the element are same and the result vector has not the same element then insert it into a result vector. \\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v;\\n\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        int i=0,j=0;\\n        int n=nums1.size();\\n        int m =nums2.size();\\n        int las =-1;\\n        while(i<n && j<m){\\n        if(nums1[i]==nums2[j] ){\\n            if( las!=nums1[i]){   \\n            v.push_back(nums1[i]);\\n            las=nums1[i];\\n            }\\n            i++;\\n            j++; \\n        }else if(nums1[i]>nums2[j]){\\n            j++;\\n        }else {\\n            i++;\\n        }\\n        }\\n\\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v;\\n\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n\\n        int i=0,j=0;\\n        int n=nums1.size();\\n        int m =nums2.size();\\n        int las =-1;\\n        while(i<n && j<m){\\n        if(nums1[i]==nums2[j] ){\\n            if( las!=nums1[i]){   \\n            v.push_back(nums1[i]);\\n            las=nums1[i];\\n            }\\n            i++;\\n            j++; \\n        }else if(nums1[i]>nums2[j]){\\n            j++;\\n        }else {\\n            i++;\\n        }\\n        }\\n\\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249417,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n    sort(nums1.begin(),nums1.end());\\n    sort(nums2.begin(),nums2.end());\\n    vector<int> ans;\\n\\n    int i=0;\\n    int j=0;\\n    while(i<nums1.size() && j<nums2.size() )\\n    {\\n        if(nums1[i]==nums2[j])\\n        {\\n            ans.push_back(nums1[i]);\\n            i++,j++;\\n        }\\n        else if(nums1[i]>nums2[j])\\n            j++;\\n        else if(nums1[i]<nums2[j])\\n            i++;\\n        while(i > 0 && i < nums1.size() && nums1[i] == nums1[i - 1]) \\n            i++;\\n        while(j > 0 && j < nums2.size() && nums2[j] == nums2[j - 1]) \\n            j++;\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n    sort(nums1.begin(),nums1.end());\\n    sort(nums2.begin(),nums2.end());\\n    vector<int> ans;\\n\\n    int i=0;\\n    int j=0;\\n    while(i<nums1.size() && j<nums2.size() )\\n    {\\n        if(nums1[i]==nums2[j])\\n        {\\n            ans.push_back(nums1[i]);\\n            i++,j++;\\n        }\\n        else if(nums1[i]>nums2[j])\\n            j++;\\n        else if(nums1[i]<nums2[j])\\n            i++;\\n        while(i > 0 && i < nums1.size() && nums1[i] == nums1[i - 1]) \\n            i++;\\n        while(j > 0 && j < nums2.size() && nums2[j] == nums2[j - 1]) \\n            j++;\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957866,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> s = new HashSet<>();\\n        for (int num : nums1) {\\n            s.add(num);\\n        }\\n        Set<Integer> t = new HashSet<>();\\n        for (int num : nums2) {\\n            if (s.contains(num)) {\\n                t.add(num);\\n            }\\n        }\\n        int[] res = new int[t.size()];\\n        int i = 0;\\n        for (int num : t) {\\n            res[i++] = num;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> s = new HashSet<>();\\n        for (int num : nums1) {\\n            s.add(num);\\n        }\\n        Set<Integer> t = new HashSet<>();\\n        for (int num : nums2) {\\n            if (s.contains(num)) {\\n                t.add(num);\\n            }\\n        }\\n        int[] res = new int[t.size()];\\n        int i = 0;\\n        for (int num : t) {\\n            res[i++] = num;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769347,
                "title": "c-solutin-explained-with-comments",
                "content": "**please UPVOTE if you like the solution/ approach**\\n\\ncomment if you have any query.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        //create a resultant vector RES and a set to store all the diffrent itersection points in both arrays\\n        vector<int> res;\\n        set<int> ans;\\n        \\n        \\n        \\n        for(int i=0;i<nums1.size();i++){\\n            //iterate over first array and skip if any iteration is repeated.(we do need to return diffrent/unique elements)\\n            if( i>0 && nums1[i]==nums1[i-1])\\n                continue;\\n            //when element is unique, check for the same element in second array.. if found, insert it into the set\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans.insert(nums1[i]);\\n                     break;\\n                }\\n               \\n            }\\n        }\\n        //assing all the values of set into vector (as we need to return a vector)\\n        res.assign(ans.begin(),ans.end());\\n        //return resultant vector\\n        return res;\\n    }\\n};\\n```\\n**please UPVOTE if you like the solution/ approach**\\n\\ncomment if you have any query.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        //create a resultant vector RES and a set to store all the diffrent itersection points in both arrays\\n        vector<int> res;\\n        set<int> ans;\\n        \\n        \\n        \\n        for(int i=0;i<nums1.size();i++){\\n            //iterate over first array and skip if any iteration is repeated.(we do need to return diffrent/unique elements)\\n            if( i>0 && nums1[i]==nums1[i-1])\\n                continue;\\n            //when element is unique, check for the same element in second array.. if found, insert it into the set\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums1[i]==nums2[j]){\\n                    ans.insert(nums1[i]);\\n                     break;\\n                }\\n               \\n            }\\n        }\\n        //assing all the values of set into vector (as we need to return a vector)\\n        res.assign(ans.begin(),ans.end());\\n        //return resultant vector\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876111,
                "title": "100-faster-c-solution",
                "content": "### C++ solution in O(nlog(n)) time\\nThe main idea behind this solution is to use binary search on previosly sorted array. What really makes this solution extremely fast is that after each iteration I am limit search space - I am increasing start_idx and I escape main loop when I see that furter search is unneccessary.\\n\\nAlgorithm:\\n1. If nums1 or nums2 is empty return empty array\\n2. Sort nums1 and nums2 using Quick Sort - O(nlog(n)) time complexity\\n3. Walk through the nums1 array and check whether current element from nums1 is in nums2\\n* \\tif current element is the same as last checked element we don\\'t have to check it again\\n* \\tif element is new to us check whether it is not bigger than the biggest element in nums2 ->if it is there is no point in further search, so we escape the main loop\\n* \\tif upper conditions are not met I am making binary search on nums2 and during it I am modyfing start_idx\\n\\n\\t\\tclass Solution {\\n    \\n\\t\\tbool isInArray(std::vector<int> &nums2, int &start_idx, int last_number){\\n\\t\\t\\tint end_idx = nums2.size()- 1;\\n\\n\\t\\t\\twhile(start_idx <= end_idx){\\n\\t\\t\\t\\tint middle_idx = (start_idx + end_idx)/2;\\n\\n\\t\\t\\t\\tif(nums2[middle_idx] < last_number){\\n\\t\\t\\t\\t\\tstart_idx = middle_idx + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (nums2[middle_idx] > last_number){\\n\\t\\t\\t\\t\\tend_idx = middle_idx - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tstart_idx = middle_idx;\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\t\\t\\tstd::vector<int> intersection;\\n\\t\\t\\t\\tif(nums1.empty() || nums2.empty()){\\n\\t\\t\\t\\t\\treturn intersection;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstd::sort(nums1.begin(), nums1.end());\\n\\t\\t\\t\\tstd::sort(nums2.begin(), nums2.end());\\n\\n\\t\\t\\t\\tint last_number = -1;\\n\\t\\t\\t\\tint start_idx = 0;\\n\\t\\t\\t\\tint end_idx = nums2.size()-1;\\n\\t\\t\\t\\tfor(size_t i = 0; i < nums1.size(); ++i){\\n\\t\\t\\t\\t\\tif(nums1[i]!=last_number){\\n\\t\\t\\t\\t\\t\\tlast_number = nums1[i];\\n\\n\\t\\t\\t\\t\\t\\tif(nums2[end_idx] < last_number){\\n\\t\\t\\t\\t\\t\\t\\t// max number in nums2 is smaller than current nr in nums1\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif(isInArray(nums2, start_idx, last_number)){\\n\\t\\t\\t\\t\\t\\t\\tintersection.push_back(last_number);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn intersection;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\tI hope that it helped! <3",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n\\t\\tbool isInArray(std::vector<int> &nums2, int &start_idx, int last_number){\\n\\t\\t\\tint end_idx = nums2.size()- 1;\\n\\n\\t\\t\\twhile(start_idx <= end_idx){\\n\\t\\t\\t\\tint middle_idx = (start_idx + end_idx)/2;\\n\\n\\t\\t\\t\\tif(nums2[middle_idx] < last_number){\\n\\t\\t\\t\\t\\tstart_idx = middle_idx + 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1243602,
                "title": "two-pointers-c",
                "content": "\\tPlz upvote if you like ->\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\t\\tsort(nums1.begin(),nums1.end());\\n\\t\\t\\tsort(nums2.begin(),nums2.end());\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tint i=0,j=0;\\n\\t\\t\\twhile(i < nums1.size() && j < nums2.size()) {\\n\\t\\t\\t\\tif(nums1[i]<nums2[j]) {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(nums1[i]>nums2[j]) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans.push_back(nums1[i]);\\n\\t\\t\\t\\t\\tif(i<nums1.size()){\\n\\t\\t\\t\\t\\t\\tint temp=nums1[i];\\n\\t\\t\\t\\t\\t\\twhile(i < nums1.size() && nums1[i]==temp){\\n\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(j< nums2.size()) {\\n\\t\\t\\t\\t\\t\\tint temp=nums2[j];\\n\\t\\t\\t\\t\\t\\twhile(j < nums2.size() && nums2[j]==temp) {\\n\\t\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\t\\tsort(nums1.begin(),nums1.end());\\n\\t\\t\\tsort(nums2.begin(),nums2.end());\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tint i=0,j=0;\\n\\t\\t\\twhile(i < nums1.size() && j < nums2.size()) {\\n\\t\\t\\t\\tif(nums1[i]<nums2[j]) {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3524790,
                "title": "single-line-code",
                "content": "\\n# Super Logic Solution Using Python\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return set(nums1) & set(nums2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return set(nums1) & set(nums2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376606,
                "title": "easy-javascript-explanation-55ms-91-62-beats",
                "content": "## SCREENSHOT:\\n![Screenshot 2023-04-04 at 02.43.55.png](https://assets.leetcode.com/users/images/db1f49c2-e287-4bdb-86cc-7778d3c2f3a7_1680569273.247834.png)\\n# Explanation\\n1. We initialize an empty array named result. This array will store the common elements between nums1 and nums2.\\n\\n2. We loop through the nums1 array using a for loop and iterate over each element in the array.\\n\\n3. For each element in nums1, we check if it also exists in the nums2 array by using the includes() method.\\n\\n4. If the current element from nums1 exists in nums2, we then check if the element is already in the result array using the includes() method.\\n\\n5. If the element is not already in the result array, we add it to the result array using the push() method.\\n\\n6. After iterating through all the elements in nums1, we return the result array, which contains all the common elements between nums1 and nums2.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[]}\\n */\\n\\nvar intersection = function (nums1, nums2) {\\n  let result = [];\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums2.includes(nums1[i])) {\\n      if (!result.includes(nums1[i])) {\\n        result.push(nums1[i]);\\n      }\\n    }\\n  }\\n  return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[]}\\n */\\n\\nvar intersection = function (nums1, nums2) {\\n  let result = [];\\n  for (let i = 0; i < nums1.length; i++) {\\n    if (nums2.includes(nums1[i])) {\\n      if (!result.includes(nums1[i])) {\\n        result.push(nums1[i]);\\n      }\\n    }\\n  }\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324713,
                "title": "most-fastest-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#include<bits/stdc++.h>\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) \\n    {\\n          map<int,int>m;\\n          \\n          map<int,int>result;\\n          vector<int>ans;\\n\\n          for(int i=0;i<nums1.size();i++)\\n          m[nums1[i]]++;\\n\\n\\n          for(int i=0;i<nums2.size();i++)\\n          {\\n              if(m.find(nums2[i])!=m.end())\\n               result[nums2[i]]++;\\n          }\\n\\n          for(auto i:result)\\n          {\\n              ans.push_back(i.first);\\n          }\\n\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#include<bits/stdc++.h>\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) \\n    {\\n          map<int,int>m;\\n          \\n          map<int,int>result;\\n          vector<int>ans;\\n\\n          for(int i=0;i<nums1.size();i++)\\n          m[nums1[i]]++;\\n\\n\\n          for(int i=0;i<nums2.size();i++)\\n          {\\n              if(m.find(nums2[i])!=m.end())\\n               result[nums2[i]]++;\\n          }\\n\\n          for(auto i:result)\\n          {\\n              ans.push_back(i.first);\\n          }\\n\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3246313,
                "title": "349-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use a set to keep track of the unique elements in the first array (nums1), and then loop through the second array (nums2) to check if each element is in the set. If it is, we add it to our result set. Finally, we convert the result set back to a list and return it.\\n\\n# Complexity\\n- Time complexity:\\n72.12%, O(n+m), where n and m are the lengths of nums1 and nums2 respectively.\\n\\n- Space complexity:\\n87.29%, O(min(n,m)), where n and m are the lengths of nums1 and nums2 respectively.\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        # Convert nums1 to set\\n        nums1_set = set(nums1)\\n        # Create a set to store the intersection\\n        intersection_set = set()\\n        # Loop through nums2 and check if each element is in nums1_set\\n        for num in nums2:\\n            if num in nums1_set:\\n                intersection_set.add(num)\\n        # Convert the intersection set back to a list and return\\n        return list(intersection_set)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        # Convert nums1 to set\\n        nums1_set = set(nums1)\\n        # Create a set to store the intersection\\n        intersection_set = set()\\n        # Loop through nums2 and check if each element is in nums1_set\\n        for num in nums2:\\n            if num in nums1_set:\\n                intersection_set.add(num)\\n        # Convert the intersection set back to a list and return\\n        return list(intersection_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174363,
                "title": "intersection-of-two-arrays-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse two hashsets and  input the elements of first array in the first hashset and remove duplicates while input of the second array elements.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> n1 = new HashSet<>();\\n        HashSet<Integer> n2 = new HashSet<>();\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            n1.add(nums1[i]);\\n        }\\n        \\n        for(int i=0;i<nums2.length;i++){\\n            if(n1.contains(nums2[i])){\\n                n2.add(nums2[i]);\\n            }\\n        }\\n\\n        int[] arr = new int[n2.size()];\\n\\n        int k =0;\\n        for(int i: n2){\\n            arr[k] = i;\\n            k++;\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> n1 = new HashSet<>();\\n        HashSet<Integer> n2 = new HashSet<>();\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            n1.add(nums1[i]);\\n        }\\n        \\n        for(int i=0;i<nums2.length;i++){\\n            if(n1.contains(nums2[i])){\\n                n2.add(nums2[i]);\\n            }\\n        }\\n\\n        int[] arr = new int[n2.size()];\\n\\n        int k =0;\\n        for(int i: n2){\\n            arr[k] = i;\\n            k++;\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270388,
                "title": "python-3-simple-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        a = []\\n        for i in nums1:\\n            if i not in a and i in nums2:\\n                a.append(i)\\n        return a",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        a = []\\n        for i in nums1:\\n            if i not in a and i in nums2:\\n                a.append(i)\\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 2161309,
                "title": "four-java-solutions-brute-better-optimal",
                "content": "Brute Force, Time Complexity = O(Npow(2)), Auxiliary Space = O(N)\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> inter = new HashSet<Integer>();\\n        for(int i = 0 ; i < nums1.length ; i++){\\n            for(int j = 0 ; j < nums2.length ; j++){\\n                if(nums1[i] == nums2[j]){\\n                    inter.add(nums1[i]);\\n                }\\n            }\\n        }\\n        int arr[] = new int[inter.size()];\\n        int i=0;\\n        // iterating over the hashset\\n        for(int ele : inter){\\n          arr[i++] = ele;\\n        }\\n        return arr;\\n    }\\n}\\n```\\nUsing Two HashMaps , Time Complexity = O(N), Space Complexity = O(N)\\n```\\npublic class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        Set<Integer> intersect = new HashSet<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            set.add(nums1[i]);\\n        }\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (set.contains(nums2[i])) {\\n                intersect.add(nums2[i]);\\n            }\\n        }\\n        int[] result = new int[intersect.size()];\\n        int i = 0;\\n        for (Integer num : intersect) {\\n            result[i++] = num;\\n        }\\n        return result;\\n    }\\n}\\n```\\nUsing Two pointers, Time Complexity = O(NlogN), Auxiliary Space = O(N)\\n```\\npublic class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int i = 0;\\n        int j = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                set.add(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        int[] result = new int[set.size()];\\n        int k = 0;\\n        for (Integer num : set) {\\n            result[k++] = num;\\n        }\\n        return result;\\n    }\\n}\\n```\\nUsing Binary Search, Time Complexity = O(NlogN), Auxiliary Space = O(N)\\n```\\npublic class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        Arrays.sort(nums2);\\n        for (Integer num : nums1) {\\n            if (binarySearch(nums2, num)) {\\n                set.add(num);\\n            }\\n        }\\n        int i = 0;\\n        int[] result = new int[set.size()];\\n        for (Integer num : set) {\\n            result[i++] = num;\\n        }\\n        return result;\\n    }\\n    \\n    public boolean binarySearch(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (nums[mid] > target) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**If you like the approaches and learnt all the ways to solve this problem, please upvote, it motivates me write solutions like this.**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> inter = new HashSet<Integer>();\\n        for(int i = 0 ; i < nums1.length ; i++){\\n            for(int j = 0 ; j < nums2.length ; j++){\\n                if(nums1[i] == nums2[j]){\\n                    inter.add(nums1[i]);\\n                }\\n            }\\n        }\\n        int arr[] = new int[inter.size()];\\n        int i=0;\\n        // iterating over the hashset\\n        for(int ele : inter){\\n          arr[i++] = ele;\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        Set<Integer> intersect = new HashSet<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            set.add(nums1[i]);\\n        }\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (set.contains(nums2[i])) {\\n                intersect.add(nums2[i]);\\n            }\\n        }\\n        int[] result = new int[intersect.size()];\\n        int i = 0;\\n        for (Integer num : intersect) {\\n            result[i++] = num;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        int i = 0;\\n        int j = 0;\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                set.add(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        int[] result = new int[set.size()];\\n        int k = 0;\\n        for (Integer num : set) {\\n            result[k++] = num;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        Arrays.sort(nums2);\\n        for (Integer num : nums1) {\\n            if (binarySearch(nums2, num)) {\\n                set.add(num);\\n            }\\n        }\\n        int i = 0;\\n        int[] result = new int[set.size()];\\n        for (Integer num : set) {\\n            result[i++] = num;\\n        }\\n        return result;\\n    }\\n    \\n    public boolean binarySearch(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            }\\n            if (nums[mid] > target) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846614,
                "title": "c-sol-using-hashmap-tc-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> map;\\n        vector<int> result;\\n        for(int i=0; i<nums1.size(); i++){\\n            map[nums1[i]]++;\\n        }\\n        for(int i=0; i<nums2.size(); i++){\\n            if(map.find(nums2[i])!=map.end()){\\n                if(map[nums2[i]]!=0)\\n                    result.push_back(nums2[i]);\\n                    map[nums2[i]]=0;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> map;\\n        vector<int> result;\\n        for(int i=0; i<nums1.size(); i++){\\n            map[nums1[i]]++;\\n        }\\n        for(int i=0; i<nums2.size(); i++){\\n            if(map.find(nums2[i])!=map.end()){\\n                if(map[nums2[i]]!=0)\\n                    result.push_back(nums2[i]);\\n                    map[nums2[i]]=0;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614032,
                "title": "0-ms-easy-to-understand-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {                        \\n        unordered_set<int> s;\\n        vector<int> nums3;\\n        int count=0;\\n        for(int i=0;i<nums1.size();i++){\\n            s.insert(nums1[i]);\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(s.find(nums2[i])!=s.end()){\\n                nums3.push_back(nums2[i]);\\n                s.erase(nums2[i]);\\n            }\\n        }\\n     return nums3;   \\n    }\\n};\\n\\npls upvote if it was helpful:)",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534777,
                "title": "kotlin-best-memory-solution-so-far",
                "content": "```\\nclass Solution {\\n    \\n    fun intersection(nums1: IntArray, nums2: IntArray): IntArray { \\n        val nums1Set = nums1.toSet()\\n        val intersection = nums1Set.filter { nums2.contains(it) }\\n        \\n        return intersection.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun intersection(nums1: IntArray, nums2: IntArray): IntArray { \\n        val nums1Set = nums1.toSet()\\n        val intersection = nums1Set.filter { nums2.contains(it) }\\n        \\n        return intersection.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481080,
                "title": "c",
                "content": "```\\npublic int[] Intersection(int[] nums1, int[] nums2) {\\n\\tvar set = new HashSet<int>(nums1);\\n\\tvar res = new HashSet<int>();\\n\\tforeach (var num in nums2)\\n\\t\\tif (set.Remove(num))\\n\\t\\t\\tres.Add(num);\\n\\treturn res.ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] Intersection(int[] nums1, int[] nums2) {\\n\\tvar set = new HashSet<int>(nums1);\\n\\tvar res = new HashSet<int>();\\n\\tforeach (var num in nums2)\\n\\t\\tif (set.Remove(num))\\n\\t\\t\\tres.Add(num);\\n\\treturn res.ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250627,
                "title": "java-solutions",
                "content": "**Solution 1: Using Two Sets**\\n\\nTime complexity: `O(m + n)` -  where `m` and `n` are lengths of arrays.\\nSpace complexity: `O(m + n)`\\n\\n```\\nclass Solution\\n{\\n    public int[] intersection(int[] A, int[] B)\\n\\t{\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setAB = new HashSet<>();\\n\\t\\tint i = 0;\\n\\n        for(int n : A)\\n\\t\\t\\tsetA.add(n);\\n\\n        for(int n : B)\\n\\t\\t{\\n            if(setA.contains(n))\\n\\t\\t\\t{\\n                setAB.add(n);\\n            }\\n        }\\n\\n        int[] result = new int[setAB.size()];\\n\\n\\t\\tfor(int n : setAB)\\n            result[i++] = n;\\n\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: Using Binary Search**\\n\\nTime complexity: `O(m log n)`\\nSpace complexity: `O(Min(m, n))`\\n\\n```\\nclass Solution\\n{\\n    public int[] intersection(int[] A, int[] B)\\n\\t{\\n        Set<Integer> set = new HashSet<>();\\n\\t\\tint i = 0;\\n\\t\\tArrays.sort(B);\\n\\n\\t\\tfor(int n : A)\\n\\t\\t{\\n            if(Arrays.binarySearch(B, n) >= 0)\\n\\t\\t\\t{\\n                set.add(n);\\n            }\\n        }\\n\\n        int[] result = new int[set.size()];\\n        \\n\\t\\tfor (int n : set)\\n\\t\\t{\\n            result[i++] = n;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 3: Sorting and Two Pointers Approach**\\n\\nTime complexity: `O(m log m  +  n log n)` -  where `m` and `n` are lengths of arrays.\\nSpace complexity: `O(Min(m, n))`\\n\\n```\\nclass Solution\\n{\\n    public int[] intersection(int[] A, int[] B)\\n\\t{\\n        Set<Integer> set = new HashSet<>();\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        int i = 0;\\n        int j = 0;\\n        \\n\\t\\twhile(i < A.length && j < B.length)\\n\\t\\t{\\n            if(A[i] == B[j])\\n\\t\\t\\t{\\n                set.add(A[i]);\\n                i++;\\n                j++;\\n            }\\n\\t\\t\\telse if (A[i] < B[j])\\n\\t\\t\\t{\\n                i++;\\n            }\\n\\t\\t\\telse\\n\\t\\t\\t{\\n                j++;\\n            }\\n        }\\n\\t\\tint[] result = new int[set.size()];\\n        int k = 0;\\n        \\n\\t\\tfor(int n : set)\\n\\t\\t{\\n            result[k++] = n;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int[] intersection(int[] A, int[] B)\\n\\t{\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setAB = new HashSet<>();\\n\\t\\tint i = 0;\\n\\n        for(int n : A)\\n\\t\\t\\tsetA.add(n);\\n\\n        for(int n : B)\\n\\t\\t{\\n            if(setA.contains(n))\\n\\t\\t\\t{\\n                setAB.add(n);\\n            }\\n        }\\n\\n        int[] result = new int[setAB.size()];\\n\\n\\t\\tfor(int n : setAB)\\n            result[i++] = n;\\n\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int[] intersection(int[] A, int[] B)\\n\\t{\\n        Set<Integer> set = new HashSet<>();\\n\\t\\tint i = 0;\\n\\t\\tArrays.sort(B);\\n\\n\\t\\tfor(int n : A)\\n\\t\\t{\\n            if(Arrays.binarySearch(B, n) >= 0)\\n\\t\\t\\t{\\n                set.add(n);\\n            }\\n        }\\n\\n        int[] result = new int[set.size()];\\n        \\n\\t\\tfor (int n : set)\\n\\t\\t{\\n            result[i++] = n;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int[] intersection(int[] A, int[] B)\\n\\t{\\n        Set<Integer> set = new HashSet<>();\\n        Arrays.sort(A);\\n        Arrays.sort(B);\\n        int i = 0;\\n        int j = 0;\\n        \\n\\t\\twhile(i < A.length && j < B.length)\\n\\t\\t{\\n            if(A[i] == B[j])\\n\\t\\t\\t{\\n                set.add(A[i]);\\n                i++;\\n                j++;\\n            }\\n\\t\\t\\telse if (A[i] < B[j])\\n\\t\\t\\t{\\n                i++;\\n            }\\n\\t\\t\\telse\\n\\t\\t\\t{\\n                j++;\\n            }\\n        }\\n\\t\\tint[] result = new int[set.size()];\\n        int k = 0;\\n        \\n\\t\\tfor(int n : set)\\n\\t\\t{\\n            result[k++] = n;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82155,
                "title": "java-6ms-o-n-m-solution-with-two-hashset",
                "content": "The problem asks us to find the same integers in both arrays and return a non-duplicate result array.\\n\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n    \\t\\tif (nums1.length == 0 || nums2.length == 0)\\n    \\t\\t\\treturn new int[0];\\n    \\t\\tSet<Integer> set = new HashSet<>();\\n    \\t\\tSet<Integer> result = new HashSet<>();\\n    \\t\\tfor (int i = 0; i < nums2.length; i++) {\\n    \\t\\t\\tset.add(nums2[i]);\\n    \\t\\t}\\n    \\t\\tfor (int i = 0; i < nums1.length; i++) {\\n    \\t\\t\\tif (set.contains(nums1[i])) {\\n    \\t\\t\\t\\tresult.add(nums1[i]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tint[] intersection = new int[result.size()];\\n    \\t\\tint j = 0;\\n    \\t\\tIterator<Integer> it = result.iterator();\\n    \\t\\twhile(it.hasNext()) {\\n    \\t\\t\\tintersection[j] = it.next();\\n    \\t\\t\\tj++;\\n    \\t\\t}\\n    \\t\\treturn intersection;\\t\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "The problem asks us to find the same integers in both arrays and return a non-duplicate result array.\\n\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n    \\t\\tif (nums1.length == 0 || nums2.length == 0)\\n    \\t\\t\\treturn new int[0];\\n    \\t\\tSet<Integer> set = new HashSet<>();\\n    \\t\\tSet<Integer> result = new HashSet<>();\\n    \\t\\tfor (int i = 0; i < nums2.length; i++) {\\n    \\t\\t\\tset.add(nums2[i]);\\n    \\t\\t}\\n    \\t\\tfor (int i = 0; i < nums1.length; i++) {\\n    \\t\\t\\tif (set.contains(nums1[i])) {\\n    \\t\\t\\t\\tresult.add(nums1[i]);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tint[] intersection = new int[result.size()];\\n    \\t\\tint j = 0;\\n    \\t\\tIterator<Integer> it = result.iterator();\\n    \\t\\twhile(it.hasNext()) {\\n    \\t\\t\\tintersection[j] = it.next();\\n    \\t\\t\\tj++;\\n    \\t\\t}\\n    \\t\\treturn intersection;\\t\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 82140,
                "title": "c-solution-using-unordered-map-o-m-n-time-and-o-m-space",
                "content": "    class Solution {\\n    public:\\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n            \\n            unordered_map<int,int> map;\\n            vector<int> result;\\n            \\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                map[nums1[i]]++;\\n            }\\n            \\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                if(map[nums2[i]] > 0)\\n                {\\n                    result.push_back(nums2[i]);\\n                    map[nums2[i]] = 0;\\n                }\\n            }\\n            \\n            return result;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n            \\n            unordered_map<int,int> map;\\n            vector<int> result;\\n            \\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                map[nums1[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3877959,
                "title": "finding-the-intersection-of-two-arrays-simple-expainnation-for-beginner",
                "content": "**Title: Finding the Intersection of Two Arrays**\\n\\n**Introduction:**\\nIn this article, we will discuss and analyze a C++ solution to find the intersection of two arrays. The given solution employs the use of unordered sets to efficiently compute the common elements present in both input arrays. The provided code implements a function called `intersection`, which takes two input vectors, `nums1` and `nums2`, and returns a new vector containing the intersection of these arrays.\\n\\n**Understanding the Approach:**\\nTo find the intersection of two arrays, we can follow these steps:\\n\\n1. Create an unordered set, `uset`, to store the unique elements of the first input array, `nums1`.\\n2. Create another unordered set, `ansset`, to hold the common elements between `nums1` and `nums2`.\\n3. Iterate through the first input array, `nums1`, and insert each element into the `uset`.\\n4. Iterate through the second input array, `nums2`, and check if the element exists in the `uset`. If it does, insert the element into the `ansset`.\\n5. Create a new vector, `ans`, to store the intersection elements.\\n6. Iterate through the `ansset` and add each element to the `ans` vector.\\n\\n**Solution Code Explanation:**\\n```cpp\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n    int n = nums1.size();\\n    int m = nums2.size();\\n    unordered_set<int> uset;\\n    unordered_set<int> ansset;\\n    \\n    // Insert all elements of nums1 into the uset\\n    for (int i = 0; i < n; i++) {\\n        uset.insert(nums1[i]);\\n    }\\n    \\n    // Find common elements between nums1 and nums2\\n    for (int i = 0; i < m; i++) {\\n        int key = nums2[i];\\n        if (uset.find(key) != uset.end()) {\\n            ansset.insert(nums2[i]);\\n        }\\n    }\\n    \\n    vector<int> ans;\\n    \\n    // Populate the ans vector with elements from ansset\\n    for (auto itr = ansset.begin(); itr != ansset.end(); itr++) {\\n        ans.push_back((*itr));\\n    }\\n    \\n    return ans;\\n}\\n```\\n\\n**Time and Space Complexity Analysis:**\\nThe time complexity of this solution is O(n + m), where \\'n\\' and \\'m\\' are the sizes of `nums1` and `nums2` respectively. This is because we iterate through both arrays once to insert elements into the `uset` and `ansset`.\\n\\nThe space complexity is O(n + m) as well. In the worst case, when there are no common elements between the two arrays, the entire `nums1` and `nums2` arrays might be stored in the `uset` and `ansset` respectively.\\n\\n**Conclusion:**\\nIn this article, we explored a C++ solution to find the intersection of two arrays using unordered sets. By leveraging the properties of unordered sets to store and look up unique elements efficiently, we can obtain the common elements between the two input arrays in linear time complexity. This approach provides an effective solution to the problem of finding the intersection of two arrays without using nested loops or sorting, which would have resulted in higher time complexity.\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```cpp\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n    int n = nums1.size();\\n    int m = nums2.size();\\n    unordered_set<int> uset;\\n    unordered_set<int> ansset;\\n    \\n    // Insert all elements of nums1 into the uset\\n    for (int i = 0; i < n; i++) {\\n        uset.insert(nums1[i]);\\n    }\\n    \\n    // Find common elements between nums1 and nums2\\n    for (int i = 0; i < m; i++) {\\n        int key = nums2[i];\\n        if (uset.find(key) != uset.end()) {\\n            ansset.insert(nums2[i]);\\n        }\\n    }\\n    \\n    vector<int> ans;\\n    \\n    // Populate the ans vector with elements from ansset\\n    for (auto itr = ansset.begin(); itr != ansset.end(); itr++) {\\n        ans.push_back((*itr));\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593284,
                "title": "simple-3-step-java-solution",
                "content": "# Approach\\nAs we are talking about unique elements in the result array, `Set` data structure is the first thing you can think about.\\n\\n1. We iterate over the first array `arr1` and store its _unique_ elements in a `set1` variable.\\n2. We iterate over the second array `arr2` and at the same time we check, whether current element is contained by the first array `arr1` or not (with the help of `set1`).\\nIf so, add the element to the `common` Set.\\n3. Transfer all the elements from the `common` object to the result array `res`.\\n\\n# Complexity\\n- Time complexity: $$O(N + M)$$, \\nwhere `N` and `M` are the lengths of `arr1` and `arr2` correspondignly \\n(as we iterate over the both arrays in the steps **1** and **2**).\\n\\n- Space complexity: $$O(N + M)$$\\nwhere `N` and `M` are the lengths of `arr1` and `arr2` correspondignly\\n(in the worst case all the elements from `arr1` and `arr2` can be the same, and we will use an additional space to store the elements in `set1` and `commonElements` variables)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] arr1, int[] arr2) {\\n        // 1. Iterate over the first array\\n        Set<Integer> set1 = new HashSet<>();\\n        for (int i : arr1) {\\n            set1.add(i);\\n        }\\n\\n        // 2. Iterate over the second array\\n        Set<Integer> commonElements = new HashSet<>();\\n        for (int i : arr2) {\\n            // does this element exist in the first array?\\n            if (set1.contains(i)) {\\n                commonElements.add(i);\\n            }\\n        }\\n\\n        // 3. Prepare the result array\\n        int[] res = new int[commonElements.size()];\\n        int idx = 0;\\n        for (int e : commonElements) {\\n            res[idx++] = e;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] arr1, int[] arr2) {\\n        // 1. Iterate over the first array\\n        Set<Integer> set1 = new HashSet<>();\\n        for (int i : arr1) {\\n            set1.add(i);\\n        }\\n\\n        // 2. Iterate over the second array\\n        Set<Integer> commonElements = new HashSet<>();\\n        for (int i : arr2) {\\n            // does this element exist in the first array?\\n            if (set1.contains(i)) {\\n                commonElements.add(i);\\n            }\\n        }\\n\\n        // 3. Prepare the result array\\n        int[] res = new int[commonElements.size()];\\n        int idx = 0;\\n        for (int e : commonElements) {\\n            res[idx++] = e;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585866,
                "title": "c-easy-using-unordered-map-beats-70",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n+m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int> ans;\\n        unordered_map<int, int> mp;\\n\\n        for(auto i:nums1)\\n        {\\n            mp[i]++;\\n        }\\n\\n        for(auto i:nums2)\\n        {\\n            if(mp[i])\\n            {\\n                mp[i]=false;\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int> ans;\\n        unordered_map<int, int> mp;\\n\\n        for(auto i:nums1)\\n        {\\n            mp[i]++;\\n        }\\n\\n        for(auto i:nums2)\\n        {\\n            if(mp[i])\\n            {\\n                mp[i]=false;\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517261,
                "title": "4-approaches-with-brute-optimal-most-efficient-solution-o-n-m-time-o-n-m-space",
                "content": "\\uD83D\\uDE0A \\uD835\\uDE4E\\uD835\\uDE5A\\uD835\\uDE61\\uD835\\uDE5B \\uD835\\uDE3E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE56\\uD835\\uDE69\\uD835\\uDE5A\\uD835\\uDE59 \\uD835\\uDE47\\uD835\\uDE64\\uD835\\uDE5C\\uD835\\uDE5E\\uD835\\uDE58 ~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDont Worry, Its Easy.\\nJust look at the Code and Comments Within it, You\\'ll get it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I Provided 4 Approaches / Solution.\\n\\nBrute Force To Optimal \\nThe Most Efficient Approach Have An Upper Bound Of O(N+M) & O(N+M) Space.\\n\\n# Complexity\\n- Time complexity: Mentioned in the code\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Mentioned in the code\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nApproach 1 :-\\n```\\n// #1 Method to find the intersection elements from two given arrays - O(N*M) & O(N)\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) { \\n    set<int> st;\\n    vector<int> ans;\\n    \\n    for(int i=0; i < nums1.size(); i++)\\n        for(int j=0; j < nums2.size(); j++)\\n            if(nums1[i] == nums2[j]) // If both the elements are equal\\n                st.insert(nums1[i]); // Than store it to set\\n\\n    for(auto val: st) \\n        ans.push_back(val); // Store the set elements to ans\\n\\n    return ans;\\n}\\n```\\nApproach 2 :- Easy Two Pointer Technique\\n```\\n// #2 Method to find the intersection elements from two given arrays - O(NLogN + MLogM) & O(N)\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) { \\n    set<int> st;\\n    vector<int> ans;\\n\\n    // Requires to easily access Kth element at last\\n    sort(begin(nums1), end(nums1));\\n    sort(begin(nums2), end(nums2));\\n\\n    int i = 0, j = 0;\\n\\n    while(i < nums1.size() && j < nums2.size()) {\\n        if(nums1[i] < nums2[j]) // If ith element is lesser\\n            i++; // Than move the ith one as its not possible to have the ith element again\\n\\n        else if(nums1[i] > nums2[j]) // If jth element is lesser\\n            j++; // Than move the jth one as its not possible to have the jth element again \\n\\n        else\\n            st.insert(nums1[i]), // Both the elements are equal hence store it to set\\n            i++, j++; // Move forward in both the array\\n    }\\n\\n    for(auto val: st)\\n        ans.push_back(val);\\n\\n    return ans;\\n}\\n```\\nApproach 3 :- Easy Two Pointer Technique\\n```\\n// #3 Method to find the intersection elements from two given arrays - O(NLogN + MLogM) & O(1)\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) { \\n    vector<int> ans;\\n\\n    sort(begin(nums1), end(nums1));\\n    sort(begin(nums2), end(nums2));\\n\\n    int i = 0, j = 0;\\n\\n    while(i < nums1.size() && j < nums2.size()) {\\n        if(nums1[i] < nums2[j]) {\\n            i++;\\n        }\\n        else if(nums1[i] > nums2[j]) {\\n            j++;\\n        }\\n        else {\\n            ans.push_back(nums1[i]);\\n            int tmpInd1 = i; int tmpInd2 = j; // Requires to skip the correct duplicates correctly\\n            // Skip the duplicates if present\\n            while(i < nums1.size() && nums1[tmpInd1] == nums1[i]) i++;\\n            while(j < nums2.size() && nums2[tmpInd2] == nums2[j]) j++;\\n        }\\n    }\\n\\n    return ans;\\n}\\n```\\nApproach 4 :-\\n```\\nclass Solution {\\npublic:\\n    // #4 Method to find the intersection elements from two given arrays - O(N+M) & O(N+M)\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st1, st2;\\n        vector<int> ans;\\n\\n        for(auto val: nums1) // Store nums1 elements to set1\\n            st1.insert(val);\\n\\n        for(auto val: nums2) // Store nums2 elements to set2\\n            st2.insert(val);\\n\\n        for(auto val: st1) // Store intersection elements to ans\\n            if(st2.count(val))\\n                ans.push_back(val);\\n\\n        return ans; \\n    }\\n};\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n// #1 Method to find the intersection elements from two given arrays - O(N*M) & O(N)\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) { \\n    set<int> st;\\n    vector<int> ans;\\n    \\n    for(int i=0; i < nums1.size(); i++)\\n        for(int j=0; j < nums2.size(); j++)\\n            if(nums1[i] == nums2[j]) // If both the elements are equal\\n                st.insert(nums1[i]); // Than store it to set\\n\\n    for(auto val: st) \\n        ans.push_back(val); // Store the set elements to ans\\n\\n    return ans;\\n}\\n```\n```\\n// #2 Method to find the intersection elements from two given arrays - O(NLogN + MLogM) & O(N)\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) { \\n    set<int> st;\\n    vector<int> ans;\\n\\n    // Requires to easily access Kth element at last\\n    sort(begin(nums1), end(nums1));\\n    sort(begin(nums2), end(nums2));\\n\\n    int i = 0, j = 0;\\n\\n    while(i < nums1.size() && j < nums2.size()) {\\n        if(nums1[i] < nums2[j]) // If ith element is lesser\\n            i++; // Than move the ith one as its not possible to have the ith element again\\n\\n        else if(nums1[i] > nums2[j]) // If jth element is lesser\\n            j++; // Than move the jth one as its not possible to have the jth element again \\n\\n        else\\n            st.insert(nums1[i]), // Both the elements are equal hence store it to set\\n            i++, j++; // Move forward in both the array\\n    }\\n\\n    for(auto val: st)\\n        ans.push_back(val);\\n\\n    return ans;\\n}\\n```\n```\\n// #3 Method to find the intersection elements from two given arrays - O(NLogN + MLogM) & O(1)\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) { \\n    vector<int> ans;\\n\\n    sort(begin(nums1), end(nums1));\\n    sort(begin(nums2), end(nums2));\\n\\n    int i = 0, j = 0;\\n\\n    while(i < nums1.size() && j < nums2.size()) {\\n        if(nums1[i] < nums2[j]) {\\n            i++;\\n        }\\n        else if(nums1[i] > nums2[j]) {\\n            j++;\\n        }\\n        else {\\n            ans.push_back(nums1[i]);\\n            int tmpInd1 = i; int tmpInd2 = j; // Requires to skip the correct duplicates correctly\\n            // Skip the duplicates if present\\n            while(i < nums1.size() && nums1[tmpInd1] == nums1[i]) i++;\\n            while(j < nums2.size() && nums2[tmpInd2] == nums2[j]) j++;\\n        }\\n    }\\n\\n    return ans;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // #4 Method to find the intersection elements from two given arrays - O(N+M) & O(N+M)\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st1, st2;\\n        vector<int> ans;\\n\\n        for(auto val: nums1) // Store nums1 elements to set1\\n            st1.insert(val);\\n\\n        for(auto val: nums2) // Store nums2 elements to set2\\n            st2.insert(val);\\n\\n        for(auto val: st1) // Store intersection elements to ans\\n            if(st2.count(val))\\n                ans.push_back(val);\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510773,
                "title": "using-hashset-iterator-beats-96-56-2-ms",
                "content": "# Intuition & Approach\\nBy Using **HASHSET** store the nums1 elements in first HashSet.\\nthen, create another HashSet for comparing the Stored elements in first HashSet. Then Store Result in second HashSet.Now, expected output is stored in Second HashSet. Now we need to convert HashSet to Array and store it in one array variable. So, am Used Iterator for storing elements in new result array. finaly, result array is returned.\\n\\n\\n# Complexity\\n- Time complexity:\\n                  O(m+n)\\n\\n- Space complexity:\\n                  O(m+n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n       \\n       HashSet<Integer> Hs = new HashSet<>();\\n       for(int i=0;i<nums1.length;i++){\\n            Hs.add(nums1[i]);\\n       }\\n\\n       HashSet<Integer> Hs1 = new HashSet<>();\\n       for(int j=0;j<nums2.length;j++){\\n            if(Hs.contains(nums2[j])){\\n              Hs1.add(nums2[j]);\\n            }\\n       }\\n\\n       int res[] = new int[Hs1.size()];\\n        Iterator<Integer> iterator = Hs1.iterator();\\n        for (int i = 0; i < res.length; i++) {\\n              res[i] = iterator.next();\\n        }\\n          return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n       \\n       HashSet<Integer> Hs = new HashSet<>();\\n       for(int i=0;i<nums1.length;i++){\\n            Hs.add(nums1[i]);\\n       }\\n\\n       HashSet<Integer> Hs1 = new HashSet<>();\\n       for(int j=0;j<nums2.length;j++){\\n            if(Hs.contains(nums2[j])){\\n              Hs1.add(nums2[j]);\\n            }\\n       }\\n\\n       int res[] = new int[Hs1.size()];\\n        Iterator<Integer> iterator = Hs1.iterator();\\n        for (int i = 0; i < res.length; i++) {\\n              res[i] = iterator.next();\\n        }\\n          return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102056,
                "title": "beginner-friendly-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbrute force\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit can be improved using find function instead of second for loop\\n\\n# Complexity\\n- Time complexity: o(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int>res;\\n        vector<int>sol;\\n        for(int i:nums1){\\n            for(int j:nums2){\\n                if(i==j)\\n                res.insert(i);\\n            }\\n        }\\n        for(int i:res){\\n            sol.push_back(i);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int>res;\\n        vector<int>sol;\\n        for(int i:nums1){\\n            for(int j:nums2){\\n                if(i==j)\\n                res.insert(i);\\n            }\\n        }\\n        for(int i:res){\\n            sol.push_back(i);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001588,
                "title": "python3-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n52ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n14.2 MB\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        if set1<set2:\\n            return [i for i in set1 if i in set2 ]\\n        else:\\n            return [i for i in set2 if i in set1 ]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        if set1<set2:\\n            return [i for i in set1 if i in set2 ]\\n        else:\\n            return [i for i in set2 if i in set1 ]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959904,
                "title": "very-easy-solurtion-using-the-two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolved Using The Two pointers Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        set<int> s;\\n        int i =0,j=0;\\n        while(i<n && j<m){\\n            if(nums1[i]>nums2[j]) j++;\\n            else if(nums1[i]<nums2[j]) i++;\\n            else{\\n                s.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto i : s) ans.push_back(i);\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        set<int> s;\\n        int i =0,j=0;\\n        while(i<n && j<m){\\n            if(nums1[i]>nums2[j]) j++;\\n            else if(nums1[i]<nums2[j]) i++;\\n            else{\\n                s.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto i : s) ans.push_back(i);\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790345,
                "title": "java-o-n-m-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> nums = new HashSet<>();\\n        for(int i = 0; i < nums1.length; i++) {\\n            nums.add(nums1[i]);\\n        }\\n        \\n        List<Integer> answer = new ArrayList<>();\\n        for(int i = 0; i < nums2.length; i++) {\\n            if(nums.contains(nums2[i])) {\\n                answer.add(nums2[i]);\\n                nums.remove(nums2[i]);\\n            }\\n        }\\n        return answer.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```\\n\\n**Please upvote if you found this helpful.**",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> nums = new HashSet<>();\\n        for(int i = 0; i < nums1.length; i++) {\\n            nums.add(nums1[i]);\\n        }\\n        \\n        List<Integer> answer = new ArrayList<>();\\n        for(int i = 0; i < nums2.length; i++) {\\n            if(nums.contains(nums2[i])) {\\n                answer.add(nums2[i]);\\n                nums.remove(nums2[i]);\\n            }\\n        }\\n        return answer.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770326,
                "title": "intuitive-python-solution-hashmap",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        hashmap = {}\\n        res = set()\\n        \\n        for i in range(len(nums1)):\\n            hashmap[nums1[i]] = i\\n        \\n        for n in nums2:\\n            if n in hashmap:\\n                res.add(n)\\n                \\n        return res\\n\\nTime and Space complexity: O(m + n) = O(max(m, n))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        hashmap = {}\\n        res = set()\\n        \\n        for i in range(len(nums1)):\\n            hashmap[nums1[i]] = i\\n        \\n        for n in nums2:\\n            if n in hashmap:\\n                res.add(n)\\n                \\n        return res\\n\\nTime and Space complexity: O(m + n) = O(max(m, n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633377,
                "title": "java-solution-hashset",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums1) {\\n            set.add(i);\\n        }\\n\\n        Set<Integer> intersection = new HashSet<>();\\n        for (int i : nums2) {\\n            if (set.contains(i)) {\\n                intersection.add(i);\\n            }\\n        }\\n\\n        int[] ans = new int[intersection.size()];\\n        int idx = 0;\\n\\n        for (int i : intersection) {\\n            ans[idx++] = i;\\n        }\\n\\n        return ans;\\n\\n        // return intersection.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n\\n// TC: O(n + m) + O(k)\\n// SC: O(m + n) + O(k)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums1) {\\n            set.add(i);\\n        }\\n\\n        Set<Integer> intersection = new HashSet<>();\\n        for (int i : nums2) {\\n            if (set.contains(i)) {\\n                intersection.add(i);\\n            }\\n        }\\n\\n        int[] ans = new int[intersection.size()];\\n        int idx = 0;\\n\\n        for (int i : intersection) {\\n            ans[idx++] = i;\\n        }\\n\\n        return ans;\\n\\n        // return intersection.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n\\n// TC: O(n + m) + O(k)\\n// SC: O(m + n) + O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629456,
                "title": "fast-javascript-solution-65-ms-top-95-speed",
                "content": "### Solution:\\n```js\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[]}\\n */\\n\\nconst set_intersection = (set1, set2) => {\\n    let output = [];\\n    const arr = Array.from(set1)\\n    for (let s of arr)\\n      if (set2.has(s)) {\\n          output.push(s);\\n      }\\n\\n    return output;\\n  }\\nvar intersection = function(nums1, nums2) {\\n    let set1 = new Set(nums1);\\n    let set2 = new Set(nums2);\\n\\n    if (set1.size < set2.size) {\\n        return set_intersection(set1, set2);\\n    }\\n    else {\\n        return set_intersection(set2, set1);\\n    }\\n};\\n```\\n\\n### LeetCode Output:\\nRuntime: **65 ms**, faster than **95.17%** of JavaScript online submissions for Intersection of Two Arrays.\\nMemory Usage: **43.3 MB**, less than **61.49%** of JavaScript online submissions for Intersection of Two Arrays.\\n[Link to submission](https://leetcode.com/submissions/detail/809599767/)",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[]}\\n */\\n\\nconst set_intersection = (set1, set2) => {\\n    let output = [];\\n    const arr = Array.from(set1)\\n    for (let s of arr)\\n      if (set2.has(s)) {\\n          output.push(s);\\n      }\\n\\n    return output;\\n  }\\nvar intersection = function(nums1, nums2) {\\n    let set1 = new Set(nums1);\\n    let set2 = new Set(nums2);\\n\\n    if (set1.size < set2.size) {\\n        return set_intersection(set1, set2);\\n    }\\n    else {\\n        return set_intersection(set2, set1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2572746,
                "title": "python-c-java-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q349. Intersection of Two Arrays***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2))\\n\\t\\t# or\\n        res=[]\\n        for i in nums1:\\n            if i not in res and i in nums2:\\n                res.append(i)\\n        return res\\n```\\n**Runtime:**  915 ms\\t\\n**Memory Usage:**  16.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++)\\n            set1.add(nums1[i]);\\n        \\n        for(int i=0; i<nums2.length; i++)\\n            set2.add(nums2[i]);\\n        \\n        int[] nums = new int[Math.min(set1.size(), set2.size())];\\n        int index = 0;\\n        \\n        for(int val : set1){\\n            if(set2.contains(val)){\\n                nums[index] = val;\\n                index++;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(nums, 0, index);\\n        \\n    }\\n}\\n```\\n**Runtime:**  7 ms\\t\\t\\n**Memory Usage:**  43.8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> mn;\\n        set<int> s;\\n        vector<int>res;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n    set_intersection(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),std::back_inserter(mn));\\n        for(auto i:mn)s.insert(s.begin(),i);\\n        for(auto i:s)res.push_back(i);\\n    return res;\\n    }\\n};\\n```\\n**Runtime:** 23 ms\\t\\n**Memory Usage:**  10.3 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2))\\n\\t\\t# or\\n        res=[]\\n        for i in nums1:\\n            if i not in res and i in nums2:\\n                res.append(i)\\n        return res\\n```\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++)\\n            set1.add(nums1[i]);\\n        \\n        for(int i=0; i<nums2.length; i++)\\n            set2.add(nums2[i]);\\n        \\n        int[] nums = new int[Math.min(set1.size(), set2.size())];\\n        int index = 0;\\n        \\n        for(int val : set1){\\n            if(set2.contains(val)){\\n                nums[index] = val;\\n                index++;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(nums, 0, index);\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> mn;\\n        set<int> s;\\n        vector<int>res;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n    set_intersection(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),std::back_inserter(mn));\\n        for(auto i:mn)s.insert(s.begin(),i);\\n        for(auto i:s)res.push_back(i);\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553732,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\n//c0de is fun \\uD83D\\uDE0E\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v1,v2; vector<int>ans;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int n = nums1.size(), m = nums2.size();\\n        \\n        int i=0, j=0;\\n        int common=INT_MIN;\\n        while(i<n and j<m){\\n            if(nums1[i] == nums2[j] and common != nums1[i]){\\n                ans.push_back(nums1[i]); common = nums1[i];\\n                i++,j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n//c0de is fun \\uD83D\\uDE0E\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v1,v2; vector<int>ans;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int n = nums1.size(), m = nums2.size();\\n        \\n        int i=0, j=0;\\n        int common=INT_MIN;\\n        while(i<n and j<m){\\n            if(nums1[i] == nums2[j] and common != nums1[i]){\\n                ans.push_back(nums1[i]); common = nums1[i];\\n                i++,j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443423,
                "title": "java-100-faster-brute-force-optimized-solution-clean-code",
                "content": "Upvote if the solution helped :) For all my optimised solutions, visit my [GitHub Repo](https://github.com/abhideepghosh/Leetcode-Solutions).\\n```\\n// Optimized Solution\\n/*\\nRuntime: 2 ms, faster than 97.86% of Java online submissions for Intersection of Two Arrays.\\nMemory Usage: 43.9 MB, less than 55.84% of Java online submissions for Intersection of Two Arrays.\\n*/\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n        int[] dp = new int[1001];\\n        \\n        for(int i : nums1){\\n            if(dp[i] == 0){\\n                dp[i]++;    \\n            }  \\n        }\\n        for(int i : nums2){\\n            if(dp[i] == 1){\\n                dp[i]++;    \\n            }\\n        }\\n        \\n        int[] res = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        \\n        for(int i=0; i<dp.length; i++){\\n            if(dp[i] >1){\\n                res[index] = i;\\n                index++;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(res, 0, index);\\n    }\\n}\\n\\n// Brute Force\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            set1.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            set2.add(nums2[i]);\\n        }\\n        int[] nums = new int[Math.min(set1.size(), set2.size())];\\n        int index = 0;\\n        \\n        for(int val : set1){\\n            if(set2.contains(val)){\\n                nums[index] = val;\\n                index++;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(nums, 0, index);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Optimized Solution\\n/*\\nRuntime: 2 ms, faster than 97.86% of Java online submissions for Intersection of Two Arrays.\\nMemory Usage: 43.9 MB, less than 55.84% of Java online submissions for Intersection of Two Arrays.\\n*/\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n        int[] dp = new int[1001];\\n        \\n        for(int i : nums1){\\n            if(dp[i] == 0){\\n                dp[i]++;    \\n            }  \\n        }\\n        for(int i : nums2){\\n            if(dp[i] == 1){\\n                dp[i]++;    \\n            }\\n        }\\n        \\n        int[] res = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        \\n        for(int i=0; i<dp.length; i++){\\n            if(dp[i] >1){\\n                res[index] = i;\\n                index++;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(res, 0, index);\\n    }\\n}\\n\\n// Brute Force\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            set1.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            set2.add(nums2[i]);\\n        }\\n        int[] nums = new int[Math.min(set1.size(), set2.size())];\\n        int index = 0;\\n        \\n        for(int val : set1){\\n            if(set2.contains(val)){\\n                nums[index] = val;\\n                index++;\\n            }\\n        }\\n        \\n        return Arrays.copyOfRange(nums, 0, index);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375080,
                "title": "c-simple-o-n-time-and-o-n-space-soln-using-unordered-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n      \\n        //Using map. O(n) time and space\\n        \\n        //Can also be solved using binary search in O(nlogn) time and O(1) space.\\n\\t\\t\\n\\t\\t//We can also 1st sort the two arrays and then use 2 pointers. This will again take O(nlogn) time and O(1) space\\n     \\n        //Naive solution takes O(n^2) time ans O(1) space.\\n        \\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<nums1.size(); i++){\\n            mp[nums1[i]] = 1;\\n        }\\n        \\n        for(int i=0; i<nums2.size(); i++){\\n            if(mp[nums2[i]] == 1){\\n                mp[nums2[i]] = 0;\\n                ans.push_back(nums2[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n      \\n        //Using map. O(n) time and space\\n        \\n        //Can also be solved using binary search in O(nlogn) time and O(1) space.\\n\\t\\t\\n\\t\\t//We can also 1st sort the two arrays and then use 2 pointers. This will again take O(nlogn) time and O(1) space\\n     \\n        //Naive solution takes O(n^2) time ans O(1) space.\\n        \\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<nums1.size(); i++){\\n            mp[nums1[i]] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2257002,
                "title": "python3-3-solutions-hashmap-two-pointers-and-binary-search",
                "content": "```\\n\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n#         O(n+m) || O(n)\\n# Runtime: 77ms 47.46% || Memory: 14.2mb 25.50%\\n        return self.hashMapSol(nums1, nums2)\\n\\n# O(nlogn), O(nlogm) || O(n)\\n# Runtime: 93% 24.79% || Memory: 14.1mb 68.42%\\n        return self.twoPointerSol(nums1, nums2)\\n\\n# O(nlogn) || O(n)\\n# Runtime: 56ms 81.21% || Memory:  14.1mb 25.50%\\n        return self.binarySearch(nums1, nums2)\\n    \\n    \\n    def hashMapSol(self, numOne, numTwo):\\n        result = []\\n        numTwoSet = set(numTwo)\\n\\n        for num in set(numOne):\\n            if num in numTwoSet:\\n                result.append(num)\\n        \\n        return result\\n\\n\\n    def twoPointerSol(self, numOne, numTwo):\\n        numOne.sort()\\n        numTwo.sort()\\n\\n        left, right = 0, 0\\n        result = []\\n        while left < len(numOne) and right < len(numTwo):\\n            if numOne[left] < numTwo[right]:\\n                left += 1\\n            elif numTwo[right] < numOne[left]:\\n                right += 1\\n            else:\\n                result.append(numOne[left])\\n                right += 1\\n                left += 1\\n\\n            \\n        return list(set(result))\\n\\n\\n    def binarySearch(self, numOne, numTwo):\\n        numTwo.sort()\\n        result = []\\n        seen = set()\\n        for num in numOne:\\n            if self.binarySearchHelper(numTwo, num) and num not in seen:\\n                result.append(num)\\n                seen.add(num)\\n            seen.add(num)\\n                \\n        return result\\n    \\n    def binarySearchHelper(self, numOne, num):\\n        left, right = 0, len(numOne) - 1\\n        while left <= right:\\n            mid = (left + right) // 2 \\n\\n            if numOne[mid] == num:\\n                return True\\n\\n            elif numOne[mid] < num:\\n                left = mid + 1\\n            else:\\n                right = mid - 1 \\n\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n#         O(n+m) || O(n)\\n# Runtime: 77ms 47.46% || Memory: 14.2mb 25.50%\\n        return self.hashMapSol(nums1, nums2)\\n\\n# O(nlogn), O(nlogm) || O(n)\\n# Runtime: 93% 24.79% || Memory: 14.1mb 68.42%\\n        return self.twoPointerSol(nums1, nums2)\\n\\n# O(nlogn) || O(n)\\n# Runtime: 56ms 81.21% || Memory:  14.1mb 25.50%\\n        return self.binarySearch(nums1, nums2)\\n    \\n    \\n    def hashMapSol(self, numOne, numTwo):\\n        result = []\\n        numTwoSet = set(numTwo)\\n\\n        for num in set(numOne):\\n            if num in numTwoSet:\\n                result.append(num)\\n        \\n        return result\\n\\n\\n    def twoPointerSol(self, numOne, numTwo):\\n        numOne.sort()\\n        numTwo.sort()\\n\\n        left, right = 0, 0\\n        result = []\\n        while left < len(numOne) and right < len(numTwo):\\n            if numOne[left] < numTwo[right]:\\n                left += 1\\n            elif numTwo[right] < numOne[left]:\\n                right += 1\\n            else:\\n                result.append(numOne[left])\\n                right += 1\\n                left += 1\\n\\n            \\n        return list(set(result))\\n\\n\\n    def binarySearch(self, numOne, numTwo):\\n        numTwo.sort()\\n        result = []\\n        seen = set()\\n        for num in numOne:\\n            if self.binarySearchHelper(numTwo, num) and num not in seen:\\n                result.append(num)\\n                seen.add(num)\\n            seen.add(num)\\n                \\n        return result\\n    \\n    def binarySearchHelper(self, numOne, num):\\n        left, right = 0, len(numOne) - 1\\n        while left <= right:\\n            mid = (left + right) // 2 \\n\\n            if numOne[mid] == num:\\n                return True\\n\\n            elif numOne[mid] < num:\\n                left = mid + 1\\n            else:\\n                right = mid - 1 \\n\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169771,
                "title": "c-easy-sol-using-sets",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        set<int>s1(nums1.begin(),nums1.end());\\n        set<int>s2(nums2.begin(),nums2.end());\\n        for(auto x: s1){\\n            if(s2.find(x)!=s2.end()){\\n                ans.push_back(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        set<int>s1(nums1.begin(),nums1.end());\\n        set<int>s2(nums2.begin(),nums2.end());\\n        for(auto x: s1){\\n            if(s2.find(x)!=s2.end()){\\n                ans.push_back(x);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1748913,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    //First I sort both array and then select the one which is smaller and perform binary search on each element of the smaller array as target in larger array to find the intersections\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        ArrayList<Integer> ans = new ArrayList <>();\\n        if(nums1.length<nums2.length){\\n           for(int i =0; i<nums1.length;i++){\\n            int a=binarySearch(nums2,nums1[i]);\\n                if(a!=-1&&!ans.contains(a)){\\n                    ans.add(a);\\n                }\\n           }\\n        }\\n        else{  \\n            for(int i =0; i<nums2.length;i++){\\n            int a=binarySearch(nums1,nums2[i]);\\n                if(a!=-1&&!ans.contains(a)){\\n                    ans.add(a);\\n                }\\n           }\\n        }\\n        int z=ans.size();\\n        int[] anns = new int[z];\\n        for(int i =0;i<z;i++){\\n            anns[i] = ans.get(i);\\n        }\\n        return anns;\\n    }\\n     int binarySearch(int[] arr, int target) {\\n        int start = 0;\\n        int end = arr.length - 1;\\n\\n        while(start <= end) {\\n           \\n            int mid = start + (end - start) / 2;\\n\\n            if (target < arr[mid]) {\\n                end = mid - 1;\\n            } else if (target > arr[mid]) {\\n                start = mid + 1;\\n            } else {\\n            \\n                return arr[mid];\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    //First I sort both array and then select the one which is smaller and perform binary search on each element of the smaller array as target in larger array to find the intersections\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        ArrayList<Integer> ans = new ArrayList <>();\\n        if(nums1.length<nums2.length){\\n           for(int i =0; i<nums1.length;i++){\\n            int a=binarySearch(nums2,nums1[i]);\\n                if(a!=-1&&!ans.contains(a)){\\n                    ans.add(a);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1654565,
                "title": "python-one-liner-solution-using-sets",
                "content": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2))\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506500,
                "title": "3-solutions-using-java",
                "content": "You can find my solutions to other leetcode problems on my Github: https://linktr.ee/rohitdhatrak\\n\\nSolution 1: arrays are sorted / using sorting\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int ptr1 = 0;\\n        int ptr2 = 0;\\n\\n        while (ptr1 < nums1.length && ptr2 < nums2.length) {\\n            if (nums1[ptr1] < nums2[ptr2]) {\\n                ptr1 = goToNextValue(ptr1, nums1);\\n            } else if (nums1[ptr1] > nums2[ptr2]) {\\n                ptr2 = goToNextValue(ptr2, nums2);\\n            } else {\\n                list.add(nums1[ptr1]);\\n                ptr1 = goToNextValue(ptr1, nums1);\\n                ptr2 = goToNextValue(ptr2, nums2);\\n            }\\n        }\\n\\n        int[] output = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            output[i] = list.get(i);\\n        }\\n        return output;\\n    }\\n    \\n    public int goToNextValue(int pointer, int[] array) {\\n        int prevValue = array[pointer];\\n        while (pointer < array.length  && array[pointer] == prevValue) {\\n            pointer++;\\n        }\\n        return pointer;\\n    }\\n}\\n```\\n\\nSolution 2: arrys are sorted + binary search\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] smaller = nums1.length <= nums2.length ? nums1 : nums2;\\n        int[] larger = nums1.length > nums2.length ? nums1 : nums2;\\n        int lastNum = -1;\\n        \\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int num: smaller) {\\n            if (num != lastNum && binarySearch(larger, num) ) {\\n                list.add(num);\\n            }\\n            lastNum = num;\\n        }\\n\\n        int[] ans = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            ans[i] = list.get(i);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    public boolean binarySearch(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            } else if (nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```\\n\\nSolution 3: Using hashset\\n```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n\\tHashSet<Integer> map = new HashSet<>();\\n\\tArrayList<Integer> list = new ArrayList<>();\\n\\tfor (int num : nums1) {\\n\\t\\tif (!map.contains(num)) {\\n\\t\\t\\tmap.add(num);\\n\\t\\t}\\n\\t}\\n\\tfor (int num : nums2) {\\n\\t\\tif (map.contains(num)) {\\n\\t\\t\\tlist.add(num); \\n\\t\\t\\tmap.remove(num);\\n\\t\\t}\\n\\t}\\n\\n\\tint[] output = new int[list.size()];\\n\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\toutput[i] = list.get(i);\\n\\t}\\n\\treturn output;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        int ptr1 = 0;\\n        int ptr2 = 0;\\n\\n        while (ptr1 < nums1.length && ptr2 < nums2.length) {\\n            if (nums1[ptr1] < nums2[ptr2]) {\\n                ptr1 = goToNextValue(ptr1, nums1);\\n            } else if (nums1[ptr1] > nums2[ptr2]) {\\n                ptr2 = goToNextValue(ptr2, nums2);\\n            } else {\\n                list.add(nums1[ptr1]);\\n                ptr1 = goToNextValue(ptr1, nums1);\\n                ptr2 = goToNextValue(ptr2, nums2);\\n            }\\n        }\\n\\n        int[] output = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            output[i] = list.get(i);\\n        }\\n        return output;\\n    }\\n    \\n    public int goToNextValue(int pointer, int[] array) {\\n        int prevValue = array[pointer];\\n        while (pointer < array.length  && array[pointer] == prevValue) {\\n            pointer++;\\n        }\\n        return pointer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] smaller = nums1.length <= nums2.length ? nums1 : nums2;\\n        int[] larger = nums1.length > nums2.length ? nums1 : nums2;\\n        int lastNum = -1;\\n        \\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int num: smaller) {\\n            if (num != lastNum && binarySearch(larger, num) ) {\\n                list.add(num);\\n            }\\n            lastNum = num;\\n        }\\n\\n        int[] ans = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            ans[i] = list.get(i);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    public boolean binarySearch(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            } else if (nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```\n```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n\\tHashSet<Integer> map = new HashSet<>();\\n\\tArrayList<Integer> list = new ArrayList<>();\\n\\tfor (int num : nums1) {\\n\\t\\tif (!map.contains(num)) {\\n\\t\\t\\tmap.add(num);\\n\\t\\t}\\n\\t}\\n\\tfor (int num : nums2) {\\n\\t\\tif (map.contains(num)) {\\n\\t\\t\\tlist.add(num); \\n\\t\\t\\tmap.remove(num);\\n\\t\\t}\\n\\t}\\n\\n\\tint[] output = new int[list.size()];\\n\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\toutput[i] = list.get(i);\\n\\t}\\n\\treturn output;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455547,
                "title": "simple-java-solution-using-binary-search",
                "content": "You can find my solutions to other leetcode problems on my Github: https://linktr.ee/rohitdhatrak\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] smaller = nums1.length <= nums2.length ? nums1 : nums2;\\n        int[] larger = nums1.length > nums2.length ? nums1 : nums2;\\n        int lastNum = -1;\\n        \\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int num: smaller) {\\n            if (num != lastNum && binarySearch(larger, num) ) {\\n                list.add(num);\\n            }\\n            lastNum = num;\\n        }\\n\\n        int[] ans = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            ans[i] = list.get(i);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    public boolean binarySearch(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            } else if (nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] smaller = nums1.length <= nums2.length ? nums1 : nums2;\\n        int[] larger = nums1.length > nums2.length ? nums1 : nums2;\\n        int lastNum = -1;\\n        \\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\n        for (int num: smaller) {\\n            if (num != lastNum && binarySearch(larger, num) ) {\\n                list.add(num);\\n            }\\n            lastNum = num;\\n        }\\n\\n        int[] ans = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            ans[i] = list.get(i);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    public boolean binarySearch(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if (nums[mid] == target) {\\n                return true;\\n            } else if (nums[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366867,
                "title": "java-sort-and-two-pointer-solution",
                "content": "```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        List<Integer> intersection = new ArrayList<Integer>();    \\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] == nums2[j] && !intersection.contains(nums1[i])) {\\n                intersection.add(nums1[i]);\\n            } else if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else {\\n                j++;\\n            }                \\n        }\\n        \\n        int[] result = new int[intersection.size()];\\n        int index = 0;\\n        for (int num : intersection) {\\n            result[index] = num;\\n            index++;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        List<Integer> intersection = new ArrayList<Integer>();    \\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] == nums2[j] && !intersection.contains(nums1[i])) {\\n                intersection.add(nums1[i]);\\n            } else if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else {\\n                j++;\\n            }                \\n        }\\n        \\n        int[] result = new int[intersection.size()];\\n        int index = 0;\\n        for (int num : intersection) {\\n            result[index] = num;\\n            index++;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1196919,
                "title": "java-easy-solution-93-faster",
                "content": "```\\nimport java.util.HashSet;\\nimport java.util.Iterator;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        HashSet<Integer> set3 = new HashSet<>();\\n\\n        for (int n : nums1) set1.add(n);\\n        for (int n : nums2) set2.add(n);\\n        \\n        for(int k : nums1) {\\n           if(set2.contains(k)) set3.add(k);\\n        }\\n        \\n        for(int k : nums2) {\\n            if(set1.contains(k)) set3.add(k);\\n        }\\n        int[] arr =  new int[set3.size()];\\n        int i = 0;\\n        Iterator<Integer> itr = set3.iterator();\\n        while (itr.hasNext()) {\\n            arr[i] = itr.next();\\n            i++;\\n        }\\n        return arr;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\nimport java.util.Iterator;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        HashSet<Integer> set3 = new HashSet<>();\\n\\n        for (int n : nums1) set1.add(n);\\n        for (int n : nums2) set2.add(n);\\n        \\n        for(int k : nums1) {\\n           if(set2.contains(k)) set3.add(k);\\n        }\\n        \\n        for(int k : nums2) {\\n            if(set1.contains(k)) set3.add(k);\\n        }\\n        int[] arr =  new int[set3.size()];\\n        int i = 0;\\n        Iterator<Integer> itr = set3.iterator();\\n        while (itr.hasNext()) {\\n            arr[i] = itr.next();\\n            i++;\\n        }\\n        return arr;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310760,
                "title": "javascript",
                "content": "```\\nvar intersection = function(nums1, nums2) {\\n    let set = new Set(nums1);\\n    let res = new Set();\\n    for(let i = 0; i < nums2.length; ++i) {\\n        if(set.has(nums2[i]))\\n            res.add(nums2[i]);\\n    }\\n    return Array.from(res);\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar intersection = function(nums1, nums2) {\\n    let set = new Set(nums1);\\n    let res = new Set();\\n    for(let i = 0; i < nums2.length; ++i) {\\n        if(set.has(nums2[i]))\\n            res.add(nums2[i]);\\n    }\\n    return Array.from(res);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256220,
                "title": "2ms-java-solution",
                "content": "```java\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> set1 = new HashSet<>();\\n        for(int i = 0; i<nums1.length; i++){\\n            set.add(nums1[i]);\\n        }\\n        for(int i = 0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))set1.add(nums2[i]);\\n        }\\n        int size = set1.size();\\n        int[] out = new int[size];\\n        int i = 0;\\n        for(Integer x : set1)out[i++]=x;\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> set1 = new HashSet<>();\\n        for(int i = 0; i<nums1.length; i++){\\n            set.add(nums1[i]);\\n        }\\n        for(int i = 0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))set1.add(nums2[i]);\\n        }\\n        int size = set1.size();\\n        int[] out = new int[size];\\n        int i = 0;\\n        for(Integer x : set1)out[i++]=x;\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241522,
                "title": "rust-0ms-hashset-solution",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn intersection(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        nums1.into_iter()\\n             .collect::<HashSet<_>>()\\n             .intersection(&nums2.into_iter()\\n                                 .collect())\\n             .into_iter()\\n             .cloned()\\n             .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn intersection(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {\\n        nums1.into_iter()\\n             .collect::<HashSet<_>>()\\n             .intersection(&nums2.into_iter()\\n                                 .collect())\\n             .into_iter()\\n             .cloned()\\n             .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207505,
                "title": "2ms-java-solution",
                "content": "```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        ArrayList<Integer> intersection = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums1.length; i++) {\\n            set.add(nums1[i]);\\n        }\\n        \\n        for (int i = 0; i < nums2.length; i++) {\\n            if (set.remove(nums2[i])) {\\n                intersection.add(nums2[i]);\\n            }\\n        }\\n        \\n        int[] result = new int[intersection.size()];\\n        for (int i = 0; i < intersection.size(); i++) {\\n            result[i] = intersection.get(i);\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        ArrayList<Integer> intersection = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums1.length; i++) {\\n            set.add(nums1[i]);\\n        }\\n        \\n        for (int i = 0; i < nums2.length; i++) {\\n            if (set.remove(nums2[i])) {\\n                intersection.add(nums2[i]);\\n            }\\n        }\\n        \\n        int[] result = new int[intersection.size()];\\n        for (int i = 0; i < intersection.size(); i++) {\\n            result[i] = intersection.get(i);\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196602,
                "title": "java-the-clearest-solution",
                "content": "\\n\\n```\\nimport java.util.Collection;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        final Set<Integer> result = new HashSet<>(toList(nums1));\\n        result.retainAll(toList(nums2));\\n        return backToStoneAge(result);\\n    }\\n    \\n    List<Integer> toList(int [] a) {\\n        return Arrays.stream(a).boxed().collect(Collectors.toList());\\n    }\\n    \\n    int[] backToStoneAge(Collection<Integer> collection) {\\n        return collection.stream().mapToInt(i->i).toArray();\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/masterel/image_1542874288.png)",
                "solutionTags": [],
                "code": "```\\nimport java.util.Collection;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        final Set<Integer> result = new HashSet<>(toList(nums1));\\n        result.retainAll(toList(nums2));\\n        return backToStoneAge(result);\\n    }\\n    \\n    List<Integer> toList(int [] a) {\\n        return Arrays.stream(a).boxed().collect(Collectors.toList());\\n    }\\n    \\n    int[] backToStoneAge(Collection<Integer> collection) {\\n        return collection.stream().mapToInt(i->i).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118783,
                "title": "scala-1-line",
                "content": "```scala\\nobject Solution {\\n    def intersection(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {\\n        (nums1 intersect nums2).distinct\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    def intersection(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {\\n        (nums1 intersect nums2).distinct\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 82036,
                "title": "solution-in-c-3ms-using-uthash",
                "content": "Since the C standard library does have a hash library (although hsearch exists, it is limited to keys that are strings), LeetCode includes [uthash](https://troydhanson.github.io/uthash/userguide.html) in its test harness. This is a solution using uthash.\\n```\\ntypedef struct { int key; bool intersect; UT_hash_handle hh; } Map;\\n\\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\\n    Map *map = NULL, *elem, *tmp;\\n    int *result, len = 0;\\n    \\n    // Get the size of the smaller list, since the intersection can never be\\n    // larger than the smaller list.\\n    *returnSize = nums1Size < nums2Size? nums1Size: nums2Size;\\n    result = malloc(*returnSize * sizeof(int));\\n    \\n    // Populate the elements of nums1 into the hash table.\\n    for (int i = 0; i < nums1Size; i++) {\\n        elem = malloc(sizeof(Map));\\n        elem->key = nums1[i];\\n        elem->intersect = false;\\n        HASH_ADD_INT(map, key, elem);\\n    }\\n\\n    // Go through nums2 and mark the common elements (same value) as intersecting.\\n    for (int i = 0; i < nums2Size; i++) {\\n        elem = NULL;\\n        HASH_FIND_INT(map, &nums2[i], elem);\\n        if (elem) {\\n            elem->intersect = true;\\n        }\\n    }\\n    \\n    // Iterate the hash table, and return only the intersecting elements.\\n    HASH_ITER(hh, map, elem, tmp) {\\n        if (elem->intersect) {\\n            result[len++] = elem->key;\\n        }\\n    }\\n    \\n    // In case the number of intersecting elements is smaller than the original\\n    // allocated size, reduce the buffer size by calling realloc.\\n    *returnSize = len;\\n    return realloc(result, sizeof(int) * len);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct { int key; bool intersect; UT_hash_handle hh; } Map;\\n\\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {\\n    Map *map = NULL, *elem, *tmp;\\n    int *result, len = 0;\\n    \\n    // Get the size of the smaller list, since the intersection can never be\\n    // larger than the smaller list.\\n    *returnSize = nums1Size < nums2Size? nums1Size: nums2Size;\\n    result = malloc(*returnSize * sizeof(int));\\n    \\n    // Populate the elements of nums1 into the hash table.\\n    for (int i = 0; i < nums1Size; i++) {\\n        elem = malloc(sizeof(Map));\\n        elem->key = nums1[i];\\n        elem->intersect = false;\\n        HASH_ADD_INT(map, key, elem);\\n    }\\n\\n    // Go through nums2 and mark the common elements (same value) as intersecting.\\n    for (int i = 0; i < nums2Size; i++) {\\n        elem = NULL;\\n        HASH_FIND_INT(map, &nums2[i], elem);\\n        if (elem) {\\n            elem->intersect = true;\\n        }\\n    }\\n    \\n    // Iterate the hash table, and return only the intersecting elements.\\n    HASH_ITER(hh, map, elem, tmp) {\\n        if (elem->intersect) {\\n            result[len++] = elem->key;\\n        }\\n    }\\n    \\n    // In case the number of intersecting elements is smaller than the original\\n    // allocated size, reduce the buffer size by calling realloc.\\n    *returnSize = len;\\n    return realloc(result, sizeof(int) * len);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 82063,
                "title": "two-lines-python-code",
                "content": "```\\nclass Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not nums1 or not nums2: return []\\n        return list(set(nums1 + nums2) - (set(nums1) - set(nums2)) - (set(nums2) - set(nums1)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not nums1 or not nums2: return []\\n        return list(set(nums1 + nums2) - (set(nums1) - set(nums2)) - (set(nums2) - set(nums1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82106,
                "title": "two-different-solutions-in-c-well-commented",
                "content": "```\\n//AC - 12ms;\\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\\nint* intersection(int* nums1, int size1, int* nums2, int size2, int* returnSize)\\n{\\n    int size = MIN(size1, size2);\\n    int *arr = (int*)malloc(sizeof(int)*(size));\\n    int top = -1;\\n    for(int i = 0; i < size1; i++) //check each element in nums1;\\n    {\\n        int j = 0;\\n        for(; j < size2; j++) //check whether the nums[i] in array nums2;\\n            if(nums1[i] == nums2[j]) break;\\n        if(j < size2)\\n        {\\n            j = 0;\\n            for(; j <= top; j++) //avoid duplicate;\\n                if(arr[j] == nums1[i]) break;\\n            if(j > top)\\n                arr[++top] = nums1[i];\\n        }\\n    }\\n    *returnSize = top+1;\\n    return arr;\\n}\\n```\\n----------\\n\\n\\n    #define MIN(a, b) ((a) < (b) ? (a) : (b))    \\n    void swap(int* p, int* q)\\n    {\\n        int t=*p; *p=*q; *q=t;\\n    }\\n    \\n    //Quick sort;\\n    void sort(int* nums, int begin, int end)\\n    {\\n        int l = begin, r = end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                swap(nums+l, nums+r);\\n                l++, r--;\\n            }\\n        }\\n        if(begin < r)\\n            sort(nums, begin, r);\\n        if(l < end)\\n            sort(nums, l, end);\\n    }\\n    \\n    //AC - 4ms - using two pointers;\\n    int* intersection(int* nums1, int size1, int* nums2, int size2, int* returnSize)\\n    {\\n        sort(nums1, 0, size1-1);\\n        sort(nums2, 0, size2-1);\\n        int size = MIN(size1, size2);\\n        int* arr = (int*)malloc(sizeof(int)*size); //the size of the result will at most be size;\\n        int top = -1;\\n        int p1=0, p2=0;\\n        while(p1<size1 && p2<size2)\\n        {\\n            if(nums1[p1] > nums2[p2]) p2++;\\n            else if(nums1[p1] < nums2[p2]) p1++;\\n            else //only collect the equal one;\\n            {\\n                if(top==-1 || arr[top]!=nums1[p1])  //avoid duplicates;\\n                    arr[++top] = nums1[p1];\\n                p1++, p2++;\\n            }\\n        }\\n        *returnSize = top+1;\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "```\\n//AC - 12ms;\\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\\nint* intersection(int* nums1, int size1, int* nums2, int size2, int* returnSize)\\n{\\n    int size = MIN(size1, size2);\\n    int *arr = (int*)malloc(sizeof(int)*(size));\\n    int top = -1;\\n    for(int i = 0; i < size1; i++) //check each element in nums1;\\n    {\\n        int j = 0;\\n        for(; j < size2; j++) //check whether the nums[i] in array nums2;\\n            if(nums1[i] == nums2[j]) break;\\n        if(j < size2)\\n        {\\n            j = 0;\\n            for(; j <= top; j++) //avoid duplicate;\\n                if(arr[j] == nums1[i]) break;\\n            if(j > top)\\n                arr[++top] = nums1[i];\\n        }\\n    }\\n    *returnSize = top+1;\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 82224,
                "title": "my-c-solutions-using-set-and-unordered-set",
                "content": "Using set 20ms\\n\\n    class Solution {\\n    public:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st1(nums1.begin(),nums1.end());\\n        set<int> st2(nums2.begin(),nums2.end());\\n        set<int> intersection; \\n        set_intersection(st1.begin(),st1.end(), st2.begin(), st2.end(), inserter(intersection, intersection.end())); \\n        return vector<int>(intersection.begin(),intersection.end());\\n    }\\n    };\\n\\nUsing unordered_set 12ms\\n\\n    class Solution {\\n    public:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> st1(nums1.begin(),nums1.end());\\n        unordered_set<int> st2(nums2.begin(),nums2.end());\\n        vector<int> ret;\\n        for(const auto & x:st1)\\n            if(st2.count(x))\\n                ret.push_back(x);\\n        return ret;\\n    }\\n    };\\n\\nUsing unordered_set 12ms\\n\\n    class Solution {\\n    public:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> st(nums1.begin(),nums1.end());\\n        vector<int> ret;\\n        for(const auto & x:nums2)\\n            if(st.count(x))\\n            {\\n                ret.push_back(x);\\n                st.erase(x);\\n            }\\n        return ret;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st1(nums1.begin(),nums1.end());\\n        set<int> st2(nums2.begin(),nums2.end());\\n        set<int> intersection; \\n        set_intersection(st1.begin(),st1.end(), st2.begin(), st2.end(), inserter(intersection, intersection.end())); \\n        return vector<int>(intersection.begin(),intersection.end());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3815734,
                "title": "c-brute-force-approach-too-easy-fully-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider the following input vectors:\\n\\n```\\nvector<int> nums1 = {1, 2, 2, 1};\\nvector<int> nums2 = {2, 2};\\n```\\nLet\\'s trace through the code with this example:\\n\\n1. Sort both input vectors \"nums1\" and \"nums2\" in ascending order.\\n\\n   - Sorted \"nums1\": `{1, 1, 2, 2}`\\n   - Sorted \"nums2\": `{2, 2}`\\n\\n2. Initialize an empty set \"st\" to store the intersection elements (since a set will automatically ensure unique elements).\\n\\n3. Initialize an empty vector \"ans\" to store the final result.\\n\\n4. Initialize two pointers \"i\" and \"j\" to 0 to keep track of the current positions in \"nums1\" and \"nums2,\" respectively.\\n\\n   - `i = 0`\\n   - `j = 0`\\n\\n5. Enter the while loop (`while(i < nums1.size() && j < nums2.size())`).\\n\\n6. Compare the elements at the current positions \"i\" and \"j\" in \"nums1\" and \"nums2,\" respectively.\\n\\n   - For `nums1[0] (1)` and `nums2[0] (2)`: Since 1 is less than 2, increment \"i.\"\\n\\n     - `i = 1`\\n\\n7. Compare the elements at the updated positions \"i\" and \"j\" in \"nums1\" and \"nums2,\" respectively.\\n\\n   - For `nums1[1] (1)` and `nums2[0] (2)`: Since 1 is less than 2, increment \"i.\"\\n\\n     - `i = 2`\\n\\n8. Compare the elements at the updated positions \"i\" and \"j\" in \"nums1\" and \"nums2,\" respectively.\\n\\n   - For `nums1[2] (2)` and `nums2[0] (2)`: Since 2 is equal to 2, insert 2 into the set \"st\" and increment both \"i\" and \"j.\"\\n\\n     - `i = 3`\\n     - `j = 1`\\n\\n9. Compare the elements at the updated positions \"i\" and \"j\" in \"nums1\" and \"nums2,\" respectively.\\n\\n   - For `nums1[3] (2)` and `nums2[1] (2)`: Since 2 is equal to 2, insert 2 into the set \"st\" and increment both \"i\" and \"j.\"\\n\\n     - `i = 4`\\n     - `j = 2`\\n\\n10. Since \"i\" is now equal to the size of \"nums1\" (4) or \"j\" is equal to the size of \"nums2\" (2), exit the while loop.\\n\\n11. Copy the elements from the set \"st\" into the vector \"ans.\"\\n\\n   - `ans = {2}`\\n\\n12. Return the \"ans\" vector, which contains the intersection of the two input vectors.\\n\\nSo, the output of the function for the given example will be `{2}`, as it represents the elements that appear in both \"nums1\" and \"nums2.\"\\n\\n# Complexity\\n- Time complexity:$$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        set<int> st;\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n        while(i < nums1.size() && j < nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                st.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        for(auto it: st){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nvector<int> nums1 = {1, 2, 2, 1};\\nvector<int> nums2 = {2, 2};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        set<int> st;\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n        while(i < nums1.size() && j < nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                st.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        for(auto it: st){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801090,
                "title": "easy-to-understand-clear-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The approach of this solution is to sort both arrays first. Then, use two pointers, one for each array, to iterate through the arrays and compare the elements. At each iteration, compare the elements at the current positions of both pointers. If the elements are equal, add the element to the output vector and advance both pointers. If the element in nums1 is greater than the element in nums2, advance the pointer for nums2. If the element in nums1 is less than the element in nums2, advance the pointer for nums1.\\n\\n![image.png](https://assets.leetcode.com/users/images/24247abe-7311-43f7-a73a-5fe1a8ba675d_1690033524.3086267.png)\\n\\n- To avoid duplicates, we add a check for the current element in nums1 against the previous element in nums1. If they are the same, advance the pointer for nums1 without adding the element to the output vector.\\n\\n- This approach takes advantage of the fact that the arrays are sorted to efficiently compare the elements and avoid duplicates.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size(),n=nums2.size(),i=0,j=0;\\n        vector<int>ans;\\n        set<int> st;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        while(i<m && j<n){\\n\\n            if(nums1[i]<nums2[j]) i++;\\n\\n            else if(nums1[i]==nums2[j]) {\\n                st.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums1[i]>nums2[j]) j++;\\n        }\\n        //hume unique value chiyee \\n        //so we can use erase function and set data structure\\n\\n        //ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        \\n        for(auto val: st)\\n           ans.push_back(val);\\n\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int m=nums1.size(),n=nums2.size(),i=0,j=0;\\n        vector<int>ans;\\n        set<int> st;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        while(i<m && j<n){\\n\\n            if(nums1[i]<nums2[j]) i++;\\n\\n            else if(nums1[i]==nums2[j]) {\\n                st.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums1[i]>nums2[j]) j++;\\n        }\\n        //hume unique value chiyee \\n        //so we can use erase function and set data structure\\n\\n        //ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n        \\n        for(auto val: st)\\n           ans.push_back(val);\\n\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763968,
                "title": "using-one-set-simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] arr1, int[] arr2) {\\n\\t\\tSet<Integer> se=new HashSet<>();\\n\\t\\tfor(int i=0;i<arr1.length;i++){\\n\\t\\t\\tse.add(arr1[i]);\\n\\t\\t}\\n\\t\\tList<Integer> li=new ArrayList<>();\\n\\t\\tfor(int i=0;i<arr2.length;i++){\\n\\t\\t\\tint a=arr2[i];\\n\\t\\t\\tif(se.contains(a)){\\n\\t\\t\\t\\tli.add(a);\\n\\t\\t\\t\\tse.remove(a);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] ans=new int[li.size()];\\n\\t\\tfor(int i=0;i<ans.length;i++){\\n\\t\\t\\tans[i]=li.get(i);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] arr1, int[] arr2) {\\n\\t\\tSet<Integer> se=new HashSet<>();\\n\\t\\tfor(int i=0;i<arr1.length;i++){\\n\\t\\t\\tse.add(arr1[i]);\\n\\t\\t}\\n\\t\\tList<Integer> li=new ArrayList<>();\\n\\t\\tfor(int i=0;i<arr2.length;i++){\\n\\t\\t\\tint a=arr2[i];\\n\\t\\t\\tif(se.contains(a)){\\n\\t\\t\\t\\tli.add(a);\\n\\t\\t\\t\\tse.remove(a);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] ans=new int[li.size()];\\n\\t\\tfor(int i=0;i<ans.length;i++){\\n\\t\\t\\tans[i]=li.get(i);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742355,
                "title": "two-sets-method-java",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n+m)\\n\\n\\n- Space complexity:\\nO(m+n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        HashSet<Integer> inter = new HashSet<>();\\n\\n        for(int i = 0; i < nums1.length; i++){\\n            if(!seen.contains(nums1[i])){\\n                seen.add(nums1[i]);\\n            }\\n        }\\n\\n        for(int i = 0; i < nums2.length; i++){\\n            if(seen.contains(nums2[i])){\\n                inter.add(nums2[i]);\\n            }\\n        }\\n        int n = inter.size();\\n        int arr[] = new int[n];\\n  \\n        int i = 0;\\n        for (int x : inter)\\n            arr[i++] = x;\\n  \\n        return arr; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        HashSet<Integer> inter = new HashSet<>();\\n\\n        for(int i = 0; i < nums1.length; i++){\\n            if(!seen.contains(nums1[i])){\\n                seen.add(nums1[i]);\\n            }\\n        }\\n\\n        for(int i = 0; i < nums2.length; i++){\\n            if(seen.contains(nums2[i])){\\n                inter.add(nums2[i]);\\n            }\\n        }\\n        int n = inter.size();\\n        int arr[] = new int[n];\\n  \\n        int i = 0;\\n        for (int x : inter)\\n            arr[i++] = x;\\n  \\n        return arr; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681088,
                "title": "c-basic-solution-for-beginners-time-o-n-space-o-n-simple-approch-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPlease Upvote if you like that will motivate me to share easy methods to hard problems\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate two set and store unique elements of both num1 and num2.\\nthen iterate from 1 set two other set and find common one and add that to vector.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> arr1,arr2;\\n        for(auto it:nums1){\\n            arr1.emplace(it);\\n        }\\n        for(auto it:nums2){\\n            arr2.emplace(it);\\n        }\\n        vector<int> list;\\n        for(auto it:arr1){\\n            if(arr2.count(it))\\n                list.push_back(it);\\n        }\\n        return list;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> arr1,arr2;\\n        for(auto it:nums1){\\n            arr1.emplace(it);\\n        }\\n        for(auto it:nums2){\\n            arr2.emplace(it);\\n        }\\n        vector<int> list;\\n        for(auto it:arr1){\\n            if(arr2.count(it))\\n                list.push_back(it);\\n        }\\n        return list;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508665,
                "title": "simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n    Set<Integer> x=new HashSet<>();\\n      Set<Integer> y=new HashSet<>();\\n      for(int i=0;i<nums1.length;i++){\\n          x.add(nums1[i]);\\n      }\\n      for(int i=0;i<nums2.length;i++){\\n          y.add(nums2[i]);\\n      }\\n      x.retainAll(y);\\n      int ans[]=new int[x.size()];\\n      int i = 0;\\n        for(Integer n : x) {\\n            ans[i] = n;\\n            i++;\\n        }\\n     return ans; }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n    Set<Integer> x=new HashSet<>();\\n      Set<Integer> y=new HashSet<>();\\n      for(int i=0;i<nums1.length;i++){\\n          x.add(nums1[i]);\\n      }\\n      for(int i=0;i<nums2.length;i++){\\n          y.add(nums2[i]);\\n      }\\n      x.retainAll(y);\\n      int ans[]=new int[x.size()];\\n      int i = 0;\\n        for(Integer n : x) {\\n            ans[i] = n;\\n            i++;\\n        }\\n     return ans; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228361,
                "title": "awesome-2-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)----->please upvote me\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)----->please upvote me\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1,nums2=set(nums1),set(nums2)\\n        return nums1 & nums2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        nums1,nums2=set(nums1),set(nums2)\\n        return nums1 & nums2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140730,
                "title": "onlycode-java-using-hashset",
                "content": "# Approach\\nThis code finds the intersection of two arrays nums1 and nums2, which means it returns an array that contains only the common elements present in both arrays. The approach taken here is to use the Java Set data structure, which does not allow duplicate elements.\\n\\nFirst, the code creates two sets set1 and set2 by adding each element of nums1 and nums2 respectively. Then, it iterates over set1 and checks if each element is present in set2 by using the contains() method. If it is, it adds that element to a final set finalSet.\\n\\nFinally, it converts the finalSet to an array arr and returns it as the result.\\n\\n# Time and Space Complexity\\n\\n- Time Complexity\\n   The time complexity of this code is O(n), where n is the length of the longest array (either nums1 or nums2). This is because the code performs two loops, one over each array to create the sets set1 and set2, and another over set1 to find the elements present in both sets and add them to the final set finalSet.\\n\\n\\n\\n\\n- Space Complexity\\nThe space complexity of this code is O(m), where m is the number of unique elements in the intersection of nums1 and nums2. This is because the final set finalSet will contain all unique elements in the intersection, and its size depends on the number of unique elements in the intersection. Additionally, the code also creates two sets set1 and set2 that take up O(m) space as well.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        for (int i : nums1) {\\n            set1.add(i);\\n        }\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int i : nums2) {\\n            set2.add(i);\\n        }\\n        Set<Integer> finalSet = new HashSet<>();\\n        for (Integer var : set1) {\\n            if (set2.contains(var)) {\\n                finalSet.add(var);\\n            }\\n        }\\n        int[] arr = new int[finalSet.size()];\\n        int idx = 0;\\n        for (Integer value : finalSet) {\\n            arr[idx] = value;\\n            idx++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        for (int i : nums1) {\\n            set1.add(i);\\n        }\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int i : nums2) {\\n            set2.add(i);\\n        }\\n        Set<Integer> finalSet = new HashSet<>();\\n        for (Integer var : set1) {\\n            if (set2.contains(var)) {\\n                finalSet.add(var);\\n            }\\n        }\\n        int[] arr = new int[finalSet.size()];\\n        int idx = 0;\\n        for (Integer value : finalSet) {\\n            arr[idx] = value;\\n            idx++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075681,
                "title": "best-solution-with-3ms-runtime-10mb-memory-beats-95-98",
                "content": "\\n# Complexity\\n- Runtime: 3ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Memory: 10mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n      vector<int> result;\\n      for(auto i: nums1)\\n      {\\n          if(count(nums2.begin(),nums2.end(),i)>0)\\n          {\\n              if(count(result.begin(),result.end(),i)==0)\\n              {\\n                  result.push_back(i);\\n              }\\n          }\\n      }\\n      return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n      vector<int> result;\\n      for(auto i: nums1)\\n      {\\n          if(count(nums2.begin(),nums2.end(),i)>0)\\n          {\\n              if(count(result.begin(),result.end(),i)==0)\\n              {\\n                  result.push_back(i);\\n              }\\n          }\\n      }\\n      return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676484,
                "title": "java-solution-using-hashset",
                "content": "```\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n       ArrayList<Integer> al=new ArrayList<>();\\n        Set<Integer> set1=new HashSet<>();\\n        Set<Integer> set2=new HashSet<>();\\n        for(int a:nums1){\\n            set1.add(a);\\n        }\\n        for(int b:nums2){\\n            set2.add(b);\\n        }\\n        for(int a:set1){\\n            if(set2.contains(a)){\\n                al.add(a);\\n            }\\n        }\\n        int[] arr=new int[al.size()];\\n        for(int k=0;k<al.size();k++){\\n            arr[k]=al.get(k);\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n       ArrayList<Integer> al=new ArrayList<>();\\n        Set<Integer> set1=new HashSet<>();\\n        Set<Integer> set2=new HashSet<>();\\n        for(int a:nums1){\\n            set1.add(a);\\n        }\\n        for(int b:nums2){\\n            set2.add(b);\\n        }\\n        for(int a:set1){\\n            if(set2.contains(a)){\\n                al.add(a);\\n            }\\n        }\\n        int[] arr=new int[al.size()];\\n        for(int k=0;k<al.size();k++){\\n            arr[k]=al.get(k);\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2654332,
                "title": "c-language-easy-solution",
                "content": "# Code\\n```\\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size,\\n                  int* returnSize) {\\n  int* map = malloc(sizeof(int) * 1000);\\n  int* res = malloc(sizeof(int) * 1000);\\n  int cnt = 0;\\n\\n  for (int i = 0; i < nums1Size; i++) {\\n    map[nums1[i]] = 1;\\n  }\\n  for (int i = 0; i < nums2Size; i++) {\\n    if (map[nums2[i]] == 1) {\\n      res[cnt++] = nums2[i];\\n      map[nums2[i]] = 0;\\n    }\\n  }\\n  *returnSize = cnt;\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size,\\n                  int* returnSize) {\\n  int* map = malloc(sizeof(int) * 1000);\\n  int* res = malloc(sizeof(int) * 1000);\\n  int cnt = 0;\\n\\n  for (int i = 0; i < nums1Size; i++) {\\n    map[nums1[i]] = 1;\\n  }\\n  for (int i = 0; i < nums2Size; i++) {\\n    if (map[nums2[i]] == 1) {\\n      res[cnt++] = nums2[i];\\n      map[nums2[i]] = 0;\\n    }\\n  }\\n  *returnSize = cnt;\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2654231,
                "title": "java-solution-with-two-pointer-approach-runtime-3ms-easy-understanding",
                "content": "```\\n //Approach 01: Two HashSet\\n        //Copy first array into hashset\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for (int i : nums1) {\\n            set.add(i);\\n        }\\n        \\n        //Create a new Hashset to store the intersection\\n        HashSet<Integer> intersectionList = new HashSet<>();\\n        for (int i : nums2) {//Loop through the second array\\n            if (set.contains(i)) intersectionList.add(i);//check that element in array 2 are present in hashset. if exists then added to the \\'intersectionList\\' hashset.\\n        }\\n    //Now final task is to store hashset value to array\\n        int[] resultList = new int[intersectionList.size()];\\n        int index = 0;\\n        for (int i : intersectionList) {\\n            resultList[index++] = i;\\n        }\\n        return resultList;\\n        \\n       \\n//Approach 02: Two Pointer approach\\n        \\n        //first sort both the arrays\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        //store the length of both the arrays\\n        int n = nums1.length;\\n        int m = nums2.length;\\n\\n        //create hashset to avoid the duplicate entry in result\\n        HashSet<Integer> resultSet = new HashSet<>();\\n        //Here, i is pointing to the first array i.e nums1 and j is pointing to second array i.e. nums2\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else if (nums1[i] == nums2[j]) {\\n                resultSet.add(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n         //Now final task is to store hashset value to array\\n        int[] finalResult = new int[resultSet.size()];\\n        int index = 0;\\n        for (int value : resultSet) {\\n            finalResult[index++] = value;\\n        }\\n        return finalResult;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n //Approach 01: Two HashSet\\n        //Copy first array into hashset\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for (int i : nums1) {\\n            set.add(i);\\n        }\\n        \\n        //Create a new Hashset to store the intersection\\n        HashSet<Integer> intersectionList = new HashSet<>();\\n        for (int i : nums2) {//Loop through the second array\\n            if (set.contains(i)) intersectionList.add(i);//check that element in array 2 are present in hashset. if exists then added to the \\'intersectionList\\' hashset.\\n        }\\n    //Now final task is to store hashset value to array\\n        int[] resultList = new int[intersectionList.size()];\\n        int index = 0;\\n        for (int i : intersectionList) {\\n            resultList[index++] = i;\\n        }\\n        return resultList;\\n        \\n       \\n//Approach 02: Two Pointer approach\\n        \\n        //first sort both the arrays\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        //store the length of both the arrays\\n        int n = nums1.length;\\n        int m = nums2.length;\\n\\n        //create hashset to avoid the duplicate entry in result\\n        HashSet<Integer> resultSet = new HashSet<>();\\n        //Here, i is pointing to the first array i.e nums1 and j is pointing to second array i.e. nums2\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else if (nums1[i] == nums2[j]) {\\n                resultSet.add(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n         //Now final task is to store hashset value to array\\n        int[] finalResult = new int[resultSet.size()];\\n        int index = 0;\\n        for (int value : resultSet) {\\n            finalResult[index++] = value;\\n        }\\n        return finalResult;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2619178,
                "title": "c-two-pointer-approach-only-less-memory-used",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> ans;\\n       \\n        int s=0,l=0,k=-1;\\n        \\n        while(s<nums1.size()&&l<nums2.size()){\\n        \\n        \\n        if(nums1[s]==nums2[l]){\\n            if(k==nums1[s]){s++;l++;}\\n            else{ans.push_back(nums1[s]);k=nums1[s];s++;l++;}}//using k to store a value that is matched already so that cases after it having the same value can be ignored \\n        else if(nums1[s]<nums2[l]) s++;\\n        else l++;\\n        \\n        }\\n        return ans;\\n    }\\n\\t\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> ans;\\n       \\n        int s=0,l=0,k=-1;\\n        \\n        while(s<nums1.size()&&l<nums2.size()){\\n        \\n        \\n        if(nums1[s]==nums2[l]){\\n            if(k==nums1[s]){s++;l++;}",
                "codeTag": "Java"
            },
            {
                "id": 2605785,
                "title": "java-faster-than-99-9-without-hashing-o-n",
                "content": "```\\n\\n```class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        int[] ar= new int[1001];\\n        for (int i=0;i<nums1.length;i++){\\n            ar[nums1[i]]=1;\\n        }\\n        ArrayList<Integer> list= new ArrayList<>();\\n        for(int i=0;i<nums2.length;i++){\\n            if(ar[nums2[i]]==1){\\n                ar[nums2[i]]=0;\\n                list.add(nums2[i]);\\n            }\\n        }\\n        int[] ar1= new int[list.size()];\\n        for(int i=0;i<list.size();i++){\\n            ar1[i]=list.get(i);\\n        }\\n        return ar1;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2600543,
                "title": "one-liner-code",
                "content": "return set([value for value in nums1 if value in nums2])",
                "solutionTags": [
                    "Python"
                ],
                "code": "return set([value for value in nums1 if value in nums2])",
                "codeTag": "Unknown"
            },
            {
                "id": 2524149,
                "title": "js-best-solution-use-hashmap-100",
                "content": "```\\nvar intersection = function(nums1, nums2) {\\n    const output = [];\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        hashmap.set(nums1[i], i);\\n    }\\n    \\n    for (let i = 0; i < nums2.length; i++) {\\n        const num = nums2[i];\\n        if (hashmap.has(num)) {\\n            output.push(num);\\n            hashmap.delete(num);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intersection = function(nums1, nums2) {\\n    const output = [];\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < nums1.length; i++) {\\n        hashmap.set(nums1[i], i);\\n    }\\n    \\n    for (let i = 0; i < nums2.length; i++) {\\n        const num = nums2[i];\\n        if (hashmap.has(num)) {\\n            output.push(num);\\n            hashmap.delete(num);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454578,
                "title": "javascript-one-line",
                "content": "```\\nconst intersection = (nums1, nums2) => nums1.reduce((a, c) => (nums2.includes(c) && !a.includes(c) ? [...a, c] : a), []);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst intersection = (nums1, nums2) => nums1.reduce((a, c) => (nums2.includes(c) && !a.includes(c) ? [...a, c] : a), []);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270237,
                "title": "c-easy-solution-hash-set-for-beginners",
                "content": "**Well commented and explained** C++ code using HashSet\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_set <int> hash;\\n        \\n        /*First Pushing all the elements of the first array into the hash set*/\\n        for (int i = 0; i < nums1.size(); i++)\\n        {\\n            hash.insert (nums1[i]);\\n        }\\n        \\n        \\n        vector <int> inter;             \\n        /*Vector to store all the interesecting elements (which may contain dupilcate values as well.)*/\\n        \\n        /*Here we shall check all the elements of second array whether it already exists in the hash set.\\n        If it does, that means it is an intersecting element and hence we push it into the inter vector*/\\n        for (int i = 0; i < nums2.size(); i++)\\n        {\\n            if (hash.count (nums2[i]) <= 0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                inter.push_back (nums2[i]);\\n            }\\n        }\\n        \\n        \\n        \\n        hash.clear();\\n        vector <int> ans;\\n        /*This vector shall remove the duplicate elements in the inter vector*/\\n        \\n        /*Removing the duplicate elements*/\\n        for (int i = 0; i < inter.size(); i++)\\n        {\\n            if (hash.count (inter[i]) <= 0)\\n            {\\n                hash.insert (inter[i]);\\n                ans.push_back (inter[i]);\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_set <int> hash;\\n        \\n        /*First Pushing all the elements of the first array into the hash set*/\\n        for (int i = 0; i < nums1.size(); i++)\\n        {\\n            hash.insert (nums1[i]);\\n        }\\n        \\n        \\n        vector <int> inter;             \\n        /*Vector to store all the interesecting elements (which may contain dupilcate values as well.)*/\\n        \\n        /*Here we shall check all the elements of second array whether it already exists in the hash set.\\n        If it does, that means it is an intersecting element and hence we push it into the inter vector*/\\n        for (int i = 0; i < nums2.size(); i++)\\n        {\\n            if (hash.count (nums2[i]) <= 0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                inter.push_back (nums2[i]);\\n            }\\n        }\\n        \\n        \\n        \\n        hash.clear();\\n        vector <int> ans;\\n        /*This vector shall remove the duplicate elements in the inter vector*/\\n        \\n        /*Removing the duplicate elements*/\\n        for (int i = 0; i < inter.size(); i++)\\n        {\\n            if (hash.count (inter[i]) <= 0)\\n            {\\n                hash.insert (inter[i]);\\n                ans.push_back (inter[i]);\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241461,
                "title": "easy-c-solution-using-2-sets",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s1(nums1.begin(),nums1.end());\\n        set<int> s2(nums2.begin(),nums2.end());\\n        vector<int> v;\\n        for(auto it:s1)\\n        {\\n            if(s2.find(it)!=s2.end()) v.push_back(it);\\n        }\\n        return v;\\n    }\\n};\\n```\\nPlease Upvote,if you like it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> s1(nums1.begin(),nums1.end());\\n        set<int> s2(nums2.begin(),nums2.end());\\n        vector<int> v;\\n        for(auto it:s1)\\n        {\\n            if(s2.find(it)!=s2.end()) v.push_back(it);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228641,
                "title": "c-map-easy-solution-o-m-n",
                "content": "\\t// Insert all the elements of nums1 into map\\n\\t// iterate through nums2 ans check is nums2[1] is found in map \\n\\t// means this is common element hence store this element in another map(m2) to avoid repetetions \\n\\t// iterate through all the elements of m2 and push back in the ans vector\\n\\t// Finally return the ans vector\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\t\\tunordered_map<int,int>m,m2;\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(auto &i:nums1)\\n\\t\\t\\t\\tm[i]++;\\n\\t\\t\\tfor(auto &i:nums2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(m.find(i)!=m.end())\\n\\t\\t\\t\\t\\tm2[i]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &i:m2)\\n\\t\\t\\t\\tans.push_back(i.first);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\t\\tunordered_map<int,int>m,m2;\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(auto &i:nums1)\\n\\t\\t\\t\\tm[i]++;\\n\\t\\t\\tfor(auto &i:nums2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(m.find(i)!=m.end())\\n\\t\\t\\t\\t\\tm2[i]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2217227,
                "title": "simple-java-solution-faster-than-100",
                "content": "Fastest JAVA solution using just boolean array not any complex data structures\\nEasy to understand\\n```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        boolean[] check = new boolean[1001]; // 0 <= nums1[i], nums2[i] <= 1000(given)\\n        int[] res = new int[Math.max(nums1.length,nums2.length)];\\n        \\n        for(int num: nums1)\\n            check[num] = true;\\n        \\n        int count = 0;\\n        for(int num: nums2){\\n            if(check[num] == true){\\n                res[count] = num;\\n                count++;\\n                check[num] = false;\\n            }\\n        }\\n        \\n        return Arrays.copyOf(res,count);\\n    }\\n}\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/61427b8b-2541-474c-9e0a-e412d10007eb_1656574374.7510054.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        boolean[] check = new boolean[1001]; // 0 <= nums1[i], nums2[i] <= 1000(given)\\n        int[] res = new int[Math.max(nums1.length,nums2.length)];\\n        \\n        for(int num: nums1)\\n            check[num] = true;\\n        \\n        int count = 0;\\n        for(int num: nums2){\\n            if(check[num] == true){\\n                res[count] = num;\\n                count++;\\n                check[num] = false;\\n            }\\n        }\\n        \\n        return Arrays.copyOf(res,count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896692,
                "title": "c-hashmap-sol",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,bool>mp;\\n        for(auto i:nums1)\\n        {\\n            mp[i]=true;\\n        }\\n    vector<int>ans;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            if(mp[nums2[i]]==true)\\n            {\\n                ans.push_back(nums2[i]);\\n                mp[nums2[i]]=false;\\n            }\\n        }\\n        return ans;\\n    \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,bool>mp;\\n        for(auto i:nums1)\\n        {\\n            mp[i]=true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1787088,
                "title": "java-hashmap-beginner-friendly-different",
                "content": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums1.length; i++){\\n             map.put(nums1[i],1);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(map.getOrDefault(nums2[i],0)==1){\\n                ans.add(nums2[i]);\\n                map.put(nums2[i],0);\\n            }\\n        }\\n        int[] result=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            result[i]=ans.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums1.length; i++){\\n             map.put(nums1[i],1);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(map.getOrDefault(nums2[i],0)==1){\\n                ans.add(nums2[i]);\\n                map.put(nums2[i],0);\\n            }\\n        }\\n        int[] result=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            result[i]=ans.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778082,
                "title": "java-hashset-solution",
                "content": "class Solution {\\n\\n     static int[] intersection(int[]nums1 ,int[]nums2){\\n       \\n        HashSet<Integer> hashSet = new HashSet<>();\\n        HashSet<Integer> hashSet2 = new HashSet<>();\\n\\n        for (int e:nums1){\\n            hashSet.add(e);\\n        }\\n        for (int e:nums2){\\n            if (hashSet.contains(e) ) {\\n                hashSet2.add(e);\\n            }\\n        }\\n\\t\\t\\n        int[]ans = new int[hashSet2.size()];\\n         int k = 0;\\n        for (int e :hashSet2){\\n          ans[k++] =  e ;\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n     static int[] intersection(int[]nums1 ,int[]nums2){\\n       \\n        HashSet<Integer> hashSet = new HashSet<>();\\n        HashSet<Integer> hashSet2 = new HashSet<>();\\n\\n        for (int e:nums1){\\n            hashSet.add(e);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1691422,
                "title": "c-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s;\\n        sort(nums1.begin() , nums1.end());\\n        sort(nums2.begin() , nums2.end());\\n        \\n        int i = 0 , j = 0;\\n        \\n        while (i < nums1.size() && j < nums2.size()){\\n            if(nums1[i] < nums2[j])\\n                i++;\\n            else if(nums1[i] > nums2[j])\\n                j++;\\n            else {\\n                s.insert(nums1[i]);\\n                i++;j++;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(auto a:s)ans.push_back(a);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s;\\n        sort(nums1.begin() , nums1.end());\\n        sort(nums2.begin() , nums2.end());\\n        \\n        int i = 0 , j = 0;\\n        \\n        while (i < nums1.size() && j < nums2.size()){\\n            if(nums1[i] < nums2[j])\\n                i++;\\n            else if(nums1[i] > nums2[j])\\n                j++;\\n            else {\\n                s.insert(nums1[i]);\\n                i++;j++;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(auto a:s)ans.push_back(a);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548147,
                "title": "c-100-faster",
                "content": "\\'\\'\\'\\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int> res;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0,j=0;\\n        while(i<nums1.size()&&j<nums2.size())\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                 if(count(res.begin(),res.end(),nums1[i])!=1)\\n                res.push_back(nums1[i]);\\n                \\n                i++;\\n                j++;\\n                \\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int> res;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0,j=0;\\n        while(i<nums1.size()&&j<nums2.size())\\n        {\\n            if(nums1[i]>nums2[j])\\n            {\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j])\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                 if(count(res.begin(),res.end(),nums1[i])!=1)\\n                res.push_back(nums1[i]);\\n                \\n                i++;\\n                j++;\\n                \\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1514376,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def binarySearch(self, nums, n, target):\\n        start = 0\\n        end = n - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid -1\\n        return False\\n    \\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        \\n        \\n        if n1 < n2:\\n            n1, n2 = n2, n1\\n            nums1, nums2 = nums2, nums1\\n        nums2.sort()\\n        \\n        output = set()\\n        for num in nums1:\\n            if self.binarySearch(nums2, n2, num):\\n                output.add(num)\\n        \\n        return output\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def binarySearch(self, nums, n, target):\\n        start = 0\\n        end = n - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return True\\n            elif nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid -1\\n        return False\\n    \\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        \\n        \\n        if n1 < n2:\\n            n1, n2 = n2, n1\\n            nums1, nums2 = nums2, nums1\\n        nums2.sort()\\n        \\n        output = set()\\n        for num in nums1:\\n            if self.binarySearch(nums2, n2, num):\\n                output.add(num)\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469254,
                "title": "simple-o-n-solution-in-c",
                "content": "```\\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false};\\n    for(int i = 0 ; i < nums1Size ; i++){\\n        visited[nums1[i]] = true;\\n    }\\n    for(int i = 0 ; i < nums2Size ; i++){\\n        if(visited[nums2[i]]){\\n            ans[pos++] = nums2[i];\\n            visited[nums2[i]] = false;\\n        }\\n    }\\n    *returnSize = pos;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    int* ans = (int*)malloc(sizeof(int)*1000);\\n    int pos = 0;\\n    bool visited[1001] = {false};\\n    for(int i = 0 ; i < nums1Size ; i++){\\n        visited[nums1[i]] = true;\\n    }\\n    for(int i = 0 ; i < nums2Size ; i++){\\n        if(visited[nums2[i]]){\\n            ans[pos++] = nums2[i];\\n            visited[nums2[i]] = false;\\n        }\\n    }\\n    *returnSize = pos;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432679,
                "title": "c-solution-faster-than-90",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        unordered_set <int> s1,s2;\\n        vector <int> res;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            s1.insert(nums1[i]);\\n        }\\n        \\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            s2.insert(nums2[i]);\\n        }\\n        \\n        for(auto i: s1)\\n        {\\n            if(s2.find(i)!=s2.end())\\n                res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        unordered_set <int> s1,s2;\\n        vector <int> res;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            s1.insert(nums1[i]);\\n        }\\n        \\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            s2.insert(nums2[i]);\\n        }\\n        \\n        for(auto i: s1)\\n        {\\n            if(s2.find(i)!=s2.end())\\n                res.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378750,
                "title": "sets-intersection-98-speed",
                "content": "![image](https://assets.leetcode.com/users/images/2ca4fd8c-0284-4bf9-b710-c99f3255e492_1627913701.8934853.png)\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return list(set(nums1) & set(nums2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366573,
                "title": "0ms-c-easy-100-faster",
                "content": "// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Intersection of Two Arrays.\\n```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n        while(i < nums1.size() && j < nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n\\t\\t//It is done to remove duplicate element from the ans vector\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        vector<int> ans;\\n        int i = 0, j = 0;\\n        while(i < nums1.size() && j < nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j]){\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n\\t\\t//It is done to remove duplicate element from the ans vector\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365505,
                "title": "simple-c-solution",
                "content": "```\\nint fill(int* rarr,int data,int k){\\n    int i=0;\\n    for(i=0;i<=k;++i){\\n        if(rarr[i]==data){\\n            return k;\\n        }\\n    }\\n    rarr[k]=data;\\n    k++;\\n    return k;\\n}\\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    \\n    int* rarr = (int *)malloc(sizeof(int*) * (nums1Size + nums2Size));\\n    int i=0,j=0,l1,l2,k=0;\\n   \\n        l1=nums1Size; \\n        l2=nums2Size;\\n\\n    for(i=0;i<l1;++i){\\n        for(j=0;j<l2;++j){\\n            if(nums1[i]==nums2[j]){\\n               k=fill(rarr,nums1[i],k);\\n                nums2[j]=-1;\\n            }\\n        }\\n        \\n    }\\n    *returnSize=k;\\n     return rarr;  \\n\\t \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint fill(int* rarr,int data,int k){\\n    int i=0;\\n    for(i=0;i<=k;++i){\\n        if(rarr[i]==data){\\n            return k;\\n        }\\n    }\\n    rarr[k]=data;\\n    k++;\\n    return k;\\n}\\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\\n    \\n    int* rarr = (int *)malloc(sizeof(int*) * (nums1Size + nums2Size));\\n    int i=0,j=0,l1,l2,k=0;\\n   \\n        l1=nums1Size; \\n        l2=nums2Size;\\n\\n    for(i=0;i<l1;++i){\\n        for(j=0;j<l2;++j){\\n            if(nums1[i]==nums2[j]){\\n               k=fill(rarr,nums1[i],k);\\n                nums2[j]=-1;\\n            }\\n        }\\n        \\n    }\\n    *returnSize=k;\\n     return rarr;  \\n\\t \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295660,
                "title": "c-time-92-space-96-hash-table",
                "content": "```\\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int hash[1001]={0};\\n        vector<int> ans;\\n        for(int i=0;i<nums1.size();i++){\\n            hash[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(hash[nums2[i]]){\\n                ans.push_back(nums2[i]);\\n                hash[nums2[i]]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int hash[1001]={0};\\n        vector<int> ans;\\n        for(int i=0;i<nums1.size();i++){\\n            hash[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(hash[nums2[i]]){\\n                ans.push_back(nums2[i]);\\n                hash[nums2[i]]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280299,
                "title": "c-solution-easy-runtime-0ms-faster-then-100-of-c-submissions",
                "content": "```\\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int h1[1005]={},h2[1005]={};\\n        vector<int>v;\\n        for(int i=0;i<nums1.size();i++){\\n            h1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            h2[nums2[i]]++;\\n        }\\n        for(int i=0;i<1005;i++){\\n            if(h1[i]&& h2[i]){\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }",
                "solutionTags": [],
                "code": "```\\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int h1[1005]={},h2[1005]={};\\n        vector<int>v;\\n        for(int i=0;i<nums1.size();i++){\\n            h1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            h2[nums2[i]]++;\\n        }\\n        for(int i=0;i<1005;i++){\\n            if(h1[i]&& h2[i]){\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1262587,
                "title": "simple-javascript-solution-faster-and-easy-intersection-of-two-arrays",
                "content": "```\\nvar intersection = function(nums1, nums2) {\\n\\n    var value = nums1.filter(x => nums2.includes(x)) // returns intersection of two arrays\\n    \\n    var remDuplicate  = [...new Set(value)]; //removes duplicates from array\\n\\n    return remDuplicate ;\\n};\\n```\\n\\n**Details:**\\n*Runtime: 92 ms, faster than 20.11% of JavaScript online submissions for Intersection of Two Arrays.\\nMemory Usage: 38.9 MB, less than 85.84% of JavaScript online submissions for Intersection of Two Arrays.*",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar intersection = function(nums1, nums2) {\\n\\n    var value = nums1.filter(x => nums2.includes(x)) // returns intersection of two arrays\\n    \\n    var remDuplicate  = [...new Set(value)]; //removes duplicates from array\\n\\n    return remDuplicate ;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258706,
                "title": "swift-5-one-line-solution",
                "content": "```\\nfunc intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\\n\\tArray(Set(nums1).intersection(Set(nums2)))\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\\n\\tArray(Set(nums1).intersection(Set(nums2)))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099397,
                "title": "java-solution-using-retainall-method-of-set-2-ms-solution",
                "content": "I created 2 `sets` for `nums1` and `nums2` and used the `retainAll()` method of `Set ` to calculate the intersection. \\n```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n   Set<Integer> s1 = new HashSet<>();\\n   Set<Integer> s2 = new HashSet<>();\\n   for (int i : nums1)\\n\\t\\ts1.add(i);\\n   for (int i : nums2)\\n\\t    s2.add(i);\\n   s1.retainAll(s2);\\n   int[] res = new int[s1.size()];\\n   int i = 0;\\n   Iterator<Integer> itr = s1.iterator();\\n   while (itr.hasNext())\\n\\t\\tres[i++] = itr.next();\\n   return res;\\n}\\n```\\nP.S. Do upvote if this is a simple solution. :)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\npublic int[] intersection(int[] nums1, int[] nums2) {\\n   Set<Integer> s1 = new HashSet<>();\\n   Set<Integer> s2 = new HashSet<>();\\n   for (int i : nums1)\\n\\t\\ts1.add(i);\\n   for (int i : nums2)\\n\\t    s2.add(i);\\n   s1.retainAll(s2);\\n   int[] res = new int[s1.size()];\\n   int i = 0;\\n   Iterator<Integer> itr = s1.iterator();\\n   while (itr.hasNext())\\n\\t\\tres[i++] = itr.next();\\n   return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 644318,
                "title": "python-two-solutions-for-the-facebook-follow-up-question",
                "content": "Thanks to @hasanseirafi: \\n\\n>This is a Facebook interview question. \\n>They ask for the intersection, which has a trivial solution using a hash or a set.\\n>\\n>Then they ask you to solve it under these constraints:\\nO(n) time and O(1) space (the resulting array of intersections is not taken into consideration).\\nYou are told the lists are sorted.\\n>\\n>Cases to take into consideration include:\\nduplicates, negative values, single value lists, 0\\'s, and empty list arguments.\\nOther considerations might include\\nsparse arrays. \"\\n\\n\\n```\\nclass Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums1 = sorted(nums1)\\n        nums2 = sorted(nums2)\\n        i, j = 0, 0\\n        rst = []\\n        \\n        # Follow-up: only record the last pair\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] == nums2[j]:\\n                while i + 1< len(nums1) and nums1[i] == nums1[i + 1]:\\n                    i += 1\\n                while j + 1< len(nums2) and nums2[j] == nums2[j + 1]:\\n                    j += 1  \\n                rst.append(nums1[i])\\n                i += 1\\n                j += 1\\n            elif nums1[i] > nums2[j]:\\n                j += 1\\n            else:\\n                i += 1\\n        return rst\\n        \\n        # Follow-up: only record the first pair\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] == nums2[j]:\\n                if (i == 0 and j == 0) or (i == 0 and nums2[j] != nums2[j - 1]) or (nums1[i] != nums1[i - 1] and j == 0) or (nums1[i] != nums1[i - 1] and nums2[j] != nums2[j - 1]):\\n                    rst.append(nums1[i])\\n                i += 1\\n                j += 1\\n            elif nums1[i] > nums2[j]:\\n                j += 1\\n            else:\\n                i += 1\\n        return rst\\n                \\n        # Original: 2 sets\\n        if len(nums1) < len(nums2):\\n            return self.intersection(nums2, nums1)\\n        rst, set2 = set(), set(nums2)\\n        for num in nums1:\\n            if num in set2:\\n                rst.add(num)\\n        return rst\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums1 = sorted(nums1)\\n        nums2 = sorted(nums2)\\n        i, j = 0, 0\\n        rst = []\\n        \\n        # Follow-up: only record the last pair\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] == nums2[j]:\\n                while i + 1< len(nums1) and nums1[i] == nums1[i + 1]:\\n                    i += 1\\n                while j + 1< len(nums2) and nums2[j] == nums2[j + 1]:\\n                    j += 1  \\n                rst.append(nums1[i])\\n                i += 1\\n                j += 1\\n            elif nums1[i] > nums2[j]:\\n                j += 1\\n            else:\\n                i += 1\\n        return rst\\n        \\n        # Follow-up: only record the first pair\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i] == nums2[j]:\\n                if (i == 0 and j == 0) or (i == 0 and nums2[j] != nums2[j - 1]) or (nums1[i] != nums1[i - 1] and j == 0) or (nums1[i] != nums1[i - 1] and nums2[j] != nums2[j - 1]):\\n                    rst.append(nums1[i])\\n                i += 1\\n                j += 1\\n            elif nums1[i] > nums2[j]:\\n                j += 1\\n            else:\\n                i += 1\\n        return rst\\n                \\n        # Original: 2 sets\\n        if len(nums1) < len(nums2):\\n            return self.intersection(nums2, nums1)\\n        rst, set2 = set(), set(nums2)\\n        for num in nums1:\\n            if num in set2:\\n                rst.add(num)\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514407,
                "title": "ruby-solution-with-explanation-24ms-faster-than-100-9-8mb-less-than-100",
                "content": "Although there are quite a few different ways to could tackle this kind of problem, trying to find a solution that\\'s `O(n)` time and space is a nice place to start.\\n\\nThe first thing to note: there **is** a very simple, built-in way to solve this problem in Ruby:\\n```ruby\\ndef intersection(nums1, nums2)\\n\\tnums1 & nums2\\nend\\n```\\nThis is cool shortcut to know, but how would go about solving this problem the \"old fashioned\" way - without using a built in helper?\\n\\nIn most problems that involve comparing values from one list to another list, converting one of them into a hash or `Set` will allow us to compare each individual value in `O(1)` time  - usually leading to a total time complexity of `O(n)` for the solution as we compare each item one time.\\n\\n```ruby\\ndef intersection(nums1, nums2)\\n  # Convert nums1 into a Set of unique values.\\n  # Because we touch each value of nums1,\\n  # this conversion is O(n) time.\\n  nums = nums1.reduce(Set.new) { |s,n| s.add(n) }\\n  \\n  # Create a second Set to store our resulting intersections.\\n  results = Set.new\\n  \\n  # Loop through nums2 comparing each value.\\n  # This loop is O(n) time, as it will\\n  # inspect each item in the second array.\\n  nums2.each do |n|\\n    # If our nums Set includes the value, add it to our results set.\\n\\t# Both `add` and `include?` are O(1) time operations.\\n    results.add(n) if nums.include?(n)\\n  end\\n  \\n  # Finally, return our results as an array.\\n  # to_a is an O(n) operation.\\n  results.to_a\\nend\\n```\\nThe total time and space complexity for this solution would be:\\n`O(n) + [O(n) * O(1)] + O(n)` ==> `3*O(n)` ==> `O(n)`",
                "solutionTags": [],
                "code": "```ruby\\ndef intersection(nums1, nums2)\\n\\tnums1 & nums2\\nend\\n```\n```ruby\\ndef intersection(nums1, nums2)\\n  # Convert nums1 into a Set of unique values.\\n  # Because we touch each value of nums1,\\n  # this conversion is O(n) time.\\n  nums = nums1.reduce(Set.new) { |s,n| s.add(n) }\\n  \\n  # Create a second Set to store our resulting intersections.\\n  results = Set.new\\n  \\n  # Loop through nums2 comparing each value.\\n  # This loop is O(n) time, as it will\\n  # inspect each item in the second array.\\n  nums2.each do |n|\\n    # If our nums Set includes the value, add it to our results set.\\n\\t# Both `add` and `include?` are O(1) time operations.\\n    results.add(n) if nums.include?(n)\\n  end\\n  \\n  # Finally, return our results as an array.\\n  # to_a is an O(n) operation.\\n  results.to_a\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 404566,
                "title": "readable-javascript-solution-set",
                "content": "\\n```\\n/**\\n * \\n * Runtime: 56 ms, faster than 78.32% of JavaScript online submissions for Intersection of Two Arrays.\\n * Memory Usage: 34.1 MB, less than 92.31% of JavaScript online submissions for Intersection of Two Arrays. \\n */\\n\\nvar intersection = function (nums1, nums2) {\\n    // grab the intersection between both arrays\\n    let solution = nums1.filter(num => nums2.includes(num))\\n\\n    // then pass that value into a set since sets return unique values\\n    const res = new Set(solution)\\n\\n    // spread the object to cast the value into an array\\n    return [...res]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * \\n * Runtime: 56 ms, faster than 78.32% of JavaScript online submissions for Intersection of Two Arrays.\\n * Memory Usage: 34.1 MB, less than 92.31% of JavaScript online submissions for Intersection of Two Arrays. \\n */\\n\\nvar intersection = function (nums1, nums2) {\\n    // grab the intersection between both arrays\\n    let solution = nums1.filter(num => nums2.includes(num))\\n\\n    // then pass that value into a set since sets return unique values\\n    const res = new Set(solution)\\n\\n    // spread the object to cast the value into an array\\n    return [...res]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398921,
                "title": "c-simplest-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> st;\\n        \\n        vector<int> res;\\n        \\n        for(int x:nums1)\\n            st.insert(x);\\n        \\n        for(int x:nums2)\\n            if(st.find(x) != st.end()){\\n                res.push_back(x);\\n                st.erase(x);\\n            }\\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> st;\\n        \\n        vector<int> res;\\n        \\n        for(int x:nums1)\\n            st.insert(x);\\n        \\n        for(int x:nums2)\\n            if(st.find(x) != st.end()){\\n                res.push_back(x);\\n                st.erase(x);\\n            }\\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377992,
                "title": "python-3-one-liner",
                "content": "Python has a set class with all common set operations, so just used that. \\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return set(nums1) & set(nums2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return set(nums1) & set(nums2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374613,
                "title": "4ms-easy-c-solution-no-extra-space",
                "content": "Runtime: 4 ms, faster than 99.34% of C++ online submissions for Intersection of Two Arrays.\\nMemory Usage: 9 MB, less than 93.33% of C++ online submissions for Intersection of Two Arrays.\\n\\n```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int> res;\\n        if(nums1.empty() || nums2.empty())\\n            return res;\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i < nums1.size() && j < nums2.size())\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                res.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n        \\n        vector<int> :: iterator it = res.begin();\\n        while(it != res.end() && it != res.end()-1)\\n        {\\n            if(*it == *(it+1))\\n                res.erase(it+1);\\n            else\\n                it++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 4 ms, faster than 99.34% of C++ online submissions for Intersection of Two Arrays.\\nMemory Usage: 9 MB, less than 93.33% of C++ online submissions for Intersection of Two Arrays.\\n\\n```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int> res;\\n        if(nums1.empty() || nums2.empty())\\n            return res;\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i < nums1.size() && j < nums2.size())\\n        {\\n            if(nums1[i] == nums2[j])\\n            {\\n                res.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i] < nums2[j])\\n                i++;\\n            else\\n                j++;\\n        }\\n        \\n        vector<int> :: iterator it = res.begin();\\n        while(it != res.end() && it != res.end()-1)\\n        {\\n            if(*it == *(it+1))\\n                res.erase(it+1);\\n            else\\n                it++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 269005,
                "title": "c-3-lines-hash-set-and",
                "content": "# Hashset Solution\\nUsing two hashsets to cross-check the common elements.\\n```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n  unordered_set<int> s1(begin(nums1), end(nums1)), s2;\\n  for (auto n : nums2) if (s1.count(n)) s2.insert(n);\\n  return vector<int>(begin(s2), end(s2));\\n}\\n```\\n## Complexity Analysis\\nRuntime: *O(n + m)*, where n and m are the vector sizes.\\nMemory: *O(n + m)*\\n# set_intersection Solution\\nUsing a library functions for sorted sets.\\n```\\nvector<int> intersection(vector<int>& n1, vector<int>& n2, vector<int> res = {}) {\\n  set<int> s1(begin(n1), end(n1)), s2(begin(n2), end(n2));\\n  set_intersection(begin(s1), end(s1), begin(s2), end(s2), inserter(res, begin(res)));\\n  return res;\\n}\\n```\\n## Complexity Analysis\\nRuntime: *O((n + m) log (n + m))*, where n and m are the vector sizes.\\nMemory: *O(n + m)*",
                "solutionTags": [],
                "code": "```\\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n  unordered_set<int> s1(begin(nums1), end(nums1)), s2;\\n  for (auto n : nums2) if (s1.count(n)) s2.insert(n);\\n  return vector<int>(begin(s2), end(s2));\\n}\\n```\n```\\nvector<int> intersection(vector<int>& n1, vector<int>& n2, vector<int> res = {}) {\\n  set<int> s1(begin(n1), end(n1)), s2(begin(n2), end(n2));\\n  set_intersection(begin(s1), end(s1), begin(s2), end(s2), inserter(res, begin(res)));\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 232127,
                "title": "python-runtime-20-ms-faster-than-100-00-not-using-built-in-functions-like-set",
                "content": "```\\nclass Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        cache = set()\\n        for e in nums1:\\n            if e not in cache:\\n                cache.add(e)\\n        for e in nums2:\\n            if e in cache:\\n                res.append(e)\\n                cache.remove(e)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def intersection(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        cache = set()\\n        for e in nums1:\\n            if e not in cache:\\n                cache.add(e)\\n        for e in nums2:\\n            if e in cache:\\n                res.append(e)\\n                cache.remove(e)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81976,
                "title": "swift-3-three-solutions",
                "content": "```\\nclass Solution {\\n    // hashset method, O(n) time and O(n) space\\n    func intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\\n        var set = Set<Int>()\\n        var result = [Int]()\\n        for num in nums1 {\\n            set.insert(num)\\n        }\\n        for num in nums2 {\\n            if set.contains(num) {\\n                result.append(num)\\n                set.remove(num)\\n            }\\n        }\\n        return result\\n    }\\n    \\n    \\n    \\n    // binary search O(nlogn) time and use Hashset O(n)\\n    func intersection2(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\\n        if nums1.isEmpty || nums2.isEmpty {\\n            return [Int]()\\n        }\\n        let arr1 = nums1.sorted()\\n        var ans = Set<Int>()\\n        for num in nums2 {\\n            if search(arr1, num, 0, arr1.count - 1) {\\n                ans.insert(num)\\n            }\\n        }\\n        return Array(ans)\\n    }\\n    \\n    func search(_ nums1: [Int], _ t: Int, _ left: Int, _ right: Int) -> Bool {\\n        var l = left, r = right\\n        while l < r {\\n            let mid = (l + r) / 2\\n            if nums1[mid] == t {\\n                return true\\n            } else if nums1[mid] < t {\\n                l = mid + 1\\n            } else {\\n                r = mid\\n            }\\n        }\\n        return nums1[l] == t\\n    }\\n    \\n    \\n    \\n    \\n    \\n    // sorted and two pointers method, O(nlogn) time and O(1)space\\n    func intersection1(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\\n        let arr1 = nums1.sorted()\\n        let arr2 = nums2.sorted()\\n        var ans = [Int]()\\n        var p1 = 0, p2 = 0\\n        while p1 < arr1.count && p2 < arr2.count {\\n            while p1 + 1 < arr1.count && arr1[p1] == arr1[p1 + 1] {\\n                p1 += 1\\n            }\\n            while p2 + 1 < arr2.count && arr2[p2] == arr2[p2 + 1] {\\n                p2 += 1\\n            }\\n            if arr1[p1] == arr2[p2] {\\n                ans.append(arr1[p1])\\n                p1 += 1\\n                p2 += 1\\n            } else if arr1[p1] < arr2[p2] {\\n                p1 += 1\\n            } else {\\n                p2 += 1\\n            }\\n        }\\n        return ans\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // hashset method, O(n) time and O(n) space\\n    func intersection(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\\n        var set = Set<Int>()\\n        var result = [Int]()\\n        for num in nums1 {\\n            set.insert(num)\\n        }\\n        for num in nums2 {\\n            if set.contains(num) {\\n                result.append(num)\\n                set.remove(num)\\n            }\\n        }\\n        return result\\n    }\\n    \\n    \\n    \\n    // binary search O(nlogn) time and use Hashset O(n)\\n    func intersection2(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\\n        if nums1.isEmpty || nums2.isEmpty {\\n            return [Int]()\\n        }\\n        let arr1 = nums1.sorted()\\n        var ans = Set<Int>()\\n        for num in nums2 {\\n            if search(arr1, num, 0, arr1.count - 1) {\\n                ans.insert(num)\\n            }\\n        }\\n        return Array(ans)\\n    }\\n    \\n    func search(_ nums1: [Int], _ t: Int, _ left: Int, _ right: Int) -> Bool {\\n        var l = left, r = right\\n        while l < r {\\n            let mid = (l + r) / 2\\n            if nums1[mid] == t {\\n                return true\\n            } else if nums1[mid] < t {\\n                l = mid + 1\\n            } else {\\n                r = mid\\n            }\\n        }\\n        return nums1[l] == t\\n    }\\n    \\n    \\n    \\n    \\n    \\n    // sorted and two pointers method, O(nlogn) time and O(1)space\\n    func intersection1(_ nums1: [Int], _ nums2: [Int]) -> [Int] {\\n        let arr1 = nums1.sorted()\\n        let arr2 = nums2.sorted()\\n        var ans = [Int]()\\n        var p1 = 0, p2 = 0\\n        while p1 < arr1.count && p2 < arr2.count {\\n            while p1 + 1 < arr1.count && arr1[p1] == arr1[p1 + 1] {\\n                p1 += 1\\n            }\\n            while p2 + 1 < arr2.count && arr2[p2] == arr2[p2 + 1] {\\n                p2 += 1\\n            }\\n            if arr1[p1] == arr2[p2] {\\n                ans.append(arr1[p1])\\n                p1 += 1\\n                p2 += 1\\n            } else if arr1[p1] < arr2[p2] {\\n                p1 += 1\\n            } else {\\n                p2 += 1\\n            }\\n        }\\n        return ans\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564942,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1573115,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1565482,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1751682,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1576232,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1569375,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1811921,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1796112,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1572321,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1811868,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1564942,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1573115,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1565482,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1751682,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1576232,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1569375,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1811921,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1796112,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1572321,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1811868,
                "content": [
                    {
                        "username": "d40a",
                        "content": "What intersection of arrays means?"
                    },
                    {
                        "username": "bitwisedhruv",
                        "content": "Bro it is just like intersection of two sets(from set theory)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "Ayush379",
                        "content": "Intersection means value present in both array, similarly union means present in any array"
                    },
                    {
                        "username": "sharma_kunal",
                        "content": "I really don\\'t understand how this problem is tagged under `binary search`. Can someone please explain that ?"
                    },
                    {
                        "username": "__ranjanritik",
                        "content": "if you are sorting the array then itself u are increasing time complexity to nlogn , what the use of using binary search afterwards"
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "[@Ayush379](/Ayush379) memory limit exceed ye show ho rha pta nhi kyo\\n"
                    },
                    {
                        "username": "Ayush379",
                        "content": "sort one array, find the value of other array using binary search.\n This reduces the time complexity of searching."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def intersection(nums1, nums2)\\n      nums1 & nums2\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9 Easy C++ FAANG \\uD83D\\uDE2C Code \\n\\nhttps://leetcode.com/problems/intersection-of-two-arrays/solutions/2345995/easy-c-faang-code/"
                    },
                    {
                        "username": "princerajcoder",
                        "content": "time:-o(nlogn)\\n\\n//By using two pointer approach...\\nsort(nums1.begin(),nums1.end());\\n       sort(nums2.begin(),nums2.end());\\n\\n        vector<int>ans;\\n        unordered_set<int> s;\\n       int i=0;\\n       int j=0;\\n\\n            while(i<nums1.size() && j<nums2.size()){\\n        if(nums1[i]==nums2[j]){\\n            s.insert(nums1[i]);\\n           i++;\\n           j++;\\n         }\\n         else if(nums1[i]<nums2[j]){\\n         i++;\\n        }\\n        else if(nums1[i]>nums2[j]){\\n        j++;\\n        }\\n       }\\n              for(auto it : s){\\n           ans.push_back(it);\\n       }\\n      return ans;"
                    },
                    {
                        "username": "rabbit2020",
                        "content": "return list(set(nums1) & set(nums2))"
                    },
                    {
                        "username": "redner",
                        "content": "I dont get the meaning of \"intersect\", are we locking for the minimal common sub-array?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better. "
                    },
                    {
                        "username": "ranjeet08kumar",
                        "content": "[@ManishChauhan11175](/ManishChauhan11175) common element which ara lie in the both array\\n"
                    },
                    {
                        "username": "ManishChauhan11175",
                        "content": "unique common digit which lies in both arrays\\n"
                    },
                    {
                        "username": "Harsh1125singh",
                        "content": "how to solve this question without using sorting hashing and vector or any other method."
                    },
                    {
                        "username": "hashcoderz",
                        "content": "```\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        boolean seen[] = new boolean[1001];\n        for(int i : nums1){\n            seen[i] = true;\n        }\n        int result[] = new int[nums2.length];\n        int idx = 0;\n        for(int i : nums2){\n            if(seen[i] == true){\n                result[idx++] = i;\n                seen[i] = false;\n            }\n        }\n        System.gc();\n        return Arrays.copyOf(result,idx);\n    }\n}\n```"
                    },
                    {
                        "username": "Vigneshwaran1009",
                        "content": "import java.util.Arrays;\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n\\n        int[] result = new int[Math.min(nums1.length, nums2.length)];\\n        int index = 0;\\n        int i = 0, j = 0;\\n\\n        while (i < nums1.length && j < nums2.length) {\\n            if (nums1[i] < nums2[j]) {\\n                i++;\\n            } else if (nums1[i] > nums2[j]) {\\n                j++;\\n            } else {\\n                if (index == 0 || nums1[i] != result[index - 1]) {\\n                    result[index++] = nums1[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n}\\n"
                    },
                    {
                        "username": "JoeRogan",
                        "content": "This problem is more so \"contains\" then \"intersection\""
                    },
                    {
                        "username": "XiaoxuanWang",
                        "content": "\\t\\'\\'\\'\\n\\tdef intersection(self, nums1, nums2):\\n        \\n\\t\\treturn list(set(nums1).intersection(set(nums2)))\\n\\t\\n\\t\\'\\'\\'"
                    },
                    {
                        "username": "ZaidKhan2002",
                        "content": "What should I return in the code:\n\n`` int i = 0;\n        int j = 0;\n\n        while (i < nums1.length && j < nums2.length){\n//            For handling duplicates\n            if (i > 0 && nums1[i] == nums1[i-1]){\n                i++;\n                continue;\n            }\n//\n            if (nums1[i] == nums2[j]){\n                i++;\n                j++;\n            }else if (nums1[i] > nums2[j]){\n                j++;\n            }else if (nums1[i] < nums2[j]){\n                i++;\n            }\n        }`\n       `"
                    },
                    {
                        "username": "Kunwar24",
                        "content": "store ans in vector and return that"
                    }
                ]
            },
            {
                "id": 1758367,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 1571622,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 2069364,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 2059994,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 2032744,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 1975094,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 1940084,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 1940064,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 1939194,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 1933237,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "Can I solve this problem using HashSet?"
                    },
                    {
                        "username": "Dipanshi_26",
                        "content": "[@lucascostaval](/lucascostaval) In which form you returned the result. As they are asking to return array but we have to take an arrayList because we don\\'t know about the size of resultant array. I am unable to convert the arrayList into array.."
                    },
                    {
                        "username": "lucascostaval",
                        "content": "You can!! That\\'s how I did It"
                    },
                    {
                        "username": "whoosh",
                        "content": "public static int[] intersection(int[] nums1, int[] nums2) {\\n return IntStream.of(nums2).distinct().filter(IntStream.of(nums1).boxed().collect(Collectors.toSet())::contains).toArray();\\n}\\n\\nOfc i can do it faster as all xD but it's not funny cuz problem is soooo easy ;)"
                    },
                    {
                        "username": "swayamrustagi22",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        int i = 0;\\n        int j = 0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        vector<int> ans;\\n        while(i<n && j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }else if(nums2[j]<nums1[i]){\\n                j++;\\n            }else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nWhy is it not running?"
                    },
                    {
                        "username": "user7544uv",
                        "content": "      class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> nums3=new HashSet<>();\\n       \\n        \\n        for(int i=0;i<nums1.length;i++)\\n        {\\n           for(int j=0;j<nums2.length;j++)\\n           {\\n               if(nums1[i]==nums2[j])\\n               {\\n                   nums3.add(nums1[i]);\\n               }\\n           }\\n        }\\n      int [] nums4=new int[nums3.size()];\\n      int i=0;\\n       for(int ele:nums3)\\n       nums4[i++]=ele;\\n       \\n   return nums4;\\n          }\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "why question name is intersection of array?"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "TC: O(N)  {Simple 3 for loops}\\nSC: O(N)  {used 2 Hashset}\\n\\nCode:\\n\\nclass Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set = new HashSet<>();\\n        HashSet<Integer> ans = new HashSet<>();\\n        for(int i=0; i<nums1.length; i++){\\n            if(!set.contains(nums1[i]))\\n                set.add(nums1[i]);\\n        }\\n        for(int i=0; i<nums2.length; i++){\\n            if(set.contains(nums2[i]))\\n                ans.add(nums2[i]);\\n        }\\n        int[] res = new int[ans.size()];\\n        int j = 0;\\n        for(Integer i : ans){\\n            res[j++] = i;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "HanArima",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> result;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int i=0;\\n        int j=0;\\n\\n        while(i<n && j<m){\\n            if(nums1[i]==nums2[j]){\\n                result.push_back(result[i]);\\n                i++;\\n                j++;\\n            }else if(nums1[i]<nums2[j]){\\n                i++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nCan somebody please help me. What is wrong with my code. I am getting the following error:\\nRUNTIME ERROR\\nLine 1034: Char 34: runtime error: applying non-zero offset 8 to null pointer (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "user4516ne",
                        "content": "when you are checking equal condition and pushing it into result you should write `result.push_back(nums1[i]);` because you want nums1 element to stored in result right. Also you need only unique element hence you need to add that part."
                    },
                    {
                        "username": "hali1",
                        "content": "the issue is with your i variable. the condition of i < n is never getting satisfied resulting in infinite loop"
                    },
                    {
                        "username": "HanArima",
                        "content": "What does it actually mean when it says time limit exceeded? How do I deal with it?"
                    },
                    {
                        "username": "hali1",
                        "content": "it could be because of many factors like infinite loop or very inefficient algorithm. make sure your loops end and use more efficient algorithms "
                    },
                    {
                        "username": "AKSHAY_GOLE",
                        "content": "Hi,\nI want to understand the time complexity of my code. I think its O(n) because using single for loop. \nPlease correct me if I am wrong.\nThanks in advance.\n\n    def intersection(self, nums1, nums2):\n        dict_nums1 = Counter(nums1)\n        dict_nums2 = Counter(nums2)\n        result = []\n        if len(dict_nums1) > len(dict_nums2):\n            for i in dict_nums2:\n                if dict_nums1.get(i, 0):\n                    result.append(i)\n        else:\n            for i in dict_nums1:\n                if dict_nums2.get(i, 0):\n                    result.append(i)\n\n        return result\n"
                    },
                    {
                        "username": "mayanknichlani",
                        "content": "How do I return more than one integer using the return keyword,even if I find a way to do it using Binary Search"
                    },
                    {
                        "username": "Naman_Paliwal",
                        "content": "ex:\\nreturn { a,b};   \\nlike this you can do it.\\n"
                    }
                ]
            },
            {
                "id": 1862022,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1852747,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1808622,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1804500,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1800601,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1791474,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1786686,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1784874,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1772130,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1769795,
                "content": [
                    {
                        "username": "christianovianto",
                        "content": "return [2][2] is unique? i dont get it man"
                    },
                    {
                        "username": "ssg_zth",
                        "content": "why does this code gives TLE\n vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n         sort(nums1.begin(),nums1.end());\n        vector<int> v;\n       \n       ` int i=0;\n        int j=0;\n        int n=nums1.size();\n        int m=nums2.size();\n        while(i<n &&j<m){\n            if(nums1[i]==nums2[j]){\n               if(nums1[i]!=nums1[i-1]){\n                v.push_back(nums1[i]);\n                i++;\n                j++;\n                }\n            }\n            else if(nums1[i]<nums2[j]){\n                i++;\n                \n            }\n            else if(nums1[i]>nums2[j]){\n                j++;\n               \n            }\n        }\n        return v;\n    }`\n\n"
                    },
                    {
                        "username": "NithinShetty",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        set<int> tempAns;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n\\n        int i=0, j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i] == nums2[j]){\\n                tempAns.insert(nums1[i]);\\n                i++, j++;\\n            }\\n            else if(nums1[i] < nums2[j]) i++;\\n            else j++;\\n        }\\n\\n        for(auto s : tempAns){\\n            ans.push_back(s);\\n        }\\n\\n        return ans;\\n    }\\n};```"
                    },
                    {
                        "username": "Amogh010",
                        "content": "hwhats wrong in this?\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n\\n        int n;\\n        int m;\\n        vector<int> ans;\\n        for(int i =0;i<n;i++)\\n        {\\n            int element = nums1[i];\\n            for(int j=0;j<m;j++){\\n                if(element==nums2[j])\\n                {\\n                    ans.push_back(element);\\n                    nums2[j]=0;\\n\\n                    break;\\n\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "kadyanparag",
                        "content": "int n = nums1.size(); and same with m"
                    },
                    {
                        "username": "sxmpath123",
                        "content": "class Solution(object):\\n    def intersection(self, nums1, nums2):\\n       obj = set(nums1)\\n       obj1 = set(nums2)\\n       c = obj.intersection(obj1)\\n       return c"
                    },
                    {
                        "username": "rathorerohit511",
                        "content": " `your inline code...your inline code...`\\nhttps://leetcode.com/problems/intersection-of-two-arrays/submissions/893092698/"
                    },
                    {
                        "username": "saurabhskukreja",
                        "content": "why is the output of [1,2,2,1] and [2,2] is [2].\nIf its intersection ( common in both arrays ) --> Shouldn't it be [2,2]"
                    },
                    {
                        "username": "harshshukla9792",
                        "content": "[@amit8810](/amit8810)  simply if u find that no alter the loop assing all that no to intmin. push nums1 value to new vector . during intersection repeated elemnt are not allowed.\nif u are not able to figure it out then reach me out Harsh shukla#3135 discord id\n"
                    },
                    {
                        "username": "amit8810",
                        "content": "I\\'m also stuck on this , did u find any solution to resolve this ?\\n"
                    },
                    {
                        "username": "rafiul29",
                        "content": "# js  Code\\n```\\nvar intersection = function(nums1, nums2) {\\n    let num1=[...new Set([...nums1])]\\n    let num2=[...new Set([...nums2])]\\nlet unique=[]\\n    for(let i=0; i<num1.length;i++){\\n        for(let j=0; j<num2.length;j++){\\n            if(num1[i]===num2[j]){\\n        unique.push(num1[i])\\n            }\\n        }\\n    }\\n    return unique\\n};\\n\\n```"
                    },
                    {
                        "username": "mayank__7",
                        "content": "I AM GETTING TLE ERROR CAN SOMEONE HELP ME OUT IN THIS :{\\n\\n\\n\\nvector<int> ans ;\\n        for (int i = 0; i < nums1.size() ; i++)\\n        {\\n            for (int a = 0; a < nums2.size() ; a++)\\n            {\\n                if (nums1[i] == nums2[a])\\n                {\\n                    ans.push_back(nums1[i]) ;\\n                    break; \\n                }\\n            }\\n        }\\n    for (int i = 0; i < ans.size()-1 ; i++)\\n    {\\n        for (int a = i+1 ; a < ans.size() ; a++)\\n        {\\n            if (ans[i] == ans[a])\\n            {\\n                ans.erase(ans.begin()+a);\\n            }\\n        }\\n    }\\n    return ans;"
                    },
                    {
                        "username": "lucascostaval",
                        "content": "Hi, the problem here is that your solution has complexity O(n*m), where n is the length of the first array and m is the length of the second array. This happens because you are using a for loop INSIDE of another for loop, which is very slow, and that\\'s why Its giving you TLE (Timit Limit Exceeded).\\n\\nYou have to make a faster solution, that is, a solution that doesn\\'t envolve loops inside each other.\\n\\nFeel free to ask me if you have doubts or want a hint :)  Good coding!!"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1766828,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1759622,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1743039,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1741286,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1733560,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1719246,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1718522,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1718185,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1715542,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            },
            {
                "id": 1715334,
                "content": [
                    {
                        "username": "Deepak_8811",
                        "content": "        int n=nums1.size();\\n        int m=nums2.size();\\n        vector<int>ans;\\n        set<int>set;\\n        int i=0,j=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        while(i<n&&j<m){\\n            if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            else{\\n                set.insert(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(auto x:set){\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "prathameshpawar28788",
                        "content": "why you didn't directly push_back to vector ans instead  inserting in set\n.... 😅 sory it also counts duplicates "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "sujaltangde",
                        "content": "vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s ;\\n        int n = nums1.size() ;\\n        int m = nums2.size() ;\\n\\n        for(int i=0 ; i < n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(nums1[i]==nums2[j]){\\n                    s.insert(nums1[i]) ;\\n                    break ;\\n                }\\n            }\\n        }\\n       vector<int> inter(s.begin(),s.end()) ;\\n        return inter ;\\n    }"
                    },
                    {
                        "username": "sk0884518",
                        "content": "class Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i]==nums2[j]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i]<nums2[j]){\\n                i++;\\n            }\\n            else if(nums1[i]>nums2[j]){\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\nhelp me with some accuracy"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Rupesh_Gupta_1909",
                        "content": "Here intersection basically means those numbers which is present in both nums1 and nums2."
                    },
                    {
                        "username": "denismj87",
                        "content": "Would be good to clearly state what is intersection means in this problem."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "Elements present in both the arrays if they are occurring twice make sure to print it once. You can google Venn diagrams that will help you to understand the concept much better."
                    },
                    {
                        "username": "Vedantaz",
                        "content": "terminate called after throwing an instance of \\'std::length_error\\'\\n  what():  vector::_M_range_insert\\n\\nwhy actually this error is coming ? "
                    },
                    {
                        "username": "ikiran001",
                        "content": "class Solution {\\n    public int[] intersection(int[] nums1, int[] nums2) {\\n        \\n\\n\\t\\tList<Integer> list=new ArrayList<>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor (int j = 0; j < nums2.length; j++) {\\n\\t\\t\\t\\tif(list.contains(nums1[i])) {break;}\\n\\t\\t\\t\\tif(nums1[i]==nums2[j]) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tlist.add(nums1[i]);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] arr=new int[list.size()];\\n\\t\\tfor (int i = 0; i < list.size(); i++) {\\n\\t\\t\\tarr[i]=list.get(i);\\n\\t\\t}      \\n\\t\\treturn arr;\\n\\t\\n    }\\n}"
                    },
                    {
                        "username": "Arjun118",
                        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        vector<int> in(1005,0);\\n        for(int i=0;i<n1;i++)\\n        {\\n            \\n            int k=nums1[i];\\n            if(in[k]==0)\\n            {\\n                \\n                int flag=0;\\n                int l=0;\\n                int h=n2-1;\\n                while(l<=h)\\n                {\\n                    int m=l+(h-l)/2;\\n                    if(nums2[m]==k)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    else if(nums2[m]>k)\\n                    {\\n                        h=m-1;\\n                    }\\n                    else\\n                    {\\n                        l=m+1;\\n                    }\\n                }\\n                if(flag==1)\\n                {\\n                    ans.push_back(k);\\n                    in[k]=1;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nbinary search implementation\\n\\nthe vector \"in\" is used to keep track of the elements that are already present the vector"
                    }
                ]
            }
        ]
    },
    {
        "title": "Serialize and Deserialize BST",
        "question_content": "<p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n\n<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>\n\n<p><b>The encoded string should be as compact as possible.</b></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,1,3]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 177617,
                "title": "the-general-solution-for-serialize-and-deserialize-bst-and-serialize-and-deserialize-bt",
                "content": "### BST\\nuse  upper and lower boundaries to check whether we should add `null`\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val).append(\",\");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.isEmpty()) return null;\\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\\n        return deserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    public TreeNode deserialize(Queue<String> q, int lower, int upper) {\\n        if (q.isEmpty()) return null;\\n        String s = q.peek();\\n        int val = Integer.parseInt(s);\\n        if (val < lower || val > upper) return null;\\n        q.poll();\\n        TreeNode root = new TreeNode(val);\\n        root.left = deserialize(q, lower, val);\\n        root.right = deserialize(q, val, upper);\\n        return root;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\\n\\n### Binary Tree\\nuse `#` whether we should add `null`\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            sb.append(\"#\").append(\",\");\\n        } else {\\n            sb.append(root.val).append(\",\");\\n            serialize(root.left, sb);\\n            serialize(root.right, sb);\\n        }\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\\n        return deserialize(q);\\n    }\\n    \\n    public TreeNode deserialize(Queue<String> q) {\\n        String s = q.poll();\\n        if (s.equals(\"#\")) return null;\\n        TreeNode root = new TreeNode(Integer.parseInt(s));\\n        root.left = deserialize(q);\\n        root.right = deserialize(q);\\n        return root;\\n    }\\n    \\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val).append(\",\");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.isEmpty()) return null;\\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\\n        return deserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    public TreeNode deserialize(Queue<String> q, int lower, int upper) {\\n        if (q.isEmpty()) return null;\\n        String s = q.peek();\\n        int val = Integer.parseInt(s);\\n        if (val < lower || val > upper) return null;\\n        q.poll();\\n        TreeNode root = new TreeNode(val);\\n        root.left = deserialize(q, lower, val);\\n        root.right = deserialize(q, val, upper);\\n        return root;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            sb.append(\"#\").append(\",\");\\n        } else {\\n            sb.append(root.val).append(\",\");\\n            serialize(root.left, sb);\\n            serialize(root.right, sb);\\n        }\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\\n        return deserialize(q);\\n    }\\n    \\n    public TreeNode deserialize(Queue<String> q) {\\n        String s = q.poll();\\n        if (s.equals(\"#\")) return null;\\n        TreeNode root = new TreeNode(Integer.parseInt(s));\\n        root.left = deserialize(q);\\n        root.right = deserialize(q);\\n        return root;\\n    }\\n    \\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93171,
                "title": "python-o-n-solution-easy-to-understand",
                "content": "EDIT: Thanks to @WKVictor , this solution uses 'deque' instead of 'list' as queue. And the performance is O( N )\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return ' '.join(map(str, vals))\\n\\n    # O( N ) since each val run build once\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(float('-infinity'), float('infinity'))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return ' '.join(map(str, vals))\\n\\n    # O( N ) since each val run build once\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(float('-infinity'), float('infinity'))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93175,
                "title": "java-preorder-queue-solution",
                "content": "Hi all, I think my solution is pretty straightforward and easy to understand, not that efficient though. And the serialized tree is compact.\\nPre order traversal of BST will output root node first, then left children, then right.\\n```\\nroot left1 left2 leftX right1 rightX\\n```\\nIf we look at the value of the pre-order traversal we get this:\\n```\\nrootValue (<rootValue) (<rootValue) (<rootValue) |separate line| (>rootValue) (>rootValue)\\n```\\nBecause of BST's property: before the |separate line| all the node values are **less than root value**, all the node values after |separate line| are **greater than root value**. We will utilize this to build left and right tree.\\n\\nPre-order traversal is BST's serialized string. I am doing it iteratively.\\nTo deserialized it, use a queue to recursively get root node, left subtree and right subtree.\\n\\n\\nI think time complexity is O(NlogN).\\nErrr, my bad, as @ray050899 put below, worst case complexity should be O(N^2), when the tree is really unbalanced. \\n\\n\\nMy implementation\\n```\\npublic class Codec {\\n    private static final String SEP = \",\";\\n    private static final String NULL = \"null\";\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return NULL;\\n        //traverse it recursively if you want to, I am doing it iteratively here\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while (!st.empty()) {\\n            root = st.pop();\\n            sb.append(root.val).append(SEP);\\n            if (root.right != null) st.push(root.right);\\n            if (root.left != null) st.push(root.left);\\n        }\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    // pre-order traversal\\n    public TreeNode deserialize(String data) {\\n        if (data.equals(NULL)) return null;\\n        String[] strs = data.split(SEP);\\n        Queue<Integer> q = new LinkedList<>();\\n        for (String e : strs) {\\n            q.offer(Integer.parseInt(e));\\n        }\\n        return getNode(q);\\n    }\\n    \\n    // some notes:\\n    //   5\\n    //  3 6\\n    // 2   7\\n    private TreeNode getNode(Queue<Integer> q) { //q: 5,3,2,6,7\\n        if (q.isEmpty()) return null;\\n        TreeNode root = new TreeNode(q.poll());//root (5)\\n        Queue<Integer> samllerQueue = new LinkedList<>();\\n        while (!q.isEmpty() && q.peek() < root.val) {\\n            samllerQueue.offer(q.poll());\\n        }\\n        //smallerQueue : 3,2   storing elements smaller than 5 (root)\\n        root.left = getNode(samllerQueue);\\n        //q: 6,7   storing elements bigger than 5 (root)\\n        root.right = getNode(q);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nroot left1 left2 leftX right1 rightX\\n```\n```\\nrootValue (<rootValue) (<rootValue) (<rootValue) |separate line| (>rootValue) (>rootValue)\\n```\n```\\npublic class Codec {\\n    private static final String SEP = \",\";\\n    private static final String NULL = \"null\";\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return NULL;\\n        //traverse it recursively if you want to, I am doing it iteratively here\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while (!st.empty()) {\\n            root = st.pop();\\n            sb.append(root.val).append(SEP);\\n            if (root.right != null) st.push(root.right);\\n            if (root.left != null) st.push(root.left);\\n        }\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    // pre-order traversal\\n    public TreeNode deserialize(String data) {\\n        if (data.equals(NULL)) return null;\\n        String[] strs = data.split(SEP);\\n        Queue<Integer> q = new LinkedList<>();\\n        for (String e : strs) {\\n            q.offer(Integer.parseInt(e));\\n        }\\n        return getNode(q);\\n    }\\n    \\n    // some notes:\\n    //   5\\n    //  3 6\\n    // 2   7\\n    private TreeNode getNode(Queue<Integer> q) { //q: 5,3,2,6,7\\n        if (q.isEmpty()) return null;\\n        TreeNode root = new TreeNode(q.poll());//root (5)\\n        Queue<Integer> samllerQueue = new LinkedList<>();\\n        while (!q.isEmpty() && q.peek() < root.val) {\\n            samllerQueue.offer(q.poll());\\n        }\\n        //smallerQueue : 3,2   storing elements smaller than 5 (root)\\n        root.left = getNode(samllerQueue);\\n        //q: 6,7   storing elements bigger than 5 (root)\\n        root.right = getNode(q);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93167,
                "title": "concise-c-19ms-solution-beating-99-4",
                "content": "Sharing my solution which doesn't have to parse string for comma at all!\\n\\nThe encoding schema is preorder of BST, and to decode this we can use the same preorder traversal to do it in one pass with recursion in O(n) time.\\n\\nTo minimize the memory, I used binary format instead of ascii format for each integer, just burn those int into 4 chars will save you a lot!!!\\n\\nReally if using ASCII numbers you are paying a lot of penalty memory for integers over 4 digit long and parsing comma is just as painful.\\n\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string order;\\n        inorderDFS(root, order);\\n        return order;\\n    }\\n    \\n    inline void inorderDFS(TreeNode* root, string& order) {\\n        if (!root) return;\\n        char buf[4];\\n        memcpy(buf, &(root->val), sizeof(int)); //burn the int into 4 chars\\n        for (int i=0; i<4; i++) order.push_back(buf[i]);\\n        inorderDFS(root->left, order);\\n        inorderDFS(root->right, order);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return reconstruct(data, pos, INT_MIN, INT_MAX);\\n    }\\n    \\n    inline TreeNode* reconstruct(const string& buffer, int& pos, int minValue, int maxValue) {\\n        if (pos >= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.\\n        \\n        int value;\\n        memcpy(&value, &buffer[pos], sizeof(int));\\n        if (value < minValue || value > maxValue) return NULL;\\n        \\n        TreeNode* node = new TreeNode(value);\\n        pos += sizeof(int);\\n        node->left = reconstruct(buffer, pos, minValue, value);\\n        node->right = reconstruct(buffer, pos, value, maxValue);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string order;\\n        inorderDFS(root, order);\\n        return order;\\n    }\\n    \\n    inline void inorderDFS(TreeNode* root, string& order) {\\n        if (!root) return;\\n        char buf[4];\\n        memcpy(buf, &(root->val), sizeof(int)); //burn the int into 4 chars\\n        for (int i=0; i<4; i++) order.push_back(buf[i]);\\n        inorderDFS(root->left, order);\\n        inorderDFS(root->right, order);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return reconstruct(data, pos, INT_MIN, INT_MAX);\\n    }\\n    \\n    inline TreeNode* reconstruct(const string& buffer, int& pos, int minValue, int maxValue) {\\n        if (pos >= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.\\n        \\n        int value;\\n        memcpy(&value, &buffer[pos], sizeof(int));\\n        if (value < minValue || value > maxValue) return NULL;\\n        \\n        TreeNode* node = new TreeNode(value);\\n        pos += sizeof(int);\\n        node->left = reconstruct(buffer, pos, minValue, value);\\n        node->right = reconstruct(buffer, pos, value, maxValue);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886396,
                "title": "c-simple-and-clean-preorder-traversal-solution",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        \\n        while (getline (ss, item, \\'-\\')) \\n            root = insert(root, stoi(item));\\n\\n        return root;\\n    }\\n    \\nprivate:\\n    string encode(TreeNode* root) {\\n        if (!root)\\n            return \"\";\\n        return to_string(root->val) + \"-\" + encode(root->left)+encode(root->right);\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int val) {\\n        if (root == NULL) {\\n\\t\\t\\tTreeNode* temp=new TreeNode(val);\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n    \\n\\t\\tif (val<=root->val)\\n\\t\\t\\troot->left=insert(root->left,val);\\n    \\n\\t\\telse\\n\\t\\t\\troot->right=insert(root->right,val);\\n    \\n\\t\\treturn root;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        \\n        while (getline (ss, item, \\'-\\')) \\n            root = insert(root, stoi(item));\\n\\n        return root;\\n    }\\n    \\nprivate:\\n    string encode(TreeNode* root) {\\n        if (!root)\\n            return \"\";\\n        return to_string(root->val) + \"-\" + encode(root->left)+encode(root->right);\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int val) {\\n        if (root == NULL) {\\n\\t\\t\\tTreeNode* temp=new TreeNode(val);\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n    \\n\\t\\tif (val<=root->val)\\n\\t\\t\\troot->left=insert(root->left,val);\\n    \\n\\t\\telse\\n\\t\\t\\troot->right=insert(root->right,val);\\n    \\n\\t\\treturn root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93168,
                "title": "deserialize-from-preorder-and-computed-inorder-reusing-old-solution",
                "content": "I serialize the tree's values in preorder. For deserializing, I additionally compute inorder simply by sorting the preorder. And then I just use the `buildTree` function that I copied&pasted from [my old solution](https://discuss.leetcode.com/topic/16221/simple-o-n-without-map) for the old problem [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/).\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        def preorder(node):\\n            if node:\\n                vals.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        vals = []\\n        preorder(root)\\n        return ' '.join(vals)\\n\\n    def deserialize(self, data):\\n        preorder = map(int, data.split())\\n        inorder = sorted(preorder)\\n        return self.buildTree(preorder, inorder)\\n\\n    def buildTree(self, preorder, inorder):\\n        def build(stop):\\n            if inorder and inorder[-1] != stop:\\n                root = TreeNode(preorder.pop())\\n                root.left = build(root.val)\\n                inorder.pop()\\n                root.right = build(stop)\\n                return root\\n        preorder.reverse()\\n        inorder.reverse()\\n        return build(None)\\n```\\n(I had seen @shallpion's [title](https://discuss.leetcode.com/topic/65773/construct-bst-using-preorder-traversal) saying \"preorder\" before thinking about this problem, so can't be sure I would've had the idea myself, though I think I would've.)",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        def preorder(node):\\n            if node:\\n                vals.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        vals = []\\n        preorder(root)\\n        return ' '.join(vals)\\n\\n    def deserialize(self, data):\\n        preorder = map(int, data.split())\\n        inorder = sorted(preorder)\\n        return self.buildTree(preorder, inorder)\\n\\n    def buildTree(self, preorder, inorder):\\n        def build(stop):\\n            if inorder and inorder[-1] != stop:\\n                root = TreeNode(preorder.pop())\\n                root.left = build(root.val)\\n                inorder.pop()\\n                root.right = build(stop)\\n                return root\\n        preorder.reverse()\\n        inorder.reverse()\\n        return build(None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549891,
                "title": "bt-bst-c-solution-preorder-comma-seperated-with-comments",
                "content": "(1) Binary Search Tree\\n```\\nclass Codec {\\npublic:\\n    void serializehelper(TreeNode* root, string& s){\\n        if(root==nullptr) return;\\n        \\n        s+=to_string(root->val) + \",\"; // \\',\\' for seperating each value\\n        serializehelper(root->left, s);\\n        serializehelper(root->right, s);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        if(root==nullptr) return \"\";\\n        \\n        string s=\"\";\\n        serializehelper(root, s);\\n        \\n        return s;\\n    }\\n    \\n    int convertStringtoInt(string& data, int& pos){ // Find \\',\\' and return value\\n        pos=data.find(\\',\\');\\n        int value=stoi(data.substr(0, pos));\\n        return value;\\n    }\\n    \\n    TreeNode* deserializehelper(string& data, int min, int max) {\\n        if(data.size()==0) return nullptr; // If no more elements, return nullptr\\n        \\n        int pos=0;\\n        int value = convertStringtoInt(data, pos); // Find new value and position of \\',\\'\\n        if (value < min || value > max) return nullptr; // Is new value in given range\\n        \\n        TreeNode* tnode = new TreeNode(value); \\n        data=data.substr(pos+1); // Update only when in range\\n        \\n        tnode->left=deserializehelper(data, min, tnode->val); // Branch off to left & right subtree with given ranges\\n        tnode->right=deserializehelper(data, tnode->val, max);\\n        return tnode;\\n    }\\n    \\n    TreeNode* deserialize(string data) {\\n        if(data==\"\") return nullptr;\\n        return deserializehelper(data, INT_MIN, INT_MAX);\\n    }\\n};\\n```\\n\\n(2) Binary Tree\\n```\\nclass Codec {\\npublic:\\n    string serialize(TreeNode* root) {\\n        if(root==nullptr) return \"X\";\\n        \\n        return to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right); // to_string\\n    }\\n    int convertStringtoInt(string& data){\\n        int pos=data.find(\\',\\');\\n        int value=stoi(data.substr(0, pos));\\n        data=data.substr(pos+1);\\n        return value;\\n    }\\n    TreeNode* deserializehelper(string& data) { // data is updated, hence by reference\\n        if(data[0]==\\'X\\'){\\n            if(data.size()>1)\\n                data=data.substr(2);  // keep removing data \\n            return nullptr;\\n        }\\n        \\n        TreeNode* tnode = new TreeNode(convertStringtoInt(data));  // covert data using stoi\\n        tnode->left=deserializehelper(data);\\n        tnode->right=deserializehelper(data);\\n        return tnode;\\n    }\\n    TreeNode* deserialize(string data) {\\n        return deserializehelper(data);\\n    }\\n};\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    void serializehelper(TreeNode* root, string& s){\\n        if(root==nullptr) return;\\n        \\n        s+=to_string(root->val) + \",\"; // \\',\\' for seperating each value\\n        serializehelper(root->left, s);\\n        serializehelper(root->right, s);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        if(root==nullptr) return \"\";\\n        \\n        string s=\"\";\\n        serializehelper(root, s);\\n        \\n        return s;\\n    }\\n    \\n    int convertStringtoInt(string& data, int& pos){ // Find \\',\\' and return value\\n        pos=data.find(\\',\\');\\n        int value=stoi(data.substr(0, pos));\\n        return value;\\n    }\\n    \\n    TreeNode* deserializehelper(string& data, int min, int max) {\\n        if(data.size()==0) return nullptr; // If no more elements, return nullptr\\n        \\n        int pos=0;\\n        int value = convertStringtoInt(data, pos); // Find new value and position of \\',\\'\\n        if (value < min || value > max) return nullptr; // Is new value in given range\\n        \\n        TreeNode* tnode = new TreeNode(value); \\n        data=data.substr(pos+1); // Update only when in range\\n        \\n        tnode->left=deserializehelper(data, min, tnode->val); // Branch off to left & right subtree with given ranges\\n        tnode->right=deserializehelper(data, tnode->val, max);\\n        return tnode;\\n    }\\n    \\n    TreeNode* deserialize(string data) {\\n        if(data==\"\") return nullptr;\\n        return deserializehelper(data, INT_MIN, INT_MAX);\\n    }\\n};\\n```\n```\\nclass Codec {\\npublic:\\n    string serialize(TreeNode* root) {\\n        if(root==nullptr) return \"X\";\\n        \\n        return to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right); // to_string\\n    }\\n    int convertStringtoInt(string& data){\\n        int pos=data.find(\\',\\');\\n        int value=stoi(data.substr(0, pos));\\n        data=data.substr(pos+1);\\n        return value;\\n    }\\n    TreeNode* deserializehelper(string& data) { // data is updated, hence by reference\\n        if(data[0]==\\'X\\'){\\n            if(data.size()>1)\\n                data=data.substr(2);  // keep removing data \\n            return nullptr;\\n        }\\n        \\n        TreeNode* tnode = new TreeNode(convertStringtoInt(data));  // covert data using stoi\\n        tnode->left=deserializehelper(data);\\n        tnode->right=deserializehelper(data);\\n        return tnode;\\n    }\\n    TreeNode* deserialize(string data) {\\n        return deserializehelper(data);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93224,
                "title": "concise-iterative-python-solution-using-stack-beat-99",
                "content": "The idea is serialize the data into pre-order string.\\n\\nIn deserialize, we stack to build the tree.\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        res, stk = [], []\\n        while stk or root:\\n            if root:\\n                res.append(str(root.val))\\n                stk.append(root)\\n                root = root.left\\n            else:\\n                root = stk.pop()\\n                root = root.right\\n        return ' '.join(res)\\n\\n    def deserialize(self, data):\\n        if not data:\\n            return None\\n        data = map(int, data.split(' '))\\n        stk = []\\n        root = node = TreeNode(data[0])\\n        for n in data[1:]:\\n            if n < node.val:\\n                node.left = TreeNode(n)\\n                stk.append(node)\\n                node = node.left\\n            else:\\n                while stk and stk[-1].val < n:\\n                    node = stk.pop()\\n                node.right = TreeNode(n)\\n                node = node.right\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        res, stk = [], []\\n        while stk or root:\\n            if root:\\n                res.append(str(root.val))\\n                stk.append(root)\\n                root = root.left\\n            else:\\n                root = stk.pop()\\n                root = root.right\\n        return ' '.join(res)\\n\\n    def deserialize(self, data):\\n        if not data:\\n            return None\\n        data = map(int, data.split(' '))\\n        stk = []\\n        root = node = TreeNode(data[0])\\n        for n in data[1:]:\\n            if n < node.val:\\n                node.left = TreeNode(n)\\n                stk.append(node)\\n                node = node.left\\n            else:\\n                while stk and stk[-1].val < n:\\n                    node = stk.pop()\\n                node.right = TreeNode(n)\\n                node = node.right\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93180,
                "title": "using-lower-bound-and-upper-bound-to-deserialize-bst",
                "content": "The idea is to encode every non null root value by preorder traversal \\n\\nwhen deserializing the tree, we can pass by the lower bound and upper bound to know the boundary of a subtree.\\n\\nThis approach has an overhead of looking up one extra number, which would be O ( 2N )\\n\\n```\\n    // Encodes a tree to a single string.\\n    void serialize(TreeNode* root, ostringstream& out )\\n    {\\n        if ( !root ) return;\\n        out << root->val << \",\";\\n        serialize(root->left, out);\\n        serialize(root->right, out);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        ostringstream ss;\\n        serialize(root, ss);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(const string& s, int lower, int upper, int & pos )\\n    {\\n        // pos is a variable to record the end of decoded buffer \\n        if ( pos == s.size() ) return nullptr;\\n        int cur_pos = pos;\\n        int number = 0;\\n        while( s[cur_pos] != ',')\\n        {\\n            number = number * 10 + s[cur_pos] - '0';\\n            ++cur_pos;\\n        }\\n        ++cur_pos;\\n        // The next number is not part of current subtree, should return nullptr\\n        if ( number < lower || number > upper ) return nullptr;\\n\\n        TreeNode* root = new TreeNode( number );\\n        pos = cur_pos; // update pos \\n        root->left =  deserialize( s, lower, root->val, pos );\\n        root->right = deserialize( s, root->val, upper, pos );\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return deserialize( data, INT_MIN, INT_MAX, pos );\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // Encodes a tree to a single string.\\n    void serialize(TreeNode* root, ostringstream& out )\\n    {\\n        if ( !root ) return;\\n        out << root->val << \",\";\\n        serialize(root->left, out);\\n        serialize(root->right, out);\\n    }\\n    \\n    string serialize(TreeNode* root) {\\n        ostringstream ss;\\n        serialize(root, ss);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(const string& s, int lower, int upper, int & pos )\\n    {\\n        // pos is a variable to record the end of decoded buffer \\n        if ( pos == s.size() ) return nullptr;\\n        int cur_pos = pos;\\n        int number = 0;\\n        while( s[cur_pos] != ',')\\n        {\\n            number = number * 10 + s[cur_pos] - '0';\\n            ++cur_pos;\\n        }\\n        ++cur_pos;\\n        // The next number is not part of current subtree, should return nullptr\\n        if ( number < lower || number > upper ) return nullptr;\\n\\n        TreeNode* root = new TreeNode( number );\\n        pos = cur_pos; // update pos \\n        root->left =  deserialize( s, lower, root->val, pos );\\n        root->right = deserialize( s, root->val, upper, pos );\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int pos = 0;\\n        return deserialize( data, INT_MIN, INT_MAX, pos );\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164504,
                "title": "java-concise-solution",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null){\\n            return \"#\";\\n        }\\n        return String.valueOf(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[]strs = data.split(\",\");\\n        return deserialize(strs, new int[]{0});\\n    }\\n    private TreeNode deserialize(String[]arr, int[]idx){\\n        if(arr[idx[0]].equals(\"#\")){\\n            idx[0]++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(arr[idx[0]++]));\\n        root.left = deserialize(arr, idx);\\n        root.right = deserialize(arr, idx);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null){\\n            return \"#\";\\n        }\\n        return String.valueOf(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[]strs = data.split(\",\");\\n        return deserialize(strs, new int[]{0});\\n    }\\n    private TreeNode deserialize(String[]arr, int[]idx){\\n        if(arr[idx[0]].equals(\"#\")){\\n            idx[0]++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(arr[idx[0]++]));\\n        root.left = deserialize(arr, idx);\\n        root.right = deserialize(arr, idx);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886354,
                "title": "python-o-n-solution-using-preorder-traversal-explained",
                "content": "My idea to solve this problem is to use **Problem 1008**. Construct Binary Search Tree from Preorder Traversal. So:\\n\\n1. For our serialization we just get preorder traversel (iterative or recursion, whatever you want, I used iterative, using stack).\\n2. For deserialization we use solution with `O(n)` time complexity: we give the function two bounds - `up` and `down`: the maximum number it will handle. The left recursion will take the elements smaller than `node.val` and  the right recursion will take the remaining elements smaller than `bound`.\\n\\n**Complexity**: both for serialization and deserialization is `O(n)`, because `self.index` will be increased by one on each iteration.\\n\\n```\\nclass Codec:\\n    def serialize(self, root):\\n        if not root: return \"\"\\n        stack, out = [root], []\\n        while stack:\\n            cur = stack.pop()\\n            out.append(cur.val)\\n            for child in filter(None, [cur.right, cur.left]):\\n                stack += [child]\\n                \\n        return \\' \\'.join(map(str, out))\\n        \\n    def deserialize(self, data):\\n        preorder = [int(i) for i in data.split()]\\n        def helper(down, up):\\n            if self.idx >= len(preorder): return None\\n            if not down <= preorder[self.idx] <= up: return None\\n            root = TreeNode(preorder[self.idx])\\n            self.idx += 1\\n            root.left = helper(down, root.val)\\n            root.right = helper(root.val, up)\\n            return root\\n            \\n        self.idx = 0\\n        return helper(-float(\"inf\"), float(\"inf\"))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def serialize(self, root):\\n        if not root: return \"\"\\n        stack, out = [root], []\\n        while stack:\\n            cur = stack.pop()\\n            out.append(cur.val)\\n            for child in filter(None, [cur.right, cur.left]):\\n                stack += [child]\\n                \\n        return \\' \\'.join(map(str, out))\\n        \\n    def deserialize(self, data):\\n        preorder = [int(i) for i in data.split()]\\n        def helper(down, up):\\n            if self.idx >= len(preorder): return None\\n            if not down <= preorder[self.idx] <= up: return None\\n            root = TreeNode(preorder[self.idx])\\n            self.idx += 1\\n            root.left = helper(down, root.val)\\n            root.right = helper(root.val, up)\\n            return root\\n            \\n        self.idx = 0\\n        return helper(-float(\"inf\"), float(\"inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93170,
                "title": "pre-or-post-order-with-only-keeping-one-bound-beat-98-and-95",
                "content": "the post-order:\\n\\n'''\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n        sb.append(Integer.valueOf(root.val)).append(\" \");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {nodes.length - 1};\\n        return deserialize(nodes, index, Integer.MIN_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int min) {\\n        if (index[0] < 0 || Integer.valueOf(nodes[index[0]]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]--]));\\n        root.right = deserialize(nodes, index, root.val);\\n        root.left = deserialize(nodes, index, min);\\n        return root;\\n    }\\n}\\n\\n'''\\n\\npre-order\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        sb.append(root.val).append(\" \");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {0};\\n        return deserialize(nodes, index, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int max) {\\n        if (index[0] >= nodes.length || Integer.valueOf(nodes[index[0]]) >= max) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]++]));\\n        root.left = deserialize(nodes, index, root.val);\\n        root.right = deserialize(nodes, index, max);\\n        return root;\\n    }\\n}\\n\\n'''",
                "solutionTags": [],
                "code": "the post-order:\\n\\n'''\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n        sb.append(Integer.valueOf(root.val)).append(\" \");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {nodes.length - 1};\\n        return deserialize(nodes, index, Integer.MIN_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int min) {\\n        if (index[0] < 0 || Integer.valueOf(nodes[index[0]]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]--]));\\n        root.right = deserialize(nodes, index, root.val);\\n        root.left = deserialize(nodes, index, min);\\n        return root;\\n    }\\n}\\n\\n'''\\n\\npre-order\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        serialize(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serialize(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            return;\\n        }\\n        sb.append(root.val).append(\" \");\\n        serialize(root.left, sb);\\n        serialize(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) {\\n            return null;\\n        }\\n        String[] nodes = data.split(\" \");\\n        int[] index = new int[] {0};\\n        return deserialize(nodes, index, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode deserialize(String[] nodes, int[] index, int max) {\\n        if (index[0] >= nodes.length || Integer.valueOf(nodes[index[0]]) >= max) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[index[0]++]));\\n        root.left = deserialize(nodes, index, root.val);\\n        root.right = deserialize(nodes, index, max);\\n        return root;\\n    }\\n}\\n\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 502589,
                "title": "python-o-n-sol-by-pre-order-traversal-75-with-explanation",
                "content": "Python O(n) sol by pre-order traversal.\\n\\n---\\n\\nHint:\\n1. Pre-order traversal of binary search tree is **unique and only**. (i.e., no repetition between two different BSTs)\\n\\n2. **Pre-order traversal rule** of binary search tree is ( **current node, left-child, right-child**)\\n\\n3. Left child value < current node value < Right child value **if all elements are unique**.\\n\\n---\\n\\nAlgorithm:\\n\\nSerialization: \\nGenerate a string to represent the input BST with preorder traversal.\\n\\nDeseialization:\\nDecode the serialization string to rebuild BST by preorder traversal.\\n\\n---\\n\\nExample illustration\\n\\n---\\n\\nSerialization:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1581313601.png)\\n\\n---\\n\\nDeserialization:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1581313629.png)\\n\\n---\\n\\n```\\nfrom collections import deque\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        \\n        # record of preorder traversal path\\n        path_of_preorder = []\\n        \\n        # Generate pre-order traversal path of binary search tree\\n        def helper( node ):\\n            \\n            if node:\\n                path_of_preorder.append( node.val )\\n                helper( node.left )\\n                helper( node.right )\\n        \\n        # ---------------------------------------------\\n        helper( root )\\n        # output as string, each node is separated by \\'#\\'\\n        return \\'#\\'.join( map(str, path_of_preorder) )\\n                \\n        \\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            # corner case handle for empty tree\\n            return None\\n        \\n        # convert input string into doubly linked list of integer type, each node is separated by \\'#\\'\\n        node_values = deque(  int(value) for value in data.split(\\'#\\') )\\n        \\n        # Reconstruct binary search tree by pre-order traversal\\n        def helper( lower_bound, upper_bound):\\n            \\n            if node_values and lower_bound < node_values[0] < upper_bound:\\n                \\n                root_value = node_values.popleft()\\n                root_node = TreeNode( root_value )\\n                \\n                root_node.left = helper( lower_bound, root_value )\\n                root_node.right = helper( root_value, upper_bound )\\n                \\n                return root_node\\n        \\n        # ---------------------------------------------\\n        \\n        return helper( float(\\'-inf\\'), float(\\'inf\\'))    \\n```\\n\\n---\\n\\nRelative leetcode challenge:\\n[Leetcode #1008 Construct Binary Search Tree from Preorder Traversal](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)\\n\\n[Leetcode #144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nfrom collections import deque\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        \\n        # record of preorder traversal path\\n        path_of_preorder = []\\n        \\n        # Generate pre-order traversal path of binary search tree\\n        def helper( node ):\\n            \\n            if node:\\n                path_of_preorder.append( node.val )\\n                helper( node.left )\\n                helper( node.right )\\n        \\n        # ---------------------------------------------\\n        helper( root )\\n        # output as string, each node is separated by \\'#\\'\\n        return \\'#\\'.join( map(str, path_of_preorder) )\\n                \\n        \\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            # corner case handle for empty tree\\n            return None\\n        \\n        # convert input string into doubly linked list of integer type, each node is separated by \\'#\\'\\n        node_values = deque(  int(value) for value in data.split(\\'#\\') )\\n        \\n        # Reconstruct binary search tree by pre-order traversal\\n        def helper( lower_bound, upper_bound):\\n            \\n            if node_values and lower_bound < node_values[0] < upper_bound:\\n                \\n                root_value = node_values.popleft()\\n                root_node = TreeNode( root_value )\\n                \\n                root_node.left = helper( lower_bound, root_value )\\n                root_node.right = helper( root_value, upper_bound )\\n                \\n                return root_node\\n        \\n        # ---------------------------------------------\\n        \\n        return helper( float(\\'-inf\\'), float(\\'inf\\'))    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 93179,
                "title": "java-o-n-recursive-dfs-without-null-changed-from-serialize-and-deserialize-bt",
                "content": "Thanks to [this post](https://discuss.leetcode.com/topic/66495/using-lower-bound-and-upper-bound-to-deserialize-bst), I realize that I can make use of lower and upper bound.\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) { // preorder\\n        StringBuilder sb = new StringBuilder();\\n        serializedfs(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serializedfs(TreeNode root, StringBuilder sb){\\n        if(root == null) return; // no \"null \"\\n        sb.append(root.val).append(\" \");\\n        serializedfs(root.left, sb);\\n        serializedfs(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length() == 0) return null;\\n        String[] list = data.split(\" \");\\n        TreeNode dummy = new TreeNode(0);\\n        deserializedfs(list, 0, dummy, true, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        return dummy.left;\\n    }\\n    \\n    private int deserializedfs(String[] list, int pos, TreeNode par, boolean isleft, \\n                                                        int lower, int upper){\\n        if(pos >= list.length) return pos;\\n    \\n        int val = Integer.valueOf(list[pos]);\\n        if(val < lower || val > upper) return pos-1; // have not used this pos, so minus one\\n        TreeNode cur = new TreeNode(val);\\n        \\n        if(isleft) par.left = cur;\\n        else       par.right = cur;\\n\\n        pos = deserializedfs(list, ++pos, cur, true, lower, val);\\n        pos = deserializedfs(list, ++pos, cur, false, val, upper);\\n        return pos;\\n    }",
                "solutionTags": [],
                "code": "Thanks to [this post](https://discuss.leetcode.com/topic/66495/using-lower-bound-and-upper-bound-to-deserialize-bst), I realize that I can make use of lower and upper bound.\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) { // preorder\\n        StringBuilder sb = new StringBuilder();\\n        serializedfs(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    private void serializedfs(TreeNode root, StringBuilder sb){\\n        if(root == null) return; // no \"null \"\\n        sb.append(root.val).append(\" \");\\n        serializedfs(root.left, sb);\\n        serializedfs(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length() == 0) return null;\\n        String[] list = data.split(\" \");\\n        TreeNode dummy = new TreeNode(0);\\n        deserializedfs(list, 0, dummy, true, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n        return dummy.left;\\n    }\\n    \\n    private int deserializedfs(String[] list, int pos, TreeNode par, boolean isleft, \\n                                                        int lower, int upper){\\n        if(pos >= list.length) return pos;\\n    \\n        int val = Integer.valueOf(list[pos]);\\n        if(val < lower || val > upper) return pos-1; // have not used this pos, so minus one\\n        TreeNode cur = new TreeNode(val);\\n        \\n        if(isleft) par.left = cur;\\n        else       par.right = cur;\\n\\n        pos = deserializedfs(list, ++pos, cur, true, lower, val);\\n        pos = deserializedfs(list, ++pos, cur, false, val, upper);\\n        return pos;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 886326,
                "title": "python-bfs-90",
                "content": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        tree = []\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node:\\n                tree.append(str(node.val))\\n                queue.extend([node.left, node.right])\\n            else:\\n                tree.append(\\'*\\')\\n        return \\',\\'.join(tree)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        tree = deque(data.split(\\',\\'))\\n        root = TreeNode(int(tree.popleft()))\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            \\n            if (left := tree.popleft()) != \\'*\\':\\n                node.left = TreeNode(int(left))\\n                queue.append(node.left)\\n            \\n            if (right := tree.popleft()) != \\'*\\':\\n                node.right = TreeNode(int(right))\\n                queue.append(node.right)\\n                \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        tree = []\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node:\\n                tree.append(str(node.val))\\n                queue.extend([node.left, node.right])\\n            else:\\n                tree.append(\\'*\\')\\n        return \\',\\'.join(tree)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        tree = deque(data.split(\\',\\'))\\n        root = TreeNode(int(tree.popleft()))\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            \\n            if (left := tree.popleft()) != \\'*\\':\\n                node.left = TreeNode(int(left))\\n                queue.append(node.left)\\n            \\n            if (right := tree.popleft()) != \\'*\\':\\n                node.right = TreeNode(int(right))\\n                queue.append(node.right)\\n                \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93184,
                "title": "easy-to-understand-c-solution-using-preorder-traversal-and-iostringstream",
                "content": "Because of BST, so we can use `PreOrder Traversal` to rebuild the tree, so do with serialize and deserialize. After using `iostringstream`, we can easily get the values and build the tree.\\n\\n```\\nclass Codec \\n{\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) \\n    {\\n        ostringstream out;\\n        mySerialize(root, out);\\n        return out.str();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) \\n    {\\n        if(data == \"\") return NULL;\\n        istringstream in(data);\\n        return myDeserialize(in);\\n    }\\nprivate:\\n\\tvoid mySerialize(TreeNode* root, ostringstream &out)\\n\\t{\\n\\t\\tif(root == NULL) return;\\n\\t\\tout << root->val << \" \";\\n\\t\\tmySerialize(root->left, out);\\n\\t\\tmySerialize(root->right, out);\\n\\t}\\n\\n\\tTreeNode* myDeserialize(istringstream &in)\\n\\t{\\n\\t\\tstring val;\\n\\t\\tin >> val;\\n\\t\\tTreeNode *root = new TreeNode(stoi(val));\\n\\t\\twhile(in >> val)\\n\\t\\t\\tbuildTree(root, stoi(val));\\n\\t\\treturn root;\\n\\t}\\n\\n\\tvoid buildTree(TreeNode* root, int n)\\n\\t{\\n\\t\\tif(root->val > n)\\n\\t\\t{\\n\\t\\t\\tif(root->left == NULL)\\n\\t\\t\\t\\troot->left = new TreeNode(n);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuildTree(root->left, n);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(root->right == NULL)\\n\\t\\t\\t\\troot->right = new TreeNode(n);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuildTree(root->right, n);\\n\\t\\t}\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec \\n{\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) \\n    {\\n        ostringstream out;\\n        mySerialize(root, out);\\n        return out.str();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) \\n    {\\n        if(data == \"\") return NULL;\\n        istringstream in(data);\\n        return myDeserialize(in);\\n    }\\nprivate:\\n\\tvoid mySerialize(TreeNode* root, ostringstream &out)\\n\\t{\\n\\t\\tif(root == NULL) return;\\n\\t\\tout << root->val << \" \";\\n\\t\\tmySerialize(root->left, out);\\n\\t\\tmySerialize(root->right, out);\\n\\t}\\n\\n\\tTreeNode* myDeserialize(istringstream &in)\\n\\t{\\n\\t\\tstring val;\\n\\t\\tin >> val;\\n\\t\\tTreeNode *root = new TreeNode(stoi(val));\\n\\t\\twhile(in >> val)\\n\\t\\t\\tbuildTree(root, stoi(val));\\n\\t\\treturn root;\\n\\t}\\n\\n\\tvoid buildTree(TreeNode* root, int n)\\n\\t{\\n\\t\\tif(root->val > n)\\n\\t\\t{\\n\\t\\t\\tif(root->left == NULL)\\n\\t\\t\\t\\troot->left = new TreeNode(n);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuildTree(root->left, n);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(root->right == NULL)\\n\\t\\t\\t\\troot->right = new TreeNode(n);\\n\\t\\t\\telse\\n\\t\\t\\t\\tbuildTree(root->right, n);\\n\\t\\t}\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212043,
                "title": "python-solution",
                "content": "One can use the encoding and decoding scheme in 297. Serialize and Deserialize Binary Tree. However, it does not use the properties of a BST: The left (right) subtree of a node contains only nodes with keys smaller (greater) than the node\\'s key. Therefore, the encoding strings there does not satisfy the requirement that it should be as compact as possible. In particular, the null nodes need to be specified in the encoding string, and is redundant here. With the aforementioned BST property, one can actually recover a BST from its preorder traversal alone (without specifying the null nodes), assuming that the node values are distinct.\\n\\nAs a concrete example, suppose the preorder traversal of some BST gives `s = \"5,4,2,3,7,9,10\"`. Since the preorder traversal traverses the tree in the order `root -> left subtree -> right subtree`, we know that `\"5\"` must be the value of the `root` of the BST. Furthermore, by the BST property, all values smaller (larger) than `5` should be all values of nodes from the left (right) subtree. Hence, we we just need to iterate over `s[1:]` and find the first occurence (at index `i`) of some number larger than `5`. Then the left subtree would consists of values `s[1:i]` (`[\"4\",\"2\",\"3\"]` in this example), and the right subtree would consists of values `s[i:]` (`[\"7\",\"9\",\"10\"]` in this example). Calling the deserialize method recursively on `s[1:i]`, and `s[i:]` gives us the roots of the left subtree `l` and right subtree `r` respectively. And by assigning `root.left = l`, and `root.right = r`, and returning `root`, we finish the deserialization procedure.\\n\\nTime complexity for `serialize`: `O(n)`. Time complexity for `deserialize`: `O(n^2)`. Space complexity for both `serialize` and `deserialize`: `O(n)`.\\n\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return \\n            res.append(str(root.val) + \",\")\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        res = []\\n        dfs(root)\\n        return \"\".join(res)\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def helper(arr, i, j):\\n            if i > j:\\n                return\\n            if i == j:\\n                node = TreeNode(arr[i])\\n                return node\\n            for k in range(i+1, j+1):\\n                if arr[k] > arr[i]:\\n                    l = helper(arr, i+1, k-1)\\n                    r = helper(arr, k, j)\\n                    root = TreeNode(arr[i])\\n                    root.left = l\\n                    root.right = r\\n                    return root\\n            l = helper(arr, i+1, j)\\n            root = TreeNode(arr[i])\\n            root.left = l\\n            return root\\n        \\n        arr = data.split(\",\")\\n        arr.pop()\\n        data = [int(x) for x in arr]\\n        return helper(data, 0, len(data)-1)\\n```\\n\\nA better solution with `O(n)` iterative deserialization:\\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return \\n            res.append(str(root.val) + \",\")\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        res = []\\n        dfs(root)\\n        return \"\".join(res)\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        lst = data.split(\",\")\\n        lst.pop()\\n        stack = []\\n        head = None\\n        for n in lst:\\n            n = int(n)\\n            if not head:\\n                head = TreeNode(n)\\n                stack.append(head)\\n            else:\\n                node = TreeNode(n)\\n                if n < stack[-1].val:\\n                    stack[-1].left = node\\n                else:\\n                    while stack and stack[-1].val < n: \\n                        u = stack.pop()\\n                    u.right = node\\n                stack.append(node)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return \\n            res.append(str(root.val) + \",\")\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        res = []\\n        dfs(root)\\n        return \"\".join(res)\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def helper(arr, i, j):\\n            if i > j:\\n                return\\n            if i == j:\\n                node = TreeNode(arr[i])\\n                return node\\n            for k in range(i+1, j+1):\\n                if arr[k] > arr[i]:\\n                    l = helper(arr, i+1, k-1)\\n                    r = helper(arr, k, j)\\n                    root = TreeNode(arr[i])\\n                    root.left = l\\n                    root.right = r\\n                    return root\\n            l = helper(arr, i+1, j)\\n            root = TreeNode(arr[i])\\n            root.left = l\\n            return root\\n        \\n        arr = data.split(\",\")\\n        arr.pop()\\n        data = [int(x) for x in arr]\\n        return helper(data, 0, len(data)-1)\\n```\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return \\n            res.append(str(root.val) + \",\")\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        res = []\\n        dfs(root)\\n        return \"\".join(res)\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        lst = data.split(\",\")\\n        lst.pop()\\n        stack = []\\n        head = None\\n        for n in lst:\\n            n = int(n)\\n            if not head:\\n                head = TreeNode(n)\\n                stack.append(head)\\n            else:\\n                node = TreeNode(n)\\n                if n < stack[-1].val:\\n                    stack[-1].left = node\\n                else:\\n                    while stack and stack[-1].val < n: \\n                        u = stack.pop()\\n                    u.right = node\\n                stack.append(node)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886180,
                "title": "python-preorder-traversal-clean-concise-o-n",
                "content": "Same with problem: [297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)\\n\\n```python\\nclass Codec:\\n    def serialize(self, root):\\n        if root == None:\\n            return \"$\"\\n        return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\\n\\n    def deserialize(self, data):\\n        nodes = data.split(\",\")\\n        self.i = 0\\n        def dfs():\\n            if self.i == len(nodes) or nodes[self.i] == \"$\":\\n                self.i += 1\\n                return None\\n            root = TreeNode(int(nodes[self.i]))\\n            self.i += 1\\n            root.left = dfs()\\n            root.right = dfs()\\n            return root\\n        \\n        return dfs()\\n```\\n**Complexity**\\n- Time & Space: `O(N)`, where `N` is number of nodes in BST.",
                "solutionTags": [],
                "code": "```python\\nclass Codec:\\n    def serialize(self, root):\\n        if root == None:\\n            return \"$\"\\n        return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\\n\\n    def deserialize(self, data):\\n        nodes = data.split(\",\")\\n        self.i = 0\\n        def dfs():\\n            if self.i == len(nodes) or nodes[self.i] == \"$\":\\n                self.i += 1\\n                return None\\n            root = TreeNode(int(nodes[self.i]))\\n            self.i += 1\\n            root.left = dfs()\\n            root.right = dfs()\\n            return root\\n        \\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886276,
                "title": "c-super-simple-clean-short-soluion-only-11-lines",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) \\n    {\\n        return !root ? \" null\" : \" \" + to_string(root->val) + serialize(root->left) + serialize(root->right);\\n    }\\n\\t\\n    TreeNode* deserialize(string data) \\n    {\\n        istringstream ss(data);\\n\\t\\treturn buildBST(ss);\\n    }\\n    \\nprivate:\\n    \\n    TreeNode* buildBST(istringstream& ss)\\n    {\\n        string s;\\n        ss >> s;\\n        \\n        if (s == \"null\")\\n\\t\\t\\treturn NULL;\\n        \\n        TreeNode* node = new TreeNode(stoi(s));\\n        node->left = buildBST(ss);\\n        node->right = buildBST(ss);\\n            \\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) \\n    {\\n        return !root ? \" null\" : \" \" + to_string(root->val) + serialize(root->left) + serialize(root->right);\\n    }\\n\\t\\n    TreeNode* deserialize(string data) \\n    {\\n        istringstream ss(data);\\n\\t\\treturn buildBST(ss);\\n    }\\n    \\nprivate:\\n    \\n    TreeNode* buildBST(istringstream& ss)\\n    {\\n        string s;\\n        ss >> s;\\n        \\n        if (s == \"null\")\\n\\t\\t\\treturn NULL;\\n        \\n        TreeNode* node = new TreeNode(stoi(s));\\n        node->left = buildBST(ss);\\n        node->right = buildBST(ss);\\n            \\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312687,
                "title": "easy-java-solution-2-approaches-beats-100-online-submissions",
                "content": "# Approach\\n1. **Perform DFS and store the result in a string seperated by \\',\\' and null is represented by \\'x\\'**\\n2. **To helpdeserialize follow the approach to build a Tree**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Codec {\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder res = new StringBuilder();\\n\\n        helpserialize(root,res);\\n\\n        return res.toString();\\n    }\\n\\n    private void helpserialize(TreeNode root, StringBuilder res){\\n        if(root == null){\\n            res.append(\"x,\");\\n            return ;\\n        }\\n\\n        res.append(root.val);\\n        res.append(\\',\\');\\n\\n        helpserialize(root.left, res);\\n        helpserialize(root.right, res);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Deque<String> q = new LinkedList<>();\\n\\n        q.addAll(Arrays.asList(data.split(\",\")));\\n\\n        return helpdeserialize(q);\\n    }\\n\\n    private TreeNode helpdeserialize(Deque<String> q){\\n        String res = q.remove();\\n\\n        if(res.equals(\"x\")){\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(Integer.parseInt(res));\\n\\n        root.left = helpdeserialize(q);\\n        root.right = helpdeserialize(q);\\n\\n        return root;\\n    }\\n}\\n```\\n\\n# Java O(1) Code\\n\\n# I mean... why not \\uD83D\\uDE02\\n```\\npublic class Codec {\\n\\n    static TreeNode res;\\n    public String serialize(TreeNode root) {\\n        res = root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Codec {\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder res = new StringBuilder();\\n\\n        helpserialize(root,res);\\n\\n        return res.toString();\\n    }\\n\\n    private void helpserialize(TreeNode root, StringBuilder res){\\n        if(root == null){\\n            res.append(\"x,\");\\n            return ;\\n        }\\n\\n        res.append(root.val);\\n        res.append(\\',\\');\\n\\n        helpserialize(root.left, res);\\n        helpserialize(root.right, res);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Deque<String> q = new LinkedList<>();\\n\\n        q.addAll(Arrays.asList(data.split(\",\")));\\n\\n        return helpdeserialize(q);\\n    }\\n\\n    private TreeNode helpdeserialize(Deque<String> q){\\n        String res = q.remove();\\n\\n        if(res.equals(\"x\")){\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(Integer.parseInt(res));\\n\\n        root.left = helpdeserialize(q);\\n        root.right = helpdeserialize(q);\\n\\n        return root;\\n    }\\n}\\n```\n```\\npublic class Codec {\\n\\n    static TreeNode res;\\n    public String serialize(TreeNode root) {\\n        res = root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821685,
                "title": "small-and-simple-code-in-c-with-o-n-time-complexity",
                "content": "Do the dry run to understand\\nexample:\\n1 ( 2 (4) (5) ) (3 (6) ( 7 (8) (9) ) )\\n1 -> children 2 and 3\\n2 -> children 4 and 5\\n3 -> children 6 and 7\\n7 -> children 8 and 9\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str = \"\";\\n        if(root == NULL) return str;\\n        str = to_string(root->val) + \"(\" + serialize(root->left) + \")\" + \"(\" + serialize(root->right) + \")\";\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* decode(string &data, int &i) {\\n        if(i < data.size() && data[i] == \\'(\\') i++;\\n        if(i>=data.size() || data[i] == \\')\\') {\\n            return NULL;\\n        }\\n        \\n        int num = 0;\\n        while(data[i] <= \\'9\\' && data[i] >= \\'0\\') {\\n            num = num * 10 + (data[i] - \\'0\\');\\n            i++;\\n        }\\n        \\n        TreeNode* root = new TreeNode(num);\\n        root->left = decode(data, i);\\n        i++;\\n        root->right = decode(data, i);\\n        i++;\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* deserialize(string data) {\\n        int i=0;\\n        return decode(data, i);       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str = \"\";\\n        if(root == NULL) return str;\\n        str = to_string(root->val) + \"(\" + serialize(root->left) + \")\" + \"(\" + serialize(root->right) + \")\";\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* decode(string &data, int &i) {\\n        if(i < data.size() && data[i] == \\'(\\') i++;\\n        if(i>=data.size() || data[i] == \\')\\') {\\n            return NULL;\\n        }\\n        \\n        int num = 0;\\n        while(data[i] <= \\'9\\' && data[i] >= \\'0\\') {\\n            num = num * 10 + (data[i] - \\'0\\');\\n            i++;\\n        }\\n        \\n        TreeNode* root = new TreeNode(num);\\n        root->left = decode(data, i);\\n        i++;\\n        root->right = decode(data, i);\\n        i++;\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* deserialize(string data) {\\n        int i=0;\\n        return decode(data, i);       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93199,
                "title": "extremely-elegant-and-simple-javascript-solution",
                "content": "My serialized list takes the form of: \\n`[root, <elements smaller than root>, <elements bigger than root>]` and this is true recursively. I cheated a little bit by using `JSON.stringify` and `JSON.parse` but the general idea is there.\\n\\n```\\nvar serialize = function(root) {\\n    function traverse(node) {\\n        if (!node) {\\n            return [];\\n        }\\n        return [node.val].concat(traverse(node.left), traverse(node.right));\\n    }\\n    return JSON.stringify(traverse(root));\\n};\\n\\nvar deserialize = function(data) {\\n    function construct(arr) {\\n        if (!arr.length) {\\n            return null;\\n        }\\n        const root = new TreeNode(arr[0]);\\n        root.left = construct(arr.filter(num => num < root.val));\\n        root.right = construct(arr.filter(num => num > root.val));\\n        return root;\\n    }\\n    return construct(JSON.parse(data));\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar serialize = function(root) {\\n    function traverse(node) {\\n        if (!node) {\\n            return [];\\n        }\\n        return [node.val].concat(traverse(node.left), traverse(node.right));\\n    }\\n    return JSON.stringify(traverse(root));\\n};\\n\\nvar deserialize = function(data) {\\n    function construct(arr) {\\n        if (!arr.length) {\\n            return null;\\n        }\\n        const root = new TreeNode(arr[0]);\\n        root.left = construct(arr.filter(num => num < root.val));\\n        root.right = construct(arr.filter(num => num > root.val));\\n        return root;\\n    }\\n    return construct(JSON.parse(data));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886500,
                "title": "serialize-and-deserialize-bst-python",
                "content": "```\\ndef serialize(self, root: TreeNode) -> str:\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return \\' \\'.join(map(str, vals))\\n        \\n        \\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val,maxVal)\\n                return node\\n\\n        return build(float(\\'-inf\\'), float(\\'inf\\'))\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef serialize(self, root: TreeNode) -> str:\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n\\n        return \\' \\'.join(map(str, vals))\\n        \\n        \\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val,maxVal)\\n                return node\\n\\n        return build(float(\\'-inf\\'), float(\\'inf\\'))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 605664,
                "title": "simple-javascript-solution",
                "content": "```\\nlet serialize = (root, result = []) => {\\n  if (root) {\\n    result.push(root.val);\\n    result.push(...serialize(root.left));\\n    result.push(...serialize(root.right));\\n  } else {\\n    result.push(null);\\n  }\\n  return result;\\n};\\n\\nlet deserialize = (data) => {\\n  let val = data.shift();\\n  if (val == null) return null;\\n  let node = new TreeNode(val);\\n  node.left = deserialize(data);\\n  node.right = deserialize(data);\\n  return node;\\n};\\n```\\n\\nSee more @ https://github.com/osdevisnot/leetcode",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet serialize = (root, result = []) => {\\n  if (root) {\\n    result.push(root.val);\\n    result.push(...serialize(root.left));\\n    result.push(...serialize(root.right));\\n  } else {\\n    result.push(null);\\n  }\\n  return result;\\n};\\n\\nlet deserialize = (data) => {\\n  let val = data.shift();\\n  if (val == null) return null;\\n  let node = new TreeNode(val);\\n  node.left = deserialize(data);\\n  node.right = deserialize(data);\\n  return node;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545174,
                "title": "c-level-order-serialization",
                "content": "We can use a queue serialize the tree level-by-level. If a child node is null, we just add a separator (instead of `null` or something to save space).\\n\\nFor example, this tree `[5,1,7,null,3,6,8,2,null,null]` will be serialized as `5,1,7,,3,6,8,2`.\\n\\n```cpp\\nstring serialize(TreeNode* root) {\\n    string res;\\n    vector<TreeNode*> q{root};\\n    while (!q.empty()) {\\n        vector<TreeNode*> q1;\\n        for (auto n : q) {\\n            res += (n == nullptr ? \"\" : to_string(n->val)) + \",\";\\n            if (n != nullptr) {\\n                q1.push_back(n->left);\\n                q1.push_back(n->right);                    \\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    while (!res.empty() && res.back() == \\',\\')\\n        res.pop_back();\\n    return res;\\n}\\nTreeNode* readNode(string& data, int &i) {\\n   string val;\\n   while (i < data.size() && data[i] != \\',\\')\\n        val += data[i++];\\n    ++i;\\n    return val.empty() ? nullptr : new TreeNode(stoi(val));\\n}\\nTreeNode* deserialize(string data) {\\n    TreeNode tmp;\\n    data = \",\" + data;\\n    vector<TreeNode*> q{&tmp};\\n    int i = 0;\\n    while (!q.empty()) {\\n        vector<TreeNode*> q1;\\n        for (auto n : q) {\\n            if (n != nullptr) {\\n                q1.push_back(n->left = readNode(data, i));\\n                q1.push_back(n->right = readNode(data, i));                \\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return tmp.right;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring serialize(TreeNode* root) {\\n    string res;\\n    vector<TreeNode*> q{root};\\n    while (!q.empty()) {\\n        vector<TreeNode*> q1;\\n        for (auto n : q) {\\n            res += (n == nullptr ? \"\" : to_string(n->val)) + \",\";\\n            if (n != nullptr) {\\n                q1.push_back(n->left);\\n                q1.push_back(n->right);                    \\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    while (!res.empty() && res.back() == \\',\\')\\n        res.pop_back();\\n    return res;\\n}\\nTreeNode* readNode(string& data, int &i) {\\n   string val;\\n   while (i < data.size() && data[i] != \\',\\')\\n        val += data[i++];\\n    ++i;\\n    return val.empty() ? nullptr : new TreeNode(stoi(val));\\n}\\nTreeNode* deserialize(string data) {\\n    TreeNode tmp;\\n    data = \",\" + data;\\n    vector<TreeNode*> q{&tmp};\\n    int i = 0;\\n    while (!q.empty()) {\\n        vector<TreeNode*> q1;\\n        for (auto n : q) {\\n            if (n != nullptr) {\\n                q1.push_back(n->left = readNode(data, i));\\n                q1.push_back(n->right = readNode(data, i));                \\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return tmp.right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426956,
                "title": "python-preorder-deque-solution-beats-98",
                "content": "```\\n\\tdef serialize(self, root):\\n        if not root:\\n            return \"X,\"\\n        return str(root.val) + \",\" + self.serialize(root.left) + self.serialize(root.right)\\n\\n    def deserialize(self, data):\\n        queue = collections.deque(data.split(\\',\\'))\\n        return self.deserializeHelper(queue)\\n    \\n    def deserializeHelper(self, queue):\\n        if queue:\\n            node = queue.popleft()\\n            if node == \\'X\\':\\n                return None\\n            new_node = TreeNode(node)\\n            new_node.left = self.deserializeHelper(queue)\\n            new_node.right = self.deserializeHelper(queue)\\n            return new_node",
                "solutionTags": [],
                "code": "```\\n\\tdef serialize(self, root):\\n        if not root:\\n            return \"X,\"\\n        return str(root.val) + \",\" + self.serialize(root.left) + self.serialize(root.right)\\n\\n    def deserialize(self, data):\\n        queue = collections.deque(data.split(\\',\\'))\\n        return self.deserializeHelper(queue)\\n    \\n    def deserializeHelper(self, queue):\\n        if queue:\\n            node = queue.popleft()\\n            if node == \\'X\\':\\n                return None\\n            new_node = TreeNode(node)\\n            new_node.left = self.deserializeHelper(queue)\\n            new_node.right = self.deserializeHelper(queue)\\n            return new_node",
                "codeTag": "Python3"
            },
            {
                "id": 887278,
                "title": "serialize-and-deserialize-bst-java-preorder-traversal",
                "content": "```\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        \\n        if(root==null) return \"\";\\n        \\n        List<String> data = new ArrayList<>();\\n        preorderTraversal(root, data);\\n        \\n        return String.join(\",\", data);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        \\n        if(data.length()==0) return null;\\n        \\n        String[] nodes= data.split(\",\");\\n        \\n        return convertPreorderTree( nodes, 0, nodes.length-1);\\n    }\\n    \\n    private void preorderTraversal(TreeNode root, List<String> data){\\n        \\n        if(root==null) return;\\n        \\n        data.add(\"\"+root.val);\\n        \\n        preorderTraversal(root.left, data);\\n        preorderTraversal(root.right, data);\\n    }\\n    \\n    private TreeNode convertPreorderTree(String[] preorder, int start, int end){\\n        \\n        if(start > end) return null;\\n        \\n        TreeNode node= new TreeNode(Integer.parseInt(preorder[start]));\\n        \\n        int i= start+1;\\n        while(i<=end && Integer.parseInt(preorder[i]) < Integer.parseInt(preorder[start])){\\n            i++;\\n        }\\n        \\n        node.left = convertPreorderTree(preorder, start+1, i-1);\\n        node.right = convertPreorderTree(preorder, i, end);\\n        \\n        return node;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        \\n        if(root==null) return \"\";\\n        \\n        List<String> data = new ArrayList<>();\\n        preorderTraversal(root, data);\\n        \\n        return String.join(\",\", data);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        \\n        if(data.length()==0) return null;\\n        \\n        String[] nodes= data.split(\",\");\\n        \\n        return convertPreorderTree( nodes, 0, nodes.length-1);\\n    }\\n    \\n    private void preorderTraversal(TreeNode root, List<String> data){\\n        \\n        if(root==null) return;\\n        \\n        data.add(\"\"+root.val);\\n        \\n        preorderTraversal(root.left, data);\\n        preorderTraversal(root.right, data);\\n    }\\n    \\n    private TreeNode convertPreorderTree(String[] preorder, int start, int end){\\n        \\n        if(start > end) return null;\\n        \\n        TreeNode node= new TreeNode(Integer.parseInt(preorder[start]));\\n        \\n        int i= start+1;\\n        while(i<=end && Integer.parseInt(preorder[i]) < Integer.parseInt(preorder[start])){\\n            i++;\\n        }\\n        \\n        node.left = convertPreorderTree(preorder, start+1, i-1);\\n        node.right = convertPreorderTree(preorder, i, end);\\n        \\n        return node;\\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2411860,
                "title": "two-approaches-20ms-easy-0ms-object-oriented",
                "content": "Solution 1:\\n```\\npublic class Codec { // 20ms solution\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root==null)return \"#\";\\n        return root.val+\" \"+serialize(root.left)+\" \"+serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    String[] arr;int index;\\n    public TreeNode deserialize(String data) {\\n        arr=data.split(\" \");\\n        index=0;\\n        return go();\\n    }\\n    \\n    private TreeNode go() {\\n        int index=this.index++;\\n        if(arr[index].equals(\"#\")) return null;\\n        TreeNode root = new TreeNode(Integer.valueOf(arr[index]));\\n        root.left=go();\\n        root.right=go();\\n        return root;\\n    }\\n}\\n```\\n\\nSolution 2:\\n```\\npublic class Codec { // 0ms solution\\n    static TreeNode node;\\n    public String serialize(TreeNode root) {\\n        node = root;\\n        return \"\";\\n    }\\n    public TreeNode deserialize(String data) {\\n        return node;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec { // 20ms solution\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root==null)return \"#\";\\n        return root.val+\" \"+serialize(root.left)+\" \"+serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    String[] arr;int index;\\n    public TreeNode deserialize(String data) {\\n        arr=data.split(\" \");\\n        index=0;\\n        return go();\\n    }\\n    \\n    private TreeNode go() {\\n        int index=this.index++;\\n        if(arr[index].equals(\"#\")) return null;\\n        TreeNode root = new TreeNode(Integer.valueOf(arr[index]));\\n        root.left=go();\\n        root.right=go();\\n        return root;\\n    }\\n}\\n```\n```\\npublic class Codec { // 0ms solution\\n    static TreeNode node;\\n    public String serialize(TreeNode root) {\\n        node = root;\\n        return \"\";\\n    }\\n    public TreeNode deserialize(String data) {\\n        return node;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420020,
                "title": "using-preorder-traversal",
                "content": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        res = []\\n        \\n        def dfs(root):\\n            if not root:\\n                res.append(\\'N\\')\\n                return\\n            \\n            res.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n        \\n        dfs(root)\\n        return \\',\\'.join(res)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        vals = data.split(\\',\\')\\n        self.i = 0\\n        \\n        def dfs():\\n            if vals[self.i] == \\'N\\':\\n                self.i += 1\\n                return None\\n            \\n            node = TreeNode(int(vals[self.i]))\\n            self.i += 1\\n            node.left = dfs()\\n            node.right = dfs()\\n            \\n            return node\\n        \\n        return dfs()\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        res = []\\n        \\n        def dfs(root):\\n            if not root:\\n                res.append(\\'N\\')\\n                return\\n            \\n            res.append(str(root.val))\\n            dfs(root.left)\\n            dfs(root.right)\\n        \\n        dfs(root)\\n        return \\',\\'.join(res)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        vals = data.split(\\',\\')\\n        self.i = 0\\n        \\n        def dfs():\\n            if vals[self.i] == \\'N\\':\\n                self.i += 1\\n                return None\\n            \\n            node = TreeNode(int(vals[self.i]))\\n            self.i += 1\\n            node.left = dfs()\\n            node.right = dfs()\\n            \\n            return node\\n        \\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887187,
                "title": "c-bfs-based-solution-explained-99-time-5-memory",
                "content": "I have to admit that I am still not great in all those tricks you can do with x-order traversals and then rebuild stuff using invariants. But I will get there; for now, I just wanted to have fun, so I went to solve it my own way, creating an encoding of comma-separated values (similar to how you build trees in LC\\'s input fields, just having empty strings instead of writing `\"null\"` there) on one hand and reading it on the others.\\n\\nTurned out my solution is still definitely efficient and can solve [a hard problem](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) without changing a single comma of it (okay, I admit before I set the value of empty nodes to `-1` and now I changed to `INT_MIN` to be compiant with the new rules, but that is about it).\\n\\nBut let\\'s proceed in order:\\n\\n## Encoding Part\\n\\nAs usual, edge cases out of the table first: if the tree is empty, we return just an empty string.\\n\\nIf not, we declare a few variables:\\n* `res`, a string initialised with the value of `root->val` converted to string;\\n* `len`, to store the length of our queue (more about it in just about one line!), initialised to `1` (since we know at least `root` is a valid node);\\n* `q`, a queue of `TreeNode` pointers, that we go and fill in immediately with `root`.\\n\\nThen we start with our BFS, which will loop as long as `len` is not `0`; inside, with another loop, we will keep removing the first `len` elements in front of the the queue and, for each one of them, we will:\\n* assign it to `root` (no need to create a new variable here);\\n* add a comma to `res`;\\n* if we have `root->left`, then we will:\\n\\t* add the stringified version of its value to `res`;\\n\\t* add the node itself to `q`;\\n* add another comma to `res`;\\n* if we have `root->right`, then we will:\\n\\t* add the stringified version of its value to `res`;\\n\\t* add the node itself to `q`.\\n\\nIf you try to proceed step-by-step, you will see that this will convert a starting tree to a format rather similar to the one used in LC\\'s custom inputs, just leaving an empty string where they put `\"null\"` as mentioned, to save space, and with possibly some extra trailing commas on the last level.\\n\\nIf you want to test yourself the logic with a non-trivial tree, try to put as a custom input `[100,90,110,80,95,105,115,70,null,null,98,104,106,null,200,60,75,null,99,null,null,null,107,116,201]` and it should give you back `\"100,90,110,80,95,105,115,70,,,98,104,106,,200,60,75,,99,,,,107,116,201,,,,,,,,,,,,\"`.\\n\\nOnce we are done, we can return `res` :)\\n\\n## Decoding Part\\n\\nSpecularly, first of all away with the edge cases: if the input string `ser` (short for \"serialised\", but also mirroring `res` above: how cool is that? Yeah, not much, but I am a simple man) is empty, we just return a `NULL` (=empty) tree.\\n\\nNow, support variables:\\n* `len`, similar to the one above, preset to `1` and used for the BFS approach;\\n* `nextVal`, where we will store what we read from each bit of serialisation;\\n* `root`, initialised with the first value read from the `ser` and our result variable, and `curr`, both `TreeNode` pointers;\\n* `q`, a queue of `TreeNode` pointers like the one above, initialised with `root`.\\n\\nEvery step of reading from the input string will be done using a class variable, `pos`, initialised to `0` and progressively incremented, and using the helper function `readString` that will take one character at a time (or no characters at all, for `NULL` nodes) to compose `res`, that will be then returned after being converted to a number (if not empty) or `INT_MIN` (if empty).\\n\\nIn our BFS, again same as above, we will loop until `len` is not `0` and internally we will extract at each round the first `len` nodes in front of `q`; I know here I could have just probably kept running until I had nodes in the queue, but I really enjoyed the symmetry of the 2 parts of the solution and I deem it important: elegant code is code that is more easily read, used and maintained.\\n\\nOr so I like to delude myself.\\n\\nAnyway, for each extracted node, we will:\\n* read from the input string `ser` and assign it to `nextVal`;\\n* if `nextVale` is not `INT_MIN`, we will then create a new `TreeNode` with that avalue, add it as a left branch to `curr` and push it into `q`;\\n* read again from the input string `s` and assign it to `nextVal`;\\n* if `nextVale` is not `INT_MIN`, we will then create a new `TreeNode` with that avalue, add it as a right branch to `curr` and push it into `q`,\\n\\nRinse and repeat until `q` is empty (`ser` will never be empty before it) and finally you can return `root` :)\\n\\nThe code:\\n\\n```cpp\\nclass Codec {\\npublic:\\n    // encoding logic\\n    string serialize(TreeNode* root) {\\n        // edge case out\\n        if (!root) return \"\";\\n        // support variables\\n        string res = to_string(root->val);\\n        int len = 1;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// BFS here!\\n        while (len) {\\n            while(len--) {\\n                // extracting the front of the queue\\n                root = q.front();\\n                q.pop();\\n                res += \\',\\';\\n                if (root->left) {\\n                    res += to_string(root->left->val);\\n                    // adding the next node only if meaningful - if it has children\\n                    q.push(root->left);\\n                }\\n                res += \\',\\';\\n                if (root->right) {\\n                    res += to_string(root->right->val);\\n                    // adding the next node only if meaningful - if it has children\\n                    q.push(root->right);\\n                }\\n            }\\n            len = q.size();\\n        }\\n        return res;\\n    }\\n    \\n    // decoding logic\\n    int pos = 0;\\n    int readString(string &s) {\\n        string tmp = \"\";\\n        while(pos < s.size() && s[pos] != \\',\\') tmp += s[pos++];\\n        pos++;\\n        return tmp.size() ? stoi(tmp) : INT_MIN;\\n    }\\n\\n    TreeNode* deserialize(string ser) {\\n        if (!ser.size()) return NULL;\\n        int len = 1, nextVal;\\n        TreeNode *root = new TreeNode(readString(ser)), *curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (len) {\\n            while(len--) {\\n                // extracting the front of the queue\\n                curr = q.front();\\n                q.pop();\\n                // adding left and right branches if present to both the tree and the queue\\n                nextVal = readString(ser);\\n                if (nextVal != INT_MIN) {\\n                    curr->left = new TreeNode(nextVal);\\n                    q.push(curr->left);\\n                }\\n                nextVal = readString(ser);\\n                if (nextVal != INT_MIN) {\\n                    curr->right = new TreeNode(nextVal);\\n                    q.push(curr->right);\\n                }\\n            }\\n            len = q.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Codec {\\npublic:\\n    // encoding logic\\n    string serialize(TreeNode* root) {\\n        // edge case out\\n        if (!root) return \"\";\\n        // support variables\\n        string res = to_string(root->val);\\n        int len = 1;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// BFS here!\\n        while (len) {\\n            while(len--) {\\n                // extracting the front of the queue\\n                root = q.front();\\n                q.pop();\\n                res += \\',\\';\\n                if (root->left) {\\n                    res += to_string(root->left->val);\\n                    // adding the next node only if meaningful - if it has children\\n                    q.push(root->left);\\n                }\\n                res += \\',\\';\\n                if (root->right) {\\n                    res += to_string(root->right->val);\\n                    // adding the next node only if meaningful - if it has children\\n                    q.push(root->right);\\n                }\\n            }\\n            len = q.size();\\n        }\\n        return res;\\n    }\\n    \\n    // decoding logic\\n    int pos = 0;\\n    int readString(string &s) {\\n        string tmp = \"\";\\n        while(pos < s.size() && s[pos] != \\',\\') tmp += s[pos++];\\n        pos++;\\n        return tmp.size() ? stoi(tmp) : INT_MIN;\\n    }\\n\\n    TreeNode* deserialize(string ser) {\\n        if (!ser.size()) return NULL;\\n        int len = 1, nextVal;\\n        TreeNode *root = new TreeNode(readString(ser)), *curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (len) {\\n            while(len--) {\\n                // extracting the front of the queue\\n                curr = q.front();\\n                q.pop();\\n                // adding left and right branches if present to both the tree and the queue\\n                nextVal = readString(ser);\\n                if (nextVal != INT_MIN) {\\n                    curr->left = new TreeNode(nextVal);\\n                    q.push(curr->left);\\n                }\\n                nextVal = readString(ser);\\n                if (nextVal != INT_MIN) {\\n                    curr->right = new TreeNode(nextVal);\\n                    q.push(curr->right);\\n                }\\n            }\\n            len = q.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201547,
                "title": "easy-to-understand-javascript-solution-84ms-beats-91",
                "content": "Serialize: push all nodes\\' value into an array in pre-order, and join them with \\',\\' or any non-numeric character\\n```\\nvar serialize = function(root) {\\n    if (root === null) return \\'\\';\\n    let result = [];\\n    serializeHelper(root, result);\\n    return result.join(\\',\\');\\n};\\n\\nconst serializeHelper = function(node, result) {\\n    if (node) {\\n        result.push(node.val);\\n        serializeHelper(node.left, result);\\n        serializeHelper(node.right, result);\\n    }\\n};\\n```\\nDeserialize: Split the data to get the pre-order array. Here we know two facts:\\n1. The input tree and all its sub-trees are BST, so all values from the left sub-tree are less than the value of root node, and all values from the right sub-tree are greater than the value of root node.\\n2. The array is a pre-order traversal of the tree, which means root always comes first, then left sub-tree (could be missing), then right sub-tree (could be missing).\\n\\nSo, the tree can be reconstructed by:\\n\\n1. Set array[0] as root and remove it from the array. \\n2. Check the new array[0]. It could be either root.left or root.right (when root.left is null). We can decide it by checking if array[0] is in the range of two sub-trees. These ranges are (currentLowerBound, root.val) and (root.val, currentUpperBound);\\n3. Do the same thing recursively to left and right subtree.\\n\\n```\\nvar deserialize = function(data) {\\n    if (!data) return null;\\n    const array = data.split(\\',\\');\\n    return deserializeHelper(array, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\\n};\\n\\nconst deserializeHelper = function(array, min, max) {\\n    if (array.length === 0) return null;\\n    let val = +array[0];\\n    if (val < min || val > max) return null;\\n    array.shift();\\n    let root = new TreeNode(val);\\n    root.left = deserializeHelper(array, min, val);\\n    root.right = deserializeHelper(array, val, max);\\n    return root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar serialize = function(root) {\\n    if (root === null) return \\'\\';\\n    let result = [];\\n    serializeHelper(root, result);\\n    return result.join(\\',\\');\\n};\\n\\nconst serializeHelper = function(node, result) {\\n    if (node) {\\n        result.push(node.val);\\n        serializeHelper(node.left, result);\\n        serializeHelper(node.right, result);\\n    }\\n};\\n```\n```\\nvar deserialize = function(data) {\\n    if (!data) return null;\\n    const array = data.split(\\',\\');\\n    return deserializeHelper(array, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\\n};\\n\\nconst deserializeHelper = function(array, min, max) {\\n    if (array.length === 0) return null;\\n    let val = +array[0];\\n    if (val < min || val > max) return null;\\n    array.shift();\\n    let root = new TreeNode(val);\\n    root.left = deserializeHelper(array, min, val);\\n    root.right = deserializeHelper(array, val, max);\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847876,
                "title": "golang-bfs-solution-o-n",
                "content": "```\\ntype Codec struct {\\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\nfunc (this *Codec) serialize(root *TreeNode) string {\\n    var queue []*TreeNode\\n\\n\\tenqueue(&queue, root)\\n\\n\\tvar result string\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tdequeuedElement := dequeue(&queue)\\n\\n\\t\\tif dequeuedElement != nil {\\n\\t\\t\\tresult = result + fmt.Sprintf(\"%v\", dequeuedElement.Val) + \",\"\\n\\t\\t\\tenqueue(&queue, dequeuedElement.Left)\\n\\t\\t\\tenqueue(&queue, dequeuedElement.Right)\\n\\t\\t} else {\\n\\t\\t\\tresult = result + \"nil\" + \",\"\\n\\t\\t}\\n\\t}\\n\\n\\treturn result[:len(result)-1]\\n}\\n\\nfunc (this *Codec) deserialize(data string) *TreeNode {    \\n    splittedData := strings.Split(data, \",\")\\n\\n\\tvar result []*TreeNode\\n\\n\\tfor _, num := range splittedData {\\n\\t\\tif num == \"nil\" {\\n\\t\\t\\tresult = append(result, nil)\\n\\t\\t} else {\\n\\t\\t\\titem := TreeNode{\\n\\t\\t\\t\\tVal: toInt(num),\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult = append(result, &item)\\n\\t\\t}\\n\\t}\\n    \\n    begin := 0\\n    \\n\\tfor _, node := range result {\\n\\t\\tif node == nil {\\n            continue\\n\\t\\t} else {\\n\\t\\t\\tleft := 2 * begin + 1\\n\\t\\t\\tright := 2 * begin + 2\\n\\n\\t\\t\\tif left < len(result) {\\n\\t\\t\\t\\tnode.Left = result[left]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif right < len(result) {\\n\\t\\t\\t\\tnode.Right = result[right]\\n\\t\\t\\t}\\n            \\n            begin++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result[0]\\n}\\n\\nfunc enqueue(queue *[]*TreeNode, newItem *TreeNode) {\\n\\tif queue == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\t*queue = append(*queue, newItem)\\n}\\n\\nfunc dequeue(queue *[]*TreeNode) *TreeNode {\\n\\tif queue == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\tif len(*queue) == 0 {\\n\\t\\tpanic(\"empty queue\")\\n\\t}\\n\\n\\tdequeuedElement := (*queue)[0]\\n\\n\\t*queue = (*queue)[1:len(*queue)]\\n\\n\\treturn dequeuedElement\\n}\\n\\nfunc toInt(s string) int {\\n\\tvalue, err := strconv.Atoi(s)\\n\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\n\\treturn value\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\ntype Codec struct {\\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\nfunc (this *Codec) serialize(root *TreeNode) string {\\n    var queue []*TreeNode\\n\\n\\tenqueue(&queue, root)\\n\\n\\tvar result string\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tdequeuedElement := dequeue(&queue)\\n\\n\\t\\tif dequeuedElement != nil {\\n\\t\\t\\tresult = result + fmt.Sprintf(\"%v\", dequeuedElement.Val) + \",\"\\n\\t\\t\\tenqueue(&queue, dequeuedElement.Left)\\n\\t\\t\\tenqueue(&queue, dequeuedElement.Right)\\n\\t\\t} else {\\n\\t\\t\\tresult = result + \"nil\" + \",\"\\n\\t\\t}\\n\\t}\\n\\n\\treturn result[:len(result)-1]\\n}\\n\\nfunc (this *Codec) deserialize(data string) *TreeNode {    \\n    splittedData := strings.Split(data, \",\")\\n\\n\\tvar result []*TreeNode\\n\\n\\tfor _, num := range splittedData {\\n\\t\\tif num == \"nil\" {\\n\\t\\t\\tresult = append(result, nil)\\n\\t\\t} else {\\n\\t\\t\\titem := TreeNode{\\n\\t\\t\\t\\tVal: toInt(num),\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult = append(result, &item)\\n\\t\\t}\\n\\t}\\n    \\n    begin := 0\\n    \\n\\tfor _, node := range result {\\n\\t\\tif node == nil {\\n            continue\\n\\t\\t} else {\\n\\t\\t\\tleft := 2 * begin + 1\\n\\t\\t\\tright := 2 * begin + 2\\n\\n\\t\\t\\tif left < len(result) {\\n\\t\\t\\t\\tnode.Left = result[left]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif right < len(result) {\\n\\t\\t\\t\\tnode.Right = result[right]\\n\\t\\t\\t}\\n            \\n            begin++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result[0]\\n}\\n\\nfunc enqueue(queue *[]*TreeNode, newItem *TreeNode) {\\n\\tif queue == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\t*queue = append(*queue, newItem)\\n}\\n\\nfunc dequeue(queue *[]*TreeNode) *TreeNode {\\n\\tif queue == nil {\\n\\t\\tpanic(\"nil pointer\")\\n\\t}\\n\\n\\tif len(*queue) == 0 {\\n\\t\\tpanic(\"empty queue\")\\n\\t}\\n\\n\\tdequeuedElement := (*queue)[0]\\n\\n\\t*queue = (*queue)[1:len(*queue)]\\n\\n\\treturn dequeuedElement\\n}\\n\\nfunc toInt(s string) int {\\n\\tvalue, err := strconv.Atoi(s)\\n\\n\\tif err != nil {\\n\\t\\tpanic(err)\\n\\t}\\n\\n\\treturn value\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886165,
                "title": "java-solution-with-explanation-using-an-example-for-better-understanding-queue-preorder",
                "content": "**EXPLANATION**\\n\\nTaking Example 1 of the question: ***BST = [2, 1, 3]***\\n\\n1. **SERIALIZE / ENCODE**: Use **Preorder Traversal** to serialize the BST where each node value is separated by a comma (**\",\"**).  So after serialization of the above tree, we will return a string like this: **2,1,3**.\\n\\n2. **DESERIALIZE / DECODE**: Here comes the importance of using **Preorder Traversal** in the above step.  By doing this, we ensured that all the parent nodes (roots) come before the children nodes *(all **left** nodes followed by all **right** nodes)*.  So all we have to do now is **Add** all the nodes in the string into a **Queue** and keep creating the tree node-by-node.  For this, the steps are:\\n\\ni) Repeat the below steps until **queue** is not empty.\\nii) Pop out a node from the front of the queue.  If the node is not null, then create a new node by using it\\'s value.\\niii) Recursively call the *Deserialize Function* to store all the **left children** first and then again to store all the **right children** of a particular node.\\niv) Return the node.\\n\\n*For example, our serialized string was **2,1,3***.  So we add them in the queue one-by-one.  So our **queue** looks like **[2,1,3]**.\\n\\nNow, popping **2** from the queue, we are left with **[1,3]**.\\n\\nRecursively call the function to store its left child.  New node is **1**, and both its **left child** and **right child** will be stored as null in the next two recursive calls.  So **1** gets stored as the **Left Child** of node **2**.  Similarly, **3** gets stored as the **Right Child** of node **2**.\\n\\nIn the end, we return node **2** which is the root of the deserialized tree. That\\'s it and you have your deserialized tree.\\n\\n*------Please **upvote** if you liked the solution.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize (TreeNode root) {\\n        if (root == null)\\n            return \"\";\\n        return String.valueOf (root.val) + \",\" + serialize (root.left) + \",\" + serialize (root.right);\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize (String data) {\\n        String S [] = data.split (\",\");\\n        Queue <String> queue = new LinkedList ();\\n        for (String s: S)\\n            queue.add (s);\\n        return deserializeUtil (queue);\\n    }\\n    \\n    public TreeNode deserializeUtil (Queue <String> queue) {\\n        while (!queue.isEmpty ()) {\\n            String s = queue.poll ();\\n            if (s.equals (\"\"))\\n                return null;\\n            TreeNode node = new TreeNode (Integer.valueOf (s));\\n            node.left = deserializeUtil (queue);\\n            node.right = deserializeUtil (queue);\\n            return node;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize (TreeNode root) {\\n        if (root == null)\\n            return \"\";\\n        return String.valueOf (root.val) + \",\" + serialize (root.left) + \",\" + serialize (root.right);\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize (String data) {\\n        String S [] = data.split (\",\");\\n        Queue <String> queue = new LinkedList ();\\n        for (String s: S)\\n            queue.add (s);\\n        return deserializeUtil (queue);\\n    }\\n    \\n    public TreeNode deserializeUtil (Queue <String> queue) {\\n        while (!queue.isEmpty ()) {\\n            String s = queue.poll ();\\n            if (s.equals (\"\"))\\n                return null;\\n            TreeNode node = new TreeNode (Integer.valueOf (s));\\n            node.left = deserializeUtil (queue);\\n            node.right = deserializeUtil (queue);\\n            return node;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208589,
                "title": "java-o-n-iterative-no-nulls",
                "content": "The whole point of this question is to use the BST property to at get rid of nulls in your serialized string (Question #297). Anything less is a suboptimal solution.\\n\\n  - To Serialize just do an iterative pre-order traversal. (in real world, recursive can stack overflow if BST is unbalanced)\\n  - To Deserialize:\\n\\t  - if next node is smaller then parent just (left) add to parent.\\n\\t  - if next node is larger then parent pop the stack until you find the largest parent you can (right) add to.\\n\\t  - finally stack the next node as a candidate parent.\\n\\nEach node gets in and out of stack only once, so time complexity `O(n)`, and the serialized string has no nulls, or markers only the nodes.\\n\\n```java\\n    public String serialize(TreeNode n) {\\n        if (n == null) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        while (n!=null) {\\n            sb.append(n.val).append(\",\");\\n            if (n.right != null) stack.push(n.right);\\n            n = (n.left == null && !stack.isEmpty()) ? stack.pop() : n.left;\\n        }\\n        sb.setLength(sb.length()-1);\\n        return sb.toString();\\n    }\\n\\n    public TreeNode deserialize(String s) {\\n        if (\"\".equals(s)) return null;\\n        String[] tokens = s.split(\",\");\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode head = new TreeNode(Integer.valueOf(tokens[0]));\\n        stack.push(head);\\n        \\n        for (int i=1;i<tokens.length;i++) {\\n            \\n            TreeNode parent = stack.peek();\\n            TreeNode next = new TreeNode(Integer.valueOf(tokens[i]));\\n            \\n            if (next.val < parent.val) parent.left = next;\\n            else {\\n                parent = stack.pop();\\n                while (!stack.isEmpty() && next.val > stack.peek().val) parent = stack.pop();\\n                parent.right = next;\\n            }\\n            stack.push(next);\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public String serialize(TreeNode n) {\\n        if (n == null) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        while (n!=null) {\\n            sb.append(n.val).append(\",\");\\n            if (n.right != null) stack.push(n.right);\\n            n = (n.left == null && !stack.isEmpty()) ? stack.pop() : n.left;\\n        }\\n        sb.setLength(sb.length()-1);\\n        return sb.toString();\\n    }\\n\\n    public TreeNode deserialize(String s) {\\n        if (\"\".equals(s)) return null;\\n        String[] tokens = s.split(\",\");\\n        \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode head = new TreeNode(Integer.valueOf(tokens[0]));\\n        stack.push(head);\\n        \\n        for (int i=1;i<tokens.length;i++) {\\n            \\n            TreeNode parent = stack.peek();\\n            TreeNode next = new TreeNode(Integer.valueOf(tokens[i]));\\n            \\n            if (next.val < parent.val) parent.left = next;\\n            else {\\n                parent = stack.pop();\\n                while (!stack.isEmpty() && next.val > stack.peek().val) parent = stack.pop();\\n                parent.right = next;\\n            }\\n            stack.push(next);\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93181,
                "title": "preorder-serialize-and-recursive-deserialize-c-26ms",
                "content": "```\\nclass Codec {\\npublic:\\n    //Encodes a tree to a single string.\\n    void serialize(TreeNode* root, vector<int> &val)\\n    {\\n        if(root == NULL) return;\\n        val.push_back(root->val);\\n        serialize(root->left, val);\\n        serialize(root->right, val);\\n    }\\n\\n    string serialize(TreeNode* root) {\\n        vector<int> val;\\n        serialize(root, val);\\n        char *p = (char*)val.data();\\n        string str(p, val.size() * sizeof(int));\\n        return str;\\n    }\\n    \\n    // deserialize val[l .. r]\\n    TreeNode* deserializeSubtree(int *val, int l, int r)\\n    {\\n        if(l > r) return NULL;\\n        TreeNode *subRoot = new TreeNode(val[l]);\\n        int i = l+1;\\n        while(i <= r && val[i] < val[l]) ++i; \\n        subRoot->left = deserializeSubtree(val, l+1, i-1);\\n        subRoot->right = deserializeSubtree(val, i, r);\\n        return subRoot;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        //preorder traversed string\\n        int n = data.size() / sizeof(int);\\n        TreeNode *root = deserializeSubtree((int*)data.data(), 0, n-1);\\n        return root;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n    //Encodes a tree to a single string.\\n    void serialize(TreeNode* root, vector<int> &val)\\n    {\\n        if(root == NULL) return;\\n        val.push_back(root->val);\\n        serialize(root->left, val);\\n        serialize(root->right, val);\\n    }\\n\\n    string serialize(TreeNode* root) {\\n        vector<int> val;\\n        serialize(root, val);\\n        char *p = (char*)val.data();\\n        string str(p, val.size() * sizeof(int));\\n        return str;\\n    }\\n    \\n    // deserialize val[l .. r]\\n    TreeNode* deserializeSubtree(int *val, int l, int r)\\n    {\\n        if(l > r) return NULL;\\n        TreeNode *subRoot = new TreeNode(val[l]);\\n        int i = l+1;\\n        while(i <= r && val[i] < val[l]) ++i; \\n        subRoot->left = deserializeSubtree(val, l+1, i-1);\\n        subRoot->right = deserializeSubtree(val, i, r);\\n        return subRoot;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        //preorder traversed string\\n        int n = data.size() / sizeof(int);\\n        TreeNode *root = deserializeSubtree((int*)data.data(), 0, n-1);\\n        return root;\\n    }\\n    \\n};",
                "codeTag": "Java"
            },
            {
                "id": 2674576,
                "title": "c-preorder-traversal-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        \\n        while (getline (ss, item, \\'-\\')) \\n            root = insert(root, stoi(item));\\n\\n        return root;\\n    }\\n    \\nprivate:\\n    string encode(TreeNode* root) {\\n        if (!root)\\n            return \"\";\\n        return to_string(root->val) + \"-\" + encode(root->left)+encode(root->right);\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int val) {\\n        if (root == NULL) {\\n\\t\\t\\tTreeNode* temp=new TreeNode(val);\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n    \\n\\t\\tif (val<=root->val)\\n\\t\\t\\troot->left=insert(root->left,val);\\n    \\n\\t\\telse\\n\\t\\t\\troot->right=insert(root->right,val);\\n    \\n\\t\\treturn root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        \\n        while (getline (ss, item, \\'-\\')) \\n            root = insert(root, stoi(item));\\n\\n        return root;\\n    }\\n    \\nprivate:\\n    string encode(TreeNode* root) {\\n        if (!root)\\n            return \"\";\\n        return to_string(root->val) + \"-\" + encode(root->left)+encode(root->right);\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int val) {\\n        if (root == NULL) {\\n\\t\\t\\tTreeNode* temp=new TreeNode(val);\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n    \\n\\t\\tif (val<=root->val)\\n\\t\\t\\troot->left=insert(root->left,val);\\n    \\n\\t\\telse\\n\\t\\t\\troot->right=insert(root->right,val);\\n    \\n\\t\\treturn root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197492,
                "title": "simple-c-code-preorder-traversal-queue-easy-to-understand",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root) return \"x,\";\\n        string l=serialize(root->left);\\n        string r=serialize(root->right);\\n        return to_string(root->val)+\",\"+l+r;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        queue<string> q;\\n        string s=\"\";\\n        for(int i=0;i<data.size();i++){\\n            if(data[i]==\\',\\'){\\n                q.push(s);\\n                s=\"\";\\n                continue;\\n            }\\n            s+=data[i];\\n        }\\n        return helper(q);\\n    }\\n    \\n    TreeNode* helper(queue<string> &q){\\n        string ch=q.front();\\n        q.pop();\\n        if(ch==\"x\") return NULL;\\n        TreeNode* root=new TreeNode(stoi(ch));\\n        root->left=helper(q);\\n        root->right=helper(q);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root) return \"x,\";\\n        string l=serialize(root->left);\\n        string r=serialize(root->right);\\n        return to_string(root->val)+\",\"+l+r;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        queue<string> q;\\n        string s=\"\";\\n        for(int i=0;i<data.size();i++){\\n            if(data[i]==\\',\\'){\\n                q.push(s);\\n                s=\"\";\\n                continue;\\n            }\\n            s+=data[i];\\n        }\\n        return helper(q);\\n    }\\n    \\n    TreeNode* helper(queue<string> &q){\\n        string ch=q.front();\\n        q.pop();\\n        if(ch==\"x\") return NULL;\\n        TreeNode* root=new TreeNode(stoi(ch));\\n        root->left=helper(q);\\n        root->right=helper(q);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094710,
                "title": "simple-c-solution-comment-your-thoughts-time-and-space-o-n",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root){\\n            return \"NULL\";\\n        }\\n        \\n        string left = serialize(root->left);\\n        string right = serialize(root->right);\\n        \\n        return to_string(root->val) + \" \" + left + \" \" + right;\\n    }\\n    \\n    TreeNode* helper_des(stringstream& ss, string s) {\\n        ss >> s;\\n        if(s == \"NULL\"){\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(stoi(s));\\n        \\n        root->left = helper_des(ss, s);\\n        root->right = helper_des(ss, s);\\n        \\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        return helper_des(ss, \"\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root){\\n            return \"NULL\";\\n        }\\n        \\n        string left = serialize(root->left);\\n        string right = serialize(root->right);\\n        \\n        return to_string(root->val) + \" \" + left + \" \" + right;\\n    }\\n    \\n    TreeNode* helper_des(stringstream& ss, string s) {\\n        ss >> s;\\n        if(s == \"NULL\"){\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(stoi(s));\\n        \\n        root->left = helper_des(ss, s);\\n        root->right = helper_des(ss, s);\\n        \\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        return helper_des(ss, \"\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091281,
                "title": "easy-java-solution-using-bst-property-similiar-to-validating-bst-problem",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    int serializedTreeIndexPointer;\\n    public String serialize(TreeNode root) {\\n      StringBuilder serializedTree = new StringBuilder();\\n      preorder(root, serializedTree);\\n      return serializedTree.toString();\\n    }\\n    \\n   void preorder(TreeNode root, StringBuilder serializedTree) {\\n       if (root == null) {\\n          return;\\n       }\\n\\n        serializedTree.append(root.val).append(\",\");\\n        preorder(root.left, serializedTree);\\n        preorder(root.right, serializedTree);\\n   }\\n\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String serializedTree) {\\n        serializedTreeIndexPointer = 0;\\n        String serializedArray[] = serializedTree.split(\",\");\\n        return treeBuilder(serializedArray, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n\\n    }\\n    \\n    TreeNode treeBuilder(String serializedArray[], int min, int max) {\\n        if (serializedTreeIndexPointer >= serializedArray.length)\\n            return null;\\n        \\n        Integer a = parseStringToInt(serializedArray[serializedTreeIndexPointer]);\\n         if ( a == null || a > max || a < min) {\\n          return null;\\n         }\\n\\n       TreeNode root = new TreeNode(Integer.parseInt(serializedArray[serializedTreeIndexPointer++]));\\n       root.left = treeBuilder(serializedArray, min, root.val);\\n       root.right = treeBuilder(serializedArray, root.val, max);\\n        \\n       return root;\\n    }\\n    \\n    Integer parseStringToInt(String s) {\\n        try {\\n          return Integer.parseInt(s);\\n        }\\n        catch (NumberFormatException e) {\\n            return null;}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    int serializedTreeIndexPointer;\\n    public String serialize(TreeNode root) {\\n      StringBuilder serializedTree = new StringBuilder();\\n      preorder(root, serializedTree);\\n      return serializedTree.toString();\\n    }\\n    \\n   void preorder(TreeNode root, StringBuilder serializedTree) {\\n       if (root == null) {\\n          return;\\n       }\\n\\n        serializedTree.append(root.val).append(\",\");\\n        preorder(root.left, serializedTree);\\n        preorder(root.right, serializedTree);\\n   }\\n\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String serializedTree) {\\n        serializedTreeIndexPointer = 0;\\n        String serializedArray[] = serializedTree.split(\",\");\\n        return treeBuilder(serializedArray, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n\\n    }\\n    \\n    TreeNode treeBuilder(String serializedArray[], int min, int max) {\\n        if (serializedTreeIndexPointer >= serializedArray.length)\\n            return null;\\n        \\n        Integer a = parseStringToInt(serializedArray[serializedTreeIndexPointer]);\\n         if ( a == null || a > max || a < min) {\\n          return null;\\n         }\\n\\n       TreeNode root = new TreeNode(Integer.parseInt(serializedArray[serializedTreeIndexPointer++]));\\n       root.left = treeBuilder(serializedArray, min, root.val);\\n       root.right = treeBuilder(serializedArray, root.val, max);\\n        \\n       return root;\\n    }\\n    \\n    Integer parseStringToInt(String s) {\\n        try {\\n          return Integer.parseInt(s);\\n        }\\n        catch (NumberFormatException e) {\\n            return null;}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887438,
                "title": "python3-solution-explained-video-code-inorder-preorder",
                "content": "[](https://www.youtube.com/watch?v=g6Q1cpQvz8A)\\nhttps://www.youtube.com/watch?v=g6Q1cpQvz8A\\n```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        res = []\\n        \\n        def preorder(root):\\n            if root:\\n                res.append(str(root.val))\\n                preorder(root.left)\\n                preorder(root.right)\\n        \\n        preorder(root)\\n        return \" \".join(res)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        data = [int(x) for x in data.split()]\\n        \\n        def build(pre, inorder):\\n            if not pre:\\n                return None\\n            \\n            node = TreeNode(pre[0])\\n            temp = inorder.index(node.val)\\n            node.left = build(pre[1: temp + 1], inorder[:temp])\\n            node.right = build(pre[temp + 1 :], inorder[temp + 1 :])\\n            \\n            return node\\n        \\n        return build(data, sorted(data))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        res = []\\n        \\n        def preorder(root):\\n            if root:\\n                res.append(str(root.val))\\n                preorder(root.left)\\n                preorder(root.right)\\n        \\n        preorder(root)\\n        return \" \".join(res)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        data = [int(x) for x in data.split()]\\n        \\n        def build(pre, inorder):\\n            if not pre:\\n                return None\\n            \\n            node = TreeNode(pre[0])\\n            temp = inorder.index(node.val)\\n            node.left = build(pre[1: temp + 1], inorder[:temp])\\n            node.right = build(pre[temp + 1 :], inorder[temp + 1 :])\\n            \\n            return node\\n        \\n        return build(data, sorted(data))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886209,
                "title": "python-recursion",
                "content": "Serialize the pre-order traversal into a string. Reconstruct from this representation. Both functions can be implemented by recursion.\\n\\n```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        if not root:\\n            return \\'\\'\\n        s1 = self.serialize(root.left)\\n        s2 = self.serialize(root.right)\\n        ret = str(root.val)\\n        if s1: ret += \\' \\' + s1\\n        if s2: ret += \\' \\' + s2\\n        return ret\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        if not data:\\n            return []\\n        def recur(arr):\\n            this = TreeNode(arr[0])\\n            left = [e for e in arr[1:] if e<arr[0]]\\n            right = [e for e in arr[1:] if e>arr[0]]\\n            if left: this.left = recur(left)\\n            if right: this.right = recur(right)\\n            return this\\n        arr = data.strip().split(\\' \\')\\n        arr = [int(e) for e in arr]\\n        return recur(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        if not root:\\n            return \\'\\'\\n        s1 = self.serialize(root.left)\\n        s2 = self.serialize(root.right)\\n        ret = str(root.val)\\n        if s1: ret += \\' \\' + s1\\n        if s2: ret += \\' \\' + s2\\n        return ret\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        if not data:\\n            return []\\n        def recur(arr):\\n            this = TreeNode(arr[0])\\n            left = [e for e in arr[1:] if e<arr[0]]\\n            right = [e for e in arr[1:] if e>arr[0]]\\n            if left: this.left = recur(left)\\n            if right: this.right = recur(right)\\n            return this\\n        arr = data.strip().split(\\' \\')\\n        arr = [int(e) for e in arr]\\n        return recur(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733367,
                "title": "c-custom-low-level-data-mapping-no-strings-no-recursion-no-built-in-ds-simple-n-short",
                "content": "**Context :** This solution of mine uses a custom low-level raw data mapping representaion. There is no string parsing involved, no recursive approach is being used, and no built-in Data Structures are used. I have kept this code like all of my other published code as barebone C code as possible.\\n\\n**Details :** Before arriving at below custom data representation, I gave the string approach a try and was way slower due to the overhead in parsing, etc. So, I decided to redesign this in terms of my own custom data representation. In this representation, each of the node\\'s address\\'s LS-16bits act as key which get mapped onto unique 1-indexed numbers. These mapped indexes are then used as offsets for each of those nodes. Each node will refer to its child nodes using those offsets. Each node in the sequence of such nodes will hold the value of a specific node and its left-child-off and right-child-off. It took considerable time to get to this far but I feel it\\'s totally worth it!\\n\\n**NOTE :** My below solution works for both BST and Binary Tree as there is no dependency on the structure or organization of the nodes or values therin. Just choose the key/mask width as per the address-range(LS-bits) of node addresses. As I observed, for the other Binary Tree case, I had to consider at least 17 lower bits of node addresses for their unique mapping whereas for the below BST, 16 lower bits were sufficient. Hence, I use appropriate width for key type as uint32_t(for 17-bits case) and uint16_t(for 16-bits case) controlled by WIDE_RANGE feature macro.\\n\\n```\\n//#define WIDE_RANGE\\n\\n#ifdef WIDE_RANGE\\n#define KEY_MASK    0x1ffff\\ntypedef uint32_t keyy_t;\\n#else\\n#define KEY_MASK    0xffff\\ntypedef uint16_t keyy_t;\\n#endif // WIDE_RANGE\\n\\n#define KEY(a)      ((uintptr_t)(a) & KEY_MASK)\\n\\nstruct srlz_data {\\n    int val;\\n    keyy_t loff, roff;   \\n} __attribute__ ((packed));\\n\\nstruct srlz {\\n    size_t sz; // To help on-disk storage/retrieval, etc\\n    size_t n;\\n    struct srlz_data z[100000];\\n} __attribute__ ((packed));\\n    \\nchar* serialize(struct TreeNode* root) {\\n    int of[KEY_MASK] = { 0 }, i = 1, k;\\n    struct TreeNode *n[10000] = { root };\\n    struct srlz *d = malloc(sizeof *d);\\n    struct srlz_data *z = d->z;\\n    d->sz = sizeof *d;\\n    of[KEY(root)] = i++;        \\n    for (int f = 0, b = 1 ; root && f < b ; f++) {\\n        z[of[k = KEY(n[f])]].val = n[f]->val;\\n        z[of[k]].loff = n[f]->left ? of[KEY(n[b++] = n[f]->left)] = i++ : 0;\\n        z[of[k]].roff = n[f]->right ? of[KEY(n[b++] = n[f]->right)] = i++ : 0;\\n    }\\n    return d->n = root ? i : 0, (char *)d;\\n}\\n\\nstruct TreeNode* deserialize(char* data) {\\n    struct srlz *d = (void *)data;\\n    struct srlz_data *z = d->z + 1;\\n    size_t c = d->n;\\n    struct TreeNode *n[100000] = { [1] = c ? malloc(sizeof **n) : NULL };\\n    for (int i = 1 ; i < c ; n[i++]->val = z++->val) {\\n        n[i]->left = z->loff ? n[z->loff] = malloc(sizeof **n) : NULL;\\n        n[i]->right = z->roff ? n[z->roff] = malloc(sizeof **n) : NULL;\\n    }\\n    return n[1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//#define WIDE_RANGE\\n\\n#ifdef WIDE_RANGE\\n#define KEY_MASK    0x1ffff\\ntypedef uint32_t keyy_t;\\n#else\\n#define KEY_MASK    0xffff\\ntypedef uint16_t keyy_t;\\n#endif // WIDE_RANGE\\n\\n#define KEY(a)      ((uintptr_t)(a) & KEY_MASK)\\n\\nstruct srlz_data {\\n    int val;\\n    keyy_t loff, roff;   \\n} __attribute__ ((packed));\\n\\nstruct srlz {\\n    size_t sz; // To help on-disk storage/retrieval, etc\\n    size_t n;\\n    struct srlz_data z[100000];\\n} __attribute__ ((packed));\\n    \\nchar* serialize(struct TreeNode* root) {\\n    int of[KEY_MASK] = { 0 }, i = 1, k;\\n    struct TreeNode *n[10000] = { root };\\n    struct srlz *d = malloc(sizeof *d);\\n    struct srlz_data *z = d->z;\\n    d->sz = sizeof *d;\\n    of[KEY(root)] = i++;        \\n    for (int f = 0, b = 1 ; root && f < b ; f++) {\\n        z[of[k = KEY(n[f])]].val = n[f]->val;\\n        z[of[k]].loff = n[f]->left ? of[KEY(n[b++] = n[f]->left)] = i++ : 0;\\n        z[of[k]].roff = n[f]->right ? of[KEY(n[b++] = n[f]->right)] = i++ : 0;\\n    }\\n    return d->n = root ? i : 0, (char *)d;\\n}\\n\\nstruct TreeNode* deserialize(char* data) {\\n    struct srlz *d = (void *)data;\\n    struct srlz_data *z = d->z + 1;\\n    size_t c = d->n;\\n    struct TreeNode *n[100000] = { [1] = c ? malloc(sizeof **n) : NULL };\\n    for (int i = 1 ; i < c ; n[i++]->val = z++->val) {\\n        n[i]->left = z->loff ? n[z->loff] = malloc(sizeof **n) : NULL;\\n        n[i]->right = z->roff ? n[z->roff] = malloc(sizeof **n) : NULL;\\n    }\\n    return n[1];\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 494967,
                "title": "javascript-solution-preorder",
                "content": "### The idea\\n1. Utilize the fact BST can be reconstructed from preorder/postorder array\\n``` javascript\\nvar serialize = function(root) {\\n    let preorder = [];\\n    let dfs = function(node) {\\n        if (node==null) return;\\n        preorder.push(node.val);\\n        dfs(node.left);\\n        dfs(node.right);\\n    }\\n    dfs(root);\\n    return preorder.join(\\',\\');\\n};\\n\\n var deserialize = function(data) {\\n    if (data == \\'\\') return null;\\n    let preorder = data.split(\\',\\');\\n    let recur = function(lower, upper) {\\n        if (Number(preorder[0]) < lower || Number(preorder[0]) > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar serialize = function(root) {\\n    let preorder = [];\\n    let dfs = function(node) {\\n        if (node==null) return;\\n        preorder.push(node.val);\\n        dfs(node.left);\\n        dfs(node.right);\\n    }\\n    dfs(root);\\n    return preorder.join(\\',\\');\\n};\\n\\n var deserialize = function(data) {\\n    if (data == \\'\\') return null;\\n    let preorder = data.split(\\',\\');\\n    let recur = function(lower, upper) {\\n        if (Number(preorder[0]) < lower || Number(preorder[0]) > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165387,
                "title": "recursive-preorder-python-solution-20-lines",
                "content": "```\\nclass Codec:\\n    \\n    def serialize(self, root):\\n        if not root: return\\n        def serializeTree(node):\\n            if not node:\\n                return \\'null\\'\\n            return str(node.val) + \",\" + serializeTree(node.left) + \",\" + serializeTree(node.right)\\n        return serializeTree(root)\\n        \\n\\n    def deserialize(self, data):\\n        if not data: return \\n        def deserializeTree(a, i):\\n            if i >= len(a) or a[i] == \\'null\\': \\n                return [None, i + 1]\\n            else:\\n                node = TreeNode(a[i])\\n                node.left, j = deserializeTree(a, i + 1)\\n                node.right, j = deserializeTree(a, j) \\n                return [node, j]\\n        return deserializeTree(data.split(\\',\\'), 0)[0]",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n    \\n    def serialize(self, root):\\n        if not root: return\\n        def serializeTree(node):\\n            if not node:\\n                return \\'null\\'\\n            return str(node.val) + \",\" + serializeTree(node.left) + \",\" + serializeTree(node.right)\\n        return serializeTree(root)\\n        \\n\\n    def deserialize(self, data):\\n        if not data: return \\n        def deserializeTree(a, i):\\n            if i >= len(a) or a[i] == \\'null\\': \\n                return [None, i + 1]\\n            else:\\n                node = TreeNode(a[i])\\n                node.left, j = deserializeTree(a, i + 1)\\n                node.right, j = deserializeTree(a, j) \\n                return [node, j]\\n        return deserializeTree(data.split(\\',\\'), 0)[0]",
                "codeTag": "Java"
            },
            {
                "id": 93212,
                "title": "simple-python-preorder",
                "content": "In ```serialize``` step we do a preorder traversal to get the string. For reconstructing the BST, ```l``` and ```r``` are the left and right boundaries of our ```current``` array. Since it's preorder traversal, for root value ```A[l]```, once we find the first point ```A[mid] < A[l]```, we know all values from this point until the right boundary are for the right subtree, and points before that until left boundary are the left subtree.\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def preorder(node):\\n            if node:\\n                res.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        res = []\\n        preorder(root)\\n        return \" \".join(res)\\n        \\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def build(l, r):\\n            if l >= r: return None\\n            root = TreeNode(A[l])\\n            mid = l+1\\n            while mid < r and A[mid] < root.val: mid += 1\\n            root.left = build(l+1, mid)\\n            root.right = build(mid, r)\\n            return root\\n            \\n        A = map(int, data.split())\\n        return build(0, len(A))\\n```",
                "solutionTags": [],
                "code": "```serialize```\n```l```\n```r```\n```current```\n```A[l]```\n```A[mid] < A[l]```\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        def preorder(node):\\n            if node:\\n                res.append(str(node.val))\\n                preorder(node.left)\\n                preorder(node.right)\\n        res = []\\n        preorder(root)\\n        return \" \".join(res)\\n        \\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def build(l, r):\\n            if l >= r: return None\\n            root = TreeNode(A[l])\\n            mid = l+1\\n            while mid < r and A[mid] < root.val: mid += 1\\n            root.left = build(l+1, mid)\\n            root.right = build(mid, r)\\n            return root\\n            \\n        A = map(int, data.split())\\n        return build(0, len(A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93261,
                "title": "java-o-n-recursive-solution",
                "content": "```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"*.\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val);\\n        if (root.left == null && root.right == null) {\\n            sb.append(\"*.\");\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        int[] begin = {0};\\n        return deserializeMethod(data, begin);\\n    }\\n\\n    private TreeNode deserializeMethod(String data, int[] begin) {\\n        int index = data.indexOf(\".\", begin[0]);\\n        TreeNode node = null;\\n        if (data.charAt(index - 1) == '*') {\\n            String str = data.substring(begin[0], index - 1);\\n            begin[0] = index + 1;\\n            if (str.equals(\"\")) {\\n                return null;\\n            }\\n            node = new TreeNode(Integer.parseInt(str));\\n        } else {\\n            String str = data.substring(begin[0], index);\\n            begin[0] = index + 1;\\n            node = new TreeNode(Integer.parseInt(str));\\n            node.left = deserializeMethod(data, begin);\\n            node.right = deserializeMethod(data, begin);\\n        }\\n        return node;\\n    }",
                "solutionTags": [],
                "code": "```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"*.\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val);\\n        if (root.left == null && root.right == null) {\\n            sb.append(\"*.\");\\n            return sb.toString();\\n        }\\n        sb.append(\".\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        int[] begin = {0};\\n        return deserializeMethod(data, begin);\\n    }\\n\\n    private TreeNode deserializeMethod(String data, int[] begin) {\\n        int index = data.indexOf(\".\", begin[0]);\\n        TreeNode node = null;\\n        if (data.charAt(index - 1) == '*') {\\n            String str = data.substring(begin[0], index - 1);\\n            begin[0] = index + 1;\\n            if (str.equals(\"\")) {\\n                return null;\\n            }\\n            node = new TreeNode(Integer.parseInt(str));\\n        } else {\\n            String str = data.substring(begin[0], index);\\n            begin[0] = index + 1;\\n            node = new TreeNode(Integer.parseInt(str));\\n            node.left = deserializeMethod(data, begin);\\n            node.right = deserializeMethod(data, begin);\\n        }\\n        return node;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 93265,
                "title": "2-concise-java-solutions-o-n-and-o-n2-with-using-bst-s-feature-not-the-old-generic-solution-for-binary-tree",
                "content": "**Idea:**\\nWe are given a BST, so it is possible to **reconstruct the tree by using Pre-Order traverse array**.\\n\\n*Notice we have 1 requirement \"The encoded string should be as compact as possible.\" So let us forget the generic BFS/DFS solution for Binary Tree (Adding \"#\" or \"NULL\" for empty node)*\\n\\n\\nSerialize:\\nVery straightforward, simplify do a pre-order traverse and append to String.\\n\\n* Version 1: Two lines\\n```\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"\";\\n        return root.val + \",\" + serialize(root.left) + serialize(root.right);\\n    }\\n```\\n\\n* Version 2: Use StringBuilder to save a little bit time.\\n```\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val).append(\",\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n```\\n\\nDeserialize\\nSince we have a pre-order array. We always know the **first element is the root**. \\nSo our strategy is to cut the array into different parts by appyling BST feature.\\n\\n* Version 1:  O(N2)\\n1.Passing start bound and end bound to helper function, which means to reconstruct tree in this scope (start ~ end).\\n2.Find the first element larger than current root, the first element index will be the middle cutting point. Which means all elements left to it need to be the **root.left**, all elements right after it need to be **root.right**. Recursively call the helper function.\\n```\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) return null;\\n        String[] sArr = data.split(\",\");\\n        return helper(sArr, 0, sArr.length - 1);\\n    }\\n    \\n    public TreeNode helper(String[] sArr, int start, int end) {\\n        if (start > end) return null;\\n        if (start == end) return new TreeNode(Integer.parseInt(sArr[start]));\\n        TreeNode node = new TreeNode(Integer.parseInt(sArr[start]));\\n        int mid = start + 1;\\n        while (mid <= end) {\\n            if (Integer.parseInt(sArr[mid]) > Integer.parseInt(sArr[start])) {\\n                break;\\n            }\\n            mid++;\\n        }\\n        node.left = helper(sArr, start + 1, mid - 1);\\n        node.right = helper(sArr, mid, end);\\n        return node;\\n    }\\n```\\n\\n\\n* Version 2: O(N)\\n1.Similar id to @cccrrryyy 's solution: https://discuss.leetcode.com/topic/66495/using-lower-bound-and-upper-bound-to-deserialize-bst\\n2.Pass a **min value (low bound)** and a **max value (high bound)** to helper function. \\n3.I use **int[] currIdx** to simulate a static index variable, cuz I really don't  like using a static/member/global variable.\\n```\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) return null;\\n        String[] sArr = data.split(\",\");\\n        int[] currIdx = {0};\\n        return helper(sArr, currIdx, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    public TreeNode helper(String[] sArr, int[] currIdx, int min, int max) {\\n        if (currIdx[0] > sArr.length - 1) return null;\\n        int curr = Integer.parseInt(sArr[currIdx[0]]);\\n\\n        if (curr < min || curr > max) return null;\\n\\n        TreeNode node = new TreeNode(curr);\\n        currIdx[0]++;\\n        node.left = helper(sArr, currIdx, min, curr);\\n        node.right = helper(sArr, currIdx, curr, max);\\n        return node;\\n\\n    }",
                "solutionTags": [],
                "code": "```\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"\";\\n        return root.val + \",\" + serialize(root.left) + serialize(root.right);\\n    }\\n```\n```\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(root.val).append(\",\");\\n        sb.append(serialize(root.left));\\n        sb.append(serialize(root.right));\\n        return sb.toString();\\n    }\\n```\n```\\n    public TreeNode deserialize(String data) {\\n        if (data == null || data.length() == 0) return null;\\n        String[] sArr = data.split(\",\");\\n        return helper(sArr, 0, sArr.length - 1);\\n    }\\n    \\n    public TreeNode helper(String[] sArr, int start, int end) {\\n        if (start > end) return null;\\n        if (start == end) return new TreeNode(Integer.parseInt(sArr[start]));\\n        TreeNode node = new TreeNode(Integer.parseInt(sArr[start]));\\n        int mid = start + 1;\\n        while (mid <= end) {\\n            if (Integer.parseInt(sArr[mid]) > Integer.parseInt(sArr[start])) {\\n                break;\\n            }\\n            mid++;\\n        }\\n        node.left = helper(sArr, start + 1, mid - 1);\\n        node.right = helper(sArr, mid, end);\\n        return node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3262799,
                "title": "simple-solution-using-level-order-traversal",
                "content": "\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL) return \"\";\\n\\n        string s = \"\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode *currNode = q.front();\\n            q.pop();\\n            if(currNode == NULL) s.append(\"#,\");\\n            else s.append(to_string(currNode->val) + \\',\\');\\n            if(currNode != NULL){\\n                q.push(currNode->left);\\n                q.push(currNode->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.size() == 0) return NULL;\\n        stringstream  s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode*root = new TreeNode(stoi(str));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode * node = q.front();\\n            q.pop();\\n\\n            getline(s,str,\\',\\');\\n            if(str == \"#\"){\\n                node->left = NULL;\\n            }\\n            else{\\n                TreeNode* leftNode = new TreeNode(stoi(str));\\n                node->left = leftNode;\\n                q.push(leftNode);\\n            }\\n            getline(s,str,\\',\\');\\n            if(str == \"#\"){\\n                node->right = NULL;\\n            }\\n            else{\\n                TreeNode* rightNode = new TreeNode(stoi(str));\\n                node->right = rightNode;\\n                q.push(rightNode);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL) return \"\";\\n\\n        string s = \"\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode *currNode = q.front();\\n            q.pop();\\n            if(currNode == NULL) s.append(\"#,\");\\n            else s.append(to_string(currNode->val) + \\',\\');\\n            if(currNode != NULL){\\n                q.push(currNode->left);\\n                q.push(currNode->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.size() == 0) return NULL;\\n        stringstream  s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode*root = new TreeNode(stoi(str));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode * node = q.front();\\n            q.pop();\\n\\n            getline(s,str,\\',\\');\\n            if(str == \"#\"){\\n                node->left = NULL;\\n            }\\n            else{\\n                TreeNode* leftNode = new TreeNode(stoi(str));\\n                node->left = leftNode;\\n                q.push(leftNode);\\n            }\\n            getline(s,str,\\',\\');\\n            if(str == \"#\"){\\n                node->right = NULL;\\n            }\\n            else{\\n                TreeNode* rightNode = new TreeNode(stoi(str));\\n                node->right = rightNode;\\n                q.push(rightNode);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743634,
                "title": "c-preorder-traversal-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) \\n{\\n   string str=\"\";\\n   fun(root,str);\\n   return str;          \\n}\\nvoid fun(TreeNode* root,string &str)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n    str.append(to_string(root->val));\\n    str.push_back(\\'-\\');\\n\\tfun(root->left,str);\\n\\tfun(root->right,str);\\n    \\n}\\n// Decodes your encoded data to tree.\\nTreeNode* deserialize(string str) \\n{\\n\\tTreeNode* root=NULL;\\n    string s=\"\";\\n    for(int i=0;i<str.length();i++)\\n    {\\n    \\tif(str[i]==\\'-\\')\\n    \\t{\\n    \\t\\tint num=stoi(s);\\n    \\t\\troot=fun(root,num);\\n    \\t\\ts.clear();\\n    \\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t   s.push_back(str[i]);\\t\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\nTreeNode* fun(TreeNode* root,int &num)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn new TreeNode(num);\\n\\t}\\n\\tif(num > root->val)\\n\\t{\\n\\t\\troot->right=fun(root->right,num);\\n\\t}\\n\\tif(num < root->val)\\n\\t{\\n\\t\\troot->left=fun(root->left,num);\\n\\t}\\n\\treturn root;\\n}\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) \\n{\\n   string str=\"\";\\n   fun(root,str);\\n   return str;          \\n}\\nvoid fun(TreeNode* root,string &str)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n    str.append(to_string(root->val));\\n    str.push_back(\\'-\\');\\n\\tfun(root->left,str);\\n\\tfun(root->right,str);\\n    \\n}\\n// Decodes your encoded data to tree.\\nTreeNode* deserialize(string str) \\n{\\n\\tTreeNode* root=NULL;\\n    string s=\"\";\\n    for(int i=0;i<str.length();i++)\\n    {\\n    \\tif(str[i]==\\'-\\')\\n    \\t{\\n    \\t\\tint num=stoi(s);\\n    \\t\\troot=fun(root,num);\\n    \\t\\ts.clear();\\n    \\t\\tcontinue;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t   s.push_back(str[i]);\\t\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\nTreeNode* fun(TreeNode* root,int &num)\\n{\\n\\tif(root==NULL)\\n\\t{\\n\\t\\treturn new TreeNode(num);\\n\\t}\\n\\tif(num > root->val)\\n\\t{\\n\\t\\troot->right=fun(root->right,num);\\n\\t}\\n\\tif(num < root->val)\\n\\t{\\n\\t\\troot->left=fun(root->left,num);\\n\\t}\\n\\treturn root;\\n}\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936631,
                "title": "python-dfs-easy-and-simple-solution",
                "content": "```\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        res = []\\n        \\n        def dfs(node):\\n            if not node:\\n                res.append(\"N\")\\n                return\\n            res.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n            \\n        dfs(root)\\n        return \",\".join(res)\\n        \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        vals = data.split(\",\")\\n        self.i = 0\\n        \\n        def dfs():\\n            if vals[self.i] == \"N\":\\n                self.i += 1\\n                return None\\n            node = TreeNode(int(vals[self.i]))\\n            self.i += 1\\n            node.left = dfs()\\n            node.right = dfs()\\n            return node\\n        return dfs()\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        res = []\\n        \\n        def dfs(node):\\n            if not node:\\n                res.append(\"N\")\\n                return\\n            res.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n            \\n        dfs(root)\\n        return \",\".join(res)\\n        \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        vals = data.split(\",\")\\n        self.i = 0\\n        \\n        def dfs():\\n            if vals[self.i] == \"N\":\\n                self.i += 1\\n                return None\\n            node = TreeNode(int(vals[self.i]))\\n            self.i += 1\\n            node.left = dfs()\\n            node.right = dfs()\\n            return node\\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164482,
                "title": "java-solution-level-order-traversal",
                "content": "# Level Order Traversal\\nNote that this is not the most compact solution and that this does not use the special property of binary search tree. It\\'s however simple to implement and does the job.\\n\\nTo Serialize:\\n* We traverse the BST in level order.\\n* We use a separator and append the node values to our string. We use `blank` (i.e. `\"\"`) character for the nulls to save some space.\\n\\nTo Deserialize:\\n* We split the string by separator.\\n* With the way we have serialized (we had also put nulls for all nodes) can use the binary tree property that for a parent at index `i`:\\n  * the left child will be at position `2 * i + 1`\\n  * the right child will be at position `2 * i + 2`\\n* We construct the tree by using queue. We process parent nodes and enqueue child nodes and continue this process until queue is empty.\\n\\n```\\npublic class Codec {\\n    \\n    public static final String SEPARATOR = \",\";\\n    public static final String EMPTY_STRING = \"\";\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        \\n        StringBuilder builder = new StringBuilder();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            TreeNode node = queue.poll();\\n            \\n            if(node!=null) {\\n                builder.append(node.val);\\n                queue.offer(node.left);\\n                queue.offer(node.right);\\n            } else {\\n                builder.append(EMPTY_STRING);\\n            }\\n            \\n            // append separator\\n            builder.append(SEPARATOR);\\n        }\\n        \\n        // rmeove last space\\n        builder.deleteCharAt(builder.length() - 1);\\n        \\n        return builder.toString();\\n    }\\n\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n\\n        String[] values = data.split(SEPARATOR);\\n        if(values[0].equals(EMPTY_STRING)) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(Integer.valueOf(values[0]));\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n       \\n        int parentIndex=0;\\n        while(!queue.isEmpty()) {\\n            \\n            TreeNode parent = queue.poll();\\n\\n            int leftChildIndex = 2 * parentIndex + 1;\\n            int rightChildIndex = 2 * parentIndex + 2; \\n            \\n            if(leftChildIndex < values.length) {\\n                if(values[leftChildIndex].equals(EMPTY_STRING)) {\\n                    parent.left = null;\\n                } else {\\n                    int val = Integer.valueOf(values[leftChildIndex]);\\n                    TreeNode leftChild = new TreeNode(val);\\n                    parent.left = leftChild;\\n                    queue.offer(leftChild);\\n                }\\n            }\\n\\n            if(rightChildIndex<values.length) {\\n                if(values[rightChildIndex].equals(EMPTY_STRING)) {\\n                    parent.right = null;\\n                } else {\\n                    int val = Integer.valueOf(values[rightChildIndex]);\\n                    TreeNode rightChild = new TreeNode(val);\\n                    parent.right = rightChild;\\n                    queue.offer(rightChild);\\n                }            \\n            }\\n\\n            parentIndex++;    \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    \\n    public static final String SEPARATOR = \",\";\\n    public static final String EMPTY_STRING = \"\";\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        \\n        StringBuilder builder = new StringBuilder();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            TreeNode node = queue.poll();\\n            \\n            if(node!=null) {\\n                builder.append(node.val);\\n                queue.offer(node.left);\\n                queue.offer(node.right);\\n            } else {\\n                builder.append(EMPTY_STRING);\\n            }\\n            \\n            // append separator\\n            builder.append(SEPARATOR);\\n        }\\n        \\n        // rmeove last space\\n        builder.deleteCharAt(builder.length() - 1);\\n        \\n        return builder.toString();\\n    }\\n\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n\\n        String[] values = data.split(SEPARATOR);\\n        if(values[0].equals(EMPTY_STRING)) {\\n            return null;\\n        }\\n\\n        TreeNode root = new TreeNode(Integer.valueOf(values[0]));\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n       \\n        int parentIndex=0;\\n        while(!queue.isEmpty()) {\\n            \\n            TreeNode parent = queue.poll();\\n\\n            int leftChildIndex = 2 * parentIndex + 1;\\n            int rightChildIndex = 2 * parentIndex + 2; \\n            \\n            if(leftChildIndex < values.length) {\\n                if(values[leftChildIndex].equals(EMPTY_STRING)) {\\n                    parent.left = null;\\n                } else {\\n                    int val = Integer.valueOf(values[leftChildIndex]);\\n                    TreeNode leftChild = new TreeNode(val);\\n                    parent.left = leftChild;\\n                    queue.offer(leftChild);\\n                }\\n            }\\n\\n            if(rightChildIndex<values.length) {\\n                if(values[rightChildIndex].equals(EMPTY_STRING)) {\\n                    parent.right = null;\\n                } else {\\n                    int val = Integer.valueOf(values[rightChildIndex]);\\n                    TreeNode rightChild = new TreeNode(val);\\n                    parent.right = rightChild;\\n                    queue.offer(rightChild);\\n                }            \\n            }\\n\\n            parentIndex++;    \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886404,
                "title": "python-simple-clean-and-short-solution",
                "content": "```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        def encode(root):\\n            return \"\" if not root else str(root.val) + \"-\" + encode(root.left)+encode(root.right)\\n\\n        return encode(root)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        def insert(root, val):\\n            if not root:\\n                return TreeNode(val)\\n\\n            if val <= root.val:\\n                root.left = insert(root.left,val)\\n\\n            else:\\n                root.right = insert(root.right,val)\\n\\n            return root\\n        \\n        root = None\\n        my_list = data.split(\"-\")\\n        my_list.pop(len(my_list)-1)\\n        for item in my_list:\\n            root = insert(root, int(item));\\n\\n        return root;\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        def encode(root):\\n            return \"\" if not root else str(root.val) + \"-\" + encode(root.left)+encode(root.right)\\n\\n        return encode(root)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        def insert(root, val):\\n            if not root:\\n                return TreeNode(val)\\n\\n            if val <= root.val:\\n                root.left = insert(root.left,val)\\n\\n            else:\\n                root.right = insert(root.right,val)\\n\\n            return root\\n        \\n        root = None\\n        my_list = data.split(\"-\")\\n        my_list.pop(len(my_list)-1)\\n        for item in my_list:\\n            root = insert(root, int(item));\\n\\n        return root;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641070,
                "title": "java-bfs-queue",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if(root ==null) return sb.toString();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode node = q.poll();\\n            if(node !=null){\\n                q.add(node.left);\\n                q.add(node.right);\\n                sb.append(node.val+\",\");\\n            }else{\\n                sb.append(\"#\"+\",\");\\n            }\\n        }\\n        return sb.toString();\\n        \\n    }\\n\\n    // Decodes encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        TreeNode head = null;\\n        if(data ==null || data.length() ==0) return head;\\n        String[] nodes = data.split(\",\");//get elements include null;\\n        TreeNode[] treeNodes = new TreeNode[nodes.length];//get a TreeNode array\\n        for(int i = 0; i<nodes.length; i++){\\n            if(! nodes[i].equals(\"#\") )\\n                treeNodes[i] = new TreeNode(Integer.valueOf(nodes[i]));//change non-null elem into node\\n        }\\n        for(int i =0,j=1; j<treeNodes.length;i++){\\n            if(treeNodes[i] != null){\\n                treeNodes[i].left = treeNodes[j++];\\n                treeNodes[i].right = treeNodes[j++];\\n            }\\n        }\\n        return treeNodes[0];       \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if(root ==null) return sb.toString();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode node = q.poll();\\n            if(node !=null){\\n                q.add(node.left);\\n                q.add(node.right);\\n                sb.append(node.val+\",\");\\n            }else{\\n                sb.append(\"#\"+\",\");\\n            }\\n        }\\n        return sb.toString();\\n        \\n    }\\n\\n    // Decodes encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        TreeNode head = null;\\n        if(data ==null || data.length() ==0) return head;\\n        String[] nodes = data.split(\",\");//get elements include null;\\n        TreeNode[] treeNodes = new TreeNode[nodes.length];//get a TreeNode array\\n        for(int i = 0; i<nodes.length; i++){\\n            if(! nodes[i].equals(\"#\") )\\n                treeNodes[i] = new TreeNode(Integer.valueOf(nodes[i]));//change non-null elem into node\\n        }\\n        for(int i =0,j=1; j<treeNodes.length;i++){\\n            if(treeNodes[i] != null){\\n                treeNodes[i].left = treeNodes[j++];\\n                treeNodes[i].right = treeNodes[j++];\\n            }\\n        }\\n        return treeNodes[0];       \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492943,
                "title": "javascript-preorder",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n  if(!root) return \\'\\'\\n  return \"\" + root.val + \\',\\' + serialize(root.left) + \\',\\' + serialize(root.right)\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    const arr = data.split(\\',\\')\\n    return helper(arr)\\n    \\n    function helper(arr) {\\n        const val = arr.shift()\\n        if(!val) return null \\n        const node = new TreeNode(val)\\n        node.left = helper(arr)\\n        node.right = helper(arr)\\n        return node\\n    }\\n    \\n    \\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n  if(!root) return \\'\\'\\n  return \"\" + root.val + \\',\\' + serialize(root.left) + \\',\\' + serialize(root.right)\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    const arr = data.split(\\',\\')\\n    return helper(arr)\\n    \\n    function helper(arr) {\\n        const val = arr.shift()\\n        if(!val) return null \\n        const node = new TreeNode(val)\\n        node.left = helper(arr)\\n        node.right = helper(arr)\\n        return node\\n    }\\n    \\n    \\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 479632,
                "title": "easy-to-follow-python-using-queue",
                "content": "```\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        q = collections.deque([root])\\n        res = []\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                q.append(node.left)\\n                q.append(node.right)\\n                res.append(str(node.val))\\n            else:\\n                res.append(\\'None\\')\\n        return \\' \\'.join(res)\\n    \\n    \\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        data_q = collections.deque(data.split(\\' \\'))\\n        root = TreeNode(int(data_q.popleft()))\\n        tree_q = collections.deque([root])\\n        while tree_q:\\n            node = tree_q.popleft()\\n            left = data_q.popleft()\\n            right = data_q.popleft()\\n            if left != \\'None\\':\\n                left_node = TreeNode(int(left))\\n                node.left = left_node\\n                tree_q.append(left_node)\\n            if right != \\'None\\':\\n                right_node = TreeNode(int(right))\\n                node.right = right_node\\n                tree_q.append(right_node)\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        q = collections.deque([root])\\n        res = []\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                q.append(node.left)\\n                q.append(node.right)\\n                res.append(str(node.val))\\n            else:\\n                res.append(\\'None\\')\\n        return \\' \\'.join(res)\\n    \\n    \\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        data_q = collections.deque(data.split(\\' \\'))\\n        root = TreeNode(int(data_q.popleft()))\\n        tree_q = collections.deque([root])\\n        while tree_q:\\n            node = tree_q.popleft()\\n            left = data_q.popleft()\\n            right = data_q.popleft()\\n            if left != \\'None\\':\\n                left_node = TreeNode(int(left))\\n                node.left = left_node\\n                tree_q.append(left_node)\\n            if right != \\'None\\':\\n                right_node = TreeNode(int(right))\\n                node.right = right_node\\n                tree_q.append(right_node)\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 285149,
                "title": "python-preorder-queue-solution-with-comments",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        # Pre-Order Traversal of Tree\\n        # Putting a marker to notify None/null, so we can recognize it during deserialization\\n        if root == None:\\n            return \\'X,\\'\\n        \\n        left_subtree = self.serialize(root.left) \\n        right_subtree = self.serialize(root.right)\\n        \\n        # Putting a delimiter on which we can split our string on during deserialization\\n        return str(root.val) + \",\" + left_subtree + right_subtree\\n    \\n    def deserializeHelper(self, data):\\n        # If we encounter our marker(\"X\") for None/null node, pop out from our queue(data) and return None\\n        # Also its our base condition!!!\\n        if data[0] == \"X\":\\n            del data[0]\\n            return None\\n        \\n        # Making a tree node with the front most element in the queue\\n        new_node = TreeNode(data[0])\\n        del data[0] # Popping our element from queue\\n        \\n        # When we encounter one \"X\" we move from left subtree to current(new_node) and when we encounter\\n        # two \"X\"\\'s we are moving to the parent (Just trying to explain the recursion taking place)\\n        new_node.left = self.deserializeHelper(data) \\n        new_node.right = self.deserializeHelper(data)\\n        \\n        return new_node\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        # Splitting our data on the delimeter we used during serialization\\n        data = data.split(\",\")\\n        del data[-1] # Last one will be None/null so omitting it\\n        return self.deserializeHelper(data)\\n       \\n# Thanks to BackToBackSWE (Youtube Channel) for helping me understand this question better\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.deserialize(codec.serialize(root))\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        # Pre-Order Traversal of Tree\\n        # Putting a marker to notify None/null, so we can recognize it during deserialization\\n        if root == None:\\n            return \\'X,\\'\\n        \\n        left_subtree = self.serialize(root.left) \\n        right_subtree = self.serialize(root.right)\\n        \\n        # Putting a delimiter on which we can split our string on during deserialization\\n        return str(root.val) + \",\" + left_subtree + right_subtree\\n    \\n    def deserializeHelper(self, data):\\n        # If we encounter our marker(\"X\") for None/null node, pop out from our queue(data) and return None\\n        # Also its our base condition!!!\\n        if data[0] == \"X\":\\n            del data[0]\\n            return None\\n        \\n        # Making a tree node with the front most element in the queue\\n        new_node = TreeNode(data[0])\\n        del data[0] # Popping our element from queue\\n        \\n        # When we encounter one \"X\" we move from left subtree to current(new_node) and when we encounter\\n        # two \"X\"\\'s we are moving to the parent (Just trying to explain the recursion taking place)\\n        new_node.left = self.deserializeHelper(data) \\n        new_node.right = self.deserializeHelper(data)\\n        \\n        return new_node\\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        # Splitting our data on the delimeter we used during serialization\\n        data = data.split(\",\")\\n        del data[-1] # Last one will be None/null so omitting it\\n        return self.deserializeHelper(data)\\n       \\n# Thanks to BackToBackSWE (Youtube Channel) for helping me understand this question better\\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.deserialize(codec.serialize(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146267,
                "title": "a-simple-solution-with-only-12-lines-of-code-beats-98",
                "content": "This solution utilizes a small array to hold the position of current value, which simplifies the code to the minimum.\\n\\n```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null) return \"#\";\\n        \\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] values = data.split(\",\");\\n        \\n        return deserialize(values, new int[1]);\\n    }\\n    \\n    private TreeNode deserialize(String[] values, int[] pos){\\n        if(\"#\".equals(values[pos[0]])){\\n            pos[0]++;\\n            return null;\\n        }\\n        \\n        TreeNode cur = new TreeNode(Integer.valueOf(values[pos[0]]));\\n        pos[0]++;\\n        \\n        cur.left = deserialize(values, pos);\\n        cur.right = deserialize(values, pos);\\n        \\n        return cur;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null) return \"#\";\\n        \\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] values = data.split(\",\");\\n        \\n        return deserialize(values, new int[1]);\\n    }\\n    \\n    private TreeNode deserialize(String[] values, int[] pos){\\n        if(\"#\".equals(values[pos[0]])){\\n            pos[0]++;\\n            return null;\\n        }\\n        \\n        TreeNode cur = new TreeNode(Integer.valueOf(values[pos[0]]));\\n        pos[0]++;\\n        \\n        cur.left = deserialize(values, pos);\\n        cur.right = deserialize(values, pos);\\n        \\n        return cur;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93195,
                "title": "python-solution-serializing-as-preorder-list",
                "content": "The remarkable difference from serialize/deserialize Binary Tree ( https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ ) is, **BST can be constructed just from its preorder array** while a general binary tree requires both [in-order and and pre-order](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/#/description ) or [in-order and post-order](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/#/description).\\n\\nSo for serializing BST, just perform a pre-order traversal and stringify the result array.\\nDeserialization can be also done in the same manner as:\\nhttp://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversal-set-2/\\n\\n```\\nclass Codec:\\n    def serialize(self, root):\\n        if not root:\\n            return \"none\"\\n        cur = root\\n        \\n        res = \"\"\\n        stack = []\\n        while cur:\\n            res += str(cur.val) + \",\"\\n            \\n            if cur.right:\\n                stack.append(cur)\\n            \\n            if cur.left:\\n                cur = cur.left\\n            elif not stack:\\n                break\\n            else:\\n                cur = stack.pop()\\n                cur = cur.right\\n        return res[:-1] # remove the last \",\"\\n          \\n    def deserialize(self, data):\\n        if data == \"none\":\\n            return None\\n        vals = data.split(\",\")\\n        root = TreeNode(int(vals[0]))\\n        cur = root\\n        \\n        stack = []\\n        for i in range(1, len(vals)):\\n            val = int(vals[i])\\n            \\n            if val < cur.val:\\n                cur.left = TreeNode(val)\\n                stack.append(cur)\\n                cur = cur.left\\n            else:\\n                while stack and cur.val < val:\\n                    if stack[-1].val < val:\\n                        cur = stack.pop()\\n                    else:\\n                        break\\n                cur.right = TreeNode(val)\\n                cur = cur.right\\n        return root\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root):\\n        if not root:\\n            return \"none\"\\n        cur = root\\n        \\n        res = \"\"\\n        stack = []\\n        while cur:\\n            res += str(cur.val) + \",\"\\n            \\n            if cur.right:\\n                stack.append(cur)\\n            \\n            if cur.left:\\n                cur = cur.left\\n            elif not stack:\\n                break\\n            else:\\n                cur = stack.pop()\\n                cur = cur.right\\n        return res[:-1] # remove the last \",\"\\n          \\n    def deserialize(self, data):\\n        if data == \"none\":\\n            return None\\n        vals = data.split(\",\")\\n        root = TreeNode(int(vals[0]))\\n        cur = root\\n        \\n        stack = []\\n        for i in range(1, len(vals)):\\n            val = int(vals[i])\\n            \\n            if val < cur.val:\\n                cur.left = TreeNode(val)\\n                stack.append(cur)\\n                cur = cur.left\\n            else:\\n                while stack and cur.val < val:\\n                    if stack[-1].val < val:\\n                        cur = stack.pop()\\n                    else:\\n                        break\\n                cur.right = TreeNode(val)\\n                cur = cur.right\\n        return root\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 93288,
                "title": "c-pre-order-serialize-very-compact-no-commas-no-null-no-separators",
                "content": "Here is the idea.  Each node can be serialized with a prefix char and and Abs value.  The prefix char acts as the separator and denotes the sign of the value and if the value has a left or right or both or is a leaf.\\n\\nI use this code but any similar codes could be used\\n```\\n'x' = leaf\\n'l' = left node only\\n'r' = right node only\\n'f' = full or both left and right\\n```\\n\\nif the value is negative I take the capitalization of the prefix\\n```\\n'X' = leaf and negative value\\n'L' = left node only and negative value\\n'R' = right node only and negative value\\n'F' = full or both left and right and negative value\\n```\\n\\nFor example:\\nA node with value \"2\" and a left node only\\n```\\nl2\\n```\\nA node with a value of \"-1234\" which is a leaf\\n```\\nX1234\\n```\\n\\nThese could be strung together to form a root \"2\" with left node leaf \"-1234\"\\n```\\nl2X1234\\n```\\n\\nThis could be further optimized by choosing codes in the upper alphabet and serializing numbers in hex.  And of course you could compact this even further by using a binary system and encoding as integers.  But I thought the main trick here of using the prefix was the piece I wanted to share.\\n\\n```\\n \\n    public class Codec\\n    {\\n        // Encodes a tree to a single string.\\n        public string serialize(TreeNode root)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            BuildSerialize(root, sb);\\n            return sb.ToString();\\n        }\\n\\n        // Decodes your encoded data to tree.\\n        public TreeNode deserialize(string data)\\n        {\\n            NodeIter nodeIter = new NodeIter(data);\\n            TreeNode root = this.BuildDeserialize(nodeIter);\\n            return root;\\n        }\\n\\n        private void BuildSerialize(TreeNode node, StringBuilder sb)\\n        {\\n            // pre-order\\n            if (node == null) return;\\n            sb.Append(SerializeNode(node));\\n            BuildSerialize(node.left, sb);\\n            BuildSerialize(node.right, sb);\\n        }\\n\\n        private string SerializeNode(TreeNode node)\\n        {\\n            if (node == null) return \"\";\\n\\n            char c = '$';\\n            if (node.left != null && node.right != null) c = 'f'; // full - both left and right\\n            else if (node.left != null) c = 'l'; // left only\\n            else if (node.right != null) c = 'r'; // right only\\n            else c = 'x'; // leaf\\n\\n            if (node.val < 0) c = Char.ToUpper(c); // negative value identified by upper case\\n\\n            return c.ToString() + Math.Abs(node.val).ToString();\\n        }\\n\\n        private TreeNode BuildDeserialize(NodeIter nodeIter)\\n        {\\n            TreeNode node = nodeIter.Next();\\n            if (node == null) return node;\\n            if (node.left != null)\\n            {\\n                node.left = BuildDeserialize(nodeIter);\\n            }\\n            if (node.right != null)\\n            {\\n                node.right = BuildDeserialize(nodeIter);\\n            }\\n            return node;\\n        }\\n    }\\n\\n    public class NodeIter\\n    {\\n        private string str = null;\\n        private int pos = 0;\\n        public NodeIter(string s)\\n        {\\n            this.str = s == null ? \"\" : s;\\n        }\\n\\n        public TreeNode Next()\\n        {\\n            TreeNode node = null;\\n            if (this.pos < this.str.Length)\\n            {\\n                node = new TreeNode(1);\\n                char c = this.str[this.pos];\\n                if (Char.IsUpper(c)) node.val = -1;\\n                switch (Char.ToLower(c))\\n                {\\n                    case 'x': break;\\n                    case 'l': node.left = new TreeNode(0); break;\\n                    case 'r': node.right = new TreeNode(0); break;\\n                    case 'f': node.left = new TreeNode(0); node.right = new TreeNode(0); break;\\n                    default: break;\\n                }\\n\\n                this.pos++;\\n                int val = 0;\\n                while (this.pos < this.str.Length && Char.IsDigit(this.str[this.pos]))\\n                {\\n                    val = val * 10 + this.str[this.pos] - '0';\\n                    this.pos++;\\n                }\\n                node.val *= val;\\n            }\\n            return node;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n'x' = leaf\\n'l' = left node only\\n'r' = right node only\\n'f' = full or both left and right\\n```\n```\\n'X' = leaf and negative value\\n'L' = left node only and negative value\\n'R' = right node only and negative value\\n'F' = full or both left and right and negative value\\n```\n```\\nl2\\n```\n```\\nX1234\\n```\n```\\nl2X1234\\n```\n```\\n \\n    public class Codec\\n    {\\n        // Encodes a tree to a single string.\\n        public string serialize(TreeNode root)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            BuildSerialize(root, sb);\\n            return sb.ToString();\\n        }\\n\\n        // Decodes your encoded data to tree.\\n        public TreeNode deserialize(string data)\\n        {\\n            NodeIter nodeIter = new NodeIter(data);\\n            TreeNode root = this.BuildDeserialize(nodeIter);\\n            return root;\\n        }\\n\\n        private void BuildSerialize(TreeNode node, StringBuilder sb)\\n        {\\n            // pre-order\\n            if (node == null) return;\\n            sb.Append(SerializeNode(node));\\n            BuildSerialize(node.left, sb);\\n            BuildSerialize(node.right, sb);\\n        }\\n\\n        private string SerializeNode(TreeNode node)\\n        {\\n            if (node == null) return \"\";\\n\\n            char c = '$';\\n            if (node.left != null && node.right != null) c = 'f'; // full - both left and right\\n            else if (node.left != null) c = 'l'; // left only\\n            else if (node.right != null) c = 'r'; // right only\\n            else c = 'x'; // leaf\\n\\n            if (node.val < 0) c = Char.ToUpper(c); // negative value identified by upper case\\n\\n            return c.ToString() + Math.Abs(node.val).ToString();\\n        }\\n\\n        private TreeNode BuildDeserialize(NodeIter nodeIter)\\n        {\\n            TreeNode node = nodeIter.Next();\\n            if (node == null) return node;\\n            if (node.left != null)\\n            {\\n                node.left = BuildDeserialize(nodeIter);\\n            }\\n            if (node.right != null)\\n            {\\n                node.right = BuildDeserialize(nodeIter);\\n            }\\n            return node;\\n        }\\n    }\\n\\n    public class NodeIter\\n    {\\n        private string str = null;\\n        private int pos = 0;\\n        public NodeIter(string s)\\n        {\\n            this.str = s == null ? \"\" : s;\\n        }\\n\\n        public TreeNode Next()\\n        {\\n            TreeNode node = null;\\n            if (this.pos < this.str.Length)\\n            {\\n                node = new TreeNode(1);\\n                char c = this.str[this.pos];\\n                if (Char.IsUpper(c)) node.val = -1;\\n                switch (Char.ToLower(c))\\n                {\\n                    case 'x': break;\\n                    case 'l': node.left = new TreeNode(0); break;\\n                    case 'r': node.right = new TreeNode(0); break;\\n                    case 'f': node.left = new TreeNode(0); node.right = new TreeNode(0); break;\\n                    default: break;\\n                }\\n\\n                this.pos++;\\n                int val = 0;\\n                while (this.pos < this.str.Length && Char.IsDigit(this.str[this.pos]))\\n                {\\n                    val = val * 10 + this.str[this.pos] - '0';\\n                    this.pos++;\\n                }\\n                node.val *= val;\\n            }\\n            return node;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93290,
                "title": "c-28ms-soluton-used-the-same-encoding-scheme-leetcode-uses-to-serialize-deserialize-tree-problem-i-o",
                "content": "#### Encoding scheme\\nFor below tree\\n```\\n    2\\n   / \\\\\\n  1   4\\n     / \\\\\\n    3   5\\n```\\nAfter serialization\\n```\\n2,1,4,#,#,3,5\\n```\\n#### Implementation\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\n    string getNextNode(string const& data, int& offset) {\\n        int end = data.find(',', offset);\\n        if(end == string::npos) {\\n            end = data.length();\\n        }\\n        string sNodeValue = data.substr(offset, end - offset);\\n        offset = end + 1;\\n        \\n        return sNodeValue;\\n    }\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string result = \"\";\\n        if(!root) return result;\\n        queue <TreeNode*> Q;\\n        Q.push(root);\\n        result += to_string(root->val);\\n        result += ',';\\n        while(!Q.empty()) {\\n            TreeNode* node = Q.front();\\n            if(node->left) {\\n                result += to_string(node->left->val);\\n                result += ',';\\n                Q.push(node->left);\\n            } else {\\n                result += \"#,\";\\n            }\\n            if(node->right) {\\n                result += to_string(node->right->val);\\n                result += ',';\\n                Q.push(node->right);\\n            } else {\\n                result += \"#,\";\\n            }\\n            Q.pop();\\n        }\\n        // triming , and # from end\\n        int i = result.size() - 1;\\n        for(--i; i >= 0 and result[i] == '#'; i -= 2);\\n        return result.substr(0, i + 1);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* root = nullptr;\\n        if(data.empty()) return root;\\n        queue<TreeNode*> Q;\\n        int offset = 0;\\n        int nodeValue = stoi(getNextNode(data, offset));\\n        root = new TreeNode(nodeValue);\\n        Q.push(root);\\n        while(!Q.empty()) {\\n            TreeNode* node = Q.front();\\n            if(offset < data.length()) {\\n                string sValue = getNextNode(data, offset);\\n                if(sValue != \"#\") {\\n                    int leftNodeValue = stoi(sValue);\\n                    node->left = new TreeNode(leftNodeValue);\\n                    Q.push(node->left);  \\n                }\\n            }\\n            if(offset < data.length()) {\\n                string sValue = getNextNode(data, offset);\\n                if(sValue != \"#\") {\\n                    int rightNodeValue = stoi(sValue);\\n                    node->right = new TreeNode(rightNodeValue);\\n                    Q.push(node->right);  \\n                }\\n            }\\n            Q.pop();\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));\\n```",
                "solutionTags": [],
                "code": "```\\n    2\\n   / \\\\\\n  1   4\\n     / \\\\\\n    3   5\\n```\n```\\n2,1,4,#,#,3,5\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\n    string getNextNode(string const& data, int& offset) {\\n        int end = data.find(',', offset);\\n        if(end == string::npos) {\\n            end = data.length();\\n        }\\n        string sNodeValue = data.substr(offset, end - offset);\\n        offset = end + 1;\\n        \\n        return sNodeValue;\\n    }\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string result = \"\";\\n        if(!root) return result;\\n        queue <TreeNode*> Q;\\n        Q.push(root);\\n        result += to_string(root->val);\\n        result += ',';\\n        while(!Q.empty()) {\\n            TreeNode* node = Q.front();\\n            if(node->left) {\\n                result += to_string(node->left->val);\\n                result += ',';\\n                Q.push(node->left);\\n            } else {\\n                result += \"#,\";\\n            }\\n            if(node->right) {\\n                result += to_string(node->right->val);\\n                result += ',';\\n                Q.push(node->right);\\n            } else {\\n                result += \"#,\";\\n            }\\n            Q.pop();\\n        }\\n        // triming , and # from end\\n        int i = result.size() - 1;\\n        for(--i; i >= 0 and result[i] == '#'; i -= 2);\\n        return result.substr(0, i + 1);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* root = nullptr;\\n        if(data.empty()) return root;\\n        queue<TreeNode*> Q;\\n        int offset = 0;\\n        int nodeValue = stoi(getNextNode(data, offset));\\n        root = new TreeNode(nodeValue);\\n        Q.push(root);\\n        while(!Q.empty()) {\\n            TreeNode* node = Q.front();\\n            if(offset < data.length()) {\\n                string sValue = getNextNode(data, offset);\\n                if(sValue != \"#\") {\\n                    int leftNodeValue = stoi(sValue);\\n                    node->left = new TreeNode(leftNodeValue);\\n                    Q.push(node->left);  \\n                }\\n            }\\n            if(offset < data.length()) {\\n                string sValue = getNextNode(data, offset);\\n                if(sValue != \"#\") {\\n                    int rightNodeValue = stoi(sValue);\\n                    node->right = new TreeNode(rightNodeValue);\\n                    Q.push(node->right);  \\n                }\\n            }\\n            Q.pop();\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93255,
                "title": "construct-bst-using-preorder-traversal",
                "content": "At first I thought this was the same as serialization/deserialization of a generic BT. Since the problem suggests minimal codec size and avoid using any external variable/function/etc I chose preorder and using stack to avoid using aux function. It can be made a little easier if using recursion I suppose. Also I think postorder works as well.\\n\\n\\n\\n    class Codec {\\n    public:\\n    \\n    \\t// Encodes a tree to a single string.\\n    \\tstring serialize(TreeNode* root) {\\n    \\t\\t// preorder traversal\\n    \\t\\tstring ret;\\n    \\t\\tif(!root) return ret;\\n    \\t\\t\\n    \\t\\tstack<TreeNode*> stk;\\n    \\t\\tstk.push(root);\\n    \\t\\twhile(!stk.empty()){\\n    \\t\\t\\tTreeNode *r = stk.top();\\n    \\t\\t\\tstk.pop();\\n    \\t\\t\\tret += to_string(r->val) + \",\";\\n    \\t\\t\\tif(r->right) stk.push(r->right);\\n    \\t\\t\\tif(r->left) stk.push(r->left);\\n    \\n    \\t\\t}\\n    \\t\\treturn ret.substr(0, ret.size()-1);\\n    \\t}\\n    \\n    \\t// Decodes your encoded data to tre.\\n    \\tTreeNode* deserialize(string data) {\\n    \\t    if(data.size() == 0) return nullptr;\\n    \\t    \\n    \\t\\tint id = 0;\\n    \\t\\t// take root at first\\n    \\t\\tint r = id;\\n    \\t\\twhile(isdigit(data[r])) r++;\\n    \\t\\tint v = stoi(data.substr(id, r-id));\\n    \\t\\tid = r+1;\\n    \\n    \\t\\tTreeNode *root = new TreeNode(v);\\n    \\t\\tstack<TreeNode*> stk;\\n    \\t\\tstk.push(root);\\n    \\n    \\t\\twhile(id < (int) data.size()) {\\n    \\t\\t\\tint r = id;\\n    \\t\\t\\twhile(isdigit(data[r]))\\tr++;\\n    \\t\\t\\tint v = stoi(data.substr(id, r - id));\\n    \\t\\t\\tid = r + 1;\\n    \\n    \\t\\t\\tTreeNode *node = nullptr;\\n    \\t\\t\\twhile(!stk.empty() && v > stk.top()->val) {\\n    \\t\\t\\t\\tnode = stk.top();\\n    \\t\\t\\t\\tstk.pop();\\n    \\t\\t\\t}\\n    \\t\\t\\tif(node) {\\n    \\t\\t\\t\\tnode->right = new TreeNode(v);\\n    \\t\\t\\t\\tstk.push(node->right);\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tstk.top()->left = new TreeNode(v);\\n    \\t\\t\\t\\tstk.push(stk.top()->left);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\treturn root;\\n    \\t}\\n    \\t// for debug\\n    \\tvoid f(TreeNode *root) {\\n    \\t\\tif(!root) return;\\n    \\t\\tf(root->left);\\n    \\t\\tcout << root->val << \", \";\\n    \\t\\tf(root->right);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "At first I thought this was the same as serialization/deserialization of a generic BT. Since the problem suggests minimal codec size and avoid using any external variable/function/etc I chose preorder and using stack to avoid using aux function. It can be made a little easier if using recursion I suppose. Also I think postorder works as well.\\n\\n\\n\\n    class Codec {\\n    public:\\n    \\n    \\t// Encodes a tree to a single string.\\n    \\tstring serialize(TreeNode* root) {\\n    \\t\\t// preorder traversal\\n    \\t\\tstring ret;\\n    \\t\\tif(!root) return ret;\\n    \\t\\t\\n    \\t\\tstack<TreeNode*> stk;\\n    \\t\\tstk.push(root);\\n    \\t\\twhile(!stk.empty()){\\n    \\t\\t\\tTreeNode *r = stk.top();\\n    \\t\\t\\tstk.pop();\\n    \\t\\t\\tret += to_string(r->val) + \",\";\\n    \\t\\t\\tif(r->right) stk.push(r->right);\\n    \\t\\t\\tif(r->left) stk.push(r->left);\\n    \\n    \\t\\t}\\n    \\t\\treturn ret.substr(0, ret.size()-1);\\n    \\t}\\n    \\n    \\t// Decodes your encoded data to tre.\\n    \\tTreeNode* deserialize(string data) {\\n    \\t    if(data.size() == 0) return nullptr;\\n    \\t    \\n    \\t\\tint id = 0;\\n    \\t\\t// take root at first\\n    \\t\\tint r = id;\\n    \\t\\twhile(isdigit(data[r])) r++;\\n    \\t\\tint v = stoi(data.substr(id, r-id));\\n    \\t\\tid = r+1;\\n    \\n    \\t\\tTreeNode *root = new TreeNode(v);\\n    \\t\\tstack<TreeNode*> stk;\\n    \\t\\tstk.push(root);\\n    \\n    \\t\\twhile(id < (int) data.size()) {\\n    \\t\\t\\tint r = id;\\n    \\t\\t\\twhile(isdigit(data[r]))\\tr++;\\n    \\t\\t\\tint v = stoi(data.substr(id, r - id));\\n    \\t\\t\\tid = r + 1;\\n    \\n    \\t\\t\\tTreeNode *node = nullptr;\\n    \\t\\t\\twhile(!stk.empty() && v > stk.top()->val) {\\n    \\t\\t\\t\\tnode = stk.top();\\n    \\t\\t\\t\\tstk.pop();\\n    \\t\\t\\t}\\n    \\t\\t\\tif(node) {\\n    \\t\\t\\t\\tnode->right = new TreeNode(v);\\n    \\t\\t\\t\\tstk.push(node->right);\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tstk.top()->left = new TreeNode(v);\\n    \\t\\t\\t\\tstk.push(stk.top()->left);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\treturn root;\\n    \\t}\\n    \\t// for debug\\n    \\tvoid f(TreeNode *root) {\\n    \\t\\tif(!root) return;\\n    \\t\\tf(root->left);\\n    \\t\\tcout << root->val << \", \";\\n    \\t\\tf(root->right);\\n    \\t}\\n    };",
                "codeTag": "C++"
            },
            {
                "id": 4031517,
                "title": "3-line-code-only-100-faster-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    static TreeNode res;\\n    public String serialize(TreeNode root) {\\n        res=root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return res;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser = new Codec();\\n// Codec deser = new Codec();\\n// String tree = ser.serialize(root);\\n// TreeNode ans = deser.deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    static TreeNode res;\\n    public String serialize(TreeNode root) {\\n        res=root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return res;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser = new Codec();\\n// Codec deser = new Codec();\\n// String tree = ser.serialize(root);\\n// TreeNode ans = deser.deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302829,
                "title": "c-serialize-deserialize-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string s=\"\";\\n        if(!root){\\n            return s;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            if(!node){\\n                s+=\"#,\";\\n            }\\n            else{\\n                s+=to_string(node->val)+\\',\\';\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()){return NULL;}\\n        string s=\"\";\\n        stringstream x(data);\\n        getline(x, s, \\',\\');\\n        TreeNode* root=new TreeNode(stoi(s));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            getline(x, s, \\',\\');\\n            if(s==\"#\"){\\n                node->left=NULL;\\n            }\\n            else{\\n                TreeNode* lft=new TreeNode(stoi(s));\\n                node->left=lft;\\n                q.push(lft);\\n            }\\n            getline(x, s, \\',\\');\\n            if(s==\"#\"){\\n                node->right=NULL;\\n            }\\n            else{\\n                TreeNode* rgt=new TreeNode(stoi(s));\\n                node->right=rgt;\\n                q.push(rgt);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string s=\"\";\\n        if(!root){\\n            return s;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            if(!node){\\n                s+=\"#,\";\\n            }\\n            else{\\n                s+=to_string(node->val)+\\',\\';\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()){return NULL;}\\n        string s=\"\";\\n        stringstream x(data);\\n        getline(x, s, \\',\\');\\n        TreeNode* root=new TreeNode(stoi(s));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            getline(x, s, \\',\\');\\n            if(s==\"#\"){\\n                node->left=NULL;\\n            }\\n            else{\\n                TreeNode* lft=new TreeNode(stoi(s));\\n                node->left=lft;\\n                q.push(lft);\\n            }\\n            getline(x, s, \\',\\');\\n            if(s==\"#\"){\\n                node->right=NULL;\\n            }\\n            else{\\n                TreeNode* rgt=new TreeNode(stoi(s));\\n                node->right=rgt;\\n                q.push(rgt);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274720,
                "title": "449-time-91-2-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor the serialize function:\\n\\n1. If the given root is None, return an empty string.\\n2. Create an empty stack and push the root node to it.\\n3. Create an empty string called serialized.\\n4. While the stack is not empty, pop a node from the stack.\\n5. If the node is None, append \"$,\" to the serialized string.\\n6. Otherwise, append the node\\'s value followed by \",\" to the serialized string.\\n7. Push the node\\'s right child to the stack (if it exists).\\n8. Push the node\\'s left child to the stack (if it exists).\\n9. Return the serialized string without the last comma.\\n\\nFor the deserialize function:\\n\\n1. If the given data string is empty, return None.\\n2. Split the data string by comma and create a deque called queue from the resulting list.\\n3. Call the _deserialize function with queue as the argument and return its result.\\n\\nFor the _deserialize function:\\n\\n1. Pop the leftmost value from the queue and store it in a variable called value.\\n2. If value is \"$\", return None.\\n3. Create a new TreeNode with the integer value of value.\\n4. Set the node\\'s left child to the result of calling _deserialize recursively with queue.\\n5. Set the node\\'s right child to the result of calling _deserialize recursively with queue.\\n6. Return the node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\"\"\"\\n        if not root:\\n            return \"\"\\n        stack = [root]\\n        serialized = \"\"\\n        while stack:\\n            node = stack.pop()\\n            if not node:\\n                serialized += \"$,\"\\n            else:\\n                serialized += str(node.val) + \",\"\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return serialized[:-1]\\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\"\"\"\\n        if not data:\\n            return None\\n        values = data.split(\",\")\\n        queue = deque(values)\\n        return self._deserialize(queue)\\n\\n    def _deserialize(self, queue: Deque[str]) -> Optional[TreeNode]:\\n        value = queue.popleft()\\n        if value == \"$\":\\n            return None\\n        node = TreeNode(int(value))\\n        node.left = self._deserialize(queue)\\n        node.right = self._deserialize(queue)\\n        return node\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\"\"\"\\n        if not root:\\n            return \"\"\\n        stack = [root]\\n        serialized = \"\"\\n        while stack:\\n            node = stack.pop()\\n            if not node:\\n                serialized += \"$,\"\\n            else:\\n                serialized += str(node.val) + \",\"\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return serialized[:-1]\\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\"\"\"\\n        if not data:\\n            return None\\n        values = data.split(\",\")\\n        queue = deque(values)\\n        return self._deserialize(queue)\\n\\n    def _deserialize(self, queue: Deque[str]) -> Optional[TreeNode]:\\n        value = queue.popleft()\\n        if value == \"$\":\\n            return None\\n        node = TreeNode(int(value))\\n        node.left = self._deserialize(queue)\\n        node.right = self._deserialize(queue)\\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051832,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to implement a serialization and deserialization method for a binary tree. The serialization method should take a binary tree and convert it into a string format, while the deserialization method should take the string format and convert it back into a binary tree.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe serialization method can be done by doing a breadth-first traversal of the tree and appending the values of the nodes to a list. If a node is None, append \"null\" to the list. After the traversal, join the list into a string using \",\" as the delimiter.\\n\\nThe deserialization method can be done by splitting the string into a list using \",\" as the delimiter. Create the root node using the first element in the list and append it to a queue. Then, for each element in the list, starting from the second element, check if the element is \"null\" or not. If it is not \"null\", create a new node with that value and append it to the left or right of the current node in the queue, depending on whether it is the left or right child. Append the new node to the queue as well. Repeat this process until all elements in the list have been processed.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root:\\n            return \"\"\\n        queue = [root]\\n        output = []\\n        while queue:\\n            current = queue.pop(0)\\n            if current:\\n                output.append(str(current.val))\\n                queue.append(current.left)\\n                queue.append(current.right)\\n            else:\\n                output.append(\"null\")\\n        return \",\".join(output)\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        data = data.split(\",\")\\n        root = TreeNode(int(data[0]))\\n        queue = [root]\\n        i = 1\\n        while queue:\\n            current = queue.pop(0)\\n            if data[i] != \"null\":\\n                current.left = TreeNode(int(data[i]))\\n                queue.append(current.left)\\n            i += 1\\n            if data[i] != \"null\":\\n                current.right = TreeNode(int(data[i]))\\n                queue.append(current.right)\\n            i += 1\\n        return root\\n\\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root:\\n            return \"\"\\n        queue = [root]\\n        output = []\\n        while queue:\\n            current = queue.pop(0)\\n            if current:\\n                output.append(str(current.val))\\n                queue.append(current.left)\\n                queue.append(current.right)\\n            else:\\n                output.append(\"null\")\\n        return \",\".join(output)\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        data = data.split(\",\")\\n        root = TreeNode(int(data[0]))\\n        queue = [root]\\n        i = 1\\n        while queue:\\n            current = queue.pop(0)\\n            if data[i] != \"null\":\\n                current.left = TreeNode(int(data[i]))\\n                queue.append(current.left)\\n            i += 1\\n            if data[i] != \"null\":\\n                current.right = TreeNode(int(data[i]))\\n                queue.append(current.right)\\n            i += 1\\n        return root\\n\\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747947,
                "title": "short-and-clean-solution",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) {\\n        if(!root)return \"#\";\\n        return to_string(root->val)+\"#\"+serialize(root->left) + serialize(root->right);\\n    }\\n    TreeNode* decode(stringstream& take,string res = \"\"){\\n        getline(take,res,\\'#\\');\\n        if(res.empty())return NULL;\\n        \\n        TreeNode* root= new TreeNode(stoi(res));\\n        root->left = decode(take), root->right = decode(take);\\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream take(data);\\n        return decode(take);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) {\\n        if(!root)return \"#\";\\n        return to_string(root->val)+\"#\"+serialize(root->left) + serialize(root->right);\\n    }\\n    TreeNode* decode(stringstream& take,string res = \"\"){\\n        getline(take,res,\\'#\\');\\n        if(res.empty())return NULL;\\n        \\n        TreeNode* root= new TreeNode(stoi(res));\\n        root->left = decode(take), root->right = decode(take);\\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream take(data);\\n        return decode(take);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254332,
                "title": "java-simple-preorder-solution",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public void preorder(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            sb.append(\"n\" + \"/\");\\n            return;\\n        }\\n        sb.append(root.val + \"/\");\\n        preorder(root.left, sb);\\n        preorder(root.right, sb);\\n    }\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        preorder(root, sb);\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode constructTree(String preorder[], int index[], int end) {\\n        if (index[0] > end) return null;\\n        if (preorder[index[0]].equals(\"n\")) {\\n            index[0] += 1;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(preorder[index[0]]));\\n        index[0] += 1;\\n        root.left = constructTree(preorder, index, end);\\n        root.right = constructTree(preorder, index, end);\\n        return root;\\n    }\\n\\n    public TreeNode deserialize(String data) {\\n        String preorder[] = data.split(\"/\");\\n        TreeNode root = constructTree(preorder, new int[1], preorder.length - 1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public void preorder(TreeNode root, StringBuilder sb) {\\n        if (root == null) {\\n            sb.append(\"n\" + \"/\");\\n            return;\\n        }\\n        sb.append(root.val + \"/\");\\n        preorder(root.left, sb);\\n        preorder(root.right, sb);\\n    }\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        preorder(root, sb);\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode constructTree(String preorder[], int index[], int end) {\\n        if (index[0] > end) return null;\\n        if (preorder[index[0]].equals(\"n\")) {\\n            index[0] += 1;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(preorder[index[0]]));\\n        index[0] += 1;\\n        root.left = constructTree(preorder, index, end);\\n        root.right = constructTree(preorder, index, end);\\n        return root;\\n    }\\n\\n    public TreeNode deserialize(String data) {\\n        String preorder[] = data.split(\"/\");\\n        TreeNode root = constructTree(preorder, new int[1], preorder.length - 1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707052,
                "title": "c-simple-level-order-traversal",
                "content": "\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root==NULL)\\n            return \"\";\\n        string s=\"\";\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            \\n            if(temp==NULL)\\n            {\\n                s.append(\"#,\");\\n            }\\n            else\\n            {\\n                s.append(to_string(temp->val)+\\',\\');\\n            }\\n            \\n            if(temp!=NULL)\\n            {\\n                q.push(temp->left);\\n                q.push(temp->right);\\n            }\\n        }\\n\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.length()==0)\\n            return NULL;\\n        \\n        stringstream s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode* root=new TreeNode(stoi(str));\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\")\\n            {\\n                temp->left=NULL;\\n            }\\n            else\\n            {\\n                TreeNode* leftNode=new TreeNode(stoi(str));\\n                temp->left=leftNode;\\n                q.push(leftNode);\\n            }\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\")\\n            {\\n                temp->right=NULL;\\n            }\\n            else\\n            {\\n                TreeNode* rightNode=new TreeNode(stoi(str));\\n                temp->right=rightNode;\\n                q.push(rightNode);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n\\n",
                "solutionTags": [
                    "String",
                    "Queue"
                ],
                "code": "\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root==NULL)\\n            return \"\";\\n        string s=\"\";\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            \\n            if(temp==NULL)\\n            {\\n                s.append(\"#,\");\\n            }\\n            else\\n            {\\n                s.append(to_string(temp->val)+\\',\\');\\n            }\\n            \\n            if(temp!=NULL)\\n            {\\n                q.push(temp->left);\\n                q.push(temp->right);\\n            }\\n        }\\n\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.length()==0)\\n            return NULL;\\n        \\n        stringstream s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode* root=new TreeNode(stoi(str));\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* temp=q.front();\\n            q.pop();\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\")\\n            {\\n                temp->left=NULL;\\n            }\\n            else\\n            {\\n                TreeNode* leftNode=new TreeNode(stoi(str));\\n                temp->left=leftNode;\\n                q.push(leftNode);\\n            }\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\")\\n            {\\n                temp->right=NULL;\\n            }\\n            else\\n            {\\n                TreeNode* rightNode=new TreeNode(stoi(str));\\n                temp->right=rightNode;\\n                q.push(rightNode);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1391262,
                "title": "c-queue-and-preorder",
                "content": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n     string serialize(TreeNode* root) {\\n        if(!root) return \"x,\";\\n        string l=serialize(root->left);\\n        string r=serialize(root->right);\\n        return to_string(root->val)+\",\"+l+r;\\n    }\\n    \\n    TreeNode* deserializeHelper(queue<string>& q) {\\n        string ch=q.front();\\n        q.pop();\\n        if(ch==\"x\") return NULL;\\n        TreeNode* root=new TreeNode(stoi(ch));\\n        root->left=deserializeHelper(q);\\n        root->right=deserializeHelper(q);\\n        return root;       \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        queue<string> q;\\n        cout << data<< endl;\\n        while (ss.good()) {\\n            string str;\\n            getline(ss, str,\\',\\');\\n            q.push(str);\\n        }\\n        return deserializeHelper(q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n     string serialize(TreeNode* root) {\\n        if(!root) return \"x,\";\\n        string l=serialize(root->left);\\n        string r=serialize(root->right);\\n        return to_string(root->val)+\",\"+l+r;\\n    }\\n    \\n    TreeNode* deserializeHelper(queue<string>& q) {\\n        string ch=q.front();\\n        q.pop();\\n        if(ch==\"x\") return NULL;\\n        TreeNode* root=new TreeNode(stoi(ch));\\n        root->left=deserializeHelper(q);\\n        root->right=deserializeHelper(q);\\n        return root;       \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        queue<string> q;\\n        cout << data<< endl;\\n        while (ss.good()) {\\n            string str;\\n            getline(ss, str,\\',\\');\\n            q.push(str);\\n        }\\n        return deserializeHelper(q);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1365738,
                "title": "simple-straightforward-java-solution",
                "content": "Simple and easy to understand Java solution.\\n(Not the most efficient, due to the simple deserialization approach)\\n\\n```\\n    // since this is a binary search tree, we\\'ll just output values in BFS\\n    // order (when serializind), then add all values to the tree one by one (when deserializing)\\n    // serialize will take O(n)\\n    // deserialize will take O(n*h), where h is the height of the tree (n in the\\n    // worst case, and log(n) if the tree is balanced)\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            TreeNode n = q.remove();\\n            sb.append(n.val).append(\\',\\');\\n            if (n.left != null)\\n                q.add(n.left);\\n            if (n.right != null)\\n                q.add(n.right);\\n        }\\n        sb.setLength(sb.length()-1); // remove last \\',\\'\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null) {\\n            return null;\\n        }\\n        \\n        String[] vals = data.split(\",\");\\n        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));\\n        for (int i=1; i<vals.length; i++) {\\n            add(root, Integer.parseInt(vals[i]));\\n        }\\n        return root;\\n    }\\n    \\n    private static void add(TreeNode root, int val) {\\n        TreeNode cur = root;\\n        TreeNode parent = null;\\n        while (cur != null) {\\n            parent = cur;\\n            cur = (val <= cur.val) ? cur.left : cur.right;\\n        }\\n        if (val <= parent.val) {\\n            parent.left = new TreeNode(val);\\n        } else {\\n            parent.right = new TreeNode(val);\\n        }\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    // since this is a binary search tree, we\\'ll just output values in BFS\\n    // order (when serializind), then add all values to the tree one by one (when deserializing)\\n    // serialize will take O(n)\\n    // deserialize will take O(n*h), where h is the height of the tree (n in the\\n    // worst case, and log(n) if the tree is balanced)\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            TreeNode n = q.remove();\\n            sb.append(n.val).append(\\',\\');\\n            if (n.left != null)\\n                q.add(n.left);\\n            if (n.right != null)\\n                q.add(n.right);\\n        }\\n        sb.setLength(sb.length()-1); // remove last \\',\\'\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data == null) {\\n            return null;\\n        }\\n        \\n        String[] vals = data.split(\",\");\\n        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));\\n        for (int i=1; i<vals.length; i++) {\\n            add(root, Integer.parseInt(vals[i]));\\n        }\\n        return root;\\n    }\\n    \\n    private static void add(TreeNode root, int val) {\\n        TreeNode cur = root;\\n        TreeNode parent = null;\\n        while (cur != null) {\\n            parent = cur;\\n            cur = (val <= cur.val) ? cur.left : cur.right;\\n        }\\n        if (val <= parent.val) {\\n            parent.left = new TreeNode(val);\\n        } else {\\n            parent.right = new TreeNode(val);\\n        }\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1033310,
                "title": "serialize-deserialize-bst-bt",
                "content": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/\\nhttps://leetcode.com/problems/serialize-and-deserialize-bst/\\n\\nIn my opinion, although the first one is marked as hard, it is actually easier than the second one. Because for the second one, you need to utilize the binary search tree property and make the tree COMPACT as required by the problem. By compact it means you can\\'t append \"null\" values to indicate tree structure. Instead, you need to utilize bst properties to get tree structure.\\n\\nSolution for BST:\\n```\\npublic class Codec {\\n    int index = 0;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        \\n        //post order traveral: left, right, root\\n        StringBuilder sb = new StringBuilder();\\n        \\n        //left \\n        String left = serialize(root.left);\\n        if (left.length() > 0) {\\n            sb.append(left).append(\",\");\\n        }\\n        \\n        //right\\n        String right = serialize(root.right);\\n        if (right.length() > 0) {\\n            sb.append(right).append(\",\");\\n        }\\n        \\n        //root\\n        sb.append(root.val).append(\",\");\\n\\n        String result = sb.substring(0, sb.length() - 1).toString();\\n        return result;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.length() <= 0) {\\n            return null;\\n        }\\n        String[] array = data.split(\",\");\\n        index = array.length - 1;\\n        return helper(array, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n        \\n    public TreeNode helper(String[] array, int lower, int upper){\\n        if (index < 0) {\\n            return null;\\n        }\\n        int num = Integer.valueOf(array[index]);\\n        if (num < lower || num > upper) {\\n            return null;\\n        }\\n        index--;\\n        TreeNode root = new TreeNode(num);\\n        root.right = helper(array, num, upper);\\n        root.left = helper(array, lower, num);\\n        return root;\\n    }\\n}\\n```\\n\\nSolution for BT (Not this problem):\\n```\\npublic class Codec {\\n    int index = 0;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"null\";\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //preorder traversal\\n        sb.append(root.val)\\n            .append(\",\")\\n            .append(serialize(root.left))\\n            .append(\",\")\\n            .append(serialize(root.right));\\n\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] array = data.split(\",\");\\n        return helper(array);\\n    }\\n    \\n    public TreeNode helper(String[] array){\\n        if (array[index].equals(\"null\")) {\\n            index++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(array[index++]));\\n        root.left = helper(array);\\n        root.right = helper(array);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    int index = 0;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"\";\\n        }\\n        \\n        //post order traveral: left, right, root\\n        StringBuilder sb = new StringBuilder();\\n        \\n        //left \\n        String left = serialize(root.left);\\n        if (left.length() > 0) {\\n            sb.append(left).append(\",\");\\n        }\\n        \\n        //right\\n        String right = serialize(root.right);\\n        if (right.length() > 0) {\\n            sb.append(right).append(\",\");\\n        }\\n        \\n        //root\\n        sb.append(root.val).append(\",\");\\n\\n        String result = sb.substring(0, sb.length() - 1).toString();\\n        return result;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.length() <= 0) {\\n            return null;\\n        }\\n        String[] array = data.split(\",\");\\n        index = array.length - 1;\\n        return helper(array, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n        \\n    public TreeNode helper(String[] array, int lower, int upper){\\n        if (index < 0) {\\n            return null;\\n        }\\n        int num = Integer.valueOf(array[index]);\\n        if (num < lower || num > upper) {\\n            return null;\\n        }\\n        index--;\\n        TreeNode root = new TreeNode(num);\\n        root.right = helper(array, num, upper);\\n        root.left = helper(array, lower, num);\\n        return root;\\n    }\\n}\\n```\n```\\npublic class Codec {\\n    int index = 0;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"null\";\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //preorder traversal\\n        sb.append(root.val)\\n            .append(\",\")\\n            .append(serialize(root.left))\\n            .append(\",\")\\n            .append(serialize(root.right));\\n\\n        return sb.toString();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] array = data.split(\",\");\\n        return helper(array);\\n    }\\n    \\n    public TreeNode helper(String[] array){\\n        if (array[index].equals(\"null\")) {\\n            index++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(array[index++]));\\n        root.left = helper(array);\\n        root.right = helper(array);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003049,
                "title": "simple-python-solution-faster-than-98-16-detailed-comments-easy-to-understand",
                "content": "```\\n# O(n) time and space complexity for both serialization and \\n# deserialization\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        # if we see a None\\n        if not root:\\n            return \"-1\"\\n        # Otherwise we serialize root, roo.left and root.right\\n        # preorder traversal\\n        return str(root.val) + \",\"+self.serialize(root.left) + \",\" + self.serialize(root.right)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        # from preorder list to tree\\n        def helper(dq): \\n            # using the dq we deserialize one by one\\n            value = dq.popleft()\\n            # if we see -1, means we need to form null node\\n            if value == -1:\\n                return None\\n            # form the actual node\\n            node = TreeNode(value)\\n            # form node\\'s left\\n            node.left = helper(dq)\\n            # form node\\'s right\\n            node.right = helper(dq)\\n            \\n            return node\\n        \\n        # at first get the node integer vals from the serial of \\n        # the tree \\n        #print(data)\\n        data = map(int,data.split(\",\"))\\n        # form a deque needed to deserialize\\n        dq = deque(data)\\n        # we call helper with the deque list\\n        return helper(dq)\\n        \\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```\\nRuntime: 64 ms, faster than 98.16% of Python3 online submissions for Serialize and Deserialize BST.",
                "solutionTags": [],
                "code": "```\\n# O(n) time and space complexity for both serialization and \\n# deserialization\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        # if we see a None\\n        if not root:\\n            return \"-1\"\\n        # Otherwise we serialize root, roo.left and root.right\\n        # preorder traversal\\n        return str(root.val) + \",\"+self.serialize(root.left) + \",\" + self.serialize(root.right)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        # from preorder list to tree\\n        def helper(dq): \\n            # using the dq we deserialize one by one\\n            value = dq.popleft()\\n            # if we see -1, means we need to form null node\\n            if value == -1:\\n                return None\\n            # form the actual node\\n            node = TreeNode(value)\\n            # form node\\'s left\\n            node.left = helper(dq)\\n            # form node\\'s right\\n            node.right = helper(dq)\\n            \\n            return node\\n        \\n        # at first get the node integer vals from the serial of \\n        # the tree \\n        #print(data)\\n        data = map(int,data.split(\",\"))\\n        # form a deque needed to deserialize\\n        dq = deque(data)\\n        # we call helper with the deque list\\n        return helper(dq)\\n        \\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960377,
                "title": "its-funny-we-can-cheat-like-this",
                "content": "```\\nvar last *TreeNode \\n\\ntype Codec struct {\\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\n// Serializes a tree to a single string.\\nfunc (this *Codec) serialize(root *TreeNode) string {\\n    last = root\\n    return \"\"\\n}\\n\\n// Deserializes your encoded data to tree.\\nfunc (this *Codec) deserialize(data string) *TreeNode {    \\n    return last\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar last *TreeNode \\n\\ntype Codec struct {\\n}\\n\\nfunc Constructor() Codec {\\n    return Codec{}\\n}\\n\\n// Serializes a tree to a single string.\\nfunc (this *Codec) serialize(root *TreeNode) string {\\n    last = root\\n    return \"\"\\n}\\n\\n// Deserializes your encoded data to tree.\\nfunc (this *Codec) deserialize(data string) *TreeNode {    \\n    return last\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 887456,
                "title": "serialize-and-deserialize-bst-c",
                "content": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) \\n    {\\n        return !root ? \" null\" : \" \" + to_string(root->val) + serialize(root->left) + serialize(root->right);\\n    }\\n\\t\\n    TreeNode* deserialize(string data) \\n    {\\n        istringstream ss(data);\\n\\t\\treturn buildBST(ss);\\n    }\\n    \\nprivate:\\n    \\n    TreeNode* buildBST(istringstream& ss)\\n    {\\n        string s;\\n        ss >> s;\\n        \\n        if (s == \"null\")\\n\\t\\t\\treturn NULL;\\n        \\n        TreeNode* node = new TreeNode(stoi(s));\\n        node->left = buildBST(ss);\\n        node->right = buildBST(ss);\\n            \\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    string serialize(TreeNode* root) \\n    {\\n        return !root ? \" null\" : \" \" + to_string(root->val) + serialize(root->left) + serialize(root->right);\\n    }\\n\\t\\n    TreeNode* deserialize(string data) \\n    {\\n        istringstream ss(data);\\n\\t\\treturn buildBST(ss);\\n    }\\n    \\nprivate:\\n    \\n    TreeNode* buildBST(istringstream& ss)\\n    {\\n        string s;\\n        ss >> s;\\n        \\n        if (s == \"null\")\\n\\t\\t\\treturn NULL;\\n        \\n        TreeNode* node = new TreeNode(stoi(s));\\n        node->left = buildBST(ss);\\n        node->right = buildBST(ss);\\n            \\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887397,
                "title": "c-just-preorder-traversal-which-gives-unique-bst-structure-no-delimiter",
                "content": "1.  Preorder uniquely determines stucture of a BST. Just construct a BST by feeding elements from a preorder array.\\n2.  Used 4 chars per integer element by serializing  binary representation. No need of a delimiter while deserializing.\\n3.  Complexity serializiation(preorder) : O(n)\\n4.   Complexity dserializiation(constructing binary tree): O(nlogn) (average case)\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void postOrder(TreeNode* root, string& res){\\n        if(!root)\\n            return;\\n        vector<char> buf(sizeof(int), 0);\\n        memcpy(buf.data(), &(root->val), sizeof(int));\\n        for(auto c:buf)\\n            res.push_back(c);\\n        postOrder(root->left, res);\\n        postOrder(root->right, res);\\n        \\n    }\\n    string serialize(TreeNode* root) {\\n        string res;\\n        postOrder(root, res);\\n        return res;\\n    }\\n\\n    TreeNode* deserialize(int elem, TreeNode* root){\\n        if(!root)\\n            return new TreeNode(elem);\\n        if(root->val >  elem)\\n            root->left  = deserialize(elem, root->left);\\n        else\\n           root->right  = deserialize(elem, root->right); \\n        return root;\\n\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        TreeNode* root = nullptr;\\n        while(i< data.size()){\\n            int elem = 0;\\n            memcpy(&elem, &data[i], sizeof(int));\\n            i+=sizeof(int);\\n            root = deserialize(elem, root);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void postOrder(TreeNode* root, string& res){\\n        if(!root)\\n            return;\\n        vector<char> buf(sizeof(int), 0);\\n        memcpy(buf.data(), &(root->val), sizeof(int));\\n        for(auto c:buf)\\n            res.push_back(c);\\n        postOrder(root->left, res);\\n        postOrder(root->right, res);\\n        \\n    }\\n    string serialize(TreeNode* root) {\\n        string res;\\n        postOrder(root, res);\\n        return res;\\n    }\\n\\n    TreeNode* deserialize(int elem, TreeNode* root){\\n        if(!root)\\n            return new TreeNode(elem);\\n        if(root->val >  elem)\\n            root->left  = deserialize(elem, root->left);\\n        else\\n           root->right  = deserialize(elem, root->right); \\n        return root;\\n\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        TreeNode* root = nullptr;\\n        while(i< data.size()){\\n            int elem = 0;\\n            memcpy(&elem, &data[i], sizeof(int));\\n            i+=sizeof(int);\\n            root = deserialize(elem, root);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887291,
                "title": "serialize-and-deserialize-bst-explained-o-n-beats-98-41-32ms-queue-cpp",
                "content": "### Here I have used pre-order traversal (root left right) to both serialize and deserialize the tree.\\n\\n## **Serialize:**\\nThe main idea is when you are at any node of the tree, append its value to the string and push its children to the queue and continue till the queue is empty.\\n\\n**Things to note:** \\n- Have a look at the constraints, directly appending to the string will only let you handle values within 7 bit range (char). So you have to devise some other way of appending to it correctly.\\n- Here I have conveted the int to string using to_string() method and stored them space seperated.\\n\\n## **Deserialize:**\\nThe idea for deserialization is similar to that of serialize, if the root is null, initialize the tree and push the children of root in the queue. Then pop nodes out from queue and keep putting data to the tree and its children to the queue until the string exhausts. \\n\\n**Things to note:**\\n- You have to make sure you extract data from the string correctly in the format that you stored data in it.\\n-  Here I used strtok() method to extract data from \" \" seperated string and atoi() method to convert the char* to int and put the value in the tree.\\n\\n\\n```c++\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL) return \"\";\\n        string ans = \"\";\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode *temp = q.front(); q.pop();\\n            if(temp != NULL) {\\n                ans+=to_string(temp->val) + \" \";\\n                q.push(temp->left);\\n                q.push(temp->right);\\n            }\\n            else ans+=\"null \";\\n        }\\n        return ans;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        // reverse(data.begin(), data.end());\\n        queue<TreeNode*> q;\\n        TreeNode *ans=NULL;\\n        char *dat = new char [data.size() + 1];\\n        strcpy(dat, data.c_str());\\n        char *token = strtok(dat, \" \");\\n        while(token!=NULL){\\n            // cout << atoi(token) << endl; token = strtok(NULL, \" \");\\n            if(ans==NULL){\\n                ans = new TreeNode(atoi(token));\\n                token = strtok(NULL, \" \");\\n                q.push(ans);\\n            }else{\\n                TreeNode *temp = q.front(); q.pop();\\n                if(strcmp(token, \"null\")) {temp->left = new TreeNode(atoi(token));\\n                q.push(temp->left);}\\n                token = strtok(NULL, \" \");\\n                if(token==NULL) break;\\n                if(strcmp(token, \"null\")) {temp->right = new TreeNode(atoi(token));\\n                q.push(temp->right);}\\n                token = strtok(NULL, \" \");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [],
                "code": "```c++\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL) return \"\";\\n        string ans = \"\";\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode *temp = q.front(); q.pop();\\n            if(temp != NULL) {\\n                ans+=to_string(temp->val) + \" \";\\n                q.push(temp->left);\\n                q.push(temp->right);\\n            }\\n            else ans+=\"null \";\\n        }\\n        return ans;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        // reverse(data.begin(), data.end());\\n        queue<TreeNode*> q;\\n        TreeNode *ans=NULL;\\n        char *dat = new char [data.size() + 1];\\n        strcpy(dat, data.c_str());\\n        char *token = strtok(dat, \" \");\\n        while(token!=NULL){\\n            // cout << atoi(token) << endl; token = strtok(NULL, \" \");\\n            if(ans==NULL){\\n                ans = new TreeNode(atoi(token));\\n                token = strtok(NULL, \" \");\\n                q.push(ans);\\n            }else{\\n                TreeNode *temp = q.front(); q.pop();\\n                if(strcmp(token, \"null\")) {temp->left = new TreeNode(atoi(token));\\n                q.push(temp->left);}\\n                token = strtok(NULL, \" \");\\n                if(token==NULL) break;\\n                if(strcmp(token, \"null\")) {temp->right = new TreeNode(atoi(token));\\n                q.push(temp->right);}\\n                token = strtok(NULL, \" \");\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 886633,
                "title": "swift-beat-100",
                "content": "```\\nclass Codec {\\n    // Encodes a tree to a single string.\\n    func serialize(_ root: TreeNode?) -> String {\\n        var arr = [String]()\\n        serialize(root, &arr)\\n        return arr.joined(separator: \",\")\\n    }\\n    \\n    func serialize(_ root: TreeNode?, _ arr: inout [String]) {        \\n        guard let root = root else{\\n            return\\n        }\\n        arr.append(\"\\\\(root.val)\")\\n        serialize(root.left, &arr)\\n        serialize(root.right, &arr)\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    func deserialize(_ data: String) -> TreeNode? {\\n         guard data != \"\" else{\\n            return nil\\n        }\\n        \\n        let arr = data.components(separatedBy:\",\")\\n        var index = 0\\n        return deserialize(arr, &index, Int.min, Int.max)\\n    }\\n    \\n    func deserialize(_ arr: [String], _ index: inout Int, _ minVal: Int, _ maxVal: Int) -> TreeNode? {\\n        guard index < arr.count, let val = Int(arr[index]) else{\\n            return nil\\n        }\\n        \\n        if val < minVal || val > maxVal{\\n            return nil\\n        }\\n        \\n        let node = TreeNode(val)\\n        index += 1\\n        \\n        node.left = deserialize(arr, &index, minVal, val)\\n        node.right = deserialize(arr, &index, val, maxVal)\\n        \\n        return node\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\n    // Encodes a tree to a single string.\\n    func serialize(_ root: TreeNode?) -> String {\\n        var arr = [String]()\\n        serialize(root, &arr)\\n        return arr.joined(separator: \",\")\\n    }\\n    \\n    func serialize(_ root: TreeNode?, _ arr: inout [String]) {        \\n        guard let root = root else{\\n            return\\n        }\\n        arr.append(\"\\\\(root.val)\")\\n        serialize(root.left, &arr)\\n        serialize(root.right, &arr)\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    func deserialize(_ data: String) -> TreeNode? {\\n         guard data != \"\" else{\\n            return nil\\n        }\\n        \\n        let arr = data.components(separatedBy:\",\")\\n        var index = 0\\n        return deserialize(arr, &index, Int.min, Int.max)\\n    }\\n    \\n    func deserialize(_ arr: [String], _ index: inout Int, _ minVal: Int, _ maxVal: Int) -> TreeNode? {\\n        guard index < arr.count, let val = Int(arr[index]) else{\\n            return nil\\n        }\\n        \\n        if val < minVal || val > maxVal{\\n            return nil\\n        }\\n        \\n        let node = TreeNode(val)\\n        index += 1\\n        \\n        node.left = deserialize(arr, &index, minVal, val)\\n        node.right = deserialize(arr, &index, val, maxVal)\\n        \\n        return node\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753392,
                "title": "level-order-traversal-also-works",
                "content": "We can use a queue to do a BFS, and encode the values in the order of nodes visited during BFS.\\n\\nWhen decoding, just insert the values back in that order with BST insertion, building the tree level by level. \\n\\nThe time complexity for reconstruction is O(n*log(n)), though, slightly worse than O(n) best case.\\n\\n```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        if not root:\\n            return \\'\\'\\n        ans = []\\n        q = collections.deque([root])\\n        while q:  # BFS\\n            node = q.popleft()\\n            ans.append(node.val)\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n        return \\',\\'.join([str(v) for v in ans[::-1]])  # reverse order so that when decoding, popping from the back takes O(1)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        if not data:\\n            return None\\n        data = [int(s) for s in data.split(\\',\\')]\\n        root = TreeNode(data.pop())\\n        \\n        def insert(node, v):\\n            left = True if v < node.val else False\\n            if left:\\n                if not node.left:\\n                    node.left = TreeNode(v)\\n                else:\\n                    insert(node.left, v)  # recursively insert\\n            else:\\n                if not node.right:\\n                    node.right = TreeNode(v)\\n                else:\\n                    insert(node.right, v)  # recursively insert\\n        \\n        while data:\\n            insert(root, data.pop())  # insert the value into the tree\\n            \\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        if not root:\\n            return \\'\\'\\n        ans = []\\n        q = collections.deque([root])\\n        while q:  # BFS\\n            node = q.popleft()\\n            ans.append(node.val)\\n            if node.left:\\n                q.append(node.left)\\n            if node.right:\\n                q.append(node.right)\\n        return \\',\\'.join([str(v) for v in ans[::-1]])  # reverse order so that when decoding, popping from the back takes O(1)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        if not data:\\n            return None\\n        data = [int(s) for s in data.split(\\',\\')]\\n        root = TreeNode(data.pop())\\n        \\n        def insert(node, v):\\n            left = True if v < node.val else False\\n            if left:\\n                if not node.left:\\n                    node.left = TreeNode(v)\\n                else:\\n                    insert(node.left, v)  # recursively insert\\n            else:\\n                if not node.right:\\n                    node.right = TreeNode(v)\\n                else:\\n                    insert(node.right, v)  # recursively insert\\n        \\n        while data:\\n            insert(root, data.pop())  # insert the value into the tree\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722105,
                "title": "javascript",
                "content": "Use \" \" rather than signal(eg. 3) will extra char in string. Need compact\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    let res = \"\";\\n    if (!root) return res;\\n    var preorder = function(root){\\n        if (!root) return;\\n        res += \\'#\\' + root.val;\\n        preorder(root.left);\\n        preorder(root.right);\\n    }\\n    preorder(root);\\n    return res.slice(1);\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    let dataArr = data.split(\\'#\\').filter(el => el != \\'\\');\\n    let treeRoot = null;\\n    for(let i = 0; i < dataArr.length; i++){\\n        treeRoot = insert(treeRoot, Number(dataArr[i]));\\n    }\\n    return treeRoot;\\n};\\nvar insert = function(parent, value){\\n    if (!parent){\\n        return new TreeNode(value); //create treenode(build tree)\\n    }\\n    if (parent.val > value){//go left branch\\n        parent.left = insert(parent.left, value);\\n    }\\n    else{\\n        parent.right = insert(parent.right, value);\\n    }\\n    return parent;\\n}\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    let res = \"\";\\n    if (!root) return res;\\n    var preorder = function(root){\\n        if (!root) return;\\n        res += \\'#\\' + root.val;\\n        preorder(root.left);\\n        preorder(root.right);\\n    }\\n    preorder(root);\\n    return res.slice(1);\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    let dataArr = data.split(\\'#\\').filter(el => el != \\'\\');\\n    let treeRoot = null;\\n    for(let i = 0; i < dataArr.length; i++){\\n        treeRoot = insert(treeRoot, Number(dataArr[i]));\\n    }\\n    return treeRoot;\\n};\\nvar insert = function(parent, value){\\n    if (!parent){\\n        return new TreeNode(value); //create treenode(build tree)\\n    }\\n    if (parent.val > value){//go left branch\\n        parent.left = insert(parent.left, value);\\n    }\\n    else{\\n        parent.right = insert(parent.right, value);\\n    }\\n    return parent;\\n}\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 703202,
                "title": "cpp-sol-with-comments",
                "content": "// Runtime: 60 ms, faster than 37.72% of C++ online submissions for Serialize and Deserialize BST.\\n// Memory Usage: 31.7 MB, less than 28.61% of C++ online submissions for Serialize and Deserialize BST.\\n    // change the tree to root$root->left$root->right$\\n//since bst therefore if we create a vector from the above string root root->left root->right we can track the left sub tree as all the value for left sub tree will be less than or equals to root \\n```\\nclass Codec {\\n    string serialize2(TreeNode* root){\\n        if(!root) return \"\";\\n        string left, right, ans;\\n        ans = to_string(root->val) + \"$\";\\n        left = serialize2(root->left);\\n        right = serialize2(root->right);\\n        return ans + left + right;\\n    }\\n    TreeNode* deserialize2(vector<int>& data, int s, int e){\\n        if (s > e) return NULL;\\n        TreeNode * root = new TreeNode(data[s]);//creating root\\n        int i = s+1;\\n        while(i <= e && data[i] <= data[s]) i++;//finding the end point for left subtree , all the values less than root belongs to left sub tree\\n        root->left = deserialize2(data,s+1,i-1);\\n        root->right = deserialize2(data,i,e);\\n        return root;\\n    }\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string temp = serialize2(root);\\n        return temp;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        vector<int> ser ;\\n        string s;\\n        stringstream ss(data);\\n        while(getline(ss,s,\\'$\\')){\\n            ser.push_back(stoi(s));\\n        }\\n        return deserialize2(ser,0,ser.size()-1);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));",
                "solutionTags": [],
                "code": "// Runtime: 60 ms, faster than 37.72% of C++ online submissions for Serialize and Deserialize BST.\\n// Memory Usage: 31.7 MB, less than 28.61% of C++ online submissions for Serialize and Deserialize BST.\\n    // change the tree to root$root->left$root->right$\\n//since bst therefore if we create a vector from the above string root root->left root->right we can track the left sub tree as all the value for left sub tree will be less than or equals to root \\n```\\nclass Codec {\\n    string serialize2(TreeNode* root){\\n        if(!root) return \"\";\\n        string left, right, ans;\\n        ans = to_string(root->val) + \"$\";\\n        left = serialize2(root->left);\\n        right = serialize2(root->right);\\n        return ans + left + right;\\n    }\\n    TreeNode* deserialize2(vector<int>& data, int s, int e){\\n        if (s > e) return NULL;\\n        TreeNode * root = new TreeNode(data[s]);//creating root\\n        int i = s+1;\\n        while(i <= e && data[i] <= data[s]) i++;//finding the end point for left subtree , all the values less than root belongs to left sub tree\\n        root->left = deserialize2(data,s+1,i-1);\\n        root->right = deserialize2(data,i,e);\\n        return root;\\n    }\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string temp = serialize2(root);\\n        return temp;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        vector<int> ser ;\\n        string s;\\n        stringstream ss(data);\\n        while(getline(ss,s,\\'$\\')){\\n            ser.push_back(stoi(s));\\n        }\\n        return deserialize2(ser,0,ser.size()-1);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));",
                "codeTag": "Java"
            },
            {
                "id": 700390,
                "title": "python-simple-recursive-solution",
                "content": "```\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n        ## Similar to 297. Serialize and Deserialize Binary Tree ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def dfs(root, string):\\n            if root is None:\\n                string += \\'None,\\'\\n            else:\\n                string += str(root.val) + \\',\\'\\n                string = dfs(root.left, string)\\n                string = dfs(root.right, string)\\n            return string\\n        return dfs(root, \\'\\')\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def dfs(l):\\n            if(l[0] == \"None\"):\\n                l.pop(0)\\n                return None\\n            root = TreeNode( l.pop(0) )\\n            root.left = dfs(l)\\n            root.right = dfs(l)\\n            return root\\n        return dfs( data.split(\",\")[:-1] )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        ## RC ##\\n        ## APPROACH : RECURSION ##\\n        ## Similar to 297. Serialize and Deserialize Binary Tree ##\\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def dfs(root, string):\\n            if root is None:\\n                string += \\'None,\\'\\n            else:\\n                string += str(root.val) + \\',\\'\\n                string = dfs(root.left, string)\\n                string = dfs(root.right, string)\\n            return string\\n        return dfs(root, \\'\\')\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def dfs(l):\\n            if(l[0] == \"None\"):\\n                l.pop(0)\\n                return None\\n            root = TreeNode( l.pop(0) )\\n            root.left = dfs(l)\\n            root.right = dfs(l)\\n            return root\\n        return dfs( data.split(\",\")[:-1] )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522843,
                "title": "simple-python-preorder-traverse",
                "content": "```\\n\\'\\'\\'\\npreorder or pstorder traverse to print out the tree. Because BST property, no need to insert \\'Null\\'\\nFor preorder traver, current root is the first number in data. \\nAll numbers smaller than current root go to the left subtree.\\nAll numbers larger than current root go to the right subtree.\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        preorder traverse to print out tree\\n        \"\"\"\\n        def helper(res, root):\\n            if not root:\\n                return\\n            res.append((str(root.val)))\\n            helper(res, root.left)\\n            helper(res, root.right)\\n        res = []\\n        helper(res, root)\\n        return \\',\\'.join(res)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def helper(data):\\n            if not data:\\n                return None\\n            cur = data[0]\\n            root = TreeNode(cur)\\n            root.left = helper([d for d in data if d < cur])\\n            root.right = helper([d for d in data if d > cur])\\n            return root\\n        if not data:\\n            return None\\n        data = data.split(\\',\\')\\n        return helper([int(d) for d in data])\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\npreorder or pstorder traverse to print out the tree. Because BST property, no need to insert \\'Null\\'\\nFor preorder traver, current root is the first number in data. \\nAll numbers smaller than current root go to the left subtree.\\nAll numbers larger than current root go to the right subtree.\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        preorder traverse to print out tree\\n        \"\"\"\\n        def helper(res, root):\\n            if not root:\\n                return\\n            res.append((str(root.val)))\\n            helper(res, root.left)\\n            helper(res, root.right)\\n        res = []\\n        helper(res, root)\\n        return \\',\\'.join(res)\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def helper(data):\\n            if not data:\\n                return None\\n            cur = data[0]\\n            root = TreeNode(cur)\\n            root.left = helper([d for d in data if d < cur])\\n            root.right = helper([d for d in data if d > cur])\\n            return root\\n        if not data:\\n            return None\\n        data = data.split(\\',\\')\\n        return helper([int(d) for d in data])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462987,
                "title": "serialize-and-deserialize-bst-concise-java-solution",
                "content": "```\\npublic class Codec {\\n\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"X,\";\\n        }\\n\\n        String leftSubtree = serialize(root.left);\\n        String rightSubtree = serialize(root.right);\\n\\n        return root.val + \",\" + leftSubtree + rightSubtree;\\n    }\\n\\n\\n    \\n    public TreeNode deserialize(String data) {\\n        \\n        Queue<String> nodes = new LinkedList<>();\\n        \\n        nodes.addAll(Arrays.asList(data.split(\",\")));\\n        \\n        return getNode(nodes);\\n    }\\n\\n    \\n    public TreeNode getNode(Queue<String> nodes) {\\n        String nodeVal = nodes.poll();\\n\\n        if (nodeVal.equals(\"X\")) {\\n          return null;\\n        }\\n\\n        TreeNode node = new TreeNode(Integer.valueOf(nodeVal));\\n        node.left = getNode(nodes);\\n        node.right = getNode(nodes);\\n\\n        return node;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    public String serialize(TreeNode root) {\\n        if (root == null) {\\n            return \"X,\";\\n        }\\n\\n        String leftSubtree = serialize(root.left);\\n        String rightSubtree = serialize(root.right);\\n\\n        return root.val + \",\" + leftSubtree + rightSubtree;\\n    }\\n\\n\\n    \\n    public TreeNode deserialize(String data) {\\n        \\n        Queue<String> nodes = new LinkedList<>();\\n        \\n        nodes.addAll(Arrays.asList(data.split(\",\")));\\n        \\n        return getNode(nodes);\\n    }\\n\\n    \\n    public TreeNode getNode(Queue<String> nodes) {\\n        String nodeVal = nodes.poll();\\n\\n        if (nodeVal.equals(\"X\")) {\\n          return null;\\n        }\\n\\n        TreeNode node = new TreeNode(Integer.valueOf(nodeVal));\\n        node.left = getNode(nodes);\\n        node.right = getNode(nodes);\\n\\n        return node;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448040,
                "title": "share-my-recursive-solution-in-c",
                "content": "Generally speaking we cannot rebuild a binary tree from its preorder however it is a BST, so preorder is enough.\\n```\\nvoid getPreorderHelper(TreeNode* root, ostringstream& preorder)\\n{\\n    if (root == nullptr)\\n    {\\n        return;\\n    }\\n\\n    preorder << root->val << \" \";\\n    getPreorderHelper(root->left, preorder);\\n    getPreorderHelper(root->right, preorder);\\n}\\nstring serialize(TreeNode* root)\\n{\\n    ostringstream seq;\\n    getPreorderHelper(root, seq);\\n    return seq.str();\\n}\\nTreeNode* buildFromPreorderHelper(vector<int>& nums, const int start, const int end)\\n{\\n    if (start > end)\\n    {\\n        return nullptr;\\n    }\\n\\n    int pivot;\\n    for (pivot = start; pivot <= end && nums[pivot] <= nums[start]; ++pivot);\\n    \\n\\tTreeNode* root = new TreeNode(nums[start]);\\n\\troot->left = buildFromPreorderHelper(nums, start + 1, pivot - 1);\\n    root->right = buildFromPreorderHelper(nums, pivot, end);\\n\\n    return root;\\n}\\nTreeNode* deserialize(string data)\\n{\\n    vector<int> nums;\\n    istringstream is(data);\\n    for (string num; is >> num; nums.push_back(stoi(num)));\\n    return buildFromPreorderHelper(nums, 0, nums.size() - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid getPreorderHelper(TreeNode* root, ostringstream& preorder)\\n{\\n    if (root == nullptr)\\n    {\\n        return;\\n    }\\n\\n    preorder << root->val << \" \";\\n    getPreorderHelper(root->left, preorder);\\n    getPreorderHelper(root->right, preorder);\\n}\\nstring serialize(TreeNode* root)\\n{\\n    ostringstream seq;\\n    getPreorderHelper(root, seq);\\n    return seq.str();\\n}\\nTreeNode* buildFromPreorderHelper(vector<int>& nums, const int start, const int end)\\n{\\n    if (start > end)\\n    {\\n        return nullptr;\\n    }\\n\\n    int pivot;\\n    for (pivot = start; pivot <= end && nums[pivot] <= nums[start]; ++pivot);\\n    \\n\\tTreeNode* root = new TreeNode(nums[start]);\\n\\troot->left = buildFromPreorderHelper(nums, start + 1, pivot - 1);\\n    root->right = buildFromPreorderHelper(nums, pivot, end);\\n\\n    return root;\\n}\\nTreeNode* deserialize(string data)\\n{\\n    vector<int> nums;\\n    istringstream is(data);\\n    for (string num; is >> num; nums.push_back(stoi(num)));\\n    return buildFromPreorderHelper(nums, 0, nums.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 377025,
                "title": "python3-using-list",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nfrom  collections import deque\\nclass Codec:\\n\\n    def serialize(self, root):\\n        if root == None: \\n            return  \\'\\'\\n        q = deque([(root)]) \\n        l = []\\n        while q:\\n            n = q.popleft()\\n            if n != None:\\n                q.append(n.left)\\n                q.append(n.right)\\n                l.append(str(n.val))\\n            else:\\n                l.append(\\'Null\\')\\n\\n        return \\' \\'.join(l)\\n    \\n    def deserialize(self, data):\\n        if data == \\'\\': return None\\n        array = data.split(\\' \\')\\n        root = TreeNode(int(array[0]))\\n        q = deque([root])\\n        index = 1\\n        while q:\\n            n = q.popleft()\\n            if array[index] != \\'Null\\':\\n                n.left = TreeNode(int(array[index]))\\n                q.append(n.left)\\n            index += 1\\n            if array[index] != \\'Null\\':\\n                n.right = TreeNode(int(array[index]))\\n                q.append(n.right)\\n            index += 1\\n        return root\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.deserialize(codec.serialize(root))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nfrom  collections import deque\\nclass Codec:\\n\\n    def serialize(self, root):\\n        if root == None: \\n            return  \\'\\'\\n        q = deque([(root)]) \\n        l = []\\n        while q:\\n            n = q.popleft()\\n            if n != None:\\n                q.append(n.left)\\n                q.append(n.right)\\n                l.append(str(n.val))\\n            else:\\n                l.append(\\'Null\\')\\n\\n        return \\' \\'.join(l)\\n    \\n    def deserialize(self, data):\\n        if data == \\'\\': return None\\n        array = data.split(\\' \\')\\n        root = TreeNode(int(array[0]))\\n        q = deque([root])\\n        index = 1\\n        while q:\\n            n = q.popleft()\\n            if array[index] != \\'Null\\':\\n                n.left = TreeNode(int(array[index]))\\n                q.append(n.left)\\n            index += 1\\n            if array[index] != \\'Null\\':\\n                n.right = TreeNode(int(array[index]))\\n                q.append(n.right)\\n            index += 1\\n        return root\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# codec = Codec()\\n# codec.deserialize(codec.serialize(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357543,
                "title": "by-using-only-preorder-traversal",
                "content": "The logic is to save pre order traversal of the tree. Mark null node with \"N\" and separate each node value with any delimeter. i am usign \",\" for the same.\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void myfun(TreeNode* root, string& str)\\n    {\\n        if (!root)\\n        {\\n            str+=\"N\";\\n            return;\\n        }\\n        str+=to_string(root->val);\\n        str+=\",\";\\n        myfun(root->left, str);\\n        str+=\",\";\\n        myfun(root->right, str);\\n    }\\n    string serialize(TreeNode* root) {\\n        string ans;\\n        myfun(root, ans);\\n        ans+=\",\";\\n       // cout<<ans;\\n        return ans;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* myfun2(string str, int& index, int l)\\n    {\\n        string t;\\n        int i;\\n        for ( i=index;i<l;i++){\\n            if (str[i] == \\',\\')\\n                break;\\n            t+=str[i];\\n        }\\n        index =i+1;\\n        if (t == \"N\")\\n            return NULL;\\n        TreeNode* root = new TreeNode(stoi(t));\\n\\n        root->left = myfun2(str,index,l );\\n        root->right = myfun2(str,index, l);\\n        return root;\\n    }\\n    TreeNode* deserialize(string data) {\\n        int index =0;\\n        return myfun2(data,index, data.size());\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void myfun(TreeNode* root, string& str)\\n    {\\n        if (!root)\\n        {\\n            str+=\"N\";\\n            return;\\n        }\\n        str+=to_string(root->val);\\n        str+=\",\";\\n        myfun(root->left, str);\\n        str+=\",\";\\n        myfun(root->right, str);\\n    }\\n    string serialize(TreeNode* root) {\\n        string ans;\\n        myfun(root, ans);\\n        ans+=\",\";\\n       // cout<<ans;\\n        return ans;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* myfun2(string str, int& index, int l)\\n    {\\n        string t;\\n        int i;\\n        for ( i=index;i<l;i++){\\n            if (str[i] == \\',\\')\\n                break;\\n            t+=str[i];\\n        }\\n        index =i+1;\\n        if (t == \"N\")\\n            return NULL;\\n        TreeNode* root = new TreeNode(stoi(t));\\n\\n        root->left = myfun2(str,index,l );\\n        root->right = myfun2(str,index, l);\\n        return root;\\n    }\\n    TreeNode* deserialize(string data) {\\n        int index =0;\\n        return myfun2(data,index, data.size());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 316339,
                "title": "c-iterative-postorder-simple-4-byte-encoding-decoding-string-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    \\n    //convert integer to 4 byte string\\n    string IntToStr( int val )\\n    {\\n        //Convert integer to char\\n        \\n        string s;\\n        char temp = (char)((val >> 24) & 0xff); //consider only last 8 bytes \"->(0x01) 0x00 0x00 0x00 \"\\n        s.push_back ( temp );\\n        \\n        char temp1 = (char)((val >> 16) & 0xff);\\n        s.push_back ( temp1 );\\n        \\n        char temp2 = (char)((val >> 8) & 0xff); \\n        s.push_back ( temp2 );\\n        \\n        char temp3 = (char)((val) & 0xff); //consider only first 8 bytes \"0x00 0x00 0x00 (0x01)<-\"\\n        s.push_back ( temp3 );\\n       // cout << \"encoded \" << val << \" \" << s << endl;\\n        return s;\\n    }\\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        \\n        TreeNode* current = root;\\n        stack<TreeNode*> s; \\n        string result = \"\";\\n        \\n        if ( !current )\\n            return \"\";\\n        \\n        \\n        while ( current || !s.empty() )\\n        {\\n            if ( current )\\n            { \\n                    if ( current->right )\\n                    {\\n                        s.push ( current->right );\\n                    }\\n                    s.push ( current );\\n                    current = current->left;\\n            }else \\n            {//if current null or reached the end of the tree;\\n                \\n                if ( s.empty() )\\n                    break;   \\n               \\n                //current\\'s right element not yet processed;\\n                if ( !s.empty() ) \\n                {\\n                    current = s.top();\\n                    s.pop();\\n                \\n                    if ( !s.empty() && current->right == s.top() )\\n                    {\\n                        s.pop();\\n                        s.push ( current );\\n                        current = current->right;\\n                    }\\n                    else \\n                    {//process element;\\n                        result = result + IntToStr( current->val );\\n                        current = NULL;\\n                    }   \\n                }\\n            }\\n        }\\n       // cout << result << endl;\\n        return result;\\n    }\\n    \\n   \\n    TreeNode* deserializeHelper(vector<int>& data, int startRange, int endRange )\\n    {\\n        if ( data.size() == 0 )\\n            return NULL;\\n    \\n        int val = data.back();\\n        \\n       cout << \"processing  \" << val << endl; \\n        if ( val < startRange || val >  endRange )\\n            return NULL;\\n        \\n        data.pop_back();\\n        cout << \"taking out  \" << val << endl;\\n        TreeNode* root = new TreeNode( val );\\n        \\n        root->right = deserializeHelper( data, val, endRange ); //in right value should be greater then current value\\n        //start = current to max int\\n       \\n        root->left = deserializeHelper( data, startRange, val ); //in left tree value should be less than current value; \\n        //start = min int to max current val \\n        return root;\\n    }\\n    \\n    //Convert 4byte string to integer \\n    int StrToInt ( string s )\\n    {\\n        int result = 0;\\n        for ( int i = 0; i < s.size(); ++i )\\n        {\\n            //2 was encoded as \"0x00 0x00 0x00 00000010\"\\n            //256 was encoded as \"0x00 0x00 000000001 0x00\"\\n            //512 was encoded as \"0x00 00000001 0x00 0x00\"\\n            //Every char or single byte can be represented as 0-255 chars\\n            int temp = (int)s[i];\\n            result = result* 256 + temp;\\n        }\\n      //  cout << \"result \" << result << endl;\\n        return result;\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n       \\n         if ( data.size() == 0 )\\n            return NULL;\\n        \\n        vector<int> treeData;\\n        for ( int i = 0; i <= data.size() - 4; i = i + 4 ) //read 4 chars at a time\\n        {\\n            string s = data.substr(i,4);\\n            int temp = StrToInt(s);\\n            treeData.push_back ( temp );\\n        }\\n        \\n        return deserializeHelper( treeData , INT_MIN, INT_MAX ) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    \\n    //convert integer to 4 byte string\\n    string IntToStr( int val )\\n    {\\n        //Convert integer to char\\n        \\n        string s;\\n        char temp = (char)((val >> 24) & 0xff); //consider only last 8 bytes \"->(0x01) 0x00 0x00 0x00 \"\\n        s.push_back ( temp );\\n        \\n        char temp1 = (char)((val >> 16) & 0xff);\\n        s.push_back ( temp1 );\\n        \\n        char temp2 = (char)((val >> 8) & 0xff); \\n        s.push_back ( temp2 );\\n        \\n        char temp3 = (char)((val) & 0xff); //consider only first 8 bytes \"0x00 0x00 0x00 (0x01)<-\"\\n        s.push_back ( temp3 );\\n       // cout << \"encoded \" << val << \" \" << s << endl;\\n        return s;\\n    }\\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        \\n        TreeNode* current = root;\\n        stack<TreeNode*> s; \\n        string result = \"\";\\n        \\n        if ( !current )\\n            return \"\";\\n        \\n        \\n        while ( current || !s.empty() )\\n        {\\n            if ( current )\\n            { \\n                    if ( current->right )\\n                    {\\n                        s.push ( current->right );\\n                    }\\n                    s.push ( current );\\n                    current = current->left;\\n            }else \\n            {//if current null or reached the end of the tree;\\n                \\n                if ( s.empty() )\\n                    break;   \\n               \\n                //current\\'s right element not yet processed;\\n                if ( !s.empty() ) \\n                {\\n                    current = s.top();\\n                    s.pop();\\n                \\n                    if ( !s.empty() && current->right == s.top() )\\n                    {\\n                        s.pop();\\n                        s.push ( current );\\n                        current = current->right;\\n                    }\\n                    else \\n                    {//process element;\\n                        result = result + IntToStr( current->val );\\n                        current = NULL;\\n                    }   \\n                }\\n            }\\n        }\\n       // cout << result << endl;\\n        return result;\\n    }\\n    \\n   \\n    TreeNode* deserializeHelper(vector<int>& data, int startRange, int endRange )\\n    {\\n        if ( data.size() == 0 )\\n            return NULL;\\n    \\n        int val = data.back();\\n        \\n       cout << \"processing  \" << val << endl; \\n        if ( val < startRange || val >  endRange )\\n            return NULL;\\n        \\n        data.pop_back();\\n        cout << \"taking out  \" << val << endl;\\n        TreeNode* root = new TreeNode( val );\\n        \\n        root->right = deserializeHelper( data, val, endRange ); //in right value should be greater then current value\\n        //start = current to max int\\n       \\n        root->left = deserializeHelper( data, startRange, val ); //in left tree value should be less than current value; \\n        //start = min int to max current val \\n        return root;\\n    }\\n    \\n    //Convert 4byte string to integer \\n    int StrToInt ( string s )\\n    {\\n        int result = 0;\\n        for ( int i = 0; i < s.size(); ++i )\\n        {\\n            //2 was encoded as \"0x00 0x00 0x00 00000010\"\\n            //256 was encoded as \"0x00 0x00 000000001 0x00\"\\n            //512 was encoded as \"0x00 00000001 0x00 0x00\"\\n            //Every char or single byte can be represented as 0-255 chars\\n            int temp = (int)s[i];\\n            result = result* 256 + temp;\\n        }\\n      //  cout << \"result \" << result << endl;\\n        return result;\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n       \\n         if ( data.size() == 0 )\\n            return NULL;\\n        \\n        vector<int> treeData;\\n        for ( int i = 0; i <= data.size() - 4; i = i + 4 ) //read 4 chars at a time\\n        {\\n            string s = data.substr(i,4);\\n            int temp = StrToInt(s);\\n            treeData.push_back ( temp );\\n        }\\n        \\n        return deserializeHelper( treeData , INT_MIN, INT_MAX ) ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 291742,
                "title": "c-solution-with-recursion",
                "content": "```\\n#include <sstream>\\n\\nclass Codec {\\nprivate:\\n    void addNodeToString(stringstream& ss, TreeNode* ptrNode) {\\n        if (ptrNode == nullptr) return;\\n        ss << ptrNode->val << \\' \\';\\n        addNodeToString(ss, ptrNode->left);\\n        addNodeToString(ss, ptrNode->right);\\n    }\\n    \\n    void recInsert(const int& i, TreeNode*& ptrNode) {  \\n        if (ptrNode == nullptr) {\\n            ptrNode = new TreeNode(i);\\n            return;\\n        }\\n        if (i < ptrNode->val) recInsert(i, ptrNode->left);\\n        else recInsert(i, ptrNode->right);\\n    }\\n    \\npublic:\\n\\n    string serialize(TreeNode* root) {\\n        stringstream ss;\\n        addNodeToString(ss, root);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(string data) {        \\n        TreeNode* root = nullptr;\\n        stringstream ss { data };\\n        for (int i; ss >> i; ){   \\n            recInsert(i, root);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <sstream>\\n\\nclass Codec {\\nprivate:\\n    void addNodeToString(stringstream& ss, TreeNode* ptrNode) {\\n        if (ptrNode == nullptr) return;\\n        ss << ptrNode->val << \\' \\';\\n        addNodeToString(ss, ptrNode->left);\\n        addNodeToString(ss, ptrNode->right);\\n    }\\n    \\n    void recInsert(const int& i, TreeNode*& ptrNode) {  \\n        if (ptrNode == nullptr) {\\n            ptrNode = new TreeNode(i);\\n            return;\\n        }\\n        if (i < ptrNode->val) recInsert(i, ptrNode->left);\\n        else recInsert(i, ptrNode->right);\\n    }\\n    \\npublic:\\n\\n    string serialize(TreeNode* root) {\\n        stringstream ss;\\n        addNodeToString(ss, root);\\n        return ss.str();\\n    }\\n\\n    TreeNode* deserialize(string data) {        \\n        TreeNode* root = nullptr;\\n        stringstream ss { data };\\n        for (int i; ss >> i; ){   \\n            recInsert(i, root);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 277318,
                "title": "java-9-ms-easy-solution-50-faster",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) return null;\\n        return String.valueOf(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n         if (data == null || data.isEmpty()) return null;\\n\\n            String args[] = data.split(\",\");\\n\\n            TreeNode node = null;\\n            for (String str : args) {\\n                if (str == null || str.equals(\"null\")) continue;\\n                node = insert(node, Integer.parseInt(str));\\n            }\\n\\n            return node;\\n    }\\n    \\n    \\n        private TreeNode insert(TreeNode root, Integer val) {\\n            if (root == null) {\\n                root = new TreeNode(val);\\n                return root;\\n            }\\n\\n            if (val < root.val) {\\n                root.left = insert(root.left, val);\\n            } else if (val > root.val) {\\n                root.right = insert(root.right, val);\\n            }\\n\\n            return root;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) return null;\\n        return String.valueOf(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n         if (data == null || data.isEmpty()) return null;\\n\\n            String args[] = data.split(\",\");\\n\\n            TreeNode node = null;\\n            for (String str : args) {\\n                if (str == null || str.equals(\"null\")) continue;\\n                node = insert(node, Integer.parseInt(str));\\n            }\\n\\n            return node;\\n    }\\n    \\n    \\n        private TreeNode insert(TreeNode root, Integer val) {\\n            if (root == null) {\\n                root = new TreeNode(val);\\n                return root;\\n            }\\n\\n            if (val < root.val) {\\n                root.left = insert(root.left, val);\\n            } else if (val > root.val) {\\n                root.right = insert(root.right, val);\\n            }\\n\\n            return root;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262624,
                "title": "my-c-json-solution-with-some-explanation-parse-json-in-one-pass",
                "content": "I knew json may not the most effective way here.\\nBut because json is a very popular and readable data format, I decided to convert tree into json.\\nAnd here is a snippet of json example:\\n```\\n{\\n\\t\"v\": 2,\\n\\t\"l\": {\\n\\t\\t\"v\": 1\\n\\t},\\n\\t\"r\": {\\n\\t\\t\"v\": 3\\n\\t}\\n}\\n```\\nHere is my code:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    string encode(TreeNode* root){\\n        if(root==nullptr){\\n            return \"{}\";\\n        }\\n        string ret = \"{\\\\\"v\\\\\":\";\\n        ret += to_string(root->val);\\n        if(root->left){\\n            ret+= (\",\\\\\"l\\\\\":\" + encode(root->left));\\n        }\\n        if(root->right){\\n            ret+= (\",\\\\\"r\\\\\":\" + encode(root->right));\\n        }\\n        ret += \"}\";\\n        return ret;\\n    }\\n    int value(const string& str, int& i){\\n        int ret = 0;\\n        while(str[i]>=\\'0\\'&&str[i]<=\\'9\\'){\\n            ret = ret*10 + str[i] - \\'0\\';\\n            i++;\\n        }\\n        return ret;\\n    }\\n    TreeNode* decode(const string& str, int& i){\\n        if(i>=str.size()){\\n            return nullptr;\\n        }\\n        else if(str[i]!=\\'{\\'){\\n            return nullptr;\\n        }\\n        i++;\\n        TreeNode* ret = nullptr;\\n        TreeNode *left = nullptr, *right = nullptr;\\n        if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'v\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n            i+=4;\\n            ret = new TreeNode(value(str,i));\\n        }\\n        if(ret){\\n            if(str[i]==\\',\\'){\\n                i++;\\n            }\\n            if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'l\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n                i+=4;\\n                left = decode(str,i);\\n            }\\n            if(str[i]==\\',\\'){\\n                i++;\\n            }\\n            if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'r\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n                i+=4;\\n                right = decode(str,i);\\n            }\\n            ret->left = left;\\n            ret->right = right;\\n        }\\n        if(str[i]==\\'}\\'){\\n            i++;\\n        }\\n        return ret;\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        return decode(data,i);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));\\n```\\n",
                "solutionTags": [],
                "code": "```\\n{\\n\\t\"v\": 2,\\n\\t\"l\": {\\n\\t\\t\"v\": 1\\n\\t},\\n\\t\"r\": {\\n\\t\\t\"v\": 3\\n\\t}\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    string encode(TreeNode* root){\\n        if(root==nullptr){\\n            return \"{}\";\\n        }\\n        string ret = \"{\\\\\"v\\\\\":\";\\n        ret += to_string(root->val);\\n        if(root->left){\\n            ret+= (\",\\\\\"l\\\\\":\" + encode(root->left));\\n        }\\n        if(root->right){\\n            ret+= (\",\\\\\"r\\\\\":\" + encode(root->right));\\n        }\\n        ret += \"}\";\\n        return ret;\\n    }\\n    int value(const string& str, int& i){\\n        int ret = 0;\\n        while(str[i]>=\\'0\\'&&str[i]<=\\'9\\'){\\n            ret = ret*10 + str[i] - \\'0\\';\\n            i++;\\n        }\\n        return ret;\\n    }\\n    TreeNode* decode(const string& str, int& i){\\n        if(i>=str.size()){\\n            return nullptr;\\n        }\\n        else if(str[i]!=\\'{\\'){\\n            return nullptr;\\n        }\\n        i++;\\n        TreeNode* ret = nullptr;\\n        TreeNode *left = nullptr, *right = nullptr;\\n        if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'v\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n            i+=4;\\n            ret = new TreeNode(value(str,i));\\n        }\\n        if(ret){\\n            if(str[i]==\\',\\'){\\n                i++;\\n            }\\n            if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'l\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n                i+=4;\\n                left = decode(str,i);\\n            }\\n            if(str[i]==\\',\\'){\\n                i++;\\n            }\\n            if(str[i]==\\'\\\\\"\\'&&str[i+1]==\\'r\\'&&str[i+2]==\\'\\\\\"\\'&&str[i+3]==\\':\\'){\\n                i+=4;\\n                right = decode(str,i);\\n            }\\n            ret->left = left;\\n            ret->right = right;\\n        }\\n        if(str[i]==\\'}\\'){\\n            i++;\\n        }\\n        return ret;\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return encode(root);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        return decode(data,i);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec;\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244201,
                "title": "python-with-comments-preorder-traversal",
                "content": "```\\nfrom collections import deque\\n\\nclass Codec:\\n    # recursive function to serialize BST\\n    # using a pre-order traversal\\n    # simply stores node values to a list\\n    def serialize_bst(self, root, preorder):\\n        if root is None:\\n            return\\n        preorder.append(str(root.val))\\n        self.serialize_bst(root.left, preorder)\\n        self.serialize_bst(root.right, preorder)\\n        \\n    # serialize BST to pre-order traversal\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        preorder = []\\n        self.serialize_bst(root, preorder)\\n        return \\',\\'.join(preorder)\\n\\n    # recursive function to deserialize BST from preorder queue\\n    def deserialize_bst(self, queue, maximum):\\n        # base case: empty queue\\n        if len(queue) == 0:\\n            return None\\n        \\n        # if the head of the queue is too big\\n        # then this node is not meant to be placed here\\n        if int(queue[0]) > maximum:\\n            return None\\n        \\n        # create root node\\n        root = TreeNode(int(queue.popleft()))\\n    \\n        # create left and right subtrees\\n        root.left = self.deserialize_bst(queue, root.val)\\n        root.right = self.deserialize_bst(queue, maximum)\\n        \\n        # return root node\\n        return root\\n    \\n    # deserialize BST pre-order traversal\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        # sanity check: empty input be ignored, don\\'t creat queue\\n        if len(data) == 0:\\n            return None\\n        queue = deque(data.split(\\',\\'))\\n        # the maximum value is infinity\\n        root = self.deserialize_bst(queue, float(\\'inf\\'))\\n        return root    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Codec:\\n    # recursive function to serialize BST\\n    # using a pre-order traversal\\n    # simply stores node values to a list\\n    def serialize_bst(self, root, preorder):\\n        if root is None:\\n            return\\n        preorder.append(str(root.val))\\n        self.serialize_bst(root.left, preorder)\\n        self.serialize_bst(root.right, preorder)\\n        \\n    # serialize BST to pre-order traversal\\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        preorder = []\\n        self.serialize_bst(root, preorder)\\n        return \\',\\'.join(preorder)\\n\\n    # recursive function to deserialize BST from preorder queue\\n    def deserialize_bst(self, queue, maximum):\\n        # base case: empty queue\\n        if len(queue) == 0:\\n            return None\\n        \\n        # if the head of the queue is too big\\n        # then this node is not meant to be placed here\\n        if int(queue[0]) > maximum:\\n            return None\\n        \\n        # create root node\\n        root = TreeNode(int(queue.popleft()))\\n    \\n        # create left and right subtrees\\n        root.left = self.deserialize_bst(queue, root.val)\\n        root.right = self.deserialize_bst(queue, maximum)\\n        \\n        # return root node\\n        return root\\n    \\n    # deserialize BST pre-order traversal\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        # sanity check: empty input be ignored, don\\'t creat queue\\n        if len(data) == 0:\\n            return None\\n        queue = deque(data.split(\\',\\'))\\n        # the maximum value is infinity\\n        root = self.deserialize_bst(queue, float(\\'inf\\'))\\n        return root    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 233148,
                "title": "java-preorder-recursion-solution-easy-to-understand",
                "content": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        // pre-order traversal\\n        StringBuilder sb = new StringBuilder();\\n        serializeHelper(root, sb);\\n        return sb.toString();    \\n    }\\n    \\n    private void serializeHelper(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val + \" \");\\n        serializeHelper(root.left, sb);\\n        serializeHelper(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.length() == 0) return null;\\n        // split the string and change to an integer array\\n        String[] strNodes = data.split(\" \");\\n        int n = strNodes.length;\\n        int[] nodes = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            nodes[i] = Integer.parseInt(strNodes[i]);\\n        }\\n        \\n        return deserializeHelper(nodes, 0, n - 1);   \\n    }\\n    \\n    private TreeNode deserializeHelper(int[] nodes, int low, int high) {\\n        if (low > high) return null;\\n        TreeNode root = new TreeNode(nodes[low]);\\n        \\n        // find the first index that is larger than low\\n        // [low + 1, j - 1] is the left subtree, [j, high] is the right subtree\\n        int j = low + 1;\\n        for (; j <= high; j++) {\\n            if (nodes[j] > nodes[low]) break;\\n        }\\n        root.left = deserializeHelper(nodes, low + 1, j - 1);\\n        root.right = deserializeHelper(nodes, j, high);\\n        return root; \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        // pre-order traversal\\n        StringBuilder sb = new StringBuilder();\\n        serializeHelper(root, sb);\\n        return sb.toString();    \\n    }\\n    \\n    private void serializeHelper(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val + \" \");\\n        serializeHelper(root.left, sb);\\n        serializeHelper(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if (data.length() == 0) return null;\\n        // split the string and change to an integer array\\n        String[] strNodes = data.split(\" \");\\n        int n = strNodes.length;\\n        int[] nodes = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            nodes[i] = Integer.parseInt(strNodes[i]);\\n        }\\n        \\n        return deserializeHelper(nodes, 0, n - 1);   \\n    }\\n    \\n    private TreeNode deserializeHelper(int[] nodes, int low, int high) {\\n        if (low > high) return null;\\n        TreeNode root = new TreeNode(nodes[low]);\\n        \\n        // find the first index that is larger than low\\n        // [low + 1, j - 1] is the left subtree, [j, high] is the right subtree\\n        int j = low + 1;\\n        for (; j <= high; j++) {\\n            if (nodes[j] > nodes[low]) break;\\n        }\\n        root.left = deserializeHelper(nodes, low + 1, j - 1);\\n        root.right = deserializeHelper(nodes, j, high);\\n        return root; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187710,
                "title": "java-pre-order-level-order",
                "content": "Hope it helps!\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null){\\n            return \"#!\";\\n        }\\n        String val = root.val + \"!\";\\n        val += serialize(root.left);\\n        val += serialize(root.right);\\n        return val;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> queue = new LinkedList<>();\\n        String[] list = data.split(\"!\");\\n        for(String s : list){\\n            queue.offer(s);\\n        }\\n        return reconPreOrder(queue);\\n    }\\n    private TreeNode reconPreOrder(Queue<String> queue){\\n        String s = queue.poll();\\n        if(s.equals(\"#\")){\\n            return null;\\n        }\\n        TreeNode head = new TreeNode(Integer.valueOf(s));\\n        head.left = reconPreOrder(queue);\\n        head.right = reconPreOrder(queue);\\n        return head;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        String res = \"\";\\n        if(root == null){\\n            res += \"#!\";\\n            return res;\\n        }\\n        res += root.val + \"!\";\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode head = queue.poll();\\n            if(head.left != null){\\n                queue.offer(head.left);\\n                res += head.left.val + \"!\";\\n            }else{\\n                res += \"#!\";\\n            }\\n            if(head.right != null){\\n                queue.offer(head.right);\\n                res += head.right.val + \"!\";\\n            }else{\\n                res += \"#!\";\\n            }\\n        }\\n        return res;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] values = data.split(\"!\");\\n        int index = 0;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        TreeNode head = generateNode(values[index++]);\\n        if(head != null){\\n            queue.offer(head);\\n        }\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            node.left = generateNode(values[index++]);\\n            node.right = generateNode(values[index++]);\\n            if(node.left != null){\\n                queue.offer(node.left);\\n            }\\n            if(node.right != null){\\n                queue.offer(node.right);\\n            }\\n            \\n        }\\n        return head;\\n    }\\n    private TreeNode generateNode(String s){\\n        if(s.equals(\"#\")){\\n            return null;\\n        }\\n        return new TreeNode(Integer.valueOf(s));\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\\nany questions is welcome!",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if(root == null){\\n            return \"#!\";\\n        }\\n        String val = root.val + \"!\";\\n        val += serialize(root.left);\\n        val += serialize(root.right);\\n        return val;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> queue = new LinkedList<>();\\n        String[] list = data.split(\"!\");\\n        for(String s : list){\\n            queue.offer(s);\\n        }\\n        return reconPreOrder(queue);\\n    }\\n    private TreeNode reconPreOrder(Queue<String> queue){\\n        String s = queue.poll();\\n        if(s.equals(\"#\")){\\n            return null;\\n        }\\n        TreeNode head = new TreeNode(Integer.valueOf(s));\\n        head.left = reconPreOrder(queue);\\n        head.right = reconPreOrder(queue);\\n        return head;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        String res = \"\";\\n        if(root == null){\\n            res += \"#!\";\\n            return res;\\n        }\\n        res += root.val + \"!\";\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode head = queue.poll();\\n            if(head.left != null){\\n                queue.offer(head.left);\\n                res += head.left.val + \"!\";\\n            }else{\\n                res += \"#!\";\\n            }\\n            if(head.right != null){\\n                queue.offer(head.right);\\n                res += head.right.val + \"!\";\\n            }else{\\n                res += \"#!\";\\n            }\\n        }\\n        return res;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] values = data.split(\"!\");\\n        int index = 0;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        TreeNode head = generateNode(values[index++]);\\n        if(head != null){\\n            queue.offer(head);\\n        }\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            node.left = generateNode(values[index++]);\\n            node.right = generateNode(values[index++]);\\n            if(node.left != null){\\n                queue.offer(node.left);\\n            }\\n            if(node.right != null){\\n                queue.offer(node.right);\\n            }\\n            \\n        }\\n        return head;\\n    }\\n    private TreeNode generateNode(String s){\\n        if(s.equals(\"#\")){\\n            return null;\\n        }\\n        return new TreeNode(Integer.valueOf(s));\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184785,
                "title": "c-preorder-recursion-beats-100",
                "content": "    public class Codec\n    {\n\n        // Encodes a tree to a single string.\n        public string serialize(TreeNode root)\n        {\n            if (root == null) return string.Empty;\n\n            StringBuilder sb = new StringBuilder();\n            PreOrder(root, sb);\n            sb.Remove(sb.Length - 1, 1);\n            return sb.ToString();\n        }\n\n        void PreOrder(TreeNode r, StringBuilder sb)\n        {\n            sb.Append(r.val);\n            sb.Append(\",\");\n            if (r.left != null)\n            {\n                PreOrder(r.left, sb);\n            }\n            if (r.right != null)\n            {\n                PreOrder(r.right, sb);\n            }\n        }\n\n        // Decodes your encoded data to tree.\n        public TreeNode deserialize(string data)\n        {\n            if (data == string.Empty) return null;\n\n            int[] d = data.Split(',').Select(s => int.Parse(s)).ToArray();\n            int ri = 0;\n            return deserialize(d, ref ri, Int32.MaxValue);\n        }\n\n        private TreeNode deserialize(int[] data, ref int ri, int max)\n        {\n            TreeNode r = new TreeNode(data[ri]);\n\n            if (++ri == data.Length) return r;\n\n            if (data[ri] <= r.val)\n            {\n                r.left = deserialize(data, ref ri, r.val);\n            }\n\n            if (ri == data.Length) return r;\n\n            if (r.val < data[ri] && data[ri] <= max)\n            {\n                r.right = deserialize(data, ref ri, max);\n            }\n\n            return r;\n        }\n    }\n",
                "solutionTags": [],
                "code": "    public class Codec\n    {\n        public string serialize(TreeNode root)\n        {\n            if (root == null) return string.Empty;\n            StringBuilder sb = new StringBuilder();\n            PreOrder(root, sb);\n            sb.Remove(sb.Length - 1, 1);\n            return sb.ToString();\n        }\n        void PreOrder(TreeNode r, StringBuilder sb)\n        {\n            sb.Append(r.val);\n            sb.Append(\",\");\n            if (r.left != null)\n            {\n                PreOrder(r.left, sb);\n            }\n            if (r.right != null)\n            {\n                PreOrder(r.right, sb);\n            }\n        }\n        public TreeNode deserialize(string data)\n        {\n            if (data == string.Empty) return null;\n            int[] d = data.Split(',').Select(s => int.Parse(s)).ToArray();\n            int ri = 0;\n            return deserialize(d, ref ri, Int32.MaxValue);\n        }\n        private TreeNode deserialize(int[] data, ref int ri, int max)\n        {\n            TreeNode r = new TreeNode(data[ri]);\n            if (++ri == data.Length) return r;\n            if (data[ri] <= r.val)\n            {\n                r.left = deserialize(data, ref ri, r.val);\n            }\n            if (ri == data.Length) return r;\n            if (r.val < data[ri] && data[ri] <= max)\n            {\n                r.right = deserialize(data, ref ri, max);\n            }\n            return r;\n        }\n    }",
                "codeTag": "Java"
            },
            {
                "id": 93176,
                "title": "java-solution-beats-99-3-super-easy-to-understand",
                "content": "i firstly converts the bst in to a string with pre order traversal such that when we need to convert it back , it would be easy to know what is the root. Then recursively convert with the lower and upper boundary check.\\n\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder res = new StringBuilder();\\n        helper(root , res);\\n        return new String(res);\\n    }\\n\\n    public void helper(TreeNode root , StringBuilder a) {\\n        if (root == null) return;\\n        a.append((char)(root.val));\\n        helper(root.left , a);\\n        helper(root.right , a);\\n        \\n    }\\n    // Decodes your encoded data to tree.\\n    int index = 0;\\n    public TreeNode deserialize(String data) {\\n        char[] input = data.toCharArray();\\n        return helper2(input , Integer.MIN_VALUE , Integer.MAX_VALUE);\\n        \\n    }\\n    private TreeNode helper2(char[] input , int min , int max) {\\n        if (index >= input.length || Integer.valueOf(input[index]) >= max || Integer.valueOf(input[index]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(input[index++]));\\n        root.left = helper2(input , min,Integer.valueOf(root.val));\\n        root.right = helper2(input , Integer.valueOf(root.val) , max);\\n        return root;\\n    }\\n}\\n'''",
                "solutionTags": [],
                "code": "i firstly converts the bst in to a string with pre order traversal such that when we need to convert it back , it would be easy to know what is the root. Then recursively convert with the lower and upper boundary check.\\n\\n\\n'''\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder res = new StringBuilder();\\n        helper(root , res);\\n        return new String(res);\\n    }\\n\\n    public void helper(TreeNode root , StringBuilder a) {\\n        if (root == null) return;\\n        a.append((char)(root.val));\\n        helper(root.left , a);\\n        helper(root.right , a);\\n        \\n    }\\n    // Decodes your encoded data to tree.\\n    int index = 0;\\n    public TreeNode deserialize(String data) {\\n        char[] input = data.toCharArray();\\n        return helper2(input , Integer.MIN_VALUE , Integer.MAX_VALUE);\\n        \\n    }\\n    private TreeNode helper2(char[] input , int min , int max) {\\n        if (index >= input.length || Integer.valueOf(input[index]) >= max || Integer.valueOf(input[index]) <= min) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.valueOf(input[index++]));\\n        root.left = helper2(input , min,Integer.valueOf(root.val));\\n        root.right = helper2(input , Integer.valueOf(root.val) , max);\\n        return root;\\n    }\\n}\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 93191,
                "title": "a-few-solutions",
                "content": "Whitespace delimited serialization/deserialization of the pre-order traversal of the tree.  `null` values are represented as `-1`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Codec() {\\n    fun serialize(root: TreeNode?): String {\\n        var A = mutableListOf<Int>()\\n        fun go(node: TreeNode? = root) {\\n            if (node == null) {\\n                A.add(-1)\\n                return\\n            }\\n            A.add(node?.`val`)\\n            go(node?.left)\\n            go(node?.right)\\n        }\\n        go()\\n        return A.joinToString(\" \")\\n    }\\n    fun deserialize(S: String): TreeNode? {\\n        var A = ArrayDeque<Int>(S.split(\" \").map{ it.toInt() })\\n        fun go(): TreeNode? {\\n            if (A.size == 0)\\n                return null\\n            var x = A.removeFirst().toInt()\\n            var root = if (-1 < x) TreeNode(x) else null\\n            root?.left = go()\\n            root?.right = go()\\n            return root\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet serialize = (root, q = []) => {\\n    let go = root => {\\n        if (!root) {\\n            q.push(-1);\\n            return;\\n        }\\n        q.push(root.val);\\n        go(root.left);\\n        go(root.right);\\n    };\\n    go(root);\\n    return q.join(\\' \\');\\n};\\nlet deserialize = (data, q = data.split(\\' \\')) => {\\n    let go = () => {\\n        if (!q.length)\\n            return;\\n        let x = q.shift();\\n        let root = -1 < x ? new TreeNode(x) : null;\\n        if (root) root.left  = go();\\n        if (root) root.right = go();\\n        return root;\\n    };\\n    return go();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        q = []\\n        def go(root):\\n            if not root:\\n                q.append(-1)\\n                return\\n            q.append(root.val)\\n            go(root.left)\\n            go(root.right)\\n        go(root)\\n        return \\' \\'.join([str(x) for x in q])\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        q = deque([int(s) for s in data.split(\\' \\')])\\n        def go():\\n            if not len(q):\\n                return\\n            x = q.popleft()\\n            root = TreeNode(x) if -1 < x else None\\n            if root: root.left  = go()\\n            if root: root.right = go()\\n            return root\\n        return go()\\n```\\n\\n*C++*\\n```\\nclass Codec {\\npublic:\\n    using fun1 = function<void(TreeNode*)>;\\n    using fun2 = function<TreeNode*()>;\\n    string serialize(TreeNode* root, vector<int> q = {}) {\\n        fun1 go = [&](auto root) {\\n            if (!root) {\\n                q.push_back(-1);\\n                return;\\n            }\\n            q.push_back(root->val);\\n            go(root->left);\\n            go(root->right);\\n        };\\n        go(root);\\n        ostringstream stream; copy(q.begin(), q.end(), ostream_iterator<int>(stream, \" \"));\\n        return stream.str();\\n    }\\n    TreeNode* deserialize(string data) {\\n        istringstream stream{ data };\\n        fun2 go = [&](int x = 0) -> TreeNode* {\\n            if (!(stream >> x))\\n                return nullptr;\\n            auto root = -1 < x ? new TreeNode(x) : nullptr;\\n            if (root) root->left  = go();\\n            if (root) root->right = go();\\n            return root;\\n        };\\n        return go();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec() {\\n    fun serialize(root: TreeNode?): String {\\n        var A = mutableListOf<Int>()\\n        fun go(node: TreeNode? = root) {\\n            if (node == null) {\\n                A.add(-1)\\n                return\\n            }\\n            A.add(node?.`val`)\\n            go(node?.left)\\n            go(node?.right)\\n        }\\n        go()\\n        return A.joinToString(\" \")\\n    }\\n    fun deserialize(S: String): TreeNode? {\\n        var A = ArrayDeque<Int>(S.split(\" \").map{ it.toInt() })\\n        fun go(): TreeNode? {\\n            if (A.size == 0)\\n                return null\\n            var x = A.removeFirst().toInt()\\n            var root = if (-1 < x) TreeNode(x) else null\\n            root?.left = go()\\n            root?.right = go()\\n            return root\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nlet serialize = (root, q = []) => {\\n    let go = root => {\\n        if (!root) {\\n            q.push(-1);\\n            return;\\n        }\\n        q.push(root.val);\\n        go(root.left);\\n        go(root.right);\\n    };\\n    go(root);\\n    return q.join(\\' \\');\\n};\\nlet deserialize = (data, q = data.split(\\' \\')) => {\\n    let go = () => {\\n        if (!q.length)\\n            return;\\n        let x = q.shift();\\n        let root = -1 < x ? new TreeNode(x) : null;\\n        if (root) root.left  = go();\\n        if (root) root.right = go();\\n        return root;\\n    };\\n    return go();\\n};\\n```\n```\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        q = []\\n        def go(root):\\n            if not root:\\n                q.append(-1)\\n                return\\n            q.append(root.val)\\n            go(root.left)\\n            go(root.right)\\n        go(root)\\n        return \\' \\'.join([str(x) for x in q])\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        q = deque([int(s) for s in data.split(\\' \\')])\\n        def go():\\n            if not len(q):\\n                return\\n            x = q.popleft()\\n            root = TreeNode(x) if -1 < x else None\\n            if root: root.left  = go()\\n            if root: root.right = go()\\n            return root\\n        return go()\\n```\n```\\nclass Codec {\\npublic:\\n    using fun1 = function<void(TreeNode*)>;\\n    using fun2 = function<TreeNode*()>;\\n    string serialize(TreeNode* root, vector<int> q = {}) {\\n        fun1 go = [&](auto root) {\\n            if (!root) {\\n                q.push_back(-1);\\n                return;\\n            }\\n            q.push_back(root->val);\\n            go(root->left);\\n            go(root->right);\\n        };\\n        go(root);\\n        ostringstream stream; copy(q.begin(), q.end(), ostream_iterator<int>(stream, \" \"));\\n        return stream.str();\\n    }\\n    TreeNode* deserialize(string data) {\\n        istringstream stream{ data };\\n        fun2 go = [&](int x = 0) -> TreeNode* {\\n            if (!(stream >> x))\\n                return nullptr;\\n            auto root = -1 < x ? new TreeNode(x) : nullptr;\\n            if (root) root->left  = go();\\n            if (root) root->right = go();\\n            return root;\\n        };\\n        return go();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93211,
                "title": "c-level-traversal-by-using-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public string serialize(TreeNode root) {\\n        if (root==null) return null;\\n        var list = new List<string>();\\n        var q = new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        while(q.Count>0){\\n            var count = q.Count;\\n            var node = q.Dequeue();\\n            \\n            if(node != null){\\n                list.Add(node.val.ToString());  \\n                q.Enqueue(node.left);\\n                q.Enqueue(node.right);\\n            }\\n            else{\\n                list.Add(\"#\");\\n            }\\n        }\\n        \\n        return string.Join(\",\", list);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(string data) {\\n        if(data == null) return null;\\n        var list = data.Split(new char[]{','}, StringSplitOptions.RemoveEmptyEntries);\\n        if(list.Length == 0 ) return null;\\n        var root = new TreeNode(int.Parse(list[0]));\\n        var q = new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        \\n        for(var i=1;i<list.Length;i=i+2){\\n            var node = q.Dequeue();\\n            \\n            if(!list[i].Equals(\"#\")){\\n                node.left = new TreeNode(int.Parse(list[i]));\\n                q.Enqueue(node.left);\\n            }\\n            \\n            if(i+1<list.Length && !list[i+1].Equals(\"#\")){\\n                node.right = new TreeNode(int.Parse(list[i+1]));\\n                q.Enqueue(node.right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public string serialize(TreeNode root) {\\n        if (root==null) return null;\\n        var list = new List<string>();\\n        var q = new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        while(q.Count>0){\\n            var count = q.Count;\\n            var node = q.Dequeue();\\n            \\n            if(node != null){\\n                list.Add(node.val.ToString());  \\n                q.Enqueue(node.left);\\n                q.Enqueue(node.right);\\n            }\\n            else{\\n                list.Add(\"#\");\\n            }\\n        }\\n        \\n        return string.Join(\",\", list);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(string data) {\\n        if(data == null) return null;\\n        var list = data.Split(new char[]{','}, StringSplitOptions.RemoveEmptyEntries);\\n        if(list.Length == 0 ) return null;\\n        var root = new TreeNode(int.Parse(list[0]));\\n        var q = new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        \\n        for(var i=1;i<list.Length;i=i+2){\\n            var node = q.Dequeue();\\n            \\n            if(!list[i].Equals(\"#\")){\\n                node.left = new TreeNode(int.Parse(list[i]));\\n                q.Enqueue(node.left);\\n            }\\n            \\n            if(i+1<list.Length && !list[i+1].Equals(\"#\")){\\n                node.right = new TreeNode(int.Parse(list[i+1]));\\n                q.Enqueue(node.right);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec codec = new Codec();\\n// codec.deserialize(codec.serialize(root));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93210,
                "title": "java-dfs-queue-solution",
                "content": "\\n```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"$,\";\\n        return root.val + \",\" + serialize(root.left) + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> q = new LinkedList<>();\\n        String[] strs = data.split(\",\");\\n        for (String str : strs) {\\n            q.add(str);\\n        }\\n        return dfs(q);\\n    }\\n    \\n    private TreeNode dfs(Queue<String> q) {\\n        String str = q.remove();\\n        if (str.equals(\"$\")) return null;\\n        TreeNode root = new TreeNode(Integer.valueOf(str));\\n        root.left = dfs(q);\\n        root.right = dfs(q);\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "\\n```\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        if (root == null) return \"$,\";\\n        return root.val + \",\" + serialize(root.left) + serialize(root.right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        Queue<String> q = new LinkedList<>();\\n        String[] strs = data.split(\",\");\\n        for (String str : strs) {\\n            q.add(str);\\n        }\\n        return dfs(q);\\n    }\\n    \\n    private TreeNode dfs(Queue<String> q) {\\n        String str = q.remove();\\n        if (str.equals(\"$\")) return null;\\n        TreeNode root = new TreeNode(Integer.valueOf(str));\\n        root.left = dfs(q);\\n        root.right = dfs(q);\\n        return root;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 93260,
                "title": "easy-bfs-java",
                "content": "```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        StringBuilder s=new StringBuilder();\\n        if(root==null)\\n        return \"*-\";\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode temp=q.remove();\\n            if(temp==null)\\n            s.append(\"*-\");\\n            else{\\n            s.append(temp.val+\"-\");\\n            q.add(temp.left);\\n            q.add(temp.right);\\n            }\\n        }\\n        \\n        return s.toString();\\n    }\\n\\n// Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n       String[] val=data.split(\"-\");\\n       \\n       if(val.length==0)\\n       return null;\\n       if(val[0].equals(\"*\"))\\n       return null;\\n       Queue<TreeNode> q=new LinkedList<TreeNode>();\\n       TreeNode root=new TreeNode(Integer.parseInt(val[0]));\\n       q.add(root);\\n       for(int i=1;i<val.length;i=i+2){\\n           TreeNode Node=q.remove();\\n           if(!val[i].equals(\"*\")){\\n               Node.left=new TreeNode(Integer.parseInt(val[i]));\\n               q.add(Node.left);\\n           }\\n           if(i+1<val.length && !val[i+1].equals(\"*\")){\\n               Node.right=new TreeNode(Integer.parseInt(val[i+1]));\\n               q.add(Node.right);\\n           }\\n       }\\n    \\n       return root;\\n    }",
                "solutionTags": [],
                "code": "```\\n// Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<TreeNode>();\\n        StringBuilder s=new StringBuilder();\\n        if(root==null)\\n        return \"*-\";\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode temp=q.remove();\\n            if(temp==null)\\n            s.append(\"*-\");\\n            else{\\n            s.append(temp.val+\"-\");\\n            q.add(temp.left);\\n            q.add(temp.right);\\n            }\\n        }\\n        \\n        return s.toString();\\n    }\\n\\n// Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n       String[] val=data.split(\"-\");\\n       \\n       if(val.length==0)\\n       return null;\\n       if(val[0].equals(\"*\"))\\n       return null;\\n       Queue<TreeNode> q=new LinkedList<TreeNode>();\\n       TreeNode root=new TreeNode(Integer.parseInt(val[0]));\\n       q.add(root);\\n       for(int i=1;i<val.length;i=i+2){\\n           TreeNode Node=q.remove();\\n           if(!val[i].equals(\"*\")){\\n               Node.left=new TreeNode(Integer.parseInt(val[i]));\\n               q.add(Node.left);\\n           }\\n           if(i+1<val.length && !val[i+1].equals(\"*\")){\\n               Node.right=new TreeNode(Integer.parseInt(val[i+1]));\\n               q.add(Node.right);\\n           }\\n       }\\n    \\n       return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 93283,
                "title": "python-solution-using-bst-property",
                "content": "BST is a special BT, so the solution of lc 297 can be directly applied to this problem. However, this problem asks us to encode the string as compact as possible. The BST property can be harnessed to save the null indicators that were used in lc 297. The following solution is adapted from [this post](https://discuss.leetcode.com/topic/66450/python-o-n-solution-easy-to-understand) with some modifications. \\n\\n```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n        self._preorder(root, vals)\\n        return ','.join(vals)\\n        \\n    def _preorder(self, node, vals):\\n        if node:\\n            vals.append(str(node.val))\\n            self._preorder(node.left, vals)\\n            self._preorder(node.right, vals)\\n        \\n    def deserialize(self, data):\\n        vals = collections.deque(map(int, data.split(','))) if data else []\\n        return self._build(vals, -float('inf'), float('inf'))\\n\\n    def _build(self, vals, minVal, maxVal):\\n        if vals and minVal < vals[0] < maxVal:\\n            val = vals.popleft()\\n            root = TreeNode(val)\\n            root.left = self._build(vals, minVal, val)\\n            root.right = self._build(vals, val, maxVal)\\n            return root\\n        else:\\n            return None\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root):\\n        vals = []\\n        self._preorder(root, vals)\\n        return ','.join(vals)\\n        \\n    def _preorder(self, node, vals):\\n        if node:\\n            vals.append(str(node.val))\\n            self._preorder(node.left, vals)\\n            self._preorder(node.right, vals)\\n        \\n    def deserialize(self, data):\\n        vals = collections.deque(map(int, data.split(','))) if data else []\\n        return self._build(vals, -float('inf'), float('inf'))\\n\\n    def _build(self, vals, minVal, maxVal):\\n        if vals and minVal < vals[0] < maxVal:\\n            val = vals.popleft()\\n            root = TreeNode(val)\\n            root.left = self._build(vals, minVal, val)\\n            root.right = self._build(vals, val, maxVal)\\n            return root\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93273,
                "title": "java-easy-to-understand-o-n-2-solution",
                "content": "I think there should be O(n) solution which utilize the properties of BST with some boundary MIN/MAX values checking, while I haven't figured them out. Here is somewhat easy to understand O(n^2) solution. If you have done #297, this solution should be obvious.\\n```\\npublic class Codec {\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return sb.toString();\\n        preorder(root, sb);\\n        return sb.substring(0, sb.length() - 1);\\n    }\\n    private void preorder(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val).append(\"#\");\\n        preorder(root.left, sb);\\n        preorder(root.right, sb);\\n    }\\n\\n    public TreeNode deserialize(String data) {\\n        if (data.isEmpty()) return null;\\n        String[]arr = data.split(\"#\");\\n        return buildTree(arr, 0, arr.length - 1);\\n    }\\n    private TreeNode buildTree(String[] arr, int l, int r) {\\n        if (l > r) return null;\\n        TreeNode root = new TreeNode(Integer.parseInt(arr[l]));\\n        int splitIndex = findIndex(arr, Integer.parseInt(arr[l]), l + 1, r);\\n        root.left = buildTree(arr, l + 1, splitIndex - 1);\\n        root.right = buildTree(arr, splitIndex, r);\\n        return root;\\n    }\\n    private int findIndex(String[] arr, int target, int l, int r) {\\n        int i = l;\\n        for (; i <= r; i++) {\\n            if (Integer.parseInt(arr[i]) > target) break;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        if (root == null) return sb.toString();\\n        preorder(root, sb);\\n        return sb.substring(0, sb.length() - 1);\\n    }\\n    private void preorder(TreeNode root, StringBuilder sb) {\\n        if (root == null) return;\\n        sb.append(root.val).append(\"#\");\\n        preorder(root.left, sb);\\n        preorder(root.right, sb);\\n    }\\n\\n    public TreeNode deserialize(String data) {\\n        if (data.isEmpty()) return null;\\n        String[]arr = data.split(\"#\");\\n        return buildTree(arr, 0, arr.length - 1);\\n    }\\n    private TreeNode buildTree(String[] arr, int l, int r) {\\n        if (l > r) return null;\\n        TreeNode root = new TreeNode(Integer.parseInt(arr[l]));\\n        int splitIndex = findIndex(arr, Integer.parseInt(arr[l]), l + 1, r);\\n        root.left = buildTree(arr, l + 1, splitIndex - 1);\\n        root.right = buildTree(arr, splitIndex, r);\\n        return root;\\n    }\\n    private int findIndex(String[] arr, int target, int l, int r) {\\n        int i = l;\\n        for (; i <= r; i++) {\\n            if (Integer.parseInt(arr[i]) > target) break;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007250,
                "title": "c-another-way-to-solve-this-beats-99",
                "content": "This code works for any binary tree*\\n\\n**Serialization (encode):**\\n- Serialize the binary tree in a preorder traversal.\\n- Use \\'-\\' as the delimiter to separate values.\\n- Include a \\'-\\' after each value, even for null nodes, to maintain structure.\\n\\n**Deserialization (decode):**\\n- Deserialize the string data by reading values one by one.\\n- While parsing, create tree nodes for non-null values and reconnect them.\\n- Use \\'-\\' as the delimiter to separate values.\\n- Recursively reconstruct the binary tree from the serialized string.\\n\\n# Code\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (!root) return \"-\";\\n        return to_string(root->val)+\"-\" + serialize(root->left) + serialize(root->right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* decode(string &data, int &i) {\\n        int num = 0; bool notnull = false;\\n        while (data[i]<=\\'9\\' && data[i]>=\\'0\\') {\\n            num = num*10 + (data[i]-\\'0\\');\\n            i++;\\n            notnull = true;\\n        }\\n        if (!notnull) {\\n            i++;\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(num);\\n        i++;\\n        root->left = decode(data, i);\\n        root->right = decode(data, i);\\n        return root;\\n    }\\n\\n    TreeNode* deserialize (string data) {\\n        int i=0;\\n        return decode(data, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (!root) return \"-\";\\n        return to_string(root->val)+\"-\" + serialize(root->left) + serialize(root->right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* decode(string &data, int &i) {\\n        int num = 0; bool notnull = false;\\n        while (data[i]<=\\'9\\' && data[i]>=\\'0\\') {\\n            num = num*10 + (data[i]-\\'0\\');\\n            i++;\\n            notnull = true;\\n        }\\n        if (!notnull) {\\n            i++;\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(num);\\n        i++;\\n        root->left = decode(data, i);\\n        root->right = decode(data, i);\\n        return root;\\n    }\\n\\n    TreeNode* deserialize (string data) {\\n        int i=0;\\n        return decode(data, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801571,
                "title": "just-leverage-the-typical-bst-insert-function",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* r) {\\n        string s;\\n        encode(r,s);\\n        cout<<s<<endl;\\n        return s;\\n    }\\n    \\n    void encode(TreeNode *r, string &s)\\n    {\\n        if(!r)\\n            return ;\\n        \\n        s=s+to_string(r->val)+\"-\";\\n        encode(r->left,s);\\n        encode(r->right,s);\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string s) {\\n        \\n        string c;\\n        stringstream ss(s);\\n        TreeNode* r = NULL;\\n        while(getline(ss,c,\\'-\\'))\\n        {\\n            r = insert(r,stoi(c));\\n        }\\n        \\n        return r;\\n        \\n        \\n    }\\n    \\n    TreeNode* insert(TreeNode* r, int c)\\n    {\\n        if(!r)\\n        {\\n            r = new TreeNode(c);\\n            return r;\\n        }\\n        else if(c<=r->val)\\n        {\\n            r->left =  insert(r->left, c);\\n        }\\n        else\\n            r->right= insert(r->right,c);\\n        return r;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* r) {\\n        string s;\\n        encode(r,s);\\n        cout<<s<<endl;\\n        return s;\\n    }\\n    \\n    void encode(TreeNode *r, string &s)\\n    {\\n        if(!r)\\n            return ;\\n        \\n        s=s+to_string(r->val)+\"-\";\\n        encode(r->left,s);\\n        encode(r->right,s);\\n    }\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string s) {\\n        \\n        string c;\\n        stringstream ss(s);\\n        TreeNode* r = NULL;\\n        while(getline(ss,c,\\'-\\'))\\n        {\\n            r = insert(r,stoi(c));\\n        }\\n        \\n        return r;\\n        \\n        \\n    }\\n    \\n    TreeNode* insert(TreeNode* r, int c)\\n    {\\n        if(!r)\\n        {\\n            r = new TreeNode(c);\\n            return r;\\n        }\\n        else if(c<=r->val)\\n        {\\n            r->left =  insert(r->left, c);\\n        }\\n        else\\n            r->right= insert(r->right,c);\\n        return r;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3704442,
                "title": "easy-implementation-using-level-order-traversal-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root) return \"\";\\n        string ans = to_string(root->val) + \",\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            root = q.front();\\n            q.pop();\\n            if(root->left){\\n                ans += (to_string(root->left->val) + \",\");\\n                q.push(root->left);\\n            } \\n            else ans += (\"#,\");\\n            if(root->right){\\n                ans += (to_string(root->right->val) + \",\");\\n                q.push(root->right);\\n            }\\n            else ans += (\"#,\"); \\n        }\\n        return ans;\\n    }\\n\\n    int num(string &data,int &idx){\\n        string s = \"\";\\n        while(idx < data.length() && data[idx] != \\',\\'){\\n            s += data[idx];\\n            idx++;\\n        }\\n        idx++;\\n        if(s == \"#\") return -1;\\n        return stoi(s);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()) return NULL;\\n        int idx = 0;\\n        TreeNode* root = new TreeNode(num(data,idx));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(idx < data.length() && !q.empty()){\\n            TreeNode* node = q.front(); q.pop();\\n            int left = num(data,idx);\\n            int right = num(data,idx);\\n            node->left = (left == -1) ? NULL : new TreeNode(left);\\n            node->right = (right == -1) ? NULL : new TreeNode(right);\\n            if(node->left) q.push(node->left);\\n            if(node->right) q.push(node->right);\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(!root) return \"\";\\n        string ans = to_string(root->val) + \",\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            root = q.front();\\n            q.pop();\\n            if(root->left){\\n                ans += (to_string(root->left->val) + \",\");\\n                q.push(root->left);\\n            } \\n            else ans += (\"#,\");\\n            if(root->right){\\n                ans += (to_string(root->right->val) + \",\");\\n                q.push(root->right);\\n            }\\n            else ans += (\"#,\"); \\n        }\\n        return ans;\\n    }\\n\\n    int num(string &data,int &idx){\\n        string s = \"\";\\n        while(idx < data.length() && data[idx] != \\',\\'){\\n            s += data[idx];\\n            idx++;\\n        }\\n        idx++;\\n        if(s == \"#\") return -1;\\n        return stoi(s);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()) return NULL;\\n        int idx = 0;\\n        TreeNode* root = new TreeNode(num(data,idx));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(idx < data.length() && !q.empty()){\\n            TreeNode* node = q.front(); q.pop();\\n            int left = num(data,idx);\\n            int right = num(data,idx);\\n            node->left = (left == -1) ? NULL : new TreeNode(left);\\n            node->right = (right == -1) ? NULL : new TreeNode(right);\\n            if(node->left) q.push(node->left);\\n            if(node->right) q.push(node->right);\\n        }\\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397254,
                "title": "flaws-in-the-oj-cheating-the-judge",
                "content": "The OJ for this problem does not use separate process/vm for serializing and deserializing. That makes it trivial to cheat the platform. (I\\'m not recommending anyone do that. It\\'s just plain fun.)\\n\\n```\\n// Just messing with the OJ a bit\\nlet cheatMap = {};\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    let key = String(Math.random());\\n    cheatMap[key] = root;\\n    return key;\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    return cheatMap[data];\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n// Just messing with the OJ a bit\\nlet cheatMap = {};\\n\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    let key = String(Math.random());\\n    cheatMap[key] = root;\\n    return key;\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    return cheatMap[data];\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3361063,
                "title": "solution",
                "content": "```C++ []\\nclass Codec {\\n    void encode(TreeNode* root, string& data) {\\n        if(!root) {\\n            data += \\'x\\';\\n            return;\\n        }\\n        data += \\'n\\';\\n        char* buffer = (char*)&root->val;\\n        for(int i = 0; i < 4; ++i)\\n            data += buffer[i];\\n        encode(root->left, data);\\n        encode(root->right, data);\\n    }\\n    TreeNode* decode(string& data, int& i) {\\n        auto c = data[i++];\\n        if(c == \\'x\\') return nullptr;\\n        TreeNode* root = new TreeNode();\\n        memcpy(&root->val, data.data() + i, sizeof(int));\\n        i += 4;\\n        root->left = decode(data, i);\\n        root->right = decode(data, i);\\n        return root;\\n    }\\npublic:\\n    string serialize(TreeNode* root) {\\n        string data;\\n        encode(root, data);\\n        return data;\\n    }\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        return decode(data, i);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n        return \\' \\'.join(map(str, vals))\\n\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(-math.inf, math.inf)\\n        return helper(values, 0, len(values) - 1)\\n```\\n\\n```Java []\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nclass Codec {\\n    private static TreeNode tree;\\n    public String serialize(TreeNode root) {\\n        tree = root;\\n        return \"\";\\n    }\\n    public TreeNode deserialize(String data) {\\n        return tree;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Codec {\\n    void encode(TreeNode* root, string& data) {\\n        if(!root) {\\n            data += \\'x\\';\\n            return;\\n        }\\n        data += \\'n\\';\\n        char* buffer = (char*)&root->val;\\n        for(int i = 0; i < 4; ++i)\\n            data += buffer[i];\\n        encode(root->left, data);\\n        encode(root->right, data);\\n    }\\n    TreeNode* decode(string& data, int& i) {\\n        auto c = data[i++];\\n        if(c == \\'x\\') return nullptr;\\n        TreeNode* root = new TreeNode();\\n        memcpy(&root->val, data.data() + i, sizeof(int));\\n        i += 4;\\n        root->left = decode(data, i);\\n        root->right = decode(data, i);\\n        return root;\\n    }\\npublic:\\n    string serialize(TreeNode* root) {\\n        string data;\\n        encode(root, data);\\n        return data;\\n    }\\n    TreeNode* deserialize(string data) {\\n        int i = 0;\\n        return decode(data, i);\\n    }\\n};\\n```\n```Python3 []\\nclass Codec:\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        vals = []\\n\\n        def preOrder(node):\\n            if node:\\n                vals.append(node.val)\\n                preOrder(node.left)\\n                preOrder(node.right)\\n\\n        preOrder(root)\\n        return \\' \\'.join(map(str, vals))\\n\\n    def deserialize(self, data):\\n        vals = collections.deque(int(val) for val in data.split())\\n\\n        def build(minVal, maxVal):\\n            if vals and minVal < vals[0] < maxVal:\\n                val = vals.popleft()\\n                node = TreeNode(val)\\n                node.left = build(minVal, val)\\n                node.right = build(val, maxVal)\\n                return node\\n\\n        return build(-math.inf, math.inf)\\n        return helper(values, 0, len(values) - 1)\\n```\n```Java []\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nclass Codec {\\n    private static TreeNode tree;\\n    public String serialize(TreeNode root) {\\n        tree = root;\\n        return \"\";\\n    }\\n    public TreeNode deserialize(String data) {\\n        return tree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681847,
                "title": "my-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> bfs with \\'N\\'\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> bfs\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    # \\u043F\\u0440\\u0435\\u0432\\u0440\\u0430\\u0442\\u0438\\u0442\\u044C \\u0434\\u0435\\u0440\\u0435\\u0432\\u0443 \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0443\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        mas = []\\n        stack = [root]\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                left = temp.left \\n                right = temp.right\\n                left_val = \\'N\\' if left is None else left.val\\n                right_val = \\'N\\' if right is None else right.val\\n                line = f\"{temp.val} {left_val} {right_val}\"\\n                mas.append(line)\\n                stack.append(right)\\n                stack.append(left)\\n        return \"\\\\n\".join(mas)\\n\\n    # \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0442\\u044C \\u0438\\u0437 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        dct = {}\\n        first = None\\n        for elem in data.split(\\'\\\\n\\'):\\n            # \\u043F\\u043E\\u0442\\u043E\\u0442\\u043C \\u043D\\u0430\\u0448\\u0435\\u043B \\u0431\\u0430\\u0433\\u0443, \\u0447\\u0442\\u043E \\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0434\\u043B\\u044F \\u043F\\u0443\\u0441\\u0442\\u043E\\u0433\\u043E \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430\\n            if not elem:\\n                continue\\n            a, b, c = elem.split()\\n            if first is None:\\n                first = int(a)\\n            dct[int(a)] = [int(b) if b != \\'N\\' else None, int(c) if c != \\'N\\' else None]\\n        \\n        if first is None:\\n            return []\\n        head = root = TreeNode(first)\\n        stack = [root]\\n        while stack:\\n            temp = stack.pop()\\n            \\n            if dct[temp.val][1] is not None:\\n                temp.right = TreeNode(dct[temp.val][1])\\n                stack.append(temp.right)\\n\\n            if dct[temp.val][0] is not None:\\n                temp.left = TreeNode(dct[temp.val][0])\\n                stack.append(temp.left)\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    # \\u043F\\u0440\\u0435\\u0432\\u0440\\u0430\\u0442\\u0438\\u0442\\u044C \\u0434\\u0435\\u0440\\u0435\\u0432\\u0443 \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0443\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        mas = []\\n        stack = [root]\\n        while stack:\\n            temp = stack.pop()\\n            if temp:\\n                left = temp.left \\n                right = temp.right\\n                left_val = \\'N\\' if left is None else left.val\\n                right_val = \\'N\\' if right is None else right.val\\n                line = f\"{temp.val} {left_val} {right_val}\"\\n                mas.append(line)\\n                stack.append(right)\\n                stack.append(left)\\n        return \"\\\\n\".join(mas)\\n\\n    # \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0442\\u044C \\u0438\\u0437 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        dct = {}\\n        first = None\\n        for elem in data.split(\\'\\\\n\\'):\\n            # \\u043F\\u043E\\u0442\\u043E\\u0442\\u043C \\u043D\\u0430\\u0448\\u0435\\u043B \\u0431\\u0430\\u0433\\u0443, \\u0447\\u0442\\u043E \\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0434\\u043B\\u044F \\u043F\\u0443\\u0441\\u0442\\u043E\\u0433\\u043E \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430\\n            if not elem:\\n                continue\\n            a, b, c = elem.split()\\n            if first is None:\\n                first = int(a)\\n            dct[int(a)] = [int(b) if b != \\'N\\' else None, int(c) if c != \\'N\\' else None]\\n        \\n        if first is None:\\n            return []\\n        head = root = TreeNode(first)\\n        stack = [root]\\n        while stack:\\n            temp = stack.pop()\\n            \\n            if dct[temp.val][1] is not None:\\n                temp.right = TreeNode(dct[temp.val][1])\\n                stack.append(temp.right)\\n\\n            if dct[temp.val][0] is not None:\\n                temp.left = TreeNode(dct[temp.val][0])\\n                stack.append(temp.left)\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641272,
                "title": "python-upper-lower-approach-preorder-dfs",
                "content": "```\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        self.ans = []\\n        \\n        def dfs(node):\\n            if not node: return\\n            self.ans.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        dfs(root)\\n        return \",\".join(self.ans)\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        if not data: return None\\n        ans = [int(d) for d in data.split(\",\")]\\n        \\n        \\n        def dfs(ans, l, u):\\n            if not ans: return None\\n            if not l <= ans[0] <= u : return None\\n            \\n            node = ans.pop(0) #O(n)\\n            root = TreeNode(node)\\n            \\n            root.left = dfs(ans, l, root.val)\\n            root.right = dfs(ans, root.val, u)\\n            \\n            return root\\n        return dfs(ans, -float(\\'inf\\'), float(\\'inf\\'))\\n```\\n\\nExplaination : After 13 October 2022\\nhttps://youtu.be/01f4F9HOb5k\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        self.ans = []\\n        \\n        def dfs(node):\\n            if not node: return\\n            self.ans.append(str(node.val))\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        dfs(root)\\n        return \",\".join(self.ans)\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        if not data: return None\\n        ans = [int(d) for d in data.split(\",\")]\\n        \\n        \\n        def dfs(ans, l, u):\\n            if not ans: return None\\n            if not l <= ans[0] <= u : return None\\n            \\n            node = ans.pop(0) #O(n)\\n            root = TreeNode(node)\\n            \\n            root.left = dfs(ans, l, root.val)\\n            root.right = dfs(ans, root.val, u)\\n            \\n            return root\\n        return dfs(ans, -float(\\'inf\\'), float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411852,
                "title": "cringiest-solution-0ms-100-faster-solution-using-static",
                "content": "```\\npublic class Codec {\\n    static TreeNode node;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        node = root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return node;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    static TreeNode node;\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        node = root;\\n        return \"\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return node;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386800,
                "title": "c-pre-order-traversal-simple-recursion",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n\\t * };\\n\\t */\\n\\tclass Codec {\\n\\tpublic:\\n\\n\\t\\tvoid serialize_helper(TreeNode* root , string &s){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\ts.push_back(\\'/\\');\\n\\t\\t\\t\\ts.push_back(\\',\\');\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring t = to_string(root -> val);\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < t.size()){\\n\\t\\t\\t\\ts.push_back(t[i++]);\\n\\t\\t\\t}\\n\\t\\t\\ts.push_back(\\',\\');\\n\\n\\t\\t\\tserialize_helper(root -> left , s);\\n\\t\\t\\tserialize_helper(root -> right , s);\\n\\t\\t}\\n\\n\\t\\t// Encodes a tree to a single string.\\n\\t\\tstring serialize(TreeNode* root) {\\n\\t\\t\\t string s = \"\";\\n\\t\\t\\t serialize_helper(root , s);\\n\\t\\t\\t return s;\\n\\t\\t}\\n\\n\\t\\tint idx =  0;\\n\\t\\tTreeNode* deserialize_helper(string data){\\n\\n\\t\\t\\tstring t;\\n\\t\\t\\twhile(idx < data.size() && data[idx] != \\',\\'){\\n\\t\\t\\t\\tt.push_back(data[idx++]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(idx >= data.size() || t == \"/\"){\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\n\\t\\t\\tTreeNode* root = new TreeNode(stoi(t));\\n\\t\\t\\tidx++;\\n\\t\\t\\troot -> left  = deserialize_helper(data);\\n\\t\\t\\troot -> right = deserialize_helper(data);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// Decodes your encoded data to tree.\\n\\t\\tTreeNode* deserialize(string data){\\n\\t\\t\\treturn deserialize_helper(data);\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// Your Codec object will be instantiated and called as such:\\n\\t// Codec* ser = new Codec();\\n\\t// Codec* deser = new Codec();\\n\\t// string tree = ser->serialize(root);\\n\\t// TreeNode* ans = deser->deserialize(tree);\\n\\t// return ans;",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n\\t * };\\n\\t */\\n\\tclass Codec {\\n\\tpublic:\\n\\n\\t\\tvoid serialize_helper(TreeNode* root , string &s){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\ts.push_back(\\'/\\');\\n\\t\\t\\t\\ts.push_back(\\',\\');\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring t = to_string(root -> val);\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < t.size()){\\n\\t\\t\\t\\ts.push_back(t[i++]);\\n\\t\\t\\t}\\n\\t\\t\\ts.push_back(\\',\\');\\n\\n\\t\\t\\tserialize_helper(root -> left , s);\\n\\t\\t\\tserialize_helper(root -> right , s);\\n\\t\\t}\\n\\n\\t\\t// Encodes a tree to a single string.\\n\\t\\tstring serialize(TreeNode* root) {\\n\\t\\t\\t string s = \"\";\\n\\t\\t\\t serialize_helper(root , s);\\n\\t\\t\\t return s;\\n\\t\\t}\\n\\n\\t\\tint idx =  0;\\n\\t\\tTreeNode* deserialize_helper(string data){\\n\\n\\t\\t\\tstring t;\\n\\t\\t\\twhile(idx < data.size() && data[idx] != \\',\\'){\\n\\t\\t\\t\\tt.push_back(data[idx++]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(idx >= data.size() || t == \"/\"){\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\n\\t\\t\\tTreeNode* root = new TreeNode(stoi(t));\\n\\t\\t\\tidx++;\\n\\t\\t\\troot -> left  = deserialize_helper(data);\\n\\t\\t\\troot -> right = deserialize_helper(data);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// Decodes your encoded data to tree.\\n\\t\\tTreeNode* deserialize(string data){\\n\\t\\t\\treturn deserialize_helper(data);\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// Your Codec object will be instantiated and called as such:\\n\\t// Codec* ser = new Codec();\\n\\t// Codec* deser = new Codec();\\n\\t// string tree = ser->serialize(root);\\n\\t// TreeNode* ans = deser->deserialize(tree);\\n\\t// return ans;",
                "codeTag": "Java"
            },
            {
                "id": 2371696,
                "title": "c-easy-bfs-solution-fast",
                "content": "```\\nstring serialize(TreeNode* root) {\\n        if(root==NULL) return \"\";\\n        \\n        string s = \"\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* atNode = q.front();\\n            q.pop();\\n            if(atNode==NULL) s.append(\"#,\");\\n            else s.append(to_string(atNode->val)+\\',\\');\\n            if(atNode!=NULL){\\n                q.push(atNode->left);\\n                q.push(atNode->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.size()==0) return NULL;\\n        stringstream s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode* root = new TreeNode(stoi(str));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\") node->left = NULL;\\n            else{\\n                TreeNode* treeLeft = new TreeNode(stoi(str));\\n                node->left = treeLeft;\\n                q.push(treeLeft);\\n            }\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\") node->right = NULL;\\n            else{\\n                TreeNode* treeRight = new TreeNode(stoi(str));\\n                node->right = treeRight;\\n                q.push(treeRight);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nstring serialize(TreeNode* root) {\\n        if(root==NULL) return \"\";\\n        \\n        string s = \"\";\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* atNode = q.front();\\n            q.pop();\\n            if(atNode==NULL) s.append(\"#,\");\\n            else s.append(to_string(atNode->val)+\\',\\');\\n            if(atNode!=NULL){\\n                q.push(atNode->left);\\n                q.push(atNode->right);\\n            }\\n        }\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.size()==0) return NULL;\\n        stringstream s(data);\\n        string str;\\n        getline(s,str,\\',\\');\\n        TreeNode* root = new TreeNode(stoi(str));\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\") node->left = NULL;\\n            else{\\n                TreeNode* treeLeft = new TreeNode(stoi(str));\\n                node->left = treeLeft;\\n                q.push(treeLeft);\\n            }\\n            \\n            getline(s,str,\\',\\');\\n            if(str==\"#\") node->right = NULL;\\n            else{\\n                TreeNode* treeRight = new TreeNode(stoi(str));\\n                node->right = treeRight;\\n                q.push(treeRight);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2320578,
                "title": "c-fast-simple-commented-picture",
                "content": "![image](https://assets.leetcode.com/users/images/e76a629b-b87e-47d9-92d0-2e294aa530bc_1658560288.5641255.png)\\n\\n![image](https://assets.leetcode.com/users/images/ed2b6a27-63b1-41c1-b031-7f3b1b7c5bcc_1658560294.6596942.png)\\n\\n![image](https://assets.leetcode.com/users/images/99407c1c-7db5-4aab-b864-e7c5cdba4083_1658560312.2203279.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/e76a629b-b87e-47d9-92d0-2e294aa530bc_1658560288.5641255.png)\\n\\n![image](https://assets.leetcode.com/users/images/ed2b6a27-63b1-41c1-b031-7f3b1b7c5bcc_1658560294.6596942.png)\\n\\n![image](https://assets.leetcode.com/users/images/99407c1c-7db5-4aab-b864-e7c5cdba4083_1658560312.2203279.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2269505,
                "title": "c-preorder-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root==NULL)\\n            return \"#,\";\\n        return to_string(root->val) + \\',\\' + serialize(root->left) + serialize(root->right) ;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    int ind=0;\\n    TreeNode* deserialize(string& data) {\\n        if(ind==data.length())\\n            return NULL;\\n        \\n        string t;\\n        while(ind<data.length() && data[ind]!=\\',\\')\\n        {\\n            t+=data[ind++];\\n        }\\n        ind++;\\n        if(t==\"#\")\\n            return NULL;\\n        int val=stoi(t);\\n        TreeNode* root= new TreeNode(val);\\n        root->left=deserialize(data);\\n        root->right=deserialize(data);\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root==NULL)\\n            return \"#,\";\\n        return to_string(root->val) + \\',\\' + serialize(root->left) + serialize(root->right) ;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    int ind=0;\\n    TreeNode* deserialize(string& data) {\\n        if(ind==data.length())\\n            return NULL;\\n        \\n        string t;\\n        while(ind<data.length() && data[ind]!=\\',\\')\\n        {\\n            t+=data[ind++];\\n        }\\n        ind++;\\n        if(t==\"#\")\\n            return NULL;\\n        int val=stoi(t);\\n        TreeNode* root= new TreeNode(val);\\n        root->left=deserialize(data);\\n        root->right=deserialize(data);\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262627,
                "title": "python-easy-solution-for-both-binary-tree-and-bst",
                "content": "## Solution\\n1. pre-order visit + mid-order visit  --> for binary tree\\n2. only pre-order visit  --> for BST\\n3. only level order visit --> reference solution \\n\\n```\\nfrom collections import deque\\nfrom typing import Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass CodecNormalTree:\\n    \"\"\"For binary tree (normal tree), we need to store both pre-order and mid-order\"\"\"\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        self.preorder_list = []\\n        self.midorder_list = []\\n        self.preorder_visit(root)\\n        self.midorder_visit(root)\\n        p = \\',\\'.join(map(str, self.preorder_list))\\n        m = \\',\\'.join(map(str, self.midorder_list))\\n        return p + \\' \\' + m\\n    \\n    def preorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.preorder_list.append(root.val)\\n        self.preorder_visit(root.left)\\n        self.preorder_visit(root.right)\\n    \\n    def midorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.midorder_visit(root.left)\\n        self.midorder_list.append(root.val)\\n        self.midorder_visit(root.right)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        p, m = data.split(\\' \\')\\n        if not p or not m:\\n            return None\\n        p_list = p.split(\\',\\')\\n        m_list = m.split(\\',\\')\\n        self.preorder_list = list(map(int, p_list))\\n        self.midorder_list = list(map(int, m_list))\\n        \\n        self.count = 0\\n        return self.construct_tree(0, len(self.preorder_list))\\n    \\n    def construct_tree(self, left, right) -> Optional[TreeNode]:\\n        if left >= right or self.count == len(self.preorder_list):\\n            return None\\n        root = TreeNode(self.preorder_list[self.count])\\n        self.count += 1\\n        idx = self.midorder_list.index(root.val)\\n        root.left = self.construct_tree(left, idx)\\n        root.right = self.construct_tree(idx + 1, right)\\n        return root\\n\\n\\nclass Codec_PreMid:\\n    \"\"\"For BST, we can utilize its feature: mid order is sorted!\"\"\"\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        self.preorder_list = []\\n        self.preorder_visit(root)\\n        p = \\',\\'.join(map(str, self.preorder_list))\\n        return p\\n    \\n    def preorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.preorder_list.append(root.val)\\n        self.preorder_visit(root.left)\\n        self.preorder_visit(root.right)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        p_list = data.split(\\',\\')\\n        self.preorder_list = list(map(int, p_list))\\n        self.midorder_list = sorted(self.preorder_list)\\n        self.count = 0\\n        return self.construct_tree(0, len(self.preorder_list))\\n    \\n    def construct_tree(self, left, right) -> Optional[TreeNode]:\\n        if left >= right or self.count == len(self.preorder_list):\\n            return None\\n        root = TreeNode(self.preorder_list[self.count])\\n        self.count += 1\\n        idx = self.midorder_list.index(root.val)\\n        root.left = self.construct_tree(left, idx)\\n        root.right = self.construct_tree(idx + 1, right)\\n        return root\\n\\n\\nclass CodecBFS:\\n    \"\"\"For BST, we can utilize its feature: level order is unique\"\"\"\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        tree = []\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node:\\n                tree.append(str(node.val))\\n                queue.extend([node.left, node.right])\\n            else:\\n                tree.append(\\'*\\')\\n        return \\',\\'.join(tree)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        tree = deque(data.split(\\',\\'))\\n        root = TreeNode(int(tree.popleft()))\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            \\n            if (left := tree.popleft()) != \\'*\\':\\n                node.left = TreeNode(int(left))\\n                queue.append(node.left)\\n            \\n            if (right := tree.popleft()) != \\'*\\':\\n                node.right = TreeNode(int(right))\\n                queue.append(node.right)\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\nfrom typing import Optional\\n\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\n\\nclass CodecNormalTree:\\n    \"\"\"For binary tree (normal tree), we need to store both pre-order and mid-order\"\"\"\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        self.preorder_list = []\\n        self.midorder_list = []\\n        self.preorder_visit(root)\\n        self.midorder_visit(root)\\n        p = \\',\\'.join(map(str, self.preorder_list))\\n        m = \\',\\'.join(map(str, self.midorder_list))\\n        return p + \\' \\' + m\\n    \\n    def preorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.preorder_list.append(root.val)\\n        self.preorder_visit(root.left)\\n        self.preorder_visit(root.right)\\n    \\n    def midorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.midorder_visit(root.left)\\n        self.midorder_list.append(root.val)\\n        self.midorder_visit(root.right)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        p, m = data.split(\\' \\')\\n        if not p or not m:\\n            return None\\n        p_list = p.split(\\',\\')\\n        m_list = m.split(\\',\\')\\n        self.preorder_list = list(map(int, p_list))\\n        self.midorder_list = list(map(int, m_list))\\n        \\n        self.count = 0\\n        return self.construct_tree(0, len(self.preorder_list))\\n    \\n    def construct_tree(self, left, right) -> Optional[TreeNode]:\\n        if left >= right or self.count == len(self.preorder_list):\\n            return None\\n        root = TreeNode(self.preorder_list[self.count])\\n        self.count += 1\\n        idx = self.midorder_list.index(root.val)\\n        root.left = self.construct_tree(left, idx)\\n        root.right = self.construct_tree(idx + 1, right)\\n        return root\\n\\n\\nclass Codec_PreMid:\\n    \"\"\"For BST, we can utilize its feature: mid order is sorted!\"\"\"\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        self.preorder_list = []\\n        self.preorder_visit(root)\\n        p = \\',\\'.join(map(str, self.preorder_list))\\n        return p\\n    \\n    def preorder_visit(self, root: Optional[TreeNode]):\\n        if not root:\\n            return None\\n        self.preorder_list.append(root.val)\\n        self.preorder_visit(root.left)\\n        self.preorder_visit(root.right)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        p_list = data.split(\\',\\')\\n        self.preorder_list = list(map(int, p_list))\\n        self.midorder_list = sorted(self.preorder_list)\\n        self.count = 0\\n        return self.construct_tree(0, len(self.preorder_list))\\n    \\n    def construct_tree(self, left, right) -> Optional[TreeNode]:\\n        if left >= right or self.count == len(self.preorder_list):\\n            return None\\n        root = TreeNode(self.preorder_list[self.count])\\n        self.count += 1\\n        idx = self.midorder_list.index(root.val)\\n        root.left = self.construct_tree(left, idx)\\n        root.right = self.construct_tree(idx + 1, right)\\n        return root\\n\\n\\nclass CodecBFS:\\n    \"\"\"For BST, we can utilize its feature: level order is unique\"\"\"\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        tree = []\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            if node:\\n                tree.append(str(node.val))\\n                queue.extend([node.left, node.right])\\n            else:\\n                tree.append(\\'*\\')\\n        return \\',\\'.join(tree)\\n    \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        tree = deque(data.split(\\',\\'))\\n        root = TreeNode(int(tree.popleft()))\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            \\n            if (left := tree.popleft()) != \\'*\\':\\n                node.left = TreeNode(int(left))\\n                queue.append(node.left)\\n            \\n            if (right := tree.popleft()) != \\'*\\':\\n                node.right = TreeNode(int(right))\\n                queue.append(node.right)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202099,
                "title": "java-level-order-traversal-readable-code",
                "content": "```\\npublic class Codec {\\n    /**\\n     * Traverses binary tree in level order \\n     * Stores node values in string(comma separated)\\n     */\\n    private String levelOrderTrav(TreeNode root){\\n        StringBuilder sb = new StringBuilder();\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.add(root);\\n        TreeNode itr = null;\\n        while(que.size()>0){\\n            itr = que.remove();\\n            if(itr!=null) {\\n                sb.append(itr.val+\",\");\\n                que.add(itr.left);\\n                que.add(itr.right);\\n            }\\n            else sb.append(\"n,\");\\n        }\\n        return sb.substring(0, sb.length()-1).toString();\\n    }\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        return levelOrderTrav(root);\\n    }\\n    /**\\n     * Contructs Binary Tree from leverl order traversalcomma separated string)\\n     */\\n    private TreeNode constructBstFromLevelOrderTrav(String data){\\n        String[] nodeValues = data.split(\",\");\\n        if(nodeValues[0].equals(\"n\")) return null; //zero nodes\\n        Queue<TreeNode> que = new LinkedList<>();\\n        TreeNode root = new TreeNode(Integer.parseInt(nodeValues[0]));\\n        que.add(root);\\n        TreeNode itr = null;\\n        int indx = 1;\\n        while(que.size()>0){\\n            itr = que.remove();\\n            String valL = nodeValues[indx++];\\n            String valR = nodeValues[indx++];\\n            if(!valL.equals(\"n\")){\\n                itr.left = new TreeNode(Integer.parseInt(valL));\\n                que.add(itr.left);\\n            }\\n            if(!valR.equals(\"n\")){\\n                itr.right = new TreeNode(Integer.parseInt(valR));\\n                que.add(itr.right);\\n            }\\n        }\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return constructBstFromLevelOrderTrav(data);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n    /**\\n     * Traverses binary tree in level order \\n     * Stores node values in string(comma separated)\\n     */\\n    private String levelOrderTrav(TreeNode root){\\n        StringBuilder sb = new StringBuilder();\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.add(root);\\n        TreeNode itr = null;\\n        while(que.size()>0){\\n            itr = que.remove();\\n            if(itr!=null) {\\n                sb.append(itr.val+\",\");\\n                que.add(itr.left);\\n                que.add(itr.right);\\n            }\\n            else sb.append(\"n,\");\\n        }\\n        return sb.substring(0, sb.length()-1).toString();\\n    }\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        return levelOrderTrav(root);\\n    }\\n    /**\\n     * Contructs Binary Tree from leverl order traversalcomma separated string)\\n     */\\n    private TreeNode constructBstFromLevelOrderTrav(String data){\\n        String[] nodeValues = data.split(\",\");\\n        if(nodeValues[0].equals(\"n\")) return null; //zero nodes\\n        Queue<TreeNode> que = new LinkedList<>();\\n        TreeNode root = new TreeNode(Integer.parseInt(nodeValues[0]));\\n        que.add(root);\\n        TreeNode itr = null;\\n        int indx = 1;\\n        while(que.size()>0){\\n            itr = que.remove();\\n            String valL = nodeValues[indx++];\\n            String valR = nodeValues[indx++];\\n            if(!valL.equals(\"n\")){\\n                itr.left = new TreeNode(Integer.parseInt(valL));\\n                que.add(itr.left);\\n            }\\n            if(!valR.equals(\"n\")){\\n                itr.right = new TreeNode(Integer.parseInt(valR));\\n                que.add(itr.right);\\n            }\\n        }\\n        return root;\\n    }\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        return constructBstFromLevelOrderTrav(data);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089613,
                "title": "c-extreme-compression-each-node-only-takes-2-chars-regardless-of-the-value",
                "content": "- The input range (i.e. `[0, 10000]`) can be represented by 14bits.\\n- We use another 2 bits to represent whether the node has left leaf or right leaf. Hence a single node can be represented by `uint16_t`, which is 2 chars. The top 2 bits can be reserved for representing left/right node existence.\\n- This probably can be further compressed using huffman encoding, but I didn\\'t go that far.\\n- Overall beats 90% time, 80% space (is the space measured by length of string or footprint of the program?)\\n```\\nclass Codec {\\npublic:\\n    const uint16_t kLeftBit = 0x8000;\\n    const uint16_t kRightBit = 0x4000;\\n    void encode(TreeNode* node, std::string& ret) {\\n        if (node == nullptr) {\\n            return;\\n        }\\n        // guranteed to be less than 14 bit\\n        uint16_t val = static_cast<uint16_t>(node->val);\\n        if (node->left != nullptr) {\\n            val |= kLeftBit;\\n        }\\n        if (node->right != nullptr) {\\n            val |= kRightBit;\\n        }\\n\\n        ret += static_cast<char>(val & 0x00ff);\\n        ret += static_cast<char>((val >> 8) & 0x00ff);\\n        encode(node->left, ret);\\n        encode(node->right, ret);\\n    }\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        std::string ret{\"\"};\\n        encode(root, ret);\\n        return ret;\\n    }\\n    \\n    TreeNode* decode(std::string& data, int& idx) {\\n        if (idx >= data.length()) {\\n            return nullptr;\\n        }\\n        uint16_t low = static_cast<uint16_t>(data[idx++]) & 0x00ff;\\n        uint16_t high = static_cast<uint16_t>(data[idx++]) & 0x00ff;\\n        uint16_t val = ((high << 8) & 0xff00) | low;\\n        \\n        bool hasLeft = (val & kLeftBit) > 0;\\n        bool hasRight = (val & kRightBit) > 0;\\n        // clear highest 2 bits\\n        val &= 0x3fff;\\n        TreeNode* curr = new TreeNode(static_cast<int>(val));\\n        if (hasLeft) {\\n            curr->left = decode(data, idx);\\n        }\\n        if (hasRight) {\\n            curr->right = decode(data, idx);\\n        }\\n        return curr;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int idx{0};\\n        return decode(data, idx);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Codec {\\npublic:\\n    const uint16_t kLeftBit = 0x8000;\\n    const uint16_t kRightBit = 0x4000;\\n    void encode(TreeNode* node, std::string& ret) {\\n        if (node == nullptr) {\\n            return;\\n        }\\n        // guranteed to be less than 14 bit\\n        uint16_t val = static_cast<uint16_t>(node->val);\\n        if (node->left != nullptr) {\\n            val |= kLeftBit;\\n        }\\n        if (node->right != nullptr) {\\n            val |= kRightBit;\\n        }\\n\\n        ret += static_cast<char>(val & 0x00ff);\\n        ret += static_cast<char>((val >> 8) & 0x00ff);\\n        encode(node->left, ret);\\n        encode(node->right, ret);\\n    }\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        std::string ret{\"\"};\\n        encode(root, ret);\\n        return ret;\\n    }\\n    \\n    TreeNode* decode(std::string& data, int& idx) {\\n        if (idx >= data.length()) {\\n            return nullptr;\\n        }\\n        uint16_t low = static_cast<uint16_t>(data[idx++]) & 0x00ff;\\n        uint16_t high = static_cast<uint16_t>(data[idx++]) & 0x00ff;\\n        uint16_t val = ((high << 8) & 0xff00) | low;\\n        \\n        bool hasLeft = (val & kLeftBit) > 0;\\n        bool hasRight = (val & kRightBit) > 0;\\n        // clear highest 2 bits\\n        val &= 0x3fff;\\n        TreeNode* curr = new TreeNode(static_cast<int>(val));\\n        if (hasLeft) {\\n            curr->left = decode(data, idx);\\n        }\\n        if (hasRight) {\\n            curr->right = decode(data, idx);\\n        }\\n        return curr;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int idx{0};\\n        return decode(data, idx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027240,
                "title": "java-dfs-solution",
                "content": "```\\npublic class Codec {\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        //pre-order root left right\\n        if(root == null)\\n            return \"\";\\n        String left = serialize(root.left);\\n        String right = serialize(root.right);\\n        return root.val + \",\" + left + right; \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data == null || data.length() == 0)\\n            return null;\\n        String[] temp = data.split(\",\");\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < temp.length; i ++){\\n            queue.offer(Integer.parseInt(temp[i]));\\n        }\\n        return build(queue, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode build(Queue<Integer> queue, int low, int high){\\n        if(queue.isEmpty() || queue.peek() < low || queue.peek() > high){\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(queue.poll());\\n        root.left = build(queue, low, root.val);\\n        root.right = build(queue, root.val, high);\\n        \\n        return root;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        //pre-order root left right\\n        if(root == null)\\n            return \"\";\\n        String left = serialize(root.left);\\n        String right = serialize(root.right);\\n        return root.val + \",\" + left + right; \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data == null || data.length() == 0)\\n            return null;\\n        String[] temp = data.split(\",\");\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < temp.length; i ++){\\n            queue.offer(Integer.parseInt(temp[i]));\\n        }\\n        return build(queue, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    private TreeNode build(Queue<Integer> queue, int low, int high){\\n        if(queue.isEmpty() || queue.peek() < low || queue.peek() > high){\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(queue.poll());\\n        root.left = build(queue, low, root.val);\\n        root.right = build(queue, root.val, high);\\n        \\n        return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976530,
                "title": "python-bfs-iterative-solution-serialized-string-compact",
                "content": "```python\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        result, q = [], []\\n        if root: q.append(root)\\n        for n in q:\\n            result.append(str(n.val))\\n            if n.left: q.append(n.left)\\n            if n.right: q.append(n.right)\\n        return \",\".join(result)\\n        \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if len(data) == 0: return None\\n        nodes, q, pos = data.split(\",\"), deque(), 1\\n        root = TreeNode(int(nodes[0]))\\n        q.append([root, -sys.maxsize, sys.maxsize])\\n        while q:\\n            n, lb, ub = q.popleft()\\n            if pos < len(nodes) and int(nodes[pos]) < n.val and lb <= int(nodes[pos]) <= ub:\\n                n.left = TreeNode(int(nodes[pos]))\\n                q.append([n.left, lb, n.val])\\n                pos += 1\\n            if pos < len(nodes) and int(nodes[pos]) > n.val and lb <= int(nodes[pos]) <= ub:\\n                n.right = TreeNode(int(nodes[pos]))\\n                q.append([n.right, n.val, ub])\\n                pos += 1\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```python\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        result, q = [], []\\n        if root: q.append(root)\\n        for n in q:\\n            result.append(str(n.val))\\n            if n.left: q.append(n.left)\\n            if n.right: q.append(n.right)\\n        return \",\".join(result)\\n        \\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if len(data) == 0: return None\\n        nodes, q, pos = data.split(\",\"), deque(), 1\\n        root = TreeNode(int(nodes[0]))\\n        q.append([root, -sys.maxsize, sys.maxsize])\\n        while q:\\n            n, lb, ub = q.popleft()\\n            if pos < len(nodes) and int(nodes[pos]) < n.val and lb <= int(nodes[pos]) <= ub:\\n                n.left = TreeNode(int(nodes[pos]))\\n                q.append([n.left, lb, n.val])\\n                pos += 1\\n            if pos < len(nodes) and int(nodes[pos]) > n.val and lb <= int(nodes[pos]) <= ub:\\n                n.right = TreeNode(int(nodes[pos]))\\n                q.append([n.right, n.val, ub])\\n                pos += 1\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952378,
                "title": "python-preorder-traversal-monotonic-stack-87-time-70-space",
                "content": "In case you don\\'t know, the pre-order traversal of the BST can be re-worked by a monotonic stack (try yourself to find out why and how, or check my codes).\\nSo we can pre-order traverse the BST to encode (only save non-empty nodes to save space), then use monotonic stack to re-incarnate the BST.\\nBoth time and space complexity of this method is O(n) (n is num of non-empty nodes).\\n```\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root:\\n            return \"\"\\n        if not root.left and not root.right:\\n            return str(root.val) + \",\"\\n        if root.left and not root.right:\\n            return str(root.val) + \",\" + self.serialize(root.left)\\n        if not root.left and root.right:\\n            return str(root.val) + \",\" + self.serialize(root.right)\\n        return str(root.val) + \",\" + self.serialize(root.left) + self.serialize(root.right)\\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        tmp = []\\n        start = 0\\n        end = 0\\n        while end < len(data):\\n            while end < len(data) and data[end] != \",\":\\n                end += 1\\n            tmp.append(int(data[start:end]))\\n            end += 1\\n            start = end\\n        root = TreeNode(tmp[0])\\n        s = [root]\\n        for x in tmp[1:]:\\n            node = TreeNode(x)\\n            if s and x < s[-1].val:\\n                s[-1].left = node\\n                s.append(node)\\n                continue\\n            cur = None\\n            while s and s[-1].val < x:\\n                cur = s.pop()\\n            if cur:\\n                cur.right = node\\n            s.append(node)\\n        return root",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "In case you don\\'t know, the pre-order traversal of the BST can be re-worked by a monotonic stack (try yourself to find out why and how, or check my codes).\\nSo we can pre-order traverse the BST to encode (only save non-empty nodes to save space), then use monotonic stack to re-incarnate the BST.\\nBoth time and space complexity of this method is O(n) (n is num of non-empty nodes).\\n```\\nclass Codec:\\n\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root:\\n            return \"\"\\n        if not root.left and not root.right:\\n            return str(root.val) + \",\"\\n        if root.left and not root.right:\\n            return str(root.val) + \",\" + self.serialize(root.left)\\n        if not root.left and root.right:\\n            return str(root.val) + \",\" + self.serialize(root.right)\\n        return str(root.val) + \",\" + self.serialize(root.left) + self.serialize(root.right)\\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data:\\n            return None\\n        tmp = []\\n        start = 0\\n        end = 0\\n        while end < len(data):\\n            while end < len(data) and data[end] != \",\":\\n                end += 1\\n            tmp.append(int(data[start:end]))\\n            end += 1\\n            start = end\\n        root = TreeNode(tmp[0])\\n        s = [root]\\n        for x in tmp[1:]:\\n            node = TreeNode(x)\\n            if s and x < s[-1].val:\\n                s[-1].left = node\\n                s.append(node)\\n                continue\\n            cur = None\\n            while s and s[-1].val < x:\\n                cur = s.pop()\\n            if cur:\\n                cur.right = node\\n            s.append(node)\\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 1891766,
                "title": "clean-postorder-in-python",
                "content": "```\\nclass Codec:\\n    SEP = \",\"\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        def postorder(n: TreeNode = root):\\n            if not n:\\n                return\\n            yield from postorder(n.left)\\n            yield from postorder(n.right)\\n            yield n.val\\n            \\n        return Codec.SEP.join(map(str, postorder()))\\n\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        data = [int(x) for x in data.split(Codec.SEP) if x]\\n        \\n        def helper(lo=-1, hi=10_001) -> TreeNode:\\n            if not data or data[-1] < lo or data[-1] > hi:\\n                return None\\n            n, v = TreeNode(data[-1]), data.pop()\\n            n.right, n.left = helper(v, hi), helper(lo, v)\\n            return n\\n        \\n        return helper()\\n```\\n\\ncomplaint: could be even cleaner if `TreeNode.__init__` supports keyword arguments for `left` and `right` :P",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Codec:\\n    SEP = \",\"\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        def postorder(n: TreeNode = root):\\n            if not n:\\n                return\\n            yield from postorder(n.left)\\n            yield from postorder(n.right)\\n            yield n.val\\n            \\n        return Codec.SEP.join(map(str, postorder()))\\n\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        data = [int(x) for x in data.split(Codec.SEP) if x]\\n        \\n        def helper(lo=-1, hi=10_001) -> TreeNode:\\n            if not data or data[-1] < lo or data[-1] > hi:\\n                return None\\n            n, v = TreeNode(data[-1]), data.pop()\\n            n.right, n.left = helper(v, hi), helper(lo, v)\\n            return n\\n        \\n        return helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777228,
                "title": "c",
                "content": "```\\nclass Codec {\\npublic:\\n\\n   string serialize(TreeNode* root) {\\n        if(root==NULL) return \"\";\\n        \\n        string s =\"\";\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()) {\\n           TreeNode* curNode = q.front();\\n           q.pop();\\n           if(curNode==NULL) s.append(\"#,\");\\n           else s.append(to_string(curNode->val)+\\',\\');\\n           if(curNode != NULL){\\n               q.push(curNode->left);\\n               q.push(curNode->right);            \\n           }\\n        }\\n        return s;\\n    }\\n\\n    // deserializing the string data \\n    TreeNode* deserialize(string data) {\\n        if(data.size() == 0) return NULL; \\n        stringstream s(data);\\n        string str; \\n        getline(s, str, \\',\\');\\n        TreeNode *root = new TreeNode(stoi(str));\\n        queue<TreeNode*> q; \\n        q.push(root); \\n        while(!q.empty()) {\\n            \\n            TreeNode *node = q.front(); \\n            q.pop(); \\n            \\n            getline(s, str, \\',\\');\\n            if(str == \"#\") {\\n                node->left = NULL; \\n            }\\n            else {\\n                TreeNode* leftNode = new TreeNode(stoi(str)); \\n                node->left = leftNode; \\n                q.push(leftNode); \\n            }\\n            \\n            getline(s, str, \\',\\');\\n            if(str == \"#\") {\\n                node->right = NULL; \\n            }\\n            else {\\n                TreeNode* rightNode = new TreeNode(stoi(str)); \\n                node->right = rightNode;\\n                q.push(rightNode); \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n   string serialize(TreeNode* root) {\\n        if(root==NULL) return \"\";\\n        \\n        string s =\"\";\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()) {\\n           TreeNode* curNode = q.front();\\n           q.pop();\\n           if(curNode==NULL) s.append(\"#,\");\\n           else s.append(to_string(curNode->val)+\\',\\');\\n           if(curNode != NULL){\\n               q.push(curNode->left);\\n               q.push(curNode->right);            \\n           }\\n        }\\n        return s;\\n    }\\n\\n    // deserializing the string data \\n    TreeNode* deserialize(string data) {\\n        if(data.size() == 0) return NULL; \\n        stringstream s(data);\\n        string str; \\n        getline(s, str, \\',\\');\\n        TreeNode *root = new TreeNode(stoi(str));\\n        queue<TreeNode*> q; \\n        q.push(root); \\n        while(!q.empty()) {\\n            \\n            TreeNode *node = q.front(); \\n            q.pop(); \\n            \\n            getline(s, str, \\',\\');\\n            if(str == \"#\") {\\n                node->left = NULL; \\n            }\\n            else {\\n                TreeNode* leftNode = new TreeNode(stoi(str)); \\n                node->left = leftNode; \\n                q.push(leftNode); \\n            }\\n            \\n            getline(s, str, \\',\\');\\n            if(str == \"#\") {\\n                node->right = NULL; \\n            }\\n            else {\\n                TreeNode* rightNode = new TreeNode(stoi(str)); \\n                node->right = rightNode;\\n                q.push(rightNode); \\n            }\\n        }\\n        return root; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676450,
                "title": "c-92-postorder",
                "content": "**Runtime:** 28 ms, faster than 92.32% of C++ online submissions for Serialize and Deserialize BST.\\n**Memory Usage:** 27 MB, less than 62.26% of C++ online submissions for Serialize and Deserialize BST.\\n```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str;\\n        postorder(root, str);\\n        if(str.size() > 0) str.pop_back();\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()) return nullptr;\\n        vector<int> nums;\\n        int curr = 0;\\n        for(int i = 0; i <= data.size(); ++i) {\\n            if(i == data.size() || data[i] == \\' \\') {\\n                nums.push_back(curr);\\n                curr = 0;\\n            }else {\\n                curr = curr * 10 - \\'0\\' + data[i];\\n            }\\n        }\\n        return deserHelper(nums, INT_MIN, INT_MAX);\\n    }\\n    \\n    void postorder(TreeNode* root, string& str) {\\n        if(root == nullptr) return;\\n        postorder(root->left, str);\\n        postorder(root->right, str);\\n        str.append(to_string(root->val));\\n        str.append(\" \");\\n    }\\n    \\n    TreeNode* deserHelper(vector<int>& nums, int lower, int upper) {\\n        if(nums.empty()) return nullptr;\\n        int val = nums[nums.size() - 1];\\n        if(val < lower || val > upper) return nullptr;\\n        nums.pop_back();\\n        TreeNode* root = new TreeNode(val);\\n        root->right = deserHelper(nums, val, upper);\\n        root->left = deserHelper(nums, lower, val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str;\\n        postorder(root, str);\\n        if(str.size() > 0) str.pop_back();\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty()) return nullptr;\\n        vector<int> nums;\\n        int curr = 0;\\n        for(int i = 0; i <= data.size(); ++i) {\\n            if(i == data.size() || data[i] == \\' \\') {\\n                nums.push_back(curr);\\n                curr = 0;\\n            }else {\\n                curr = curr * 10 - \\'0\\' + data[i];\\n            }\\n        }\\n        return deserHelper(nums, INT_MIN, INT_MAX);\\n    }\\n    \\n    void postorder(TreeNode* root, string& str) {\\n        if(root == nullptr) return;\\n        postorder(root->left, str);\\n        postorder(root->right, str);\\n        str.append(to_string(root->val));\\n        str.append(\" \");\\n    }\\n    \\n    TreeNode* deserHelper(vector<int>& nums, int lower, int upper) {\\n        if(nums.empty()) return nullptr;\\n        int val = nums[nums.size() - 1];\\n        if(val < lower || val > upper) return nullptr;\\n        nums.pop_back();\\n        TreeNode* root = new TreeNode(val);\\n        root->right = deserHelper(nums, val, upper);\\n        root->left = deserHelper(nums, lower, val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669607,
                "title": "python-3-way-general-tree-preorder-postorder",
                "content": "Approach 1, general Binary Tree method. \\n\\n```\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def helper(node, string):\\n            if not node:\\n                string += \\'None,\\'\\n            else:\\n                string += str(node.val) + \\',\\'\\n                string = helper(node.left, string)\\n                string = helper(node.right, string)\\n            return string\\n        return helper(root, \\'\\')\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def helper(l):\\n            if l[0] == \\'None\\':\\n                l.pop(0)\\n                return None\\n            root = TreeNode(l[0])\\n            l.pop(0)\\n            root.left = helper(l)\\n            root.right = helper(l)\\n            return root\\n        data_list = data.split(\\',\\')\\n        root = helper(data_list)\\n        return root\\n```\\n\\nApproach 2, preorder way\\n```\\n        def serialize(self, root: Optional[TreeNode]) -> str:\\n            def helper(node):\\n                return [node.val] + helper(node.left) + helper(node.right) if node else []\\n            return \\' \\'.join(map(str, helper(root)))\\n        \\n        def deserialize(self, data: str) -> Optional[TreeNode]:\\n            data = [int(x) for x in data.split() if x]\\n            def helper(lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n                if not data or data[0] < lower or data[0] > upper:\\n                    return None\\n                val = data[0]\\n                root = TreeNode(val)\\n                root.left = helper(lower, val)\\n                root.right = helper(val, upper)\\n                return root\\n            return helper()\\n```\\n\\napproach 3, postorder way\\n```\\n        def serialize(self, root: Optional[TreeNode]) -> str:\\n            def helper(node):\\n                return helper(node.left) + helper(node.right) + [node.val] if node else []\\n            return \\' \\'.join(map(str, helper(root)))\\n                  \\n        \\n        def deserialize(self, data: str) -> Optional[TreeNode]:\\n            def helper(lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n                if not data or data[-1] < lower or data[-1] > upper:\\n                    return None # if root is not within the range, means there is no node. \\n                val = data.pop()\\n                root = TreeNode(val)\\n                root.right = helper(val, upper) #pop() is poping the last element, so we need to do right first, as it is left -> right -> root\\n                root.left = helper(lower, val)\\n                return root\\n            data = [int(x) for x in data.split(\\' \\') if x]\\n            return helper()\\n```",
                "solutionTags": [],
                "code": "```\\n    def serialize(self, root: Optional[TreeNode]) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def helper(node, string):\\n            if not node:\\n                string += \\'None,\\'\\n            else:\\n                string += str(node.val) + \\',\\'\\n                string = helper(node.left, string)\\n                string = helper(node.right, string)\\n            return string\\n        return helper(root, \\'\\')\\n        \\n\\n    def deserialize(self, data: str) -> Optional[TreeNode]:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def helper(l):\\n            if l[0] == \\'None\\':\\n                l.pop(0)\\n                return None\\n            root = TreeNode(l[0])\\n            l.pop(0)\\n            root.left = helper(l)\\n            root.right = helper(l)\\n            return root\\n        data_list = data.split(\\',\\')\\n        root = helper(data_list)\\n        return root\\n```\n```\\n        def serialize(self, root: Optional[TreeNode]) -> str:\\n            def helper(node):\\n                return [node.val] + helper(node.left) + helper(node.right) if node else []\\n            return \\' \\'.join(map(str, helper(root)))\\n        \\n        def deserialize(self, data: str) -> Optional[TreeNode]:\\n            data = [int(x) for x in data.split() if x]\\n            def helper(lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n                if not data or data[0] < lower or data[0] > upper:\\n                    return None\\n                val = data[0]\\n                root = TreeNode(val)\\n                root.left = helper(lower, val)\\n                root.right = helper(val, upper)\\n                return root\\n            return helper()\\n```\n```\\n        def serialize(self, root: Optional[TreeNode]) -> str:\\n            def helper(node):\\n                return helper(node.left) + helper(node.right) + [node.val] if node else []\\n            return \\' \\'.join(map(str, helper(root)))\\n                  \\n        \\n        def deserialize(self, data: str) -> Optional[TreeNode]:\\n            def helper(lower = float(\\'-inf\\'), upper = float(\\'inf\\')):\\n                if not data or data[-1] < lower or data[-1] > upper:\\n                    return None # if root is not within the range, means there is no node. \\n                val = data.pop()\\n                root = TreeNode(val)\\n                root.right = helper(val, upper) #pop() is poping the last element, so we need to do right first, as it is left -> right -> root\\n                root.left = helper(lower, val)\\n                return root\\n            data = [int(x) for x in data.split(\\' \\') if x]\\n            return helper()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1662351,
                "title": "c-fast-codec-apis-post-order-traversal-while-encoding",
                "content": "```cpp\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (root == nullptr) return \"(#)\";\\n        string left = serialize(root->left);\\n        string right = serialize(root->right);\\n        return \"(\" + to_string(root->val) + left + right + \")\";\\n    }\\n    \\n    \\n    TreeNode *decode(string &data, int &n) {\\n        ++n;\\n        string curNum = \"\";\\n        while(data[n] != \\')\\' && data[n] != \\'(\\') {\\n            curNum += data[n];\\n            ++n;\\n        }\\n        TreeNode *root = nullptr;\\n        if (curNum != \"#\") {\\n            root = new TreeNode(stoi(curNum));\\n            if(data[n] == \\'(\\') root->left = decode(data, n);\\n            if(data[n] == \\'(\\') root->right = decode(data, n);\\n        }\\n        ++n;\\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int n = 0;\\n        return decode(data, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (root == nullptr) return \"(#)\";\\n        string left = serialize(root->left);\\n        string right = serialize(root->right);\\n        return \"(\" + to_string(root->val) + left + right + \")\";\\n    }\\n    \\n    \\n    TreeNode *decode(string &data, int &n) {\\n        ++n;\\n        string curNum = \"\";\\n        while(data[n] != \\')\\' && data[n] != \\'(\\') {\\n            curNum += data[n];\\n            ++n;\\n        }\\n        TreeNode *root = nullptr;\\n        if (curNum != \"#\") {\\n            root = new TreeNode(stoi(curNum));\\n            if(data[n] == \\'(\\') root->left = decode(data, n);\\n            if(data[n] == \\'(\\') root->right = decode(data, n);\\n        }\\n        ++n;\\n        return root;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int n = 0;\\n        return decode(data, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643817,
                "title": "c-using-bytes-to-compact",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (root == nullptr) {\\n            return \"\";\\n        }\\n        std::vector<unsigned char> bytes;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while (!st.empty()) {\\n            TreeNode* top = st.top();\\n            bytes.resize(bytes.size()+sizeof(int));\\n            memcpy(&bytes[bytes.size()-sizeof(int)], &(top->val), sizeof(int));\\n            st.pop();\\n            if (top->left != nullptr) {\\n                st.push(top->left);\\n            }\\n            if (top->right != nullptr) {\\n                st.push(top->right);\\n            }\\n        }\\n        return std::string(bytes.begin(), bytes.end());\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if (data.empty()) {\\n            return nullptr;\\n        }\\n        TreeNode* result = nullptr;\\n        for (int i=0; i<data.length(); i+=sizeof(int)) {\\n            int val;\\n            memcpy(&val, &data[i], sizeof(int));\\n            Insert(result, val);\\n        }\\n        return result;\\n    }\\n    \\n    void Insert(TreeNode*& root, int val) {\\n        if (root == nullptr) {\\n            root = new TreeNode(val);\\n            return;\\n        }\\n        if (val < root->val) {\\n            Insert(root->left, val);\\n        } else {\\n            Insert(root->right, val);\\n        }\\n    }\\n    \\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if (root == nullptr) {\\n            return \"\";\\n        }\\n        std::vector<unsigned char> bytes;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while (!st.empty()) {\\n            TreeNode* top = st.top();\\n            bytes.resize(bytes.size()+sizeof(int));\\n            memcpy(&bytes[bytes.size()-sizeof(int)], &(top->val), sizeof(int));\\n            st.pop();\\n            if (top->left != nullptr) {\\n                st.push(top->left);\\n            }\\n            if (top->right != nullptr) {\\n                st.push(top->right);\\n            }\\n        }\\n        return std::string(bytes.begin(), bytes.end());\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if (data.empty()) {\\n            return nullptr;\\n        }\\n        TreeNode* result = nullptr;\\n        for (int i=0; i<data.length(); i+=sizeof(int)) {\\n            int val;\\n            memcpy(&val, &data[i], sizeof(int));\\n            Insert(result, val);\\n        }\\n        return result;\\n    }\\n    \\n    void Insert(TreeNode*& root, int val) {\\n        if (root == nullptr) {\\n            root = new TreeNode(val);\\n            return;\\n        }\\n        if (val < root->val) {\\n            Insert(root->left, val);\\n        } else {\\n            Insert(root->right, val);\\n        }\\n    }\\n    \\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625604,
                "title": "solved-using-preorder-bst-traversal-again-building-back-the-tree-from-string-with-explanation",
                "content": "Accepted\\t\\n32 ms\\t\\n28.5 MB\\t\\ncpp\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return preorderTraverse(root);\\n    }\\n    \\n    // this function will create a preoder string of given bst\\n    // why preorder?\\n    // bcz then after we can easily create back the same bst using that preorder string of a bst\\n    string preorderTraverse(TreeNode* root)\\n    {\\n        if(!root)\\n            return\"\";\\n        \\n        return to_string(root->val) + \"-\" + preorderTraverse(root->left) + preorderTraverse(root->right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        vector<int>preorder;\\n        \\n        // cout<<data;\\n        \\n        // convert string to integers again & save them to vector\\n        while (getline (ss, item, \\'-\\')) \\n        {\\n            preorder.push_back(stoi(item));\\n        }\\n        \\n        int start=0,end=preorder.size()-1;\\n        return  makeTree(preorder,start,end);\\n    }\\n    \\n    // building out a bst from given preorder\\n    TreeNode* makeTree(vector<int> &preorder ,int start, int end)\\n    {\\n        if(start<=end)\\n        {\\n            TreeNode* newnode = new TreeNode(preorder[start]);\\n            \\n            int bigger=start+1;\\n            while(bigger<=end && preorder[start]>preorder[bigger])\\n            {\\n                bigger++;\\n            }\\n            \\n            if(bigger>end)\\n            {\\n                newnode->left = makeTree(preorder,start+1,end);\\n                newnode->right = NULL;\\n            }\\n            else\\n            {\\n                newnode->left = makeTree(preorder,start+1,bigger-1);\\n                newnode->right = makeTree(preorder,bigger,end);\\n            }\\n            \\n            return newnode;\\n        }\\n        else\\n        {\\n            return NULL;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        return preorderTraverse(root);\\n    }\\n    \\n    // this function will create a preoder string of given bst\\n    // why preorder?\\n    // bcz then after we can easily create back the same bst using that preorder string of a bst\\n    string preorderTraverse(TreeNode* root)\\n    {\\n        if(!root)\\n            return\"\";\\n        \\n        return to_string(root->val) + \"-\" + preorderTraverse(root->left) + preorderTraverse(root->right);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream ss(data);\\n        string item;\\n        vector<int>preorder;\\n        \\n        // cout<<data;\\n        \\n        // convert string to integers again & save them to vector\\n        while (getline (ss, item, \\'-\\')) \\n        {\\n            preorder.push_back(stoi(item));\\n        }\\n        \\n        int start=0,end=preorder.size()-1;\\n        return  makeTree(preorder,start,end);\\n    }\\n    \\n    // building out a bst from given preorder\\n    TreeNode* makeTree(vector<int> &preorder ,int start, int end)\\n    {\\n        if(start<=end)\\n        {\\n            TreeNode* newnode = new TreeNode(preorder[start]);\\n            \\n            int bigger=start+1;\\n            while(bigger<=end && preorder[start]>preorder[bigger])\\n            {\\n                bigger++;\\n            }\\n            \\n            if(bigger>end)\\n            {\\n                newnode->left = makeTree(preorder,start+1,end);\\n                newnode->right = NULL;\\n            }\\n            else\\n            {\\n                newnode->left = makeTree(preorder,start+1,bigger-1);\\n                newnode->right = makeTree(preorder,bigger,end);\\n            }\\n            \\n            return newnode;\\n        }\\n        else\\n        {\\n            return NULL;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1562441,
                "title": "java-easyy-with-2-preorder-traversl-o-2n",
                "content": "```\\npublic class Codec {\\n  public void helper(TreeNode node,StringBuilder str){\\n      if(node==null){\\n          str.append(\"#\"+\" \");\\n          return ;\\n      }\\n      \\n      str.append(node.val+\" \");\\n      helper(node.left,str);\\n      helper(node.right,str);\\n  }\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder str=new StringBuilder();\\n        helper(root,str);\\n        \\n        return str.toString();\\n    }\\n \\n    public TreeNode dhelper(String[] arr,int []idx){\\n        if(idx[0]>arr.length || arr[idx[0]].equals(\"#\")){\\n            idx[0]++;\\n            return null;\\n        }\\n        int i=idx[0];\\n        idx[0]++;\\n        int val=Integer.parseInt(arr[i]);\\n        \\n        TreeNode left=dhelper(arr,idx);\\n        TreeNode right=dhelper(arr,idx);\\n        \\n        TreeNode node=new TreeNode(val);\\n        \\n        node.left=left;\\n        node.right=right;\\n        \\n        \\n        return node;\\n        \\n    }\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String arr[]=data.split(\" \");\\n        int idx[]=new int[1];\\n        return dhelper(arr,idx);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n  public void helper(TreeNode node,StringBuilder str){\\n      if(node==null){\\n          str.append(\"#\"+\" \");\\n          return ;\\n      }\\n      \\n      str.append(node.val+\" \");\\n      helper(node.left,str);\\n      helper(node.right,str);\\n  }\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder str=new StringBuilder();\\n        helper(root,str);\\n        \\n        return str.toString();\\n    }\\n \\n    public TreeNode dhelper(String[] arr,int []idx){\\n        if(idx[0]>arr.length || arr[idx[0]].equals(\"#\")){\\n            idx[0]++;\\n            return null;\\n        }\\n        int i=idx[0];\\n        idx[0]++;\\n        int val=Integer.parseInt(arr[i]);\\n        \\n        TreeNode left=dhelper(arr,idx);\\n        TreeNode right=dhelper(arr,idx);\\n        \\n        TreeNode node=new TreeNode(val);\\n        \\n        node.left=left;\\n        node.right=right;\\n        \\n        \\n        return node;\\n        \\n    }\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String arr[]=data.split(\" \");\\n        int idx[]=new int[1];\\n        return dhelper(arr,idx);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1557031,
                "title": "simple-c-solution-using-preorder-concept",
                "content": "class Codec {\\npublic:\\n\\n    TreeNode* helper(stringstream &str){\\n        string s;\\n        getline(str, s, \\' \\');\\n        if(s == \"#\")\\n            return NULL;\\n        TreeNode *root = new TreeNode(stoi(s));\\n        root->left = helper(str);\\n        root->right = helper(str);\\n        return root;\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL)\\n            return \"#\";\\n        return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right);\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream s(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        return helper(s);\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Codec {\\npublic:\\n\\n    TreeNode* helper(stringstream &str){\\n        string s;\\n        getline(str, s, \\' \\');\\n        if(s == \"#\")\\n            return NULL;\\n        TreeNode *root = new TreeNode(stoi(s));\\n        root->left = helper(str);\\n        root->right = helper(str);\\n        return root;\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        if(root == NULL)\\n            return \"#\";\\n        return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right);\\n        \\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        stringstream s(data);\\n        string item;\\n        TreeNode* root = NULL;\\n        return helper(s);\\n\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1529425,
                "title": "c-easy-solution-with-short-explanation",
                "content": "\\t/*In Serialize part we are traversing the tree in Preorder and then storing it in the string \\n\\twith a space after each number in order to identify distinct numbers.....(preorder function is for this)\\n\\t\\n\\tnow in deserializing we are storing the string into a vector(pre) and then sorting it into another\\n\\tvector (in)  now we are converting it into tree using preorder and inorder traversal\\n\\t(solve function is for this) :) */\\n\\t\\n\\t\\n\\tclass Codec {\\n\\tpublic:\\n        string pre=\"\";\\n    int x=0;\\n    \\n\\t  //Deserialize\\n    TreeNode* solve(vector<int>& pre,vector<int>& in,int i,int j){\\n            if(i > j) return NULL;\\n            int m;\\n            if(x < pre.size()){\\n                for(m=i;m<=j;++m){\\n                    if(pre[x] == in[m]){\\n                        x++;\\n                       break; \\n                    }\\n                }\\n            } else return NULL;\\n            TreeNode* temp = new TreeNode(in[m]);\\n            temp->left=solve(pre,in,i,m-1);\\n            temp->right=solve(pre,in,m+1,j);\\n            \\n            return temp;\\n            \\n        }\\n    \\n    \\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        preorder(root);\\n        return pre;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        vector<int> in;\\n        int i=0;\\n        while(i <data.size()){\\n            if(data[i]!=\\' \\'){\\n                int val=0;\\n                while(i < data.size() && data[i]!=\\' \\'){\\n                    val=val*10+(data[i++]-48);\\n                }\\n                in.push_back(val);\\n            }else i++;\\n        }\\n        vector<int> pre=in;\\n        sort(in.begin(),in.end());\\n        \\n      return solve(pre,in,0,pre.size()-1);\\n    }\\n    \\n    \\n    //for preorder\\n    void preorder(TreeNode* root){\\n        if(!root) return;\\n        pre+=to_string(root->val);\\n        pre+= \" \";\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "\\t/*In Serialize part we are traversing the tree in Preorder and then storing it in the string \\n\\twith a space after each number in order to identify distinct numbers.....(preorder function is for this)\\n\\t\\n\\tnow in deserializing we are storing the string into a vector(pre) and then sorting it into another\\n\\tvector (in)  now we are converting it into tree using preorder and inorder traversal\\n\\t(solve function is for this) :) */\\n\\t\\n\\t\\n\\tclass Codec {\\n\\tpublic:\\n        string pre=\"\";\\n    int x=0;\\n    \\n\\t  //Deserialize\\n    TreeNode* solve(vector<int>& pre,vector<int>& in,int i,int j){\\n            if(i > j) return NULL;\\n            int m;\\n            if(x < pre.size()){\\n                for(m=i;m<=j;++m){\\n                    if(pre[x] == in[m]){\\n                        x++;\\n                       break; \\n                    }\\n                }\\n            } else return NULL;\\n            TreeNode* temp = new TreeNode(in[m]);\\n            temp->left=solve(pre,in,i,m-1);\\n            temp->right=solve(pre,in,m+1,j);\\n            \\n            return temp;\\n            \\n        }\\n    \\n    \\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        preorder(root);\\n        return pre;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        vector<int> in;\\n        int i=0;\\n        while(i <data.size()){\\n            if(data[i]!=\\' \\'){\\n                int val=0;\\n                while(i < data.size() && data[i]!=\\' \\'){\\n                    val=val*10+(data[i++]-48);\\n                }\\n                in.push_back(val);\\n            }else i++;\\n        }\\n        vector<int> pre=in;\\n        sort(in.begin(),in.end());\\n        \\n      return solve(pre,in,0,pre.size()-1);\\n    }\\n    \\n    \\n    //for preorder\\n    void preorder(TreeNode* root){\\n        if(!root) return;\\n        pre+=to_string(root->val);\\n        pre+= \" \";\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 1527925,
                "title": "javascript-optimize-solution-for-serialize-and-deserialize-bst",
                "content": "``` \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    if(root === null) {\\n        return \\'X\\';\\n    }\\n       let leftTree = serialize(root.left);\\n       let rightTree = serialize(root.right);\\n       return root.val + \\',\\' +leftTree + \\',\\' + rightTree;\\n    \\n    \\n    \\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    const queue = [...data.split(\\',\\')];\\n    return helper(queue);\\n    function helper(queue) {\\n        let val = queue.shift();\\n        if (val === \\'X\\') {\\n            return null;\\n        }\\n        const node = new TreeNode(val);\\n        node.left = helper(queue);\\n        node.right = helper(queue);\\n        return node\\n    }\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ````",
                "solutionTags": [],
                "code": "``` \\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    if(root === null) {\\n        return \\'X\\';\\n    }\\n       let leftTree = serialize(root.left);\\n       let rightTree = serialize(root.right);\\n       return root.val + \\',\\' +leftTree + \\',\\' + rightTree;\\n    \\n    \\n    \\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    const queue = [...data.split(\\',\\')];\\n    return helper(queue);\\n    function helper(queue) {\\n        let val = queue.shift();\\n        if (val === \\'X\\') {\\n            return null;\\n        }\\n        const node = new TreeNode(val);\\n        node.left = helper(queue);\\n        node.right = helper(queue);\\n        return node\\n    }\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447456,
                "title": "preorder-binarysearch",
                "content": "Preorder of a bst is enough for its idenity first save its preorder in a string.\\nwhile deserializing we can store preorder in vector then can convert preorder to BST,we can use binary search to find number of nodes going to left and right.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void f(TreeNode* root,string& s){\\n        if(!root)\\n            return;\\n        s=s+to_string(root->val);\\n        s.push_back(\\'*\\');\\n        f(root->left,s);\\n        f(root->right,s);\\n    }\\n    string serialize(TreeNode* root) {\\n        string s;\\n        f(root,s);\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    int bs(vector<int>&v,int l,int h){\\n        int x=h+1;\\n        int i=l-1;\\n        while(l<=h){\\n            int m=(l+h)/2;\\n            if(v[m]>v[i]){\\n                x=m;\\n                h=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return x;\\n    }\\n    TreeNode* g(vector<int>&v,int l,int h){\\n        if(h<l)\\n            return NULL;\\n         if(l==h)\\n             return new TreeNode(v[l]);\\n        int x=bs(v,l+1,h);\\n        return new TreeNode(v[l],g(v,l+1,x-1),g(v,x,h));\\n    }\\n    TreeNode* deserialize(string data) {\\n        vector<int>v;\\n        string t;\\n        int n=data.size();\\n        for(int i=0;i<n;i++){\\n            if(data[i]==\\'*\\')\\n            {    v.push_back(stoi(t));\\n                t=\"\";}\\n            else\\n                t.push_back(data[i]);\\n            \\n        }\\n        return g(v,0,v.size()-1);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    void f(TreeNode* root,string& s){\\n        if(!root)\\n            return;\\n        s=s+to_string(root->val);\\n        s.push_back(\\'*\\');\\n        f(root->left,s);\\n        f(root->right,s);\\n    }\\n    string serialize(TreeNode* root) {\\n        string s;\\n        f(root,s);\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    int bs(vector<int>&v,int l,int h){\\n        int x=h+1;\\n        int i=l-1;\\n        while(l<=h){\\n            int m=(l+h)/2;\\n            if(v[m]>v[i]){\\n                x=m;\\n                h=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return x;\\n    }\\n    TreeNode* g(vector<int>&v,int l,int h){\\n        if(h<l)\\n            return NULL;\\n         if(l==h)\\n             return new TreeNode(v[l]);\\n        int x=bs(v,l+1,h);\\n        return new TreeNode(v[l],g(v,l+1,x-1),g(v,x,h));\\n    }\\n    TreeNode* deserialize(string data) {\\n        vector<int>v;\\n        string t;\\n        int n=data.size();\\n        for(int i=0;i<n;i++){\\n            if(data[i]==\\'*\\')\\n            {    v.push_back(stoi(t));\\n                t=\"\";}\\n            else\\n                t.push_back(data[i]);\\n            \\n        }\\n        return g(v,0,v.size()-1);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec* ser = new Codec();\\n// Codec* deser = new Codec();\\n// string tree = ser->serialize(root);\\n// TreeNode* ans = deser->deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400933,
                "title": "beat-99-2ms-no-delimiter-e-g-comma-no-stack-queue-just-turn-val-into-char",
                "content": "```\\npublic class Codec {\\n\\n    /*\\n    max node.val is 10000, less than 6xxxx(max value of char)   \\n    So just turn node.val into char.\\n    Serialize with preorder (parent > left > right)\\n    */\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        helper_serialize(sb, root);\\n        return sb.toString();\\n    }\\n    \\n    private void helper_serialize(StringBuilder sb, TreeNode root) {\\n        if (root == null) \\n            return;\\n        sb.append((char)(root.val + \\'0\\'));\\n        helper_serialize(sb, root.left);\\n        helper_serialize(sb, root.right);\\n    }\\n\\n    /*\\n    it\\'s BST, so it\\'s already in proper order as long as you add the node in order.\\n    */\\n    public TreeNode deserialize(String data) {\\n        TreeNode root = null;\\n        for(char c : data.toCharArray()) {\\n            root = add(root, c - \\'0\\');\\n        }\\n        return root;\\n    }\\n    private TreeNode add(TreeNode root, int val) {\\n        if (root == null)\\n            return new TreeNode(val);\\n        \\n        if (val < root.val) {\\n            root.left = add(root.left, val);\\n        } else {\\n            root.right = add(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n\\nFYI what char looks like when int is above 9:\\n\\n```\\nint: 5 char: 5\\nint: 6 char: 6\\nint: 7 char: 7\\nint: 8 char: 8\\nint: 9 char: 9\\nint: 10 char: :\\nint: 11 char: ;\\nint: 12 char: <\\nint: 13 char: =\\nint: 14 char: >\\nint: 15 char: ?\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Codec {\\n\\n    /*\\n    max node.val is 10000, less than 6xxxx(max value of char)   \\n    So just turn node.val into char.\\n    Serialize with preorder (parent > left > right)\\n    */\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        helper_serialize(sb, root);\\n        return sb.toString();\\n    }\\n    \\n    private void helper_serialize(StringBuilder sb, TreeNode root) {\\n        if (root == null) \\n            return;\\n        sb.append((char)(root.val + \\'0\\'));\\n        helper_serialize(sb, root.left);\\n        helper_serialize(sb, root.right);\\n    }\\n\\n    /*\\n    it\\'s BST, so it\\'s already in proper order as long as you add the node in order.\\n    */\\n    public TreeNode deserialize(String data) {\\n        TreeNode root = null;\\n        for(char c : data.toCharArray()) {\\n            root = add(root, c - \\'0\\');\\n        }\\n        return root;\\n    }\\n    private TreeNode add(TreeNode root, int val) {\\n        if (root == null)\\n            return new TreeNode(val);\\n        \\n        if (val < root.val) {\\n            root.left = add(root.left, val);\\n        } else {\\n            root.right = add(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nint: 5 char: 5\\nint: 6 char: 6\\nint: 7 char: 7\\nint: 8 char: 8\\nint: 9 char: 9\\nint: 10 char: :\\nint: 11 char: ;\\nint: 12 char: <\\nint: 13 char: =\\nint: 14 char: >\\nint: 15 char: ?\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386028,
                "title": "python-solution-based-on-preorder-and-inorder-traversals",
                "content": "Using preorder only (utilize BST property):\\n```Python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def preorderTraversal(node):\\n            if not node:\\n                return\\n            data.append(str(node.val))\\n            preorderTraversal(node.left)\\n            preorderTraversal(node.right)\\n        data = []\\n        preorderTraversal(root)\\n        return \".\".join(data)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def buildTree(values):\\n            if not values:\\n                return\\n            root = TreeNode(values[0])\\n            # find the smallest value that is \\n            # greater than root\\n            idx = 1\\n            while idx < len(values) and values[idx] < values[0]:\\n                idx += 1\\n            root.left = buildTree(values[1:idx])\\n            root.right = buildTree(values[idx:])\\n            return root\\n            \\n        values = [int(x) for x in data.split(\".\") if x]\\n        return buildTree(values)\\n            \\n        \\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```\\n\\nUse both preorder and inorder (don\\'t utilize BST property)\\n```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return\\n        self.inorderTraversal(root.left)\\n        self.inorder.append(str(root.val))\\n        self.inorderTraversal(root.right)\\n        \\n    def preorderTraversal(self, root):\\n        if not root:\\n            return\\n        self.preorder.append(str(root.val))\\n        self.preorderTraversal(root.left)\\n        self.preorderTraversal(root.right)\\n    \\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        self.inorder = []\\n        self.preorder = []\\n        self.inorderTraversal(root)\\n        self.preorderTraversal(root)\\n        return \".\".join(self.inorder)+\\',\\'+\\'.\\'.join(self.preorder)\\n        \\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def reconstruct(inorder, preorder):\\n            if not inorder:\\n                return\\n            \\n            if preorder[0]:\\n                root = TreeNode()\\n                root.val = int(preorder[0])\\n                size_left = inorder.index(preorder[0])\\n                root.left = reconstruct(inorder[:size_left], preorder[1:1+size_left])\\n                root.right = reconstruct(inorder[size_left+1:], preorder[1+size_left:])\\n                return root\\n        \\n        traversals = data.split(\\',\\')\\n        inorder = traversals[0].split(\\'.\\')\\n        preorder = traversals[1].split(\\'.\\')\\n        \\n        return reconstruct(inorder, preorder)\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```Python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        def preorderTraversal(node):\\n            if not node:\\n                return\\n            data.append(str(node.val))\\n            preorderTraversal(node.left)\\n            preorderTraversal(node.right)\\n        data = []\\n        preorderTraversal(root)\\n        return \".\".join(data)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        def buildTree(values):\\n            if not values:\\n                return\\n            root = TreeNode(values[0])\\n            # find the smallest value that is \\n            # greater than root\\n            idx = 1\\n            while idx < len(values) and values[idx] < values[0]:\\n                idx += 1\\n            root.left = buildTree(values[1:idx])\\n            root.right = buildTree(values[idx:])\\n            return root\\n            \\n        values = [int(x) for x in data.split(\".\") if x]\\n        return buildTree(values)\\n            \\n        \\n# Your Codec object will be instantiated and called as such:\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```\n```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return\\n        self.inorderTraversal(root.left)\\n        self.inorder.append(str(root.val))\\n        self.inorderTraversal(root.right)\\n        \\n    def preorderTraversal(self, root):\\n        if not root:\\n            return\\n        self.preorder.append(str(root.val))\\n        self.preorderTraversal(root.left)\\n        self.preorderTraversal(root.right)\\n    \\n    def serialize(self, root):\\n        \"\"\"Encodes a tree to a single string.\\n        \\n        :type root: TreeNode\\n        :rtype: str\\n        \"\"\"\\n        self.inorder = []\\n        self.preorder = []\\n        self.inorderTraversal(root)\\n        self.preorderTraversal(root)\\n        return \".\".join(self.inorder)+\\',\\'+\\'.\\'.join(self.preorder)\\n        \\n\\n    def deserialize(self, data):\\n        \"\"\"Decodes your encoded data to tree.\\n        \\n        :type data: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        def reconstruct(inorder, preorder):\\n            if not inorder:\\n                return\\n            \\n            if preorder[0]:\\n                root = TreeNode()\\n                root.val = int(preorder[0])\\n                size_left = inorder.index(preorder[0])\\n                root.left = reconstruct(inorder[:size_left], preorder[1:1+size_left])\\n                root.right = reconstruct(inorder[size_left+1:], preorder[1+size_left:])\\n                return root\\n        \\n        traversals = data.split(\\',\\')\\n        inorder = traversals[0].split(\\'.\\')\\n        preorder = traversals[1].split(\\'.\\')\\n        \\n        return reconstruct(inorder, preorder)\\n        \\n\\n# Your Codec object will be instantiated and called as such:\\n# ser = Codec()\\n# deser = Codec()\\n# tree = ser.serialize(root)\\n# ans = deser.deserialize(tree)\\n# return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377431,
                "title": "python-preorder-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        def process(node: TreeNode):\\n            if not node:\\n                return\\n            numbers.append(node.val)\\n            process(node.left)\\n            process(node.right)\\n            \\n        numbers = []\\n        process(root);\\n        answer = \"\"\\n        for num in numbers:\\n            if answer:\\n                answer += \" \"\\n            answer += str(num)\\n        print(answer)\\n        return answer\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        def create(sortedNumbers: List[int], numbers: List[int]) -> TreeNode:\\n            assert len(numbers) == len(sortedNumbers)\\n            if not numbers:\\n                return None\\n            \\n            val = numbers[0]\\n            valIndex = bisect_left(sortedNumbers, val)\\n            \\n            left = create(sortedNumbers[:valIndex], numbers[1:valIndex + 1])\\n            right = create(sortedNumbers[valIndex + 1:], numbers[valIndex + 1:])\\n            \\n            return TreeNode(val, left, right)\\n            \\n        numbers = [int(number) for number in data.split()]\\n        sortedNumbers = sorted(numbers)\\n        return create(sortedNumbers, numbers)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        def process(node: TreeNode):\\n            if not node:\\n                return\\n            numbers.append(node.val)\\n            process(node.left)\\n            process(node.right)\\n            \\n        numbers = []\\n        process(root);\\n        answer = \"\"\\n        for num in numbers:\\n            if answer:\\n                answer += \" \"\\n            answer += str(num)\\n        print(answer)\\n        return answer\\n        \\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        def create(sortedNumbers: List[int], numbers: List[int]) -> TreeNode:\\n            assert len(numbers) == len(sortedNumbers)\\n            if not numbers:\\n                return None\\n            \\n            val = numbers[0]\\n            valIndex = bisect_left(sortedNumbers, val)\\n            \\n            left = create(sortedNumbers[:valIndex], numbers[1:valIndex + 1])\\n            right = create(sortedNumbers[valIndex + 1:], numbers[valIndex + 1:])\\n            \\n            return TreeNode(val, left, right)\\n            \\n        numbers = [int(number) for number in data.split()]\\n        sortedNumbers = sorted(numbers)\\n        return create(sortedNumbers, numbers)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356432,
                "title": "python-bfs-beat-99-66",
                "content": "This is a general method for all binary tree\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        q = collections.deque([(root)])\\n        data = []\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                data.append(str(node.val))\\n                q.append(node.left)\\n                q.append(node.right)\\n            else:\\n                data.append(\\'#\\')\\n        return \\',\\'.join(data)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        data = data.split(\\',\\')\\n        q = collections.deque(data)\\n        root = TreeNode(int(q.popleft()))\\n        p = collections.deque([root]) # memory non-empty nodes\\n        while q:\\n            node = p.popleft()\\n            left = q.popleft()\\n            right = q.popleft()\\n            if left != \\'#\\':\\n                node.left = TreeNode(int(left))\\n                p.append(node.left) # add non-empty node\\n            if right != \\'#\\':\\n                node.right = TreeNode(int(right))\\n                p.append(node.right)# add non-empty node\\n        return root",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "This is a general method for all binary tree\\n\\n    def serialize(self, root: TreeNode) -> str:\\n        \"\"\"Encodes a tree to a single string.\\n        \"\"\"\\n        if not root: return \\'\\'\\n        q = collections.deque([(root)])\\n        data = []\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                data.append(str(node.val))\\n                q.append(node.left)\\n                q.append(node.right)\\n            else:\\n                data.append(\\'#\\')\\n        return \\',\\'.join(data)\\n\\n    def deserialize(self, data: str) -> TreeNode:\\n        \"\"\"Decodes your encoded data to tree.\\n        \"\"\"\\n        if not data: return None\\n        data = data.split(\\',\\')\\n        q = collections.deque(data)\\n        root = TreeNode(int(q.popleft()))\\n        p = collections.deque([root]) # memory non-empty nodes\\n        while q:\\n            node = p.popleft()\\n            left = q.popleft()\\n            right = q.popleft()\\n            if left != \\'#\\':\\n                node.left = TreeNode(int(left))\\n                p.append(node.left) # add non-empty node\\n            if right != \\'#\\':\\n                node.right = TreeNode(int(right))\\n                p.append(node.right)# add non-empty node\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 1348989,
                "title": "c-simple-and-intuitive-99-easy-to-understand",
                "content": "```\\nclass Codec {\\npublic:\\n    void encode(TreeNode* root, string &str){\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val);\\n        str += \"-\";\\n        encode(root->left, str);\\n        encode(root->right, str);\\n    }\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str = \"\";\\n        encode(root, str);\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* root = NULL;\\n        stringstream ss(data);\\n        string value;\\n        while(getline(ss, value, \\'-\\')){\\n            root = insert(root, stoi(value));\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int data){\\n        if(root == NULL){\\n            root = new TreeNode(data);\\n            return root;\\n        }\\n        if(root->val > data){\\n            root->left = insert(root->left, data);\\n            return root;\\n        }\\n        else{\\n            root->right = insert(root->right, data);\\n            return root;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    void encode(TreeNode* root, string &str){\\n        if(root == NULL)\\n            return;\\n        str += to_string(root->val);\\n        str += \"-\";\\n        encode(root->left, str);\\n        encode(root->right, str);\\n    }\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string str = \"\";\\n        encode(root, str);\\n        return str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* root = NULL;\\n        stringstream ss(data);\\n        string value;\\n        while(getline(ss, value, \\'-\\')){\\n            root = insert(root, stoi(value));\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* insert(TreeNode* root, int data){\\n        if(root == NULL){\\n            root = new TreeNode(data);\\n            return root;\\n        }\\n        if(root->val > data){\\n            root->left = insert(root->left, data);\\n            return root;\\n        }\\n        else{\\n            root->right = insert(root->right, data);\\n            return root;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315977,
                "title": "81-faster-c-using-string-manipulation-and-postot",
                "content": "\\tclass Codec {\\n\\tpublic:\\n\\t\\tvoid inOrder(TreeNode* root, string &s){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tqueue<TreeNode*> que;\\n\\t\\t\\tque.push(root);\\n\\t\\t\\twhile(!que.empty()){\\n\\t\\t\\t\\tauto temp = que.front();\\n\\t\\t\\t\\ts += to_string(temp->val)+\"-\";\\n\\t\\t\\t\\tque.pop();  \\n\\t\\t\\t\\tif(temp->left){\\n\\t\\t\\t\\t\\tque.push(temp->left);\\n\\t\\t\\t\\t} if(temp->right){\\n\\t\\t\\t\\t\\tque.push(temp->right);\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// Encodes a tree to a single string.\\n\\t\\tstring serialize(TreeNode* root) {\\n\\t\\t\\tstring s = \"\";\\n\\t\\t\\tinOrder(root, s);\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\n\\t\\tTreeNode* insertNode(TreeNode* root, int key){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn new TreeNode(key);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val > key){\\n\\t\\t\\t\\troot->left = insertNode(root->left, key);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val < key){\\n\\t\\t\\t\\troot->right = insertNode(root->right, key);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// Decodes your encoded data to tree.\\n\\t\\tTreeNode* deserialize(string data) {\\n\\t\\t\\tvector<int> vec;\\n\\t\\t\\tstring s = \"\";\\n\\t\\t\\tfor(int i=0;i<data.size(); i++){\\n\\t\\t\\t\\tif(data[i] == \\'-\\'){\\n\\t\\t\\t\\t\\tvec.push_back(stoi(s));\\n\\t\\t\\t\\t\\ts = \"\";\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ts += data[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode* root = NULL;\\n\\t\\t\\tfor(int i=0;i<vec.size(); i++){\\n\\t\\t\\t\\troot = insertNode(root, vec[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Codec {\\n\\tpublic:\\n\\t\\tvoid inOrder(TreeNode* root, string &s){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tqueue<TreeNode*> que;\\n\\t\\t\\tque.push(root);\\n\\t\\t\\twhile(!que.empty()){\\n\\t\\t\\t\\tauto temp = que.front();\\n\\t\\t\\t\\ts += to_string(temp->val)+\"-\";\\n\\t\\t\\t\\tque.pop();  \\n\\t\\t\\t\\tif(temp->left){\\n\\t\\t\\t\\t\\tque.push(temp->left);\\n\\t\\t\\t\\t} if(temp->right){\\n\\t\\t\\t\\t\\tque.push(temp->right);\\n\\t\\t\\t\\t}   \\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t// Encodes a tree to a single string.\\n\\t\\tstring serialize(TreeNode* root) {\\n\\t\\t\\tstring s = \"\";\\n\\t\\t\\tinOrder(root, s);\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\n\\t\\tTreeNode* insertNode(TreeNode* root, int key){\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn new TreeNode(key);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val > key){\\n\\t\\t\\t\\troot->left = insertNode(root->left, key);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->val < key){\\n\\t\\t\\t\\troot->right = insertNode(root->right, key);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\n\\t\\t// Decodes your encoded data to tree.\\n\\t\\tTreeNode* deserialize(string data) {\\n\\t\\t\\tvector<int> vec;\\n\\t\\t\\tstring s = \"\";\\n\\t\\t\\tfor(int i=0;i<data.size(); i++){\\n\\t\\t\\t\\tif(data[i] == \\'-\\'){\\n\\t\\t\\t\\t\\tvec.push_back(stoi(s));\\n\\t\\t\\t\\t\\ts = \"\";\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ts += data[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode* root = NULL;\\n\\t\\t\\tfor(int i=0;i<vec.size(); i++){\\n\\t\\t\\t\\troot = insertNode(root, vec[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 1245040,
                "title": "java-easy-solution-using-preorder",
                "content": "**Do vote up if you like it :)**\\n```\\npublic class Codec {\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serializeHelper(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serializeHelper(TreeNode root, StringBuilder sb){\\n        if(root == null){\\n            sb.append(\"null\").append(\",\");\\n            return;\\n        }\\n        sb.append(root.val).append(\",\");\\n        serializeHelper(root.left, sb);\\n        serializeHelper(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] strArr = data.split(\",\");\\n        return deserializeHelper(strArr);\\n    }\\n    \\n    int idx = 0;\\n    public TreeNode deserializeHelper(String[] strArr){\\n        if(idx == strArr.length || strArr[idx].equals(\"null\")){\\n            idx++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(strArr[idx++]));\\n        root.left = deserializeHelper(strArr);\\n        root.right = deserializeHelper(strArr);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        StringBuilder sb = new StringBuilder();\\n        serializeHelper(root, sb);\\n        return sb.toString();\\n    }\\n    \\n    public void serializeHelper(TreeNode root, StringBuilder sb){\\n        if(root == null){\\n            sb.append(\"null\").append(\",\");\\n            return;\\n        }\\n        sb.append(root.val).append(\",\");\\n        serializeHelper(root.left, sb);\\n        serializeHelper(root.right, sb);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] strArr = data.split(\",\");\\n        return deserializeHelper(strArr);\\n    }\\n    \\n    int idx = 0;\\n    public TreeNode deserializeHelper(String[] strArr){\\n        if(idx == strArr.length || strArr[idx].equals(\"null\")){\\n            idx++;\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(Integer.parseInt(strArr[idx++]));\\n        root.left = deserializeHelper(strArr);\\n        root.right = deserializeHelper(strArr);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227938,
                "title": "java-dfs-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    StringBuffer encode;\\n    public String serialize(TreeNode root) {\\n        encode = new StringBuffer();\\n        preOrder(root,encode);\\n      return encode.toString();\\n    }\\n    private void preOrder(TreeNode node,StringBuffer encode){\\n      if(node == null){\\n        encode.append(\"null,\");\\n        return ;\\n      }\\n      encode.append(node.val+\",\");\\n      preOrder(node.left,encode);\\n      preOrder(node.right,encode);\\n      \\n    }\\n    // Decodes your encoded data to tree.\\n    int idx = 0;\\n    public TreeNode deserialize(String data) {\\n        String arr[] = data.split(\",\");\\n       return deserialize(arr);\\n    }\\n   private TreeNode deserialize(String arr[]){\\n     if(idx >= arr.length || arr[idx].equals(\"null\")){\\n       idx++;\\n       return null;\\n     }\\n     \\n     TreeNode newNode = new TreeNode(Integer.parseInt(arr[idx++]));\\n     newNode.left = deserialize(arr);\\n     newNode.right = deserialize(arr);\\n     \\n     return newNode;\\n   }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser = new Codec();\\n// Codec deser = new Codec();\\n// String tree = ser.serialize(root);\\n// TreeNode ans = deser.deserialize(tree);\\n// return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Codec {\\n\\n    // Encodes a tree to a single string.\\n    StringBuffer encode;\\n    public String serialize(TreeNode root) {\\n        encode = new StringBuffer();\\n        preOrder(root,encode);\\n      return encode.toString();\\n    }\\n    private void preOrder(TreeNode node,StringBuffer encode){\\n      if(node == null){\\n        encode.append(\"null,\");\\n        return ;\\n      }\\n      encode.append(node.val+\",\");\\n      preOrder(node.left,encode);\\n      preOrder(node.right,encode);\\n      \\n    }\\n    // Decodes your encoded data to tree.\\n    int idx = 0;\\n    public TreeNode deserialize(String data) {\\n        String arr[] = data.split(\",\");\\n       return deserialize(arr);\\n    }\\n   private TreeNode deserialize(String arr[]){\\n     if(idx >= arr.length || arr[idx].equals(\"null\")){\\n       idx++;\\n       return null;\\n     }\\n     \\n     TreeNode newNode = new TreeNode(Integer.parseInt(arr[idx++]));\\n     newNode.left = deserialize(arr);\\n     newNode.right = deserialize(arr);\\n     \\n     return newNode;\\n   }\\n}\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser = new Codec();\\n// Codec deser = new Codec();\\n// String tree = ser.serialize(root);\\n// TreeNode ans = deser.deserialize(tree);\\n// return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223342,
                "title": "using-preorder-bst-property-o-n-without",
                "content": "```\\npublic class Codec {\\n    int idx = 0;\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        return serializeHelper(root,\"\");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] arr = data.split(\",\");\\n        return deserializeHelper(arr, Long.MAX_VALUE, Long.MIN_VALUE, data);\\n    }\\n    \\n    \\n    private String serializeHelper(TreeNode root, String res) {\\n        if(root == null) {\\n            return res;\\n        }\\n        res+=root.val+\",\";\\n        res = serializeHelper(root.left, res);\\n        res = serializeHelper(root.right, res);\\n        return res;\\n    }\\n    \\n    \\n    private TreeNode deserializeHelper(String[] arr, long max, long min, String data) {\\n        if(arr.length == idx)\\n            return null;\\n        if(data == \"\")    //handling empty data\\n            return null;\\n        Integer value = Integer.valueOf(arr[idx]);\\n        if(value > max || value < min)  // using bst prop\\n            return null;\\n        idx++;\\n        TreeNode root = new TreeNode(value);\\n        root.left = deserializeHelper(arr, root.val, min, data);\\n        root.right = deserializeHelper(arr, max, root.val, data);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    int idx = 0;\\n\\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        return serializeHelper(root,\"\");\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        String[] arr = data.split(\",\");\\n        return deserializeHelper(arr, Long.MAX_VALUE, Long.MIN_VALUE, data);\\n    }\\n    \\n    \\n    private String serializeHelper(TreeNode root, String res) {\\n        if(root == null) {\\n            return res;\\n        }\\n        res+=root.val+\",\";\\n        res = serializeHelper(root.left, res);\\n        res = serializeHelper(root.right, res);\\n        return res;\\n    }\\n    \\n    \\n    private TreeNode deserializeHelper(String[] arr, long max, long min, String data) {\\n        if(arr.length == idx)\\n            return null;\\n        if(data == \"\")    //handling empty data\\n            return null;\\n        Integer value = Integer.valueOf(arr[idx]);\\n        if(value > max || value < min)  // using bst prop\\n            return null;\\n        idx++;\\n        TreeNode root = new TreeNode(value);\\n        root.left = deserializeHelper(arr, root.val, min, data);\\n        root.right = deserializeHelper(arr, max, root.val, data);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194243,
                "title": "not-a-solution-but-an-hack-to-pass-all-the-test-cases-xd",
                "content": "Just store tree value globally and return the same when needed XD \\n\\n**This was not an solution i was just checking that does leetcode complier checks the reference of newly created tree or not .**\\n\\n```\\nTreeNode* t = NULL ;\\nclass Codec {\\npublic:\\n    \\n    \\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        t = root; \\n\\t\\treturn \"blabla\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        return t;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* t = NULL ;\\nclass Codec {\\npublic:\\n    \\n    \\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        t = root; \\n\\t\\treturn \"blabla\";\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        return t;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174286,
                "title": "c-solution",
                "content": "```\\npublic class Codec {\\n    List<char> values = new List<char>();\\n    // Encodes a tree to a single string.\\n    public string serialize(TreeNode root) {\\n        PreOrder(root);\\n        char[] arr = values.ToArray();\\n        return new string(arr);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(string data) {\\n        TreeNode node = null;\\n        for(int i=0;i<data.Length;i++){\\n            Console.WriteLine($\"str = {data[i]}\");\\n            int val = Convert.ToInt32(data[i] - \\'0\\');\\n            Console.WriteLine($\"int={val}\");\\n            node = Insert(node, val);\\n        }\\n        return node;\\n    }\\n    \\n    private TreeNode Insert(TreeNode node, int val){\\n        if(node == null){\\n            node = new TreeNode(val);\\n        }else if(val > node.val){\\n            node.right = Insert(node.right, val);\\n        } else if (val < node.val){\\n            node.left = Insert(node.left, val);\\n        }\\n        return node;\\n    }\\n    private void PreOrder(TreeNode node){\\n        if(node == null) return;\\n        values.Add((char)(node.val + \\'0\\'));\\n        PreOrder(node.left);\\n        PreOrder(node.right);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n    List<char> values = new List<char>();\\n    // Encodes a tree to a single string.\\n    public string serialize(TreeNode root) {\\n        PreOrder(root);\\n        char[] arr = values.ToArray();\\n        return new string(arr);\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(string data) {\\n        TreeNode node = null;\\n        for(int i=0;i<data.Length;i++){\\n            Console.WriteLine($\"str = {data[i]}\");\\n            int val = Convert.ToInt32(data[i] - \\'0\\');\\n            Console.WriteLine($\"int={val}\");\\n            node = Insert(node, val);\\n        }\\n        return node;\\n    }\\n    \\n    private TreeNode Insert(TreeNode node, int val){\\n        if(node == null){\\n            node = new TreeNode(val);\\n        }else if(val > node.val){\\n            node.right = Insert(node.right, val);\\n        } else if (val < node.val){\\n            node.left = Insert(node.left, val);\\n        }\\n        return node;\\n    }\\n    private void PreOrder(TreeNode node){\\n        if(node == null) return;\\n        values.Add((char)(node.val + \\'0\\'));\\n        PreOrder(node.left);\\n        PreOrder(node.right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150143,
                "title": "short",
                "content": "**Serialize:** BFS, time `O(N)`;\\n**Deserialize:** iterative insert into BST, time `O(NlogN)`.\\n```\\nclass Codec \\n{\\npublic:\\n    string serialize(TreeNode* r) \\n    {\\n        string out;\\n        for(queue<TreeNode*> q({r}); !empty(q); q.pop())\\n            if(q.front())\\n            {\\n                q.push(q.front()->left);\\n                q.push(q.front()->right);\\n                out += to_string(q.front()->val) + \" \"s;\\n            }\\n        return out;\\n    }\\n                             \\n    TreeNode* deserialize(string d) \\n    {\\n        TreeNode* out{nullptr};\\n        auto r{&out};\\n        int val{-1};\\n        for(stringstream ss{d}; ss>>d; *r = new TreeNode(val))\\n            for(val = stoi(d), r = &out; *r; r = val<=(*r)->val ? &(*r)->left : &(*r)->right);\\n        return out;\\n    }\\n};\\n```\\n<details>\\n<summary>\\nRecursive insert variation:\\n</summary>\\n\\n```\\nclass Codec \\n{\\npublic:\\n    string serialize(TreeNode* r) \\n    {\\n        string out;\\n        for(queue<TreeNode*> q({r}); !empty(q); q.pop())\\n            if(q.front())\\n            {\\n                q.push(q.front()->left);\\n                q.push(q.front()->right);\\n                out += to_string(q.front()->val) + \" \"s;\\n            }\\n        return out;\\n    }\\n\\n    TreeNode* insert(TreeNode* r, int val)\\n    {\\n        if(!r) return new TreeNode(val);\\n        TreeNode* & child = val<=r->val ? r->left : r->right;\\n        child = insert(child,  val);\\n        return r;\\n    }\\n                              \\n    TreeNode* deserialize(string d) \\n    {\\n        TreeNode* out{nullptr};\\n        for(stringstream ss{d}; ss>>d; out = insert(out, stoi(d)));\\n        return out;\\n    }\\n};\\n```\\n</details>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Codec \\n{\\npublic:\\n    string serialize(TreeNode* r) \\n    {\\n        string out;\\n        for(queue<TreeNode*> q({r}); !empty(q); q.pop())\\n            if(q.front())\\n            {\\n                q.push(q.front()->left);\\n                q.push(q.front()->right);\\n                out += to_string(q.front()->val) + \" \"s;\\n            }\\n        return out;\\n    }\\n                             \\n    TreeNode* deserialize(string d) \\n    {\\n        TreeNode* out{nullptr};\\n        auto r{&out};\\n        int val{-1};\\n        for(stringstream ss{d}; ss>>d; *r = new TreeNode(val))\\n            for(val = stoi(d), r = &out; *r; r = val<=(*r)->val ? &(*r)->left : &(*r)->right);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Codec \\n{\\npublic:\\n    string serialize(TreeNode* r) \\n    {\\n        string out;\\n        for(queue<TreeNode*> q({r}); !empty(q); q.pop())\\n            if(q.front())\\n            {\\n                q.push(q.front()->left);\\n                q.push(q.front()->right);\\n                out += to_string(q.front()->val) + \" \"s;\\n            }\\n        return out;\\n    }\\n\\n    TreeNode* insert(TreeNode* r, int val)\\n    {\\n        if(!r) return new TreeNode(val);\\n        TreeNode* & child = val<=r->val ? r->left : r->right;\\n        child = insert(child,  val);\\n        return r;\\n    }\\n                              \\n    TreeNode* deserialize(string d) \\n    {\\n        TreeNode* out{nullptr};\\n        for(stringstream ss{d}; ss>>d; out = insert(out, stoi(d)));\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120513,
                "title": "c-serialize-deserialize-into-from-preorder-sequence-elegant-and-concise-beats-99",
                "content": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        ostringstream oss;\\n\\n        bool first = true;\\n        stack<TreeNode*> stk;\\n        if (root) {\\n            stk.emplace(root);\\n        }\\n        while (!stk.empty()) {\\n            TreeNode* node = stk.top();\\n            stk.pop();\\n\\n            if (0 < oss.tellp()) {\\n                oss << \" \";\\n            }\\n            oss << node->val;\\n\\n            if (node->right) {\\n                stk.push(node->right);\\n            }\\n            if (node->left) {\\n                stk.push(node->left);\\n            }\\n        }\\n\\n        return oss.str();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* pHead = nullptr;\\n        TreeNode** ppCur = &pHead;\\n\\n        int num;\\n        stack<TreeNode*> stk;\\n        for (istringstream iss(data); iss >> num;) {\\n            while (!stk.empty() && stk.top()->val < num) {\\n                ppCur = &(stk.top()->right);\\n                stk.pop();\\n            }\\n\\n            *ppCur = new TreeNode(num);\\n            stk.push(*ppCur);\\n\\n            ppCur = &((*ppCur)->left);\\n        }\\n\\n        return pHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Codec {\\npublic:\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        ostringstream oss;\\n\\n        bool first = true;\\n        stack<TreeNode*> stk;\\n        if (root) {\\n            stk.emplace(root);\\n        }\\n        while (!stk.empty()) {\\n            TreeNode* node = stk.top();\\n            stk.pop();\\n\\n            if (0 < oss.tellp()) {\\n                oss << \" \";\\n            }\\n            oss << node->val;\\n\\n            if (node->right) {\\n                stk.push(node->right);\\n            }\\n            if (node->left) {\\n                stk.push(node->left);\\n            }\\n        }\\n\\n        return oss.str();\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        TreeNode* pHead = nullptr;\\n        TreeNode** ppCur = &pHead;\\n\\n        int num;\\n        stack<TreeNode*> stk;\\n        for (istringstream iss(data); iss >> num;) {\\n            while (!stk.empty() && stk.top()->val < num) {\\n                ppCur = &(stk.top()->right);\\n                stk.pop();\\n            }\\n\\n            *ppCur = new TreeNode(num);\\n            stk.push(*ppCur);\\n\\n            ppCur = &((*ppCur)->left);\\n        }\\n\\n        return pHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053261,
                "title": "java-preorder-solution",
                "content": "```\\npublic class Codec {\\n\\n    void preorder(TreeNode root, List list) {\\n        if(root==null)\\n            return;\\n        list.add(String.valueOf(root.val));\\n        preorder(root.left, list);\\n        preorder(root.right, list);\\n    }\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        preorder(root, list);\\n        String result = String.join(\",\",list);\\n        return list.size()==0?\"\":result;\\n    }\\n\\n    int idx=0;\\n    public TreeNode decode(String[] arr, int len, int min, int max) {\\n        if(idx==len)\\n            return null;\\n        int val = Integer.parseInt(arr[idx]);\\n        if(val<min || val>max)\\n            return null;\\n        idx++;\\n        TreeNode node = new TreeNode(val);\\n        node.left = decode(arr, len, min, val);\\n        node.right = decode(arr, len, val, max);\\n        return node;\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length()==0)\\n            return null;\\n        String[] arr = data.split(\",\");\\n        return decode(arr,arr.length,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Codec {\\n\\n    void preorder(TreeNode root, List list) {\\n        if(root==null)\\n            return;\\n        list.add(String.valueOf(root.val));\\n        preorder(root.left, list);\\n        preorder(root.right, list);\\n    }\\n    \\n    // Encodes a tree to a single string.\\n    public String serialize(TreeNode root) {\\n        List<String> list = new ArrayList<String>();\\n        preorder(root, list);\\n        String result = String.join(\",\",list);\\n        return list.size()==0?\"\":result;\\n    }\\n\\n    int idx=0;\\n    public TreeNode decode(String[] arr, int len, int min, int max) {\\n        if(idx==len)\\n            return null;\\n        int val = Integer.parseInt(arr[idx]);\\n        if(val<min || val>max)\\n            return null;\\n        idx++;\\n        TreeNode node = new TreeNode(val);\\n        node.left = decode(arr, len, min, val);\\n        node.right = decode(arr, len, val, max);\\n        return node;\\n    }\\n    \\n    // Decodes your encoded data to tree.\\n    public TreeNode deserialize(String data) {\\n        if(data.length()==0)\\n            return null;\\n        String[] arr = data.split(\",\");\\n        return decode(arr,arr.length,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043500,
                "title": "step-by-step-video-solutions-with-chinese-and-english",
                "content": "Leetcode\\u4E0A\\u6709\\u597D\\u51E0\\u4E2A\\u5173\\u4E8E\\u6811\\u7684\\u5E8F\\u5217\\u5316\\u7684\\u95EE\\u9898\\uFF0C\\u5206\\u522B\\u662F297/428/449. \\u4ED6\\u4EEC\\u4E4B\\u95F4\\u5404\\u6709\\u8054\\u7CFB\\u3002\\u6811\\u7684\\u5E8F\\u5217\\u5316\\u662F\\u4E00\\u4E2A\\u8001\\u751F\\u5E38\\u8C08\\u7684\\u95EE\\u9898\\uFF0C\\u4F46\\u662F\\u53C8\\u662F\\u4E00\\u4E2A\\u5F88\\u91CD\\u8981\\u7684\\u4E3B\\u9898\\u3002\\u6211\\u5728\\u4EE5\\u524D\\u9762\\u82F9\\u679C\\u7684\\u65F6\\u5019\\u5C31\\u88AB\\u95EE\\u5230\\uFF1A\\u5982\\u679C\\u5E8F\\u5217\\u5316\\u4E00\\u4E2A\\u4E8C\\u53C9\\u6811\\uFF0C\\u6BCF\\u4E2A\\u8282\\u70B9\\u7684data\\u662F\\'a\\'-\\'z\\'\\u6216\\u8005\\'A\\'-\\'Z\\'\\u3002\\u5F53\\u65F6\\u6211\\u7684\\u662F\\u5728\\u9762\\u8BD5\\u5B98\\u7684\\u63D0\\u793A\\u4E0B\\u624D\\u60F3\\u51FA\\u4ED6\\u60F3\\u8981\\u6211\\u5B9E\\u73B0\\u7684\\u65B9\\u6CD5\\u3002\\u6240\\u4EE5\\u501F\\u8FD9\\u4E2A\\u673A\\u4F1A\\u5206\\u4EAB\\u7ED9\\u5927\\u5BB6\\u3002\\n\\nThere are some tree serialization problems in Leetcode. They are Leetcode 297/428/449. Tree serialization and deserialization is a very common problem. There was an Apple interview question: How to serialize a binary tree if each node is a character \\'a\\'-\\'z\\' or \\'A\\'-\\'Z\\'. I gave the optimal solution after some hints. So I share it here.\\n\\n\\u4E2D\\u6587\\u89E3\\u7B54: https://youtu.be/8_JSg4RWvhY\\n\\nEnglish Solution: https://youtu.be/iZHDx-k2Mxw\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1026292,
                "title": "runtime-32-ms-faster-than-93-54-of-c-order-n-solution-preorder-recursion",
                "content": "class Codec {\\npublic:\\n    int start=0;\\n    TreeNode* myfunc(string &S,int count){\\n        int temp=start;\\n        int count1=count;\\n        while(count1--){\\n            if(S[start]!=\\'-\\'){\\n                start=temp;\\n                return NULL;\\n            }\\n            start++;\\n        }\\n        if(start>=S.size())return NULL;\\n        TreeNode* root=new TreeNode;\\n        int v=0;\\n        while(start<S.size()&&S[start]!=\\'-\\'){\\n            v=v*10+S[start]-48;\\n            start++;\\n        }\\n        start--;\\n        if(v==10001){\\n            start++;\\n            return NULL;\\n        }\\n        root->val=v;\\n        start++;\\n        root->left=myfunc(S,count+1);\\n        root->right=myfunc(S,count+1);\\n        return root;\\n    }\\n    string s;\\n    void preorder(TreeNode* root,int level){\\n        if(!root)return;\\n        s+=to_string(root->val);\\n        if(root->left){\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            preorder(root->left,level+1);\\n        }\\n        else{\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            s+=\"10001\";\\n        }\\n        if(root->right){\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            preorder(root->right,level+1);\\n        }\\n        else{\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            s+=\"10001\";\\n        }\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        preorder(root,1);\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        return myfunc(data,0);\\n    }\\n};\\nhttps://leetcode.com/problems/recover-a-tree-from-preorder-traversal/\\nThe deserialize function also solve this question while serialize function changes in the preorder string needed for the string.\\nValue 10001 is use to check for a null value.\\nCan\\'t use -ve value to check as - is treated as dash.\\n\\nWith few basic modification we can solve this problem too https://leetcode.com/problems/serialize-and-deserialize-binary-tree/submissions/ . Just replace - with # and use a flag to maintain +ve and -ve numbers.\\nMake sure to *UPVOTE*",
                "solutionTags": [],
                "code": "class Codec {\\npublic:\\n    int start=0;\\n    TreeNode* myfunc(string &S,int count){\\n        int temp=start;\\n        int count1=count;\\n        while(count1--){\\n            if(S[start]!=\\'-\\'){\\n                start=temp;\\n                return NULL;\\n            }\\n            start++;\\n        }\\n        if(start>=S.size())return NULL;\\n        TreeNode* root=new TreeNode;\\n        int v=0;\\n        while(start<S.size()&&S[start]!=\\'-\\'){\\n            v=v*10+S[start]-48;\\n            start++;\\n        }\\n        start--;\\n        if(v==10001){\\n            start++;\\n            return NULL;\\n        }\\n        root->val=v;\\n        start++;\\n        root->left=myfunc(S,count+1);\\n        root->right=myfunc(S,count+1);\\n        return root;\\n    }\\n    string s;\\n    void preorder(TreeNode* root,int level){\\n        if(!root)return;\\n        s+=to_string(root->val);\\n        if(root->left){\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            preorder(root->left,level+1);\\n        }\\n        else{\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            s+=\"10001\";\\n        }\\n        if(root->right){\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            preorder(root->right,level+1);\\n        }\\n        else{\\n            int copy=level;\\n            while(copy--)s+=\\'-\\';\\n            s+=\"10001\";\\n        }\\n    }\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        preorder(root,1);\\n        return s;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        return myfunc(data,0);\\n    }\\n};\\nhttps://leetcode.com/problems/recover-a-tree-from-preorder-traversal/\\nThe deserialize function also solve this question while serialize function changes in the preorder string needed for the string.\\nValue 10001 is use to check for a null value.\\nCan\\'t use -ve value to check as - is treated as dash.\\n\\nWith few basic modification we can solve this problem too https://leetcode.com/problems/serialize-and-deserialize-binary-tree/submissions/ . Just replace - with # and use a flag to maintain +ve and -ve numbers.\\nMake sure to *UPVOTE*",
                "codeTag": "Java"
            },
            {
                "id": 1008464,
                "title": "javascript-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    const result = [];\\n    if (!root) {\\n        return result;\\n    }\\n    const queue = [[root, 0]];\\n    while (queue.length > 0) {\\n        const [node, index] = queue.shift();\\n        result[index] = node.val;\\n        if (node.left) {\\n            queue.push([node.left, 2 * index + 1]);\\n        }\\n        if (node.right) {\\n            queue.push([node.right, 2 * index + 2]);\\n        }\\n    }\\n    return result;\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    if (!data || data.length < 1) {\\n        return null\\n    }\\n    const root = new TreeNode(data[0]);\\n    const queue = [[root, 0]];\\n    while (queue.length > 0) {\\n        const [node, index] = queue.shift();\\n        const leftIndex = 2 * index + 1;\\n        const rightIndex = 2 * index + 2;\\n        const left = data[leftIndex];\\n        const right = data[rightIndex];\\n        if (left !== undefined) {\\n            node.left = new TreeNode(left);\\n            queue.push([node.left, leftIndex]);\\n        }\\n        if (right !== undefined) {\\n            node.right = new TreeNode(right);\\n            queue.push([node.right, rightIndex]);\\n        }\\n    }\\n    return root;\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * Encodes a tree to a single string.\\n *\\n * @param {TreeNode} root\\n * @return {string}\\n */\\nvar serialize = function(root) {\\n    const result = [];\\n    if (!root) {\\n        return result;\\n    }\\n    const queue = [[root, 0]];\\n    while (queue.length > 0) {\\n        const [node, index] = queue.shift();\\n        result[index] = node.val;\\n        if (node.left) {\\n            queue.push([node.left, 2 * index + 1]);\\n        }\\n        if (node.right) {\\n            queue.push([node.right, 2 * index + 2]);\\n        }\\n    }\\n    return result;\\n};\\n\\n/**\\n * Decodes your encoded data to tree.\\n *\\n * @param {string} data\\n * @return {TreeNode}\\n */\\nvar deserialize = function(data) {\\n    if (!data || data.length < 1) {\\n        return null\\n    }\\n    const root = new TreeNode(data[0]);\\n    const queue = [[root, 0]];\\n    while (queue.length > 0) {\\n        const [node, index] = queue.shift();\\n        const leftIndex = 2 * index + 1;\\n        const rightIndex = 2 * index + 2;\\n        const left = data[leftIndex];\\n        const right = data[rightIndex];\\n        if (left !== undefined) {\\n            node.left = new TreeNode(left);\\n            queue.push([node.left, leftIndex]);\\n        }\\n        if (right !== undefined) {\\n            node.right = new TreeNode(right);\\n            queue.push([node.right, rightIndex]);\\n        }\\n    }\\n    return root;\\n};\\n\\n/**\\n * Your functions will be called as such:\\n * deserialize(serialize(root));\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003030,
                "title": "scala-solution-preorder-simple-solution",
                "content": "```\\n// Encodes a list of strings to a single string.\\ndef serialize(root: TreeNode): String = root match {\\n\\tcase null => \"x,\"\\n\\tcase root => root.value +\",\"+ serialize(root.left) + serialize(root.right)\\n}\\n\\n// Decodes a single string to a list of strings.\\ndef deserialize(data: String): TreeNode = {\\n\\tdef dfs(q: Queue[String]): TreeNode = {\\n\\t\\tval value = q.dequeue\\n\\t\\tif(value == \"x\") return null\\n\\n\\t\\tval root = TreeNode(value.toInt)\\n\\t\\troot.left = dfs(q)\\n\\t\\troot.right = dfs(q)\\n\\t\\troot\\n\\t}\\n\\tdfs(Queue[String]().enqueueAll(data.split(\",\")))\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Encodes a list of strings to a single string.\\ndef serialize(root: TreeNode): String = root match {\\n\\tcase null => \"x,\"\\n\\tcase root => root.value +\",\"+ serialize(root.left) + serialize(root.right)\\n}\\n\\n// Decodes a single string to a list of strings.\\ndef deserialize(data: String): TreeNode = {\\n\\tdef dfs(q: Queue[String]): TreeNode = {\\n\\t\\tval value = q.dequeue\\n\\t\\tif(value == \"x\") return null\\n\\n\\t\\tval root = TreeNode(value.toInt)\\n\\t\\troot.left = dfs(q)\\n\\t\\troot.right = dfs(q)\\n\\t\\troot\\n\\t}\\n\\tdfs(Queue[String]().enqueueAll(data.split(\",\")))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 945096,
                "title": "c-easy-bfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    \\n    //use level order traversal as its easy and iterative compared to preorder\\n    //store level order traversal/BFS of tree and put special marker \\'NULL\\' for NULL and \\',\\' for separation\\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string serializedOP=\"\";\\n        \\n        queue<TreeNode*> bfs;\\n        bfs.push(root);\\n        \\n        while(!bfs.empty())\\n        {\\n            TreeNode* temp = bfs.front();\\n            bfs.pop();\\n            if(temp == NULL)\\n            {\\n                serializedOP+=\"NULL,\";\\n            }\\n            else\\n            {\\n                serializedOP+=to_string(temp->val)+\",\";\\n                \\n                bfs.push(temp->left);\\n                bfs.push(temp->right);\\n            }\\n            \\n        }\\n        //cout<<serializedOP<<endl;\\n        return serializedOP;\\n    }\\n\\n    \\n    \\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty())\\n            return NULL;\\n        stringstream stream(data);\\n        string nodeVal;\\n        //each getline will give new nodeVal\\n        std::getline(stream,nodeVal,\\',\\');\\n        \\n        //if first is NULL then tree is empty\\n        if(nodeVal == \"NULL\")\\n            return NULL;\\n        \\n        //create root\\n        TreeNode* root = new TreeNode(stoi(nodeVal));\\n        queue<TreeNode*> bfs; \\n        bfs.push(root);\\n        \\n        \\n        while(!bfs.empty())\\n        {\\n            //take out first node\\n            TreeNode* temp = bfs.front();\\n            \\n            std::getline(stream,nodeVal,\\',\\');\\n            \\n            if(nodeVal == \"NULL\")\\n            {\\n                temp->left = NULL;\\n            }\\n            else\\n            {\\n                temp->left = new TreeNode(stoi(nodeVal));\\n                bfs.push(temp->left);\\n            }\\n            \\n            \\n            std::getline(stream,nodeVal,\\',\\');\\n            \\n            if(nodeVal == \"NULL\")\\n            {\\n                temp->right = NULL;\\n            }\\n            else\\n            {\\n                temp->right = new TreeNode(stoi(nodeVal));\\n                bfs.push(temp->right);\\n            }\\n            \\n            bfs.pop();\\n        }\\n        \\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser, deser;\\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n    \\n    //use level order traversal as its easy and iterative compared to preorder\\n    //store level order traversal/BFS of tree and put special marker \\'NULL\\' for NULL and \\',\\' for separation\\n    \\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string serializedOP=\"\";\\n        \\n        queue<TreeNode*> bfs;\\n        bfs.push(root);\\n        \\n        while(!bfs.empty())\\n        {\\n            TreeNode* temp = bfs.front();\\n            bfs.pop();\\n            if(temp == NULL)\\n            {\\n                serializedOP+=\"NULL,\";\\n            }\\n            else\\n            {\\n                serializedOP+=to_string(temp->val)+\",\";\\n                \\n                bfs.push(temp->left);\\n                bfs.push(temp->right);\\n            }\\n            \\n        }\\n        //cout<<serializedOP<<endl;\\n        return serializedOP;\\n    }\\n\\n    \\n    \\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        if(data.empty())\\n            return NULL;\\n        stringstream stream(data);\\n        string nodeVal;\\n        //each getline will give new nodeVal\\n        std::getline(stream,nodeVal,\\',\\');\\n        \\n        //if first is NULL then tree is empty\\n        if(nodeVal == \"NULL\")\\n            return NULL;\\n        \\n        //create root\\n        TreeNode* root = new TreeNode(stoi(nodeVal));\\n        queue<TreeNode*> bfs; \\n        bfs.push(root);\\n        \\n        \\n        while(!bfs.empty())\\n        {\\n            //take out first node\\n            TreeNode* temp = bfs.front();\\n            \\n            std::getline(stream,nodeVal,\\',\\');\\n            \\n            if(nodeVal == \"NULL\")\\n            {\\n                temp->left = NULL;\\n            }\\n            else\\n            {\\n                temp->left = new TreeNode(stoi(nodeVal));\\n                bfs.push(temp->left);\\n            }\\n            \\n            \\n            std::getline(stream,nodeVal,\\',\\');\\n            \\n            if(nodeVal == \"NULL\")\\n            {\\n                temp->right = NULL;\\n            }\\n            else\\n            {\\n                temp->right = new TreeNode(stoi(nodeVal));\\n                bfs.push(temp->right);\\n            }\\n            \\n            bfs.pop();\\n        }\\n        \\n        return root;\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser, deser;\\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1564831,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1567263,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1569114,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1569848,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1568221,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1573178,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1574305,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1929806,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1820888,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1816458,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1564831,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1567263,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1569114,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1569848,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1568221,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1573178,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1574305,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1929806,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1820888,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            },
            {
                "id": 1816458,
                "content": [
                    {
                        "username": "jordandong",
                        "content": "what's the difference between this and #297 ?"
                    },
                    {
                        "username": "browntiger",
                        "content": "The difference is that here we can make the serialized string even shorter. How? We do not need to mark the nulls using some char like \\'#\\' in this problem since we can use BST properties to know when we hit the null node. \\n\\nIMO, this problem should be marked as Hard."
                    },
                    {
                        "username": "WagdySamih",
                        "content": "[@ayushraj03](/ayushraj03) \\nThere are almost the same\\nI solved both with same code!\\njust changed the null character to be `#`  instead of `-1 `"
                    },
                    {
                        "username": "user2049D",
                        "content": "In #297, node.val can be negative. Not here."
                    },
                    {
                        "username": "ayushraj03",
                        "content": "In this problem, we have to serialize and de-serialize ```Binary Search Tree``` \nwhile in ```LC 297``` we have to serialize and de-serialize ```Binary Tree```"
                    },
                    {
                        "username": "zzg_zzm",
                        "content": "I have seen many top solutions using the following algorithm for serialization:\\n* Pre-order traversal to store all node values sequentially in a string with a special separator char between adjacent values.\\n\\nThe absence of `\"NULL\"` node notation is the benefit we get from BST compared to [Problem 297 (generic binary tree)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree). \\n\\nHowever, when it comes to deserialization, I am not sure how you can restore to the structure of the original BST if there are duplicated node values. The key question is that \\n* **if a child node has the same value as its parent, should it be inserted to left or right sub-tree?**\\n\\nForgiven me as I am not from Computer Science major. According to the well known book, \\n* \"*Introduction to Algorithms, 3rd Ed*\" (by T. Cormen, C. Leiserson, R. Rivest and C. Stein), page 287, \\n\\nthe key of a node in BST `>=` any node key in left sub-tree and `<=` any node key value in right sub-tree. So if I have a BST with all identical node key values, there will be many ways to re-construct the BST.\\n\\nHowever, from Wikipedia, [the definition of BST](https://en.wikipedia.org/wiki/Binary_search_tree#Definition) makes it strict on left sub-tree, i.e., a node's value is strictly greater than (`>`) any node's value in its left sub-tree, which will ensure the uniqueness of insertion place if a new node coming in with a duplicated key value with an existing node in BST. \\n\\nTherefore, the consequence is that if given a BST with all identical node values, the serialized string is trivial and there is no way to restore the original structure if using the definition from \"Introduction to Algorithms, 3rd Ed\".\\n\\nSince we certainly cannot use Wikipedia as an official source for scientific terminology, so I appreciate if someone can clarify the \"*commonly accepted*\" definition of BST when there are duplicated node values. Thanks.\\n\\nAre they all considered BST? Or this problem guarantees that there is no duplicated node values in given BST? @administrators \\n![0_1485543002090_BST.JPG](/uploads/files/1485543004601-bst.jpg)"
                    },
                    {
                        "username": "zurakatsura",
                        "content": "The definition of BST can be left <= root < right or even left < root <= right or left < root < right. Here it\\'s the last one. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "a bit late, and I am also not a CS major, so I am not going to argue over definitions. But for this problem, duplicate values are not allowed. "
                    },
                    {
                        "username": "genius19",
                        "content": "I find lots of solutions here using preorder and inorder to do the serialize and deserialize. But what if the BST contains duplicate elements? Any one can clarify the question?"
                    },
                    {
                        "username": "lucasgagne",
                        "content": "[@akorn1](/akorn1) In the test cases there are duplicates.. "
                    },
                    {
                        "username": "nishntraut17",
                        "content": "[@akorn1](/akorn1) thanks brother, I had the same question"
                    },
                    {
                        "username": "akorn1",
                        "content": "Duplicates are not allowed for BSTs. I know I\\'m super late on this but better late than never"
                    },
                    {
                        "username": "rvpk",
                        "content": "Any idea, what difference BT or BST will make in Serialization and Deserialization.\\nThanks."
                    },
                    {
                        "username": "Karthikr6",
                        "content": "In BST, we know the order of the next node (i.e whether it is a left or a right child) but in BT, we cannot judge it - we have to use a NULL placeholder in BT."
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "\"Serialization could be easily implemented with both strategies, but for optimal deserialization better to choose the postorder traversal because member/global/static variables are not allowed here. \"\\n\\nnot anderstand why ? anyone can explain this, thx."
                    },
                    {
                        "username": "aneonoir",
                        "content": "input: [5,3,6,2,4,null,null,1,2,76,null,null,null,null,null,3]\\nExpected output: \\n[5,3,76,2,4,3,null,1,null,null,null,null,6,null,2]\\n\\nThere is something wrong with the solution / judging code. Or I misunderstood the question ? \\n\\n\\n"
                    },
                    {
                        "username": "kimayabedarkar1",
                        "content": "I am not able to understand if what we are trying to do in serialize is just store the preorder and in deserialize use this preorder and the sorted form of that which is the inorder to construct the tree. Why are we needing any lower bound or upper bound? Please help!"
                    },
                    {
                        "username": "psionl0",
                        "content": "Here is a way to cheat the question (if you are a C programmer):\n```\nchar* serialize(struct TreeNode* root) {\n    return (char*) root;\n}\n\nstruct TreeNode* deserialize(char* data) {\n    return (struct TreeNode*) data;\n}\n```\nIf you print the string that results from the serialize action, it is just an empty string so it is hard to tell what is being encoded. I suspect that only the root node actually ends up being cast into a character array.\n\nTo test how valid this code is, I split the operations into two separate files: one for serialize and one for deserialize. The output from the serialize operation was put into a file. Sure enough, the deserialize operation failed in this circumstance. The file was only 4 bytes long so it had nowhere near enough information to reconstruct the tree.\n\nObviously this worked in this case because the tree is in memory at the time the deserialize operation was performed."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great question, but quite hard in my opinion. Harder than #297, which is labeled as hard, because there my code passes and here I am getting TLE.  "
                    },
                    {
                        "username": "hilly_billy",
                        "content": "useless"
                    }
                ]
            }
        ]
    }
]