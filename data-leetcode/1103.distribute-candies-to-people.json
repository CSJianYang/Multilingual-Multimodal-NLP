[
    {
        "title": "Distribute Candies to People",
        "question_content": "We distribute some&nbsp;number of candies, to a row of n =&nbsp;num_people&nbsp;people in the following way:\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give n&nbsp;candies to the last person.\nThen, we go back to the start of the row, giving n&nbsp;+ 1 candies to the first person, n&nbsp;+ 2 candies to the second person, and so on until we give 2 * n&nbsp;candies to the last person.\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.&nbsp; The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\nReturn an array (of length num_people&nbsp;and sum candies) that represents the final distribution of candies.\n&nbsp;\nExample 1:\n\nInput: candies = 7, num_people = 4\nOutput: [1,2,3,1]\nExplanation:\nOn the first turn, ans[0] += 1, and the array is [1,0,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3,0].\nOn the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].\n\nExample 2:\n\nInput: candies = 10, num_people = 3\nOutput: [5,2,3]\nExplanation: \nOn the first turn, ans[0] += 1, and the array is [1,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3].\nOn the fourth turn, ans[0] += 4, and the final array is [5,2,3].\n\n&nbsp;\nConstraints:\n\n\t1 <= candies <= 10^9\n\t1 <= num_people <= 1000",
        "solutions": [
            {
                "id": 323314,
                "title": "java-python3-easy-code-w-explanation-and-analysis",
                "content": "1. Use `give % num_people` to determine the current index of the people, where `give` is the `give-th` giving of candy;\\n2. Increase each giving amount by 1 till run out of candies.\\n\\n**Java:**\\n```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        for (int give = 0; candies > 0; candies -= give) {\\n            people[give % num_people] +=  Math.min(candies, ++give);\\n        }\\n        return people;\\n    }\\n```\\n----\\n**Python3:**\\n```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        people = num_people * [0]\\n        give = 0\\n        while candies > 0:\\n            people[give % num_people] += min(candies, give + 1)\\n            give += 1\\n            candies -= give\\n        return people\\n```\\n**Analysis:**\\nAssume there are `give` times distribution such that `1 + 2 + ... + give >= candies`. Therefore,\\n`(1 + give) * give / 2 >= candies`, and when `give` is big enough, `(give + 1) * give /2 ~ candies`. We have: \\n```\\n1/2 * give ^ 2 < 1/2 * (give ^ 2 + give)  < 1/ 2 * (give + 1) ^ 2\\n```\\nthen \\n```\\n1/2 * give ^ 2 < candies < 1/ 2 * (give + 1) ^ 2\\n```\\nso\\n```\\ngive < sqrt(2 * candies) ~ O(sqrt(candies))\\n```\\nTime: O(sqrt(candies)), space: O(num_people) - including return array.",
                "solutionTags": [],
                "code": "```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        for (int give = 0; candies > 0; candies -= give) {\\n            people[give % num_people] +=  Math.min(candies, ++give);\\n        }\\n        return people;\\n    }\\n```\n```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        people = num_people * [0]\\n        give = 0\\n        while candies > 0:\\n            people[give % num_people] += min(candies, give + 1)\\n            give += 1\\n            candies -= give\\n        return people\\n```\n```\\n1/2 * give ^ 2 < 1/2 * (give ^ 2 + give)  < 1/ 2 * (give + 1) ^ 2\\n```\n```\\n1/2 * give ^ 2 < candies < 1/ 2 * (give + 1) ^ 2\\n```\n```\\ngive < sqrt(2 * candies) ~ O(sqrt(candies))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323364,
                "title": "java-c-python-math-solution-and-simulation-o-1-to-get-each",
                "content": "# **Solution 1: Math**\\nMath solution, but personally not really like it.\\nTime only `O(1)` to get value for each people, \\nthough `O(n)` for output.\\nAnd strictly speaking, `math.sqrt` also consumes the time.\\n\\n```python\\n    def distributeCandies(self, candies, n):\\n        x = int(math.sqrt(candies * 2 + 0.25) - 0.5)\\n        res = [0] * n\\n        for i in xrange(n):\\n            m = x / n + (x % n > i)\\n            res[i] = m * (i + 1) + m * (m - 1) / 2 * n\\n        res[x % n] += candies - x * (x + 1) / 2\\n        return res\\n```\\n<br>\\n\\n# **Intuition**\\nBrute force of simulation seems to be easy.\\nBut how is the time complexity?\\n<br>\\n\\n# **Solution 2: Explanation**\\nThe `i-th` distribution,\\nwe will distribute `i + 1` candies to `(i % n)`th people.\\nWe just simulate the process of distribution until we ran out of candies.\\n\\n# **Complexity**\\nTime `O(sqrt(candies) + n)`\\nSpace `O(n)` for output\\n\\nThe number of given candies is `i + 1`, which is an increasing sequence.\\nThe total number distributed candies is `c * (c + 1) / 2` until it\\'s bigger than `candies`.\\nSo the time it takes is `O(sqrt(candies))`\\n<br>\\n\\n**Java:**\\n```java\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += Math.min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```python\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        i = 0\\n        while candies > 0:\\n            res[i % n] += min(candies, i + 1)\\n            candies -= i + 1\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n    def distributeCandies(self, candies, n):\\n        x = int(math.sqrt(candies * 2 + 0.25) - 0.5)\\n        res = [0] * n\\n        for i in xrange(n):\\n            m = x / n + (x % n > i)\\n            res[i] = m * (i + 1) + m * (m - 1) / 2 * n\\n        res[x % n] += candies - x * (x + 1) / 2\\n        return res\\n```\n```java\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += Math.min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        i = 0\\n        while candies > 0:\\n            res[i % n] += min(candies, i + 1)\\n            candies -= i + 1\\n            i += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323298,
                "title": "c-brute-force",
                "content": "I was going down the mathematical path and it felt a bit tricky. Since the problem is \\'Easy\\', I guessed the brute-force should do for the contest.\\n```\\nvector<int> distributeCandies(int c, int num) {\\n  vector<int> res(num);\\n  for (auto i = 0; c > 0; c -= ++i) \\n    res[i % num] += min(i + 1, c);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> distributeCandies(int c, int num) {\\n  vector<int> res(num);\\n  for (auto i = 0; c > 0; c -= ++i) \\n    res[i % num] += min(i + 1, c);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796574,
                "title": "python-math-o-k-solution-with-explanation",
                "content": "There are different ways how you can handle this problem, I prefer mathematical way. Let us define `k = num_people` and `n = candies` and try to understand how many candies we need to give to `i`-the person.  \\n\\n| 1    | 2   | 3    | ... | k   |\\n|------|-----|------|-----|-----|\\n| **k+1**  | **k+2** | **k+3**  | **...** | **2k**  |\\n| **...**  | **...** | **...**  | **...** | **...** |\\n| **sk+1** | **...** | **sk+i** |     |     |\\n\\nWe need to find the biggest `s`, such that the sum of numbers before is less or equal to `n`. Let us compute it:\\n\\n**1.** First row: `k(k+1)/2`, sum of arithmetic progression.\\n\\n**2.** Second row: `k(k+1)/2 + k^2`.\\n\\n**3.** Third row:  `k(k+1)/2 + 2*k^2`.\\n...\\n\\n**s-1.** `k(k+1)/2 + (s-1)*k^2`.\\n\\n**s.** `s*k*i + i(i+1)/2`.\\n\\nLet us evaluate this sum and solve quadratic inequality:\\n\\n![image](https://assets.leetcode.com/users/images/d526bc75-9a24-4903-a81f-361ab34dda1b_1597655950.5398853.png)\\n\\n\\nSo, we have root `s = ((-1-2*i) + sqrt(1+8*n))/(2*k)` and we need to find the biggest integer number which is less than `s`, let us define it `t = floor(s)`.\\nNow, how many candies we need to give to this person? It is `i + (k+i) + ... + (sk+i) = i*(t+1) + k*t*(t+1)//2`. Finally, we need to find the last person, who gets the rest of the candies. How we can do it? I evaluate difference `s - floor(s)` and choose the person with the biggest difference.\\n\\n**Complexity**: time and space complexity is `O(k)`, where `k` is number of people. \\n\\n\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        k, n = num_people, candies\\n        alloc = [0]*k\\n        Final = (0, 0)\\n        for i in range(1, k+1):\\n            s = ((-1-2*i) + sqrt(1+8*n))/(2*k)\\n            t = floor(s)\\n            alloc[i-1] = i*(t+1) + k*t*(t+1)//2\\n            Final = max(Final, (s-floor(s), i)) \\n            \\n        alloc[Final[1]-1] += (n - sum(alloc))\\n            \\n        return alloc\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        k, n = num_people, candies\\n        alloc = [0]*k\\n        Final = (0, 0)\\n        for i in range(1, k+1):\\n            s = ((-1-2*i) + sqrt(1+8*n))/(2*k)\\n            t = floor(s)\\n            alloc[i-1] = i*(t+1) + k*t*(t+1)//2\\n            Final = max(Final, (s-floor(s), i)) \\n            \\n        alloc[Final[1]-1] += (n - sum(alloc))\\n            \\n        return alloc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796745,
                "title": "distribute-candies-0-ms-math-heavy-java",
                "content": "Of course, we could do literally what the problem says and simulate the distribution of candy - but as you imagine, this can get really slow when we reach `num_people = 10 ^ 9`.\\n\\nThe other approach is to skip the simulation and calculate the final candy distribution.\\n\\nLet\\'s imagine the candy distribution process for `candies = 10`, and `num_people = 3`:\\n\\nPerson 0 receives 1 piece of candy, Person 1 receives 2 pieces of candy, Person 2 receives 3 pieces of candy then we go back to Person 0 to give them the remaining 4 pieces of candy.\\nSo,\\n```\\n    p[0]  p[1]  p[2]\\n0:   1     2     3   +\\n1:   4\\n----------------\\n     5     2     3\\n```\\n\\nLet\\'s generalise: (`n = num_people`)\\n```\\n              p[0]            p[1]      ...       p[n - 1]\\n-----------------------------------------------------------\\n0:              1               2       ...           n\\n1:            n + 1           n + 2     ...         2 * n\\n...            ...             ...      ...          ... \\nk-1:  (k-1) * n + 1     (k-1)*n + 2     ...         k * n\\n```\\n(Remember this sum `1 + 2 + ... + n = n*(n + 1)/2`. Let\\'s call this as `gauss(n)` - EDIT: sum is `n*(n+1)/2` as user \\'cantbenix\\' said not `n*(n-1)/2` as I had left it before)\\nHow much candy have I distributed up until now? `1 + 2 + 3 + ... k * n = gauss(k * n)`\\nOf course, let\\'s not forget the remaining candy, which wouldn\\'t be enough to finish another row (or distribution cycle):\\n```\\n          k * n + 1       k * n + 2     ...\\n```\\nSo what did I need to do here? I want to find the greatest `k` such that I can do `k` passes of candy distribution \"automatically\". (I\\'ll do the remaining in a \"manual\" `for` loop.)\\nThat is, I need to find the greatest `k` so that `gauss(k * n) <= c`, where `c = candies`.\\nThis means: find greatest k such that `k*n * (k*n + 1) / 2 <= c`\\nWrite it again: \\n`n^2 * k^2 + n * k - 2*c <= 0`\\n\\nEDIT: Added process to obtain `k`.\\n![image](https://assets.leetcode.com/users/images/21103f79-5f58-4e0e-89c8-583395f1c721_1597852489.4983099.png)\\n\\n\\nIn code:\\n```\\nint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n```\\nI have `k`, let\\'s take out our `k` distribution cycles of candy.\\n```\\ncandies -= gauss(k * num_people);\\n```\\n(gauss(n) in code:)\\n```\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```\\n(EDIT: in the last row, second column it should be n*gauss(k-1) + 2*k,  as user \\'Juggernaut12\\' said)\\nNow let\\'s go back to our rows - and add them up:\\n```\\n              p[0]            p[1]             ...       p[n - 1]\\n------------------------------------------------------------------------\\n0:              1                     2        ...           n\\n1:            n + 1                 n + 2      ...         2 * n\\n...            ...                   ...       ...          ... \\nk-1:  (k-1) * n + 1           (k-1)*n + 2      ...         n * n\\n---------------------------------------------------------------------------\\ns: n*gauss(k-1) + 1*k    n*gauss(k-1) + 2*k    ...    n*gauss(k-1) + n*k\\n```\\nIn code:\\n```\\nfor (int i = 0; i < num_people; i++) {\\n\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n}\\n```\\nAll that remains is the last remaining distribution cycle.\\nIn code:\\n```\\nint d = k * num_people + 1;\\nint j = d;\\nfor (; candies - j >= 0; j++) {\\n\\tp[j - d] += j;\\n\\tcandies -= j;\\n}\\n\\nif (candies > 0) {\\n\\tp[j - d] += candies;\\n}\\n```\\n\\nFull solution:\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] p = new int[num_people];\\n\\n\\tint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n\\tcandies -= gauss(k * num_people);\\n\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n\\t}\\n\\n\\tint d = k * num_people + 1;\\n\\tint j = d;\\n\\tfor (; candies - j >= 0; j++) {\\n\\t\\tp[j - d] += j;\\n\\t\\tcandies -= j;\\n\\t}\\n\\n\\tif (candies > 0) {\\n\\t\\tp[j - d] += candies;\\n\\t}\\n\\n\\treturn p;\\n}\\n\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    p[0]  p[1]  p[2]\\n0:   1     2     3   +\\n1:   4\\n----------------\\n     5     2     3\\n```\n```\\n              p[0]            p[1]      ...       p[n - 1]\\n-----------------------------------------------------------\\n0:              1               2       ...           n\\n1:            n + 1           n + 2     ...         2 * n\\n...            ...             ...      ...          ... \\nk-1:  (k-1) * n + 1     (k-1)*n + 2     ...         k * n\\n```\n```\\n          k * n + 1       k * n + 2     ...\\n```\n```\\nint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n```\n```\\ncandies -= gauss(k * num_people);\\n```\n```\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```\n```\\n              p[0]            p[1]             ...       p[n - 1]\\n------------------------------------------------------------------------\\n0:              1                     2        ...           n\\n1:            n + 1                 n + 2      ...         2 * n\\n...            ...                   ...       ...          ... \\nk-1:  (k-1) * n + 1           (k-1)*n + 2      ...         n * n\\n---------------------------------------------------------------------------\\ns: n*gauss(k-1) + 1*k    n*gauss(k-1) + 2*k    ...    n*gauss(k-1) + n*k\\n```\n```\\nfor (int i = 0; i < num_people; i++) {\\n\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n}\\n```\n```\\nint d = k * num_people + 1;\\nint j = d;\\nfor (; candies - j >= 0; j++) {\\n\\tp[j - d] += j;\\n\\tcandies -= j;\\n}\\n\\nif (candies > 0) {\\n\\tp[j - d] += candies;\\n}\\n```\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] p = new int[num_people];\\n\\n\\tint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n\\tcandies -= gauss(k * num_people);\\n\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n\\t}\\n\\n\\tint d = k * num_people + 1;\\n\\tint j = d;\\n\\tfor (; candies - j >= 0; j++) {\\n\\t\\tp[j - d] += j;\\n\\t\\tcandies -= j;\\n\\t}\\n\\n\\tif (candies > 0) {\\n\\t\\tp[j - d] += candies;\\n\\t}\\n\\n\\treturn p;\\n}\\n\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324215,
                "title": "java-o-num-people-one-pass-math-solution-solving-quadratic-function",
                "content": "Different solution from the O(sqrt(candies)) one.\\n\\nExplanation:\\n The operation of distributing candies is an Arithmetic Sequence. \\n If we want to get the sum from 1 to n, the formula is` (1+n) * n / 2`.\\n =>` (1+n) * n / 2 = candies => n^2 + n - 2*candies = 0` \\n If the one dimensional quadratic function is like `ax^2 + bx + c = 0` where a, b, c are parameters.\\n There is a formula to solve it which is[ x = (-b (+/-) sqrt(b^2-4\\\\*a\\\\*c)) / (2\\\\*a)](https://en.wikipedia.org/wiki/Quadratic_formula).\\n \\n Based on that, we can know the # of times which the candies are fully distributed where fully means the person get the # of candies which is supposed to distribute, \\n not the leftover.\\n \\n Let\\'s use 3 people as an example,\\n 1       ->  2       ->  3\\n (1+3)-> (2+3)  -> (3 + 3)\\n (1+2\\\\*3) -> (2+2\\\\*3) ->(3+2\\\\*3)\\n ......\\n It is quite obvious that except the first round, the value of each cell of the rest rounds is just the sum of their count at the first round\\n plus the length of the array times the number of rounds(0 based) it goes(Another Arithmetic sequence). Based on the length of the quadratic formula we calculated above, we can calculate the # of rounds, the mod, and the # of candies of the leftover. \\nThe complexity is `O(num_people)`, since we only need to assign value to the return array once.\\n \\n \\n     public int[] distributeCandies(int candies, int num_people) {\\n        int end = (int)((-1 + Math.sqrt(1L+8L*candies)) / 2f);  // Kind of dislike the overflow testcase of this question.\\n        int extra_candies = candies - (1 + end) * end / 2; // Get the leftover for the last distribution.\\n        int rounds = end / num_people;\\n        int rest = end % num_people;\\n        int[] res = new int[num_people];\\n\\t\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\t\\tif (i < rest) {\\n\\t\\t\\t\\tres[i] = (int)((i + 1) * (rounds + 1) + (1 + rounds) * rounds / 2 * num_people);\\n\\t\\t\\t} else if (i == rest) {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people + extra_candies;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people;\\n\\t\\t\\t}\\n\\t\\t}\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Different solution from the O(sqrt(candies)) one.\\n\\nExplanation:\\n The operation of distributing candies is an Arithmetic Sequence. \\n If we want to get the sum from 1 to n, the formula is` (1+n) * n / 2`.\\n =>` (1+n) * n / 2 = candies => n^2 + n - 2*candies = 0` \\n If the one dimensional quadratic function is like `ax^2 + bx + c = 0` where a, b, c are parameters.\\n There is a formula to solve it which is[ x = (-b (+/-) sqrt(b^2-4\\\\*a\\\\*c)) / (2\\\\*a)](https://en.wikipedia.org/wiki/Quadratic_formula).\\n \\n Based on that, we can know the # of times which the candies are fully distributed where fully means the person get the # of candies which is supposed to distribute, \\n not the leftover.\\n \\n Let\\'s use 3 people as an example,\\n 1       ->  2       ->  3\\n (1+3)-> (2+3)  -> (3 + 3)\\n (1+2\\\\*3) -> (2+2\\\\*3) ->(3+2\\\\*3)\\n ......\\n It is quite obvious that except the first round, the value of each cell of the rest rounds is just the sum of their count at the first round\\n plus the length of the array times the number of rounds(0 based) it goes(Another Arithmetic sequence). Based on the length of the quadratic formula we calculated above, we can calculate the # of rounds, the mod, and the # of candies of the leftover. \\nThe complexity is `O(num_people)`, since we only need to assign value to the return array once.\\n \\n \\n     public int[] distributeCandies(int candies, int num_people) {\\n        int end = (int)((-1 + Math.sqrt(1L+8L*candies)) / 2f);  // Kind of dislike the overflow testcase of this question.\\n        int extra_candies = candies - (1 + end) * end / 2; // Get the leftover for the last distribution.\\n        int rounds = end / num_people;\\n        int rest = end % num_people;\\n        int[] res = new int[num_people];\\n\\t\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\t\\tif (i < rest) {\\n\\t\\t\\t\\tres[i] = (int)((i + 1) * (rounds + 1) + (1 + rounds) * rounds / 2 * num_people);\\n\\t\\t\\t} else if (i == rest) {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people + extra_candies;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people;\\n\\t\\t\\t}\\n\\t\\t}\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 796969,
                "title": "c-one-pass-solution",
                "content": "candies can be separated into kth consecutive numbers and remains (less than k + 1) which can be represented by \\n\\n![image](https://assets.leetcode.com/users/images/1912f310-2130-4725-a1c5-7bcef2f1749c_1597674695.8112812.png)\\n\\nAfter getting k, we can know how many rounds that all persons get the desire candies are performed.\\n![image](https://assets.leetcode.com/users/images/60f69745-3943-4290-8fb1-8660ac2070a2_1597674738.0373456.png)\\n\\n\\nfor ith person, the total candies that he obtains is \\n\\n![image](https://assets.leetcode.com/users/images/55e53b64-f0b6-415c-b9dd-8ba9de9a6550_1597674766.2962093.png)\\n\\n\\nConvert above into C++ code\\n```C++\\nvector<int> distributeCandies(double candies, int num_people) {\\n\\tvector<int> res(num_people, 0);\\n\\n\\tdouble total = floor((-1 + sqrt(1 + 8 * candies)) / 2);\\n\\tint round = floor(total / num_people);\\n\\n\\tfor (int i = 1; i <= num_people; i++)\\n\\t{\\n\\t\\tint first = i;\\n\\t\\tint last = first + num_people * (round - 1);\\n\\t\\tint inComplete = candies - (num_people+last) * (num_people + last - 1) / 2;\\n\\t\\tres[i - 1] = (first + last) * round / 2 + max(min(last + num_people, inComplete), 0);\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```C++\\nvector<int> distributeCandies(double candies, int num_people) {\\n\\tvector<int> res(num_people, 0);\\n\\n\\tdouble total = floor((-1 + sqrt(1 + 8 * candies)) / 2);\\n\\tint round = floor(total / num_people);\\n\\n\\tfor (int i = 1; i <= num_people; i++)\\n\\t{\\n\\t\\tint first = i;\\n\\t\\tint last = first + num_people * (round - 1);\\n\\t\\tint inComplete = candies - (num_people+last) * (num_people + last - 1) / 2;\\n\\t\\tres[i - 1] = (first + last) * round / 2 + max(min(last + num_people, inComplete), 0);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796427,
                "title": "easy-to-understand-java-solution-without-complex-math-formulas",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797848,
                "title": "solution-python",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        # create an array of size num_people and initialize it with 0\\n        list_people = [0] * num_people\\n        \\n        # starting value\\n        index = 1\\n        \\n        # iterate until the number of candies are more than 0\\n        while candies > 0:\\n            \\n            # if candies are more than index value, add the index value to the location \\n            if candies > index:\\n                # we are using mod operation by the num_people to locate the index of the array\\n                # we are subtracting by 1 because the array index starts at 0\\n                list_people[(index - 1) % num_people] += index\\n            else:\\n                # if candies are less than index value, add all remaining candies to location\\n                list_people[(index - 1) % num_people] += candies\\n            \\n            # subtract the candies with index values\\n            candies -= index\\n            \\n            # increment the index values\\n            index += 1\\n        \\n        # return the resultant array\\n        return(list_people)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        # create an array of size num_people and initialize it with 0\\n        list_people = [0] * num_people\\n        \\n        # starting value\\n        index = 1\\n        \\n        # iterate until the number of candies are more than 0\\n        while candies > 0:\\n            \\n            # if candies are more than index value, add the index value to the location \\n            if candies > index:\\n                # we are using mod operation by the num_people to locate the index of the array\\n                # we are subtracting by 1 because the array index starts at 0\\n                list_people[(index - 1) % num_people] += index\\n            else:\\n                # if candies are less than index value, add all remaining candies to location\\n                list_people[(index - 1) % num_people] += candies\\n            \\n            # subtract the candies with index values\\n            candies -= index\\n            \\n            # increment the index values\\n            index += 1\\n        \\n        # return the resultant array\\n        return(list_people)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331676,
                "title": "c-0ms-no-math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        int c = 1, i = 0;\\n        \\n        vector<int> result(num_people, 0);\\n        \\n        while(candies) {\\n\\n            int give = min(c, candies);\\n            result[i] += give;\\n            candies -= give;\\n            \\n            c++;\\n            i = (i+1) % num_people; \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        int c = 1, i = 0;\\n        \\n        vector<int> result(num_people, 0);\\n        \\n        while(candies) {\\n\\n            int give = min(c, candies);\\n            result[i] += give;\\n            candies -= give;\\n            \\n            c++;\\n            i = (i+1) % num_people; \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796547,
                "title": "optimal-python-solution-with-clear-explanation-of-idea",
                "content": "Please read with patience for clear understanding - Before proceeding, remember that sum of first n natural numbers is n*(n+1)//2\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n       \\'\\'\\'\\n        Idea: Round number k (starting from 1)\\n              -> give away\\n              (k-1)*n+1 + (k-1)*n+2 + ... + (k-1)*n + n = \\n              (k-1)*n^2 + n*(n+1)/2 candies\\n              \\n        Assume we have completed K full rounds, then K is the largest integer >= 0 with\\n        \\n        K*n*(n+1)/2 + K * (K-1)/2 * n^2 <= candies \\n        \\n        Find K by binary search and then simulate the last round.\\n        \\n        The person at index i gets\\n    \\n        0*n+i+1 + ... + (K-1)*n+i+1 = K*(i+1) + n*K*(K-1)/2 \\n        \\n        candies from rounds 1 to K, plus everything they get on their\\n        last round.\\n        \\n        Important: Allow for the fact that we may not complete a single round.\\n\\n        REVIEW\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        lo, hi = 0, candies\\n        K = 0\\n        while lo <= hi:\\n            k = (lo + hi)//2\\n            if k*(num_people*(num_people+1))//2 + (k*(k-1))//2 * num_people**2 <= candies:\\n                K = k\\n                lo = k + 1\\n            else:\\n                hi = k - 1\\n        result = [(i+1)*K+num_people*(K*(K-1))//2 for i in range(num_people)]\\n        candies -= sum(result)\\n        for i in range(num_people):\\n            add = min(candies, K * num_people + i + 1)\\n            result[i] += add\\n            candies -= add\\n            if candies == 0:\\n                break\\n        return result  \\n\\t\\t```\\nIf you came till here - Please Upvote my effort",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n       \\'\\'\\'\\n        Idea: Round number k (starting from 1)\\n              -> give away\\n              (k-1)*n+1 + (k-1)*n+2 + ... + (k-1)*n + n = \\n              (k-1)*n^2 + n*(n+1)/2 candies\\n              \\n        Assume we have completed K full rounds, then K is the largest integer >= 0 with\\n        \\n        K*n*(n+1)/2 + K * (K-1)/2 * n^2 <= candies \\n        \\n        Find K by binary search and then simulate the last round.\\n        \\n        The person at index i gets\\n    \\n        0*n+i+1 + ... + (K-1)*n+i+1 = K*(i+1) + n*K*(K-1)/2 \\n        \\n        candies from rounds 1 to K, plus everything they get on their\\n        last round.\\n        \\n        Important: Allow for the fact that we may not complete a single round.\\n\\n        REVIEW\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        lo, hi = 0, candies\\n        K = 0\\n        while lo <= hi:\\n            k = (lo + hi)//2\\n            if k*(num_people*(num_people+1))//2 + (k*(k-1))//2 * num_people**2 <= candies:\\n                K = k\\n                lo = k + 1\\n            else:\\n                hi = k - 1\\n        result = [(i+1)*K+num_people*(K*(K-1))//2 for i in range(num_people)]\\n        candies -= sum(result)\\n        for i in range(num_people):\\n            add = min(candies, K * num_people + i + 1)\\n            result[i] += add\\n            candies -= add\\n            if candies == 0:\\n                break\\n        return result  \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1088057,
                "title": "c-0-ms-faster-than-100-00-4-lines-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        for ( int index = 0; candies > 0; ++index, candies -= index )\\n            res[index % num_people] += min(index + 1, candies);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        for ( int index = 0; candies > 0; ++index, candies -= index )\\n            res[index % num_people] += min(index + 1, candies);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 797184,
                "title": "c-very-performant-linear-approach-explained-100-time-75-space",
                "content": "Alright, I promise I will try to keep the math part to a minimum, but bear with me for that part.\\n\\nAssuming we have 4 people to feed glue + glucose (and diabetes) as in the first example and having a large amount of them, our situation would look like this:\\n\\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\\n\\nCan we spot a pattern here? I would say so: for now let\\'s look at each row and we can see how each one is formed; the initial one comes from the sum of all the first `n` numbers, but we know how to handle this with the Gaussian formula (conveniently abstracted in the `gaussianSum` helper).\\n\\nThe following ones come having each an extra of `n` times `n`, which I stored as `squaredN` times the current iteration (counting from `0`); or, in other words: the first round will be giving out `gaussianSum(n)` candies (we will store this number initially in `partialSum`) and all the following ones will increase said amount by `squaredN`.\\n\\nNow we can have a loop to compute how many full iterations we can run before being left with not enough candy to go for a full round of gluttony and this is not a small advantage!\\n\\nThe whole logic of the first `while` loop is dedicated to that, so that we can have a reliable `countLoop` value which tells us how many full loops we can go [and I am sure you can also set it up as an equation to find them, but I felt uninspired for that and it was more fun this way].\\n\\nNext step, we will fill all the slots with all the candies you can get doing full runs of each row.\\n\\nLooks again at this:\\n\\n```cpp\\n 1   2   3   4\\n 5   6   7   8\\n 9  10  11  12\\n13  14  15  16\\n```\\n\\nBut focus on the columns now: we can see that each one is made of `countLoops` times its position (starting the count from `1`, not from `0`) plus `0` times `n` from the first row, `1` time `n` from the second row, `2` times `n` from the second row and so on - that is to say, `gaussianSum(countLoops - 1)` times `n`.\\n\\nIn our `for` loop we put both thing together and we can get away filling the data of the full runs in linear time once we have `countLoops` properly computed.\\n\\nLast step: we need another `while` loop to finish assigning our sticky bonbon, iterating with `nextValue` initially set to the minimum value between the current amount of `candies` and `countLoops * n + 1` (which would have been the value of the extra candies given to the very first person in the next iteration), going on like that until we have something to give away - ie: at each step we decrease the amount of leftover `candies` by `nextValue`, add the `i`th cell by `nextValue` and increase both `i` and `nextValue` by `1`.\\n\\nAgain linear time :)\\n\\nFinally, we return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops = 0, partialSum = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        while (partialSum <= candies) {\\n            countLoops++;\\n            candies -= partialSum;\\n            partialSum += squaredN;\\n        }\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWell, in the end I did feel inspired and went on for a more mathematical approach.\\n\\nSticking to the previous example, we know that each full loop is made of the Gaussian sum of all the numbers up to `n` times the number of loops, plus `n` times `n`, AKA `squaredN`, times the sum of all the first `n - 1` numbers (check them looking at the second part of the sequence with `16, 32, 48, ...`). Allow me to repeat the scheme:\\n\\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\\n\\nNow, we can build an equation out of it:\\n\\n```cpp\\ncandies == sumToN * x + (x - 1) * x / 2 * squaredN\\n```\\n\\nWith `x` being the number of full loops we can do (basically `countLoop`, but I guess with `x` it is clearer to see it as an equation).\\n\\nGrouping, we can have\\n\\n```cpp\\n0 == (squaredN / 2) * (x * x) + (sumToN -squaredN / 2) * x - candies;\\n```\\n\\nSo, basically we just need to solve a second degree equation with this coefficients:\\n* `a`: `squaredN / 2`;\\n* `b`: `sumToN -squaredN / 2`;\\n* `c`: `- candies`;\\n* taking only the positive solution (negative loops do not make sense here): `(-b + sqrt(b * b - 4 * a * c)) / (2 * a)`.\\n\\nAnd that works!\\n\\nBut now we have another problem: nothing decreases our `candies` any more!\\n\\nWell, we just have to compute how many we gave away with full loops!\\n\\nGiven that the formula for one cell is (see explanation above) `numberOfNs * n + (i + 1) * (countLoops)`, we just have to compute how much would it be running it from `1` to `n`, but that is relatively easy!\\n\\nDoing some math, we see that the first part is constant, so it would be `numberOfNs * n * n` or, better, `numberOfNs * squaredN`; the second part is basically `countLoops` multiplied the sum of all the numbers from `1` to `n` , so `sumToN * countLoops`.\\n\\nWith that done, we just need to keep our previous logic for the final (partial) pass and we are done :)\\n\\nThe updated code, much faster for larger values of `candies`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops, sumToN = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        float halfSquaredN = squaredN / 2.0, a = halfSquaredN, b = sumToN - halfSquaredN, c = -candies;\\n        countLoops = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // updating candies\\n        candies -= numberOfNs * squaredN + sumToN * countLoops;\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\n```cpp\\n 1   2   3   4\\n 5   6   7   8\\n 9  10  11  12\\n13  14  15  16\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops = 0, partialSum = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        while (partialSum <= candies) {\\n            countLoops++;\\n            candies -= partialSum;\\n            partialSum += squaredN;\\n        }\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\n```cpp\\ncandies == sumToN * x + (x - 1) * x / 2 * squaredN\\n```\n```cpp\\n0 == (squaredN / 2) * (x * x) + (sumToN -squaredN / 2) * x - candies;\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops, sumToN = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        float halfSquaredN = squaredN / 2.0, a = halfSquaredN, b = sumToN - halfSquaredN, c = -candies;\\n        countLoops = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // updating candies\\n        candies -= numberOfNs * squaredN + sumToN * countLoops;\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796528,
                "title": "c-simple-explained-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people, 0); // start with zero candies for each person\\n        int i=0;\\n        while (candies > 0) // while there are more candies to distribute\\n        {\\n            res[i%num_people]+=i+1;\\n            candies-=i+1;\\n            i++;\\n        }\\n        if (candies < 0) // if the last person got more than the candies we had left\\n            res[(i-1)%num_people] -= abs(candies);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people, 0); // start with zero candies for each person\\n        int i=0;\\n        while (candies > 0) // while there are more candies to distribute\\n        {\\n            res[i%num_people]+=i+1;\\n            candies-=i+1;\\n            i++;\\n        }\\n        if (candies < 0) // if the last person got more than the candies we had left\\n            res[(i-1)%num_people] -= abs(candies);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323418,
                "title": "python-math-solution-explained-o-n",
                "content": "First check how many complete rounds\\nthen distribute the rest greedy.\\n```\\nclass Solution:\\n    def distributeCandies(self, c: int, n: int) -> List[int]:\\n        k = math.floor((math.sqrt(1+8*c)-1)/2/n)\\n        res = [0 for i in range(n)]\\n        for i in range(n):\\n            res[i] = (i+1+(k-1)*(n)+i+1)*k/2\\n        remain = c - sum(res)\\n        i = 0\\n        cur = k*n+1\\n        while remain >= 0:\\n            res[i] += min(remain,cur)\\n            remain -= cur\\n            \\n            cur += 1\\n            i += 1\\n        return [int(i) for i in res]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, c: int, n: int) -> List[int]:\\n        k = math.floor((math.sqrt(1+8*c)-1)/2/n)\\n        res = [0 for i in range(n)]\\n        for i in range(n):\\n            res[i] = (i+1+(k-1)*(n)+i+1)*k/2\\n        remain = c - sum(res)\\n        i = 0\\n        cur = k*n+1\\n        while remain >= 0:\\n            res[i] += min(remain,cur)\\n            remain -= cur\\n            \\n            cur += 1\\n            i += 1\\n        return [int(i) for i in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361640,
                "title": "java-o-num-people-beats-100-with-detailed-math-explanation",
                "content": "This solution is based on the hint provided in the question. *Give candy to everyone each \"turn\" first [until you can\\'t], then give candy to one person per turn.*\\n\\nFirst, we get the number of turns in which we can distribute candies on every one. For example if we have 21 candies and 3 people. We have 2 turns. In the first turn we give 1, 2, 3 and in the 2nd we give 4, 5, 6. The candies distributed per turn are as follows:\\n\\n1st turn  => 1, 2, 3, ...., n \\n\\n\\t=> 0 * n + 1 + 0 * n + 2 + 0 * n + 3, ..., 0 * n + n\\n\\t\\n2nd turn => n + 1, n + 2, n + 3, ... , n + n \\n\\n\\t=>  1 * n + 1 + 1 * n + 2 + 1 * n + 3, ..., 1 * n + n\\n\\t\\n3rd turn => 2n + 1, 2n + 2, 2n + 3, ...., 2n + n \\n\\n\\t=> 2 * n + 1 + 2 * n + 2 + 2 * n + 3, ..., 2 * n + n\\n\\t\\nkth turn \\n\\n\\t=> (k - 1) * n + 1 + (k - 1) * n + 2 + (k - 1) * n + 3, ..., (k - 1) * n + n\\n\\t\\nThe total number of candies per turn for all people can be described by \\n\\t\\n\\tn * (k - 1) * n + summation of sequence 1, 2, 3, .., n. \\n\\t=> n * (k - 1) * n + (n (n + 1)) / 2.\\n\\nGet the total number of turns by subtracting the total turn candies from the total number of candies.\\n\\n```\\nint turns = 0; // starting at turn 0 instead of doing k - 1\\nint n = num_people;\\nint closedSum = (n * (n + 1)) / 2;\\nint totalTurnSum = closedSum;\\n\\n// Getting total number of possible FULL turns\\nwhile (candies - totalTurnSum >= 0) {\\n\\tcandies -= totalTurnSum;\\n\\t// Setting totalTurnSum for next turn\\n\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n}\\n```\\n\\nThe total number of candies for the ith person for all \"full\" turns can be described by summation of the sequence (k - 1) * n + (k - 1) * (i + 1) (Because the first person (i = 0) starts with 1) over k, where k is the number of turns. \\n\\n\\tsummation of  [ (k - 1) * n + (i + 1) ]  over k from 1 to turns\\n\\t= summation of (k - 1) * n + summation of (i + 1)\\n\\t= n * summation of (k - 1) + (i + 1) summation of 1\\n\\t= n * ((turns - 1) * turns) / 2 +  (i + 1) * turns\\n\\n```\\n// if we have at least 1 full turn\\nif (turns > 0) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tres[i] = n * (turns * (turns - 1)) / 2 + (i + 1) * turns;\\n\\t}\\n}\\n```\\n\\nFor the last incomplete turn we simply distribute the remaining coins. (Similar to this approach by rock https://leetcode.com/problems/distribute-candies-to-people/discuss/323314/JavaPython3-Easy-code-w-explanation-and-analysis.)\\n\\n```\\n// distributing the last incomplete turn\\nint offset = turns * n + 1;\\nfor (int i = 0; i < n && candies > 0; i++) {\\n\\tres[i] += Math.min(candies, offset);\\n\\tcandies -= offset++;\\n}\\n```\\n\\nThis might be an overkill for an easy question. Code modifications, tips and tricks are most welcome! :)\\n\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        if (candies == 0 || num_people == 0) return new int[num_people];\\n        int[] res = new int[num_people];\\n        int turns = 0;  // starting at turn 0 instead of doing k - 1\\n\\t\\tint n = num_people;\\n\\t\\tint closedSum = (n * (n + 1)) / 2;\\n\\t\\tint totalTurnSum = closedSum;\\n\\t\\t// Getting total number of possible FULL turns\\n\\t\\twhile (candies - totalTurnSum >= 0) {\\n\\t\\t\\tcandies -= totalTurnSum;\\n\\t\\t\\t// Setting totalTurnSum for next turn\\n\\t\\t\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n\\t\\t}\\n        // if we have at least 1 full turn\\n        if (turns > 0) {\\n            for (int i = 0; i < n; i++) {\\n                res[i] = n * (turns * (turns - 1)) / 2 +  (i + 1) * turns;\\n            }\\n        }\\n        // distributing the last incomplete turn\\n        int offset = turns * n + 1;\\n        for (int i = 0; i < n && candies > 0; i++) {\\n            res[i] += Math.min(candies, offset);\\n            candies -= offset++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint turns = 0; // starting at turn 0 instead of doing k - 1\\nint n = num_people;\\nint closedSum = (n * (n + 1)) / 2;\\nint totalTurnSum = closedSum;\\n\\n// Getting total number of possible FULL turns\\nwhile (candies - totalTurnSum >= 0) {\\n\\tcandies -= totalTurnSum;\\n\\t// Setting totalTurnSum for next turn\\n\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n}\\n```\n```\\n// if we have at least 1 full turn\\nif (turns > 0) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tres[i] = n * (turns * (turns - 1)) / 2 + (i + 1) * turns;\\n\\t}\\n}\\n```\n```\\n// distributing the last incomplete turn\\nint offset = turns * n + 1;\\nfor (int i = 0; i < n && candies > 0; i++) {\\n\\tres[i] += Math.min(candies, offset);\\n\\tcandies -= offset++;\\n}\\n```\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        if (candies == 0 || num_people == 0) return new int[num_people];\\n        int[] res = new int[num_people];\\n        int turns = 0;  // starting at turn 0 instead of doing k - 1\\n\\t\\tint n = num_people;\\n\\t\\tint closedSum = (n * (n + 1)) / 2;\\n\\t\\tint totalTurnSum = closedSum;\\n\\t\\t// Getting total number of possible FULL turns\\n\\t\\twhile (candies - totalTurnSum >= 0) {\\n\\t\\t\\tcandies -= totalTurnSum;\\n\\t\\t\\t// Setting totalTurnSum for next turn\\n\\t\\t\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n\\t\\t}\\n        // if we have at least 1 full turn\\n        if (turns > 0) {\\n            for (int i = 0; i < n; i++) {\\n                res[i] = n * (turns * (turns - 1)) / 2 +  (i + 1) * turns;\\n            }\\n        }\\n        // distributing the last incomplete turn\\n        int offset = turns * n + 1;\\n        for (int i = 0; i < n && candies > 0; i++) {\\n            res[i] += Math.min(candies, offset);\\n            candies -= offset++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369518,
                "title": "python3-very-easy-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n\\t\\t\\tresult=[0]*num_people\\n\\t\\t\\tcurrentCandies=1\\n\\t\\t\\ti=0\\n\\t\\t\\twhile candies>0:\\n\\t\\t\\t\\tresult[i%num_people]+=min(candies,currentCandies)\\n\\t\\t\\t\\tcandies-=currentCandies\\n\\t\\t\\t\\tcurrentCandies+=1\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn result",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n\\t\\t\\tresult=[0]*num_people\\n\\t\\t\\tcurrentCandies=1\\n\\t\\t\\ti=0\\n\\t\\t\\twhile candies>0:\\n\\t\\t\\t\\tresult[i%num_people]+=min(candies,currentCandies)\\n\\t\\t\\t\\tcandies-=currentCandies\\n\\t\\t\\t\\tcurrentCandies+=1\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 464830,
                "title": "python-simplest-and-easiest-understand-way",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]* num_people\\n        cnt = 1\\n        \\n        while candies > 0:\\n\\n            for i in range(len(ans)):\\n\\n                if candies >= cnt:\\n                    ans[i] += cnt\\n                    candies -= cnt\\n                else:\\n                    ans[i] += candies\\n                    candies = 0\\n                cnt += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]* num_people\\n        cnt = 1\\n        \\n        while candies > 0:\\n\\n            for i in range(len(ans)):\\n\\n                if candies >= cnt:\\n                    ans[i] += cnt\\n                    candies -= cnt\\n                else:\\n                    ans[i] += candies\\n                    candies = 0\\n                cnt += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3405818,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis=[0]*num_people\\n        i=1\\n        j=0\\n        while(candies):\\n            if(candies<i):\\n                lis[j%num_people]+=candies\\n                break\\n            if(candies>=i):\\n                lis[j%num_people]+=i\\n                candies-=i\\n                j+=1\\n                i+=1\\n            \\n        return(lis)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis=[0]*num_people\\n        i=1\\n        j=0\\n        while(candies):\\n            if(candies<i):\\n                lis[j%num_people]+=candies\\n                break\\n            if(candies>=i):\\n                lis[j%num_people]+=i\\n                candies-=i\\n                j+=1\\n                i+=1\\n            \\n        return(lis)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739916,
                "title": "simple-beginner-friendly-approach-java",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n       int[] ans = new int[num_people];\\n        int count = 1;\\n        int i = 0;\\n        while(candies>0){\\n            if(candies<count)\\n                ans[i]=ans[i]+candies;\\n            else\\n                ans[i]=ans[i]+count;\\n            i++;\\n            candies-=count;\\n            count++;\\n            if(i==ans.length)\\n                i=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n       int[] ans = new int[num_people];\\n        int count = 1;\\n        int i = 0;\\n        while(candies>0){\\n            if(candies<count)\\n                ans[i]=ans[i]+candies;\\n            else\\n                ans[i]=ans[i]+count;\\n            i++;\\n            candies-=count;\\n            count++;\\n            if(i==ans.length)\\n                i=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424125,
                "title": "c-easy-to-understand-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int> ans(num_people);\\n        int loops=0,i=0,curr_candies;\\n       while(candies>0)\\n       {\\n           if(i==num_people)\\n           {\\n              loops++;\\n              i=0;\\n           }  \\n           curr_candies=loops*num_people+i+1;\\n           if(candies-curr_candies<0)\\n           {\\n              ans[i]+=candies;\\n           }\\n           else\\n           ans[i]+=curr_candies;\\n           candies-=curr_candies;\\n           i++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int> ans(num_people);\\n        int loops=0,i=0,curr_candies;\\n       while(candies>0)\\n       {\\n           if(i==num_people)\\n           {\\n              loops++;\\n              i=0;\\n           }  \\n           curr_candies=loops*num_people+i+1;\\n           if(candies-curr_candies<0)\\n           {\\n              ans[i]+=candies;\\n           }\\n           else\\n           ans[i]+=curr_candies;\\n           candies-=curr_candies;\\n           i++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402807,
                "title": "java-solution",
                "content": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[]ans=new int[n];\\n        int i=0;\\n        while(candies>0){\\n            ans[i%n]+=Math.min(i+1,candies);    \\n\\t\\t\\t//doing i%n so that we can some back  again and give candies if there are any\\n            candies-=i+1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[]ans=new int[n];\\n        int i=0;\\n        while(candies>0){\\n            ans[i%n]+=Math.min(i+1,candies);    \\n\\t\\t\\t//doing i%n so that we can some back  again and give candies if there are any\\n            candies-=i+1;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1088053,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        index = 0\\n        while candies > 0:\\n            res[index % num_people] += min(index + 1, candies)\\n            index += 1\\n            candies -= index\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        index = 0\\n        while candies > 0:\\n            res[index % num_people] += min(index + 1, candies)\\n            index += 1\\n            candies -= index\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 797800,
                "title": "java-solution-beats-100-time",
                "content": "Given candies = 40 , num_people = 3.\\n\\nThe distrbution is like the following:\\n```\\n\\t\\t\\tpeople_0  people_1  people_2  \\nrow_0           1         2         3\\nrow_1           4         5         6\\nrow_2           7         8         (4)\\n```\\n\\nThe total number of candies ditrubuted to each people are:\\npeople_0: 1 + 4 + 7\\npeople_1: 2 + 5 + 8\\npeople_2: 3 + 6 + (4)\\n\\nIts indicated that the number of candies each person receives follows arithmetic sequence where the common difference is the 3 (num_people)\\n\\nSo the goals of the problem are to:\\n```\\n1) Find the last number of the distrubition without running out of candies. which is to find 8 in above case.\\n2) Calculate the total number of candies for each people. \\n3) Find the index of the last people who are given the remaining candies after 1), which is 8 % 3 = 2.\\n4) Calcute the number of remaining candies after 1), which is (4) in above case.  (40 - (1+2 ... +8) = 4)\\n```\\n\\nTo calucate 1) \\nWe have to find the max positive integer of N which satifies \\n(1 + N) * N / 2 <= candies   \\n--> \\nN2 + N - 2 * candies <= 0\\n\\nSo N = floor( ![image](https://assets.leetcode.com/users/images/cfcf8b6b-64d2-41b1-9078-adee03d4332f_1597709353.2275171.png)) \\n=  floor(![image](https://assets.leetcode.com/users/images/c6cdb2ef-df45-44f1-97a7-b06f89689cf5_1597709442.058968.png) )\\n=  floor(![image](https://assets.leetcode.com/users/images/b106ad98-d715-4e88-b08b-0d65eec92872_1597709484.9748318.png))\\n\\nTo calcaute 2)\\n```\\ntotal(people_i) = (first_time_candies_given + last_time_candies_given) * times_candies_given / 2;\\n\\n                = (i+1) + ((i+1) + (highest_row-1) * num_people)) * highest_row / 2;\\n\\nFor e.g. \\ntotal(people_0) = ((0+1) + (0+1) + (3-1) * 3)) * 3 /2\\n                = (1 + (1 + 2 * 3)) * 3 / 2 = 12\\n\\ntotal(people_2) = ((2+1) + (2+1) + (2-1) * 3)) * 3 /2\\n                = (3 + (3 + 1 * 3)) * 2 / 2 = 9\\n```\\nTo calcaulte 4) \\n```\\nrenaming_candies = candies - (1 + N) * N /2\\n```\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        \\n        int N = (int) Math.floor(((Math.sqrt(1 + 8 * (long) candies) - 1) / 2));\\n        int[] ans = new int[num_people];\\n        int row = N / num_people;\\n\\t\\t\\n        for(int i = 0; i < N && i < num_people; i++) {\\n            if(i < N % num_people) {\\n                ans[i] = (2 * (i+1) + row * num_people) * (row + 1) / 2;\\n            }\\n            else {\\n                ans[i] = (2 * (i+1) + (row - 1) * num_people) * row / 2;\\n            }\\n        }\\n        \\n\\t\\t// add remaning candies to his total\\n        ans[N % num_people] += candies - N * (N + 1) /2;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTime:O(n)     n->num_people\\nExtra space:O(1)",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\tpeople_0  people_1  people_2  \\nrow_0           1         2         3\\nrow_1           4         5         6\\nrow_2           7         8         (4)\\n```\n```\\n1) Find the last number of the distrubition without running out of candies. which is to find 8 in above case.\\n2) Calculate the total number of candies for each people. \\n3) Find the index of the last people who are given the remaining candies after 1), which is 8 % 3 = 2.\\n4) Calcute the number of remaining candies after 1), which is (4) in above case.  (40 - (1+2 ... +8) = 4)\\n```\n```\\ntotal(people_i) = (first_time_candies_given + last_time_candies_given) * times_candies_given / 2;\\n\\n                = (i+1) + ((i+1) + (highest_row-1) * num_people)) * highest_row / 2;\\n\\nFor e.g. \\ntotal(people_0) = ((0+1) + (0+1) + (3-1) * 3)) * 3 /2\\n                = (1 + (1 + 2 * 3)) * 3 / 2 = 12\\n\\ntotal(people_2) = ((2+1) + (2+1) + (2-1) * 3)) * 3 /2\\n                = (3 + (3 + 1 * 3)) * 2 / 2 = 9\\n```\n```\\nrenaming_candies = candies - (1 + N) * N /2\\n```\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        \\n        int N = (int) Math.floor(((Math.sqrt(1 + 8 * (long) candies) - 1) / 2));\\n        int[] ans = new int[num_people];\\n        int row = N / num_people;\\n\\t\\t\\n        for(int i = 0; i < N && i < num_people; i++) {\\n            if(i < N % num_people) {\\n                ans[i] = (2 * (i+1) + row * num_people) * (row + 1) / 2;\\n            }\\n            else {\\n                ans[i] = (2 * (i+1) + (row - 1) * num_people) * row / 2;\\n            }\\n        }\\n        \\n\\t\\t// add remaning candies to his total\\n        ans[N % num_people] += candies - N * (N + 1) /2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797248,
                "title": "python-easy-o-sqrt-candies-solution",
                "content": "The idea of my solution is super straightforward. We basically follow the task: we would add 1 to the first cell, 2 to the second, and so on. If we reach the end of the loop we subtracts the list length (=*num_people*) from the iteration counter and keep doing so. How long do we do it? As long as we have more candies than we have to add. So once *i* surpasses *candies* we exit the loop. After that we just have to add the remaining candies to the next cell and that would be it. \\n\\n```\\n        res = [0] * num_people\\n        i, j = 0, 0\\n        i = 0\\n        while candies > i:\\n            res[j] += i + 1\\n            j += 1\\n            i += 1\\n            candies -= i\\n            if j == num_people - 1: j -= num_people\\n        res[j] += candies\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n        res = [0] * num_people\\n        i, j = 0, 0\\n        i = 0\\n        while candies > i:\\n            res[j] += i + 1\\n            j += 1\\n            i += 1\\n            candies -= i\\n            if j == num_people - 1: j -= num_people\\n        res[j] += candies\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796986,
                "title": "javascript-easy-solution",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let finalDistribution = new Array(num_people).fill(0) // [0,0,0,0] //candies=7\\n    let candy =1;\\n    let i = 0;\\n    while(candy < candies){\\n        if(i===num_people) i=0\\n        finalDistribution[i] = finalDistribution[i]+candy;\\n        candies = candies - candy;\\n        candy++;\\n        i++;\\n    }\\n    if(candies > 0){\\n        if(i===num_people) i=0;\\n        finalDistribution[i] = finalDistribution[i] + candies;\\n    }\\n    return finalDistribution\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let finalDistribution = new Array(num_people).fill(0) // [0,0,0,0] //candies=7\\n    let candy =1;\\n    let i = 0;\\n    while(candy < candies){\\n        if(i===num_people) i=0\\n        finalDistribution[i] = finalDistribution[i]+candy;\\n        candies = candies - candy;\\n        candy++;\\n        i++;\\n    }\\n    if(candies > 0){\\n        if(i===num_people) i=0;\\n        finalDistribution[i] = finalDistribution[i] + candies;\\n    }\\n    return finalDistribution\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3773227,
                "title": "faster-than-100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801400,
                "title": "js-o-n-beats-95-easy-to-read",
                "content": "# Intuition\\nIterate over the total amount of candies.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function (c, n) {\\n  let j = 0;\\n  let left = c;\\n  const arr = [];\\n  for (let i = 0; i < n; i++) {\\n    arr[i] = 0;\\n  }\\n  for (let i = 1; i < c + 1; i++) {\\n    if (i > left) {\\n      arr[j] += left;\\n      break;\\n    }\\n    arr[j] += i;\\n    j++;\\n    if (j === n) {\\n      j = 0;\\n    }\\n    left -= i;\\n  }\\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function (c, n) {\\n  let j = 0;\\n  let left = c;\\n  const arr = [];\\n  for (let i = 0; i < n; i++) {\\n    arr[i] = 0;\\n  }\\n  for (let i = 1; i < c + 1; i++) {\\n    if (i > left) {\\n      arr[j] += left;\\n      break;\\n    }\\n    arr[j] += i;\\n    j++;\\n    if (j === n) {\\n      j = 0;\\n    }\\n    left -= i;\\n  }\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652771,
                "title": "c-super-easy-faster-than-100",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> distributeCandies(int candies, int len) {\\n        int i=0;\\n        int a=1;\\n        vector<int>ans(len,0);\\n       while(1){  \\n           if(candies<a){\\n               ans[i]+=candies;\\n               break;\\n           } \\n           ans[i]+=a;\\n           candies-=a;\\n           i=(i+1)%len;\\n           a++;\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> distributeCandies(int candies, int len) {\\n        int i=0;\\n        int a=1;\\n        vector<int>ans(len,0);\\n       while(1){  \\n           if(candies<a){\\n               ans[i]+=candies;\\n               break;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2641832,
                "title": "js-very-easy-solution",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    const output = new Array(num_people).fill(0);\\n    let cursor = 0;\\n    let count = 1;\\n    \\n    while (candies > 0) {\\n        output[cursor] += (count <= candies ? count : candies);\\n        candies -= count;\\n        count++;\\n        cursor++;\\n        if (cursor === num_people) {\\n            cursor = 0;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    const output = new Array(num_people).fill(0);\\n    let cursor = 0;\\n    let count = 1;\\n    \\n    while (candies > 0) {\\n        output[cursor] += (count <= candies ? count : candies);\\n        candies -= count;\\n        count++;\\n        cursor++;\\n        if (cursor === num_people) {\\n            cursor = 0;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2501941,
                "title": "java-easy-code",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int ans[]=new int[num_people];\\n        int ix=0, gift=1;\\n        while(candies>0){\\n            ix=ix%num_people;\\n            if(gift<=candies){\\n                ans[ix]+=gift;\\n            }else{\\n                ans[ix]+=candies;\\n            }\\n            candies-=gift;\\n            ix++;\\n            gift++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int ans[]=new int[num_people];\\n        int ix=0, gift=1;\\n        while(candies>0){\\n            ix=ix%num_people;\\n            if(gift<=candies){\\n                ans[ix]+=gift;\\n            }else{\\n                ans[ix]+=candies;\\n            }\\n            candies-=gift;\\n            ix++;\\n            gift++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440921,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int n) {\\n\\n\\t\\t\\tvector<int> ans(n, 0);\\n\\n\\t\\t\\tint i = 0, x = 1;\\n\\t\\t\\twhile(candies != 0){\\n\\n\\t\\t\\t\\tif(candies < x){\\n\\t\\t\\t\\t\\tans[i % n] += candies;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i % n] += x;\\n\\t\\t\\t\\tcandies -= x;\\n\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int n) {\\n\\n\\t\\t\\tvector<int> ans(n, 0);\\n\\n\\t\\t\\tint i = 0, x = 1;\\n\\t\\t\\twhile(candies != 0){\\n\\n\\t\\t\\t\\tif(candies < x){\\n\\t\\t\\t\\t\\tans[i % n] += candies;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 985041,
                "title": "python-3-solution-28-36ms",
                "content": "The idea is that:\\n\\nthe candies are distributed as `1,2,3,4,...,n, candies-(n+1)*n/2`, thus we just need to find `n`. Then the problem is easy to deal with.\\n\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        #\\n        res = [0]*num_people\\n        n = int(-1/2+sqrt(4*2*candies+1)/2)  # find n by Vieta\\'s formulas\\n        turns = n//num_people\\n        flattern = list(range(1,n+1))+[candies-n*(n+1)//2]\\n        flattern += (-len(flattern)+(turns+1)*num_people)*[0]\\n        for i in range(turns+1):\\n            res = [m+n for m,n in zip(res,flattern[i*num_people:(i+1)*num_people])]\\n        return res\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        #\\n        res = [0]*num_people\\n        n = int(-1/2+sqrt(4*2*candies+1)/2)  # find n by Vieta\\'s formulas\\n        turns = n//num_people\\n        flattern = list(range(1,n+1))+[candies-n*(n+1)//2]\\n        flattern += (-len(flattern)+(turns+1)*num_people)*[0]\\n        for i in range(turns+1):\\n            res = [m+n for m,n in zip(res,flattern[i*num_people:(i+1)*num_people])]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797425,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        results=[0]*num_people \\n        give=0\\n        totalCandiesGiven=0\\n        left=candies-totalCandiesGiven\\n        \\n        while totalCandiesGiven<candies: \\n\\n            for i in range(len(results)): \\n                \\n                left=candies-totalCandiesGiven    \\n                give+=1\\n                \\n                results[i]= results[i]+give if left>=give else results[i]+left\\n                \\n\\n                totalCandiesGiven+=give\\n                \\n                if totalCandiesGiven>=candies:\\n                    break\\n                \\n                \\n        return results        \\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        results=[0]*num_people \\n        give=0\\n        totalCandiesGiven=0\\n        left=candies-totalCandiesGiven\\n        \\n        while totalCandiesGiven<candies: \\n\\n            for i in range(len(results)): \\n                \\n                left=candies-totalCandiesGiven    \\n                give+=1\\n                \\n                results[i]= results[i]+give if left>=give else results[i]+left\\n                \\n\\n                totalCandiesGiven+=give\\n                \\n                if totalCandiesGiven>=candies:\\n                    break\\n                \\n                \\n        return results        \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 796845,
                "title": "distribute-candies-java-o-candies",
                "content": "```\\nclass Solution {\\n\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        int i = 0,j = 1;\\n        while( candies > 0 ){\\n            res[i%n] += j<candies?j:candies;\\n            candies -= j;\\n            j++; i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        int i = 0,j = 1;\\n        while( candies > 0 ){\\n            res[i%n] += j<candies?j:candies;\\n            candies -= j;\\n            j++; i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796821,
                "title": "beating-100-simple-c-solution-p",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        int i=1;\\n        while(candies -i>0 && ans.size()<num_people){\\n            ans.push_back(i);\\n            candies-=i;\\n            i++;\\n        }\\n        while(ans.size()<num_people){\\n            ans.push_back(candies);\\n            candies=0;\\n        }\\n        if(candies==0) return ans;\\n        int j=num_people+1;\\n        int k=0;\\n        while(candies>0){\\n            k=k% num_people;\\n            if(candies>j){\\n                ans[k]+=j;\\n                candies-=j;\\n            }\\n            else{\\n                ans[k]+=candies;\\n                break;\\n            }\\n            k++;\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        int i=1;\\n        while(candies -i>0 && ans.size()<num_people){\\n            ans.push_back(i);\\n            candies-=i;\\n            i++;\\n        }\\n        while(ans.size()<num_people){\\n            ans.push_back(candies);\\n            candies=0;\\n        }\\n        if(candies==0) return ans;\\n        int j=num_people+1;\\n        int k=0;\\n        while(candies>0){\\n            k=k% num_people;\\n            if(candies>j){\\n                ans[k]+=j;\\n                candies-=j;\\n            }\\n            else{\\n                ans[k]+=candies;\\n                break;\\n            }\\n            k++;\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796777,
                "title": "typescript-solutions",
                "content": "// Runtime: 76 ms, faster than 48.28% of JavaScript online submissions for Distribute Candies to People.\\n// Memory Usage: 36.6 MB, less than 34.48% of JavaScript online submissions for Distribute Candies to People.\\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const res: number[] = new Array(num_people).fill(0);\\n  let i = 1;\\n  while (candies > 0) {\\n    res[(i - 1) % num_people] += Math.min(i, candies);\\n    candies -= i;\\n    i++;\\n  }\\n  return res;\\n}\\n```\\n\\n// Generating an array with the distributions\\n// Runtime: 72 ms, faster than 68.10% of JavaScript online submissions for Distribute Candies to People.\\n// Memory Usage: 38.1 MB, less than 5.17% of JavaScript online submissions for Distribute Candies to People.\\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const distributions: number[] = [];\\n  let x = 1;\\n  while (candies > 0) {\\n    if (candies >= x) {\\n      candies -= x;\\n      distributions.push(x);\\n    } else {\\n      distributions.push(candies);\\n      candies = 0;\\n    }\\n    x++;\\n  }\\n\\n  const res = new Array(num_people).fill(0);\\n\\n  for (let i = 0; i < num_people; i++) {\\n    for (let j = i; j < distributions.length; j += num_people) {\\n      res[i] += distributions[j];\\n    }\\n  }\\n\\n  return res;\\n}\\n```\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const res: number[] = new Array(num_people).fill(0);\\n  let i = 1;\\n  while (candies > 0) {\\n    res[(i - 1) % num_people] += Math.min(i, candies);\\n    candies -= i;\\n    i++;\\n  }\\n  return res;\\n}\\n```\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const distributions: number[] = [];\\n  let x = 1;\\n  while (candies > 0) {\\n    if (candies >= x) {\\n      candies -= x;\\n      distributions.push(x);\\n    } else {\\n      distributions.push(candies);\\n      candies = 0;\\n    }\\n    x++;\\n  }\\n\\n  const res = new Array(num_people).fill(0);\\n\\n  for (let i = 0; i < num_people; i++) {\\n    for (let j = i; j < distributions.length; j += num_people) {\\n      res[i] += distributions[j];\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796562,
                "title": "java-think-like-a-human-easy-to-understand-with-explanation-pseudocode",
                "content": "## Analysis\\nThe basic idea is, every time, the number of candies we should distribute is incremented by 1. If we have enough candies, just give him the number he deserved. However, when we give him all we left. \\n\\nIt\\'s simply the same as what we human  deal with this prob.\\n## Explanation\\n- When we have adequate candies to distribute (in the while-loop)\\n\\t- Distribute normally\\n\\t\\t- `thisPpl` gets `thisPplGet` candies\\n\\t\\t- Find out how many candies were distributed in total\\n\\t\\t- Next people = `nextPpl()`\\n\\t\\t- Increment `thisPplGet` by 1\\n- If we don\\'t have enough candies fot `thisPpl`\\n\\t- Give him all we left, aka `candies - curDistributedTotal` candies\\n\\n```Java\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int curDistributedTotal = 0;\\n        int thisPplGet = 1;\\n        int thisPpl = 0;\\n        while(candies - curDistributedTotal >= thisPplGet) {\\n            res[thisPpl] += thisPplGet;\\n            curDistributedTotal += thisPplGet;\\n            thisPpl = nextPpl(num_people, thisPpl);\\n            thisPplGet += 1;\\n        }\\n        res[thisPpl] += candies - curDistributedTotal;\\n        return res;\\n    }\\n    \\n    private static int nextPpl(int num_people, int thisPpl) {\\n        if (thisPpl == num_people - 1) return 0;\\n        return thisPpl + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int curDistributedTotal = 0;\\n        int thisPplGet = 1;\\n        int thisPpl = 0;\\n        while(candies - curDistributedTotal >= thisPplGet) {\\n            res[thisPpl] += thisPplGet;\\n            curDistributedTotal += thisPplGet;\\n            thisPpl = nextPpl(num_people, thisPpl);\\n            thisPplGet += 1;\\n        }\\n        res[thisPpl] += candies - curDistributedTotal;\\n        return res;\\n    }\\n    \\n    private static int nextPpl(int num_people, int thisPpl) {\\n        if (thisPpl == num_people - 1) return 0;\\n        return thisPpl + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796485,
                "title": "c-simple-clear-solution-100-faster-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) \\n    {\\n        vector<int> candiesDistributed(num_people, 0);\\n        int i = 0;\\n        \\n        //while there are still candies to give out\\n        while (candies > 0) \\n        {\\n            //give every person according to his turn (incremented by one every turn)\\n            candiesDistributed[i % num_people] += i + 1;\\n            //update number of candies left\\n            candies -= i + 1;\\n            i++;\\n        }\\n        \\n        //incase we gave an extra candy to last person (so if there are less than 0 candies left we decrement last person\\'s candies otherwise candies = 0 so nothing changes)\\n        candiesDistributed[(i - 1) % num_people] += candies;\\n        \\n        \\n        return candiesDistributed;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) \\n    {\\n        vector<int> candiesDistributed(num_people, 0);\\n        int i = 0;\\n        \\n        //while there are still candies to give out\\n        while (candies > 0) \\n        {\\n            //give every person according to his turn (incremented by one every turn)\\n            candiesDistributed[i % num_people] += i + 1;\\n            //update number of candies left\\n            candies -= i + 1;\\n            i++;\\n        }\\n        \\n        //incase we gave an extra candy to last person (so if there are less than 0 candies left we decrement last person\\'s candies otherwise candies = 0 so nothing changes)\\n        candiesDistributed[(i - 1) % num_people] += candies;\\n        \\n        \\n        return candiesDistributed;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796407,
                "title": "java-1ms-exactly-as-defined-in-problem-statement",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int count = candies;\\n        int[] result = new int[num_people];\\n        int index = 0;\\n        int i = 1;\\n        while(count != 0){\\n            if(i > count){\\n                result[index] += count;\\n                count = 0;\\n            } else{\\n                result[index] += i;\\n                count -= i;\\n            }\\n            \\n            ++i;\\n            index = (index + 1) % num_people;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int count = candies;\\n        int[] result = new int[num_people];\\n        int index = 0;\\n        int i = 1;\\n        while(count != 0){\\n            if(i > count){\\n                result[index] += count;\\n                count = 0;\\n            } else{\\n                result[index] += i;\\n                count -= i;\\n            }\\n            \\n            ++i;\\n            index = (index + 1) % num_people;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752712,
                "title": "c-100-fast",
                "content": "```\\n vector<int> v(num_people,0);\\n        int i=0;\\n        \\n        while(candies  > 0){\\n            \\n            v[i%num_people] += min(candies , i+1);\\n            candies -= i+1;\\n                \\n            i++;\\n        }\\n        \\n        return v;\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n vector<int> v(num_people,0);\\n        int i=0;\\n        \\n        while(candies  > 0){\\n            \\n            v[i%num_people] += min(candies , i+1);\\n            candies -= i+1;\\n                \\n            i++;\\n        }\\n        \\n        return v;\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 749184,
                "title": "java-0ms-beats-100-math-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int sum = (num_people + 1) * num_people / 2;\\n        int k = -1;\\n        int consume = 0;\\n        while (consume < candies) {\\n            k += 1;\\n            consume += k * num_people * num_people + sum;\\n        }\\n        k -= 1;\\n        int[] res = new int[num_people];\\n        int total_candies = candies;\\n        for (int i=1; i<=num_people; i++) {\\n            res[i-1] = (k + 1) * i + k * (k + 1) * num_people / 2;\\n            total_candies -= res[i-1];\\n        }\\n        int idx = 0;\\n        while (total_candies > 0) {\\n            int got = Math.min((k + 1) * num_people + idx + 1, total_candies);\\n            res[idx] += got;\\n            total_candies -= got;\\n            idx ++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nExplanation here:\\nSuppose we can write down the distribution in every round (number n people from 1 to n):\\n```\\n(P for person)\\nP1         P2        P3  ...  Pn\\n-----------------------------------\\n  1         2         3  ...   n\\nn+1       n+2       n+3      n+n\\n2n+1     2n+2      2n+3     2n+n\\n...\\nkn+1     kn+2      kn+3     kn+n\\n(k+1)n +1 ...  (k+1)n +j\\n```\\nHere `k` is the second last round, and we end in `k+1`th round at position `j` (j <= n).\\nSo How many candies does the 1st position get?\\nIt\\'s :\\n```\\nin previous round 0~k\\n(1) + (n + 1) + (2n+1) + ... (kn+1) \\n= (1 + n + 1 + 2n+1 + ... kn+1) \\n= k*(k+1)/2 *n + n * 1\\n\\ndon\\'t forget the last round, it\\'s:\\n(k+1)n +1\\n``` \\nFor other positions you can get similar results. And also you can calculate how many candies you need in each round, it\\'s:\\n```\\n(kn+1) + (kn+2) + ... (kn+n)\\n= k*n*n + (1 + 2 + .. n)\\n= k*n*n+n*(n+1)/2\\n```\\nfor round `k`.\\n\\nThen you can find `k`.\\nSo basically that\\'s all, I found `k` in my code at beginning. After that, I first add all round `0~k` in one loop and add the last round finally.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int sum = (num_people + 1) * num_people / 2;\\n        int k = -1;\\n        int consume = 0;\\n        while (consume < candies) {\\n            k += 1;\\n            consume += k * num_people * num_people + sum;\\n        }\\n        k -= 1;\\n        int[] res = new int[num_people];\\n        int total_candies = candies;\\n        for (int i=1; i<=num_people; i++) {\\n            res[i-1] = (k + 1) * i + k * (k + 1) * num_people / 2;\\n            total_candies -= res[i-1];\\n        }\\n        int idx = 0;\\n        while (total_candies > 0) {\\n            int got = Math.min((k + 1) * num_people + idx + 1, total_candies);\\n            res[idx] += got;\\n            total_candies -= got;\\n            idx ++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n(P for person)\\nP1         P2        P3  ...  Pn\\n-----------------------------------\\n  1         2         3  ...   n\\nn+1       n+2       n+3      n+n\\n2n+1     2n+2      2n+3     2n+n\\n...\\nkn+1     kn+2      kn+3     kn+n\\n(k+1)n +1 ...  (k+1)n +j\\n```\n```\\nin previous round 0~k\\n(1) + (n + 1) + (2n+1) + ... (kn+1) \\n= (1 + n + 1 + 2n+1 + ... kn+1) \\n= k*(k+1)/2 *n + n * 1\\n\\ndon\\'t forget the last round, it\\'s:\\n(k+1)n +1\\n```\n```\\n(kn+1) + (kn+2) + ... (kn+n)\\n= k*n*n + (1 + 2 + .. n)\\n= k*n*n+n*(n+1)/2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712708,
                "title": "java-clean-code-solution-1-ms-time-90-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int[] distributeCandies (int candies, int num_people) {\\n \\n\\t\\tint[] ans = new int[num_people];\\n\\t\\t\\n\\t\\tfor (int i = 0, k = 0; candies != 0; i++) {\\n\\t\\t\\tif (k >= candies) {\\n\\t\\t\\t\\tans[i % num_people] += candies;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans[i % num_people] += ++k;\\n\\t\\t\\tcandies -= k;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n \\nTime Complexity: O(N) \\nwhere N = Number of Candies\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int[] distributeCandies (int candies, int num_people) {\\n \\n\\t\\tint[] ans = new int[num_people];\\n\\t\\t\\n\\t\\tfor (int i = 0, k = 0; candies != 0; i++) {\\n\\t\\t\\tif (k >= candies) {\\n\\t\\t\\t\\tans[i % num_people] += candies;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans[i % num_people] += ++k;\\n\\t\\t\\tcandies -= k;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n \\nTime Complexity: O(N) \\nwhere N = Number of Candies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527087,
                "title": "java",
                "content": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        \\n        int turn = 1;\\n        int index = 0;\\n        while(candies != 0)\\n        {\\n            int candiesToGive = Math.min(candies,turn++);\\n            res[index++%num_people] += candiesToGive;\\n            candies -= candiesToGive;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        \\n        int turn = 1;\\n        int index = 0;\\n        while(candies != 0)\\n        {\\n            int candiesToGive = Math.min(candies,turn++);\\n            res[index++%num_people] += candiesToGive;\\n            candies -= candiesToGive;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 502605,
                "title": "javascript-solution-48ms",
                "content": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n  let arr = new Array(num_people).fill(0);\\n  let countCycle = 0;\\n\\n  for (let i = 0; candies > 0; i++) {\\n    if (i === arr.length) {\\n      i = 0;\\n      countCycle += arr.length;\\n    }\\n    \\n    if (candies < (i + 1) + countCycle) {\\n      arr[i] += candies;\\n      break;\\n    }\\n    \\n    arr[i] += i + 1 + countCycle;\\n    candies -= (i + 1 + countCycle);\\n  }\\n  \\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n  let arr = new Array(num_people).fill(0);\\n  let countCycle = 0;\\n\\n  for (let i = 0; candies > 0; i++) {\\n    if (i === arr.length) {\\n      i = 0;\\n      countCycle += arr.length;\\n    }\\n    \\n    if (candies < (i + 1) + countCycle) {\\n      arr[i] += candies;\\n      break;\\n    }\\n    \\n    arr[i] += i + 1 + countCycle;\\n    candies -= (i + 1 + countCycle);\\n  }\\n  \\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 439535,
                "title": "java-mathematical-solution-beats-100-time-and-100-space",
                "content": "The initial while loop in the code can be avoided by solving a quadratic equation which will give you the number of rows where all the n people can get candies.\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[] ans = new int[n];\\n        int i = 0;\\n        int sum = 0;\\n        \\n        while(true){\\n            int t = ((int)Math.pow(n, 2) * i) + (n * (n + 1))/2;\\n            if(sum + t > candies) break;\\n            sum += t;\\n            i++;\\n        }\\n        \\n        i--;\\n        \\n        for(int j = 0; j < n; j++){\\n            ans[j] = (i + 1) * (j + 1) + (i * n * (i + 1))/2; \\n        }\\n        \\n        i++;\\n        \\n        candies -= sum;\\n        int start = n * i + 1;\\n        int j = 0;\\n        while(candies >= start){\\n            ans[j] += start;\\n            candies -= start;\\n            start++;\\n            j++;\\n        }\\n        \\n        if(candies > 0) ans[j] += candies;\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[] ans = new int[n];\\n        int i = 0;\\n        int sum = 0;\\n        \\n        while(true){\\n            int t = ((int)Math.pow(n, 2) * i) + (n * (n + 1))/2;\\n            if(sum + t > candies) break;\\n            sum += t;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 435169,
                "title": "java-0ms-100-solution-with-comments",
                "content": "Lets say we have x people, then distribution will look like:\\n1         2         3         4          ... x            total amount of candies is sum from 1 to x\\n1 + x   2 + x   3 + x   4 + x   ... x + x     \\n1 + 2x 2 + 2x 3 + 2x 4 + 2x ... x + 2x\\neach next round we are giving same amount of candies, from 1 to x, but + amount of candies we gave to last person in previous round, which is x for 1st round, which is equal to people amount. So we are giving addiotionally num_people candies num_people times comparing to previous round. It means we can cound how many candies we will distribute during full rounds!\\n\\n```class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] result = new int[num_people];\\n        int amount = num_people * (num_people + 1) / 2; // sum from 1 to num_people, amount of candies for 1st round\\n        int rounds = 0;\\n        //counting rounds and amount of candies which left after all full rounds\\n        while(candies >= amount) {\\n            rounds++;\\n            candies -= amount;\\n            amount += num_people * num_people; //increase amount of candies, required for next round\\n        }\\n        \\n        for(int i = 0; i < num_people; i++) {\\n\\t\\t\\t//counting amount of candies, distributed to i-th person during full rounds. Lets say we have 4 rounds for 4 people. \\n\\t\\t\\t//1st will get 1 + 5 + 9 + 13, 2nd 2 + 6 + 10 + 14 and so on.\\n\\t\\t\\t//So its sum of N (which is rounds amount) numbers, statring from person number (i + 1) with step = num_people\\n\\t\\t\\t//Formula is  (2 * 1st + step * (N - 1) ) * N / 2\\n            result[i] = (2 * i + 2 + num_people * (rounds - 1)) * rounds / 2; \\n\\t\\t\\t\\n\\t\\t\\t//if we have more candies - counting how many we need to give to current person and taking this amount from candies \\n\\t\\t\\t//or all candies if we have not enough left\\n            if(candies > 0) {\\n                int n = 1 + i + num_people * rounds;\\n                n = candies < n ? candies : n;\\n                result[i] += n;\\n                candies -= n;\\n            }\\n        }\\n        return result;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] result = new int[num_people];\\n        int amount = num_people * (num_people + 1) / 2; // sum from 1 to num_people, amount of candies for 1st round\\n        int rounds = 0;\\n        //counting rounds and amount of candies which left after all full rounds\\n        while(candies >= amount) {\\n            rounds++;\\n            candies -= amount;\\n            amount += num_people * num_people; //increase amount of candies, required for next round\\n        }\\n        \\n        for(int i = 0; i < num_people; i++) {\\n\\t\\t\\t//counting amount of candies, distributed to i-th person during full rounds. Lets say we have 4 rounds for 4 people. \\n\\t\\t\\t//1st will get 1 + 5 + 9 + 13, 2nd 2 + 6 + 10 + 14 and so on.\\n\\t\\t\\t//So its sum of N (which is rounds amount) numbers, statring from person number (i + 1) with step = num_people\\n\\t\\t\\t//Formula is  (2 * 1st + step * (N - 1) ) * N / 2\\n            result[i] = (2 * i + 2 + num_people * (rounds - 1)) * rounds / 2; \\n\\t\\t\\t\\n\\t\\t\\t//if we have more candies - counting how many we need to give to current person and taking this amount from candies \\n\\t\\t\\t//or all candies if we have not enough left\\n            if(candies > 0) {\\n                int n = 1 + i + num_people * rounds;\\n                n = candies < n ? candies : n;\\n                result[i] += n;\\n                candies -= n;\\n            }\\n        }\\n        return result;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 431245,
                "title": "python3-simple-solution-no-modulo-beats-91",
                "content": "```class Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = num_people * [0]\\n        index = 0\\n        increment = 0\\n        \\n        while candies > 0:\\n            take_away = min(candies, increment + 1)\\n            \\n            distribution[index] += take_away\\n            \\n            candies -= take_away\\n            increment += 1\\n            index += 1\\n            \\n            if index == num_people:\\n                index = 0\\n        \\n        return distribution\\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = num_people * [0]\\n        index = 0\\n        increment = 0\\n        \\n        while candies > 0:\\n            take_away = min(candies, increment + 1)\\n            \\n            distribution[index] += take_away\\n            \\n            candies -= take_away\\n            increment += 1\\n            index += 1\\n            \\n            if index == num_people:\\n                index = 0\\n        \\n        return distribution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416033,
                "title": "python3-3-solution-3-lines-99-16",
                "content": "**Method 1** A simulation-based solution is as below (21.55%), in which we assign candies to people according to the rule given by the problem and stop when we run out of candies. \\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans = [0]*num_people\\n        i = 0\\n        while candies > 0: \\n            i += 1\\n            ans[(i-1)%num_people] += min(i, candies)\\n            candies -= i\\n        return ans \\n```\\n**Method 2** The above simulation can be implemented in a more Pythonic fashion (3-line & 99.16%)\\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        n = int(0.5*(-1 + sqrt(1 + 8*candies)))\\n        numbers = list(range(1, n+1)) + [candies - n*(n+1)//2]\\n        return [sum(numbers[i::num_people]) for i in range(num_people)]\\n```\\n**Method 3** Mathematics (95.99%). Given number of candies and people, one can compute mathematically how many candies are assigned to each people. \\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        k = int(0.5*(-1 + sqrt(1 + 8*candies))) #length of arithmetic series\\n        m, n = divmod(k, num_people)\\n        \\n        ans = [0]*num_people \\n        for i in range(num_people):\\n            if i == n: m -= 1\\n            ans[i] = (m+1)*(i+1) + m*(m+1)*num_people//2\\n        ans[n] += candies - k*(k+1)//2\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans = [0]*num_people\\n        i = 0\\n        while candies > 0: \\n            i += 1\\n            ans[(i-1)%num_people] += min(i, candies)\\n            candies -= i\\n        return ans \\n```\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        n = int(0.5*(-1 + sqrt(1 + 8*candies)))\\n        numbers = list(range(1, n+1)) + [candies - n*(n+1)//2]\\n        return [sum(numbers[i::num_people]) for i in range(num_people)]\\n```\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        k = int(0.5*(-1 + sqrt(1 + 8*candies))) #length of arithmetic series\\n        m, n = divmod(k, num_people)\\n        \\n        ans = [0]*num_people \\n        for i in range(num_people):\\n            if i == n: m -= 1\\n            ans[i] = (m+1)*(i+1) + m*(m+1)*num_people//2\\n        ans[n] += candies - k*(k+1)//2\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 326992,
                "title": "golang-simple-solution-with-self-explanation-beat-100",
                "content": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tvar res []int = make([]int,num_people)\\n\\tvar cnt int = 1\\n\\tfor candies > cnt{\\n\\t\\tres[(cnt - 1) % num_people] += cnt\\n\\t\\tcandies -= cnt\\n\\t\\tcnt++\\n\\t}\\n\\tres[(cnt - 1) % num_people] += candies\\n\\treturn res\\n}",
                "solutionTags": [],
                "code": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tvar res []int = make([]int,num_people)\\n\\tvar cnt int = 1\\n\\tfor candies > cnt{\\n\\t\\tres[(cnt - 1) % num_people] += cnt\\n\\t\\tcandies -= cnt\\n\\t\\tcnt++\\n\\t}\\n\\tres[(cnt - 1) % num_people] += candies\\n\\treturn res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 325281,
                "title": "python-8-20ms-math-with-explanation",
                "content": "For each **full round**, we give candies to every person, it consumes:\\nn(n+1)/2 + 0nn *for the 1st round*\\nn(n+1)/2 + 1nn *for the 2nd round*\\nn(n+1)/2 + 2nn *for the 3rd round*\\n...\\nWe first count that for the given candies, how many **full rounds** we can do.\\nThen we do all the **full rounds** at one time:\\nFor the person with index i, it consumes:\\n(i+1 + 0) + (i+1 + n) + ... + (i+1+ (k-1)n) = (i+1)k + k(k-1)n/2\\n\\nAfter this, the candies left are not enough to do another **full round**. Then, we enter the new round with the first person receiving 1 + kn candies.\\nFrom here, we just distribute  i+1 + kn candies to person with index i when we have enough candies.\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        k, s, res = 0, 0, [0 for x in range(n)]\\n\\t\\t# count how many full rounds we can do\\n        while s + n*(n+1)/2 + k*n*n < candies:\\n            s += n*(n+1)/2 + k*n*n\\n            k += 1\\n\\t\\t# do all full rounds at one time\\n        if k > 0:\\n            for i in range(len(res)):\\n                res[i] = (i+1)*k + k*(k-1)*n/2\\n                candies -= res[i]\\n        i = 0\\n\\t\\t# distribute the candies left\\n        while candies > 0:\\n            if candies > i+1 + k*n:\\n                res[i] += i+1 + k*n\\n                candies -= i+1 + k*n\\n            else:\\n                res[i] += candies\\n                break\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        k, s, res = 0, 0, [0 for x in range(n)]\\n\\t\\t# count how many full rounds we can do\\n        while s + n*(n+1)/2 + k*n*n < candies:\\n            s += n*(n+1)/2 + k*n*n\\n            k += 1\\n\\t\\t# do all full rounds at one time\\n        if k > 0:\\n            for i in range(len(res)):\\n                res[i] = (i+1)*k + k*(k-1)*n/2\\n                candies -= res[i]\\n        i = 0\\n\\t\\t# distribute the candies left\\n        while candies > 0:\\n            if candies > i+1 + k*n:\\n                res[i] += i+1 + k*n\\n                candies -= i+1 + k*n\\n            else:\\n                res[i] += candies\\n                break\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324809,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[]res=new int[num_people];\\n        int c=1;\\n        while (candies>0){\\n            for (int i=0;i<num_people;i++)\\n            {\\n                if (candies<c){\\n                    res[i]+=candies;\\n                    return res;\\n                } else {\\n\\t\\t\\t\\t\\tres[i]+=candies>c?c:candies;\\n\\t\\t\\t\\t\\tcandies-=c;\\n\\t\\t\\t\\t\\tc++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[]res=new int[num_people];\\n        int c=1;\\n        while (candies>0){\\n            for (int i=0;i<num_people;i++)\\n            {\\n                if (candies<c){\\n                    res[i]+=candies;\\n                    return res;\\n                } else {\\n\\t\\t\\t\\t\\tres[i]+=candies>c?c:candies;\\n\\t\\t\\t\\t\\tcandies-=c;\\n\\t\\t\\t\\t\\tc++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324250,
                "title": "fastest-math-solution-in-python-o-num-people",
                "content": "1. Find the smallest `n` such that `n * (n + 1) / 2 >= candles`\\n2. Find how many rounds we need to loop through num_people\\n3. Find out what\\'s the last index to fill\\n4. Fill into the result array according to the rounds and start index\\n\\nReference: https://en.wikipedia.org/wiki/Arithmetic_progression#Sum\\n\\n```\\ndef distributeCandies(self, candies, num_people):\\n        res = [0] * num_people\\n\\t\\t\\n\\t\\t# Find the smallest n\\n        n = math.floor(math.sqrt(candies * 2))\\n        if n * (n + 1) < candies * 2:\\n            n += 1\\n\\t\\t\\n\\t\\t# How many rounds we need to loop through num_people\\n        if n % num_people == 0:\\n            rounds = n // num_people \\n        else:\\n            rounds = n // num_people + 1\\n\\t\\t\\n\\t\\t# The last index to fill\\n        last = int(n % num_people - 1)\\n        edge = last\\n        if edge < 0:\\n            edge += num_people\\n\\t\\t\\n        for i in range(edge):\\n            res[i] = int((2*i + 2 + num_people * rounds - num_people) * rounds / 2\\n            candies -= res[i]\\n        for i in range(edge + 1, len(res)):\\n            res[i] = int((2*i + 2 + num_people * (rounds - 1) - num_people) * (rounds - 1) / 2)\\n            candies -= res[i]\\n        res[last] = candies\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef distributeCandies(self, candies, num_people):\\n        res = [0] * num_people\\n\\t\\t\\n\\t\\t# Find the smallest n\\n        n = math.floor(math.sqrt(candies * 2))\\n        if n * (n + 1) < candies * 2:\\n            n += 1\\n\\t\\t\\n\\t\\t# How many rounds we need to loop through num_people\\n        if n % num_people == 0:\\n            rounds = n // num_people \\n        else:\\n            rounds = n // num_people + 1\\n\\t\\t\\n\\t\\t# The last index to fill\\n        last = int(n % num_people - 1)\\n        edge = last\\n        if edge < 0:\\n            edge += num_people\\n\\t\\t\\n        for i in range(edge):\\n            res[i] = int((2*i + 2 + num_people * rounds - num_people) * rounds / 2\\n            candies -= res[i]\\n        for i in range(edge + 1, len(res)):\\n            res[i] = int((2*i + 2 + num_people * (rounds - 1) - num_people) * (rounds - 1) / 2)\\n            candies -= res[i]\\n        res[last] = candies\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323409,
                "title": "javascript-python3-c-brute-force",
                "content": "**Synopsis:**\\n\\nLet `candy` be a monotonically increasing value, starting at `1` which denotes the maximum amount of candies we can currently take.  Take `candy` until all `k` candies have been exhausted.\\n\\n---\\n\\n*Javascript*\\n```\\nlet distributeCandies = (k, N, candy = 0) => {\\n    let ans = Array(N).fill(0);\\n    while (k) {\\n        for (let i = 0; i < N; ++i) {\\n            let take = Math.min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n            ans[i] += take, k -= take;\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def distributeCandies(self, k: int, N: int, candy = 1) -> List[int]:\\n        ans = [0] * N\\n        while k:\\n            for i in range(N):\\n                take = min(candy, k)  # \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take\\n                k -= take\\n                candy += 1\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector< int >;\\n    VI distributeCandies(int k, int N, int candy = 0){\\n        VI ans(N);\\n        while (k) {\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto take = min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take, k -= take;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet distributeCandies = (k, N, candy = 0) => {\\n    let ans = Array(N).fill(0);\\n    while (k) {\\n        for (let i = 0; i < N; ++i) {\\n            let take = Math.min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n            ans[i] += take, k -= take;\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def distributeCandies(self, k: int, N: int, candy = 1) -> List[int]:\\n        ans = [0] * N\\n        while k:\\n            for i in range(N):\\n                take = min(candy, k)  # \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take\\n                k -= take\\n                candy += 1\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector< int >;\\n    VI distributeCandies(int k, int N, int candy = 0){\\n        VI ans(N);\\n        while (k) {\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto take = min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take, k -= take;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323313,
                "title": "c-brute-force-just-as-the-logic-asks-for-it",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n, 0);\\n        int loop = 0; //use a loop variable to track the number of times it comes back to start\\n        while(candies > 0){\\n            for(int i=0; i<n; i++){\\n                int toGive = i+1 + loop*n;\\n                if(candies < toGive){\\n\\t\\t\\t\\t\\t// if not enough candies left then assign all of them to current person\\n                    res[i] += candies;\\n                    candies = 0;\\n                    break;\\n                }else{\\n                    res[i] += toGive;\\n                    candies -= toGive;\\n                }\\n            }\\n            loop++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n, 0);\\n        int loop = 0; //use a loop variable to track the number of times it comes back to start\\n        while(candies > 0){\\n            for(int i=0; i<n; i++){\\n                int toGive = i+1 + loop*n;\\n                if(candies < toGive){\\n\\t\\t\\t\\t\\t// if not enough candies left then assign all of them to current person\\n                    res[i] += candies;\\n                    candies = 0;\\n                    break;\\n                }else{\\n                    res[i] += toGive;\\n                    candies -= toGive;\\n                }\\n            }\\n            loop++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773226,
                "title": "faster-than-100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439758,
                "title": "c-for-dumbs-100-faster",
                "content": "\\n\\n# Approach\\nInitially the program only wants to give some candy to each person, the website would inform the number of candiess to distribute and the number of people.\\n\\nIn the initial distribution the first person should receive only one candy, the second person should receive one more than the first one and after all the people have earned the candies, it would start another distribution loop in the same way until there is no more candies.\\n\\nThe last person would only receive all the candy avaliable in case there is no candy necessary to fulfill the formula. **n+1**\\n\\nin my solution the distributions will happen until there is no more candies\\n```\\nwhile(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n```\\n**y** represents the number of candies to each pearson that would increase aways by one, in this way the number of candies will always  decrease too by **y** to analyse how many candies remain. And if there is no more candies to fulfill the formula, the last person will receive all the rest of the candies.\\n\\n**res**[0] represents the number of candies that the first person would receive and candies represents the total of cadies that remain to be destributed.\\n\\n**If you like please upvote**\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#include <stdlib.h>\\n#include <stdio.h>\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\n    *returnSize = num_people;\\n    int x[num_people];\\n    int y = 1;\\n    int *res=(int*)calloc(num_people,sizeof(int));\\n    while(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n    }\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nwhile(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n```\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#include <stdlib.h>\\n#include <stdio.h>\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\n    *returnSize = num_people;\\n    int x[num_people];\\n    int y = 1;\\n    int *res=(int*)calloc(num_people,sizeof(int));\\n    while(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3159155,
                "title": "python3-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis,i=num_people*[0],1\\n        while candies>=i:\\n            lis[(i-1)%num_people]+=i\\n            candies-=i\\n            i+=1\\n        if candies>0:    \\n            lis[(i-1)%num_people]+=candies\\n        return lis\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis,i=num_people*[0],1\\n        while candies>=i:\\n            lis[(i-1)%num_people]+=i\\n            candies-=i\\n            i+=1\\n        if candies>0:    \\n            lis[(i-1)%num_people]+=candies\\n        return lis\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001605,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = [0 for i in range(num_people)]\\n        i = 0\\n        j = 1\\n        while candies > 0:\\n            if i == len(arr):\\n                i = 0\\n            if candies >= j:\\n                arr[i] += j\\n                candies -= j\\n                j += 1\\n            else:\\n                arr[i] += candies\\n                break\\n            i += 1\\n        return arr\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = [0 for i in range(num_people)]\\n        i = 0\\n        j = 1\\n        while candies > 0:\\n            if i == len(arr):\\n                i = 0\\n            if candies >= j:\\n                arr[i] += j\\n                candies -= j\\n                j += 1\\n            else:\\n                arr[i] += candies\\n                break\\n            i += 1\\n        return arr\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885846,
                "title": "java-runtime-1-ms-beats-97-31-memory-39-9-mb-beats-91-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] rs = new int[num_people];\\n        int index = 1;\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                if (candies == 0) break;\\n                index = candies > index ? index : candies;\\n                rs[i] += index;\\n                candies -= index++;\\n            }\\n        }\\n\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] rs = new int[num_people];\\n        int index = 1;\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                if (candies == 0) break;\\n                index = candies > index ? index : candies;\\n                rs[i] += index;\\n                candies -= index++;\\n            }\\n        }\\n\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848458,
                "title": "java-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838299,
                "title": "java-brute-force-solution-explained",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int c, int n) {\\n        int[] arr = new int[n];\\n        int idx = 0;\\n        while (c > 0) {\\n            //[idx++ % n] - means that I find index of array to add\\n            //and then increment this index\\n            //Math.min(idx, c) - is used because in the end when we have candies left less than we need to add, then just add minimum number\\n            arr[idx++ % n] += Math.min(idx, c);\\n\\n            //during loop we need to substract given number of candies\\n            //above from all number of candies left\\n            //if this number is negative, then just 0 left.\\n            c = Math.max(c - idx, 0);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int c, int n) {\\n        int[] arr = new int[n];\\n        int idx = 0;\\n        while (c > 0) {\\n            //[idx++ % n] - means that I find index of array to add\\n            //and then increment this index\\n            //Math.min(idx, c) - is used because in the end when we have candies left less than we need to add, then just add minimum number\\n            arr[idx++ % n] += Math.min(idx, c);\\n\\n            //during loop we need to substract given number of candies\\n            //above from all number of candies left\\n            //if this number is negative, then just 0 left.\\n            c = Math.max(c - idx, 0);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780239,
                "title": "java-98-beats-just-one-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int n, int num_people) {\\n        int[] nums = new int[num_people];\\n        int i=0;\\n        int givenCandies=0;\\n        int candies=1;\\n        while(true){\\n            if(i==num_people) i=0;\\n            if(givenCandies+candies<=n){\\n                nums[i++]+=candies++;\\n                givenCandies+=candies-1;\\n            }else{\\n                nums[i]+=n-givenCandies;\\n                break;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int n, int num_people) {\\n        int[] nums = new int[num_people];\\n        int i=0;\\n        int givenCandies=0;\\n        int candies=1;\\n        while(true){\\n            if(i==num_people) i=0;\\n            if(givenCandies+candies<=n){\\n                nums[i++]+=candies++;\\n                givenCandies+=candies-1;\\n            }else{\\n                nums[i]+=n-givenCandies;\\n                break;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378857,
                "title": "java-faster-than-98-users",
                "content": "```\\nint ans[]=new int[people];\\n        int curr=1;\\n        int rem=candies;\\n        while(rem>0){\\n            for(int i=0;i<people;i=(i+1)%people){\\n                if(rem<=curr){\\n                    ans[i]+=rem;\\n                    rem=0;\\n                    break;\\n                }\\n                else{\\n                    ans[i]+=curr;\\n                    rem=rem-curr;\\n                    curr++;\\n                }\\n            }\\n        }\\n        return ans;```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint ans[]=new int[people];\\n        int curr=1;\\n        int rem=candies;\\n        while(rem>0){\\n            for(int i=0;i<people;i=(i+1)%people){\\n                if(rem<=curr){\\n                    ans[i]+=rem;\\n                    rem=0;\\n                    break;\\n                }\\n                else{\\n                    ans[i]+=curr;\\n                    rem=rem-curr;\\n                    curr++;\\n                }\\n            }\\n        }\\n        return ans;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2217899,
                "title": "c-easy-problem",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int t, int np) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans(np,0);\\n\\t\\t\\tint i=1;\\n\\t\\t\\tfor(int j=0;j<np;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(t<=i)  \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans[j]+=t;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[j]+=i;\\n\\t\\t\\t\\tt-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(j==np-1) j=-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int t, int np) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans(np,0);\\n\\t\\t\\tint i=1;\\n\\t\\t\\tfor(int j=0;j<np;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(t<=i)  \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans[j]+=t;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2114146,
                "title": "easy-java-2ms",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] ans=new int[num_people];\\n        int k=0;\\n        while(candies>0){\\n            ans[k%num_people]+=Math.min(k+1,candies);\\n            candies-=Math.min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] ans=new int[num_people];\\n        int k=0;\\n        while(candies>0){\\n            ans[k%num_people]+=Math.min(k+1,candies);\\n            candies-=Math.min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098819,
                "title": "c-0ms-beats-100",
                "content": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>ans(num_people,0);\\n        int k=0;\\n        while(candies)\\n        {\\n            ans[k%num_people]+=min(k+1,candies);\\n                candies-=min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>ans(num_people,0);\\n        int k=0;\\n        while(candies)\\n        {\\n            ans[k%num_people]+=min(k+1,candies);\\n                candies-=min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081337,
                "title": "java-solution",
                "content": "```java \\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] a = new int[num_people];\\n        int i=0;\\n        int c=1;\\n        while(candies>0)\\n        {\\n            if(candies>=c)\\n            {\\n                candies-=c;\\n               a[i%a.length]+=c++;\\n            }\\n            else\\n            {\\n                a[i%a.length]+=candies;\\n                candies=0;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] a = new int[num_people];\\n        int i=0;\\n        int c=1;\\n        while(candies>0)\\n        {\\n            if(candies>=c)\\n            {\\n                candies-=c;\\n               a[i%a.length]+=c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1966144,
                "title": "easy-java-solution-95-faster-easy-understanding-approach",
                "content": "# JAVA Solution | 95% faster | Easy friendly understanding :)\\n1. While we have given less candies than the ones we had at the beginning (`while(total < candies){}`)\\n2. Use `count % num_people == 0` to determine the current index of the people.\\n3. Remeber to leave a like! ;) \\n\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];        //Initialize the array of people\\n        int toGiveCandie = 1, count = 0, total = 0;    \\n        while(total < candies){                 //While the total candies given is fewer than the candies we have...\\n            if(count % num_people == 0){        //This is to \\'reset\\' de counter to 0 when we reach the last person.\\n                count = 0;\\n            }\\n            if(total + toGiveCandie <= candies){  \\n                //If the number of candies we have already given plus the candies we are \\n                // going to give are less or equal than the total candies...\\n                res[count] += toGiveCandie;     //We add the candies to the array (give the candie to the person)\\n                total += toGiveCandie;          //We update the candies we have given\\n                toGiveCandie++;                 //To the next person we will give one more candie\\n            }else{\\n                //If we don\\'t have the enough candies, we just give the candies left\\n                res[count] += candies-total;    \\n                total += candies-total;\\n                toGiveCandie++;\\n            }\\n            count++;\\n        }\\n        return res;                            //We return the filled array\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];        //Initialize the array of people\\n        int toGiveCandie = 1, count = 0, total = 0;    \\n        while(total < candies){                 //While the total candies given is fewer than the candies we have...\\n            if(count % num_people == 0){        //This is to \\'reset\\' de counter to 0 when we reach the last person.\\n                count = 0;\\n            }\\n            if(total + toGiveCandie <= candies){  \\n                //If the number of candies we have already given plus the candies we are \\n                // going to give are less or equal than the total candies...\\n                res[count] += toGiveCandie;     //We add the candies to the array (give the candie to the person)\\n                total += toGiveCandie;          //We update the candies we have given\\n                toGiveCandie++;                 //To the next person we will give one more candie\\n            }else{\\n                //If we don\\'t have the enough candies, we just give the candies left\\n                res[count] += candies-total;    \\n                total += candies-total;\\n                toGiveCandie++;\\n            }\\n            count++;\\n        }\\n        return res;                            //We return the filled array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944613,
                "title": "c-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int npeople) {\\n        vector<int>ans(npeople,0);\\n        int i=0,n=1;\\n        while(candies>0){\\n            i = i%npeople;\\n            ans[i]= ans[i]+min(candies,n);\\n            candies-=n;\\n            n++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int npeople) {\\n        vector<int>ans(npeople,0);\\n        int i=0,n=1;\\n        while(candies>0){\\n            i = i%npeople;\\n            ans[i]= ans[i]+min(candies,n);\\n            candies-=n;\\n            n++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896445,
                "title": "python-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        dist = 1\\n        pos = 0\\n        while candies > 0:\\n            if pos == num_people:\\n                pos = 0\\n            if candies < dist:\\n                res[pos] += candies\\n                return res\\n            res[pos] += dist\\n            candies -= dist\\n            dist += 1\\n            pos += 1\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        dist = 1\\n        pos = 0\\n        while candies > 0:\\n            if pos == num_people:\\n                pos = 0\\n            if candies < dist:\\n                res[pos] += candies\\n                return res\\n            res[pos] += dist\\n            candies -= dist\\n            dist += 1\\n            pos += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1878038,
                "title": "easier-efficient-javascript-solution",
                "content": "/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let arr = new Array(num_people).fill(0), j = 1, sum = 1, i = 0;\\n    while (sum < candies) {\\n        i = i%num_people;\\n        arr[i] += j;\\n        i++;\\n        j++;\\n        sum += j;\\n    }\\n\\t//handling last remaining candy\\n    arr[i%num_people] += candies - (sum - j);\\n    return arr;\\n};",
                "solutionTags": [],
                "code": "/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let arr = new Array(num_people).fill(0), j = 1, sum = 1, i = 0;\\n    while (sum < candies) {\\n        i = i%num_people;\\n        arr[i] += j;\\n        i++;\\n        j++;\\n        sum += j;\\n    }\\n\\t//handling last remaining candy\\n    arr[i%num_people] += candies - (sum - j);\\n    return arr;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1827308,
                "title": "java-3-liner-explained",
                "content": "**Idea:** Keep distributing the candies in increment of 1 until they run out. Wrap around the array using `% numPeople` and take min to avoid giving more candies than left\\n>**T/S:** O(sqrt(candies))/O(numPeople)\\n```\\npublic int[] distributeCandies(int candies, int numPeople) {\\n\\tvar distribution = new int[numPeople];\\n\\tfor (var i = 0; candies > 0; candies -= ++i)\\n\\t\\tdistribution[i % numPeople] += Math.min(candies, i + 1);\\n\\treturn distribution;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] distributeCandies(int candies, int numPeople) {\\n\\tvar distribution = new int[numPeople];\\n\\tfor (var i = 0; candies > 0; candies -= ++i)\\n\\t\\tdistribution[i % numPeople] += Math.min(candies, i + 1);\\n\\treturn distribution;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807566,
                "title": "c",
                "content": "**4 lines Code\\uD83D\\uDE2E:- \\n\\nstep 1: initalization index i=0, and add = every element adds to the next indexs 1 to n\\n\\nstep 2: iterate while --> cand is not equal to zero.\\n\\nstep  3:  every element is add to evry index by incrementing +1, and remove the elements from cand that are add to an array.\\n\\nstep 4: if iterator \\'i\\'==n them we need  to create circular array from like i=i%n;\\nfor eg: 0,1,2,3,4--->after 4 it again go near index i=0 --> 0,1,2,3,4,0,1,2,3,4.... so on.\\n\\n\\ncode: -\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int cand, int n) {\\n        \\n        int i=0,add=1;\\n        vector<int> arr(n);\\n        while(cand>0){\\n            \\n            arr[i]+=min(add,cand);\\n            cand-=add;\\n            add+=1;\\n            i=(i+1)%n;  \\n        }\\n        return arr;\\n        \\n    }\\n};\\n\\n Thanks please Vote!!\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int cand, int n) {\\n        \\n        int i=0,add=1;\\n        vector<int> arr(n);\\n        while(cand>0){\\n            \\n            arr[i]+=min(add,cand);\\n            cand-=add;\\n            add+=1;\\n            i=(i+1)%n;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1692289,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> arr;\\n        for(int i=0; i<num_people;i++){\\n            arr.push_back(0);\\n        }\\n        int giv=1,i=0;\\n        while(candies!=0){\\n            if(giv>=candies){\\n                arr[i%num_people]+=candies;\\n                candies=0;\\n            }\\n            else{\\n                arr[i%num_people]+= giv;\\n                candies=candies-giv;\\n                giv=giv+ 1;                \\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> arr;\\n        for(int i=0; i<num_people;i++){\\n            arr.push_back(0);\\n        }\\n        int giv=1,i=0;\\n        while(candies!=0){\\n            if(giv>=candies){\\n                arr[i%num_people]+=candies;\\n                candies=0;\\n            }\\n            else{\\n                arr[i%num_people]+= giv;\\n                candies=candies-giv;\\n                giv=giv+ 1;                \\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579712,
                "title": "python-3-solution",
                "content": "```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        \\n        i, candy = 0, 1\\n        while candies > 0:\\n            res[i] += min(candies, candy)\\n            candies -= candy\\n            candy += 1\\n            i = (i + 1) % num_people\\n            \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        \\n        i, candy = 0, 1\\n        while candies > 0:\\n            res[i] += min(candies, candy)\\n            candies -= candy\\n            candy += 1\\n            i = (i + 1) % num_people\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481631,
                "title": "simple-solution-4-lines-without-break-statements",
                "content": "```\\nvar distributeCandies = function (candies, num_people) {\\n    let people = new Array(num_people).fill(0);\\n    for (let index = 0; candies > 0; index++) {\\n        const res = Math.min(index + 1, candies); // if candies is less take only rem ones\\n        people[index % people.length] += res // rotate array and add value to cureent array index\\n        candies = candies - res; //sub candies\\n    }\\n    return people;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function (candies, num_people) {\\n    let people = new Array(num_people).fill(0);\\n    for (let index = 0; candies > 0; index++) {\\n        const res = Math.min(index + 1, candies); // if candies is less take only rem ones\\n        people[index % people.length] += res // rotate array and add value to cureent array index\\n        candies = candies - res; //sub candies\\n    }\\n    return people;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472818,
                "title": "python-easy-to-understand-code-o-n",
                "content": "**Time: O(N)\\nSpace: O(1)**\\n\\n\\n```\\nres=[0 for i in range (num_people)]\\n        val=1\\n        i=0\\n        while(candies>0):\\n            res[i]+=val\\n            i+=1\\n            candies-=val\\n            val+=1\\n            if i==(num_people):\\n                i=0\\n            if val>candies:\\n                val=candies\\n                res[i]+=val\\n                candies=0\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nres=[0 for i in range (num_people)]\\n        val=1\\n        i=0\\n        while(candies>0):\\n            res[i]+=val\\n            i+=1\\n            candies-=val\\n            val+=1\\n            if i==(num_people):\\n                i=0\\n            if val>candies:\\n                val=candies\\n                res[i]+=val\\n                candies=0\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387311,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret;\\n        int j=1;\\n        for(int i=0;i<num_people;i++) {\\n            if(j<=candies) {\\n                ret.push_back(j);\\n                candies-=j;\\n                j++;\\n            }\\n            else  {\\n                ret.push_back(candies);\\n                candies=0;\\n            }\\n        }\\n        int i=0;\\n        while(candies>0) {\\n            if(j<=candies) {\\n                ret[i]+=j;\\n                candies-=j;\\n                i++;\\n                j++;\\n                if(i==num_people) i=0;\\n            }\\n            else {\\n                ret[i]+=candies;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret;\\n        int j=1;\\n        for(int i=0;i<num_people;i++) {\\n            if(j<=candies) {\\n                ret.push_back(j);\\n                candies-=j;\\n                j++;\\n            }\\n            else  {\\n                ret.push_back(candies);\\n                candies=0;\\n            }\\n        }\\n        int i=0;\\n        while(candies>0) {\\n            if(j<=candies) {\\n                ret[i]+=j;\\n                candies-=j;\\n                i++;\\n                j++;\\n                if(i==num_people) i=0;\\n            }\\n            else {\\n                ret[i]+=candies;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324110,
                "title": "simple-c-code-easy-to-understand-0ms-runtime-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> v(num_people,0);\\n        int j=1;\\n        while(candies>0){\\n                v[(j-1)%num_people]+=min(j,candies);\\n                candies-=j;\\n                j++;\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> v(num_people,0);\\n        int j=1;\\n        while(candies>0){\\n                v[(j-1)%num_people]+=min(j,candies);\\n                candies-=j;\\n                j++;\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287989,
                "title": "easy-java-o-n-soln",
                "content": "Do give an upvote if you liked it!\\n```\\npublic int[] distributeCandies(int c, int p) {\\n        int arr[]=new int[p];\\n        int ind = 0;\\n        int k = 1;\\n        while(c>0){\\n            if(c>k)\\n                arr[ind%p]+=k;\\n            else\\n                arr[ind%p]+=c;\\n            ind++;\\n            c=c-k;\\n            k++;\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int c, int p) {\\n        int arr[]=new int[p];\\n        int ind = 0;\\n        int k = 1;\\n        while(c>0){\\n            if(c>k)\\n                arr[ind%p]+=k;\\n            else\\n                arr[ind%p]+=c;\\n            ind++;\\n            c=c-k;\\n            k++;\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1264310,
                "title": "python-3-100-fast-used-math",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = 0\\n        iteration = 0\\n        past_distribution = 0\\n        \\n        while distribution <= candies:\\n            past_distribution = distribution\\n            iteration += 1\\n            distribution = ((num_people*iteration)*(num_people * iteration + 1))//2\\n            \\n        candies -= past_distribution\\n        ans = []\\n        for i in range(num_people):\\n            x = iteration-1\\n            ith_candies = (i+1)*(x) + (num_people*x*(x-1))//2\\n            \\n            if candies > 0:\\n                new_candy = (i+1) + ((iteration-1)*num_people)\\n                new_candies = min(candies, new_candy)\\n                ith_candies += new_candies\\n                candies -= new_candies\\n            ans.append(ith_candies)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = 0\\n        iteration = 0\\n        past_distribution = 0\\n        \\n        while distribution <= candies:\\n            past_distribution = distribution\\n            iteration += 1\\n            distribution = ((num_people*iteration)*(num_people * iteration + 1))//2\\n            \\n        candies -= past_distribution\\n        ans = []\\n        for i in range(num_people):\\n            x = iteration-1\\n            ith_candies = (i+1)*(x) + (num_people*x*(x-1))//2\\n            \\n            if candies > 0:\\n                new_candy = (i+1) + ((iteration-1)*num_people)\\n                new_candies = min(candies, new_candy)\\n                ith_candies += new_candies\\n                candies -= new_candies\\n            ans.append(ith_candies)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252681,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\nvar distributeCandies = function(candies, num_people) {\\n  \\n   let res =Array(num_people).fill(0) ,i=0 , j =1;\\n \\n    while(candies>0)\\n    {    \\n        if(i==num_people)\\n        {\\n            i=0;\\n        }\\n        res[i]+=candies>=j? j :candies;\\n        candies-=j\\n        i++;   \\n        j++;\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [],
                "code": "\\nvar distributeCandies = function(candies, num_people) {\\n  \\n   let res =Array(num_people).fill(0) ,i=0 , j =1;\\n \\n    while(candies>0)\\n    {    \\n        if(i==num_people)\\n        {\\n            i=0;\\n        }\\n        res[i]+=candies>=j? j :candies;\\n        candies-=j\\n        i++;   \\n        j++;\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1240670,
                "title": "java-bruteforce",
                "content": "```\\nclass Solution \\n{\\n    public int[] distributeCandies(int candies, int num_people) \\n    {\\n        int i = 0 , candy = 1 ;\\n        int[] a = new int[num_people] ;\\n        while( candies > 0 )\\n        {\\n            if( candy > candies )\\n            {\\n                a[i] += candies ;\\n            }\\n            else\\n            {\\n                a[i] += candy ;\\n                i++ ;\\n            }\\n            candies = candies - candy ;\\n            candy++ ;\\n            if( i == num_people )\\n            {\\n                i = 0 ;\\n            }\\n        }\\n        return a ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] distributeCandies(int candies, int num_people) \\n    {\\n        int i = 0 , candy = 1 ;\\n        int[] a = new int[num_people] ;\\n        while( candies > 0 )\\n        {\\n            if( candy > candies )\\n            {\\n                a[i] += candies ;\\n            }\\n            else\\n            {\\n                a[i] += candy ;\\n                i++ ;\\n            }\\n            candies = candies - candy ;\\n            candy++ ;\\n            if( i == num_people )\\n            {\\n                i = 0 ;\\n            }\\n        }\\n        return a ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132765,
                "title": "c-o-n-100-fast-time-gauss-summation",
                "content": "```\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        auto iters = 0;  //count how many full cycles we can get\\n        auto sum = 0; //sum of each cycle\\n        auto count = 1; // start value of 1st human in cycle\\n        if(num_people == 1){\\n            return {candies}; \\n        }\\n        sum = (num_people*(count+num_people))/2; //compute first sum of candies for the 1st cycle\\n        while(candies >= sum){ // while we can give candies for each people in cycle, count it and residual of candies\\n            candies -= sum;\\n            count += num_people;\\n            sum = (num_people*(2*count+num_people-1))/2; // sum of all candies from count to N+count\\n            iters++; // if we in while loop, that means we can make a cycle\\n        }\\n        vector<int> res(num_people, 0); // create our final result vector\\n        auto extra = count; //last value for the fisrt human in cycle that we shoul bring\\n        for(auto i = 0; i < num_people; ++i){\\n            if(iters > 0) // if we have full cycles\\n                res[i] = ((i+1)*iters + num_people*(iters-1)*iters/2); //compute sum of all candies for Ith person that can be given from cycles\\n            if(candies >= (extra)){ //if we have extra candies after cycles computing, lets add them\\n                res[i] += extra;\\n                candies -= extra;\\n                ++extra;\\n                \\n            }\\n            else if(candies > 0){\\n                res[i] += candies;\\n                candies = 0;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        auto iters = 0;  //count how many full cycles we can get\\n        auto sum = 0; //sum of each cycle\\n        auto count = 1; // start value of 1st human in cycle\\n        if(num_people == 1){\\n            return {candies}; \\n        }\\n        sum = (num_people*(count+num_people))/2; //compute first sum of candies for the 1st cycle\\n        while(candies >= sum){ // while we can give candies for each people in cycle, count it and residual of candies\\n            candies -= sum;\\n            count += num_people;\\n            sum = (num_people*(2*count+num_people-1))/2; // sum of all candies from count to N+count\\n            iters++; // if we in while loop, that means we can make a cycle\\n        }\\n        vector<int> res(num_people, 0); // create our final result vector\\n        auto extra = count; //last value for the fisrt human in cycle that we shoul bring\\n        for(auto i = 0; i < num_people; ++i){\\n            if(iters > 0) // if we have full cycles\\n                res[i] = ((i+1)*iters + num_people*(iters-1)*iters/2); //compute sum of all candies for Ith person that can be given from cycles\\n            if(candies >= (extra)){ //if we have extra candies after cycles computing, lets add them\\n                res[i] += extra;\\n                candies -= extra;\\n                ++extra;\\n                \\n            }\\n            else if(candies > 0){\\n                res[i] += candies;\\n                candies = 0;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132441,
                "title": "c-100-fast-intuitive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num) {\\n        vector<int> arr(num,0);\\n        \\n        int i=0;\\n        int count=1;\\n\\n        while(candies>0){\\n               arr[i%num]+=min(count,candies);\\n               candies-=count;    \\n               count++;\\n               i++;\\n        }\\n        \\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num) {\\n        vector<int> arr(num,0);\\n        \\n        int i=0;\\n        int count=1;\\n\\n        while(candies>0){\\n               arr[i%num]+=min(count,candies);\\n               candies-=count;    \\n               count++;\\n               i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1063785,
                "title": "easy-brute-force-o-sqrt-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n = num_people;\\n        vector<int> ans(n,0);\\n        int i=0,j=1;\\n        while(candies > 0){\\n        \\n            if(candies > j)\\n                ans[(i+n)%n] += j;\\n            else\\n                ans[(i+n)%n] += candies;\\n                \\n            candies -= j;\\n            i++,j++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n = num_people;\\n        vector<int> ans(n,0);\\n        int i=0,j=1;\\n        while(candies > 0){\\n        \\n            if(candies > j)\\n                ans[(i+n)%n] += j;\\n            else\\n                ans[(i+n)%n] += candies;\\n                \\n            candies -= j;\\n            i++,j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1041303,
                "title": "0ms-time-complexity-o-num-people-space-complexity-o-num-people",
                "content": "Brute force approach giving one candy to first position, two to second etc and looping around until you run out of candy is quick and easy to code but has complexity O(Sqrt(candies)). The limits suggest max number of people is 1000, but max number of candies can be 1,000,000,000 so potentially 30 times as much work! This makes an O(num_people) time algorithm attractive.\\nThe brute force algorithm will take O(Sqrt(candies)) time because there are a quadratic number of steps as explained in the O(num_people) based time.\\n\\nI noticed that the number of candies given out in X steps is given by the sum of the arithmetic progression - **Sum = (n/2)(a+l)**.\\nStep of progression is 1. First step is 1 and number of steps is steps and last value in progression is steps.\\nSo **total candies given out in steps = (steps/2)(1+steps)**.\\nThis gives a quadratic equation in terms of candies\\n**(steps^2)/2 + steps/2 - candies = 0**\\nGiven that we know candies we can solve for steps using general quadratic equation - **x = (-b+sqrt(b^2-4ac))/2a**.\\n**steps = (-(1/2) + sqrt((-1/2)^2-4(1/2)(-candies))/2(1/2)**\\nGiven the number of steps this gives the number of steps where all the candies were given out.\\nFrom this I can calculate the number of complete rounds where everybody got their full complement of candy.\\nFrom this I can calculate the number of candies for each person again based on sum of arithmetic progression (this time step is num_people and intial value is person number)\\nFinally I can calculate the number of candies not handed out in steps and this remainder will be added to the last person to receive candies.\\n\\n**Time Complexity is O(num_people)** and **Space Complexity is O(num_people)**\\n\\nHere is annotated code.\\n\\nIf this helps you please remember to upvote :-) Thank You!\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n\\t\\t// Space O(N)\\n        int[] result = new int[num_people];\\n        // Total candies given out for n steps = n/2(1+n) = (n^2+n)/2 <= candies\\n        // n^2/2+n/2-candies = 0;\\n        // Solving for n = (-1/2)+sqrt(1/4+2candies)\\n        int steps = (int)(Math.sqrt(2*candies+1/4) - 1.0/2);\\n        int rounds = (steps) / num_people;\\n        int partial = steps % num_people;\\n        // System.out.println(\"steps \"+steps);\\n        // System.out.println(\"rounds \"+rounds);\\n        // System.out.println(\"partial \"+partial);\\n        // System.out.println(\"given \"+(steps*(1+steps)/2));\\n\\t\\t// Tiem complexity O(N)\\n        for (int i=0; i<num_people; i++) {\\n            result[i] = rounds*(i+i+2+(rounds-1)*num_people)/2;\\n            if (i < partial)\\n                result[i] += rounds*num_people + i + 1;\\n            // System.out.printf(\"round[%d]=%d\\\\n\", i, result[i]);\\n            if (i == partial)\\n                result[i] += candies - steps*(1+steps)/2;\\n        }\\n        // Brute Force\\n        /*\\n        int share = 1;\\n        int n = 0;\\n        while (candies > 0) {\\n            int amount = Math.min(candies, share++);\\n            result[n++] += amount;\\n            candies -= amount;\\n            n %= num_people;\\n        }\\n        */\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n\\t\\t// Space O(N)\\n        int[] result = new int[num_people];\\n        // Total candies given out for n steps = n/2(1+n) = (n^2+n)/2 <= candies\\n        // n^2/2+n/2-candies = 0;\\n        // Solving for n = (-1/2)+sqrt(1/4+2candies)\\n        int steps = (int)(Math.sqrt(2*candies+1/4) - 1.0/2);\\n        int rounds = (steps) / num_people;\\n        int partial = steps % num_people;\\n        // System.out.println(\"steps \"+steps);\\n        // System.out.println(\"rounds \"+rounds);\\n        // System.out.println(\"partial \"+partial);\\n        // System.out.println(\"given \"+(steps*(1+steps)/2));\\n\\t\\t// Tiem complexity O(N)\\n        for (int i=0; i<num_people; i++) {\\n            result[i] = rounds*(i+i+2+(rounds-1)*num_people)/2;\\n            if (i < partial)\\n                result[i] += rounds*num_people + i + 1;\\n            // System.out.printf(\"round[%d]=%d\\\\n\", i, result[i]);\\n            if (i == partial)\\n                result[i] += candies - steps*(1+steps)/2;\\n        }\\n        // Brute Force\\n        /*\\n        int share = 1;\\n        int n = 0;\\n        while (candies > 0) {\\n            int amount = Math.min(candies, share++);\\n            result[n++] += amount;\\n            candies -= amount;\\n            n %= num_people;\\n        }\\n        */\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038560,
                "title": "surprisingly-fast-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int candie = 1;\\n        auto guy = ret.begin();\\n        while(candies)\\n        {\\n            candie = min(candie, candies); // get at most whatever candie is left\\n            candies -= candie;  // take out candie\\n            *guy += candie; // give it to guy\\n            \\n            guy++; // go to next guy\\n            if (guy == ret.end()) guy = ret.begin();  // loop back if needed\\n            candie++; // increase amount by one\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int candie = 1;\\n        auto guy = ret.begin();\\n        while(candies)\\n        {\\n            candie = min(candie, candies); // get at most whatever candie is left\\n            candies -= candie;  // take out candie\\n            *guy += candie; // give it to guy\\n            \\n            guy++; // go to next guy\\n            if (guy == ret.end()) guy = ret.begin();  // loop back if needed\\n            candie++; // increase amount by one\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000334,
                "title": "java-solution-faster-than-91-97-with-explanation",
                "content": "This is a pretty simple solution that checks whether the number of candies is greater than or equal to counter, if so then add that to the persons number of candies and subtract counter from candies to show how many candies are left. Else it adds the number of candies to the persons number of candies and makes candies equal to zero to break out of the loop and return.\\n\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] numCandies = new int[num_people];\\n\\tint people  = 0;\\n\\tint counter = 1;\\n\\twhile (candies > 0){\\n\\t\\tif (candies >= counter){\\n\\t\\t\\tnumCandies[people] += counter;\\n\\t\\t\\tcandies -= counter;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnumCandies[people] += candies;\\n\\t\\t\\tcandies = 0;\\n\\t\\t}\\n\\t\\tif (people == num_people - 1){\\n\\t\\t\\tpeople = -1;\\n\\t\\t}\\n\\t\\tpeople++;\\n\\t\\tcounter ++;\\n\\t}\\n\\treturn numCandies;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] numCandies = new int[num_people];\\n\\tint people  = 0;\\n\\tint counter = 1;\\n\\twhile (candies > 0){\\n\\t\\tif (candies >= counter){\\n\\t\\t\\tnumCandies[people] += counter;\\n\\t\\t\\tcandies -= counter;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnumCandies[people] += candies;\\n\\t\\t\\tcandies = 0;\\n\\t\\t}\\n\\t\\tif (people == num_people - 1){\\n\\t\\t\\tpeople = -1;\\n\\t\\t}\\n\\t\\tpeople++;\\n\\t\\tcounter ++;\\n\\t}\\n\\treturn numCandies;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979990,
                "title": "python-distribute-one-by-one",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        cand = 1\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cand >= candies:\\n                    res[i] += candies\\n                    candies = 0\\n                    break\\n                else:\\n                    res[i] += cand\\n                    candies -= cand\\n                    cand += 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        cand = 1\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cand >= candies:\\n                    res[i] += candies\\n                    candies = 0\\n                    break\\n                else:\\n                    res[i] += cand\\n                    candies -= cand\\n                    cand += 1\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 949648,
                "title": "c-beats-100-using-ap-series",
                "content": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        \\n        int sum=0;\\n        int i=1;\\n        while(sum+i<=candies)\\n        {\\n            sum+=i;\\n            if(sum+i+1>candies)\\n                break;\\n            i++;\\n        }\\n       \\n        \\n        int row=i/num_people;\\n        \\n        int d=num_people;\\n        int l=0;\\n        int curr=0;\\n        for(int i=0;i<num_people;i++)\\n        {\\n            int a=i+1;\\n            l=a+(row-1)*d;\\n            int s=((a+l)*row)/2;\\n            ans.push_back(s);\\n            curr+=s;\\n            \\n        }\\n        \\n        if(curr<candies)\\n        {\\n            l++;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(curr+l<=candies)\\n                {\\n                    ans[i]=ans[i]+l;\\n                    curr+=l;\\n                }\\n                else\\n                {\\n                    ans[i]=ans[i]+candies-curr;\\n                    break;\\n                }\\n                l++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        \\n        int sum=0;\\n        int i=1;\\n        while(sum+i<=candies)\\n        {\\n            sum+=i;\\n            if(sum+i+1>candies)\\n                break;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 929706,
                "title": "c-faster-than-100-people-neatly-written",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>v(num_people);\\n        int cur=0,sum=0;\\n        for(int i=1;i!=0;i++){\\n            v[cur]+=i;\\n            sum+=i;\\n            if(sum==candies)\\n                break;\\n            else if(sum>candies){\\n                v[cur] -= i;\\n                sum-=i;\\n                v[cur]+=candies-sum;\\n                break;\\n            }\\n            cur++;\\n            cur = cur%num_people;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>v(num_people);\\n        int cur=0,sum=0;\\n        for(int i=1;i!=0;i++){\\n            v[cur]+=i;\\n            sum+=i;\\n            if(sum==candies)\\n                break;\\n            else if(sum>candies){\\n                v[cur] -= i;\\n                sum-=i;\\n                v[cur]+=candies-sum;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 926177,
                "title": "easy-python-3",
                "content": "\\tclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans=[0]*num_people\\n        i=0\\n        while candies>0:\\n            if candies>(i+1):\\n                ans[i%num_people]+=i+1\\n                         \\n            else:\\n                ans[i%num_people]+=candies\\n                \\n            candies-=(i+1)\\n            i+=1\\n            \\n        return ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans=[0]*num_people\\n        i=0\\n        while candies>0:\\n            if candies>(i+1):\\n                ans[i%num_people]+=i+1\\n                         \\n            else:\\n                ans[i%num_people]+=candies\\n                \\n            candies-=(i+1)\\n            i+=1\\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 908015,
                "title": "easy-way-explanation-every-step",
                "content": "#  idea is  you increasing 1 candy for every person until nth person and when your reach last person comeback first.\\n# and put candy whatever gives last person +1 if not enough candy then gives whatever remaining\\n# if 4 person and candy 92\\n\\n# 1 + 2+ 3+  4     ---- first time\\n# 5 + 6+ 7+ 8----- second time\\n# 9 + 10+ 11+ 12  -----thrid time till here 91\\n# 13+1(this place he maximum can gets 14 but not enough canndy)\\n# ----- fourth time\\n# sum of all time candy gets one person  [(1+5+9+13),(2+6+10+1),(3+7+11+0)(4+8+12+0)]\\n# Explanation Bellow  another example example\\n```\\nYour input\\n100\\n8\\nstdout\\n(\\'person=\\', 1, \\'candies gets=\\', 1)\\n[1, 0, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 2)\\n[1, 2, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 3)\\n[1, 2, 3, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 4)\\n[1, 2, 3, 4, 0, 0, 0, 0]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 5)\\n[1, 2, 3, 4, 5, 0, 0, 0]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 6)\\n[1, 2, 3, 4, 5, 6, 0, 0]\\n\\n(\\'person=\\', 7, \\'candies gets=\\', 7)\\n[1, 2, 3, 4, 5, 6, 7, 0]\\n\\n(\\'person=\\', 8, \\'candies gets=\\', 8)\\n[1, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 1, \\'candies gets=\\', 9)\\n[10, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 10)\\n[10, 12, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 11)\\n[10, 12, 14, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 12)\\n[10, 12, 14, 16, 5, 6, 7, 8]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 13)\\n[10, 12, 14, 16, 18, 6, 7, 8]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 9)\\n[10, 12, 14, 16, 18, 15, 7, 8]\\n\\nOutput\\n[10,12,14,16,18,15,7,8]\\nExpected\\n[10,12,14,16,18,15,7,8]\\n\\n\\n\\n\\n```\\n```\\n\\nclass Solution(object):\\n    def distributeCandies(self, can, n):\\n        \"\"\"\\n        :type candies: int\\n        :type num_people: int\\n        :rtype: List[int]\\n        \"\"\"\\n        re=[0 for i in range(n)]\\n        i=1\\n        while can>0:\\n        \\n          re[(i-1)%n]+=min(i,can)\\n\\t\\t  \\n          can,i=can-i,i+1\\n          \\n        return re\\n      \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nYour input\\n100\\n8\\nstdout\\n(\\'person=\\', 1, \\'candies gets=\\', 1)\\n[1, 0, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 2)\\n[1, 2, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 3)\\n[1, 2, 3, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 4)\\n[1, 2, 3, 4, 0, 0, 0, 0]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 5)\\n[1, 2, 3, 4, 5, 0, 0, 0]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 6)\\n[1, 2, 3, 4, 5, 6, 0, 0]\\n\\n(\\'person=\\', 7, \\'candies gets=\\', 7)\\n[1, 2, 3, 4, 5, 6, 7, 0]\\n\\n(\\'person=\\', 8, \\'candies gets=\\', 8)\\n[1, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 1, \\'candies gets=\\', 9)\\n[10, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 10)\\n[10, 12, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 11)\\n[10, 12, 14, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 12)\\n[10, 12, 14, 16, 5, 6, 7, 8]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 13)\\n[10, 12, 14, 16, 18, 6, 7, 8]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 9)\\n[10, 12, 14, 16, 18, 15, 7, 8]\\n\\nOutput\\n[10,12,14,16,18,15,7,8]\\nExpected\\n[10,12,14,16,18,15,7,8]\\n\\n\\n\\n\\n```\n```\\n\\nclass Solution(object):\\n    def distributeCandies(self, can, n):\\n        \"\"\"\\n        :type candies: int\\n        :type num_people: int\\n        :rtype: List[int]\\n        \"\"\"\\n        re=[0 for i in range(n)]\\n        i=1\\n        while can>0:\\n        \\n          re[(i-1)%n]+=min(i,can)\\n\\t\\t  \\n          can,i=can-i,i+1\\n          \\n        return re\\n      \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870584,
                "title": "simple-c-solution-100-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int num_people) {\\n\\t\\t\\tvector<int> v(num_people,0);\\n\\t\\t\\tint i = 1;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile(candies > 0){\\n\\t\\t\\t\\tv[j%num_people] += min(candies,i);\\n\\t\\t\\t\\tcandies-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n        \\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int num_people) {\\n\\t\\t\\tvector<int> v(num_people,0);\\n\\t\\t\\tint i = 1;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile(candies > 0){\\n\\t\\t\\t\\tv[j%num_people] += min(candies,i);\\n\\t\\t\\t\\tcandies-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 869907,
                "title": "swift-solution-readability-performance-92",
                "content": "I would prefer my solution for readability than those weird modulo formula. It\\'s dumb in my opinion to use the solution. Not everyone knows that.\\n\\n```\\nclass Solution {\\n    func distributeCandies(_ candies: Int, _ num_people: Int) -> [Int] {\\n        \\n        var result: [Int] = Array(repeating: 0, count: num_people)\\n        var candies = candies\\n        var currentIndex = 0\\n        var currentGive = 1\\n        \\n        while candies > 0 {\\n            if candies > currentGive {\\n                result[currentIndex] += currentGive\\n                candies -= currentGive\\n                currentGive += 1\\n            } else {\\n                result[currentIndex] += candies\\n                candies = 0\\n            }\\n            currentIndex = currentIndex < num_people - 1 ? currentIndex + 1 : 0\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distributeCandies(_ candies: Int, _ num_people: Int) -> [Int] {\\n        \\n        var result: [Int] = Array(repeating: 0, count: num_people)\\n        var candies = candies\\n        var currentIndex = 0\\n        var currentGive = 1\\n        \\n        while candies > 0 {\\n            if candies > currentGive {\\n                result[currentIndex] += currentGive\\n                candies -= currentGive\\n                currentGive += 1\\n            } else {\\n                result[currentIndex] += candies\\n                candies = 0\\n            }\\n            currentIndex = currentIndex < num_people - 1 ? currentIndex + 1 : 0\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839218,
                "title": "javascript-mathematical-solution",
                "content": "##### Amortized Analysis\\n\\nTIme Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n---\\n##### Code\\n---\\n```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nconst seriesSum = n => (n * (n+1))/2;\\n\\nconst binarySearch = (low, high, candies) => {\\n  while(low < high) {\\n    let mid = (low + high) >> 1;\\n    let sum = seriesSum(mid);\\n    if( sum == candies ) {\\n      return mid;\\n    } else if (sum < candies) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n  return high;\\n}\\nvar distributeCandies = function(candies, num_people) {\\n  // find how many time it is possible to circle back\\n  let round = binarySearch(0, 1e5, candies) / num_people >> 0;\\n  // find the extra andies\\n  let extra = candies - seriesSum(round * num_people);\\n  let answer = Array(num_people).fill(0); \\n  // first person will get  n * (r*(r+1))/2 + r + 1 candies, where n = num_people and r = round - 1\\n  answer[0] = Math.max(0, num_people * seriesSum(round - 1) + round);\\n  let candiesLeft = candies - answer[0];\\n  for(let i = 1; i < num_people; i++) {\\n\\t // every one will get exactly **r** candies more than the previous persion\\n    answer[i] = Math.min(answer[i - 1] + round, candiesLeft);\\n    candiesLeft -= answer[i];\\n  }\\n  // distribute the extra candies\\n  for(let i = 0; i < num_people && extra > 0; i++) {\\n\\t // everyone will get n * r + i + 1 extra candies. where n = num_people, r =round, i is the position of the persion (0 indexed)\\n    let exCandies = Math.min(num_people * round + i + 1 , extra);\\n    answer[i] += exCandies\\n    extra -= exCandies;\\n  }\\n  return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nconst seriesSum = n => (n * (n+1))/2;\\n\\nconst binarySearch = (low, high, candies) => {\\n  while(low < high) {\\n    let mid = (low + high) >> 1;\\n    let sum = seriesSum(mid);\\n    if( sum == candies ) {\\n      return mid;\\n    } else if (sum < candies) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n  return high;\\n}\\nvar distributeCandies = function(candies, num_people) {\\n  // find how many time it is possible to circle back\\n  let round = binarySearch(0, 1e5, candies) / num_people >> 0;\\n  // find the extra andies\\n  let extra = candies - seriesSum(round * num_people);\\n  let answer = Array(num_people).fill(0); \\n  // first person will get  n * (r*(r+1))/2 + r + 1 candies, where n = num_people and r = round - 1\\n  answer[0] = Math.max(0, num_people * seriesSum(round - 1) + round);\\n  let candiesLeft = candies - answer[0];\\n  for(let i = 1; i < num_people; i++) {\\n\\t // every one will get exactly **r** candies more than the previous persion\\n    answer[i] = Math.min(answer[i - 1] + round, candiesLeft);\\n    candiesLeft -= answer[i];\\n  }\\n  // distribute the extra candies\\n  for(let i = 0; i < num_people && extra > 0; i++) {\\n\\t // everyone will get n * r + i + 1 extra candies. where n = num_people, r =round, i is the position of the persion (0 indexed)\\n    let exCandies = Math.min(num_people * round + i + 1 , extra);\\n    answer[i] += exCandies\\n    extra -= exCandies;\\n  }\\n  return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798651,
                "title": "c-best-in-time-complexity-o-log-candies-simple-binary-search-easy-explain",
                "content": "**Binary Search**\\n* Apply simple binary search to  find the number of how many times candies can be distributed continuosly.\\n* \\n![image](https://assets.leetcode.com/users/images/9bdfc860-e8b2-45b2-a9df-d7177004c7fd_1597749409.8828528.png)\\n\\n```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n=num_people;\\n        vector<int> v(n);\\n     int left=1;\\n        int right=sqrt(INT_MAX)-1,mid;\\n      while(left<=right)\\n      {\\n            mid=(left+right)/2;\\n        if((mid*(mid+1))/2<candies)\\n        {\\n            left=mid+1;\\n            \\n        }\\n          else if((mid*(mid+1))/2> candies)\\n              right=mid-1;\\n          else\\n              break;\\n          \\n      }\\n     if((mid*(mid+1))/2>candies)\\n         mid--;\\n        \\n    int k=mid/n;\\n        candies-=(k*n*(k*n+1))/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]=(i+1)*(k) + ((k-1)*(k)/2)*n+min(candies,k*n+i+1);\\n            candies-=min(candies,k*n+i+1);\\n        }\\n        \\n  //  v.pb(mid);\\n        return v;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n=num_people;\\n        vector<int> v(n);\\n     int left=1;\\n        int right=sqrt(INT_MAX)-1,mid;\\n      while(left<=right)\\n      {\\n            mid=(left+right)/2;\\n        if((mid*(mid+1))/2<candies)\\n        {\\n            left=mid+1;\\n            \\n        }\\n          else if((mid*(mid+1))/2> candies)\\n              right=mid-1;\\n          else\\n              break;\\n          \\n      }\\n     if((mid*(mid+1))/2>candies)\\n         mid--;\\n        \\n    int k=mid/n;\\n        candies-=(k*n*(k*n+1))/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]=(i+1)*(k) + ((k-1)*(k)/2)*n+min(candies,k*n+i+1);\\n            candies-=min(candies,k*n+i+1);\\n        }\\n        \\n  //  v.pb(mid);\\n        return v;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798038,
                "title": "simple-c-solution",
                "content": "Please comment for any doubt\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        if (num_people==0 or candies==0)\\n            return {};\\n        if(num_people==1)\\n            return {candies};\\n        vector<int> res(num_people,0);\\n        int i=1;\\n        int ind=0;\\n        while (candies>0)\\n        {\\n            res[ind]+=min(i,candies);\\n            candies-=i;\\n            i+=1;\\n            ind=(ind+1)%num_people;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        if (num_people==0 or candies==0)\\n            return {};\\n        if(num_people==1)\\n            return {candies};\\n        vector<int> res(num_people,0);\\n        int i=1;\\n        int ind=0;\\n        while (candies>0)\\n        {\\n            res[ind]+=min(i,candies);\\n            candies-=i;\\n            i+=1;\\n            ind=(ind+1)%num_people;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798037,
                "title": "distribute-candies-to-people-python-simplest-solution-28-ms-faster-than-98-59-of-python3",
                "content": "```\\ndef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        counter  = 1\\n        result = [0] * num_people\\n        \\n        while candies :\\n            index = (counter - 1) % num_people\\n            if candies - counter >= 0:\\n                result[index] += counter\\n                candies -= counter\\n            else :\\n                result[index] += candies\\n                candies = 0\\n                \\n            counter += 1\\n        \\n        return result \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        counter  = 1\\n        result = [0] * num_people\\n        \\n        while candies :\\n            index = (counter - 1) % num_people\\n            if candies - counter >= 0:\\n                result[index] += counter\\n                candies -= counter\\n            else :\\n                result[index] += candies\\n                candies = 0\\n                \\n            counter += 1\\n        \\n        return result \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 797716,
                "title": "beats-100-using-formula-for-sum-of-series",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int j = (int) ((-1 + Math.sqrt(1 + (long) 8 * candies)) / 2);\\n        \\n        int leftovercandies = candies - (j * (j + 1) / 2);\\n        \\n        int[] ans = new int[num_people];\\n        \\n        int r = j / num_people - 1;\\n        \\n        for (int i = 0; i < num_people; i++) {\\n            ans[i] = (r + 1) * (i + 1) + num_people * (r * (r + 1)) / 2;\\n        }\\n        \\n        for (int i = 0; i < j % num_people; i++) {\\n            ans[i] += (r + 1) * num_people + i + 1;\\n        }\\n        \\n        ans[j % num_people] += leftovercandies;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nUse quadratic formula to find mininum j such that j * (j + 1) / 2 = num_candies.\\n\\nCalculate leftover candies for last person (when no longer enough candy to continue pattern) using candies - j * (j + 1) / 2.\\n\\nCalculate r (number of full rounds of distributing candy), and subtract 1 to use 0 indexing.\\n\\nWrite out the numbers on a sheet of paper, and you can see that the numbers down each column (with each round on top of each other) and you see that the numbers down each column is also a series, so we can use a formula to directly calculate the candies after r full rounds for each person.\\n\\nAnother loop for the final, possible non-full round, (starts at index i and ends at j % num_people.\\n\\nAdd leftover candies to final person.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int j = (int) ((-1 + Math.sqrt(1 + (long) 8 * candies)) / 2);\\n        \\n        int leftovercandies = candies - (j * (j + 1) / 2);\\n        \\n        int[] ans = new int[num_people];\\n        \\n        int r = j / num_people - 1;\\n        \\n        for (int i = 0; i < num_people; i++) {\\n            ans[i] = (r + 1) * (i + 1) + num_people * (r * (r + 1)) / 2;\\n        }\\n        \\n        for (int i = 0; i < j % num_people; i++) {\\n            ans[i] += (r + 1) * num_people + i + 1;\\n        }\\n        \\n        ans[j % num_people] += leftovercandies;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797508,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int []res = new int[num_people];\\n        \\n        int counter = 1;\\n        int currentPerson = 0;\\n        while(candies >= 0) {\\n            res[currentPerson] += (counter < candies) ? counter: candies;\\n            candies -= counter++;\\n            currentPerson = (currentPerson + 1)%num_people;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int []res = new int[num_people];\\n        \\n        int counter = 1;\\n        int currentPerson = 0;\\n        while(candies >= 0) {\\n            res[currentPerson] += (counter < candies) ? counter: candies;\\n            candies -= counter++;\\n            currentPerson = (currentPerson + 1)%num_people;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 797055,
                "title": "simple-loop-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        int candyCount = 1;\\n        while(candies>0){\\n            \\n                for(int i = 0 ; i < num_people; ++i){\\n                    if(candyCount<=candies){\\n                        people[i]+=candyCount;\\n                        candies-=candyCount;\\n                        ++candyCount;\\n                    }else{\\n                        people[i]+=candies;\\n                        candies=0;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n            \\n        }\\n        return people;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        int candyCount = 1;\\n        while(candies>0){\\n            \\n                for(int i = 0 ; i < num_people; ++i){\\n                    if(candyCount<=candies){\\n                        people[i]+=candyCount;\\n                        candies-=candyCount;\\n                        ++candyCount;\\n                    }else{\\n                        people[i]+=candies;\\n                        candies=0;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n            \\n        }\\n        return people;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796909,
                "title": "java-one-go-o-num-people-math",
                "content": "I have tried to represent the formula in hand-written.\\n**Caution : bad hand-writing ahead**\\n![image](https://assets.leetcode.com/users/images/61bfada6-bc5c-4a70-8dee-261a1afe598d_1597671597.664236.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f8282f08-f5ba-4609-9c92-68f45751701f_1597671574.2589667.png)\\n\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int c, int num_people) {\\n        int [] p = new int[num_people];\\n        int candiesRemaining = c;\\n        // x*(x+1)/2 = c\\n        double x = (-1 + Math.sqrt(1+(double)8*c))/2;\\n        // x = k*n + r;\\n        int k = ((int)x)/num_people;\\n        int r = ((int)x)%num_people;\\n        for(int i=0;i<num_people;i++){\\n            if(i<r){\\n                p[i] = (k+1)*(i+1) + num_people*(k)*(k+1)/2;\\n            }\\n            else{\\n                p[i] = (k)*(i+1) + num_people*(k)*(k-1)/2;\\n            }\\n            candiesRemaining-=p[i];\\n        }\\n        p[r] += candiesRemaining;\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int c, int num_people) {\\n        int [] p = new int[num_people];\\n        int candiesRemaining = c;\\n        // x*(x+1)/2 = c\\n        double x = (-1 + Math.sqrt(1+(double)8*c))/2;\\n        // x = k*n + r;\\n        int k = ((int)x)/num_people;\\n        int r = ((int)x)%num_people;\\n        for(int i=0;i<num_people;i++){\\n            if(i<r){\\n                p[i] = (k+1)*(i+1) + num_people*(k)*(k+1)/2;\\n            }\\n            else{\\n                p[i] = (k)*(i+1) + num_people*(k)*(k-1)/2;\\n            }\\n            candiesRemaining-=p[i];\\n        }\\n        p[r] += candiesRemaining;\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796903,
                "title": "single-pass-o-num-people-i-e-o-n-explained-java-beats-100-solutions-0ms",
                "content": "We can think of distributing candies to people standing in an infinite row and later arrange them in\\n\\nWe will first find out how many times we can give as many candies to people as many they can take at that particular chance. Lets denote this number as ```n```.\\n{For eg.- if there are 2 people and 9 candies, we can give required candies 3 times (so n=3). 1 candy to first person (1), then 2 candies to second person (2), then 3 candies to first person (3). Now we have 3 candies left (```extra```) but second person requires 4 candies.}\\n\\n```candies = n*(n+1)/2 + extra```\\n```candies - extra = n*(n+1)/2```\\ntherefore,``` n*n + n - 2*(candies -extra) = 0```\\nSolving this equation for n ( I am using [Quadratic Formula](https://en.wikipedia.org/wiki/Quadratic_formula) here) we can get n as:\\n```n = (-1 \\xB1 \\u221A(1-4 * (-2) * (candies-extra)) )/2```\\nWe can ignore the negative root, because the number of candies cannot be negative.\\nAlso, we are interested to find the maximum number for which candies are sufficient, so we can strike off extra. \\nThis gives us ```n = (-1 + \\u221A(1+(8 * candies)) )/2```\\nWe will use floor value (integer value) of n because number of candies cannot be a fraction here.\\n\\nLets represent number of passes in which everyone gets the maximum number of candies they can get as ```passes```, then:\\n```passes = n/num_people```  {passes = 1, in case of above example, because in second pass/iteration, second person could not get required number of candies}\\nNow, the candies remaining after ```passes``` passes/iteration , ```rem``` equals number of candies distributed in ```passes``` passes/iteration subtracte from total candies, ```candies```\\n```rem = candies - passes*num_people*(passes*num_people+1)/2```\\n\\nFor each person, we can get the number of candies that he/she receives as the sum of an Arithmetic Progression in ```passes``` iterations + the candies he/she will receive in the final iteration (if any).\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int n = ((int)Math.sqrt(1+8*(long)candies) - 1)/2;\\n        int passes = n/num_people;\\n        int rem = candies - passes*num_people*(passes*num_people+1)/2;\\n        for(int i=0; i<num_people; i++)\\n        {\\n            int remAdd = Math.min(rem, passes*num_people + i+1);\\n            rem -= remAdd;\\n            res[i] = passes*(2*(i+1) + (passes-1)*num_people)/2 + remAdd;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```n```\n```extra```\n```candies = n*(n+1)/2 + extra```\n```candies - extra = n*(n+1)/2```\n``` n*n + n - 2*(candies -extra) = 0```\n```n = (-1 \\xB1 \\u221A(1-4 * (-2) * (candies-extra)) )/2```\n```n = (-1 + \\u221A(1+(8 * candies)) )/2```\n```passes```\n```passes = n/num_people```\n```passes```\n```rem```\n```passes```\n```candies```\n```rem = candies - passes*num_people*(passes*num_people+1)/2```\n```passes```\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int n = ((int)Math.sqrt(1+8*(long)candies) - 1)/2;\\n        int passes = n/num_people;\\n        int rem = candies - passes*num_people*(passes*num_people+1)/2;\\n        for(int i=0; i<num_people; i++)\\n        {\\n            int remAdd = Math.min(rem, passes*num_people + i+1);\\n            rem -= remAdd;\\n            res[i] = passes*(2*(i+1) + (passes-1)*num_people)/2 + remAdd;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796823,
                "title": "java-distribute-candies-to-people-beats-100-time-o-n-space-o-1",
                "content": "```\\npublic class DistributeCandiestoPeople {\\n\\n    public int[] distributeCandies(int candies, int num_people) {\\n        long candiesLong=candies;\\n        // TO calculate nearest n for  the Summation of n natural number that is the candies\\n        //candies=n(n+1)/2\\n        double nearestSummation= ((Math.sqrt(((8*candiesLong)+1))-1)/2);\\n        //Levels are the levels downwards that need to be summed up vertically\\n        //if data is aligned vertically that is nearestSummation % num_people ==0 the data is summed up vertically for all the levels\\n        //if it is not then the levels summed up vertically is done till second last level after that\\n        //the data is added manually with left over candies and the n th addition to the n % num_people\\n        int levels;\\n\\n        if(Math.floor(nearestSummation)==nearestSummation)\\n            levels=  (((int)nearestSummation)/num_people);\\n        else {\\n            nearestSummation=Math.floor(nearestSummation);\\n            levels = (((int) nearestSummation ) / num_people);\\n        }\\n\\n        int sumbase=1;\\n        for(int i=1;i<=levels-1;i++){\\n            sumbase=sumbase+num_people*i+1;\\n        }\\n\\n        if(nearestSummation<num_people)\\n            levels=1;\\n        int[] arr =new int[num_people];\\n        for(int i=0;i<num_people && candies>0;i++){\\n            arr[i]=sumbase<candies?sumbase:candies;\\n            sumbase=sumbase+levels;\\n            candies-=arr[i];\\n        }\\n       //sumbase resetted as the n th addition on the array\\n        sumbase=num_people*levels+1;\\n        //n++ th addition for ever consecutive person till the candies run out and last person gets all the remaining candy\\n        levels=1;\\n        //Does not execute if candies are finished\\n        for(int i=0;i<num_people && candies>0;i++){\\n            int tempAlot=sumbase<candies?sumbase:candies;\\n            arr[i]+=tempAlot;\\n            sumbase=sumbase+levels;\\n            candies-=tempAlot;\\n        }\\n\\n        return arr;\\n    }\\n\\n    public static void main(String[] args) {\\n        DistributeCandiestoPeople distributeCandiestoPeople= new DistributeCandiestoPeople();\\n        int[] arr= distributeCandiestoPeople.distributeCandies(1000000000,1000);\\n        for(int x:arr)\\n            System.out.println(x);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class DistributeCandiestoPeople {\\n\\n    public int[] distributeCandies(int candies, int num_people) {\\n        long candiesLong=candies;\\n        // TO calculate nearest n for  the Summation of n natural number that is the candies\\n        //candies=n(n+1)/2\\n        double nearestSummation= ((Math.sqrt(((8*candiesLong)+1))-1)/2);\\n        //Levels are the levels downwards that need to be summed up vertically\\n        //if data is aligned vertically that is nearestSummation % num_people ==0 the data is summed up vertically for all the levels\\n        //if it is not then the levels summed up vertically is done till second last level after that\\n        //the data is added manually with left over candies and the n th addition to the n % num_people\\n        int levels;\\n\\n        if(Math.floor(nearestSummation)==nearestSummation)\\n            levels=  (((int)nearestSummation)/num_people);\\n        else {\\n            nearestSummation=Math.floor(nearestSummation);\\n            levels = (((int) nearestSummation ) / num_people);\\n        }\\n\\n        int sumbase=1;\\n        for(int i=1;i<=levels-1;i++){\\n            sumbase=sumbase+num_people*i+1;\\n        }\\n\\n        if(nearestSummation<num_people)\\n            levels=1;\\n        int[] arr =new int[num_people];\\n        for(int i=0;i<num_people && candies>0;i++){\\n            arr[i]=sumbase<candies?sumbase:candies;\\n            sumbase=sumbase+levels;\\n            candies-=arr[i];\\n        }\\n       //sumbase resetted as the n th addition on the array\\n        sumbase=num_people*levels+1;\\n        //n++ th addition for ever consecutive person till the candies run out and last person gets all the remaining candy\\n        levels=1;\\n        //Does not execute if candies are finished\\n        for(int i=0;i<num_people && candies>0;i++){\\n            int tempAlot=sumbase<candies?sumbase:candies;\\n            arr[i]+=tempAlot;\\n            sumbase=sumbase+levels;\\n            candies-=tempAlot;\\n        }\\n\\n        return arr;\\n    }\\n\\n    public static void main(String[] args) {\\n        DistributeCandiestoPeople distributeCandiestoPeople= new DistributeCandiestoPeople();\\n        int[] arr= distributeCandiestoPeople.distributeCandies(1000000000,1000);\\n        for(int x:arr)\\n            System.out.println(x);\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796753,
                "title": "my-o-sqrt-candies-solution-using-ap-formula-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n\\t/*\\n\\tget the last number of arithmetic progression (AP) that can be made by candies\\n\\te.g if candies = 7, n = 3, i.e AP will be 1 2 3\\n\\tthe equation to get n is => n/2 * (n + 1) = candies\\n\\t=> n * (n + 1) = 2 * candies\\n\\t=> n^2 + n = 2 * candies\\n\\t=> (n + 0.5)^2 - 0.25 = 2 * candies\\n\\t=> (n + 0.5)^2 = 2 * candies + 0.25\\n\\t=> n + 0.5 = sqrt(2 * candies + 0.25)\\n\\t=> n = sqrt(2 * candies + 0.25) - 0.5\\n\\tafter that we will distribute each number of the AP to the poeple till we reach last person, then we will give the last person the remainder of the candies \\n\\t*/\\n        int n = sqrt(2*candies + 0.25) - 0.5;\\n        vector<int> ans(num_people);\\n        \\n        int idx = 0;\\n\\t// loop on each number of AP and distribute it to the current person\\n        for (int i = 1; i <= n; i++) {\\n            ans[idx] += i;\\n            candies -= i;\\n\\t    /* make addition with mod to return to the first person in case of idx = num_people, i.e we reach after last person so we return back to first person\\n\\t    this is equal to => idx++; if (idx == num_people) idx = 0;\\n            */\\n            idx = (idx + 1) % num_people;\\n        }\\n\\t// give last person the remainder of candies if exists\\n        ans[idx] += candies;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n\\t/*\\n\\tget the last number of arithmetic progression (AP) that can be made by candies\\n\\te.g if candies = 7, n = 3, i.e AP will be 1 2 3\\n\\tthe equation to get n is => n/2 * (n + 1) = candies\\n\\t=> n * (n + 1) = 2 * candies\\n\\t=> n^2 + n = 2 * candies\\n\\t=> (n + 0.5)^2 - 0.25 = 2 * candies\\n\\t=> (n + 0.5)^2 = 2 * candies + 0.25\\n\\t=> n + 0.5 = sqrt(2 * candies + 0.25)\\n\\t=> n = sqrt(2 * candies + 0.25) - 0.5\\n\\tafter that we will distribute each number of the AP to the poeple till we reach last person, then we will give the last person the remainder of the candies \\n\\t*/\\n        int n = sqrt(2*candies + 0.25) - 0.5;\\n        vector<int> ans(num_people);\\n        \\n        int idx = 0;\\n\\t// loop on each number of AP and distribute it to the current person\\n        for (int i = 1; i <= n; i++) {\\n            ans[idx] += i;\\n            candies -= i;\\n\\t    /* make addition with mod to return to the first person in case of idx = num_people, i.e we reach after last person so we return back to first person\\n\\t    this is equal to => idx++; if (idx == num_people) idx = 0;\\n            */\\n            idx = (idx + 1) % num_people;\\n        }\\n\\t// give last person the remainder of candies if exists\\n        ans[idx] += candies;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796717,
                "title": "python-sol-by-simulation-w-comment",
                "content": "Python sol by simulation\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, num_people):\\n\\n\\n        n = num_people\\n        \\n        # candies distribution for each person\\n        result = [0] * n\\n         \\n        c = 0\\n        while candies > 0:\\n            \\n            # candies may be not enough on last round, therefore compute min(candies, c+1)\\n            result[c % n] += min(candies, c+1)\\n            \\n            # add one more candies for next person\\n            c += 1\\n            \\n            # update total number of candies\\n            candies -= c\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, num_people):\\n\\n\\n        n = num_people\\n        \\n        # candies distribution for each person\\n        result = [0] * n\\n         \\n        c = 0\\n        while candies > 0:\\n            \\n            # candies may be not enough on last round, therefore compute min(candies, c+1)\\n            result[c % n] += min(candies, c+1)\\n            \\n            # add one more candies for next person\\n            c += 1\\n            \\n            # update total number of candies\\n            candies -= c\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796537,
                "title": "distribute-candies-c-clear-100",
                "content": "Maybe not the most concise, but very easy to understand.\\nJust do literally what the description says.\\n```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> distributed(num_people);\\n        int candiesToGive = 1, i = 0;\\n\\t\\t// While there are remaining candies, increment the number of candies to give\\n        while (candies > 0) {\\n            if (i >= num_people) i = 0; // Reset index when we pass the last person\\n            distributed[i++] += min(candiesToGive, candies); // The amount of candies for the next person. Min of remaining or required to give\\n            candies -= candiesToGive++; // Reduce remaining candies\\n        }\\n        return distributed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> distributed(num_people);\\n        int candiesToGive = 1, i = 0;\\n\\t\\t// While there are remaining candies, increment the number of candies to give\\n        while (candies > 0) {\\n            if (i >= num_people) i = 0; // Reset index when we pass the last person\\n            distributed[i++] += min(candiesToGive, candies); // The amount of candies for the next person. Min of remaining or required to give\\n            candies -= candiesToGive++; // Reduce remaining candies\\n        }\\n        return distributed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796449,
                "title": "simple-optimised-c-solution-with-o-num-people-complexity",
                "content": "/*this is the best solution with simple mathematics.\\nmake a matrix like this suppose three people and 28 candies\\n[1,2,3]\\n[4,5,6]\\n[7,0,0]\\nwill be distributed in this manner now to understand how we calcuate this sum 1+4+7 for people 1 and 2+5 for people 2 and 3+6 for people 3*/\\n/* the 1+4+7 notice it sum of first 3 terms with common difference as number of people and terms as t+rem if(rem!=0) for t and rem check the code how we calculate them and for sum of first t terms check the loop*/\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int>ans(num_people,0);\\n        if(candies==0) return ans;\\n        int num=1,s=1;\\n        while(s<=candies){\\n            num++;\\n            s+=num;\\n        }\\n        num--;\\n        int t=num/num_people;\\n        int rem=num%num_people;\\n        int rem1=rem;\\n        for(int i=1;i<=num_people;i++){\\n            int no_of_terms=t;\\n            if(rem!=0){\\n                no_of_terms++;\\n                rem--;\\n            }\\n            int sum1=no_of_terms*(2*i+(no_of_terms-1)*num_people);\\n            sum1/=2;\\n            candies-=sum1;\\n            ans[i-1]=sum1;\\n        }\\n        /*this step is for suppose canidies instead of 28 they are 30 then remaining 2 candies will go to \\n        people 2 and sum will be 2+5+2 for people 2 as mentioned in question*/\\n        ans[rem1]+=candies;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int>ans(num_people,0);\\n        if(candies==0) return ans;\\n        int num=1,s=1;\\n        while(s<=candies){\\n            num++;\\n            s+=num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 796441,
                "title": "c-intuitive-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people);\\n        \\n        for (int i = 0, round = 0; candies > 0;) {\\n            int distribute = round * num_people + i + 1;\\n            \\n            if (candies >= distribute) {\\n                candies -= distribute;\\n                ans[i] += distribute;\\n            } else {\\n                ans[i] += candies;\\n                candies = 0;\\n            }\\n            \\n            if (++i >= num_people) {\\n                i = 0;\\n                ++round;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people);\\n        \\n        for (int i = 0, round = 0; candies > 0;) {\\n            int distribute = round * num_people + i + 1;\\n            \\n            if (candies >= distribute) {\\n                candies -= distribute;\\n                ans[i] += distribute;\\n            } else {\\n                ans[i] += candies;\\n                candies = 0;\\n            }\\n            \\n            if (++i >= num_people) {\\n                i = 0;\\n                ++round;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796414,
                "title": "c-o-num-people-log-candies-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(ll candies, ll num_people) {\\n        ll l = 0LL, r = 1e5 + 1LL, no_of_iterations = 0, ls_exp;\\n        while(l <= r){\\n            ll mid = (l + r) >> 1;\\n            ll exp = ((num_people * num_people * mid * (mid - 1LL)) + \\n                     (mid * num_people * (num_people + 1LL)) ) >> 1;\\n            if(exp <= candies){\\n                l = mid + 1LL;\\n                no_of_iterations = mid;\\n                ls_exp = exp;\\n            }\\n            else{\\n                r = mid - 1LL;\\n            }\\n        }\\n        vector<int> ans(num_people);\\n        candies -= ls_exp;\\n        ll com_term = (no_of_iterations * (no_of_iterations - 1LL) * num_people ) >> 1;\\n        for(ll i = 0LL; i < num_people; i ++){\\n            ll expected = ((no_of_iterations * num_people) + (i + 1LL)), add;\\n            if(expected <= candies){\\n                candies -= expected;\\n                add = expected;\\n            }\\n            else{\\n                add = candies;\\n                candies = 0LL;\\n            }\\n            ans[i] = com_term + (no_of_iterations * (i + 1LL)) + add;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(ll candies, ll num_people) {\\n        ll l = 0LL, r = 1e5 + 1LL, no_of_iterations = 0, ls_exp;\\n        while(l <= r){\\n            ll mid = (l + r) >> 1;\\n            ll exp = ((num_people * num_people * mid * (mid - 1LL)) + \\n                     (mid * num_people * (num_people + 1LL)) ) >> 1;\\n            if(exp <= candies){\\n                l = mid + 1LL;\\n                no_of_iterations = mid;\\n                ls_exp = exp;\\n            }\\n            else{\\n                r = mid - 1LL;\\n            }\\n        }\\n        vector<int> ans(num_people);\\n        candies -= ls_exp;\\n        ll com_term = (no_of_iterations * (no_of_iterations - 1LL) * num_people ) >> 1;\\n        for(ll i = 0LL; i < num_people; i ++){\\n            ll expected = ((no_of_iterations * num_people) + (i + 1LL)), add;\\n            if(expected <= candies){\\n                candies -= expected;\\n                add = expected;\\n            }\\n            else{\\n                add = candies;\\n                candies = 0LL;\\n            }\\n            ans[i] = com_term + (no_of_iterations * (i + 1LL)) + add;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796408,
                "title": "my-0ms-c-solution-easy-to-understand",
                "content": "```\\n    static vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people, 0);\\n        int i = 0;\\n        while (candies > 0) {\\n            ans[i % num_people] += i + 1;\\n            candies -= i + 1;\\n            ++i;\\n        }\\n        \\n        if (candies < 0) { //Fix for giving too many candies to last person\\n            ans[(i - 1) % num_people] += candies;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n    static vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people, 0);\\n        int i = 0;\\n        while (candies > 0) {\\n            ans[i % num_people] += i + 1;\\n            candies -= i + 1;\\n            ++i;\\n        }\\n        \\n        if (candies < 0) { //Fix for giving too many candies to last person\\n            ans[(i - 1) % num_people] += candies;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 796403,
                "title": "0-ms-c-solution-distribute-candies-to-people",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> l;\\n        int turn=1;\\n        for(int i=0;i<num_people;i++){\\n            l.push_back(0);    \\n        }\\n        while(candies>0){\\n            for(int i=0;i<num_people;i++){\\n                if(turn<candies){\\n                    l[i]+=turn;\\n                    candies-=turn;\\n                    turn+=1;\\n                }\\n                else if(candies>0){\\n                    l[i]+=candies;\\n                    candies-=candies;\\n                    break;\\n                }                \\n            }\\n        }\\n    return(l);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> l;\\n        int turn=1;\\n        for(int i=0;i<num_people;i++){\\n            l.push_back(0);    \\n        }\\n        while(candies>0){\\n            for(int i=0;i<num_people;i++){\\n                if(turn<candies){\\n                    l[i]+=turn;\\n                    candies-=turn;\\n                    turn+=1;\\n                }\\n                else if(candies>0){\\n                    l[i]+=candies;\\n                    candies-=candies;\\n                    break;\\n                }                \\n            }\\n        }\\n    return(l);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788026,
                "title": "ruby-solution-while-loop-and-get-index-of-person-by-modulo-operation",
                "content": "##### Leetcode: 1103. Distribute Candies to People.\\n\\nCreate loop that iterates until there more than zero candies and two variables amount of candies to give and index, index grows on each iteration and amount grows too. To get index of person to add amount of candies modulo operation could be implemented or rest of division index variable by number of people. In each iteration delete amount from candies. If there less candies than amount for gift give all the rest of candies to a person.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1103. Distribute Candies to People.\\n# https://leetcode.com/problems/distribute-candies-to-people/\\n# Runtime: 36 ms, faster than 85.71% of Ruby online submissions for Distribute Candies to People.\\n# Memory Usage: 9.7 MB, less than 14.29% of Ruby online submissions for Distribute Candies to People.\\n# @param {Integer} candies\\n# @param {Integer} num_people\\n# @return {Integer[]}\\ndef distribute_candies(candies, num_people)\\n    arr = Array.new(num_people,0)\\n    i,amount = 0,1\\n    while candies > 0\\n        if amount <= candies\\n            arr[i%num_people] += amount\\n            candies -= amount\\n            amount += 1\\n        else\\n            arr[i%num_people] += candies\\n            candies = 0\\n        end\\n        i += 1\\n    end\\n    arr\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1103. Distribute Candies to People.\\n# https://leetcode.com/problems/distribute-candies-to-people/\\n# Runtime: 36 ms, faster than 85.71% of Ruby online submissions for Distribute Candies to People.\\n# Memory Usage: 9.7 MB, less than 14.29% of Ruby online submissions for Distribute Candies to People.\\n# @param {Integer} candies\\n# @param {Integer} num_people\\n# @return {Integer[]}\\ndef distribute_candies(candies, num_people)\\n    arr = Array.new(num_people,0)\\n    i,amount = 0,1\\n    while candies > 0\\n        if amount <= candies\\n            arr[i%num_people] += amount\\n            candies -= amount\\n            amount += 1\\n        else\\n            arr[i%num_people] += candies\\n            candies = 0\\n        end\\n        i += 1\\n    end\\n    arr\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 694657,
                "title": "rust-simulate-distribute-processing-0ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn distribute_candies(candies: i32, num_people: i32) -> Vec<i32> {\\n        let mut res = vec![0; num_people as usize];\\n        let mut i = 0;\\n        let mut candies = candies;\\n        \\'outer: loop {\\n            for x in res.iter_mut() {\\n                i += 1;\\n                if candies < i {\\n                    *x += candies;\\n                    break \\'outer;\\n                } else {\\n                    candies -= i;\\n                    *x += i\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn distribute_candies(candies: i32, num_people: i32) -> Vec<i32> {\\n        let mut res = vec![0; num_people as usize];\\n        let mut i = 0;\\n        let mut candies = candies;\\n        \\'outer: loop {\\n            for x in res.iter_mut() {\\n                i += 1;\\n                if candies < i {\\n                    *x += candies;\\n                    break \\'outer;\\n                } else {\\n                    candies -= i;\\n                    *x += i\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670471,
                "title": "c-solution",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\nint* ret_array = malloc(num_people * sizeof(int));\\nint count, person;\\nfor (count=0; count<num_people; count++) ret_array[count]=0;\\ncount=1;\\nperson=0;\\n*returnSize = num_people;\\n    \\n// Loop until all candies gone, adding one to what\\'s given to each,\\n// and resetting person back to 0 when you\\'ve gone through all of them.\\nwhile (true) {\\n    if (candies<=0) return ret_array;\\n    if (count>candies) count=candies;\\n    ret_array[person++] += count;\\n    candies -= count++;\\n    if (person==num_people) person=0;\\n}\\nreturn -1; // We should never get here, though\\n}\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\nint* ret_array = malloc(num_people * sizeof(int));\\nint count, person;\\nfor (count=0; count<num_people; count++) ret_array[count]=0;\\ncount=1;\\nperson=0;\\n*returnSize = num_people;\\n    \\n// Loop until all candies gone, adding one to what\\'s given to each,\\n// and resetting person back to 0 when you\\'ve gone through all of them.\\nwhile (true) {\\n    if (candies<=0) return ret_array;\\n    if (count>candies) count=candies;\\n    ret_array[person++] += count;\\n    candies -= count++;\\n    if (person==num_people) person=0;\\n}\\nreturn -1; // We should never get here, though\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 659367,
                "title": "python3-28ms-beats-98-easy-iteration-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        num = 1\\n        while candies > 0:\\n        \\tfor i in range(num_people):\\n        \\t\\tres[i] += num\\n        \\t\\tcandies -= num\\n        \\t\\tif candies <= 0:\\n        \\t\\t\\tres[i] -= abs(candies)\\n        \\t\\t\\tbreak\\n        \\t\\tnum += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        num = 1\\n        while candies > 0:\\n        \\tfor i in range(num_people):\\n        \\t\\tres[i] += num\\n        \\t\\tcandies -= num\\n        \\t\\tif candies <= 0:\\n        \\t\\t\\tres[i] -= abs(candies)\\n        \\t\\t\\tbreak\\n        \\t\\tnum += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629995,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let i = 0;\\n    let ans = new Array(num_people).fill(0);\\n    while(candies - i > 0) {\\n        ans[i % num_people] += i+1;\\n        i++;\\n        candies -= i;\\n    }\\n    ans[i % num_people] += candies;\\n    return ans;\\n};",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let i = 0;\\n    let ans = new Array(num_people).fill(0);\\n    while(candies - i > 0) {\\n        ans[i % num_people] += i+1;\\n        i++;\\n        candies -= i;\\n    }\\n    ans[i % num_people] += candies;\\n    return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 585008,
                "title": "c-one-loop-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int c, int n) {\\n        vector<int> ans(n);\\n        for (int i=1; c > 0; ++i){\\n            ans[(i-1)%n] += min(i, c);\\n            c -= i;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int c, int n) {\\n        vector<int> ans(n);\\n        for (int i=1; c > 0; ++i){\\n            ans[(i-1)%n] += min(i, c);\\n            c -= i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 529674,
                "title": "python3-easy-to-understand-time-81-memory-100",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        n = 1\\n        while candies:\\n            for i in range(num_people):\\n                res[i] += n\\n                candies -= n\\n                if candies < 0:\\n                    res[i] -= n\\n                    res[i] += n + candies\\n                    return res\\n            \\n                n += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        n = 1\\n        while candies:\\n            for i in range(num_people):\\n                res[i] += n\\n                candies -= n\\n                if candies < 0:\\n                    res[i] -= n\\n                    res[i] += n + candies\\n                    return res\\n            \\n                n += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487953,
                "title": "python-3-purely-math-98-100-super-fast",
                "content": "The math algorithm is:\\n1, find how many rows are fully filled (1 row means rounds of having candies distributed for everyone)\\n2, distribute the residue candies in a round:\\ncompute how many people can still get routine number\\nthere is one guy who can\\'t get routine number\\nothers have no candies\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        full_row = int((-1 + math.sqrt(8*candies+1))/2/num_people)\\n        res = candies - full_row*num_people*(1+full_row*num_people)//2\\n        out = [j * full_row + (full_row-1) * full_row // 2 * num_people for j in range(1,num_people+1)]\\n        if res:\\n            full_col = int((-2*num_people*full_row-1+math.sqrt((2*num_people*full_row+1)**2 + 8*res))/2)\\n            res = res - (1+full_col)*full_col//2 - num_people * full_row * full_col\\n            out = [out[j-1] + j+ full_row * num_people for j in range(1,full_col+1)] + \\\\\\n                    [out[full_col]+res] + out[full_col+1:]      \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        full_row = int((-1 + math.sqrt(8*candies+1))/2/num_people)\\n        res = candies - full_row*num_people*(1+full_row*num_people)//2\\n        out = [j * full_row + (full_row-1) * full_row // 2 * num_people for j in range(1,num_people+1)]\\n        if res:\\n            full_col = int((-2*num_people*full_row-1+math.sqrt((2*num_people*full_row+1)**2 + 8*res))/2)\\n            res = res - (1+full_col)*full_col//2 - num_people * full_row * full_col\\n            out = [out[j-1] + j+ full_row * num_people for j in range(1,full_col+1)] + \\\\\\n                    [out[full_col]+res] + out[full_col+1:]      \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487353,
                "title": "without-min",
                "content": "Brute force but without the `min` call in every iteration. Instead, add the final (non-positive) number of cookies to the last person who got some. So a little less brute :-)\\n```\\npublic int[] distributeCandies(int c, int n) {\\n    int[] p = new int[n];\\n    int i = 0;\\n    while (c > 0) {\\n        p[i % n] += ++i;\\n        c -= i;\\n    }\\n    p[--i % n] += c;\\n    return p;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int c, int n) {\\n    int[] p = new int[n];\\n    int i = 0;\\n    while (c > 0) {\\n        p[i % n] += ++i;\\n        c -= i;\\n    }\\n    p[--i % n] += c;\\n    return p;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478235,
                "title": "easy-understandable-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        long int sum=0;\\n        vector < int > v(num_people,0);\\n        bool status=1;\\n        int  count=1;\\n        \\n        while(status)\\n        {\\n            for(int i=0;i<v.size();i++)\\n            {\\n                \\n            if(count+sum>candies)\\n            {\\n                v[i]+=candies-sum;\\n                status=0;\\n                break;\\n            }\\n                \\n                v[i]+=count;\\n                sum+=count++;\\n                \\n            }      \\n        }\\n        \\n        \\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        long int sum=0;\\n        vector < int > v(num_people,0);\\n        bool status=1;\\n        int  count=1;\\n        \\n        while(status)\\n        {\\n            for(int i=0;i<v.size();i++)\\n            {\\n                \\n            if(count+sum>candies)\\n            {\\n                v[i]+=candies-sum;\\n                status=0;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 456045,
                "title": "c-time-o-n-space-o-n",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> distributeCandies(int candies, \\n                                  int num_people) \\n    {\\n        vector<int> result(num_people, 0);\\n        \\n        int index = 0;        \\n        int count = 1;\\n        int sum = 0;\\n\\n        while(true)\\n        {             \\n            result[index] += count;\\n            \\n            // Keep accumulating the sum with the current count,\\n            // then update the counter.\\n            sum += (count++);\\n            \\n            // rotate index.\\n            index = (index +1) %num_people;\\n            \\n            // current accumulated sum cannot be bigger than the total candies\\n            // after adding the next counter value. No more next round if it is bigger.\\n            if((sum +count) >candies)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Add the remaining candies to the last person.\\n        result[index] += (candies -sum);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> distributeCandies(int candies, \\n                                  int num_people) \\n    {\\n        vector<int> result(num_people, 0);\\n        \\n        int index = 0;        \\n        int count = 1;\\n        int sum = 0;\\n\\n        while(true)\\n        {             \\n            result[index] += count;\\n            \\n            // Keep accumulating the sum with the current count,\\n            // then update the counter.\\n            sum += (count++);\\n            \\n            // rotate index.\\n            index = (index +1) %num_people;\\n            \\n            // current accumulated sum cannot be bigger than the total candies\\n            // after adding the next counter value. No more next round if it is bigger.\\n            if((sum +count) >candies)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Add the remaining candies to the last person.\\n        result[index] += (candies -sum);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440742,
                "title": "java-faster-than-92-solution-with-comments",
                "content": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint i = 0;\\n\\tint j = 1;\\n\\tint[] arr = new int[num_people];\\n\\n\\twhile (candies > 0) {\\n\\t\\t// distribute candies and update values\\n\\t\\tarr[i++] += j;\\n\\t\\tcandies -= j;\\n\\n\\t\\t// check if we need to start from the first\\n\\t\\tif (i > num_people - 1)\\n\\t\\t\\ti = 0;\\n\\n\\t\\t// check if we have enough candies to increment j\\n\\t\\t// otherwise, assign remaining candies to j\\n\\t\\tj = (j + 1 <= candies) ? j + 1 : candies;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint i = 0;\\n\\tint j = 1;\\n\\tint[] arr = new int[num_people];\\n\\n\\twhile (candies > 0) {\\n\\t\\t// distribute candies and update values\\n\\t\\tarr[i++] += j;\\n\\t\\tcandies -= j;\\n\\n\\t\\t// check if we need to start from the first\\n\\t\\tif (i > num_people - 1)\\n\\t\\t\\ti = 0;\\n\\n\\t\\t// check if we have enough candies to increment j\\n\\t\\t// otherwise, assign remaining candies to j\\n\\t\\tj = (j + 1 <= candies) ? j + 1 : candies;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399925,
                "title": "c-4ms-faster-than-64-38-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int sum=0,i=1;\\n        while((sum+i)<=candies){\\n            ret[(i-1)%num_people] += i;\\n            sum+=i;\\n            ++i;\\n        }\\n        if(sum!=candies)\\n            ret[(i-1)%num_people]+= candies-sum;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int sum=0,i=1;\\n        while((sum+i)<=candies){\\n            ret[(i-1)%num_people] += i;\\n            sum+=i;\\n            ++i;\\n        }\\n        if(sum!=candies)\\n            ret[(i-1)%num_people]+= candies-sum;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394765,
                "title": "javascript-simple-beats-86",
                "content": "```\\nlet op = new Array(num_people).fill(0), i = 0, c = 1\\n\\nwhile (candies > 0) {\\n\\tif (candies <= c) c = candies\\n\\top[i] += c\\n\\tcandies -= c\\n\\ti = (i + 1) % num_people\\n\\tc++\\n}\\n\\nreturn op\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet op = new Array(num_people).fill(0), i = 0, c = 1\\n\\nwhile (candies > 0) {\\n\\tif (candies <= c) c = candies\\n\\top[i] += c\\n\\tcandies -= c\\n\\ti = (i + 1) % num_people\\n\\tc++\\n}\\n\\nreturn op\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383068,
                "title": "python-sum-of-n-numbers-with-binary-search-with-thought-process",
                "content": "So the idea is:\\n1. Find how many times we can distribute the candies to all `num_people` i.e.\\n\\t```python\\n\\tgc = 0 # Start with zeroth round\\n\\ttarget = (num_people * (num_people+1))//2 # Number of candies required for zeroth round \\n\\twhile target <= candies:\\n\\t\\tfor i in range(num_people):\\n\\t\\t\\tres[i] += (gc * num_people) + (i + 1)\\n\\n\\t\\tgc += 1\\n\\t\\tcandies -= target\\n\\t\\t# Now for next round the target will change e.g.\\n\\t\\t# For n = 3, for first round distribution, we need (n*(n+1))/2\\n\\t\\t# but for second round, every person will need n i.e. 3 extra candies, so overall n**2 extra candies\\n\\t\\ttarget += num_people ** 2\\n\\t```\\n2. Now, after step one, we will be left with candies which can\\'t be distributed equally to all n people, so the idea to to use binary search to find the index till when we can continue distributing the required amout of candies. Once we have that index, we can distribute the candies till `i`th person in required fashion and give remaining candies to the `(i+1)`th person. i.e.\\n\\t```\\n\\tif candies:\\n            offset = num_people * gc # We need this offset to indicated that we in some xth distribution round and we need this much extra candies for each person in comparison of zeroth round.\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n\\t```\\n\\t\\nFull Soultion here:\\n```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        gc = 0\\n        res = [0] * num_people\\n        \\n        def binarySearch(l, r, candies, offset):\\n            while l <= r:\\n                mid = (l + r)//2\\n                \\n                n_sum = (mid * (mid+1))//2\\n                n_sum += offset * mid\\n                if n_sum == candies:\\n                    return mid\\n                elif n_sum < candies:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            \\n            return l\\n        \\n        target = (num_people * (num_people+1))//2 \\n        while target <= candies:\\n            for i in range(num_people):\\n                res[i] += (gc * num_people) + (i + 1)\\n                \\n            gc += 1\\n            candies -= target\\n            target += num_people * num_people\\n\\n        if candies:\\n            offset = num_people * gc\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Search"
                ],
                "code": "```python\\n\\tgc = 0 # Start with zeroth round\\n\\ttarget = (num_people * (num_people+1))//2 # Number of candies required for zeroth round \\n\\twhile target <= candies:\\n\\t\\tfor i in range(num_people):\\n\\t\\t\\tres[i] += (gc * num_people) + (i + 1)\\n\\n\\t\\tgc += 1\\n\\t\\tcandies -= target\\n\\t\\t# Now for next round the target will change e.g.\\n\\t\\t# For n = 3, for first round distribution, we need (n*(n+1))/2\\n\\t\\t# but for second round, every person will need n i.e. 3 extra candies, so overall n**2 extra candies\\n\\t\\ttarget += num_people ** 2\\n\\t```\n```\\n\\tif candies:\\n            offset = num_people * gc # We need this offset to indicated that we in some xth distribution round and we need this much extra candies for each person in comparison of zeroth round.\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n\\t```\n```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        gc = 0\\n        res = [0] * num_people\\n        \\n        def binarySearch(l, r, candies, offset):\\n            while l <= r:\\n                mid = (l + r)//2\\n                \\n                n_sum = (mid * (mid+1))//2\\n                n_sum += offset * mid\\n                if n_sum == candies:\\n                    return mid\\n                elif n_sum < candies:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            \\n            return l\\n        \\n        target = (num_people * (num_people+1))//2 \\n        while target <= candies:\\n            for i in range(num_people):\\n                res[i] += (gc * num_people) + (i + 1)\\n                \\n            gc += 1\\n            candies -= target\\n            target += num_people * num_people\\n\\n        if candies:\\n            offset = num_people * gc\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380564,
                "title": "easy-concise-c-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Distribute Candies to People.\\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Distribute Candies to People.\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        \\n        vector<int> res(num_people, 0);\\n        int i = 0;\\n        int k = 1;\\n        \\n        while(candies > 0)\\n        {\\n            if(candies < k)\\n            {\\n                res[i] += candies;\\n                break;\\n            }\\n            \\n            res[i] += k;\\n            candies -= k;\\n            \\n            if(i == num_people-1)\\n                i = 0;\\n            else\\n                i++;\\n            k++;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Distribute Candies to People.\\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Distribute Candies to People.\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        \\n        vector<int> res(num_people, 0);\\n        int i = 0;\\n        int k = 1;\\n        \\n        while(candies > 0)\\n        {\\n            if(candies < k)\\n            {\\n                res[i] += candies;\\n                break;\\n            }\\n            \\n            res[i] += k;\\n            candies -= k;\\n            \\n            if(i == num_people-1)\\n                i = 0;\\n            else\\n                i++;\\n            k++;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 374940,
                "title": "java-1ms-quick-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int i = 0;\\n        int count = 1;\\n        while (candies > 0){\\n            res[i] += Math.min(count, candies);\\n            candies -= count;\\n            count++;\\n            i++;\\n            i = i % num_people;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int i = 0;\\n        int count = 1;\\n        while (candies > 0){\\n            res[i] += Math.min(count, candies);\\n            candies -= count;\\n            count++;\\n            i++;\\n            i = i % num_people;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361961,
                "title": "golang-beginner-solution",
                "content": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tresult := make([]int, num_people)\\n\\tpidx := 0\\n\\tctr := 1\\n\\tfor candies > 0 {\\n\\t\\t// fmt.Println(pidx, candies, ctr)\\n\\t\\tif pidx == num_people {\\n\\t\\t\\tpidx = 0\\n\\t\\t}\\n\\t\\tif candies < ctr {\\n\\t\\t\\tresult[pidx] += candies\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tresult[pidx] += ctr\\n\\t\\tcandies -= ctr\\n\\t\\tctr++\\n\\t\\tpidx++\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tresult := make([]int, num_people)\\n\\tpidx := 0\\n\\tctr := 1\\n\\tfor candies > 0 {\\n\\t\\t// fmt.Println(pidx, candies, ctr)\\n\\t\\tif pidx == num_people {\\n\\t\\t\\tpidx = 0\\n\\t\\t}\\n\\t\\tif candies < ctr {\\n\\t\\t\\tresult[pidx] += candies\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tresult[pidx] += ctr\\n\\t\\tcandies -= ctr\\n\\t\\tctr++\\n\\t\\tpidx++\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358972,
                "title": "kotlin-runtime-148-ms-memory-usage-31-8-mb",
                "content": "```\\nfun distributeCandies(candies: Int, num_people: Int): IntArray {\\n    val distrArray = IntArray(num_people)\\n    var accumulator = 0 // candies accumulator per person\\n    var index = 0   // distribution index\\n    var mCandies = candies // val can\\'t be reassigned\\n\\n    while (mCandies > accumulator++) {\\n        distrArray[index++ % num_people] += accumulator // ensure index is in num_people scope using mod\\n        mCandies -= accumulator\\n    }\\n    return if (mCandies > 0) {\\n        distrArray[index % num_people] += mCandies\\n        distrArray\\n    } else distrArray\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun distributeCandies(candies: Int, num_people: Int): IntArray {\\n    val distrArray = IntArray(num_people)\\n    var accumulator = 0 // candies accumulator per person\\n    var index = 0   // distribution index\\n    var mCandies = candies // val can\\'t be reassigned\\n\\n    while (mCandies > accumulator++) {\\n        distrArray[index++ % num_people] += accumulator // ensure index is in num_people scope using mod\\n        mCandies -= accumulator\\n    }\\n    return if (mCandies > 0) {\\n        distrArray[index % num_people] += mCandies\\n        distrArray\\n    } else distrArray\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325796,
                "title": "javascript-solution-understandable",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let result = new Array(num_people).fill(0);\\n    for(let give=0; candies>0; candies-=give){\\n        result[give%num_people] += Math.min(candies, ++give);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let result = new Array(num_people).fill(0);\\n    for(let give=0; candies>0; candies-=give){\\n        result[give%num_people] += Math.min(candies, ++give);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325345,
                "title": "two-python-solutions-brute-force-and-mathematical",
                "content": "Brute Force: just translate the problem into code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        idx, cur, total = 0, 1, 0;\\n        res = [0] * num_people;\\n        while(total + cur <= candies):\\n            res[idx] += cur;\\n            idx = (idx + 1) % num_people;\\n            total += cur;\\n            cur += 1;\\n        if(total != candies): res[idx] += (candies - total);\\n        return res;\\n```\\n\\nMathematical: calculate how many turns the index will be iterated through\\n```\\nimport math;\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        res = [0] * num_people;\\n        tact_num = int((math.sqrt(1 + 8 * candies) - 1) / 2);\\n        tact_turn = tact_num // num_people;\\n        total = (1 + tact_num) * tact_num // 2;\\n        for i in range(num_people):\\n            turn = tact_turn + 1 if(tact_num % num_people > i) else tact_turn;\\n            res[i] = int((i + 1) * turn + 0.5 * turn * (turn - 1) * num_people);\\n        res[tact_num % num_people] += (candies - total);\\n        return res;\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        idx, cur, total = 0, 1, 0;\\n        res = [0] * num_people;\\n        while(total + cur <= candies):\\n            res[idx] += cur;\\n            idx = (idx + 1) % num_people;\\n            total += cur;\\n            cur += 1;\\n        if(total != candies): res[idx] += (candies - total);\\n        return res;\\n```\n```\\nimport math;\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        res = [0] * num_people;\\n        tact_num = int((math.sqrt(1 + 8 * candies) - 1) / 2);\\n        tact_turn = tact_num // num_people;\\n        total = (1 + tact_num) * tact_num // 2;\\n        for i in range(num_people):\\n            turn = tact_turn + 1 if(tact_num % num_people > i) else tact_turn;\\n            res[i] = int((i + 1) * turn + 0.5 * turn * (turn - 1) * num_people);\\n        res[tact_num % num_people] += (candies - total);\\n        return res;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325108,
                "title": "java-0ms-o-n-solution-using-gauss-formula",
                "content": "Here is a solution that uses Gauss\\' formula for calculating sum of a series.\\nShould take O(2*num_people) time.\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] r = new int[num_people];\\n        \\n\\t\\t// find number of people that could get candies if just kept handing them over to new person each time\\n        int x = (int)Math.round((1. + Math.sqrt(1. + 4. * candies)) / 2.);\\n\\t\\t\\n\\t\\t// find number of full passes we can do over array of num_people\\n        int fullRows = x / num_people;\\n        \\n\\t\\t// for each person in the array give them all the candies they can get when only doing full array passes\\n        for (int i = 0; i < num_people; i++) {\\n            r[i] = (fullRows * (2 * (i + 1) + (fullRows - 1) * num_people)) / 2;\\n        }\\n        \\n\\t\\t// how many candie giving actions were just performed if we did those separately without summing\\n        int dist_pos = fullRows * num_people;\\n        \\n\\t\\t// calculate remaining candies to be distributed\\n        candies -= dist_pos*(dist_pos + 1) / 2;\\n        \\n\\t\\t// figure out the number of candies that we gave to last person\\n        int last = fullRows > 0 ? (r[num_people - 1] - ((fullRows - 1) * (2 * (num_people) + (fullRows - 2) * num_people)) / 2) : 0;\\n\\n\\t\\t// distribute all the remaining candies\\n\\t\\t// need while here because there can be less candies than we would usually give to a person\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                int n = Math.min(candies, last + 1);\\n\\n                if (n == 0) {\\n                    break;\\n                }\\n\\n                candies -= n;\\n                r[i] += n;\\n                last++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] r = new int[num_people];\\n        \\n\\t\\t// find number of people that could get candies if just kept handing them over to new person each time\\n        int x = (int)Math.round((1. + Math.sqrt(1. + 4. * candies)) / 2.);\\n\\t\\t\\n\\t\\t// find number of full passes we can do over array of num_people\\n        int fullRows = x / num_people;\\n        \\n\\t\\t// for each person in the array give them all the candies they can get when only doing full array passes\\n        for (int i = 0; i < num_people; i++) {\\n            r[i] = (fullRows * (2 * (i + 1) + (fullRows - 1) * num_people)) / 2;\\n        }\\n        \\n\\t\\t// how many candie giving actions were just performed if we did those separately without summing\\n        int dist_pos = fullRows * num_people;\\n        \\n\\t\\t// calculate remaining candies to be distributed\\n        candies -= dist_pos*(dist_pos + 1) / 2;\\n        \\n\\t\\t// figure out the number of candies that we gave to last person\\n        int last = fullRows > 0 ? (r[num_people - 1] - ((fullRows - 1) * (2 * (num_people) + (fullRows - 2) * num_people)) / 2) : 0;\\n\\n\\t\\t// distribute all the remaining candies\\n\\t\\t// need while here because there can be less candies than we would usually give to a person\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                int n = Math.min(candies, last + 1);\\n\\n                if (n == 0) {\\n                    break;\\n                }\\n\\n                candies -= n;\\n                r[i] += n;\\n                last++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324770,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        li, i = [0] * n, 1\\n        while candies > 0: \\n            li[(i-1)%n] += min(i, candies)\\n            candies, i = candies-i, i+1\\n        return li\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        li, i = [0] * n, 1\\n        while candies > 0: \\n            li[(i-1)%n] += min(i, candies)\\n            candies, i = candies-i, i+1\\n        return li\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324101,
                "title": "faster-than-100-and-memory-less-than-100-python-simple-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]*num_people\\n        i = 0\\n        k = 1\\n        while True:\\n        \\n            if candies-k <= 0:\\n                ans[i] += candies\\n                break\\n            else:\\n                ans[i] += k\\n                candies -= k\\n                k+=1\\n                i+=1\\n                if i == num_people:\\n                    i = 0\\n                    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]*num_people\\n        i = 0\\n        k = 1\\n        while True:\\n        \\n            if candies-k <= 0:\\n                ans[i] += candies\\n                break\\n            else:\\n                ans[i] += k\\n                candies -= k\\n                k+=1\\n                i+=1\\n                if i == num_people:\\n                    i = 0\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324057,
                "title": "java-simulation-o-sqrt-n-beats-100",
                "content": "We are simulating each step of distribution. For each iteration increment the number of candies to give to a next person and also calculate the index of that person in the array. Lastly decrement number of candies left by number of candies we gave.\\nComplexities: time is O(sqrt(candies)) - on each step the number of candies left will be decreasing proportional to sqrt(). Space - O(1) - just few state variables, am excluding resulting array from analysis. \\n```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int idx = 0;\\n        int c = 1;\\n        \\n        while(candies > 0) {\\n            //num of candies to distribute on this step. Need to check if we have enough, otherwise\\n            //use the remainder of candies\\n            res[idx] += (c < candies) ? c : candies;\\n            //next person - need to start from 0 if it was a last one\\n            idx = (idx == num_people - 1) ? 0 : idx + 1;\\n            //decrement number of candies left\\n            candies -= c++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int idx = 0;\\n        int c = 1;\\n        \\n        while(candies > 0) {\\n            //num of candies to distribute on this step. Need to check if we have enough, otherwise\\n            //use the remainder of candies\\n            res[idx] += (c < candies) ? c : candies;\\n            //next person - need to start from 0 if it was a last one\\n            idx = (idx == num_people - 1) ? 0 : idx + 1;\\n            //decrement number of candies left\\n            candies -= c++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324015,
                "title": "simple-and-and-efficient-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {        \\n        int[] distribution = new int[num_people];\\n        int current = 1;\\n        while(candies > 0){\\n            for(int i = 0; i < num_people; i++){\\n                if(candies - current >= 0){\\n                    distribution[i] += current;\\n                    candies = candies - current;\\n                    current += 1;\\n                }\\n                else if(candies > 0){\\n                    distribution[i] += candies;\\n                    candies -= candies;                    \\n                }\\n                else break;                \\n            }                \\n        }\\n        return distribution;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {        \\n        int[] distribution = new int[num_people];\\n        int current = 1;\\n        while(candies > 0){\\n            for(int i = 0; i < num_people; i++){\\n                if(candies - current >= 0){\\n                    distribution[i] += current;\\n                    candies = candies - current;\\n                    current += 1;\\n                }\\n                else if(candies > 0){\\n                    distribution[i] += candies;\\n                    candies -= candies;                    \\n                }\\n                else break;                \\n            }                \\n        }\\n        return distribution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323872,
                "title": "0ms-go-solution",
                "content": "func distributeCandies(candies int, num_people int) []int {\\n\\tif num_people <= 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tvar out = make([]int, num_people)\\n\\n\\tif candies <= 0 {\\n\\t\\treturn out\\n\\t}\\n\\n\\tvar equ bool\\n\\tvar N = num_people\\n\\tvar count = 1\\n\\tvar flag = 1\\n\\tvar a, b int\\n\\tfor {\\n\\t\\tfmt.Println((N + count) * num_people / 2)\\n\\t\\tif (N+count)*num_people/2 > candies {\\n\\t\\t\\tequ = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif (N+count)*num_people/2 == candies {\\n\\t\\t\\tequ = true\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tflag++\\n\\t\\ta, b = count, N\\n\\t\\tcount = count + (flag-1)*num_people + 1\\n\\t\\tN = N + (flag-1)*num_people + num_people\\n\\t}\\n\\n\\tif !equ && a != 0 {\\n\\t\\tflag--\\n\\t}\\n\\tif a == 0 || equ {\\n\\t\\ta, b = count, N\\n\\t}\\n\\n\\tvar can = candies\\n\\tvar i = 0\\n\\tvar k = a\\n\\n\\tfor i < num_people {\\n\\t\\tif k <= can {\\n\\t\\t\\tout[i] = k\\n\\t\\t}\\n\\t\\tif k > can {\\n\\t\\t\\tout[i] = can\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tcan -= k\\n\\t\\tk += flag\\n\\t\\ti++\\n\\t}\\n\\n\\tif can <= 0 && (equ == true || flag == 1) {\\n\\t\\tfmt.Println(out)\\n\\t\\treturn out\\n\\t}\\n\\n\\tcan = candies - (a+b)*num_people/2\\n\\ti = 0\\n\\n\\tci := count - out[0]\\n\\tfor can >= 0 {\\n\\t\\tif can <= ci {\\n\\t\\t\\tout[i] += can\\n\\t\\t}\\n\\t\\tif can > ci {\\n\\t\\t\\tout[i] += ci\\n\\t\\t}\\n\\t\\ti++\\n\\t\\tcan -= ci\\n\\t\\tci++\\n\\t}\\n\\n\\tfmt.Println(out)\\n\\treturn out\\n}",
                "solutionTags": [],
                "code": "func distributeCandies(candies int, num_people int) []int {\\n\\tif num_people <= 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tvar out = make([]int, num_people)\\n\\n\\tif candies <= 0 {\\n\\t\\treturn out\\n\\t}\\n\\n\\tvar equ bool\\n\\tvar N = num_people\\n\\tvar count = 1\\n\\tvar flag = 1\\n\\tvar a, b int\\n\\tfor {\\n\\t\\tfmt.Println((N + count) * num_people / 2)\\n\\t\\tif (N+count)*num_people/2 > candies {\\n\\t\\t\\tequ = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif (N+count)*num_people/2 == candies {\\n\\t\\t\\tequ = true\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tflag++\\n\\t\\ta, b = count, N\\n\\t\\tcount = count + (flag-1)*num_people + 1\\n\\t\\tN = N + (flag-1)*num_people + num_people\\n\\t}\\n\\n\\tif !equ && a != 0 {\\n\\t\\tflag--\\n\\t}\\n\\tif a == 0 || equ {\\n\\t\\ta, b = count, N\\n\\t}\\n\\n\\tvar can = candies\\n\\tvar i = 0\\n\\tvar k = a\\n\\n\\tfor i < num_people {\\n\\t\\tif k <= can {\\n\\t\\t\\tout[i] = k\\n\\t\\t}\\n\\t\\tif k > can {\\n\\t\\t\\tout[i] = can\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tcan -= k\\n\\t\\tk += flag\\n\\t\\ti++\\n\\t}\\n\\n\\tif can <= 0 && (equ == true || flag == 1) {\\n\\t\\tfmt.Println(out)\\n\\t\\treturn out\\n\\t}\\n\\n\\tcan = candies - (a+b)*num_people/2\\n\\ti = 0\\n\\n\\tci := count - out[0]\\n\\tfor can >= 0 {\\n\\t\\tif can <= ci {\\n\\t\\t\\tout[i] += can\\n\\t\\t}\\n\\t\\tif can > ci {\\n\\t\\t\\tout[i] += ci\\n\\t\\t}\\n\\t\\ti++\\n\\t\\tcan -= ci\\n\\t\\tci++\\n\\t}\\n\\n\\tfmt.Println(out)\\n\\treturn out\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 323722,
                "title": "javascript-100-time-100-space-not-brute-force",
                "content": "This approach attempts to reduce the number of iterations required by brute force for large candy counts. I\\'d like to compare the complexity with the brute froce approach, but I\\'m not certain what the complexity of this algorithm is due to the first loop - it depends on the ratio of candies to people. The last two loops are O(people).\\n\\n```javascript\\n/**\\n * @param {number} candies The number of candies to distribute.\\n * @param {number} p The number of people to receive candies.\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, p) {\\n  let numFullRows = 0;\\n  \\n  /**\\n   * Determine the number of full rows. This is\\n   * done by calculating the number of candies\\n   * required by n rows. When the required number\\n   * of candies is greater than the number of\\n   * candies we have, the loop is exited and we\\n   * know the number of full rows is one less than\\n   * the number of full rows from the last\\n   * iteration of the loop (hence --numFullRows).\\n   */\\n  let max = 0;\\n  let k = 0;\\n  while (max <= candies) {\\n    ++numFullRows;\\n    max = p * k * p + numFullRows * ((p * (p + 1)) / 2);\\n    k += numFullRows;\\n  }\\n  --numFullRows;\\n  \\n  /**\\n   * Now that the number of full rows is known,\\n   * it can be calculated that each person is\\n   * guaranteed to receive a certain number of\\n   * candies. I\\'ll call this amount \"base\".\\n   * Calculating it now, instead of for every\\n   * person, will save a little time in the next\\n   * loop.\\n   */\\n  let base = 0;\\n  for (let i = 1; i < numFullRows; ++i) {\\n    base += i * p;\\n  }\\n  \\n  /**\\n   * Initialize the result array with all\\n   * completed rows. For each i = 1 ... p,\\n   * this is: base + i * numFullRows.\\n   *\\n   * This loop is not combined with the last loop\\n   * because the last loop needs an accurate count\\n   * of remaining candies for the (potentially)\\n   * partial last row.\\n   */\\n  let result = [];\\n  for (let i = 1; i <= p; ++i) {\\n    let count = base + i * numFullRows;\\n    candies -= count;\\n    result.push(count);\\n  }\\n  \\n  /**\\n   * Fill in the remaining number of candies\\n   * from left to right. The number of candies\\n   * to give the i-th person during the n-th\\n   * pass is: 1 + (p * (n - 1)) + i. numFullRows\\n   * already represents n - 1, so we use it\\n   * instead.\\n   */\\n  let i = 0;\\n  while (candies > 0) {\\n    let top = 1 + (p * numFullRows) + i;\\n    if (top > candies) top = candies;\\n    result[i++] += top;\\n    candies -= top;\\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number} candies The number of candies to distribute.\\n * @param {number} p The number of people to receive candies.\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, p) {\\n  let numFullRows = 0;\\n  \\n  /**\\n   * Determine the number of full rows. This is\\n   * done by calculating the number of candies\\n   * required by n rows. When the required number\\n   * of candies is greater than the number of\\n   * candies we have, the loop is exited and we\\n   * know the number of full rows is one less than\\n   * the number of full rows from the last\\n   * iteration of the loop (hence --numFullRows).\\n   */\\n  let max = 0;\\n  let k = 0;\\n  while (max <= candies) {\\n    ++numFullRows;\\n    max = p * k * p + numFullRows * ((p * (p + 1)) / 2);\\n    k += numFullRows;\\n  }\\n  --numFullRows;\\n  \\n  /**\\n   * Now that the number of full rows is known,\\n   * it can be calculated that each person is\\n   * guaranteed to receive a certain number of\\n   * candies. I\\'ll call this amount \"base\".\\n   * Calculating it now, instead of for every\\n   * person, will save a little time in the next\\n   * loop.\\n   */\\n  let base = 0;\\n  for (let i = 1; i < numFullRows; ++i) {\\n    base += i * p;\\n  }\\n  \\n  /**\\n   * Initialize the result array with all\\n   * completed rows. For each i = 1 ... p,\\n   * this is: base + i * numFullRows.\\n   *\\n   * This loop is not combined with the last loop\\n   * because the last loop needs an accurate count\\n   * of remaining candies for the (potentially)\\n   * partial last row.\\n   */\\n  let result = [];\\n  for (let i = 1; i <= p; ++i) {\\n    let count = base + i * numFullRows;\\n    candies -= count;\\n    result.push(count);\\n  }\\n  \\n  /**\\n   * Fill in the remaining number of candies\\n   * from left to right. The number of candies\\n   * to give the i-th person during the n-th\\n   * pass is: 1 + (p * (n - 1)) + i. numFullRows\\n   * already represents n - 1, so we use it\\n   * instead.\\n   */\\n  let i = 0;\\n  while (candies > 0) {\\n    let top = 1 + (p * numFullRows) + i;\\n    if (top > candies) top = candies;\\n    result[i++] += top;\\n    candies -= top;\\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323534,
                "title": "c-binary-search-solution-0-ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        if(candies < 0 || num_people<=0){\\n            return res;\\n        }\\n        long long int l = 0, r = 100000;\\n        long long int ans=0;\\n        while(l<=r){\\n            long long int m = (l+r)/2;\\n            long long int sum = m*num_people;\\n            sum=sum*(sum+1)/2;\\n            if(sum>candies){\\n                r=m-1;\\n            }\\n            else{\\n                ans=m;\\n                l=m+1;\\n            }\\n        }\\n        for(int i=0;i<num_people;i++){\\n            long long int temp = ans*(2*(i+1)+(ans-1)*num_people)/2;\\n            res[i]=temp;\\n        }\\n        long long int rem = ans*num_people;\\n        rem = rem*(rem+1)/2;\\n        rem = candies - rem;\\n        for(int i=0;i<num_people and rem>0;i++){\\n            res[i] += min((ans)*num_people+(i+1), rem);\\n            rem-=(ans)*num_people+(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        if(candies < 0 || num_people<=0){\\n            return res;\\n        }\\n        long long int l = 0, r = 100000;\\n        long long int ans=0;\\n        while(l<=r){\\n            long long int m = (l+r)/2;\\n            long long int sum = m*num_people;\\n            sum=sum*(sum+1)/2;\\n            if(sum>candies){\\n                r=m-1;\\n            }\\n            else{\\n                ans=m;\\n                l=m+1;\\n            }\\n        }\\n        for(int i=0;i<num_people;i++){\\n            long long int temp = ans*(2*(i+1)+(ans-1)*num_people)/2;\\n            res[i]=temp;\\n        }\\n        long long int rem = ans*num_people;\\n        rem = rem*(rem+1)/2;\\n        rem = candies - rem;\\n        for(int i=0;i<num_people and rem>0;i++){\\n            res[i] += min((ans)*num_people+(i+1), rem);\\n            rem-=(ans)*num_people+(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323384,
                "title": "straightforward-python-solution",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = num_people * [0]\\n        i = 0\\n        while candies > 0:\\n            if candies >= i + 1:\\n                arr[i % num_people] += i + 1\\n                candies -= i + 1\\n            else:\\n                arr[i % num_people] += candies\\n                break\\n            i += 1\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = num_people * [0]\\n        i = 0\\n        while candies > 0:\\n            if candies >= i + 1:\\n                arr[i % num_people] += i + 1\\n                candies -= i + 1\\n            else:\\n                arr[i % num_people] += candies\\n                break\\n            i += 1\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323319,
                "title": "python-math-faster-than-brute-force-and-sqrt-candies",
                "content": "We first calculate how many (maximum) `turns` can we hand out candies such that every people get candies in this turn.\\nThen if we still have candies, give them out starting from the first person.\\n\\nThe time complexity is faster than brute force.\\n`T(brute_force) = O(#gives_out) = O(#people * #turns)`\\n`T(math_solution) = O(#turns + #people) > T(brute_force)`\\n\\nThe time complexity of brute force can also be denoted as `sqrt(#candies)` because `O(#candies) = O(1 + 2 + ... + #gives_out) = O(#gives_out^2)`.\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        base = (1 + n) * n / 2\\n        total = turns = 0\\n        while total + base < candies:\\n            total += base\\n            base += n * n\\n            turns += 1\\n\\t\\tfor i in xrange(len(res)):\\n\\t\\t\\tres[i] = turns * (i + 1) + n * (turns - 1) * turns / 2\\n        k = turns * n\\n        i = 0\\n        distributed = sum(res)\\n        while distributed < candies:\\n            k += 1\\n            res[i] += min(k, candies - distributed)\\n            distributed += k\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        base = (1 + n) * n / 2\\n        total = turns = 0\\n        while total + base < candies:\\n            total += base\\n            base += n * n\\n            turns += 1\\n\\t\\tfor i in xrange(len(res)):\\n\\t\\t\\tres[i] = turns * (i + 1) + n * (turns - 1) * turns / 2\\n        k = turns * n\\n        i = 0\\n        distributed = sum(res)\\n        while distributed < candies:\\n            k += 1\\n            res[i] += min(k, candies - distributed)\\n            distributed += k\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323316,
                "title": "c-share-my-solution-time-complexity-is-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> r(num_people,0);\\n        int idx=0;\\n        while(candies>0){\\n            if(candies-idx-1<0)\\n                r[idx%num_people]+=candies,candies=0;\\n            else\\n                r[idx%num_people]+=idx+1,candies-=idx+1;\\n            idx++;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> r(num_people,0);\\n        int idx=0;\\n        while(candies>0){\\n            if(candies-idx-1<0)\\n                r[idx%num_people]+=candies,candies=0;\\n            else\\n                r[idx%num_people]+=idx+1,candies-=idx+1;\\n            idx++;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323296,
                "title": "python-brute-force-simulation",
                "content": "In a brute force way, distribute the candies to each person in round robin fashion.\\n\\n```\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        res = [0] * n\\n        i = 0\\n        cur = 1\\n        while candies >= cur:\\n            res[i] += cur\\n            candies -= cur\\n            cur += 1\\n            i = (i + 1) % n\\n        res[i] += candies\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        res = [0] * n\\n        i = 0\\n        cur = 1\\n        while candies >= cur:\\n            res[i] += cur\\n            candies -= cur\\n            cur += 1\\n            i = (i + 1) % n\\n        res[i] += candies\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4096589,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] DistributeCandies(int candies, int num_people) {\\n        int i=1,k=0,j=0;\\n        int[] result=new int[num_people];\\n        while(k+i<candies){\\n            for(j=0;(k+i)<candies && j<num_people;j++){\\n                result[j]+= i;\\n                k+=i;\\n                i++;\\n            }\\n        }\\n        if(j==num_people)\\n            j=0;\\n\\n        result[j] += candies-k;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] DistributeCandies(int candies, int num_people) {\\n        int i=1,k=0,j=0;\\n        int[] result=new int[num_people];\\n        while(k+i<candies){\\n            for(j=0;(k+i)<candies && j<num_people;j++){\\n                result[j]+= i;\\n                k+=i;\\n                i++;\\n            }\\n        }\\n        if(j==num_people)\\n            j=0;\\n\\n        result[j] += candies-k;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096283,
                "title": "beats-99-8-percent-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        child = [0]*num_people\\n        index = 0\\n        candy = 1\\n        while candies >0:\\n            if candies < candy :\\n                candy = candies\\n            child[index] += candy \\n            candies -= candy\\n            candy +=1\\n            index +=1\\n            if index  == num_people:\\n                index = 0\\n        return child\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        child = [0]*num_people\\n        index = 0\\n        candy = 1\\n        while candies >0:\\n            if candies < candy :\\n                candy = candies\\n            child[index] += candy \\n            candies -= candy\\n            candy +=1\\n            index +=1\\n            if index  == num_people:\\n                index = 0\\n        return child\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572836,
                "content": [
                    {
                        "username": "Han6431",
                        "content": "**Pure math problem. If we get the math behind, we get the solution.**\\n1) By the total number of candies, we know how many distributions of candices we will have for people: 1 + 2 + 3 + ... = number of candies. Here, the number of distributions is the number of natural numbers on the left of the equation. (Use the formula (1+n)*n/2 = number of candies. The n might not be an integer. If so, it means there are remain candies for the last person. Let m be the floor number of n, and we can use m and the total number of candies to calculate the remain candies for the last person.)\\n2) With the number of distributions, we can calculate how many rounds we will have. (Each round means going through all people once). Use integer division of number of distributions on number of people, we have the number of rounds.\\n3) Use mode calculation we can get the number of distributions for the last incomplete round. \\n4) Don\\'t forget to add the remain candies to the last person.\\n\\nWith these numbers calculated, for each person in the list, we can directly calculate the number of candies there."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = [0] * num_people\\n\\ti = 0\\n\\twhile candies >= 0:\\n\\t\\tresult[i % num_people] += min(i + 1, candies)\\n\\t\\ti += 1\\n\\t\\tcandies -= i\\n\\treturn result"
                    }
                ]
            },
            {
                "id": 1574846,
                "content": [
                    {
                        "username": "Han6431",
                        "content": "**Pure math problem. If we get the math behind, we get the solution.**\\n1) By the total number of candies, we know how many distributions of candices we will have for people: 1 + 2 + 3 + ... = number of candies. Here, the number of distributions is the number of natural numbers on the left of the equation. (Use the formula (1+n)*n/2 = number of candies. The n might not be an integer. If so, it means there are remain candies for the last person. Let m be the floor number of n, and we can use m and the total number of candies to calculate the remain candies for the last person.)\\n2) With the number of distributions, we can calculate how many rounds we will have. (Each round means going through all people once). Use integer division of number of distributions on number of people, we have the number of rounds.\\n3) Use mode calculation we can get the number of distributions for the last incomplete round. \\n4) Don\\'t forget to add the remain candies to the last person.\\n\\nWith these numbers calculated, for each person in the list, we can directly calculate the number of candies there."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = [0] * num_people\\n\\ti = 0\\n\\twhile candies >= 0:\\n\\t\\tresult[i % num_people] += min(i + 1, candies)\\n\\t\\ti += 1\\n\\t\\tcandies -= i\\n\\treturn result"
                    }
                ]
            }
        ]
    }
]