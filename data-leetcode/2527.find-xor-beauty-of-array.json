[
    {
        "title": "Find Xor-Beauty of Array",
        "question_content": "You are given a 0-indexed integer array nums.\nThe effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).\nThe xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.\nReturn the xor-beauty of nums.\nNote that:\n\n\tval1 | val2 is bitwise OR of val1 and val2.\n\tval1 & val2 is bitwise AND of val1 and val2.\n\n&nbsp;\nExample 1:\n\nInput: nums = [1,4]\nOutput: 5\nExplanation: \nThe triplets and their corresponding effective values are listed below:\n- (0,0,0) with effective value ((1 | 1) & 1) = 1\n- (0,0,1) with effective value ((1 | 1) & 4) = 0\n- (0,1,0) with effective value ((1 | 4) & 1) = 1\n- (0,1,1) with effective value ((1 | 4) & 4) = 4\n- (1,0,0) with effective value ((4 | 1) & 1) = 1\n- (1,0,1) with effective value ((4 | 1) & 4) = 4\n- (1,1,0) with effective value ((4 | 4) & 1) = 0\n- (1,1,1) with effective value ((4 | 4) & 4) = 4 \nXor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.\nExample 2:\n\nInput: nums = [15,45,20,2,34,35,5,44,32,30]\nOutput: 34\nExplanation: The xor-beauty of the given array is 34.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length&nbsp;<= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3015014,
                "title": "why-just-xor-of-all-numbers-works",
                "content": "**Simple reason why taking XOR of all numbers work**:\\n\\nLet\\'s just consider all possible combinations, and simplify the xor operations.\\n\\nSplit all the possible triplets into below 3 types.\\n\\n- **Type 1**: Considering 1 number `a` with **all 3 indices same**\\n`(a | a) & a`    =     `a`\\n\\n- **Type 2**: Considering 2 numbers `a b` with **any 2 indices same**\\n\\n    Different combinations are:\\n    1. `(a | a) & b` = `a & b`\\n    2. `(b | b) & a` = `b & a`\\n    3. `(a | b) & a` = `aa | ab` = `a | ab` = `a` (By `Distributive_law` and `Absorption_law`)\\n    4. `(b | a) & a` = `a`\\n    5. `(a | b) & b` = `b`\\n    6. `(b | a) & b` = `b`\\n\\n    XOR of the above values :\\n    (a & b) ^ (b & a) ^ a ^ a ^ b ^ b\\n    = `(a&b)^(a&b)` ^ `a^a` ^ `b^b`\\n    = `0`\\n\\n    We can also note that,\\n    - 1st point and 2nd pt are same.\\n    - 3rd point and 4th pt are same.\\n    - 5th point and 6th pt are same.\\n\\n- **Type 3**: Considering 3 numbers `a b c` with **all 3 indices are different**\\n    - Whenever we consider `(a | b) & c`,\\n    we should also consider `(b | a) & c`.\\nIt is easy to note that, both these have the same values. So, taking XOR of these 2, equates to `0`.\\n    - Similarily, we can do the same for `(a|c)&b`, along with `(c|a)&b`. XOR of these is `0`.\\n    - Also, for `(b|c)&a` ^ `(c|b)&a` is `0`.\\n\\nSo, the only numbers that remain are the numbers which have all 3 indices same\\n`(a | a) & a`.\\n\\n**Code**\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for (int num : nums)\\n            xor ^= num;\\n        return xor;\\n    }\\n}\\n```\\n\\n**Complexity**\\n- Time complexity: `O(n)`\\n- Space complexity: `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for (int num : nums)\\n            xor ^= num;\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014972,
                "title": "python3-one-liner-with-formal-proof",
                "content": "# Intuition\\nMany of you may get accepted during contest by guessing the answer (the bitwise XOR of all `num` in `nums`). Here we provide a formal proof.\\n\\n# Key Observations:\\n1. Fully utilize the symmetry between `i, j, k`.\\n2. `a ^ a = 0` (the property of bitwise XOR).\\n\\n# Proof: \\n\\n1. First, note that by symmetry of `i` and `j`, we know that the value of `((nums[i] | nums[j]) & nums[k])` and `((nums[j] | nums[i]) & nums[k])` are equal. Which then implies that for a pair of `(i, j)` where `i != j`, the bitwise XOR of `((nums[i] | nums[j]) & nums[k])` and `((nums[j] | nums[i]) & nums[k])` is 0. Thus, we only need to deal with the triplets `(i, j, k)` where `i == j`.\\n\\n2. Now we only need to consider the triplets `(i, j, k)` where `i == j`, so that `((nums[i] | nums[j]) & nums[k]) = ((nums[i] | nums[i]) & nums[k]) = nums[i] & nums[k]`. By symmetry of `i` and `k`, we know that the value of `nums[i] & nums[k]` and `nums[k] & nums[i]` are equal. Which then implies that for a pair of `(i, k)` where `i != k`, the bitwise XOR of `nums[i] & nums[k]` and `nums[k] & nums[i]` is 0. Thus, we only need to deal with the case of `i == k`.\\n\\n3. Therefore, we only need to consider the triplets `(i, j, k)` where `i == j == k`, and the final answer reduces to the bitwise XOR of `((nums[i] | nums[j]) & nums[k]) = ((nums[i] | nums[i]) & nums[i]) = nums[i]`.\\n\\n# Complexity\\n- Time complexity: `O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(xor, nums)  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(xor, nums)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014926,
                "title": "handwritten-explanation-of-why",
                "content": "![WhatsApp Image 2023-01-07 at 11.27.40 PM.jpeg](https://assets.leetcode.com/users/images/4b6929ac-350f-4b24-9178-d81c56d3c1e7_1673114359.7266495.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int num: nums) ans ^= num;\\n        return ans;\\n    }\\n};\\n```\\n\\nHelp others by upvoting. Suggestion are welcome!",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int num: nums) ans ^= num;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015549,
                "title": "3-lines-java-code",
                "content": "\\n\\n# Code\\n```\\n    public int xorBeauty(int[] nums) {\\n        int answer = 0;\\n        for(int i=0; i<nums.length; i++)    answer ^= nums[i];\\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int xorBeauty(int[] nums) {\\n        int answer = 0;\\n        for(int i=0; i<nums.length; i++)    answer ^= nums[i];\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015170,
                "title": "java-pen-and-paper-proof",
                "content": "# Please Upvote :D\\n---\\nThe answer is nothing but the `xor` of all the elements in the given array.\\n\\n![IMG_20230107_234007.jpg](https://assets.leetcode.com/users/images/3c70d237-03ac-4fc2-9c84-2f3a4a2283cf_1673115228.8249195.jpeg)\\nThis is for just two elements, it\\'d be the same for more elements. You just need to expand it. \\nThe terms with similar tick marks would cancel each other.\\n\\n``` java []\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for (int i : nums) {\\n            xor ^= i;\\n        }\\n        \\n        return xor;\\n    }\\n} \\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for (int i : nums) {\\n            xor ^= i;\\n        }\\n        \\n        return xor;\\n    }\\n} \\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014947,
                "title": "one-liner-java-accepted-by-mistake",
                "content": "Intuition\\nMath! The final answer is (v|v) & v where v is the xor of all numbers.\\n\\n```\\npublic int xorBeauty(int[] arr) {\\n\\t//one Liner\\n\\tfor(int i=1; i<arr.length; i++){\\n\\t\\tarr[0]^=arr[i];\\n\\t}\\n\\treturn arr[0];\\n}\\n```\\n\\n**Java One Liner :**\\n```\\nclass Solution {\\n    public int xorBeauty(int[] arr) {\\n        return Arrays.stream(arr).reduce((a, b) -> a ^ b).orElse(0);\\n    }\\n}\\n```\\n\\n**Python One Liner** :\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```\\n\\nComplexity\\n* Time O(N)\\n* Space O(1)",
                "solutionTags": [],
                "code": "```\\npublic int xorBeauty(int[] arr) {\\n\\t//one Liner\\n\\tfor(int i=1; i<arr.length; i++){\\n\\t\\tarr[0]^=arr[i];\\n\\t}\\n\\treturn arr[0];\\n}\\n```\n```\\nclass Solution {\\n    public int xorBeauty(int[] arr) {\\n        return Arrays.stream(arr).reduce((a, b) -> a ^ b).orElse(0);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015896,
                "title": "python-no-magic",
                "content": "# Intuition\\n\\nI\\'ll tell you what to do if you haven\\'t noticed symmetries in the formula.\\n\\n# Approach\\n\\nFirst of all, contributions of different bits are independent, which is a common pattern in such questions. For each bit and each of the 8 possible combinations of bits in $$x, y, z$$, we can calculate how many triples $$(i, j, k)$$ yield this combination.\\n\\nThis technique is useful in formulas that are not that easy to simplify, the formulas that involve sums instead of xor-sums, and also in formulas that consider only ordered indices, like `i < j < k`.\\n\\nNote: I used `math.floor(math.log2(max(nums))) + 1` to calculate the number of bits, but you may as well hardcode `30` in this problem.\\n\\nNote: I used `itertools.product((0, 1), repeat=3)` to generate all 8 combinations `(0, 0, 0), (0, 0, 1), (0, 1, 0), ...` because I don\\'t want to write three nested loops, but you can say `for x in (0, 1): for y in (0, 1): for z in (0, 1):`.\\n\\n# Complexity\\n\\n- Time complexity: $$O(n \\\\log \\\\max)$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n\\n[Submission link](https://leetcode.com/problems/find-xor-beauty-of-array/submissions/873943705/)\\n\\n```python\\nimport collections\\nimport itertools\\nimport math\\n\\n\\nclass Solution:\\n    def xorBeauty(self, nums: list[int]) -> int:\\n        beauty = 0\\n\\n        for bit in range(math.floor(math.log2(max(nums))) + 1):\\n            cnt = collections.Counter((num >> bit) & 1 for num in nums)\\n\\n            for i, j, k in itertools.product((0, 1), repeat=3):\\n                if (cnt[i] * cnt[j] * cnt[k]) & 1:\\n                    beauty ^= ((i | j) & k) << bit\\n\\n        return beauty\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```python\\nimport collections\\nimport itertools\\nimport math\\n\\n\\nclass Solution:\\n    def xorBeauty(self, nums: list[int]) -> int:\\n        beauty = 0\\n\\n        for bit in range(math.floor(math.log2(max(nums))) + 1):\\n            cnt = collections.Counter((num >> bit) & 1 for num in nums)\\n\\n            for i, j, k in itertools.product((0, 1), repeat=3):\\n                if (cnt[i] * cnt[j] * cnt[k]) & 1:\\n                    beauty ^= ((i | j) & k) << bit\\n\\n        return beauty\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032186,
                "title": "c-proof-of-array-xor-boolean-algebra",
                "content": "# Proof\\nThe final answer for array $x$ can be written mathematically as:\\n$$\\\\displaystyle\\\\bigoplus_{i=1}^{n} \\\\bigoplus_{j=1}^{n} \\\\bigoplus_{k=1}^{n} \\\\left(x_i \\\\vee x_j\\\\right) \\\\wedge x_k$$\\n\\nSince, there are $n$ choices for each indices $[i, j, k]$, total number of triplets formed will be $n^3$.\\n\\n---\\n\\nWe can divide these triplets $[i, j, k]$ into two types:\\n- $i = j$: Triplets will be $[i, i, k]$ and terms will be $\\\\left(x_i \\\\vee x_i\\\\right) \\\\wedge x_k = x_i \\\\wedge x_k$, since $x_i \\\\vee x_i = x_i$.\\n- $i \\\\ne j$: For triplets $[i, j, k]$, there are two choices:\\n  - $i < j$: Terms will be $\\\\left(x_i \\\\vee x_j\\\\right) \\\\wedge x_k$.\\n  - $i > j$: Terms will be $\\\\left(x_i \\\\vee x_j\\\\right) \\\\wedge x_k$. But if we swap the indices $i$ and $j$, it can be written as $j > i$ and $\\\\left(x_j \\\\vee x_i\\\\right) \\\\wedge x_k$. So condition for this is also converted to $i < j$.\\n  - So for $i \\\\ne j$: Merging above two, condition will be $i < j$ and terms will be $\\\\left(\\\\left(x_i \\\\vee x_j\\\\right) \\\\wedge x_k\\\\right) \\\\oplus \\\\left(\\\\left(x_j \\\\vee x_i\\\\right) \\\\wedge x_k\\\\right)$. Since $x_i \\\\vee x_j = x_j \\\\vee x_i$, the two terms are equal and their XOR is $0$.\\n\\n---\\n\\nApplying this to our answer:\\n\\n$$= \\\\displaystyle\\\\bigoplus_{i=1}^{n} \\\\bigoplus_{j=1}^{n} \\\\bigoplus_{k=1}^{n} \\\\left(x_i \\\\vee x_j\\\\right) \\\\wedge x_k$$\\n\\n$$= \\\\left[\\\\displaystyle\\\\bigoplus_{i=1}^{n} \\\\bigoplus_{k=1}^{n} \\\\left(x_i \\\\wedge x_k\\\\right)\\\\right]\\n\\\\bigoplus\\n\\\\left[\\\\displaystyle\\\\bigoplus_{i=1}^{n} \\\\bigoplus_{j=i+1}^{n} \\\\bigoplus_{k=1}^{n} \\\\left(\\\\left(x_i \\\\vee x_j\\\\right) \\\\wedge x_k\\\\right) \\\\oplus \\\\left(\\\\left(x_j \\\\vee x_i\\\\right) \\\\wedge x_k\\\\right)\\\\right]$$\\n\\n$$= \\\\displaystyle\\\\bigoplus_{i=1}^{n} \\\\bigoplus_{k=1}^{n} \\\\left(x_i \\\\wedge x_k\\\\right)$$\\n\\n---\\n\\nNow, apply same technique for pairs $[i, k]$. We can divide these pairs $[i, k]$ into two types:\\n- $i = k$: Pairs will be $[i, i]$ and terms will be $x_i \\\\wedge x_i = x_i$.\\n- $i \\\\ne k$: For pairs $[i, k]$, there are two choices:\\n  - $i < k$: Terms will be $x_i \\\\wedge x_k$.\\n  - $i > k$: Terms will be $x_i \\\\wedge x_k$. But if we swap the indices $i$ and $k$, it can be written as $k > i$ and $x_k \\\\wedge x_i$. So condition for this is also converted to $i < k$.\\n  - So for $i \\\\ne k$: Merging above two, condition will be $i < k$ and terms will be $\\\\left(x_i \\\\wedge x_k\\\\right) \\\\oplus \\\\left(x_k \\\\wedge x_i\\\\right)$. Since $x_i \\\\wedge x_k = x_k \\\\wedge x_i$, their XOR is $0$.\\n\\n---\\n\\nApplying this to our answer:\\n\\n$$= \\\\displaystyle\\\\bigoplus_{i=1}^{n} \\\\bigoplus_{k=1}^{n} \\\\left(x_i \\\\wedge x_k\\\\right)$$\\n\\n$$= \\\\left[\\\\displaystyle\\\\bigoplus_{i=1}^{n} x_i\\\\right]\\n\\\\bigoplus\\n\\\\left[\\\\displaystyle\\\\bigoplus_{i=1}^{n} \\\\bigoplus_{k=i+1}^{n} \\\\left(x_i \\\\wedge x_k\\\\right) \\\\oplus \\\\left(x_k \\\\wedge x_i\\\\right)\\\\right]$$\\n\\n$$= \\\\displaystyle\\\\bigoplus_{i=1}^{n} x_i$$\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015989,
                "title": "c-one-liner-w-std-accumulate-and-std-bit-xor-fast-44ms-100",
                "content": "# Approach 1: std::accumulate\\nThere are some other post that do a great job explaining why the result is just the XOR of all values.\\n\\n```cpp\\n    static int xorBeauty(const vector<int>& nums) {\\n        return accumulate(begin(nums), end(nums), 0, bit_xor{});\\n    }\\n```\\n\\nWe could replace ```std::accumulate``` with ```std::reduce```, which would be particular intesting of we could use parallel execution, unfortunatly LC does\\'t seem to support the necessary headers at this point.\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of the input vector then the\\n  * Time complexity is $$O(n)$$ and the\\n  * Space complexity is $$O(1)$$\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int xorBeauty(const vector<int>& nums) {\\n        return accumulate(begin(nums), end(nums), 0, bit_xor{});\\n    }\\n```\n```std::accumulate```\n```std::reduce```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017260,
                "title": "python-3-1-line-w-explanation-and-example-t-m-350-ms-27-8-mb",
                "content": "Here\\'s the analysis:\\n- We start with an identity:\\n`A^A^B =B   [Proof: `A^A^B = (A^A)^B = (0)^B = B `] \\n\\nHere\\'s an example of how this identity works:\\n    `1^2^3^2^2^1 = 1^1 ^ 2^2 ^ 2 ^ 3 = 0^0^2^3 = 2^3 = 1`\\n\\n- In Example 1:\\n```\\nBeauty = (1|4)&1)^(4|1)&1) ^ (1|4)&4)^(4|1)&4) ^ (1|1)&4) ^ (4|4)&1) ^ (1|1)&1) ^ (4|4)&4)\\n             \\\\        /          \\\\        /          \\n            (5&1    5&1)        (5&4    5&4)\\n```\\n\\n- We can use the identity to discard the two pairs in parentheses. Note we are left only with elements in the form `(A|A)&B`, where `A` and `B` are not nescessarily distinct.\\n```\\nBeauty =  (1|1)&4)^(4|4)&1) ^ (1|1)&1) ^ (4|4)&4)\\n              \\\\        /         \\n             (1&4    4&1)\\n```    \\n    \\n- We can apply the identity again to discard the pair in parentheses to arrive at\\n```\\n    Beauty = (1|1)&1) ^ (4|4)&4) = 1&1 ^ 4&4  = 1 ^ 4 = 5\\n                 |        |     \\n                1&4      4&1\\n```\\nNote we are now left only with elements in the form `(A|A)&A` for all `A` in`nums`, and note that `(A|A)&A = A`.\\n\\nBottom line: We can generalize from this example; the solution is simply XOR(`nums`) \\n\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n\\n        return  reduce(xor, nums)\\n\\n```\\n[https://leetcode.com/problems/find-xor-beauty-of-array/submissions/873591810/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nBeauty = (1|4)&1)^(4|1)&1) ^ (1|4)&4)^(4|1)&4) ^ (1|1)&4) ^ (4|4)&1) ^ (1|1)&1) ^ (4|4)&4)\\n             \\\\        /          \\\\        /          \\n            (5&1    5&1)        (5&4    5&4)\\n```\n```\\nBeauty =  (1|1)&4)^(4|4)&1) ^ (1|1)&1) ^ (4|4)&4)\\n              \\\\        /         \\n             (1&4    4&1)\\n```\n```\\n    Beauty = (1|1)&1) ^ (4|4)&4) = 1&1 ^ 4&4  = 1 ^ 4 = 5\\n                 |        |     \\n                1&4      4&1\\n```\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n\\n        return  reduce(xor, nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015687,
                "title": "c-solution-xor-of-all-elements",
                "content": "\\n```\\n\\n/*\\nFrom the example it self it can be seen that we need to just XOR all the number and the answer will be same as the solution we are looking for.\\n*/\\n\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto n: nums) ans = ans^n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n/*\\nFrom the example it self it can be seen that we need to just XOR all the number and the answer will be same as the solution we are looking for.\\n*/\\n\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto n: nums) ans = ans^n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014955,
                "title": "python-1-simple-line",
                "content": "```python\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```\\n\\nPlease vote up if you like my solution \\uD83D\\uDE4F",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654415,
                "title": "time-o-n-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int a = 0, b = 0;\\n        for(auto &i: nums){\\n            a |= i,b^=i;\\n        }\\n        return (a&b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int a = 0, b = 0;\\n        for(auto &i: nums){\\n            a |= i,b^=i;\\n        }\\n        return (a&b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206678,
                "title": "c-detailed-explanation",
                "content": "# Intuition\\nExplanation in comments\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& v) {\\n        /*\\n        type1: same index\\n            a | a & a = a\\n        */\\n        \\n        /*\\n        type 2: one index repeated\\n            all combinations of a b\\n            *a a b = a&b\\n            -a b a\\n            +a b b\\n            *b b a = b&a\\n            -b a a\\n            +b a b\\n            = a&b ^ b&a = 0\\n        */ \\n\\n        /*\\n        type 3: all different\\n            use a,b,c\\n                (a | b) & c  ^      ab & c ^\\n                (a | c) & b  ^      ac & b ^    \\n                (b | a) & c  ^      ab & c ^\\n                (b | c) & a  ^      bc & a ^\\n                (c | a) & b  ^      ac & b ^\\n                (c | b) & a  ^      bc & a ^\\n                \\n                == 0\\n        */\\n\\n        int ans = 0;\\n        for (auto a:v)\\n            ans = ans^a;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& v) {\\n        /*\\n        type1: same index\\n            a | a & a = a\\n        */\\n        \\n        /*\\n        type 2: one index repeated\\n            all combinations of a b\\n            *a a b = a&b\\n            -a b a\\n            +a b b\\n            *b b a = b&a\\n            -b a a\\n            +b a b\\n            = a&b ^ b&a = 0\\n        */ \\n\\n        /*\\n        type 3: all different\\n            use a,b,c\\n                (a | b) & c  ^      ab & c ^\\n                (a | c) & b  ^      ac & b ^    \\n                (b | a) & c  ^      ab & c ^\\n                (b | c) & a  ^      bc & a ^\\n                (c | a) & b  ^      ac & b ^\\n                (c | b) & a  ^      bc & a ^\\n                \\n                == 0\\n        */\\n\\n        int ans = 0;\\n        for (auto a:v)\\n            ans = ans^a;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015659,
                "title": "c-3-line-code-clean-short-easy-code",
                "content": "![image](https://assets.leetcode.com/users/images/b7ed3bbc-b4da-40b5-a4c2-178207644933_1673122368.5230727.png)\\n\\n\\n**T->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint xorBeauty(vector<int>& nums) {\\n\\t\\t\\tint Xor=0;\\n\\t\\t\\tfor(auto i:nums) Xor^=i;\\n\\t\\t\\treturn Xor;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint xorBeauty(vector<int>& nums) {\\n\\t\\t\\tint Xor=0;\\n\\t\\t\\tfor(auto i:nums) Xor^=i;\\n\\t\\t\\treturn Xor;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3014927,
                "title": "python3-o-n",
                "content": "All the numbers will get cancelled out because of XOR, except the numbers themselves.\\n\\nSo, XOR of the numbers will give the answer\\n\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n\\t\\n        s = 0\\n        for x in nums:\\n            s^=x\\n        return s",
                "solutionTags": [
                    "Python3"
                ],
                "code": "All the numbers will get cancelled out because of XOR, except the numbers themselves.\\n\\nSo, XOR of the numbers will give the answer\\n\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n\\t\\n        s = 0\\n        for x in nums:\\n            s^=x\\n        return s",
                "codeTag": "Java"
            },
            {
                "id": 3415259,
                "title": "c-short-sweet-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        int i;\\n        for(i = 0; i < nums.size()-1; i++){\\n            if(nums[i]!=nums[i+1])break;\\n        }\\n        if(i==nums.size()-1)return 0;\\n        int ans = 0;\\n        for(auto &i: nums) ans |= i;\\n        for(auto &i: nums) ans &= i;\\n        for(auto &i: nums) ans ^= i;\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        int i;\\n        for(i = 0; i < nums.size()-1; i++){\\n            if(nums[i]!=nums[i+1])break;\\n        }\\n        if(i==nums.size()-1)return 0;\\n        int ans = 0;\\n        for(auto &i: nums) ans |= i;\\n        for(auto &i: nums) ans &= i;\\n        for(auto &i: nums) ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020419,
                "title": "xor-of-whole-array",
                "content": "```\\nint xorBeauty(vector<int>& nums) {\\n        if(nums.size()==1)  return nums[0];\\n        \\n        int ans=nums[0]^nums[1];\\n        \\n        for(int i=2;i<nums.size();i++)  ans=ans^nums[i];\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint xorBeauty(vector<int>& nums) {\\n        if(nums.size()==1)  return nums[0];\\n        \\n        int ans=nums[0]^nums[1];\\n        \\n        for(int i=2;i<nums.size();i++)  ans=ans^nums[i];\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017874,
                "title": "c-xor-of-all-elements-easy-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int x=0;\\n        for(int p:nums){\\n            x= x^p;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int x=0;\\n        for(int p:nums){\\n            x= x^p;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015975,
                "title": "why-xor-all-elements-easy-explaination",
                "content": "\\n# Approach\\uD83E\\uDDE0:\\n\\u2744\\uFE0FWe must know that a^a=0 (^ is XOR).\\n\\n\\u2705We can have 3 possible cases : \\n\\n#### Case 1 :  \\n\\u25FB We have all three indices same i.e\\ni=j=k=x(say) , so\\n```\\n(nums[x] | nums[x]) & nums[x] = nums[x]\\n```\\n-------\\n#### Case 2 : \\nWe have any two indices same\\n\\n\\u25FB firstly , i=j=x(say)\\n```\\n(nums[x] | nums[x]) & nums[k] = nums[x] & nums[k]\\n```\\nbut there would also be a case when k & x in above gets replaced .\\n\\n```\\n(nums[k] | nums[k]) & nums[x] = nums[k] & nums[x]\\n```\\nThe XOR of above two is ZERO .\\n\\n\\u25FB Now for any index x ,\\n\\neither i=k=x(say)\\n```\\n(nums[x] | nums[j]) & nums[x] = nums[x] \\n```\\nor j=k=x(say)\\n```\\n(nums[i] | nums[x]) & nums[x] = nums[x] \\n\\n```\\n\\nThe XOR of above two is ZERO.\\n\\n-----\\n#### Case 3 :\\n\\u25FB When all three indices are different-\\n\\nFor any index k there would exist\\n```\\n(nums[i] | nums[j]) & nums[k]\\n```\\n```\\n(nums[j] | nums[i]) & nums[k]   (i & j gets inter-changed)\\n```\\nThe XOR of above two is again ZERO .\\n\\n### *\\u270D\\uFE0FTherefor all we need to solve is case 1 (To do XOR of all elements).*\\n----\\n---\\n# Complexity\\u231B:\\n### - Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n### - Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=nums[0];\\n        for(int i=1 ; i<nums.size() ; i++){\\n            ans^=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n---\\n### Do upvote\\uD83D\\uDD3C if it adds value .",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n(nums[x] | nums[x]) & nums[x] = nums[x]\\n```\n```\\n(nums[x] | nums[x]) & nums[k] = nums[x] & nums[k]\\n```\n```\\n(nums[k] | nums[k]) & nums[x] = nums[k] & nums[x]\\n```\n```\\n(nums[x] | nums[j]) & nums[x] = nums[x] \\n```\n```\\n(nums[i] | nums[x]) & nums[x] = nums[x] \\n\\n```\n```\\n(nums[i] | nums[j]) & nums[k]\\n```\n```\\n(nums[j] | nums[i]) & nums[k]   (i & j gets inter-changed)\\n```\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=nums[0];\\n        for(int i=1 ; i<nums.size() ; i++){\\n            ans^=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015278,
                "title": "xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int  ans = 0;\\n        for(int i : nums) ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int  ans = 0;\\n        for(int i : nums) ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015178,
                "title": "c-rust-js-java-1-liner-100-faster",
                "content": "**First appoarch.**\\n\\nDoes exactly what is told. Gets `TLE`.\\n```c++\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int result = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            for (int j = 0; j < nums.size(); j++) \\n                for (int k = 0; k < nums.size(); k++) {\\n                    int val = (nums[i] | nums[j]) & nums[k];\\n                    result ^= val;\\n                }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n**Working approaches**\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums, int ans = 0) {\\n        for (int x: nums) ans ^= x; return ans;\\n    }\\n};\\n```\\n\\n**Rust**\\n```rust\\nfn xor_beauty(nums: &Vec<i32>) -> i32 {\\n    let mut ans = 0;\\n    for x in nums {\\n        ans ^= x;\\n    }\\n    ans\\n}\\n```\\n\\n**JS**\\n```js\\nfunction xorBeauty(nums) {\\n  let ans = 0;\\n  for (const x of nums) {\\n    ans ^= x;\\n  }\\n  return ans;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int xorBeauty(int[] nums) {\\n    int ans = 0;\\n    for (int x : nums) {\\n        ans ^= x;\\n    }\\n    return ans;\\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int result = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            for (int j = 0; j < nums.size(); j++) \\n                for (int k = 0; k < nums.size(); k++) {\\n                    int val = (nums[i] | nums[j]) & nums[k];\\n                    result ^= val;\\n                }\\n        return result;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums, int ans = 0) {\\n        for (int x: nums) ans ^= x; return ans;\\n    }\\n};\\n```\n```rust\\nfn xor_beauty(nums: &Vec<i32>) -> i32 {\\n    let mut ans = 0;\\n    for x in nums {\\n        ans ^= x;\\n    }\\n    ans\\n}\\n```\n```js\\nfunction xorBeauty(nums) {\\n  let ans = 0;\\n  for (const x of nums) {\\n    ans ^= x;\\n  }\\n  return ans;\\n}\\n```\n```java\\npublic int xorBeauty(int[] nums) {\\n    int ans = 0;\\n    for (int x : nums) {\\n        ans ^= x;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015078,
                "title": "straightforward-one-pass-c-solution-key-observation-explained",
                "content": "# Approach\\nThe key observation is that the triplets `((nums[i] | nums[j]) & nums[k])` occurs in pairs except when $$i=j=k$$. \\n- when $$i = j = k$$, the result `((nums[i] | nums[j]) & nums[k])` is the the number itself. \\n- when $$i = j$$ but $$i \\\\neq k$$, we would have `nums[i] & nums[k]` and `nums[k] & nums[i]` be valid triplets for each pair of number in `nums`. XORing them would give 0. \\n- otherwise, for each `nums[k]`, `((nums[i] | nums[j]) & nums[k])` and `((nums[j] | nums[i]) & nums[k])` would both be a valid triplets and be considered in the final result. Obviously they are the same and XORing them in the last step would make them 0. \\n\\nHence, the result is just the XOR of all numbers in the array. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = 0;\\n        for (int x : nums)\\n            res ^= x;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = 0;\\n        for (int x : nums)\\n            res ^= x;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876684,
                "title": "jawab-dekh-kar-maja-aajayega-cpp-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n) single loop\\n- space complexity :O(1)\\n\\n\\n# Code\\n```\\n// bhai dekho simple sa hai logic \\n// har ek case ka opposite hai\\n// kehana ka ye matlab hai \\n// dekho 1 eg [1,4]\\n// take case [0,0,1] & [1,1,0] both will cancel each other in xor\\n//similarly rest all cases\\n// only [0,0,0] [1,1,1] these types of cases do not have any factor to cancel\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n       int ans=0;\\n       for(auto i:nums)\\n       {\\n           ans=ans^i;\\n       }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// bhai dekho simple sa hai logic \\n// har ek case ka opposite hai\\n// kehana ka ye matlab hai \\n// dekho 1 eg [1,4]\\n// take case [0,0,1] & [1,1,0] both will cancel each other in xor\\n//similarly rest all cases\\n// only [0,0,0] [1,1,1] these types of cases do not have any factor to cancel\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n       int ans=0;\\n       for(auto i:nums)\\n       {\\n           ans=ans^i;\\n       }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852990,
                "title": "beginner-friendly-one-liner-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) \\n    {\\n        int val=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            val=val^nums[i];\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) \\n    {\\n        int val=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            val=val^nums[i];\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761401,
                "title": "python3-solution-with-full-explanation",
                "content": "# Explanation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n##### Consider 3 different indexes:\\n`nums[i] = a`, `nums[j] = b`, `nums[k] = c`\\n1. `(i, j, k)` - `(a | b) & c`\\n2. `(i, k, j)` - `(a | c) & b`\\n3. `(j, i, k)` - `(b | a) & c`\\n4. `(j, k, i)` - `(b | c) & a`\\n5. `(k, i, j)` - `(c | a) & b`\\n6. `(k, j, i)` - `(c | b) & a`\\n\\n`(1.) & (3.) = ((a | b) & c) ^ ((b | a) & c) = 0`\\n`(2.) & (5.) = ((a | c) & b) ^ ((c | a) & b) = 0`\\n`(4.) & (6.) = ((b | c) & a) ^ ((c | b) & a) = 0`\\n\\nXOR-beauty is 0.\\n\\n##### Consider 2 different indexes:\\n`nums[i] = a`, `nums[j] = b`\\n1. `(i, i, j)` - `(a | a) & b = a & b`\\n2. `(i, j, i)` - `(a | b) & a`\\n3. `(j, i, i)` - `(b | a) & a`\\n4. `(j, j, i)` - `(b | b) & a = b & a`\\n5. `(j, i, j)` - `(b | a) & b`\\n6. `(i, j, j)` - `(a | b) & b`\\n\\n`(1.) ^ (4.) = (a & b) ^ (b & a) = 0`\\n`(2.) ^ (3.) = ((a | b) & a) ^ ((b | a) & a) = 0`\\n`(5.) ^ (6.) = ((b | a) & b) ^ ((a | b) & b) = 0`\\n\\nXOR-beauty is 0.\\n\\n##### Consider equal indexes:\\n`nums[i] = a`\\n`(a | a) & a = a & a = a`\\n\\nXOR-beaty is same element.\\n\\nSo only XOR of elements remains.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        result = 0\\n        for elem in nums:\\n            result ^= elem\\n        return result\\n\\n```\\n#### If you found this useful or interesting, please upvote!",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        result = 0\\n        for elem in nums:\\n            result ^= elem\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401115,
                "title": "a-method-which-is-not-the-xor-all-one",
                "content": "# Intuition\\nFor `(nums[i] | nums[j]) & nums[k]`, we generate the ultimate xor for all triplets with `nums[k]` fixed. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, let\\'s calculate, of how many numbers the `i-th` bit is `1`.\\n\\nThen for a fixed `nums[k]` and the `i-th` bit, among all the `n*n` triplets, let\\'s see how many will eventually be `1`.\\n\\n* If the `i-th` bit of `nums[k]` is `0`, the bit will surely be `0`.\\n* If the `i-th` bit of `nums[k]` is `1`, say we have `m` numbers with the `i-th` bit being `1`, the number of the triplets of which the `i-th` bit will be `1` is `n * n - (n - m) * (n - m) = 2 * n * m - m * m`. Namely, for `nums[i]` and `nums[j]`, the `i-th` bit of either one being 1 works.\\n* If `2 * n * m - m * m` is even, the bit will be `0`. Otherwise, it will be `1`.\\n\\nSo we can iterate through the numbers and xor them in the end to get the final result.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int n = nums.size();\\n        int bc[31] = {0};\\n        for (int v : nums) {\\n            for (int i = 0; i < 31; i++) {\\n                if (v & (1 << i)) {\\n                    bc[i]++;\\n                }\\n            }\\n        }\\n\\n        int r = 0;\\n        for (int v : nums) {\\n            int vv = 0;\\n            for (int i = 0; i < 31; i++) {\\n                if (v & (1 << i)) {\\n                    long long m = bc[i];\\n                    if ((2 * n * m - m * m) & 1) {\\n                        vv = vv | (1 << i);\\n                    }\\n                    // cout << 2 * n * m - m << \" \" << n << \" \" << m << endl;\\n                }\\n            }\\n            // cout << \"*\" << vv << endl;\\n            r = r ^ vv;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int n = nums.size();\\n        int bc[31] = {0};\\n        for (int v : nums) {\\n            for (int i = 0; i < 31; i++) {\\n                if (v & (1 << i)) {\\n                    bc[i]++;\\n                }\\n            }\\n        }\\n\\n        int r = 0;\\n        for (int v : nums) {\\n            int vv = 0;\\n            for (int i = 0; i < 31; i++) {\\n                if (v & (1 << i)) {\\n                    long long m = bc[i];\\n                    if ((2 * n * m - m * m) & 1) {\\n                        vv = vv | (1 << i);\\n                    }\\n                    // cout << 2 * n * m - m << \" \" << n << \" \" << m << endl;\\n                }\\n            }\\n            // cout << \"*\" << vv << endl;\\n            r = r ^ vv;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3166735,
                "title": "java-iterative-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = -1;\\n        if (nums.length == 1) return nums[0];\\n        for (int i = 1; i < nums.length; i+=2) {\\n            int a = nums[i - 1], b = nums[i];\\n            if (xor == -1) xor = a ^ 0 ^ a ^ b ^ a ^ b ^ 0 ^ b;\\n            else xor ^= a ^ 0 ^ a ^ b ^ a ^ b ^ 0 ^ b;\\n        }\\n        return nums.length % 2 == 1 ? xor - nums[nums.length - 1] : xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = -1;\\n        if (nums.length == 1) return nums[0];\\n        for (int i = 1; i < nums.length; i+=2) {\\n            int a = nums[i - 1], b = nums[i];\\n            if (xor == -1) xor = a ^ 0 ^ a ^ b ^ a ^ b ^ 0 ^ b;\\n            else xor ^= a ^ 0 ^ a ^ b ^ a ^ b ^ 0 ^ b;\\n        }\\n        return nums.length % 2 == 1 ? xor - nums[nums.length - 1] : xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073596,
                "title": "swift-solution-100-efficient",
                "content": "# Approach\\n1. Declare a variable named \"val\" of type Int and set it to 0\\n2. Iterate through the input array of integers\\n3. For each integer x in the array, XOR it with the current value of val. \\n4. Return the final value of val.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func xorBeauty(_ nums: [Int]) -> Int {\\n        var val = 0; \\n        for x in nums { val ^= x; } \\n        return val; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func xorBeauty(_ nums: [Int]) -> Int {\\n        var val = 0; \\n        for x in nums { val ^= x; } \\n        return val; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070353,
                "title": "you-won-t-believe-your-eyes",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n    pub fn xor_beauty(nums: Vec<i32>) -> i32 {\\n        nums.into_iter().fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn xor_beauty(nums: Vec<i32>) -> i32 {\\n        nums.into_iter().fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3040228,
                "title": "3lines-c-code-100-faster-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            x = (x^i);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            x = (x^i);\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034253,
                "title": "bitwise-operation-yet-another-solution-solution-you-never-asked-for-ac",
                "content": "# Intuition\\nWhenever bitwise operation comes in the problem, i try to first think in the direction of how would i solve the problem if it was single bit number in the entire array because bitwise operation for a particular bit place don\\'t affect other bit places surrounding it.\\n\\n# Approach\\nHere i have thought about having independent analysis of which bit will be set in the ans because the boolean operations on ith bit don\\'t effect the surrounding bits at all. So if i know whether the ith bit is set or not in the ans (for all 0<=i<=30), i can know the exact ans\\n\\na_i = ith bit of value a\\n\\nith bit of (a | b) & c is set only in three cases:\\na_i = 0 , b_i = 1 , c_i = 1 --> type i\\na_i = 1 , b_i = 0 , c_i = 1 --> type ii\\na_i = 1 , b_i = 1 , c_i = 1 --> type iii\\n\\nNow if the number of pairs of three numbers, giving ith bit set, is even then xoring all such pairs would lead to unset of ith bit and if such pairs are odd in number then only the ith bit in the ans would be set\\n\\nCounting pairs by independent counting method of multiplication:\\nLet\\'s assume,\\nnumber of values having ith bit set = x\\ntotal size of array = n\\n\\ntype i --> (n-x) * x * x\\ntype ii --> x * (n-x) * x\\ntype iii --> x * x * x\\n\\nTotal pairs having ith bit set = type_i + type_ii + type_iii \\nOnce we get the pairs as we said if its even then ith bit would be 0 or 1 otherwise.\\n\\nWE CAN DO THIS FOR ALL BITS\\n\\nNow think about for a min, no other pairs would interfere in the ith bit decision other than these pairs that we counted. So we can independently analyse the bits. Think for sometime about this idea. Hope it helped. \\n\\n# Complexity\\n- Time complexity: O(N * log(max(Ai))),\\n    Since we are doing it for bits = 30 in this case because Ai <= 10^9\\n- Space complexity: O(1) constant space\\n \\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll getPairsHavingIthBitSet(ll x,ll n){\\n        return (x * x * x) + 2 * (x * (n-x) * x);\\n    }\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int j = 0;j < 31;j++){\\n            int cnt = 0;\\n            for(auto& i: nums){\\n                if(i&(1<<j)){\\n                    cnt++;\\n                }\\n            }\\n            ll pairs = getPairsHavingIthBitSet((ll)cnt,(ll)nums.size());\\n            pairs %= 2;\\n            if(pairs){\\n                ans |= (1<<j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll getPairsHavingIthBitSet(ll x,ll n){\\n        return (x * x * x) + 2 * (x * (n-x) * x);\\n    }\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int j = 0;j < 31;j++){\\n            int cnt = 0;\\n            for(auto& i: nums){\\n                if(i&(1<<j)){\\n                    cnt++;\\n                }\\n            }\\n            ll pairs = getPairsHavingIthBitSet((ll)cnt,(ll)nums.size());\\n            pairs %= 2;\\n            if(pairs){\\n                ans |= (1<<j);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023477,
                "title": "annihilation-proerty-of-xor-and-commutativity-of-and-detailed-analysis-python",
                "content": "1- Reduce the problem to find the XOR result of elements in the given list:\\n```\\nMethod: use symmetry or commutativity, and the annihilation property of XOR.\\n\\nThis is a very straighforward problem if we are very familiar with the bitwise\\noperation properties. For this problem, the following properties come into play:\\n\\n(1) XOR annihilation property: a ^ a = 0 for integer a; here we can restrict a to be nonnegative by the constraints - Item 2.\\n\\n(2) Commutativilty of &, |;  a | b = b | a, a & b = b & a\\n\\nThe above 2 observations plus symmetry can help us reduce the problem to the\\nXOR result of elements in the given list nums.\\n\\nFirst, for each (fixed) index k, consider two different indices i, j, i != j:\\nthey correspond to two triplets: (i, j, k), (j, i, k) for each index k. Their contribution is:\\n\\n( (nums[i] | nums[j]) & nums[k] ) ^ ((nums[j] | nums[i]) & nums[k] )\\n\\n= 0 b/c  (nums[i] | nums[j]) =  (nums[j] | nums[i]), and (1)\\n\\nTherefore, we just need to consider the case i == j, which corresponds to one\\ntriplet for each index k, i.e., (i, i, k), or correspondingly, we consider the following contributions for indices i, k\\n((nums[i] | nums[i]) & nums[k]) = nums[i] & nums[k]\\n\\nSecond, if i != k, then we know, consider (i, k), (k, i)  (in the original triplit form, this corresponds to (i, i, k), (k, k, i), we have their contritution is:\\n\\n(nums[i] & nums[k]) ^ (nums[k] & nums[i]) = 0 because of (2) and (1).\\n\\nHence, we just need to consider the cases i == k.(In original triplet, it corresponds to i == j == k), and the corresponding format:\\n\\n((nums[i] | nums[i]) & nums[i]) = nums[i] & nums[i] = nums[i]\\n\\nThird, in conclusion, we just need to compute the elements XOR result for \\nthe list nums given.\\n\\n```\\n\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        res = 0\\n        for y in nums:\\n            res ^= y\\n        return res        \\n```\\n2- Video Explanation: [Click Here](https://youtu.be/jloyMReW0cc;)\\n",
                "solutionTags": [],
                "code": "```\\nMethod: use symmetry or commutativity, and the annihilation property of XOR.\\n\\nThis is a very straighforward problem if we are very familiar with the bitwise\\noperation properties. For this problem, the following properties come into play:\\n\\n(1) XOR annihilation property: a ^ a = 0 for integer a; here we can restrict a to be nonnegative by the constraints - Item 2.\\n\\n(2) Commutativilty of &, |;  a | b = b | a, a & b = b & a\\n\\nThe above 2 observations plus symmetry can help us reduce the problem to the\\nXOR result of elements in the given list nums.\\n\\nFirst, for each (fixed) index k, consider two different indices i, j, i != j:\\nthey correspond to two triplets: (i, j, k), (j, i, k) for each index k. Their contribution is:\\n\\n( (nums[i] | nums[j]) & nums[k] ) ^ ((nums[j] | nums[i]) & nums[k] )\\n\\n= 0 b/c  (nums[i] | nums[j]) =  (nums[j] | nums[i]), and (1)\\n\\nTherefore, we just need to consider the case i == j, which corresponds to one\\ntriplet for each index k, i.e., (i, i, k), or correspondingly, we consider the following contributions for indices i, k\\n((nums[i] | nums[i]) & nums[k]) = nums[i] & nums[k]\\n\\nSecond, if i != k, then we know, consider (i, k), (k, i)  (in the original triplit form, this corresponds to (i, i, k), (k, k, i), we have their contritution is:\\n\\n(nums[i] & nums[k]) ^ (nums[k] & nums[i]) = 0 because of (2) and (1).\\n\\nHence, we just need to consider the cases i == k.(In original triplet, it corresponds to i == j == k), and the corresponding format:\\n\\n((nums[i] | nums[i]) & nums[i]) = nums[i] & nums[i] = nums[i]\\n\\nThird, in conclusion, we just need to compute the elements XOR result for \\nthe list nums given.\\n\\n```\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        res = 0\\n        for y in nums:\\n            res ^= y\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020080,
                "title": "python-solution-beats-100-time-and-space-complexity-it-s-super-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Disclaimer : This question is meduim to understand but super easy to solve. Iterate over the array once doing xor of all elements and simply return it.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in nums:\\n            ans ^= i\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Disclaimer : This question is meduim to understand but super easy to solve. Iterate over the array once doing xor of all elements and simply return it.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in nums:\\n            ans ^= i\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3019019,
                "title": "4-lines-of-clean-code-o-1-space-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar xorBeauty = function(nums) {\\n    let result = 0\\n    for(let num of nums) {\\n        result ^= num\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar xorBeauty = function(nums) {\\n    let result = 0\\n    for(let num of nums) {\\n        result ^= num\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018764,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(xor, nums)  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(xor, nums)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017971,
                "title": "python-simple-1-liner-simplify-the-expression-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTried to simplify the expression\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key observation is that the triplets ```((nums[i] | nums[j]) & nums[k])``` occurs in pairs except when $$i=j=k$$.\\n\\nWhen $$i=j=k$$, the result ```((nums[i] | nums[j]) & nums[k])``` is the the number itself.\\n\\nWhen $$i=j$$ but $$i\\u2260k$$, we would have ```nums[i] & nums[k]``` and ```nums[k] & nums[i]``` be valid triplets for each pair of number in ```nums```. XORing them would give 0. Otherwise, for each ```nums[k]```, ```((nums[i] | nums[j]) & nums[k])``` and ```((nums[j] | nums[i]) & nums[k])``` would both be a valid triplets and be considered in the final result. Obviously they are the same and XORing them in the last step would make them 0.\\nHence, the result is just the XOR of all numbers in the array.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(operator.xor, nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```((nums[i] | nums[j]) & nums[k])```\n```((nums[i] | nums[j]) & nums[k])```\n```nums[i] & nums[k]```\n```nums[k] & nums[i]```\n```nums```\n```nums[k]```\n```((nums[i] | nums[j]) & nums[k])```\n```((nums[j] | nums[i]) & nums[k])```\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(operator.xor, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017361,
                "title": "vey-fast-and-easy-to-understand-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int xorBeauty(int[] arr) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<arr.length;++i){\\n            ans ^= arr[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] arr) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0;i<arr.length;++i){\\n            ans ^= arr[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016633,
                "title": "do-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i : nums) ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i : nums) ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016629,
                "title": "3-liner-java-simple-beginner-friendly-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll we need to do here is to find the xor of all elements.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor=0;      \\n        for(int i:nums) xor^=i;        \\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor=0;      \\n        for(int i:nums) xor^=i;        \\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016494,
                "title": "java-1ms-with-explanation-easy-understanding",
                "content": "# Intuition\\n> If we notice carefully, it\\'s actually xoring every number in array 3 times.\\n\\n# Approach\\n> Suppose if we have 2 numbers in array like. \\n[1, 4] and xoring them 3 times will be => (1 ^ 4) ^ (1 ^ 4) ^ (1 ^ 4), rearranging this it will become => (1 ^ 1 ^ 1) ^ (4 ^ 4 ^ 4). Now If we XOR a Number with itself 2 times we get 0, thus above equation will become (0 ^ 1) ^ (0 ^ 4) = (1 ^ 4) => xor of all elements in the array. Using this approach implemented 5 Lines of Code. \\nPlease Upvote if you feel this helpful.\\n\\n# Complexity\\n- Time complexity:\\n> Since we are traversing all elements of array one time, thus it will be O(N).\\n\\n- Space complexity:\\n> No additional space is required except a single variable, thus S.C. will be O(1) or constant.\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for(int val : nums){\\n            xor = xor ^ val;\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for(int val : nums){\\n            xor = xor ^ val;\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016162,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res=res^nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res=res^nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016067,
                "title": "java-o-n-and-o-1-beats-100-time-and-space",
                "content": "# Intuition\\nJust note that xor and the \\'and\\' operators are associative.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xorBeauty = 0;\\n        int kBeauty = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            kBeauty = (kBeauty ^ nums[i]);\\n        }\\n        int jBeauty = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            jBeauty = (jBeauty & kBeauty);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            xorBeauty = (xorBeauty ^ ((nums[i] | jBeauty) & kBeauty));\\n        }\\n        return xorBeauty;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xorBeauty = 0;\\n        int kBeauty = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            kBeauty = (kBeauty ^ nums[i]);\\n        }\\n        int jBeauty = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            jBeauty = (jBeauty & kBeauty);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            xorBeauty = (xorBeauty ^ ((nums[i] | jBeauty) & kBeauty));\\n        }\\n        return xorBeauty;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015909,
                "title": "calculate-contribution-of-each-bit-independently",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        // we can solve this problem independently for each bit\\n        const int LOG = 30;\\n        long long n = nums.size();\\n\\n        // onebit will count for each bit how many times it is set in the array\\n        // to check how many times bit i is unset we can simply subtract oneBit[i] from n\\n        vector<long long> oneBit(LOG, 0);\\n        for (auto &it : nums) {\\n            for (int i = 0; i < LOG; i++) {\\n                if ((1 << i) & it) {\\n                    oneBit[i]++;\\n                }\\n            }\\n        }\\n\\n        // oneBitInORPairs will count for each bit how many times it is set among\\n        // all pairs nums[i] | nums[j]\\n        // it can be calculated as follows:\\n        // there are n * n total pairs or numbers, and only those pairs\\n        // in which both numbers have the bit set to 0 will have the bit set to 0 after we | them\\n        vector<long long> oneBitInORPairs(LOG, 0);\\n        for (int i = 0; i < LOG; i++) {\\n            oneBitInORPairs[i] = n * n - (n - oneBit[i]) * (n - oneBit[i]);\\n        }\\n        \\n        // oneBitInTriplets will count for each bit how many times it is set among all triplets\\n        // (nums[i] | nums[j]) & nums[k]\\n        // only 1 & 1 = 1, so it is easy to deduce that \\n        // oneBitInTriplets[i] = oneBit[i] * oneBitInPairs[i] for a bit i\\n        vector<long long> oneBitInTriplets(LOG, 0);\\n        for (int i = 0; i < LOG; i++) {\\n            oneBitInTriplets[i] = oneBit[i] * oneBitInORPairs[i];\\n        }\\n        \\n        // finally, by knowing how many times each individual bit is set among all triplets\\n        // a bit i will be set in xor-beauty of array only if oneBitInTriplets[i] is odd\\n        // this is obvious from XOR property\\n        // you may wonder why we don\\'t consider unset bits in triplets, the reason is simple:\\n        // x XOR 0 = x\\n        long long ans = 0;\\n        for (int i = 0; i < 30; i++) {\\n            if (oneBitInTriplets[i] % 2 == 1) {\\n                ans += (1 << i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        // we can solve this problem independently for each bit\\n        const int LOG = 30;\\n        long long n = nums.size();\\n\\n        // onebit will count for each bit how many times it is set in the array\\n        // to check how many times bit i is unset we can simply subtract oneBit[i] from n\\n        vector<long long> oneBit(LOG, 0);\\n        for (auto &it : nums) {\\n            for (int i = 0; i < LOG; i++) {\\n                if ((1 << i) & it) {\\n                    oneBit[i]++;\\n                }\\n            }\\n        }\\n\\n        // oneBitInORPairs will count for each bit how many times it is set among\\n        // all pairs nums[i] | nums[j]\\n        // it can be calculated as follows:\\n        // there are n * n total pairs or numbers, and only those pairs\\n        // in which both numbers have the bit set to 0 will have the bit set to 0 after we | them\\n        vector<long long> oneBitInORPairs(LOG, 0);\\n        for (int i = 0; i < LOG; i++) {\\n            oneBitInORPairs[i] = n * n - (n - oneBit[i]) * (n - oneBit[i]);\\n        }\\n        \\n        // oneBitInTriplets will count for each bit how many times it is set among all triplets\\n        // (nums[i] | nums[j]) & nums[k]\\n        // only 1 & 1 = 1, so it is easy to deduce that \\n        // oneBitInTriplets[i] = oneBit[i] * oneBitInPairs[i] for a bit i\\n        vector<long long> oneBitInTriplets(LOG, 0);\\n        for (int i = 0; i < LOG; i++) {\\n            oneBitInTriplets[i] = oneBit[i] * oneBitInORPairs[i];\\n        }\\n        \\n        // finally, by knowing how many times each individual bit is set among all triplets\\n        // a bit i will be set in xor-beauty of array only if oneBitInTriplets[i] is odd\\n        // this is obvious from XOR property\\n        // you may wonder why we don\\'t consider unset bits in triplets, the reason is simple:\\n        // x XOR 0 = x\\n        long long ans = 0;\\n        for (int i = 0; i < 30; i++) {\\n            if (oneBitInTriplets[i] % 2 == 1) {\\n                ans += (1 << i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015563,
                "title": "java-easy-to-understand-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter solving the expression we observe that its equal to XOR of all the numbers only.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo we need to just xor all the elements in the array and return the final result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for(int i:nums){\\n            xor^=i;\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for(int i:nums){\\n            xor^=i;\\n        }\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015498,
                "title": "c-simple-explaination-worth-reading",
                "content": "*if u find anything ambigious please feel free to ask*\\n**xor of even number of  equal elements results 0**\\n**xor of odd number of equal elements result the element itself**\\n\\n                    only 3 cases\\n\\t1) All 3 are different\\n\\t2) two equal one different\\n\\t3) all equal\\n \\n \\n** case 1**\\n```\\nfirst consider all are different indices ie\\nx,y,z \\nx !=y, y!=z and x!=z\\n```\\n\\n\\n\\n```if we consider the permutations for above x,y,z\\nwe get  6 permuations (3!)\\nx y z\\ny x z\\ny z x\\nz y x\\nz x y\\nx z y\\n\\nif u observe first two permutations they are equal  so xor of it will result 0 and similarly remaining 4 permutations.\\n\\nie (x|y)&z==(y|x)&z\\n \\n so all 6 permutations will get cancelled after doing xor operation\\n\\n****case 2****\\n\\nnow consider  two  equal and one is different   ie 3 permutations\\n    x,x,y\\n    x,y,x\\n\\ty,x,x\\n\\t\\n\\tbelow two are equal so their xor results 0 and the remaining one (above one) is (x,x,y)\\n\\t\\n\\tnow think that there will be a permuation with two y\\'s and one x\\n\\t  ie y y x\\n\\t     y x y\\n\\t\\t x y y\\n\\t\\t \\n\\t\\tso the remaining permutation will be (y,y,x)\\n\\t\\t\\n\\t\\t\\n\\t\\tif we observe the two remaning permutations \\n\\t\\t      (x,x,y) and (y,y,x)\\n\\t\\t\\t  \\n\\t\\t\\t  they will also get canceled as  (x|x)&y==(y|y)&x    \\n\\t\\t\\t  \\nso 2nd case also got cancelled after doing xor operation.\\n\\t\\t\\t  \\n\\t\\t\\t  \\n  Now we are left with third case\\n  \\n         the x,x,x   i.e (all are equal)\\n\\n (x|x)&x=x;\\n\\n\\n\\n  so the solution is  xor of  the all  array elements\\n\\t\\t \\n\\t\\t  \\n\\t\\t  \\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nfirst consider all are different indices ie\\nx,y,z \\nx !=y, y!=z and x!=z\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015467,
                "title": "c-easy-explanation-for-xor-ing-all-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is really no intuition for this, you have to write it down on pen and paper and calculate the expression of the final answer, here\\'s how I did it\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI took the example of [1, 4] as [x, y] then I tried to find the final expression \\n=> (((x | x) & x) ^ ((x | x) & y) ^ ((x | y) & x) ^ ((x | y) & y) ^ ((y | x) & x) ^ ((y | x) & y) ^ ((y | y) & x) ^ ((y | y) & y))\\n\\n=> x ^ (x & y) ^ ((x | y) & x) ^ ((x | y) & y) ^ ((y | x) & x) ^ ((y | x) & y) ^ (y & x) ^ y  \\n(since, x | x == x and x & x == x)\\n\\nUsing the following basic boolean/bitwise operation properties\\n1) x ^ x == 0\\n2) x & y == y & x\\n2) (x | y) & x == (y | x) & x \\n\\nWe can see that all the elements from (x & y) to (y & x) cancel each other out, and the only expression that remains is x ^ y\\n\\nThis can be extrapolated to array of all lengths, and thus the answer just comes out as the XOR of all the elements.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        for(int x : nums)\\n            ans ^= x;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        for(int x : nums)\\n            ans ^= x;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015418,
                "title": "c-1-line-code-solution",
                "content": "Upvote if this you like \\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0; for(auto i:nums) ans^=i; return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0; for(auto i:nums) ans^=i; return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015215,
                "title": "python-1-line-solution-two-cases",
                "content": "The goal is to calculate the `xor` sum of  `s(i,j,k) = (nums[i] | nums[j]) & nums[k]` for all possible (i, j, k)\\nWe just need to consider TWO case:\\n1.  For `nums[i]!=nums[j]`, we will have `s(i, j, k)==s(j, i, k)`, which results as `s(i, j, k)^s(j, i, k)=0`\\n2. For `nums[i]==nums[j]`, we will have `s(i, i, k)=(nums[i] | nums[i]) & nums[k] = nums[i] & nums[k])`\\n\\tIt results in `s(i, i, k)^s(k, k, i)=0` for all `i!=k`\\n\\tThe only remaining item is `i==k` as `s(i,i,i) = nums[i]`\\n\\nAs a result, the final answer is xor sum of nums\\n```\\ndef xorBeauty(self, nums: List[int]) -> int:\\n\\treturn reduce(ixor, nums)\\n```",
                "solutionTags": [],
                "code": "```\\ndef xorBeauty(self, nums: List[int]) -> int:\\n\\treturn reduce(ixor, nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3015125,
                "title": "an-interesting-solution-video-explanation",
                "content": "## Explanation\\n\\nhttps://www.youtube.com/watch?v=d4h6bTjWOPI\\n\\n[Click here if the preview doesn\\'t work](https://www.youtube.com/watch?v=d4h6bTjWOPI)\\n\\n## Code\\n```\\ntypedef long long int ll;\\n\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int result = 0;\\n        \\n        for (int j = 0; j < 30; j ++) {\\n            ll set_bits = 0;\\n            ll unset_bits = 0;\\n            \\n            for (auto i : nums)\\n                if (i & (1 << j)) set_bits ++;\\n                else unset_bits ++;\\n            \\n            ll total_triplets_with_set_bit = (unset_bits * set_bits * set_bits) * 2 + (set_bits * set_bits * set_bits);\\n            if (total_triplets_with_set_bit % 2 == 1) \\n                result += (1 << j);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int result = 0;\\n        \\n        for (int j = 0; j < 30; j ++) {\\n            ll set_bits = 0;\\n            ll unset_bits = 0;\\n            \\n            for (auto i : nums)\\n                if (i & (1 << j)) set_bits ++;\\n                else unset_bits ++;\\n            \\n            ll total_triplets_with_set_bit = (unset_bits * set_bits * set_bits) * 2 + (set_bits * set_bits * set_bits);\\n            if (total_triplets_with_set_bit % 2 == 1) \\n                result += (1 << j);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015115,
                "title": "easy-and-understandable-c-beats-80-efficient-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans=(ans ^ nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans=(ans ^ nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015082,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) \\n    {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++) \\n            ans ^= nums[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) \\n    {\\n        int ans = 0;\\n        for(int i=0; i<nums.size(); i++) \\n            ans ^= nums[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015017,
                "title": "c-java-python3-math",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7360be4d63ffa8b13518401baa628a6f6800d326) for solutions of weekly 95. \\n\\n**Intuition**\\nMath! The final answer is `(v|v) & v` where `v` is the xor of all numbers. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int val = 0; \\n        for (auto& x : nums) val ^= x; \\n        return val; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int val = 0; \\n        for (int x : nums) val ^= x; \\n        return val; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(xor, nums)\\n```\\n**Complexity**\\nTime `O(N)`\\nSpace `O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int val = 0; \\n        for (auto& x : nums) val ^= x; \\n        return val; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int val = 0; \\n        for (int x : nums) val ^= x; \\n        return val; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(xor, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014948,
                "title": "python-one-line",
                "content": "# Intuition\\nWhen you read it, it acutally asks to xor all elements\\n\\n# Approach\\nWhen you read it, it acutally asks to xor all elements\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom functools import reduce\\nfrom operator import xor\\n\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(xor, nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nfrom operator import xor\\n\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(xor, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014944,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    void getCnt(const vi(int)&v, vi(ll)&cnt){ // prefix\\n            vi(ll)osf(32); // osf[i]=count of numbers with ith bit set (Ones So Far)\\n            for(ll i=0;i<v.size();++i){\\n                for(ll j=0;j<32;++j){\\n                    if((v[i]>>j)&1){\\n                        cnt[j]+=2*i+1; // *2 for duplicacy, +1 for the pair (i,i)\\n                    }\\n                    else{\\n                        cnt[j]+=2*osf[j]; // just couple with existing ones, no other choice\\n                    }\\n                    osf[j]+=(v[i]>>j)&1;\\n                }\\n            }\\n    }\\n    // a triplet ((i | j) & k) is effective if it evaluates to 1\\n    int xorBeauty(vector<int>&v) {\\n        ll ans=0;\\n        vi(ll)cnt(32); // cnt[i]=count of numbers having ith bit set\\n        getCnt(v, cnt);\\n        for(ll i=0;i<32;++i){ // preparing the ith bit of the answer\\n            bool odd=0; // for ith bit to be set, count of effective triplets should be odd, due to XOR property\\n            for(ll it:v){ // think of \\'it\\' as the \\'k\\' in the expression \\'(i | j) & k\\'\\n                if(((it>>i)&1) && (cnt[i]&1)){\\n                    odd=!odd;\\n                }\\n                // ((it>>i)&1) -> if current bit is zero, all triplets formed will be ineffective, as the bit will be zero, regardless of the remaining part of the expression (i | j)\\n                // (cnt[i]&1) -> count of pairs with ith bit set must be odd for ith bit of the overall XOR to be set\\n            }\\n            if(odd){\\n                ans|=1LL<<i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    void getCnt(const vi(int)&v, vi(ll)&cnt){ // prefix\\n            vi(ll)osf(32); // osf[i]=count of numbers with ith bit set (Ones So Far)\\n            for(ll i=0;i<v.size();++i){\\n                for(ll j=0;j<32;++j){\\n                    if((v[i]>>j)&1){\\n                        cnt[j]+=2*i+1; // *2 for duplicacy, +1 for the pair (i,i)\\n                    }\\n                    else{\\n                        cnt[j]+=2*osf[j]; // just couple with existing ones, no other choice\\n                    }\\n                    osf[j]+=(v[i]>>j)&1;\\n                }\\n            }\\n    }\\n    // a triplet ((i | j) & k) is effective if it evaluates to 1\\n    int xorBeauty(vector<int>&v) {\\n        ll ans=0;\\n        vi(ll)cnt(32); // cnt[i]=count of numbers having ith bit set\\n        getCnt(v, cnt);\\n        for(ll i=0;i<32;++i){ // preparing the ith bit of the answer\\n            bool odd=0; // for ith bit to be set, count of effective triplets should be odd, due to XOR property\\n            for(ll it:v){ // think of \\'it\\' as the \\'k\\' in the expression \\'(i | j) & k\\'\\n                if(((it>>i)&1) && (cnt[i]&1)){\\n                    odd=!odd;\\n                }\\n                // ((it>>i)&1) -> if current bit is zero, all triplets formed will be ineffective, as the bit will be zero, regardless of the remaining part of the expression (i | j)\\n                // (cnt[i]&1) -> count of pairs with ith bit set must be odd for ith bit of the overall XOR to be set\\n            }\\n            if(odd){\\n                ans|=1LL<<i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014912,
                "title": "python3-iteration-solution-for-reference",
                "content": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        OR = 0 \\n        for i in range(N):\\n            OR = OR | nums[i]\\n            \\n        for i in range(N):\\n            nums[i] &= OR\\n        \\n        ans = 0 \\n        \\n        for i in nums:\\n            ans ^= i\\n        \\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        OR = 0 \\n        for i in range(N):\\n            OR = OR | nums[i]\\n            \\n        for i in range(N):\\n            nums[i] &= OR\\n        \\n        ans = 0 \\n        \\n        for i in nums:\\n            ans ^= i\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 4079966,
                "title": "one-line-solution-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar xorBeauty = function(nums) {\\n      return nums.reduce((a, b) => a ^ b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar xorBeauty = function(nums) {\\n      return nums.reduce((a, b) => a ^ b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049818,
                "title": "java-solution-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int x = nums[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            x = x^nums[i];\\n\\n        return x;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int x = nums[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            x = x^nums[i];\\n\\n        return x;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035653,
                "title": "find-xor-beauty-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978727,
                "title": "xor-the-all-element-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nXor all the element of the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhy it\\'s work\\n1. for every (i, j, k) exist in pair except (i==j==k)\\n2. as we know if element in pair then, when we xor it\\'s result will be 0.\\n3. when (i=j=k), (a[i]|a[j])&a[k] = a[i], element itself \\n4. so xoring all the element, it will gives you result of the all triplet.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n\\n        int xr=0;\\n        for(auto x: nums)\\n        xr^=x;\\n\\n        return xr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n\\n        int xr=0;\\n        for(auto x: nums)\\n        xr^=x;\\n\\n        return xr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885916,
                "title": "beats-98-with-o-n-linear-time-complexity-simple-and-easy-to-understand-beginner-friendly-code",
                "content": "# Intuition\\nLooking like the XOR of all the element in the nums gives the ans.\\nUnderstand why it gives the solution below.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n---\\n\\n\\n### Why XOR of all the elements  gives the solution ?\\n#### Discussion - \\n**for eg . [1,4]**\\nthe solution is given by : \\n**Explanation:** \\nThe triplets and their corresponding effective values are listed below:\\n- (0,0,0) with effective value ((1 | 1) & 1) = 1\\n- (0,0,1) with effective value ((1 | 1) & 4) = 0\\n- (0,1,0) with effective value ((1 | 4) & 1) = 1\\n- (0,1,1) with effective value ((1 | 4) & 4) = 4\\n- (1,0,0) with effective value ((4 | 1) & 1) = 1\\n- (1,0,1) with effective value ((4 | 1) & 4) = 4\\n- (1,1,0) with effective value ((4 | 4) & 1) = 0\\n- (1,1,1) with effective value ((4 | 4) & 4) = 4 \\nXor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = **5**.\\n\\nhence, the ans can also be written as -\\n=>((1 | 1) & 1)^((1 | 1) & 4)^((1 | 4) & 1)^((1 | 4) & 4)^((4 | 1) & 1)^((4 | 1) & 4)^((4 | 4) & 1)^((4 | 4) & 4)\\n\\n=>(1 & 1)^(1 & 4)^(5 & 1)^(5 & 4)^(5 & 1)^(5 & 4)^(4 & 1)^(4 & 4)\\n\\nhence, all the term except the term which consits of only combination of same element is come twice which result in cancelling of each other.\\nSo, the solution of this problem is given by **(1 & 1)^(4 & 4) = 1 ^ 4 = 5**. \\n\\n---\\n\\n\\n\\n### ALGORITHM --XOR Beauty-- \\n1. Start with an integer variable **ans** initialized to 0. This variable will store the XOR beauty of the array.\\n2. Iterate through each element of the **nums** array from index 0 to the last index:\\n3. Let the current element be **nums[i]**.\\n4. Perform the XOR operation b/w the current value of ans and **nums[i]** and update the value of ans with the result of the XOR operation.\\n5. After iterating through all the elements in the array, the **ans** variable will contain the XOR beauty of the array.\\n6. Return the value of **ans** as the result of the xorBeauty function.\\n\\n**Here\\'s a summarized version of the algorithm steps:**\\n1. Initialize ans to 0.\\n2. For each element nums[i] in the array:\\n3. Update ans by performing XOR operation: ans ^= nums[i].\\n4. Return the final value of ans as the XOR beauty of the array.\\n5. \\n\\n---\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        //xor beauty is \\n        int ans = 0 ; \\n        for(int i = 0;i < nums.size();i++){\\n            ans ^= nums[i] ; \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        //xor beauty is \\n        int ans = 0 ; \\n        for(int i = 0;i < nums.size();i++){\\n            ans ^= nums[i] ; \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848441,
                "title": "c-easy-solution-beats-96-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint xorBeauty(vector<int>& nums) {\\n\\t\\tint Xor=0;\\n\\t\\tfor(const auto& i:nums) {\\n\\t\\t\\tXor^=i;\\n\\t\\t}\\n\\t\\treturn Xor;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint xorBeauty(vector<int>& nums) {\\n\\t\\tint Xor=0;\\n\\t\\tfor(const auto& i:nums) {\\n\\t\\t\\tXor^=i;\\n\\t\\t}\\n\\t\\treturn Xor;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846773,
                "title": "layman-thinking-beginners-based-on-observation-noob-s-best-solution",
                "content": "# Intuition + Code\\n```\\n/*\\n        My Thinking Approach\\n        ---------------------\\n\\n        Note: Use Pen and Paper for better Intuition\\n\\n        #CASE 0:\\n\\n        if (i != j != k)\\n            0 1 2 -> (0 | 1) & 2\\n            0 2 1 -> (0 | 2) & 1\\n            1 0 2 -> (0 | 1) & 2\\n            1 2 0 -> (1 | 2) & 0\\n            2 1 0 -> (2 | 1) & 0\\n            2 0 1 -> (2 | 0) & 1\\n        By symetry, it is evident that\\n            XOR beauty of this part is 0 - (#0)\\n\\n        ----------------------\\n\\n        #CASE 1:\\n\\n        if (i == j == k)\\n            Effective value: nums[k]\\n        So for i == j == k\\n            XOR beauty of this part is XOR of all elements - (#1)\\n\\n        ----------------------\\n\\n        #CASE 2:\\n\\n        if(i == j) and i != k and j != k\\n            Effective value: nums[i] & nums[k]\\n        For i == j and n == 3\\n            0 0 1 -> 0 & 1\\n            0 0 2 -> 0 & 2\\n            1 1 0 -> 1 & 0\\n            1 1 2 -> 1 & 2\\n            2 2 0 -> 2 & 0\\n            2 2 1 -> 2 & 1\\n            \\n        Due to symetry, XOR beauty of this part is 0 - (#2)\\n\\n        ---------------------\\n\\n        #CASE 3:\\n\\n        if(i == k), if(j == k), but i != j\\n      \\n        For i != j\\n            1. i == k\\n                0 1 0 -> (0 | 1) & 0 -> it has (1 | 0) & 0 in j == k\\n                0 2 0 -> (0 | 2) & 0\\n                1 0 1 -> (1 | 0) & 1\\n                1 2 1 -> (1 | 2) & 1\\n                2 0 2 -> (2 | 0) & 2\\n                2 1 2 -> (2 | 1) & 2\\n            2. j == k\\n                0 1 1 -> (0 | 1) & 1\\n                0 2 2 -> (0 | 2) & 2\\n                1 0 0 -> (1 | 0) & 0\\n                1 2 2 -> (1 | 2) & 2\\n                2 0 0 -> (2 | 0) & 0\\n                2 1 1 -> (2 | 1) & 1\\n\\n        Due to symetry, XOR beauty of this part is 0 - (#3)\\n\\n        FROM #0, #1, #2, #3,\\n            the required answer is #1 => XOR of all elements\\n    */\\n\\n\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for(int i = 0; i < nums.length; i++)\\n            xor ^= nums[i];\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n        My Thinking Approach\\n        ---------------------\\n\\n        Note: Use Pen and Paper for better Intuition\\n\\n        #CASE 0:\\n\\n        if (i != j != k)\\n            0 1 2 -> (0 | 1) & 2\\n            0 2 1 -> (0 | 2) & 1\\n            1 0 2 -> (0 | 1) & 2\\n            1 2 0 -> (1 | 2) & 0\\n            2 1 0 -> (2 | 1) & 0\\n            2 0 1 -> (2 | 0) & 1\\n        By symetry, it is evident that\\n            XOR beauty of this part is 0 - (#0)\\n\\n        ----------------------\\n\\n        #CASE 1:\\n\\n        if (i == j == k)\\n            Effective value: nums[k]\\n        So for i == j == k\\n            XOR beauty of this part is XOR of all elements - (#1)\\n\\n        ----------------------\\n\\n        #CASE 2:\\n\\n        if(i == j) and i != k and j != k\\n            Effective value: nums[i] & nums[k]\\n        For i == j and n == 3\\n            0 0 1 -> 0 & 1\\n            0 0 2 -> 0 & 2\\n            1 1 0 -> 1 & 0\\n            1 1 2 -> 1 & 2\\n            2 2 0 -> 2 & 0\\n            2 2 1 -> 2 & 1\\n            \\n        Due to symetry, XOR beauty of this part is 0 - (#2)\\n\\n        ---------------------\\n\\n        #CASE 3:\\n\\n        if(i == k), if(j == k), but i != j\\n      \\n        For i != j\\n            1. i == k\\n                0 1 0 -> (0 | 1) & 0 -> it has (1 | 0) & 0 in j == k\\n                0 2 0 -> (0 | 2) & 0\\n                1 0 1 -> (1 | 0) & 1\\n                1 2 1 -> (1 | 2) & 1\\n                2 0 2 -> (2 | 0) & 2\\n                2 1 2 -> (2 | 1) & 2\\n            2. j == k\\n                0 1 1 -> (0 | 1) & 1\\n                0 2 2 -> (0 | 2) & 2\\n                1 0 0 -> (1 | 0) & 0\\n                1 2 2 -> (1 | 2) & 2\\n                2 0 0 -> (2 | 0) & 0\\n                2 1 1 -> (2 | 1) & 1\\n\\n        Due to symetry, XOR beauty of this part is 0 - (#3)\\n\\n        FROM #0, #1, #2, #3,\\n            the required answer is #1 => XOR of all elements\\n    */\\n\\n\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0;\\n        for(int i = 0; i < nums.length; i++)\\n            xor ^= nums[i];\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845430,
                "title": "beats-96-70-0-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808049,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nConstant Time. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> store;\\n        int ans = 0;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            ans ^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> store;\\n        int ans = 0;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            ans ^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701642,
                "title": "100-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int x=0;\\n       for(int i=0;i<nums.size();i++){\\n           x^=nums[i];\\n       }\\n  return x;  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int x=0;\\n       for(int i=0;i<nums.size();i++){\\n           x^=nums[i];\\n       }\\n  return x;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699148,
                "title": "very-easy-solution-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int total=0;\\n        for(int i=0;i<nums.length;i++){\\n            total^=nums[i];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int total=0;\\n        for(int i=0;i<nums.length;i++){\\n            total^=nums[i];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684932,
                "title": "java-most-efficient-code-beats-100-in-tc-sc-1-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor=0;\\n        for(int i=0;i<nums.length;i++)\\n            xor=xor^nums[i];\\n        return xor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor=0;\\n        for(int i=0;i<nums.length;i++)\\n            xor=xor^nums[i];\\n        return xor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659967,
                "title": "c-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int a = 0, b = 0;\\n        for(auto &i: nums){\\n            a|=i;\\n            b^=i;\\n        }\\n        return (a&b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int a = 0, b = 0;\\n        for(auto &i: nums){\\n            a|=i;\\n            b^=i;\\n        }\\n        return (a&b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626860,
                "title": "complex-beauty-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> bit(32 , 0);\\n        int ans = 0;\\n\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < 32 ; j++) {\\n                if((nums[i] & (1 << j))) {\\n                    bit[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0 ; i < 32 ; i++) {\\n            if(bit[i] && (long long)pow(bit[i] , 2) % 2 != 0) ans ^= (1 << i);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> bit(32 , 0);\\n        int ans = 0;\\n\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < 32 ; j++) {\\n                if((nums[i] & (1 << j))) {\\n                    bit[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0 ; i < 32 ; i++) {\\n            if(bit[i] && (long long)pow(bit[i] , 2) % 2 != 0) ans ^= (1 << i);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599153,
                "title": "javascript-easy-method-beats-100-faster-beginner-s-friendly",
                "content": "```\\nconst xorBeauty = function(nums) {\\n    let result = 0\\n    for(let i=0;i<nums.length;i++) result ^= nums[i];\\n    return result\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst xorBeauty = function(nums) {\\n    let result = 0\\n    for(let i=0;i<nums.length;i++) result ^= nums[i];\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543913,
                "title": "c-easy-to-understand-clean-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int val=0;\\n        // element with self (a|a)&a=a;\\n        //but other numbers are get repeate combinations\\n        /*\\n        like (a|b)&c\\n        but also exist in array another combination (b|a)&c and both values are same \\n        so there xor get 0\\n        so ultimately only number exist in arry are possible so find there xor directly\\n        */\\n        //if(nums.size()==1) return 0;\\n        for(auto it:nums) val^=it;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int val=0;\\n        // element with self (a|a)&a=a;\\n        //but other numbers are get repeate combinations\\n        /*\\n        like (a|b)&c\\n        but also exist in array another combination (b|a)&c and both values are same \\n        so there xor get 0\\n        so ultimately only number exist in arry are possible so find there xor directly\\n        */\\n        //if(nums.size()==1) return 0;\\n        for(auto it:nums) val^=it;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540730,
                "title": "simple-cpp-code-xor-operator",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i:nums){\\n            ans^=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i:nums){\\n            ans^=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494241,
                "title": "c-and-java-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere we have to consider allthe combinations possible of i,j and k\\nwhich means->\\ni:(0->n-1) j:(0->n-1) k:(0->n-1)\\nThis would account to n^3 combinations \\ndoing a abrute force will take the TC to 1e5x3\\nNow how to solve it, we konow that if a ano is xored even no of times it becomes 0(no contribution in result)\\nnow if you will do a ompl xors of all these combinations then you will get that only those triplets in which i==j==k, are appearing one time and other triplets are appearing even no of times. Why?\\nlets take a ex [1,4,5]\\n\\nsee, for a particular i say 0->nums[0]->1\\ntriplets i=0:\\n1,1,1\\n1,1,4\\n1,1,5\\n1,4,1\\n1,4,4\\n1,4,5\\n1,5,1\\n1,5,4\\n1,5,5\\nnow we know that or and && operators are commutative ie;a or b==b or a and && also works the same way.\\nHere for every j and k of a i=0 another triplet with swapped values of j and k also exist\\nlike if there is a 1,1,4\\nthen at some point j will also take 4 and k 1\\nwhich would result the same thing 1&&(1||4) and 1&&(4||1) respectively\\nsince the by comm prop of or this would result the same and contribute in a even count to the total xor result so there is no need to take this into consideration(as it is 0) the same goes with every diff pairs of j and kof every i bcz j and k are having every poss value from 0->n-1\\nnow for j==k would result in same nums[j] after or and the result will be nums[i]&&nums[j]\\nnow for this also a pair exist which is nums[j]&&nums[i]\\nwhich will be the result of i->curr j value and j==k->curr i value\\nexample 1,4,4 will be same as 4,1,1 check it by your own 1&&4 == 4&&1\\njust if all thre i==j==k are equal then there would not be any pair for this that can be finally taken into consideartion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n**PLS UPVOTE**\\n# C++\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans^=nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans^=nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480914,
                "title": "rust-python-with-math-proof",
                "content": "# Intuition\\nIn total you have $n^3$ tripplets and you can divide them into 3 groups. \\n\\n 1. `i, j, k` are all different. This is most frequent use case.\\n 2. there are exactly 2 duplicates (either `i == j` or `i == k` or `j == k`). This is second by frequency (you will have `3 * n (n + 1)` such tripplets)\\n 3. all indices are the same. `i == j == k`. This is the least frequent case (you will only have `n` such trippplets)\\n\\nLets assume that the values at those positions are `a, b, c`. The values there might be the same, but here we assume that they are different.\\n\\nLets start with **item 3** as it is the easiest to reason about as the formula becomes `(a | a) & a = a`. So in this case the xoring of all such elements will be xor of all values in array\\n\\nSurprisingly the second easiest is **item 1**. Here you will have 6 possible cases:\\n\\n1. `(a | b) & c`\\n2. `(a | c) & b`\\n3. `(b | c) & a`\\n4. `(b | a) & c`\\n5. `(c | a) & b`\\n6. `(c | b) & a`\\n\\nNotice that here the values 1 and 4 are the same (so xoring them is 0). Similar 2 and 5 are the same and 3 and 6. So xoring all of it is 0. And therefore xoring all unique tripplets is also zero\\n\\nAnd last is **item 2** where we also have 6 cases:\\n\\n1. `(a | a) & b = a & b`\\n2. `(a | b) & a = a`\\n3. `(b | a) & a = a`\\n4. `(b | b) & a = b & a`\\n5. `(b | a) & b = b`\\n6. `(a | b) & b = b`\\n\\nHere `1 = 4`, `2 = 3`, `5 = 6`. So xoring is also zero. \\n\\nSo in the end we have only xoring of all elements.\\n\\n# Rant\\nI personally do not like such questions (where it is very easy to guess the answer and coding is trivial, but it is very hard to prove it). This is happening with some math questions or questions with greedy strategies where you see that greedy works, but can\\'t figure out why.\\n\\nI was able to see that xoring works here after just a few custom cases in just a few minutes. But it took me ~30 mins to gain some intuition why it might work and even more to get a full proof. \\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n```Rust []\\nimpl Solution {\\n  pub fn xor_beauty(nums: Vec<i32>) -> i32 {\\n    let mut res = 0;\\n    for v in nums {\\n      res ^= v;\\n    }\\n    return res;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def xorBeauty(self, nums: List[int]) -> int:\\n    res = 0\\n    for v in nums:\\n      res ^= v\\n    return res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Math"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn xor_beauty(nums: Vec<i32>) -> i32 {\\n    let mut res = 0;\\n    for v in nums {\\n      res ^= v;\\n    }\\n    return res;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def xorBeauty(self, nums: List[int]) -> int:\\n    res = 0\\n    for v in nums:\\n      res ^= v\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464002,
                "title": "2-liner-code-beats-100-java-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int XOR = 0;\\n        for(int i =0;i<nums.length;i++){XOR = XOR ^ nums[i];}\\n        return XOR;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int XOR = 0;\\n        for(int i =0;i<nums.length;i++){XOR = XOR ^ nums[i];}\\n        return XOR;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411890,
                "title": "why-take-the-xor-of-the-array-pen-and-copy",
                "content": "# Intuition\\n![WhatsApp Image 2023-04-13 at 13.30.55.jpeg](https://assets.leetcode.com/users/images/da4ce6e8-af5b-4e4d-b45c-ab73a149b136_1681372955.6806855.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum=sum^nums[i];\\n        }\\n        return sum;     \\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum=sum^nums[i];\\n        }\\n        return sum;     \\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411780,
                "title": "just-take-the-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum=sum^nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum=sum^nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394176,
                "title": "bit-manipulation-o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for (auto i : nums) ans^=i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for (auto i : nums) ans^=i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386990,
                "title": "easy-solution-in-c-two-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint xorBeauty(int* nums, int numsSize){\\nint i,j,res=0;\\nfor(i=0;i<numsSize;i++)\\nres^=nums[i];\\nreturn res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint xorBeauty(int* nums, int numsSize){\\nint i,j,res=0;\\nfor(i=0;i<numsSize;i++)\\nres^=nums[i];\\nreturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3350343,
                "title": "simple-1-line-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<functional>\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<functional>\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3339944,
                "title": "fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto x:nums)ans^=x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto x:nums)ans^=x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336574,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i: nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i: nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319370,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func xorBeauty(_ nums: [Int]) -> Int {\\n        nums.reduce(0, ^)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func xorBeauty(_ nums: [Int]) -> Int {\\n        nums.reduce(0, ^)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317168,
                "title": "100-runtime-easy-approach-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint xorBeauty(int* nums, int numsSize){\\n    int result=0;\\n    for(int i=0; i<numsSize; i++){\\n        result^=nums[i];\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint xorBeauty(int* nums, int numsSize){\\n    int result=0;\\n    for(int i=0; i<numsSize; i++){\\n        result^=nums[i];\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3288758,
                "title": "easy-java-i-am-idiot-thinking-about-complex-approaches-its-so-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0 ;\\n        for(int i =  0;i<nums.length ;i++){\\n            xor = xor ^ nums[i];\\n            \\n           \\n        }\\n       \\n        return xor ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int xor = 0 ;\\n        for(int i =  0;i<nums.length ;i++){\\n            xor = xor ^ nums[i];\\n            \\n           \\n        }\\n       \\n        return xor ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282692,
                "title": "java-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 1ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] arr) {\\n       int i=1;\\n\\t\\twhile(i<arr.length){\\n\\t\\t    arr[0]^=arr[i];\\n\\t\\t    i++;}return arr[0];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] arr) {\\n       int i=1;\\n\\t\\twhile(i<arr.length){\\n\\t\\t    arr[0]^=arr[i];\\n\\t\\t    i++;}return arr[0];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280643,
                "title": "c-solution-enjoyed-the-process",
                "content": "**Question statement:**\\n\\n*You are given a 0-indexed integer array nums.*\\n\\n*The effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).*\\n\\n*The xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.*\\n\\n*Return the xor-beauty of nums.*\\n\\n**Solution:**\\n\\n**indices** i, j and k need not to be distinct.\\n\\nlet a, b, c be the **values** of i, j and k, a != b, b != c, c != a.\\n\\nFor example, if a = 2, and i = a, j = a, then i = 2, j = 2.\\n\\nWe noted the following possible configurations:\\n\\n1. ((a | b) & c)\\n2. ((a | a) & c)\\n3. ((a | c) & a)\\n4. ((a | a) & a)\\n\\nFor pattern 1, all values are distinct **[case 1]**\\nFor pattern 2 to 3, there are 2 distinct types of values. **[case 2]**\\nFor pattern 4, there is only one type of value. **[case 3]**\\n\\n**[case 3] explanation**\\n(a | a) = a, and a & a = a.\\nValue of a = refers to index in array.\\nPossible indices of array of size n = (0 to n - 1)\\nSo, there are n values with pattern ((a | a) & a).\\n\\n**[case 2] explanation**\\nPattern 2: ((a | a) & c). How many such patterns are there?\\nSince c != a, and (a | a) = a.\\nSo, pattern 2 = ((a | a) & c) = (a & c)\\nNotice that, if ((a | a) & c)  exists, we must be able to find ((c | c) & a)\\n((a | a) & c) = ((c | c) & a). Easy, because (a & c) = (c & a)...\\n\\nOk, next, notice that, if we XOR two identical values, we have:\\na ^ a = 0, then 0 ^ a = a, then a ^ a = 0, ... (XOR, easy idea).\\n\\nSo, if we apply XOR even number of times, the result is 0.\\nSince ((a | a) & c) = ((c | c) & a), there are 2 (a & c), the count is even. \\nSo, they all cancelled out, bye.\\n\\nHow about ((a | c) & a) and ((a | c) & c)? \\nRemember than i, j, k need not to be distinct. \\nSo, ((a | c) & a) and ((c | a) & a) will co-exist, \\n((a | c) & a) = a, ((c | a) & a) = a, a ^ a = 0, cancelled out, easy.\\n\\n**[case 1] explanation**\\nFinally, we have ((a | b) & c).\\nBy simple combination, we have:\\n1. ((a | b) & c)\\n2. ((a | c) & b)\\n3. ((b | a) & c)\\n4. ((b | c) & a)\\n5. ((c | a) & b)\\n6. ((c | b) & a)\\n\\n1 and 3 cancelled out, 2 and 5 cancelled out, 4 and 6 cancelled out. (XOR) = 0.\\n\\nSo, all **[case 3]** and **[case 2]** have been cancelled out.\\n**[case 1]** left, guys. \\nThere are n values in an array of size n (-_-)... obvious.\\n\\nThe question: XOR all beauty values ba ba ba?\\nXOR all values in array = solution.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            res ^= nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            res ^= nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259928,
                "title": "easy-xor-operation-of-array-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i: nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i: nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250679,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        return accumulate(cbegin(nums), cend(nums), 0, [] (int a, int b) {\\n            return a ^ b;\\n        });        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        return accumulate(cbegin(nums), cend(nums), 0, [] (int a, int b) {\\n            return a ^ b;\\n        });        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223299,
                "title": "python3-solution-1-line-bit-manipulation-approach",
                "content": "```python\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195178,
                "title": "swift-one-liner-nums-reduce-0",
                "content": "**One-Liner (accepted answer)**\\n```\\nclass Solution {\\n    func xorBeauty(_ nums: [Int]) -> Int {\\n        nums.reduce(0,^)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func xorBeauty(_ nums: [Int]) -> Int {\\n        nums.reduce(0,^)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167579,
                "title": "very-simple-just-pure-observation-0ms",
                "content": "# Intuition\\njust pen and paper and yes dry run some test cases\\n\\n# Approach\\ndirectly find the xor of all the elements\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto x:nums)\\n        ans^=x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto x:nums)\\n        ans^=x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164081,
                "title": "c-simple",
                "content": "# Intuition\\nnoticed that x^x = 0.\\nfor a,b,c triple, since (a|b)&c = (b|a)&c, their xor eliminated.\\nfor a,a,b triple, (a|a)&b = a&b, (b|b)&a = b&a. their xor eliminated.\\nfor a,a,a triple, (a|a)&a = a\\nso the answer is xor of all elements in the array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = 0;\\n        for(auto x:nums) res ^= x;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = 0;\\n        for(auto x:nums) res ^= x;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151506,
                "title": "4-line-java-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n          ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n          ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147467,
                "title": "c-2-line-code-easy-solution",
                "content": "# Intuition\\nTraverse the array and find xor of each with previous answer.\\n\\n# Approach\\n- Traverse the array\\n- Take a variable\\n- Find xor of variable with array elements consecutively\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) \\n    {\\n        int x=0;\\n        for(auto i:nums)\\n        {\\n            x=x^i;\\n        }\\n        return x;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) \\n    {\\n        int x=0;\\n        for(auto i:nums)\\n        {\\n            x=x^i;\\n        }\\n        return x;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141044,
                "title": "c-golang-math",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int num: nums) {\\n            ans ^= num;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc xorBeauty(nums []int) int {\\n    var ans int = 0\\n    for _, num := range nums {\\n        ans = ans ^ num\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int num: nums) {\\n            ans ^= num;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc xorBeauty(nums []int) int {\\n    var ans int = 0\\n    for _, num := range nums {\\n        ans = ans ^ num\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140650,
                "title": "c-full-explanation-very-easy",
                "content": "\\n# Approach\\n- This code calculates the XOR beauty of the input array nums. It iterates over the elements of the array and XORs each element with the ans variable. The XOR operation is a bitwise operator in which the result of the operation is 1 if either of the bits is 1 but not both. In other words, if both bits are the same, the result is 0, and if they are different, the result is 1.\\n\\n**Let\\'s take an example to understand the code better:**\\n\\n```\\nInput: nums = [1, 2, 3, 4]\\n\\nOutput: 0\\n\\nExplanation:\\nans = 0 ^ 1 = 1\\nans = 1 ^ 2 = 3\\nans = 3 ^ 3 = 0\\nans = 0 ^ 4 = 4\\n\\nThe final value of `ans` is 0.\\n```\\n\\n- In this example, the elements of the nums array are 1, 2, 3, 4. In the first iteration, ans is XORed with nums[0], which is 1. So, ans becomes 0 ^ 1 = 1. In the second iteration, ans is XORed with nums[1], which is 2. So, ans becomes 1 ^ 2 = 3. In the third iteration, ans is XORed with nums[2], which is 3. So, ans becomes 3 ^ 3 = 0. In the last iteration, ans is XORed with nums[3], which is 4. So, ans becomes 0 ^ 4 = 4. The final value of ans is returned as the result of the function.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            ans = ans ^ nums[i];\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nInput: nums = [1, 2, 3, 4]\\n\\nOutput: 0\\n\\nExplanation:\\nans = 0 ^ 1 = 1\\nans = 1 ^ 2 = 3\\nans = 3 ^ 3 = 0\\nans = 0 ^ 4 = 4\\n\\nThe final value of `ans` is 0.\\n```\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            ans = ans ^ nums[i];\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138079,
                "title": "xor-beauty-3-senarios",
                "content": "Let\\'s consider an array `[a,b,c]`\\nSo here total three senarios are possible\\n**Case 1:  a & ( b | c )**\\nso there will also be the snario for value a & ( c | b ), which cancel each other so their xor will be zero.\\n**Case 2 : a & ( b | b )**\\nThis is an extended version of case 1, there will be only one pair for a & ( b | b ), but  there will also be the snario for value b & ( a | a ), which will cancel each other so their xor will be zero again.\\n**Case 3: a & ( a | a )**\\n this is equal to `a`  and it is the only senario left in last , so their xor will be evluated as xor of all element.\\n\\nCode : \\n```class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res=0;\\n        for(int el:nums) res^=el;\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res=0;\\n        for(int el:nums) res^=el;\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121905,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef xor_beauty(nums)\\n    result = 0\\n    nums.each { |n| result = result ^ n }\\n    result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef xor_beauty(nums)\\n    result = 0\\n    nums.each { |n| result = result ^ n }\\n    result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3117014,
                "title": "3-lines-of-code-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int count=0;\\n     for(int i=0;i<nums.size();i++){\\n         count=count^nums[i];\\n     }   \\n     return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int count=0;\\n     for(int i=0;i<nums.size();i++){\\n         count=count^nums[i];\\n     }   \\n     return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112662,
                "title": "xor-operation",
                "content": "# Intuition\\nTo perform XOR Operations\\n\\n# Approach\\nInitialize a variable, (let s) with 0.\\nRun a loop with all the elements in an array\\n    Perform Xor operation with each variable present in the array with its previous result. For the first element xor it with the initialzed variable (say s) where s=0. \\nReturn the final value after performing xor operations with all the variables\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity: O(n)\\n\\n- Space complexity:\\nSpace Complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) \\n    {\\n     int i,s=0;\\n     for(i=0;i<nums.length;i++)\\n     {\\n         s=s^nums[i];\\n     }\\n     return s;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) \\n    {\\n     int i,s=0;\\n     for(i=0;i<nums.length;i++)\\n     {\\n         s=s^nums[i];\\n     }\\n     return s;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107929,
                "title": "easy-c-approch-3-lines-of-codes-bitwise-operator-dont-confuse",
                "content": "# Intuition\\nDont confuse in bitwise operator\\n\\n# Approach\\nonly traverse the array and do res=res^nums[i];and simply return res\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        //this is also a method but thier time complexity is O(n^3)whch is very worst tme complexity so we dont use this method \\n        int n=nums.size();\\n        int res=0;\\n       /* for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    int ans=(nums[i]|nums[j])&nums[k];\\n                    res=res^ans;\\n                }\\n            }\\n        }return res;*/\\n        for(int i=0;i<n;i++){\\n            res=res^nums[i];\\n        }return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        //this is also a method but thier time complexity is O(n^3)whch is very worst tme complexity so we dont use this method \\n        int n=nums.size();\\n        int res=0;\\n       /* for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    int ans=(nums[i]|nums[j])&nums[k];\\n                    res=res^ans;\\n                }\\n            }\\n        }return res;*/\\n        for(int i=0;i<n;i++){\\n            res=res^nums[i];\\n        }return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107718,
                "title": "python-just-xor-each-element-in-the-array",
                "content": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        ans = 0\\n        for num in nums:\\n            ans ^= num\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        ans = 0\\n        for num in nums:\\n            ans ^= num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103992,
                "title": "xor-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res^=nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res^=nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097877,
                "title": "2527-simple-c-solution-4-liner-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& num) {\\n        int x=0;\\n        for(auto i:num)\\n        x^=i;\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& num) {\\n        int x=0;\\n        for(auto i:num)\\n        x^=i;\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096830,
                "title": "simple-c-solution-by-xoring-all-elements-of-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        x^=nums[i];\\n        return x;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++)\\n        x^=nums[i];\\n        return x;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086878,
                "title": "begineer-friendly-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums):\\n        ans = 0\\n        n = len(nums)\\n        for i in range(0, n):\\n            ans ^=nums[i]\\n        return ans\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums):\\n        ans = 0\\n        n = len(nums)\\n        for i in range(0, n):\\n            ans ^=nums[i]\\n        return ans\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081047,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar xorBeauty = function (nums) {\\n  return nums.reduce((a, b) => a ^ b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar xorBeauty = function (nums) {\\n  return nums.reduce((a, b) => a ^ b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080915,
                "title": "c-easy-fast",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int xorBeauty(vector<int>& nums) {\\n\\t\\tint Xor=0;\\n\\t\\tfor(auto i:nums) Xor^=i;\\n\\t\\treturn Xor;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int xorBeauty(vector<int>& nums) {\\n\\t\\tint Xor=0;\\n\\t\\tfor(auto i:nums) Xor^=i;\\n\\t\\treturn Xor;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078920,
                "title": "c-math",
                "content": "# Approach\\n## Reference: https://leetcode.cn/problems/find-xor-beauty-of-array/solution/no6289-cha-xun-shu-zu-xor-mei-li-zhi-by-d5ylk/\\n## !!!This is just a translation version!!!\\nIf by brute force, the code should be:\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        res = 0\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    res ^= (nums[i] | nums[j]) & nums[k]\\n        \\n        return res\\n```\\nBrute force could easily lead to TLE, cause the complexity is $O(n^3)$, we try to simpify it in the following:\\nAssume nums = [a, b, c], follow code above, we could put all effective values as the matrix style:\\n```\\n(a | a) & a     (b | a) & a     (c | a) & a\\n(a | a) & b     (b | a) & b     (c | a) & b\\n(a | a) & c     (b | a) & c     (c | a) & c\\n\\n(a | b) & a     (b | b) & a     (c | b) & a\\n(a | b) & b     (b | b) & b     (c | b) & b\\n(a | b) & c     (b | b) & c     (c | b) & c\\n\\n(a | c) & a     (b | c) & a     (c | c) & a\\n(a | c) & b     (b | c) & b     (c | c) & b\\n(a | c) & c     (b | c) & c     (c | c) & c\\n```\\nFollow the symmetry of bit wise all operation, that is `x | y = y | x`, we could find the above matrix as a symmetric matrix. Also with bit-wise xor operation, `a ^ a = 0`, then we could cancel out all elements except elements on the diagonal:\\n```\\n(a | a) & a     (b | b) & a     (c | c) & a\\n(a | a) & b     (b | b) & b     (c | c) & b\\n(a | a) & c     (b | b) & c     (c | c) & c\\n```\\nAgain, we could find `b | b = b`, `b & a = a & b`, so elements cancel out again. Only remains 3 elements:\\n```\\n(a | a) & a     (b | b) & b     (c | c) & c\\n```\\nFrom here, we know:\\n```\\nresult = a ^ b ^ c\\n```\\n\\n# \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = 0;\\n        for (auto num: nums){\\n            res ^= num;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        n = len(nums)\\n\\n        res = 0\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    res ^= (nums[i] | nums[j]) & nums[k]\\n        \\n        return res\\n```\n```\\n(a | a) & a     (b | a) & a     (c | a) & a\\n(a | a) & b     (b | a) & b     (c | a) & b\\n(a | a) & c     (b | a) & c     (c | a) & c\\n\\n(a | b) & a     (b | b) & a     (c | b) & a\\n(a | b) & b     (b | b) & b     (c | b) & b\\n(a | b) & c     (b | b) & c     (c | b) & c\\n\\n(a | c) & a     (b | c) & a     (c | c) & a\\n(a | c) & b     (b | c) & b     (c | c) & b\\n(a | c) & c     (b | c) & c     (c | c) & c\\n```\n```\\n(a | a) & a     (b | b) & a     (c | c) & a\\n(a | a) & b     (b | b) & b     (c | c) & b\\n(a | a) & c     (b | b) & c     (c | c) & c\\n```\n```\\n(a | a) & a     (b | b) & b     (c | c) & c\\n```\n```\\nresult = a ^ b ^ c\\n```\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = 0;\\n        for (auto num: nums){\\n            res ^= num;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073062,
                "title": "easy-cpp-sol",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n    int res = 0;\\n    for (int i = 0; i < nums.size(); i++) {\\n        res ^= nums[i];\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n    int res = 0;\\n    for (int i = 0; i < nums.size(); i++) {\\n        res ^= nums[i];\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066182,
                "title": "bit-xor-all-the-numbers",
                "content": "```\\nint xorBeauty(vector<int> & n)\\n{\\n\\treturn accumulate(begin(n), end(n), 0, bit_xor{});    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint xorBeauty(vector<int> & n)\\n{\\n\\treturn accumulate(begin(n), end(n), 0, bit_xor{});    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3063959,
                "title": "c-3lines-code-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n//         for(int i:nums){\\n//             ans = ans ^ i;\\n//         }\\n        \\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            // for(int j =0;j<n;j++){\\n                \\n            //     ans = ans ^ (nums[i] & nums[j]);\\n            // }\\n            ans = ans ^ nums[i];\\n        }\\n        \\n        return ans;\\n        // vector<int> temp;\\n        \\n        \\n        // for(int i=0;i<nums.size();i++){\\n        //     for(int j=0;j<nums.size();j++){\\n        //         for(int k =0;k<nums.size();k++){\\n        //             int t = ((nums[i] | nums[j]) & nums[k]);\\n        //             temp.push_back(t);\\n        //         }\\n        //     }\\n        // }\\n        // for(int i=0;i<temp.size() - 1;i++){\\n        //     temp[0] = temp[0] ^ temp[i+1];\\n        // }\\n        // return temp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n//         for(int i:nums){\\n//             ans = ans ^ i;\\n//         }\\n        \\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            // for(int j =0;j<n;j++){\\n                \\n            //     ans = ans ^ (nums[i] & nums[j]);\\n            // }\\n            ans = ans ^ nums[i];\\n        }\\n        \\n        return ans;\\n        // vector<int> temp;\\n        \\n        \\n        // for(int i=0;i<nums.size();i++){\\n        //     for(int j=0;j<nums.size();j++){\\n        //         for(int k =0;k<nums.size();k++){\\n        //             int t = ((nums[i] | nums[j]) & nums[k]);\\n        //             temp.push_back(t);\\n        //         }\\n        //     }\\n        // }\\n        // for(int i=0;i<temp.size() - 1;i++){\\n        //     temp[0] = temp[0] ^ temp[i+1];\\n        // }\\n        // return temp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061519,
                "title": "golang-simple-xor",
                "content": "```\\n// ((x|y)&z) = z\\n// i, j, k => 3*n => k^k^k, i^i^i, j^j^j = > k, i, j \\nfunc xorBeauty(nums []int) int {\\n    x := 0\\n    for i := 0; i < len(nums); i++ {\\n        x ^= nums[i]\\n    }\\n    return x\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// ((x|y)&z) = z\\n// i, j, k => 3*n => k^k^k, i^i^i, j^j^j = > k, i, j \\nfunc xorBeauty(nums []int) int {\\n    x := 0\\n    for i := 0; i < len(nums); i++ {\\n        x ^= nums[i]\\n    }\\n    return x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3060994,
                "title": "easy-xor",
                "content": "# Intuition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = 0;\\n        for(int n : nums)\\n            res ^= n;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = 0;\\n        for(int n : nums)\\n            res ^= n;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059138,
                "title": "easy-to-understand-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int> >help(n,vector<int>(32,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;\\n            int dig=nums[i];\\n            while(dig)\\n            {\\n                int bit=dig&1;\\n                help[i][j]+=bit;\\n                dig=dig>>1;\\n                j++;   \\n            }\\n        }\\n        vector<int> fre(32,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<32;j++)\\n                fre[j]+=help[i][j];\\n        }\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            long long int freq=fre[i];\\n            if(freq%2!=0)\\n                ans+=(pow(2,i));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int> >help(n,vector<int>(32,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;\\n            int dig=nums[i];\\n            while(dig)\\n            {\\n                int bit=dig&1;\\n                help[i][j]+=bit;\\n                dig=dig>>1;\\n                j++;   \\n            }\\n        }\\n        vector<int> fre(32,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<32;j++)\\n                fre[j]+=help[i][j];\\n        }\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            long long int freq=fre[i];\\n            if(freq%2!=0)\\n                ans+=(pow(2,i));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051646,
                "title": "c-xor-of-all-array-elements",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i : nums)\\n            ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i : nums)\\n            ans ^= i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049301,
                "title": "find-xor-beauty-of-array-logical-approach",
                "content": "\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        # if(len(nums)==1):\\n        #     return nums[0]\\n        # if(total==0):\\n        #     return 0\\n        # WITH THOSE COMMENTED LINE IT WILL ALSO WORK...NO EDGE CASES\\uD83D\\uDE01\\n        res=0\\n        for i in nums:\\n            res^=i\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        # if(len(nums)==1):\\n        #     return nums[0]\\n        # if(total==0):\\n        #     return 0\\n        # WITH THOSE COMMENTED LINE IT WILL ALSO WORK...NO EDGE CASES\\uD83D\\uDE01\\n        res=0\\n        for i in nums:\\n            res^=i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049015,
                "title": "easy-intuitive-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0]\\n        total_count = (n ** 3) - n\\n\\n        iteration = (total_count // n) % 2\\n        \\n        if total_count == 0:\\n            return 0\\n        xor = 0\\n        for i in nums:\\n            xor = xor ^ i\\n        return xor\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0]\\n        total_count = (n ** 3) - n\\n\\n        iteration = (total_count // n) % 2\\n        \\n        if total_count == 0:\\n            return 0\\n        xor = 0\\n        for i in nums:\\n            xor = xor ^ i\\n        return xor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048980,
                "title": "actual-logical-solution-how-to-get-to-the-most-optimised-solution-observation",
                "content": "# Prerequisite\\n  Permutation & Combinations \\n\\n# Code\\n```\\nclass Solution:\\n        \\n    \\'\\'\\'\\n    READ THIS ONCE YOU UNDERSTAND THE BELOW SHOWN PROCESS - \\n\\n                Now why XORing all the elements work ?\\n                PROOF - \\n\\n                combos % 2 \\n                = (ones*ones + 2*ones*zeros) % 2\\n                = (ones*ones) % 2\\n                = so totally depends on number of ones :) \\n\\n                Now If you still wondering why XORing works then would \\n                recommend you to go through Bit Basics\\n    \\'\\'\\'\\n    def xorBeauty(self, a):\\n        n = len(a)\\n        ans = 0\\n        for i in range(30, -1, -1):\\n            ones = 0\\n            for x in a:\\n                ones += (x >> i) & 1\\n            if ones == 0:\\n                continue\\n            zeros = n - ones\\n            combos = ((ones + zeros) * (ones + zeros) - (zeros * zeros)) * ones\\n            ans += (1 << i) * (combos % 2)\\n        return ans\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n        \\n    \\'\\'\\'\\n    READ THIS ONCE YOU UNDERSTAND THE BELOW SHOWN PROCESS - \\n\\n                Now why XORing all the elements work ?\\n                PROOF - \\n\\n                combos % 2 \\n                = (ones*ones + 2*ones*zeros) % 2\\n                = (ones*ones) % 2\\n                = so totally depends on number of ones :) \\n\\n                Now If you still wondering why XORing works then would \\n                recommend you to go through Bit Basics\\n    \\'\\'\\'\\n    def xorBeauty(self, a):\\n        n = len(a)\\n        ans = 0\\n        for i in range(30, -1, -1):\\n            ones = 0\\n            for x in a:\\n                ones += (x >> i) & 1\\n            if ones == 0:\\n                continue\\n            zeros = n - ones\\n            combos = ((ones + zeros) * (ones + zeros) - (zeros * zeros)) * ones\\n            ans += (1 << i) * (combos % 2)\\n        return ans\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046716,
                "title": "c-solution-with-detail-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWhy just xor of all the element in the array works? \\n\\n\\nIf we think about the triplet in the array at index i, j and k where i <= j <= k, there can be set of triplet.\\n(a, a, a)\\n(a, a, b)\\n(b, a, a)\\n(a, b, a)\\n(a, b, c)\\n\\nIf we pick triplet form the last (a, b, c) this can be cancel by the triplet (b, a, c) int the overall result because ((a | b) & c) = ((b | a) & c) and xor or 2 equal value will be 0.\\nIn the same way \\n(a | a) & b = (b | b) & a.\\n(b | a) & a = (a | b) & a.\\n\\nwe just have to consider the first case in the result which is the ((a | a) & a) = a.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046338,
                "title": "c-easy-solution-beats-98-bit-manipulation",
                "content": "\\n# Approach\\nXor of same number even times are canceled;\\n\\n    1 ^ 4 ^ 4 ^ 4 ^ 4 ^ 5 ^ 5 = 1\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        // For fast input output\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        for(int i=1;i<nums.size();++i){\\n            nums[0]=nums[0]^nums[i];\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        // For fast input output\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        for(int i=1;i<nums.size();++i){\\n            nums[0]=nums[0]^nums[i];\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3046116,
                "title": "find-xor-beauty-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    bitwise xor operation\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {   \\n      int ans=0;\\n      for(auto x:nums){\\n              ans^=x;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {   \\n      int ans=0;\\n      for(auto x:nums){\\n              ans^=x;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043091,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        beauty = 0\\n\\n        for x in nums:\\n            beauty ^= x\\n        \\n        return beauty\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        beauty = 0\\n\\n        for x in nums:\\n            beauty ^= x\\n        \\n        return beauty\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042245,
                "title": "java-beats-100-0-ms-59-1-mb",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nXOR each value with an initial value of 0.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int result = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int result = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041973,
                "title": "3-lines-code-simple-observation-problem-easy-solution-c-accepted",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = nums[0];\\n        for(int i = 1; i<nums.size(); i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = nums[0];\\n        for(int i = 1; i<nums.size(); i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040958,
                "title": "java-obvious",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int xorBeauty(int[] nums) {\\n    int ans = 0;\\n    for(int n : nums) ans ^= n;\\n    return ans;      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int xorBeauty(int[] nums) {\\n    int ans = 0;\\n    for(int n : nums) ans ^= n;\\n    return ans;      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036186,
                "title": "easy-xor-all-num",
                "content": "```\\nclass Solution {\\n    public int xorBeauty(int[] a) {\\n        int xor=0;\\n        for(int i=0;i<a.length;i++)xor^=a[i];\\n        return xor;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] a) {\\n        int xor=0;\\n        for(int i=0;i<a.length;i++)xor^=a[i];\\n        return xor;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3035351,
                "title": "math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ret = 0;\\n        for (auto n : nums) {\\n            ret ^= n;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ret = 0;\\n        for (auto n : nums) {\\n            ret ^= n;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034287,
                "title": "xor-beauty-of-array-solution-easy-4-lines-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int ans=0;\\n        for(int i:nums)\\n        ans=ans^i;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int ans=0;\\n        for(int i:nums)\\n        ans=ans^i;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029081,
                "title": "very-easy-c-code",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n         for(int i=0;i<nums.size();i++){\\n             ans^=nums[i];\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n         for(int i=0;i<nums.size();i++){\\n             ans^=nums[i];\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026970,
                "title": "o-n-c-one-liner",
                "content": "# Intuition\\nSince `x | y == y | x` all `nums[i] | nums[j]` for `i != j` will produce paris that cancel each other out, e.g. `(nums[i] | nums[j]) ^ (nums[j] | nums[i]) == 0` and each such pair will be tied to ` & nums[k]`, they will also cancel each other out. So the only ones that are going to be preserved are those that have `i == j`. So, in the end, we just need to xor all `nums`.\\n\\n# Approach\\nReduce all `nums` using binary xor.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(const vector<int>& nums) {\\n        return reduce(begin(nums), end(nums), 0, bit_xor<int>{});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(const vector<int>& nums) {\\n        return reduce(begin(nums), end(nums), 0, bit_xor<int>{});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025545,
                "title": "beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        ans = 0\\n        for v in nums: ans ^= v\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        ans = 0\\n        for v in nums: ans ^= v\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024813,
                "title": "xor-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\neasy xor technique\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind all xor of all elements in a list return it and chill!!!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\nMD ARHAM KALAM ANSARI \\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int r=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            r^=nums[i];\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int r=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            r^=nums[i];\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024587,
                "title": "golang-50-ms-10-4-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nfunc xorBeauty(nums []int) int {\\n\\tvar result int\\n\\tfor _, num := range nums {\\n\\t\\tresult ^= num\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc xorBeauty(nums []int) int {\\n\\tvar result int\\n\\tfor _, num := range nums {\\n\\t\\tresult ^= num\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024189,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn xor_beauty(nums: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        for i in 0..32 {\\n            let mut cnt = 0;\\n            for &num in &nums {\\n                if num & (1 << i) != 0 {\\n                    cnt += 1;\\n                }\\n            }\\n            ans |= (cnt % 2) << i;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn xor_beauty(nums: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        for i in 0..32 {\\n            let mut cnt = 0;\\n            for &num in &nums {\\n                if num & (1 << i) != 0 {\\n                    cnt += 1;\\n                }\\n            }\\n            ans |= (cnt % 2) << i;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024020,
                "title": "c-easy-solution-o-n-time-complexity",
                "content": "# Intuition\\nIf you generate all possibilities you will see that most of case will come in triplets and so a pair will just disapear we can just xor all element of the given array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++)\\n            res = res ^ nums[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++)\\n            res = res ^ nums[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022660,
                "title": "maths-explained-fastest-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthink about the mathematics behind the question. \\ntry to see the relation and one important thing to remember is that ever bit is a individual entity. try to think like this in most of the bit manipulation question it will become easy for you to solve them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nyou can find the realtion that each bit is their for x^3+2x^2 time using this the bit will be set only if it is odd no of times there so if x is odd then only it will exist which lead us to the normal bitwise xor of the entire array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int result=0;\\n        for(int i=0;i<nums.size();i++){\\n            result^=nums[i];\\n        }\\n    return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int result=0;\\n        for(int i=0;i<nums.size();i++){\\n            result^=nums[i];\\n        }\\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022506,
                "title": "java-simplest-question-i-ever-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nno need to think to much \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply apply XOR \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n):where n =number of elements in the array \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int v=0;\\n        for(int i:nums)v^=i;\\n        return v;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int xorBeauty(int[] nums) {\\n        int v=0;\\n        for(int i:nums)v^=i;\\n        return v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022267,
                "title": "python3-o-n-linear-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any triplets that not i == j == k, ((nums[i] & nums[j]) | nums[k]) ^ ((nums[j] & nums[i]) | nums[k]) = 0. All we need to consider is when i == j == k, (nums[i] & nums[j]) | nums[k] = nums[i].\\n\\n# Code\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        ans = 0\\n        for v in nums: ans ^= v\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n        ans = 0\\n        for v in nums: ans ^= v\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021486,
                "title": "o-32n-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        vector<int> count(32, 0);\\n        for(int ele: nums) {\\n            for(int i=0;i<32;i++) {\\n                if((ele & (1<<i))!=0) {\\n                    count[i]++;\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        int n = nums.size();\\n        vector<long long> tmp(32, 0);\\n        for(int ele: nums) {\\n            for(int i=0;i<32;i++) {\\n                if((ele&(1<<i))!=0) {\\n                    tmp[i] += (long long)2*count[i]*n - (long long)count[i] * count[i];\\n                }\\n            }\\n        }\\n        // for(int i=0;i<tmp.size();i++) {\\n        //     cout << tmp[i] <<\" \";\\n        // }\\n        for(int i=0;i<32;i++) {\\n            if(tmp[i]%2==1) {\\n                res |= (1<<i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        vector<int> count(32, 0);\\n        for(int ele: nums) {\\n            for(int i=0;i<32;i++) {\\n                if((ele & (1<<i))!=0) {\\n                    count[i]++;\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        int n = nums.size();\\n        vector<long long> tmp(32, 0);\\n        for(int ele: nums) {\\n            for(int i=0;i<32;i++) {\\n                if((ele&(1<<i))!=0) {\\n                    tmp[i] += (long long)2*count[i]*n - (long long)count[i] * count[i];\\n                }\\n            }\\n        }\\n        // for(int i=0;i<tmp.size();i++) {\\n        //     cout << tmp[i] <<\" \";\\n        // }\\n        for(int i=0;i<32;i++) {\\n            if(tmp[i]%2==1) {\\n                res |= (1<<i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3020976,
                "title": "c-easiest-approach-easy-question-explained",
                "content": "# Approach\\n- Just Xoring All The Elements Of Vector And Returning It \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int a = 0;\\n        for(auto i : nums)\\n        {\\n            a = a ^ i;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int a = 0;\\n        for(auto i : nums)\\n        {\\n            a = a ^ i;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020873,
                "title": "easiest-solution-c-easy-to-understand-just-3-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans =0;\\n        for(auto i:nums) ans^=i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans =0;\\n        for(auto i:nums) ans^=i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020621,
                "title": "c-simple-one-liner-concept",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n            res^=nums[i];\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n            res^=nums[i];\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3019930,
                "title": "rusty-solution-with-parallel-prefix",
                "content": "# This is approaching some beauty...\\nBut it has nothing to do with the problem at hand, it\\'s just an optimization using a parallel prefix algorithm, and using 2 threads to split up the work, due to not being able to access the environment to check amount of available threads.\\n\\nThe time used will drop with larger arrays. In this case, my submission ran at 0ms, while the general solution was about 3ms for the wastest and around 4ms on average.\\n\\nThe time complexity theoretically stays the same, but the work is split up, lowering the compute time.\\n\\nIf you want to try it out, the whole point here is to play with the amount of threads. Given we don\\'t have enough information, it\\'s guesswork. But e.g. 16 threads also seems to lower the time spent.\\n\\n\\n# Code\\n```\\nuse std::sync::{Arc, Mutex};\\nuse std::thread;\\nuse std::boxed::Box;\\n\\nimpl Solution {\\n    fn xor_beauty(a: Vec<i32>) -> i32 {\\n        let a = Box::new(a);\\n        let a_ptr = Box::into_raw(a);\\n        let res = xor(unsafe { &*a_ptr });\\n        unsafe {\\n            drop(Box::from_raw(a_ptr));\\n        }\\n        res\\n    }\\n}\\n\\nfn xor(arr: &\\'static Vec<i32>) -> i32 {\\n    let n = arr.len();\\n    let mut result = 0;\\n    if n == 0 {\\n        return result;\\n    }\\n\\n    let mut num_threads = 2;\\n    if num_threads > n {\\n        num_threads = n;\\n    }\\n    let chunk_size = (n + num_threads - 1) / num_threads;\\n    let arr = Arc::new(arr);\\n\\n    let mut handles = Vec::new();\\n    for i in 0..num_threads {\\n        let arr = arr.clone();\\n        let start = i * chunk_size;\\n        let end = std::cmp::min((i + 1) * chunk_size, n);\\n        handles.push(thread::spawn(move || {\\n            let mut xor = 0;\\n            for i in start..end {\\n                xor ^= arr[i];\\n            }\\n            xor\\n        }));\\n    }\\n\\n    for handle in handles {\\n        result ^= handle.join().unwrap();\\n    }\\n\\n    result\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::sync::{Arc, Mutex};\\nuse std::thread;\\nuse std::boxed::Box;\\n\\nimpl Solution {\\n    fn xor_beauty(a: Vec<i32>) -> i32 {\\n        let a = Box::new(a);\\n        let a_ptr = Box::into_raw(a);\\n        let res = xor(unsafe { &*a_ptr });\\n        unsafe {\\n            drop(Box::from_raw(a_ptr));\\n        }\\n        res\\n    }\\n}\\n\\nfn xor(arr: &\\'static Vec<i32>) -> i32 {\\n    let n = arr.len();\\n    let mut result = 0;\\n    if n == 0 {\\n        return result;\\n    }\\n\\n    let mut num_threads = 2;\\n    if num_threads > n {\\n        num_threads = n;\\n    }\\n    let chunk_size = (n + num_threads - 1) / num_threads;\\n    let arr = Arc::new(arr);\\n\\n    let mut handles = Vec::new();\\n    for i in 0..num_threads {\\n        let arr = arr.clone();\\n        let start = i * chunk_size;\\n        let end = std::cmp::min((i + 1) * chunk_size, n);\\n        handles.push(thread::spawn(move || {\\n            let mut xor = 0;\\n            for i in start..end {\\n                xor ^= arr[i];\\n            }\\n            xor\\n        }));\\n    }\\n\\n    for handle in handles {\\n        result ^= handle.join().unwrap();\\n    }\\n\\n    result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019639,
                "title": "c-clean-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n      int bea = nums[0];\\n  for (int i = 1; i < nums.size(); i++) {\\n      bea^=nums[i];\\n  }\\n  return bea;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n      int bea = nums[0];\\n  for (int i = 1; i < nums.size(); i++) {\\n      bea^=nums[i];\\n  }\\n  return bea;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019549,
                "title": "java-1-line",
                "content": "public int xorBeauty(int[] nums) {\\n        return Arrays.stream(nums).reduce((a,b) -> a^b).getAsInt();\\n    }",
                "solutionTags": [],
                "code": "public int xorBeauty(int[] nums) {\\n        return Arrays.stream(nums).reduce((a,b) -> a^b).getAsInt();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3019469,
                "title": "c-o-n-just-xor-all-the-numbers",
                "content": "# Intuition\\nJust XOR all the numbers to get your final answer. To understand the approach read below.\\n\\n# Approach\\nThere are three cases in this ques -\\n**1.** All the three numbers are same - \\n\\nin this case- (a|a)&a = a\\n\\n**2.** Two of the numbers are same-\\n\\n(a|b) & a = a , (a|b)&b = b , (a|a)&b= a&b, (b|b)&a = a&b, (b|a)&a = a, (b|a)&b = b\\n\\nIf you xor all the numbers above you will get-\\n(a^a) ^ (b^b) ^ (a&b ^ a&b) = 0\\n\\n**3.** Similarly if all the three numbers are different then-\\n((a|b)&c) ^ ((b|a)&c) ^ ((a|c)&b) ^ ((c|a)&b) ^ ((b|c)&a) ^ ((c|b)&a) = 0\\n\\n*So the final answer will be the xor of all the numbers present in the array.*\\n    \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            ans^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            ans^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019299,
                "title": "easy-c-3-lines-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans= 0;\\n        for(auto it:nums) ans^=it;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans= 0;\\n        for(auto it:nums) ans^=it;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1835771,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            },
            {
                "id": 2015174,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            },
            {
                "id": 1746698,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            },
            {
                "id": 1750860,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            },
            {
                "id": 1804904,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            },
            {
                "id": 1770846,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            },
            {
                "id": 1752837,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            },
            {
                "id": 1746772,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            },
            {
                "id": 1746594,
                "content": [
                    {
                        "username": "charonme",
                        "content": "For every effective value efv(i,j,k) there is another equal efv(j,i,k) which gives efv(i,j,k) ^ efv(j,i,k) = 0 except when i=j, so if i!=j the efv doesn\\'t contribute to the result, so we don\\'t need to xor all triplets, we can just xor all the pairs. Furthermore for every pair efv(a,b) = (a|a)&b = a&b there is another equal efv(b,a) which again doesn\\'t contribute to the xor because efv(a,b)^efv(b,a)=0, except when a=b, so we only need to xor all the efv(x,x,x) = (x|x)&x = x values"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Don\\'t just XOR entire array and return. Try to think why that is the answer.  "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Pretentious description.\\n\\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table"
                    },
                    {
                        "username": "ayush2420",
                        "content": "Hint- Just take the xor of whole array  😅"
                    },
                    {
                        "username": "zhhackk",
                        "content": "[@Ayush Kumar Jha](/ayush2420) Discussion Rules\n\n1. Please don't post **any solutions** in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "captain_code12",
                        "content": "can you please explain this logic"
                    },
                    {
                        "username": "motidivya",
                        "content": "Guys, can anyone please explain what the question meant? How are you guys forming pairs? How are you guys representing number above 7 with just 3 bits?\\n"
                    },
                    {
                        "username": "obattalov",
                        "content": "The same decisions beat as 95% so 5% as in Runtime so in Memory"
                    },
                    {
                        "username": "alexhutcheson",
                        "content": "Question should clarify that i, j, and k do not have to be distinct."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "class Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                for(int k=0;k<nums.size();k++){\\n                    ans^=(nums[i]|nums[j])&nums[k];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nI got TLE .Someone plz help it."
                    },
                    {
                        "username": "_uzaifgaur",
                        "content": "Your solution is of O(N^3), which is not accept due the length of array is 10^5"
                    },
                    {
                        "username": "sk0884518",
                        "content": "TLE ho jyega go to more optimize solution\\n"
                    },
                    {
                        "username": "IRFANSARI",
                        "content": "u want full explanation?  u can search on yt\\n\\n\\nmy code:\\nclass Solution {\\npublic:\\n    int xorBeauty(vector<int>& nums) {\\n        \\n        \\n        int ans = 0;\\n        for(int i : nums) {\\n            ans = ans ^ i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Brute force doesn\\'t work, simplify the boolean expression itself. For example, this rule is a part of the simplification process: `(a&c)^(b&c) = (a^b)&c`."
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged under \\'easy\\' category. "
                    },
                    {
                        "username": "Finesse",
                        "content": "A good Boolean algebra knowledge is required to make something better than brute-force"
                    }
                ]
            }
        ]
    }
]