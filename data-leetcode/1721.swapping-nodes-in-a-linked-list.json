[
    {
        "title": "Valid Permutations for DI Sequence",
        "question_content": "You are given a string s of length n where s[i] is either:\n\n\t'D' means decreasing, or\n\t'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\n\tIf s[i] == 'D', then perm[i] > perm[i + 1], and\n\tIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n\nExample 2:\n\nInput: s = \"D\"\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tn == s.length\n\t1 <= n <= 200\n\ts[i] is either 'I' or 'D'.",
        "solutions": [
            {
                "id": 168278,
                "title": "c-java-python-dp-solution-o-n-2",
                "content": "# Intuition\\n`dp[i][j]` means the number of possible permutations of first `i + 1` digits,\\nwhere the `i + 1`th digit is `j + 1`th smallest in the rest of unused digits.\\n\\n\\nOk, may not make sense ... Let\\'s see the following diagram.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lee215/image_1536486527.png)\\n\\nI take the example of `S = \"DID\"`.\\nIn the parenthesis, I list all possible permutations.\\n\\nThe permutation can start from `1, 2, 3, 4`.\\nSo `dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = 1`.\\n\\nWe decrese from the first digit to the second,\\nthe down arrow show the all possibile decresing pathes.\\n\\nThe same, because we increase from the second digit to the third,\\nthe up arrow show the all possibile increasing pathes.\\n\\n`dp[2][1] = 5`, mean the number of permutations\\nwhere the third digitis the second smallest of the rest.\\nWe have 413,314,214,423,324.\\nFow example 413, where 2,3 are left and 3 the second smallest of them.\\n<br>\\n\\n# Explanation\\nAs shown in the diagram,\\nfor \"I\", we calculate prefix sum of the array,\\nfor \"D\", we calculate sufixsum of the array.\\n<br>\\n\\n# Complexity\\nTime `O(N^2)`\\nSpace `O(N^2)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\\n\\n# Solution 2:\\nNow as we did for every DP, make it 1D dp.\\nTime `O(N^2)`\\nSpace `O(N)`\\n\\n**C++:**\\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<int> dp(n + 1, 1), dp2(n);\\n        for (int i = 0; i < n; dp = dp2, i++) {\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[] dp = new int[n + 1], dp2 = new int[n];;\\n        for (int j = 0; j <= n; j++) dp[j] = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n            dp = Arrays.copyOf(dp2, n);\\n        }\\n        return dp[0];\\n    }\\n```\\n\\n**Python2**\\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for c in S:\\n            if c == \"I\":\\n                dp = dp[:-1]\\n                for i in range(1, len(dp)):\\n                    dp[i] += dp[i - 1]\\n            else:\\n                dp = dp[1:]\\n                for i in range(len(dp) - 1)[::-1]:\\n                    dp[i] += dp[i + 1]\\n        return dp[0] % (10**9 + 7)\\n```\\n**Python3**\\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```\n```cpp\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<int> dp(n + 1, 1), dp2(n);\\n        for (int i = 0; i < n; dp = dp2, i++) {\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n        }\\n        return dp[0];\\n    }\\n```\n```java\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[] dp = new int[n + 1], dp2 = new int[n];;\\n        for (int j = 0; j <= n; j++) dp[j] = 1;\\n        for (int i = 0; i < n; i++) {\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp2[j] = cur = (cur + dp[j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp2[j] = cur = (cur + dp[j + 1]) % mod;\\n            dp = Arrays.copyOf(dp2, n);\\n        }\\n        return dp[0];\\n    }\\n```\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for c in S:\\n            if c == \"I\":\\n                dp = dp[:-1]\\n                for i in range(1, len(dp)):\\n                    dp[i] += dp[i - 1]\\n            else:\\n                dp = dp[1:]\\n                for i in range(len(dp) - 1)[::-1]:\\n                    dp[i] += dp[i + 1]\\n        return dp[0] % (10**9 + 7)\\n```\n```py\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 196939,
                "title": "easy-to-understand-solution-with-detailed-explanation",
                "content": "\\nBefore diving into the state transition function, let us first start with a simple example.\\n\\n### 1. a simple example\\n\\nIn the following discussion, for simplification, I will use both notation DI-seq and DI-rule instead of DI sequence.\\n\\nConsider a permutation 1032, which is based on a DI-seq \"DID\", how to use it to construct a new instance ending at **2** and based on DI-seq \"DID**D**\"?\\n\\n**Method**:\\nstep 1.\\nfor the original permutation `1032`, we add 1 to the digits *that are larger than or equal to* **2**.\\n```C++\\n1032->1043\\n  ^^\\n```\\n\\nstep 2.\\nthen directly append **2**  to `1043`,  i.e., 1043 -> 1043**2**\\n\\n**Remark on step 1**:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival **2**.\\n(2) More importantly, such operation on the digits **will not break the original DI-rule**. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward,  you can validate yourself.\\n\\nNow a new permutation with DI-rule \"DID**D**\" and ending at **2** has been constructed from 1032, namely 1043**2**.\\n\\n\\nWith the same spirit, using 1032(\"DID\"), we can construct instances with DI-rule \"DID**D**\": 2043**1**(ending with **1**), 2143**0**(ending with **0**).\\n(Note that the instance(based on \"DID**D**\") which ends with 3 can not be constructed.)\\n\\n\\n\\nSimilarly, from 1032(\"DID\"), we can construct instances with DI-rule \"DID**I**\": 10423(ending with **3**), 10324(ending with **4**).\\n(Note that the instance(based on \"DID**I**\") which ends with 1 or 2 can not be constructed.)\\n\\n\\n\\n### 2. state transition function\\n\\nWith the example above in mind, the transition function seems to be clear.\\n\\nGiven a string DI-seq S, let `dp[i][j]` represents the number of permutation of number `0, 1, ... , i`, satisfying DI-rule S.substr(0, i), and ending with digit `j`.\\n\\n\\n```C++\\nif(S[i-1] == \\'D\\')\\n   dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + ... + dp[i-1][i-1]\\n\\nif(S[i-1] == \\'I\\') \\n   dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1]\\n```\\n\\n\\n\\n\\n### 3.  Solution\\n\\n```C++\\nlass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.size(), m = 1e9 + 7;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 0; j <= i; j++)\\n                if(S[i-1] == \\'D\\')\\n                    for(int k = j; k <= i-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n                else\\n                    for(int k = 0; k <= j-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n        int res = 0;\\n        for(int i = 0; i <= n; i++)\\n            res = res%m + dp[n][i]%m;\\n        return res%m;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```C++\\n1032->1043\\n  ^^\\n```\n```C++\\nif(S[i-1] == \\'D\\')\\n   dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + ... + dp[i-1][i-1]\\n\\nif(S[i-1] == \\'I\\') \\n   dp[i][j] = dp[i-1][0] + dp[i-1][1] + ... + dp[i-1][j-1]\\n```\n```C++\\nlass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.size(), m = 1e9 + 7;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        dp[0][0] = 1;\\n        for(int i = 1; i <= n; i++)\\n            for(int j = 0; j <= i; j++)\\n                if(S[i-1] == \\'D\\')\\n                    for(int k = j; k <= i-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n                else\\n                    for(int k = 0; k <= j-1; k++)\\n                        dp[i][j] = dp[i][j]%m + dp[i-1][k]%m;\\n        int res = 0;\\n        for(int i = 0; i <= n; i++)\\n            res = res%m + dp[n][i]%m;\\n        return res%m;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168612,
                "title": "top-down-with-memo-bottom-up-dp-n-3-dp-n-2-dp-o-n-space",
                "content": "**Top-down with Memo:**\\n\\nDefinition: `helper(String s, Map<String, Long> map)`: Answer to `s`.\\n\\nIntuition: Insert the largest number into appropriate postion.\\n\\neg. `s=\\'IIDD\\'`, we can only insert `4` between `I` and `D`. We break the remained numbers `0, 1, 2, 3` into two groups both with the size of 2. We have `C(4, 2)` possible combinations. Then `helper(\"IIDD\") = helper(\"I\") * helper(\"D\") * C(4, 2)`.\\n\\nTricky: How to calculate `C(n, k) % M`? I referred a method using *Pascal Triangle* from [here](https://www.geeksforgeeks.org/compute-ncr-p-set-1-introduction-and-dynamic-programming-solution/). (This part makes this method ugly and lengthy, anybody has better approaches?)\\n\\nTime complexity: `O(n^4)` in my implementation, however could improve to `O(n^3)`.\\n\\nCode:\\n\\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    private int[][] nCkMemo;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        nCkMemo = new int[n + 1][n + 1];\\n        return (int)helper(S, new HashMap<>());\\n    }\\n    private long helper(String s, Map<String, Long> map) {\\n        if (s.equals(\"\")) {\\n            return 1;\\n        }\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        long result = 0;\\n        int n = s.length();\\n        if (s.charAt(0) == \\'D\\') {\\n            result += helper(s.substring(1), map);\\n            result %= M;\\n        }\\n        if (s.charAt(n - 1) == \\'I\\') {\\n            result += helper(s.substring(0, n - 1), map);\\n            result %= M;\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i - 1) == \\'I\\' && s.charAt(i) == \\'D\\') {\\n                long left = helper(s.substring(0, i - 1), map);\\n                long right = helper(s.substring(i + 1), map);\\n                result += (((left * right) % M) * nCk(n, i)) % M;\\n                result %= M;\\n            }\\n        }\\n        map.put(s, result);\\n        return result;\\n    }\\n    private int nCk(int n, int k) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k) + nCk(n - 1, k - 1)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\\n\\n**Bottom-up DP:**\\n\\nSame idea with the Top-down. `dp[i][j]` represent the answer of `s.substring(i, j)`. Just a Bottom-up implementation:\\n\\nTime complexity: `O(n^3)`\\n\\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        int[][] nCkMemo = new int[n + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][i] = 1;\\n        }\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len;\\n                if (S.charAt(i) == \\'D\\') {\\n                    dp[i][j] += dp[i + 1][j];\\n                    dp[i][j] %= M;\\n                }\\n                for (int k = i + 1; k < j; k++) {\\n                    if (S.charAt(k - 1) == \\'I\\' && S.charAt(k) == \\'D\\') {\\n                        dp[i][j] += (((dp[i][k - 1] * dp[k + 1][j]) % M) * nCk(len, k - i, nCkMemo)) % M;\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n                if (S.charAt(j - 1) == \\'I\\') {\\n                    dp[i][j] += dp[i][j - 1];\\n                    dp[i][j] %= M;\\n                }\\n            }\\n        }\\n        return (int)dp[0][n];\\n    }\\n    private int nCk(int n, int k, int[][] nCkMemo) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k, nCkMemo) + nCk(n - 1, k - 1, nCkMemo)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\\n\\n**N^3 DP:**\\n\\nLet\\'s change the definition of `dp` matrix to make the calculation simple: let\\'s say `dp[i][j]` represents the number of permutation of number `0, 1, ... , i` which ends with `j`. Also, it represents the answer of  `s.substring(0, i)` which ends with `j`.\\nWe will have two conditions: \\n\\n1. `s.charAt(i - 1) == \\'I\\'`: In this case, `dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1])`.\\n2. `s.charAt(i - 1) == \\'D\\'`: In this case, `dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1])`.\\n\\nImagine each time when appending the `j` to the previous permutations, you have to **add 1 to each number in the previous permutation which is greater than or equals to `j`**. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation `(1, 0, 3, 2)`. We are trying to append `2`. Now the `(1, 0, 3, 2)` changes to `(1, 0, 4, 3)` then appended with a `2`. We have `(1, 0, 4, 3, 2)`. Although the values change but the order and count don\\'t change.\\n\\nTime complexity: `O(n^3)`\\n\\nCode:\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    for (int k = j; k < i; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                } else {\\n                    for (int k = 0; k < j; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 0; j <= n; j++) {\\n            result += dp[n][j];\\n            result %= M;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n **N^2 DP:**\\n \\n Notice that in the previous method, we are actually calculate the **prefix sum** and **suffix sum**  in the two conditions:\\n \\n1. `s.charAt(i - 1) == \\'I\\'`: In this case, `dp[i][j] = sum[i - 1][j - 1]`.\\n2. `s.charAt(i - 1) == \\'D\\'`: In this case, `dp[i][j] = sum[i - 1][i - 1] - sum[i - 1][j - 1]`.\\n\\nWe can define `dp[i][j]` as `sum(dp[i][0], dp[i][1], ... dp[i][j])` which is `sum[i][j]`.\\n\\nTime complexity: `O(n^2)`\\n\\nCode:\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        Arrays.fill(dp[0], 1);\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                dp[i][j] = j == 0 ? 0 : dp[i][j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    dp[i][j] += (dp[i - 1][i - 1] - (j == 0 ? 0 : dp[i - 1][j - 1])) % M;\\n                    if (dp[i][j] < 0) {\\n                        dp[i][j] += M;\\n                    }\\n                } else {\\n                    dp[i][j] += j == 0 ? 0 : dp[i - 1][j - 1];\\n                }\\n                dp[i][j] %= M;\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n```\\n\\n**O(N) space:**\\n\\nPrevious solution could be optimized to `O(n)` space.\\n\\nTime complexity: `O(n^2)`. Space complexity: `O(n)`.\\n\\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i <= n; i++) {\\n            int[] temp = new int[n + 1];\\n            for (int j = 0; j <= i; j++) {\\n                temp[j] = j == 0 ? 0 : temp[j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    temp[j] += (dp[i - 1] - (j == 0 ? 0 : dp[j - 1])) % M;\\n                    if (temp[j] < 0) {\\n                        temp[j] += M;\\n                    }\\n                } else {\\n                    temp[j] += j == 0 ? 0 : dp[j - 1];\\n                }\\n                temp[j] %= M;\\n            }\\n            dp = temp;\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    private int[][] nCkMemo;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        nCkMemo = new int[n + 1][n + 1];\\n        return (int)helper(S, new HashMap<>());\\n    }\\n    private long helper(String s, Map<String, Long> map) {\\n        if (s.equals(\"\")) {\\n            return 1;\\n        }\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        long result = 0;\\n        int n = s.length();\\n        if (s.charAt(0) == \\'D\\') {\\n            result += helper(s.substring(1), map);\\n            result %= M;\\n        }\\n        if (s.charAt(n - 1) == \\'I\\') {\\n            result += helper(s.substring(0, n - 1), map);\\n            result %= M;\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i - 1) == \\'I\\' && s.charAt(i) == \\'D\\') {\\n                long left = helper(s.substring(0, i - 1), map);\\n                long right = helper(s.substring(i + 1), map);\\n                result += (((left * right) % M) * nCk(n, i)) % M;\\n                result %= M;\\n            }\\n        }\\n        map.put(s, result);\\n        return result;\\n    }\\n    private int nCk(int n, int k) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k) + nCk(n - 1, k - 1)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int M = (int)1e9 + 7;\\n    public int numPermsDISequence(String S) {\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        int[][] nCkMemo = new int[n + 1][n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][i] = 1;\\n        }\\n        for (int len = 1; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len;\\n                if (S.charAt(i) == \\'D\\') {\\n                    dp[i][j] += dp[i + 1][j];\\n                    dp[i][j] %= M;\\n                }\\n                for (int k = i + 1; k < j; k++) {\\n                    if (S.charAt(k - 1) == \\'I\\' && S.charAt(k) == \\'D\\') {\\n                        dp[i][j] += (((dp[i][k - 1] * dp[k + 1][j]) % M) * nCk(len, k - i, nCkMemo)) % M;\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n                if (S.charAt(j - 1) == \\'I\\') {\\n                    dp[i][j] += dp[i][j - 1];\\n                    dp[i][j] %= M;\\n                }\\n            }\\n        }\\n        return (int)dp[0][n];\\n    }\\n    private int nCk(int n, int k, int[][] nCkMemo) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        if (nCkMemo[n][k] == 0) {\\n            nCkMemo[n][k] = (nCk(n - 1, k, nCkMemo) + nCk(n - 1, k - 1, nCkMemo)) % M;\\n        }\\n        return nCkMemo[n][k];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    for (int k = j; k < i; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                } else {\\n                    for (int k = 0; k < j; k++) {\\n                        dp[i][j] += dp[i - 1][k];\\n                        dp[i][j] %= M;\\n                    }\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (int j = 0; j <= n; j++) {\\n            result += dp[n][j];\\n            result %= M;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        Arrays.fill(dp[0], 1);\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                dp[i][j] = j == 0 ? 0 : dp[i][j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    dp[i][j] += (dp[i - 1][i - 1] - (j == 0 ? 0 : dp[i - 1][j - 1])) % M;\\n                    if (dp[i][j] < 0) {\\n                        dp[i][j] += M;\\n                    }\\n                } else {\\n                    dp[i][j] += j == 0 ? 0 : dp[i - 1][j - 1];\\n                }\\n                dp[i][j] %= M;\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int n = S.length(), M = (int)1e9 + 7;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i <= n; i++) {\\n            int[] temp = new int[n + 1];\\n            for (int j = 0; j <= i; j++) {\\n                temp[j] = j == 0 ? 0 : temp[j - 1];\\n                if (S.charAt(i - 1) == \\'D\\') {\\n                    temp[j] += (dp[i - 1] - (j == 0 ? 0 : dp[j - 1])) % M;\\n                    if (temp[j] < 0) {\\n                        temp[j] += M;\\n                    }\\n                } else {\\n                    temp[j] += j == 0 ? 0 : dp[j - 1];\\n                }\\n                temp[j] %= M;\\n            }\\n            dp = temp;\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168289,
                "title": "share-my-o-n-3-o-n-2-c-dp-solution-including-the-thoughts-of-improvement",
                "content": "Came up with the original idea during contest, so might not be the best. But it works.\\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] number of permutation whose length is i and end with j\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    // add all string with length i - 1 and last digit is greater than or equal to j\\n                    for (int k = j; k <= i; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                } else {\\n                    // increase to j\\n                    // add all string with length i - 1 and last digit is smaller than j\\n                    for (int k = 1; k < j; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= N; ++i) ans = (ans + dp[N][i]) % MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n**UPDATE 9/9/2018**:\\nThanks to `@chosun1`, I used prefix sum to save the result which reduce the complexity to O(N ^ 2). There is no need to keep a separate 2d array for prefix sum, just change the definition of dp array is fine. Here is the updated code, it is even shorter.\\n\\n`dp[i][j]` means number of permutation whose length is `i` and end with **at most** `j`.\\n\\nLet\\'s say the current position of DI sequence is `\\'D\\'`, \\nSo, `dp[i][j] = dp[i][j-1] + X`, where `X` is number of permutations whose length is `i` and end exactly with `j`. We can calculate it by adding number of permutations whose length is `i-1` and end with `{j, j+1, ..., i-1}`, because they will satisfy the condition of \"decreasing to j\". (*Wait! Wait! Why start with j not j + 1?, see the bolded explaination below.*)\\nAccording to the definition of dp array, we can get `X = dp[i-1][i-1] - dp[i-1][j-1]`.\\n\\nIf the DI sequence is `\\'I\\'`, it\\'s similiar.\\n\\n**So, why start with j, not j + 1, since the sequence is decreasing to j?**\\n`Thought Experiment`: In the sequence with length of `i-1`, the largest number in this sequence should be `i-1`. However, when we are dealing with length `i` and end with `j`, the previous sequence has already another `j` and we should also add `i` to the sequence. What we can do is, **add one to all those numbers greater than or equal to j**. This operation will make the largest number to be `i` without breaking the sequence property, also, it will free the `j` so that we can use it at the end of the sequence. By this thought experiment, we can easily get the result of `X`. For example, if the sequence is `{3,4,1,2,5}` and we want to expand it to be of length 6 and end with 3. We first make it to be `{3->4,4->5,1,2,5->6}`, and then, add 3 to the end of the sequence.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] means number of permutation whose length is i and end with at most j.\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][i-1] - dp[i-1][j-1]) % MOD) % MOD;\\n                } else {\\n                    // increase to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][j-1] - dp[i-1][0]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        return (dp[N][N] + MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] number of permutation whose length is i and end with j\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    // add all string with length i - 1 and last digit is greater than or equal to j\\n                    for (int k = j; k <= i; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                } else {\\n                    // increase to j\\n                    // add all string with length i - 1 and last digit is smaller than j\\n                    for (int k = 1; k < j; ++k) {\\n                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 1; i <= N; ++i) ans = (ans + dp[N][i]) % MOD;\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.length() + 1;\\n        int MOD = 1e9 + 7;\\n        // dp[i][j] means number of permutation whose length is i and end with at most j.\\n        int dp[202][202] = {};\\n        dp[1][1] = 1;\\n        for (int i = 2; i <= N; ++i) {\\n            // length is i\\n            for (int j = 1; j <= i; ++j) {\\n                // end with j\\n                if (S[i - 2] == \\'D\\') {\\n                    // decrease to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][i-1] - dp[i-1][j-1]) % MOD) % MOD;\\n                } else {\\n                    // increase to j\\n                    dp[i][j] = (dp[i][j-1] + (dp[i-1][j-1] - dp[i-1][0]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        return (dp[N][N] + MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715588,
                "title": "how-to-define-the-dp-states-with-clear-picture-explanation",
                "content": "When I tried to understand lee215\\'s [solution](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C++JavaPython-DP-Solution-O(N2)), I got stuck. Then I redescribe this process to better understand the whole process. Credits go to lee215.  \\nThe intuition is: given a string s, results of the number of permutations for the following strings are the same.\\n```\\n0,1,2\\n1,2,3\\n1,2,4\\n```\\n\\nBased on this observation, we can use the index of the sorted unused digits to aggregate the results.\\nI am going to improve the illustration and also state definition.\\nDefine the state of DP[i][j] as:\\n- i is the digit index.\\n- j is the **index** of current digit from sorted(current digit + remaining digits).\\n\\nThe reason we define j in this way is:\\nAll the following will have the same results based on the same string S.\\n```\\n0, 1,2\\n1,2,3\\n1,2,4\\n```\\nWe can use index to have an unified representation.\\n```\\n0, 1, 2   ->   0, 1,  2\\n1, 2, 3   ->   0, 1,  2\\n1, 2, 4   ->   0, 1,  2\\n```\\nAfter figuring out this, the transitions can be shown as below:![image](https://assets.leetcode.com/users/images/d146760c-7121-409f-be5d-a7d406029ae0_1623956092.467306.png)\\n\\n\\nMore detail can be found [Here.](https://medium.com/@jim.morris.shen/hard-dp-77774c6a4695?source=friends_link&sk=d901fef6067a08fdbb184acfdeb8cf5e)\\n\\nAfter figuring out the state transitions, then the code is pretty simple.\\nif \"D\": postfix sum\\nif \\'I\\': prefix sum\\n```\\n/*\\njimmy shen\\nTime complexity: O(n^2)\\nSpace complexity: O(n)\\n*/\\n\\nint MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.size();\\n        vector<int> dp(N+1, 1);\\n        for (int i=1;i<N+1;++i){\\n            int M = (N+1)-i;\\n            vector<int> new_dp(M, 0);\\n            if (S[i-1]==\\'D\\'){\\n                //postfix sum\\n                for (int j=dp.size()-2;j>=0;--j){\\n                    dp[j] += dp[j+1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j+1];\\n                }\\n            }\\n            else{\\n                //prefix sum\\n                for (int j=1;j<dp.size();++j){\\n                    dp[j] += dp[j-1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j];\\n                }\\n            }\\n            dp = new_dp;\\n        }\\n        int ret = 0;\\n        for (int i=0;i<dp.size();++i){\\n            ret+=dp[i];\\n            if (ret>=MOD)ret %= MOD;}\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0,1,2\\n1,2,3\\n1,2,4\\n```\n```\\n0, 1,2\\n1,2,3\\n1,2,4\\n```\n```\\n0, 1, 2   ->   0, 1,  2\\n1, 2, 3   ->   0, 1,  2\\n1, 2, 4   ->   0, 1,  2\\n```\n```\\n/*\\njimmy shen\\nTime complexity: O(n^2)\\nSpace complexity: O(n)\\n*/\\n\\nint MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int N = S.size();\\n        vector<int> dp(N+1, 1);\\n        for (int i=1;i<N+1;++i){\\n            int M = (N+1)-i;\\n            vector<int> new_dp(M, 0);\\n            if (S[i-1]==\\'D\\'){\\n                //postfix sum\\n                for (int j=dp.size()-2;j>=0;--j){\\n                    dp[j] += dp[j+1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j+1];\\n                }\\n            }\\n            else{\\n                //prefix sum\\n                for (int j=1;j<dp.size();++j){\\n                    dp[j] += dp[j-1]; \\n                    if (dp[j]>=MOD)dp[j] %= MOD;\\n                }\\n                for (int j=0;j<M;++j){\\n                    new_dp[j] = dp[j];\\n                }\\n            }\\n            dp = new_dp;\\n        }\\n        int ret = 0;\\n        for (int i=0;i<dp.size();++i){\\n            ret+=dp[i];\\n            if (ret>=MOD)ret %= MOD;}\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707459,
                "title": "python-dp-approach-some-explanation",
                "content": "Most of us here are preparing for programming Interviews and those interviews have a threshold of about 45 minutes, and you have to come-up with an approach, write code, and explain. If you spend some time on the discuss section, you will realize there are some awesome solutions, which take you more than an interview-time to understand, let alone to come-up and code it. You may probably not hit the cool greedy solution, or the most optimized DP within time (though with time you will improve) but you should first practice to be able to solve the problem **within time**.\\nIt is often helpful to keep a timer of 45 minutes to solve these problems, even if you are not able to solve it you will get enough understanding to explain your approaches and why those won\\'t work out? Then move to discuss sections and try to understand a solution in 10-20 minutes. If you are able to understand in this time, you can code in the remaining time.\\n\\nSo, the following is what I came up within ~45 minutes:\\nThis problem clearly speaks for a Dynamic Programmic approach. \\nYou can imagine a state graph, \\n* last state can have any values between [0, n]\\n* if the last step was \\'D\\', the previous state can have only a higher value than what at the last state. Similarly, a lower value if step was \\'I\\'.\\n* and the combination should be unique.\\n\\nThe third point, required some book-keeping of what numbers have appeared already. And I started out with a solution to keep the mask (as a tuple) (which as you may already know, won\\'t work). After much brainstorming, I realized that it is not required to keep the details of which numbers (specifically) have appeared. It would just suffice to keep the details of the number of numbers haven\\'t appeared and how many of them are lower (or higher) than the last number.\\n\\n```python\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        N = len(S)\\n        MOD = 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(i, less, more):\\n            res = 0\\n            if(i < 0): return 1\\n            if(less + more == 0): return 0\\n            if(S[i] == \\'I\\'):\\n                for k in range(less):\\n                    res = (res + dp(i-1, k, less - k -1 + more)) % MOD\\n            elif(S[i] == \\'D\\'):\\n                for k in range(more):\\n                    res = (res + dp(i-1, less + k, more - k - 1)) % MOD\\n            return res\\n        \\n        return sum(dp(N-1, k, N-k) for k in range(N+1)) % MOD\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        N = len(S)\\n        MOD = 10**9 + 7\\n        \\n        @lru_cache(None)\\n        def dp(i, less, more):\\n            res = 0\\n            if(i < 0): return 1\\n            if(less + more == 0): return 0\\n            if(S[i] == \\'I\\'):\\n                for k in range(less):\\n                    res = (res + dp(i-1, k, less - k -1 + more)) % MOD\\n            elif(S[i] == \\'D\\'):\\n                for k in range(more):\\n                    res = (res + dp(i-1, less + k, more - k - 1)) % MOD\\n            return res\\n        \\n        return sum(dp(N-1, k, N-k) for k in range(N+1)) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186571,
                "title": "python-o-n-3-o-n-2-time-o-n-space-dp-solution-with-clear-explanation-no-relative-rank-stuff",
                "content": "Since I didn\\'t understand the relative rank stuff, I found this problem to be quite confusing until I saw this thread:\\nhttps://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/169126/Visualization-Key-to-the-DP-solution:-imagine-cutting-a-piece-of-paper-and-separating-the-halves\\n\\n**Property: If we increment elements that are greater than or equal to a certain value the D or I property will not be broken, as this only makes \"larger\" elements even larger.**\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length i depends on, and can be derived from, the number of solutions with length i-1, as follows:\\n\\n    We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n    We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n    ...\\n    We increment all elements that are greater than or equal to i, and see if we can append i to the end of the sequence.\\n\\n**Therefore, we only care about the last number of each existing valid permutation.**\\n\\nFor each j in the range (0, i), we want to find the number of valid permutations of len i ending in j. \\n* When placing j following a decreasing instruction \\'D\\', we want the last number in the existing permutation to have a higher value. \\n* When placing j following an increasing instruction \\'I\\', we want the last number in the existing permutation to have a lower value. \\n\\nWe use two DP arrays of len(S)+1, dp and dp2. We swap dp and dp2 at the end of each step.\\n\\n**D:** 10\\nThe only valid permutation for \\'D\\' is 10.\\n* solutions ending with 0: 1\\n* solutions ending with 1: 0\\n\\n**DI:** 102, 201\\nWe want the last number in each existing permutation to have a lower value than j.\\n* \\\\# solutions ending with 0: 0\\nWe cannot add a 0 to any existing valid permutation, since the only valid permutation for \\'D\\' is 10.\\n* \\\\# solutions ending with 1: dp2[1] = dp[0], which is 1\\nWe have 1 solution ending with a 0 we can add a 0 to, since we want the last number in the permutation to have a lower value.\\n* \\\\# solutions ending with 2: dp2[2] = dp[0] + dp[1], which is 1\\nWe have 1 solution ending with a 0 we can add a 2 to, since we want the last number in the permutation to have a lower value.\\n\\n**DID:** 5 permutations\\nWe want the last number in each existing permutation to have a higher value than j. \\n* \\\\# of solutions ending with 0: dp[0] + dp[1] + dp[2] = 2\\nWe increment all elements in 102, 201 that are >= 0 to get 213 and 312, which we can add a 0 to.\\n* \\\\# solutions ending with 1: dp[1] + dp[2] = 2\\nWe increment all elements in 102, 201 that are >= 1 to get 203 and 302, which we can add a 1 to.\\n* \\\\# solutions ending with 2: dp[2] = 1\\nSimilarly, the permutation 102 becomes 103, which we can add a 2 to.\\n* \\\\# solutions ending with 3: 0\\n\\n**DIDI:** 16 permutations\\nFrom this point onward, only the number of permutations is listed for the sake of brevity.\\n\\nsolutions ending with 0: 0\\nsolutions ending with 1: 2 (dp[0])\\nsolutions ending with 2: 4 (dp[0] + dp[1])\\nsolutions ending with 3: 5 (dp[0] + dp[1] + dp[2])\\nsolutions ending with 4: 5 (dp[0] + dp[1] + dp[2] + dp[3])\\n\\nNow let\\'s see the two different outcomes for adding an I or D to that sequence:\\n\\n**DIDID:** 61 permutations\\nsolutions ending with 0: 16 (dp[0] + dp[1] + dp[2] + dp[3] + dp[4])\\nsolutions ending with 1: 16 (dp[1] + dp[2] + dp[3] + dp[4])\\nsolutions ending with 2: 14 (dp[2] + dp[3] + dp[4])\\nsolutions ending with 3: 10 (dp[3] + dp[4])\\nsolutions ending with 4: 5 (dp[4])\\nsolutions ending with 5: 0\\n\\n**DIDII:** 35 permutations\\nsolutions ending with 0: 0 \\nsolutions ending with 1: 0 (dp[0])\\nsolutions ending with 2: 2 (dp[0] + dp[1])\\nsolutions ending with 3: 6 (dp[0] + dp[1] + dp[2])\\nsolutions ending with 4: 11 (dp[0] + dp[1] + dp[2] + dp[3])\\nsolutions ending with 5: 16 (dp[0] + dp[1] + dp[2] + dp[3] + dp[4])\\n\\nYou might be able to notice a pattern here:\\nWhen placing j following a decreasing instruction \\'D\\', then dp2[j] = sum of dp[j] to dp[i-1]\\nWhen placing j following an increasing instruction \\'I\\', then dp2[j] = sum of dp[0] to dp[j-1]\\n\\nTherefore:\\n\\n```\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1 for c in range(len(S)+1)]\\n        dp2 = [0 for c in range(len(S)+1)]\\n        \\n        for i in range(1, len(S) + 1):\\n            if S[i-1] == \\'D\\':\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[j:i])\\n            else:\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[:j])\\n            dp, dp2 = dp2, dp\\n            \\n        return sum(dp) % 1000000007\\n```\\n\\t\\t\\n\\t\\t\\nThis solution is O(n^3)\\nInstead of having to use sum() each inner loop, you can calculate prefix/suffix sums in order to bring the runtime down to O(n^2)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1 for c in range(len(S)+1)]\\n        dp2 = [0 for c in range(len(S)+1)]\\n        \\n        for i in range(1, len(S) + 1):\\n            if S[i-1] == \\'D\\':\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[j:i])\\n            else:\\n                for j in range(i+1):\\n                    dp2[j] = sum(dp[:j])\\n            dp, dp2 = dp2, dp\\n            \\n        return sum(dp) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246618,
                "title": "why-backtracking-memoization-is-working",
                "content": "To all Coders of the Leetcode Community this post needs to be addressed \\nwhy this solution is working ??\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int n;\\n    \\n    vector<int> vis;\\n    \\n    int dp[202][202];\\n    \\n    long long func(int i,int j,string &s){\\n        if(i == n) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        long long ans=0;\\n        if(s[i] == \\'D\\'){\\n            \\n            for(int k=j-1;k>=0;k--){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }\\n            }\\n        }else{\\n            for(int k=j+1;k<=n;k++){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }\\n            }\\n        }\\n        \\n        return dp[i][j] = ans;\\n        \\n    }\\n    \\n    int numPermsDISequence(string s) {\\n        \\n        n = s.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vis = vector<int> (n+1,false);\\n        \\n        long long ans = 0;\\n        for(int i=0;i<=n;i++){\\n            vis[i] = true;\\n            long long tmp = func(0,i,s);\\n            ans += tmp;\\n            ans%=mod;\\n            vis[i] = false;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int n;\\n    \\n    vector<int> vis;\\n    \\n    int dp[202][202];\\n    \\n    long long func(int i,int j,string &s){\\n        if(i == n) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        long long ans=0;\\n        if(s[i] == \\'D\\'){\\n            \\n            for(int k=j-1;k>=0;k--){\\n                if(vis[k] == false){\\n                    vis[k] = true;\\n                    long long tmp = func(i+1,k,s);\\n                    ans += tmp;\\n                    ans%=mod;\\n                    vis[k] = false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1285921,
                "title": "c-memoization-backtracking-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int vis[201];\\n    long long int dp[202][202];\\n    int mod=1000000007;\\n    int util(string &s,int index,int prev){\\n        if(index==s.size()) return 1;\\n        \\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        \\n        long long int cnt=0;\\n        if(s[index]==\\'D\\'){\\n           for(int i=0;i<prev;i++){\\n               if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                     vis[i]=0;\\n               }\\n           } \\n        }\\n        else{\\n            for(int i=prev+1;i<=s.size();i++){\\n                if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                    vis[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        long long int cnt=0;\\n         memset(vis,0,sizeof(vis));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=s.size();i++){\\n            vis[i]=1;\\n            cnt+=(util(s,0,i))%mod;\\n            vis[i]=0;\\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[201];\\n    long long int dp[202][202];\\n    int mod=1000000007;\\n    int util(string &s,int index,int prev){\\n        if(index==s.size()) return 1;\\n        \\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        \\n        long long int cnt=0;\\n        if(s[index]==\\'D\\'){\\n           for(int i=0;i<prev;i++){\\n               if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                     vis[i]=0;\\n               }\\n           } \\n        }\\n        else{\\n            for(int i=prev+1;i<=s.size();i++){\\n                if(vis[i]==0){\\n                    vis[i]=1;\\n                    cnt+=(util(s,index+1,i))%mod;\\n                    vis[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        long long int cnt=0;\\n         memset(vis,0,sizeof(vis));\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=s.size();i++){\\n            vis[i]=1;\\n            cnt+=(util(s,0,i))%mod;\\n            vis[i]=0;\\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251715,
                "title": "c-soln-backtracking-dp",
                "content": "```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[201][202];\\n    int sol(string &s, int ind, int prev){\\n        if(ind==s.length()+1){return 1;}\\n        if(dp[ind][prev+1]!=-1)return dp[ind][prev+1];\\n        long ans=0;\\n        for(int i=0;i<=s.length();i++){\\n            if(vis[i]!=0)continue;\\n            if(prev!=-1){\\n                if(s[ind-1]==\\'D\\'){\\n                    if(i>prev)break;\\n                    vis[i]=1;\\n                    ans+=sol(s,ind+1,i);\\n                    vis[i]=0;\\n                }\\n                else{\\n                    if(i<prev)continue;\\n                    vis[i]=1;\\n                    ans+=sol(s, ind+1,i);\\n                    vis[i]=0;\\n                }\\n            }\\n            else {\\n                vis[i]=1;\\n                ans+=sol(s, ind+1, i);\\n                vis[i]=0;\\n            }\\n            \\n        }\\n        return dp[ind][prev+1]=ans%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        vis.resize(s.length()+1,0);\\n        return sol(s,0,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[201][202];\\n    int sol(string &s, int ind, int prev){\\n        if(ind==s.length()+1){return 1;}\\n        if(dp[ind][prev+1]!=-1)return dp[ind][prev+1];\\n        long ans=0;\\n        for(int i=0;i<=s.length();i++){\\n            if(vis[i]!=0)continue;\\n            if(prev!=-1){\\n                if(s[ind-1]==\\'D\\'){\\n                    if(i>prev)break;\\n                    vis[i]=1;\\n                    ans+=sol(s,ind+1,i);\\n                    vis[i]=0;\\n                }\\n                else{\\n                    if(i<prev)continue;\\n                    vis[i]=1;\\n                    ans+=sol(s, ind+1,i);\\n                    vis[i]=0;\\n                }\\n            }\\n            else {\\n                vis[i]=1;\\n                ans+=sol(s, ind+1, i);\\n                vis[i]=0;\\n            }\\n            \\n        }\\n        return dp[ind][prev+1]=ans%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        vis.resize(s.length()+1,0);\\n        return sol(s,0,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877923,
                "title": "dp-o-n-2-space-o-n-with-intuitive-walkthrough-about-how-to-derive-it",
                "content": "Knowing that we only have to figure out how many permutaitons there are, I stopped thinking about index orders, and instead thought about paths.\\n\\nConceptually, with D alone there\\'s only one path.\\n\\n```\\n *   \\n  \\\\\\n   * (ending)\\n ```\\n \\n If we do DI, then the up path can end either between the existing two nodes, or at the top:\\n\\n```\\n0:      * (ending)\\n1: *   /\\n    \\\\ /\\n2:   *\\n\\n0: *\\n1:  \\\\   *(ending)\\n     \\\\ /\\n2:    *\\n```\\n\\nThe way I began to represent this is the number of paths that END at a given index.\\nD: [0, 1]\\nDI: [1, 1, 0]\\n\\nNow, for DID, we should think about continuing the path that ends at index 0 and 1. Since it will have to go down from there, we\\'ll add an index and consider the number of places the current paths can go. When there are more than just 1 paths ending at an index, we\\'ll need to preserve the increasing possibilities, so I\\'m using variables instead of 1 to show how it should work.\\n\\n```\\n0: x |\\n1: y |\\n2: z |\\n3:   |  (add an index)\\n\\n// add x to all of the indices below it.\\n// add y to all of the indices below it.\\n// etc. for each index i from 1..n\\n// x = 1, y = 1, z = 0\\n0: x |\\n1: y | x\\n2: z | x y\\n3:   | x y z\\n\\n0: 1 |     -> 0\\n1: 1 | 1   -> 1\\n2: 0 | 1 1 -> 2\\n3:   | 1 1 -> 2\\n```\\n\\nSo DID = [0, 1, 2, 2] (The sum of these = 5)\\n\\nNow lets take it one step further for each direction to watch how it evolves:\\n\\n```\\nDIDD:\\n0: 0 |       -> 0\\n1: 1 |       -> 0\\n2: 2 | 1     -> 1\\n3: 2 | 1 2   -> 3\\n4:   | 1 2 2 -> 5\\n\\nDIDI:\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n```\\n\\nFor increasing the end paths, we have to first imagine shifting all of the indices up (down visually in my ascii art) by one and inserting a new index at 0 => [0 0 1 2 2]. Then accumulating each index to the indices before it. However, we don\\'t actually have shift all the data, we can just modify where we read the array from. That\\'s why it\\'s depicted above as adding the number of ending paths to all of the rows ABOVE OR EQUAL to that index.\\n\\nNow, at this point, we can look for patterns.\\nOne thing I spotted was this:\\n```\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n-------------------\\n       2*4 +\\n\\t     2*3 +\\n\\t\\t   1*2 +\\n\\t\\t     0*1\\n```\\nWhich, does give us the answer, but alas isn\\'t that useful for determining the next incremental step.\\nSo instead looking at each row rather than each column, we can see that \"2 2 1\" from the previous array is present, at index 0 and 1.\\nAnd it\\'s essentially a running sum from back to front.\\n\\nSo now we can translate that into an algorithm to compute each index:\\nSo, for the case of \"I\":\\n\\nassuming we index into the string with k, S[k] == \"I\":\\nn = k+1\\n\\n\\t// sum from n-1 to 0\\n\\t// writing from n-1 to 0\\n\\tdp[n] = 0;\\n\\tfor (int i = n-1; i >= 0; i--) {\\n\\t\\tdp[i] = (dp[i+1] + dp[i]) % m;\\n\\t}\\n\\nNow lets look at D again:\\n\\n    DIDD:\\n\\t0: 0 |       -> 0\\n\\t1: 1 |       -> 0\\n\\t2: 2 | 1     -> 1\\n\\t3: 2 | 2 1   -> 3\\n\\t4:   | 2 2 1 -> 5\\n\\nIndex 4 shows [2 2 1], and index 3 shows [2 1], so spotting the pattern, just like in the increasing case, we can accumulate the values from the previous step and store them, but this time we need to iterate through the array in the forwards direction when accumulating.\\n                \\n\\t// sum from 0 to n-1\\n\\t// writing from 1 to n\\n\\t//sum = dp[0];\\n\\tint saved  = dp[0];\\n\\tdp[0] = 0;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tint t = dp[i];\\n\\t\\tdp[i] = (dp[i-1] + saved) % m;\\n\\t\\tsaved = t;\\n\\t}\\n\\nI\\'m having to use some temporary values so I can modify the same array, since we need to iterate through it forward and shift it at the same time.\\n\\nHere\\'s the full solution:\\n\\n    int numPermsDISequence(string s) {\\n        int m = 1000000007;\\n        // make the buffer:\\n        int dp[s.size()+1];\\n        dp[0] = 1;\\n        \\n        int sum = 0;\\n        for (int k = 0; k < s.size(); k++) {\\n            int n = k+1;\\n            if (s[k] == \\'D\\') {\\n                // sum from 0 to n-1\\n                // writing to 1 to n\\n                //sum = dp[0];\\n                int saved  = dp[0];\\n                dp[0] = 0;\\n                for (int i = 1; i <= n; i++) {\\n                    int t = dp[i];\\n                    dp[i] = (dp[i-1] + saved) % m;\\n                    saved = t;\\n                }\\n            } else {\\n                // sum from n-1 to 0\\n                // writing from n-1 to 0\\n                dp[n] = 0;\\n                for (int i = n-1; i >= 0; i--) {\\n                    dp[i] = (dp[i+1] + dp[i]) % m;\\n                }\\n            }\\n        }\\n        sum = 0;\\n        for (int i = 0; i <= s.size(); i++) {\\n            sum = (sum + dp[i]) % m;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\n *   \\n  \\\\\\n   * (ending)\\n ```\n```\\n0:      * (ending)\\n1: *   /\\n    \\\\ /\\n2:   *\\n\\n0: *\\n1:  \\\\   *(ending)\\n     \\\\ /\\n2:    *\\n```\n```\\n0: x |\\n1: y |\\n2: z |\\n3:   |  (add an index)\\n\\n// add x to all of the indices below it.\\n// add y to all of the indices below it.\\n// etc. for each index i from 1..n\\n// x = 1, y = 1, z = 0\\n0: x |\\n1: y | x\\n2: z | x y\\n3:   | x y z\\n\\n0: 1 |     -> 0\\n1: 1 | 1   -> 1\\n2: 0 | 1 1 -> 2\\n3:   | 1 1 -> 2\\n```\n```\\nDIDD:\\n0: 0 |       -> 0\\n1: 1 |       -> 0\\n2: 2 | 1     -> 1\\n3: 2 | 1 2   -> 3\\n4:   | 1 2 2 -> 5\\n\\nDIDI:\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n```\n```\\n0: 0 | 2 2 1 | 5\\n1: 1 | 2 2 1 | 5\\n2: 2 | 2 2   | 4\\n3: 2 | 2     | 2\\n4: 0 |       | 0\\n-------------------\\n       2*4 +\\n\\t     2*3 +\\n\\t\\t   1*2 +\\n\\t\\t     0*1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 652054,
                "title": "java-dfs-with-memo",
                "content": "\\n```\\nclass Solution {\\n    private static int MOD = 1000000007;\\n    public int numPermsDISequence(String S) {\\n        int res = 0;\\n        Integer[][] dp = new Integer[S.length() + 1][S.length() + 1];\\n        \\n        for (int i = 0; i <= S.length(); i++) {\\n            res += dfs(i, S.length() - i, dp, S, 0);\\n            res = res % MOD;\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int higher, int lower, Integer[][] dp, String S, int index) {\\n        if (index == S.length()) {\\n            return 1;\\n        }\\n        int d = S.charAt(index) == \\'D\\' ? 1 : 0;\\n        if (dp[higher][lower] != null) {\\n            return dp[higher][lower];\\n        }\\n        int count = 0;\\n        if (d == 1) {\\n            if (lower > 0) {\\n                for (int i = 0; i < lower; i++) {\\n                    count += dfs(higher + i, lower - (i + 1), dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        } else {\\n            if (higher > 0) {\\n                for (int i = 0; i < higher; i++) {\\n                    count += dfs(higher - (i + 1), lower + i, dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        }\\n        dp[higher][lower] = count;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int MOD = 1000000007;\\n    public int numPermsDISequence(String S) {\\n        int res = 0;\\n        Integer[][] dp = new Integer[S.length() + 1][S.length() + 1];\\n        \\n        for (int i = 0; i <= S.length(); i++) {\\n            res += dfs(i, S.length() - i, dp, S, 0);\\n            res = res % MOD;\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int higher, int lower, Integer[][] dp, String S, int index) {\\n        if (index == S.length()) {\\n            return 1;\\n        }\\n        int d = S.charAt(index) == \\'D\\' ? 1 : 0;\\n        if (dp[higher][lower] != null) {\\n            return dp[higher][lower];\\n        }\\n        int count = 0;\\n        if (d == 1) {\\n            if (lower > 0) {\\n                for (int i = 0; i < lower; i++) {\\n                    count += dfs(higher + i, lower - (i + 1), dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        } else {\\n            if (higher > 0) {\\n                for (int i = 0; i < higher; i++) {\\n                    count += dfs(higher - (i + 1), lower + i, dp, S, index + 1);\\n                    count = count % MOD;\\n                }\\n            }\\n        }\\n        dp[higher][lower] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606518,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long dp[][];\\n    public int numPermsDISequence(String s) {//i: string index   end: end with number end\\n        int len=s.length();\\n        long res=0;\\n        dp=new long[len+1][len+1];\\n        dp[0][0]=1;\\n        for(int i=1;i<=s.length();i++){\\n            char c=s.charAt(i-1);\\n            for(int end=0;end<=i;end++){\\n                long val=0;\\n                if(c==\\'D\\'){\\n                    for(int j=end;j<=i-1;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }else{\\n                    for(int j=0;j<end;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }\\n                dp[i][end]=val;\\n            }\\n        }\\n        for(int i=0;i<dp[0].length;i++){\\n            res+=dp[len][i];\\n            res%=mod;\\n        }\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    long dp[][];\\n    public int numPermsDISequence(String s) {//i: string index   end: end with number end\\n        int len=s.length();\\n        long res=0;\\n        dp=new long[len+1][len+1];\\n        dp[0][0]=1;\\n        for(int i=1;i<=s.length();i++){\\n            char c=s.charAt(i-1);\\n            for(int end=0;end<=i;end++){\\n                long val=0;\\n                if(c==\\'D\\'){\\n                    for(int j=end;j<=i-1;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }else{\\n                    for(int j=0;j<end;j++){\\n                        val+=dp[i-1][j];\\n                        val%=mod;\\n                    }\\n                }\\n                dp[i][end]=val;\\n            }\\n        }\\n        for(int i=0;i<dp[0].length;i++){\\n            res+=dp[len][i];\\n            res%=mod;\\n        }\\n        return (int)(res%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289703,
                "title": "backtracking-to-dp-java-solution",
                "content": "**Idea**\\nWe will try all possibilities for all positions and backtracking when we can\\'t go further. `seen` maintains the visited numbers in per recursion tree branch.\\n\\n**Solution1** **TLE**\\n```\\nclass Solution {\\n    int[] seen = null;\\n    public int numPermsDISequence(String s) {\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount += numPerms(s, 0, i);\\n            seen[i] = 0;\\n        }\\n        return count;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Solution2** DP Memo for overlapping subproblems. `dp[j][p]` indicates number of permutations till `j`th char in `s` and for permutations ending with number `p` (`p` stands for parent in my recursion, since we are exploring the subtree rooted at `p` in the recursion call).\\n```\\nclass Solution {\\n    private static final int DIV = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % DIV + numPerms(s, 0, i) % DIV;\\n            seen[i] = 0;\\n        }\\n        return count % DIV;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i)  % DIV;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i) % DIV;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % DIV;\\n        return dp[j][p];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] seen = null;\\n    public int numPermsDISequence(String s) {\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount += numPerms(s, 0, i);\\n            seen[i] = 0;\\n        }\\n        return count;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count += numPerms(s, j+1, i);\\n                seen[i] = 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private static final int DIV = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % DIV + numPerms(s, 0, i) % DIV;\\n            seen[i] = 0;\\n        }\\n        return count % DIV;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i)  % DIV;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % DIV + numPerms(s, j+1, i) % DIV;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % DIV;\\n        return dp[j][p];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154540,
                "title": "memo-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int dp[201][201];\\n    int mod=1e9+7;\\n    int util(string &s,vector<int>&visited,int curr,int index,int n){\\n        if(index==s.length())\\n            return 1;\\n        if(dp[curr][index]!=-1)\\n            return dp[curr][index];\\n        int res=0;\\n        visited[curr]=true;\\n        if(s[index]==\\'I\\'){\\n            for(int i=curr+1;i<=n;i++)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }else{\\n            for(int i=curr-1;i>=0;i--)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }\\n        visited[curr]=false;\\n        return dp[curr][index]=res;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=s.length();\\n        vector<int>visited(n+1,false);\\n        int res=0;\\n        for(int i=0;i<=n;i++)\\n         res=(res+util(s,visited,i,0,n))%mod;\\n        return res;\\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int dp[201][201];\\n    int mod=1e9+7;\\n    int util(string &s,vector<int>&visited,int curr,int index,int n){\\n        if(index==s.length())\\n            return 1;\\n        if(dp[curr][index]!=-1)\\n            return dp[curr][index];\\n        int res=0;\\n        visited[curr]=true;\\n        if(s[index]==\\'I\\'){\\n            for(int i=curr+1;i<=n;i++)\\n                if(!visited[i])\\n                res=(res+util(s,visited,i,index+1,n))%mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3392399,
                "title": "backtracking-memoization-is-working-why",
                "content": "# Doubt\\n   Since to decide a unique state , we need:\\n\\n            1.index at which we are currently in string s\\n            2.previous element chosen\\n            3.set of numbers that are used or left.Here vis vector.\\n\\n   But i have done memoization over first two, but the soln is working.Can\\'t understand why??\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[202][202];\\n    ll mod=1e9+7;\\nint fun(int ind,int prev,int n,string&s, vector<bool>&vis)\\n{\\n    if(ind==s.size())\\n    {\\n        return 1;\\n    }\\n\\n     if(dp[ind][prev]!=-1) return dp[ind][prev];\\n    int ans=0;\\n    if(s[ind]==\\'D\\')\\n    {\\n       for(int i=prev-1;i>=0;i--)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n    else if(s[ind]==\\'I\\')\\n    {\\n        for(int i=prev+1;i<=n;i++)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n   return dp[ind][prev]=ans;\\n}\\n\\nint numPermsDISequence(string s) \\n{\\n    memset(dp,-1,sizeof(dp));\\n    ll n=s.size();\\n    vector<bool>vis(n+1,0);\\n    int ans=0;\\n    for(int i=0;i<=n;i++)\\n    {\\n        vis[i]=1;\\n        ans+=fun(0,i,n,s,vis);\\n        ans%=mod;\\n        vis[i]=0;\\n    }\\n    //cout<<\"ans=\"<<ans<<endl;\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[202][202];\\n    ll mod=1e9+7;\\nint fun(int ind,int prev,int n,string&s, vector<bool>&vis)\\n{\\n    if(ind==s.size())\\n    {\\n        return 1;\\n    }\\n\\n     if(dp[ind][prev]!=-1) return dp[ind][prev];\\n    int ans=0;\\n    if(s[ind]==\\'D\\')\\n    {\\n       for(int i=prev-1;i>=0;i--)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n    else if(s[ind]==\\'I\\')\\n    {\\n        for(int i=prev+1;i<=n;i++)\\n       {\\n         if(vis[i]==0)\\n         {\\n            vis[i]=1;\\n            ans+=fun(ind+1,i,n,s,vis);\\n            ans%=mod;\\n            vis[i]=0;\\n         }\\n       }\\n    }\\n   return dp[ind][prev]=ans;\\n}\\n\\nint numPermsDISequence(string s) \\n{\\n    memset(dp,-1,sizeof(dp));\\n    ll n=s.size();\\n    vector<bool>vis(n+1,0);\\n    int ans=0;\\n    for(int i=0;i<=n;i++)\\n    {\\n        vis[i]=1;\\n        ans+=fun(0,i,n,s,vis);\\n        ans%=mod;\\n        vis[i]=0;\\n    }\\n    //cout<<\"ans=\"<<ans<<endl;\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2781519,
                "title": "detailed-explanation-and-intuition",
                "content": "# Intuition\\n\\nThe possible lengths of `s`, and the fact that there\\'s a modulo involved, hints that were dealing with some sort of recursive function.\\n\\nIndeed, we have a very large number of alternatives for each step. For a 200 character string, there are 200 valid first choices to explore (some of which may later turn out to be invalid). Then, there\\'s potentially 199 choices, and so on, yielding $\\\\textrm{O}(n!)$.\\n\\nThis tells us that we need to memoize each step somehow. For memoization to work, we must describe the state in such a way that the state space isn\\'t too large.\\n\\nA naive first attempt at a state would be to store:\\n\\n1. $\\\\textrm{O}(n)$ - previously picked index\\n2. $\\\\textrm{O}(n)$ - remaining string length\\n3. $\\\\textrm{O}(n!)$ - set of remaining numbers\\n\\nClearly, (3) won\\'t work.\\n\\nAt this point when you\\'re stuck, it\\'s good to write down some different examples and look for clues. Try moving from a massive `n` to the next step, like `n = 100` to `n = 99`. Try to move from `n = 1` to `n = 0`. Try the other direction, i.e. to introduce a new number to the set.\\n\\nFor me, the breakthrough was when I imagined the last step of a long series of changes that started with `n = 100`. What possible numbers could be left in the set?\\n\\n$$\\n\\\\{ (0, 1), (0, 2), ..., (0, n) \\\\}\\\\\\\\\\n\\\\{ (1, 0), (1, 2), ..., (1, n) \\\\}\\\\\\\\\\n... \\\\\\\\\\n\\\\{ (n, 0), (n, 1), ..., (n, n-1) \\\\}\\\\\\\\\\n$$\\n\\nTo evaluate `\\'D\\'` or `\\'I\\'` with these pairs, it only mattered whether the pair was increasing or decreasing. In other words, we could reduce all these pairs to $(0, 1)$ or $(1, 0)$ and it would make no difference to the result.\\n\\nThis told me that the set could always contain the same numbers, i.e. from `0..n`. It was only the relative position of numbers that mattered.\\n\\n# Approach\\n\\nDue to the reasoning above, the set of possible choices is dependent only on the length of / position in `s` and the previously picked value `x`. This gives us a state space of $\\\\textrm{O}(n^2)$.\\n\\nOnce a valid current number is found, we pick it and continue evaluation. Since the set of numbers is reduced each turn, we must deduct 1 from number `y` when is larger than `x` (x is removed from the set).\\n\\nNote: it is trivial to change top-down to bottom-up, almost always at the expense of legibility. So I\\'ll stick with top-down here.\\n\\n# Complexity\\n\\n- Time complexity: $\\\\textrm{O}(n^2)$\\n- Space complexity: $\\\\textrm{O}(n^2)$\\n\\n# Code\\n\\n```go\\nconst mod = 1e9 + 7\\n\\nfunc numPermsDISequence(s string) int {\\n\\tvar res int\\n\\tn := len(s)\\n\\tmem := make([][]int, n+1)\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, n+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tres = (res + numPerms(mem, s, i)) % mod\\n\\t}\\n\\treturn res\\n}\\n\\nfunc numPerms(mem [][]int, s string, x int) int {\\n\\tn := len(s)\\n\\tif mem[n][x] != -1 {\\n\\t\\treturn mem[n][x]\\n\\t}\\n\\tif len(s) == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tvar res int\\n\\tif s[0] == \\'I\\' {\\n\\t\\tfor y := x + 1; y <= n; y++ {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y-1)) % mod\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor y := x - 1; y >= 0; y-- {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y)) % mod\\n\\t\\t}\\n\\t}\\n\\tmem[n][x] = res\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nconst mod = 1e9 + 7\\n\\nfunc numPermsDISequence(s string) int {\\n\\tvar res int\\n\\tn := len(s)\\n\\tmem := make([][]int, n+1)\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, n+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tres = (res + numPerms(mem, s, i)) % mod\\n\\t}\\n\\treturn res\\n}\\n\\nfunc numPerms(mem [][]int, s string, x int) int {\\n\\tn := len(s)\\n\\tif mem[n][x] != -1 {\\n\\t\\treturn mem[n][x]\\n\\t}\\n\\tif len(s) == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\tvar res int\\n\\tif s[0] == \\'I\\' {\\n\\t\\tfor y := x + 1; y <= n; y++ {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y-1)) % mod\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor y := x - 1; y >= 0; y-- {\\n\\t\\t\\tres = (res + numPerms(mem, s[1:], y)) % mod\\n\\t\\t}\\n\\t}\\n\\tmem[n][x] = res\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030781,
                "title": "python-dp-10-lines-of-code-detailed-comments",
                "content": "```\\ndef numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # len(dp) is the length of remaining unused set as remain_set\\n        # dp[i] means the last digit of any permutation formed by used set is remain_set[i]\\n        # so, initially, remain_set = [0, 1, ..,n]\\n        # dp[i] = 1\\n        # so, the remain_set for dp[i] is [0, 1,..,i-1, i+1..n]\\n        # Two edge cases:\\n        # remain_set for dp[0] becomes [1, 2,..,n]\\n        # remain_set for dp[n] becomes [0, 1, 2,..,n-1]\\n        # for the new remain_set, dp\\'s lenght becomes the length of new remain_set\\n        # let\\'s create a new dp1 which depends on s[0]\\n        # if s[0] is \\'I\\',\\n        # dp1[0] = dp[0] + dp[1]\\n        # dp1[i] = dp[0] + dp[1] + ..+ dp[i]\\n        # if s[0] is \\'D\\',\\n        # dp1[len(remain_set)-1 # n-1] = dp[n]\\n        # dp1[i] = dp[i+1] + dp[i+2] + ..+ dp[n]\\n        dp = [1] * (n+1)\\n        for c in s:\\n            dp1 = [0]*(len(dp)-1)\\n            if c == \"I\":\\n                for i in range(len(dp1)):\\n                    dp1[i] = sum(dp[:i+1])\\n            else:\\n                for i in range(len(dp1)-1, -1, -1):\\n                    dp1[i] = sum(dp[i+1:])\\n            dp = dp1\\n        return dp[0] % (10**9 + 7)",
                "solutionTags": [],
                "code": "```\\ndef numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # len(dp) is the length of remaining unused set as remain_set\\n        # dp[i] means the last digit of any permutation formed by used set is remain_set[i]\\n        # so, initially, remain_set = [0, 1, ..,n]\\n        # dp[i] = 1\\n        # so, the remain_set for dp[i] is [0, 1,..,i-1, i+1..n]\\n        # Two edge cases:\\n        # remain_set for dp[0] becomes [1, 2,..,n]\\n        # remain_set for dp[n] becomes [0, 1, 2,..,n-1]\\n        # for the new remain_set, dp\\'s lenght becomes the length of new remain_set\\n        # let\\'s create a new dp1 which depends on s[0]\\n        # if s[0] is \\'I\\',\\n        # dp1[0] = dp[0] + dp[1]\\n        # dp1[i] = dp[0] + dp[1] + ..+ dp[i]\\n        # if s[0] is \\'D\\',\\n        # dp1[len(remain_set)-1 # n-1] = dp[n]\\n        # dp1[i] = dp[i+1] + dp[i+2] + ..+ dp[n]\\n        dp = [1] * (n+1)\\n        for c in s:\\n            dp1 = [0]*(len(dp)-1)\\n            if c == \"I\":\\n                for i in range(len(dp1)):\\n                    dp1[i] = sum(dp[:i+1])\\n            else:\\n                for i in range(len(dp1)-1, -1, -1):\\n                    dp1[i] = sum(dp[i+1:])\\n            dp = dp1\\n        return dp[0] % (10**9 + 7)",
                "codeTag": "Python3"
            },
            {
                "id": 4049287,
                "title": "explained-why-backtrack-memorization-working",
                "content": "why it works without explicitly saving the state of the visited array?\\n\\n\\nWhen we backtrack and return from a recursive call, we reset ```_ visited[curr] to false _``` which means that the state of visited is restored to what it was before the recursive call.\\n\\nThe memoization table dp is used to store and retrieve previously computed results for specific combinations of curr and index. This allows the algorithm to avoid redundant calculations and significantly improves its efficiency.\\n\\nIn summary, while the visited array is modified during the recursion, it is effectively reset to its original state when backtracking,``` _ thanks to the visited[curr] = false statement _ ``` \\nThe state of visited is managed correctly within the recursive calls, and the memoization table dp ensures that previously computed results are reused to avoid unnecessary computations. This is why the algorithm works correctly without explicitly saving the state of the visited array.\\n\\n```\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    int n;\\n    int dp[203][203];\\n    int m=1e9+7;\\n    int solve(int idx,int prev, vector<int>&vis)\\n    {\\n        if(idx==n) return 1;        \\n        if(dp[idx+1][prev+1]!=-1) return dp[idx+1][prev+1];\\n        long long ans=0;\\n        if(idx==-1)\\n        {\\n            for(int i=0; i<=n; i++) \\n            {\\n                vis[i]=1;\\n                ans+=solve(0,i,vis)%m;\\n                ans%=m;\\n                vis[i]=0;\\n            }\\n        }else\\n        {\\n            for(int i=0; i<=n; i++)\\n            {\\n                if(vis[i]==0 )\\n                {\\n                    if(s[idx]==\\'D\\' &&i<prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }else if(s[idx]==\\'I\\' && i>prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[idx+1][prev+1]=(int)ans;\\n    }\\n    \\n    int numPermsDISequence(string s1) \\n    {\\n        s=s1;\\n        n=s.size();\\n        vector<int> vis(n+1,0);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(-1,-1,vis);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```_ visited[curr] to false _```\n``` _ thanks to the visited[curr] = false statement _ ```\n```\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    int n;\\n    int dp[203][203];\\n    int m=1e9+7;\\n    int solve(int idx,int prev, vector<int>&vis)\\n    {\\n        if(idx==n) return 1;        \\n        if(dp[idx+1][prev+1]!=-1) return dp[idx+1][prev+1];\\n        long long ans=0;\\n        if(idx==-1)\\n        {\\n            for(int i=0; i<=n; i++) \\n            {\\n                vis[i]=1;\\n                ans+=solve(0,i,vis)%m;\\n                ans%=m;\\n                vis[i]=0;\\n            }\\n        }else\\n        {\\n            for(int i=0; i<=n; i++)\\n            {\\n                if(vis[i]==0 )\\n                {\\n                    if(s[idx]==\\'D\\' &&i<prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }else if(s[idx]==\\'I\\' && i>prev)\\n                    {\\n                        vis[i]=1;\\n                        ans+=solve(idx+1,i, vis)%m;\\n                        ans%=m;\\n                        vis[i]=0;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[idx+1][prev+1]=(int)ans;\\n    }\\n    \\n    int numPermsDISequence(string s1) \\n    {\\n        s=s1;\\n        n=s.size();\\n        vector<int> vis(n+1,0);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(-1,-1,vis);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649709,
                "title": "dp-solution",
                "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2333944,
                "title": "python-solution-tricky-question",
                "content": "```\\nclass Solution:\\n    # an implicit DP problem\\n    # For simplicity, let\\'s consider the sequence \"D\"\\n    # So we have the sequences [0,1] to permute\\n    # The valid permutation is [1,0]\\n    # Now let\\'s go to \"DI\", we add the number 2\\n    # and let\\'s separate the cases in which the sequence ends with different numbers\\n    # We see that 0 cannot be the end, because it cannot account for the I\\n    # We see that it can end with 1, by increasing every number larger than 1 by 1: [2, 0, 1]\\n    # We see the same applies for ending with 2: [1, 0, 2]\\n    # Now we consider the alternative \"DD\"\\n    # We see that we can get 0 to be the end by increasing all numbers larger or equal to 0 by 1: [2,1,0]\\n    # We cannot satisfy this for 1 and 2\\n    # Therefore, to solve the problem, we need to build the sequences from left to right\\n    # dp[i][j] = number of sequences that uses integers from [0,i] and ends with j\\n    # dp[0][0] = 1\\n    # If s = \"D\": dp[1][0] = dp[0][0] = 1; dp[1][1] = 0\\n    # If s = \"I\": dp[1][0] = 0; dp[1][1] = dp[0][0] = 1\\n    # If s = \"DI\": dp[2][0] = 0; dp[2][1] = dp[1][0] = 1; dp[2][2] = dp[1][0] + dp[1][1] = 1\\n    # If s = \"DD\": dp[2][0] = dp[1][0] + dp[1][1] = 1; dp[2][1] = dp[1][0] = 0; dp[2][2] = 0\\n    # If s = \"DID\": dp[3][0] = dp[2][0] + dp[2][1] + dp[2][2] = 0 + 1 + 1 = 2; dp[3][1] = dp[2][1] + dp[2][2] = 1 + 1 = 2; dp[3][2] =  dp[2][2] = 1; dp[3][3] = 0\\n    # As we see we should calculate prefix sum or suffix sums according to whether the current character is \"D\" or \"L\" respectively to facilitate calculations\\n    def numPermsDISequence(self, s: str) -> int:\\n        prev, MOD = [1], pow(10,9) + 7\\n        for i, c in enumerate(s):\\n            if c == \"D\":\\n                prefix = [0]*(i+2)\\n                for j in range(1,i+2,1):\\n                    prefix[j] = prefix[j-1] + prev[j-1]\\n                    prefix[j] %= MOD\\n                #print(\"prefix = \", prefix)\\n                nxt = [0]*(i+2)\\n                for j in range(i+1):\\n                    nxt[j] = prefix[i+1] - prefix[j]\\n            else:\\n                suffix = [0]*(i+2)\\n                for j in range(i,-1,-1):\\n                    suffix[j] = suffix[j+1] + prev[j]\\n                    suffix[j] %= MOD\\n                #print(\"suffix = \", suffix)\\n                nxt = [0]*(i+2)\\n                for j in range(1,i+2):\\n                    nxt[j] = suffix[0] - suffix[j]\\n            prev = nxt[:]\\n        return sum(prev) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # an implicit DP problem\\n    # For simplicity, let\\'s consider the sequence \"D\"\\n    # So we have the sequences [0,1] to permute\\n    # The valid permutation is [1,0]\\n    # Now let\\'s go to \"DI\", we add the number 2\\n    # and let\\'s separate the cases in which the sequence ends with different numbers\\n    # We see that 0 cannot be the end, because it cannot account for the I\\n    # We see that it can end with 1, by increasing every number larger than 1 by 1: [2, 0, 1]\\n    # We see the same applies for ending with 2: [1, 0, 2]\\n    # Now we consider the alternative \"DD\"\\n    # We see that we can get 0 to be the end by increasing all numbers larger or equal to 0 by 1: [2,1,0]\\n    # We cannot satisfy this for 1 and 2\\n    # Therefore, to solve the problem, we need to build the sequences from left to right\\n    # dp[i][j] = number of sequences that uses integers from [0,i] and ends with j\\n    # dp[0][0] = 1\\n    # If s = \"D\": dp[1][0] = dp[0][0] = 1; dp[1][1] = 0\\n    # If s = \"I\": dp[1][0] = 0; dp[1][1] = dp[0][0] = 1\\n    # If s = \"DI\": dp[2][0] = 0; dp[2][1] = dp[1][0] = 1; dp[2][2] = dp[1][0] + dp[1][1] = 1\\n    # If s = \"DD\": dp[2][0] = dp[1][0] + dp[1][1] = 1; dp[2][1] = dp[1][0] = 0; dp[2][2] = 0\\n    # If s = \"DID\": dp[3][0] = dp[2][0] + dp[2][1] + dp[2][2] = 0 + 1 + 1 = 2; dp[3][1] = dp[2][1] + dp[2][2] = 1 + 1 = 2; dp[3][2] =  dp[2][2] = 1; dp[3][3] = 0\\n    # As we see we should calculate prefix sum or suffix sums according to whether the current character is \"D\" or \"L\" respectively to facilitate calculations\\n    def numPermsDISequence(self, s: str) -> int:\\n        prev, MOD = [1], pow(10,9) + 7\\n        for i, c in enumerate(s):\\n            if c == \"D\":\\n                prefix = [0]*(i+2)\\n                for j in range(1,i+2,1):\\n                    prefix[j] = prefix[j-1] + prev[j-1]\\n                    prefix[j] %= MOD\\n                #print(\"prefix = \", prefix)\\n                nxt = [0]*(i+2)\\n                for j in range(i+1):\\n                    nxt[j] = prefix[i+1] - prefix[j]\\n            else:\\n                suffix = [0]*(i+2)\\n                for j in range(i,-1,-1):\\n                    suffix[j] = suffix[j+1] + prev[j]\\n                    suffix[j] %= MOD\\n                #print(\"suffix = \", suffix)\\n                nxt = [0]*(i+2)\\n                for j in range(1,i+2):\\n                    nxt[j] = suffix[0] - suffix[j]\\n            prev = nxt[:]\\n        return sum(prev) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293851,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\\'I\\' + S, S):\\n            dp = list(itertools.accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880241,
                "title": "c-dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dfs(vector<vector<int>> &dp,vector<bool> &vis,string &s,int in,int n,int last){\\n        if(in>=s.size()) return 1;\\n        if(dp[in][last]!=-1) return dp[in][last];\\n        if(s[in]==\\'D\\'){  \\n            long re = 0;\\n            for(int i = 0; i<last; ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n        else{\\n            long re = 0;\\n            for(int i = last+1; i<=s.size(); ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n    }\\n    int numPermsDISequence(string s) {\\n        int n = s.size(), i = 0; \\n        long re = 0;\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,0);\\n        \\n        if(s[0]==\\'D\\') i++; \\n        for(;i<=n;i++){\\n            vis[i] = 1;\\n            re = (re + dfs(dp,vis,s,0,n,i))%mod;\\n            vis[i] = 0;\\n        }\\n        return (int)re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dfs(vector<vector<int>> &dp,vector<bool> &vis,string &s,int in,int n,int last){\\n        if(in>=s.size()) return 1;\\n        if(dp[in][last]!=-1) return dp[in][last];\\n        if(s[in]==\\'D\\'){  \\n            long re = 0;\\n            for(int i = 0; i<last; ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n        else{\\n            long re = 0;\\n            for(int i = last+1; i<=s.size(); ++i){\\n                if(vis[i]==1) continue;\\n                vis[i] = 1;\\n                int k = dfs(dp,vis,s,in+1,n,i);\\n                vis[i]=0;\\n                re = (re + k)%mod;\\n            }\\n            return dp[in][last] = (int)re;\\n        }\\n    }\\n    int numPermsDISequence(string s) {\\n        int n = s.size(), i = 0; \\n        long re = 0;\\n        vector<vector<int>> dp(n+2,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,0);\\n        \\n        if(s[0]==\\'D\\') i++; \\n        for(;i<=n;i++){\\n            vis[i] = 1;\\n            re = (re + dfs(dp,vis,s,0,n,i))%mod;\\n            vis[i] = 0;\\n        }\\n        return (int)re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261833,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        \\n        @cache \\n        def fn(i, x): \\n            \"\"\"Return number of valid permutation given x numbers smaller than previous one.\"\"\"\\n            if i == len(s): return 1 \\n            if s[i] == \"D\": \\n                if x == 0: return 0 # cannot decrease\\n                return fn(i, x-1) + fn(i+1, x-1)\\n            else: \\n                if x == len(s)-i: return 0 # cannot increase \\n                return fn(i, x+1) + fn(i+1, x)\\n        \\n        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        \\n        @cache \\n        def fn(i, x): \\n            \"\"\"Return number of valid permutation given x numbers smaller than previous one.\"\"\"\\n            if i == len(s): return 1 \\n            if s[i] == \"D\": \\n                if x == 0: return 0 # cannot decrease\\n                return fn(i, x-1) + fn(i+1, x-1)\\n            else: \\n                if x == len(s)-i: return 0 # cannot increase \\n                return fn(i, x+1) + fn(i+1, x)\\n        \\n        return sum(fn(0, x) for x in range(len(s)+1)) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645163,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++){\\n            dp[0][j] = 1;\\n        } \\n        for (int i = 0; i < n; i++){\\n            if (S[i] == \\'I\\'){\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            } else {\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;   \\n            }\\n        }  \\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++){\\n            dp[0][j] = 1;\\n        } \\n        for (int i = 0; i < n; i++){\\n            if (S[i] == \\'I\\'){\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            } else {\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;   \\n            }\\n        }  \\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490123,
                "title": "c-dp-100-100",
                "content": "I highly doubt if this is a real interview question or merely from contest, which adopts ideas/techniques in some fields. \\n \\nThe main challege to apply DP is the state space is too large, if remembering which numbers have been assigned. This challenge can be overcomed by using ranking. For people with background in discrete and combinatorics math, the idea is rather common. \\n\\nAlso, this problem requires some modeling technique commonly seen in optimal control/operations research. Dynamic programming models typically requires defining state and actions associated with the state. One can solve a DP model as a sequence of action choosing problems for each state. Another way is to regard state and action pair as a whole, and solve the DP by searching for the next state-and-actoin. As for which approach to take, it depends on specific problems. For this question, the latter one is more straightforward. \\n\\nTherefore, it is not a fair problem and should not be used in real interview. \\n\\n```\\n    int numPermsDISequence(string S) {\\n        const int M = 1e9 + 7, n = S.length(); \\n        vector<int> curr(n + 1, 1), next(n + 1, 0);\\n        for (int t = 0; t < n; ++t) {\\n            char c = S[t]; \\n            int sum = 0; \\n            if (c == \\'D\\') {\\n                for (int i = n - t - 1; i >=0; --i) {\\n                    sum = (curr[i + 1]%M + sum%M)%M;\\n                    next[i] = sum; \\n                }\\n            } else {\\n                for (int i = 0; i < n - t; ++i) {\\n                    sum = (curr[i]%M + sum%M)%M; \\n                    next[i] = sum;  \\n                }\\n            }\\n            swap(curr, next); \\n        } \\n        return curr.front(); \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numPermsDISequence(string S) {\\n        const int M = 1e9 + 7, n = S.length(); \\n        vector<int> curr(n + 1, 1), next(n + 1, 0);\\n        for (int t = 0; t < n; ++t) {\\n            char c = S[t]; \\n            int sum = 0; \\n            if (c == \\'D\\') {\\n                for (int i = n - t - 1; i >=0; --i) {\\n                    sum = (curr[i + 1]%M + sum%M)%M;\\n                    next[i] = sum; \\n                }\\n            } else {\\n                for (int i = 0; i < n - t; ++i) {\\n                    sum = (curr[i]%M + sum%M)%M; \\n                    next[i] = sum;  \\n                }\\n            }\\n            swap(curr, next); \\n        } \\n        return curr.front(); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482430,
                "title": "java-dfs-with-memo",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\t\\tint MOD = (int)1e9 + 7;\\n\\t\\tpublic int numPermsDISequence(String s) {\\n\\t\\t\\tif (s == null || s.length() == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tSet<Integer> hashSet = new HashSet<>();\\n\\t\\t\\tfor (int i = 0; i <= s.length(); i++) {\\n\\t\\t\\t\\thashSet.add(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong result = helper(s, 0, hashSet, null, null, new boolean[s.length() + 1][s.length() + 1], new long[s.length() + 1][s.length() + 1]);\\n\\t\\t\\tSystem.out.println(result);\\n\\t\\t\\treturn (int)(result % MOD);\\n\\t\\t}\\n\\n\\t\\tpublic long helper(String s, int startIndex, Set<Integer> hashSet, Integer lastNumber, Integer relativeIndex, boolean[][] visited, long[][] dp) {\\n\\t\\t\\tif (startIndex == s.length() + 1) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (relativeIndex != null && visited[startIndex][relativeIndex]) {\\n\\t\\t\\t\\treturn dp[startIndex][relativeIndex];\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong result = 0;\\n\\t\\t\\tint index = -1;\\n\\t\\t\\tPriorityQueue<Integer> pQueue = new PriorityQueue<Integer>(hashSet); \\n\\t\\t\\tfor (int i : pQueue) {\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\tif (startIndex != 0 && ((s.charAt(startIndex - 1) == \\'D\\' && i > lastNumber) || \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(s.charAt(startIndex - 1) == \\'I\\' && i < lastNumber))) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thashSet.remove(i);\\n\\t\\t\\t\\tresult += helper(s, startIndex + 1, hashSet, i, index, visited, dp);\\n\\t\\t\\t\\tresult %= MOD;\\n\\t\\t\\t\\thashSet.add(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (relativeIndex != null) {\\n\\t\\t\\t\\tvisited[startIndex][relativeIndex] = true;\\n\\t\\t\\t\\tdp[startIndex][relativeIndex] = result;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\'\\'\\'\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint MOD = (int)1e9 + 7;\\n\\t\\tpublic int numPermsDISequence(String s) {\\n\\t\\t\\tif (s == null || s.length() == 0) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 257525,
                "title": "java-solution",
                "content": "```\\n    public int numPermsDISequence(String S) {\\n        int len = S.length(), N = len + 1, mod = 1000000007;\\n        int[][] dp = new int[N+1][N];\\n        \\n        for(int i = 0; i < N; i++) dp[1][i] = 1;\\n        \\n        for(int i = 1; i <= len; i++) {\\n            if(S.charAt(i-1) == \\'D\\') for(int j = N - i -1; j >= 0; j--) dp[i+1][j] = (dp[i+1][j+1] + dp[i][j+1])%mod;\\n            else  for(int j = 0; j <= N - i-1; j++) dp[i+1][j] = ((j > 0 ? dp[i+1][j-1] : 0) + dp[i][j])%mod;\\n        }\\n        \\n        return dp[N][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numPermsDISequence(String S) {\\n        int len = S.length(), N = len + 1, mod = 1000000007;\\n        int[][] dp = new int[N+1][N];\\n        \\n        for(int i = 0; i < N; i++) dp[1][i] = 1;\\n        \\n        for(int i = 1; i <= len; i++) {\\n            if(S.charAt(i-1) == \\'D\\') for(int j = N - i -1; j >= 0; j--) dp[i+1][j] = (dp[i+1][j+1] + dp[i][j+1])%mod;\\n            else  for(int j = 0; j <= N - i-1; j++) dp[i+1][j] = ((j > 0 ? dp[i+1][j-1] : 0) + dp[i][j])%mod;\\n        }\\n        \\n        return dp[N][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085333,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852423,
                "title": "editorial-like-solution-simple-to-understand-with-multiple-approaches-from-brute-force-to-optimal",
                "content": "The problem asks what is the number of valid permutations that follow a string of `\"DI\"` instructions, if a number `i` is used in a podition with `\\'D\\'` the next number must be in the range `0 <= j < i`, likewise if it\\'s in an `\\'I\\'` position the next number must be `i < j <= n` where `n` is the length if the string provided, the hard part comes in that we cannot repeat the same number, so it seems (but turns out not to be the case) that we need to remember all the previous numbers to solve the problem, let\\'s see how we might develop a solution.\\n\\n\\n# Approach #1: Brute-Force\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing that is recommended to be done in a complex problem like this one is to generate all possible solutions and discard the invalid ones, that can be done via backtracking, we define a helper function `backTrack` that keeps track of where in the string we are and what was the previous number used, and define a set `state` that contains all numbers previously used; at a given index position `i` we check for all numbers bigger/smaller than the previous number, if we can insert it into the permutation we add it to the stack, we we are done generating all it\\'s sub-solutions we remove it from the set, (this can also be done with a stack, which may be faster).\\nIf we reach `i == n` we finished generating a permutation and add `1` to our count (which I named `ans`).\\n\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a set/stack and a counter\\n2. Define the `backTrack` function:\\n2.1 If we reached the end, increase the counter\\n2.2 If not, go through all numbers lower/higher than the previous number and check if they can be added, if yes then add the number tot the set, call `backTrack` with `i+1` and this added number, when the function returns, remove the number from the set\\n3. Call `backTrack` for all possible starting number `0` to `n`\\n\\n# Complexity\\n- Time complexity: $$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAt any index `i` we have `i` options to choose from in worst-case, since `n` can go up to `200` this will result in a TLE.\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use a set/stack that will contain at most `n` numbers when a permutation is complete\\n\\n# Implementation (only python, sorry)\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        ans = [0]\\n        state = set()\\n        def backTrack(i, p):\\n            if i == n:\\n                ans[0] += 1\\n                return\\n            if s[i] == \"I\":\\n                for j in range(p+1, n+1):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            else:\\n                for j in range(0, p):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            return  \\n        for i in range(n+1):\\n            state.add(i)\\n            backTrack(0, i)\\n            state.remove(i)\\n        return ans[0]%(10**9+7)\\n```\\n\\n# Approach #2: Dynamic programming\\n\\n# Intuition\\nThe previous solution was too slow to be accepted, we need to find a faster way to calculate the answer. We first note that we got asked the number of valid permutations, so maybe (for this problem to be possible, we definitely) we don\\'t need to generate all possible permutations to know how many there are, usually we can break down a problem into sub-problems to generate an answer faster from solving sub-problems\\nAt first it may look like this is impossible to do here, since at each index the number we choose will affect all the possible choices in the future, but remembering we only need to know the quantity we may wonder if maybe the quantities are not dependent directly on the number you choose to place, let\\'s do a thought experiment, imagine instead of using the numbers `(1,2,3,4, ...)` to generate our permutatons we use `(1,1,1,1, ...)` only a bunch of ones, and when we use a number like `3` the whole thing turns into `(1,1,0,1, ...)` so we have a certain concept of \"order\" so that the problem is the same, now think about using `1` or `2` or `3`, in a given index `i` we would get accordingly `(0,1,1,1), (1,0,1,1), (1,1,0,1)` which are different, but look very similar! Why they all look so similar? because they all have the same idea of **relative ordering**, `1` is still smaller than `3` and `4` even when 2 is out of the equation and likewise for all the others, so if we only focus on the relative ordering of the numbers essentially all of the three sub-problems above are **identical**, so we can just represent them all as `(1,1,1)`.\\nThis is still not the complete picture, we know that the `\"ID\"` will limit our choice of next number, so returning to the last example, if the digit is `\\'I\\'`, then in the case of choosing `1` we would have `(0,1,1,1)` and the next number could be any of the following ones, but if we chose `2` the the sub-problem is `(1,0,1,1)` and we can only choose as the next number the ones to the right of the new zero, likewise if it were a `\\'D\\'` it would be the ones to the left of the zero, with that in mind we can now define our dynamic programming sub-problem.\\n\\n`\\ndp[i][j] = Solution to sub-problem s[i:n], if we can choose only ones bounded to the j\\'th one\\n`\\n\\nBy bounded I mean that if `s[i]` is `\\'I\\'` we can choose the ones from the `j` one to the right-end and if it is a `\\'D\\'` we can choose the ones from `j` one to the left-end.\\nFor example `dp[2][3]` for the tuple `(1,1,1,1,1,1,1)` is the solution to the sub-string `s[2:n]` using at position `2` any one that is from the inclusive left/right (depending on `s[2]`) of the highlighted one in `(1,1,_1_,1,1)`, notice that the size of the tuple is smaller by 2 than the original because we zero\\'ed two other ones in the original tuple, in general, if the original tuple is of size `n`, at index `i` the tuple will have size `n-i`.\\n\\nNow that we have a table, let\\'s see how we can generate answers from sub-problems. The base case is very simple, `s[n-1]` is either `\\'I\\'` or `\\'D\\'` and the tuple is simply `(1,1)`, we can define the base cases as follows:\\n```\\nif s[n-1] == \\'I\\':\\n    #If we choose 1, then it is impossible to increase\\n    dp[n-1][0] = 1\\n    dp[n-1][1] = 0\\nelif s[n-1] == \\'D:\\n    #If we choose 0, then it is impossible to decrease\\n    dp[n-1][0] = 0\\n    dp[n-1][1] = 1\\n```\\nThis idea of choosing the highest number or the lowest, makes it impossible to continue will keep re-occurring in later cases too.\\nFor an index `i < n-1` we know that if `s[i] == \\'I\\'` then the last number will have an answer of zero, if `s[i] == \\'D\\'` then the first number will have an answer of zero, in general `dp[i][j]\\n` will have all the answers that were pre-calculated in that row `i` (from the definition of the dp) and will also contain all the possible answers of the sub-problem at the `i+1` using only one to the left/right of it, which in our table happens that answer turns out to be stored in `dp[i+1][j]` (you can convince yourself of that by imagining how removing a one from a tuple changes the absolute postion of each remaining one), so our final update step looks like this.\\n\\n```\\nif s[n-1] == \\'I\\':\\n    if i == n-1:\\n        #If we choose 1, then it is impossible to increase\\n        dp[n-1][0] = 1\\n        dp[n-1][1] = 0\\n    else:\\n        if j == n-i:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j+1] + dp[i+1][j]\\nelif s[n-1] == \\'D:\\n    if i == n-1:\\n        #If we choose 0, then it is impossible to decrease\\n        dp[n-1][0] = 0\\n        dp[n-1][1] = 1\\n    else:\\n        if j == 0:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j-1] + dp[i+1][j]\\n```\\nPhew! That\\'s a pretty complicated update step, make sure you understand it, before writing it down because later on it will get worse! Now at last all that\\'s left to do is to write down the solution\\n\\n# Algorithm\\n1. Define our table `dp`\\n2. Go from the base case to the original case\\n3. Update the table according to the update step\\n4. return the `sum` of all possible start choices\\n\\n# Implementation (only python, sorry)\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[None for j in range(n-i+1)] for i in range(n)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[j][0] = 1\\n                    dp[j][1] = 0\\n                else:\\n                    dp[j][n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[j][i] = dp[j+1][i]+dp[j][i+1]\\n            else:\\n                if j == n-1:\\n                    dp[j][0] = 0\\n                    dp[j][1] = 1\\n                else:\\n                    dp[j][0] = 0\\n                    for i in range(1, n-j+1):\\n                        dp[j][i] = dp[j+1][i-1]+dp[j][i-1]\\n        return sum([dp[0][i] for i in range(n+1)])%(10**9+7)\\n```\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt only takes $O(1)$ to calculate the update step, we have `n + n-1 + n-2 + ... ` entries in the table, so $n^2$ time to compute every entry.\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe table has size $n^2$\\n\\n# Approach 3 DP + Double buffer\\n\\nWe notice that the update step only makes use of the last computed row and the current row being computed, so we can use two arrays and to calculate the whole ordeal, the space complexity will then be $O(n)$\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = None\\n        for j in range(n-1, 0-1, -1):\\n            ndp = [None for i in range(n-j+1)]\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    ndp[0] = 1\\n                    ndp[1] = 0\\n                else:\\n                    ndp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        ndp[i] = dp[i]+ndp[i+1]\\n            else:\\n                if j == n-1:\\n                    ndp[0] = 0\\n                    ndp[1] = 1\\n                else:\\n                    ndp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        ndp[i] = dp[i-1]+ndp[i-1]\\n            dp = ndp\\n        return sum(dp)%(10**9+7)\\n```\\n\\n# Approach 4 Optimized memory\\n\\nWe can make a solution with only one array, first notice that the update step of `\\'I\\'` is fairly easy to adapt to one array since the base case is in a completely new index, but in the `\\'D` case we need to update `i=0` so we set a variable `last` to remember the last value removed, but we need the last variable to update the next entry so we define an `nlast` to remember the variable that is about to be updated so that we can then update last with the  value that was before the update, whew... (see the code, it\\'s easier to understand)\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0 for _ in range(n+1)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[0] = 1\\n                    dp[1] = 0\\n                else:\\n                    dp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[i] = dp[i]+dp[i+1]\\n            else:\\n                if j == n-1:\\n                    dp[0] = 0\\n                    dp[1] = 1\\n                else:\\n                    last = dp[0]\\n                    dp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        nlast = dp[i]\\n                        dp[i] = last+dp[i-1]\\n                        last = nlast\\n        return sum(dp)%(10**9+7)\\n```\\n\\nAny comments or improvements are appreciated, thank you for reading!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        ans = [0]\\n        state = set()\\n        def backTrack(i, p):\\n            if i == n:\\n                ans[0] += 1\\n                return\\n            if s[i] == \"I\":\\n                for j in range(p+1, n+1):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            else:\\n                for j in range(0, p):\\n                    if j not in state:\\n                        state.add(j)\\n                        backTrack(i+1, j)\\n                        state.remove(j)\\n            return  \\n        for i in range(n+1):\\n            state.add(i)\\n            backTrack(0, i)\\n            state.remove(i)\\n        return ans[0]%(10**9+7)\\n```\n```\\nif s[n-1] == \\'I\\':\\n    #If we choose 1, then it is impossible to increase\\n    dp[n-1][0] = 1\\n    dp[n-1][1] = 0\\nelif s[n-1] == \\'D:\\n    #If we choose 0, then it is impossible to decrease\\n    dp[n-1][0] = 0\\n    dp[n-1][1] = 1\\n```\n```\\nif s[n-1] == \\'I\\':\\n    if i == n-1:\\n        #If we choose 1, then it is impossible to increase\\n        dp[n-1][0] = 1\\n        dp[n-1][1] = 0\\n    else:\\n        if j == n-i:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j+1] + dp[i+1][j]\\nelif s[n-1] == \\'D:\\n    if i == n-1:\\n        #If we choose 0, then it is impossible to decrease\\n        dp[n-1][0] = 0\\n        dp[n-1][1] = 1\\n    else:\\n        if j == 0:\\n            dp[i][j] = 0\\n        else:\\n            dp[i][j] = dp[i][j-1] + dp[i+1][j]\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [[None for j in range(n-i+1)] for i in range(n)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[j][0] = 1\\n                    dp[j][1] = 0\\n                else:\\n                    dp[j][n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[j][i] = dp[j+1][i]+dp[j][i+1]\\n            else:\\n                if j == n-1:\\n                    dp[j][0] = 0\\n                    dp[j][1] = 1\\n                else:\\n                    dp[j][0] = 0\\n                    for i in range(1, n-j+1):\\n                        dp[j][i] = dp[j+1][i-1]+dp[j][i-1]\\n        return sum([dp[0][i] for i in range(n+1)])%(10**9+7)\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = None\\n        for j in range(n-1, 0-1, -1):\\n            ndp = [None for i in range(n-j+1)]\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    ndp[0] = 1\\n                    ndp[1] = 0\\n                else:\\n                    ndp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        ndp[i] = dp[i]+ndp[i+1]\\n            else:\\n                if j == n-1:\\n                    ndp[0] = 0\\n                    ndp[1] = 1\\n                else:\\n                    ndp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        ndp[i] = dp[i-1]+ndp[i-1]\\n            dp = ndp\\n        return sum(dp)%(10**9+7)\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0 for _ in range(n+1)]\\n        for j in range(n-1, 0-1, -1):\\n            if s[j] == \"I\":\\n                if j == n-1:\\n                    dp[0] = 1\\n                    dp[1] = 0\\n                else:\\n                    dp[n-j] = 0\\n                    for i in range((n-j)-1, 0-1, -1):\\n                        dp[i] = dp[i]+dp[i+1]\\n            else:\\n                if j == n-1:\\n                    dp[0] = 0\\n                    dp[1] = 1\\n                else:\\n                    last = dp[0]\\n                    dp[0] = 0\\n                    for i in range(1, n-j+1):\\n                        nlast = dp[i]\\n                        dp[i] = last+dp[i-1]\\n                        last = nlast\\n        return sum(dp)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731618,
                "title": "simple-c-solution-dynamic-programming-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int prev,vector<int>&curr,vector<int>&visited,string &s,int &n,vector<vector<long long>>&dp){\\n    if(index>=s.length() && curr.size()==n+1)return 1;\\n    if(dp[index+1][prev+1]!=-1)return dp[index+1][prev+1];\\n    long long ans=0;\\n    if(index==-1){\\n        for(int i=0;i<=n;i++){\\n            curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n        }\\n    }\\n    else if(index!=-1){\\n        if(s[index]==\\'I\\'){\\n            int previous=prev;\\n            for(int i=previous+1;i<=n;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n        else if(s[index]==\\'D\\'){\\n            int previous=prev;\\n            for(int i=0;i<previous;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n    }\\n    return dp[index+1][prev+1]=ans%mod;\\n}\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n  vector<int>visited(s.length()+1,0);\\n  vector<int>curr;\\n  vector<vector<long long>>dp(202,vector<long long>(202,-1));\\n  long long fa=hope(-1,-1,curr,visited,s,n,dp)%mod;\\n  int answer=fa;\\n  return answer;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index,int prev,vector<int>&curr,vector<int>&visited,string &s,int &n,vector<vector<long long>>&dp){\\n    if(index>=s.length() && curr.size()==n+1)return 1;\\n    if(dp[index+1][prev+1]!=-1)return dp[index+1][prev+1];\\n    long long ans=0;\\n    if(index==-1){\\n        for(int i=0;i<=n;i++){\\n            curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n        }\\n    }\\n    else if(index!=-1){\\n        if(s[index]==\\'I\\'){\\n            int previous=prev;\\n            for(int i=previous+1;i<=n;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n        else if(s[index]==\\'D\\'){\\n            int previous=prev;\\n            for(int i=0;i<previous;i++){\\n                if(visited[i]!=-1){\\n                    curr.push_back(i);\\n            visited[i]=-1;\\n            ans=(ans%mod+hope(index+1,i,curr,visited,s,n,dp)%mod)%mod;\\n            curr.pop_back();\\n            visited[i]=0;\\n                }\\n            }\\n        }\\n    }\\n    return dp[index+1][prev+1]=ans%mod;\\n}\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n  vector<int>visited(s.length()+1,0);\\n  vector<int>curr;\\n  vector<vector<long long>>dp(202,vector<long long>(202,-1));\\n  long long fa=hope(-1,-1,curr,visited,s,n,dp)%mod;\\n  int answer=fa;\\n  return answer;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633737,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def numPermsDISequence(s: String): Int = {\\n      val n = s.length\\n      val dp = Array.ofDim[Int](n+2, 2)\\n      val mod = 1000000007\\n      dp(1)(0) = 1\\n      for (i <- 1 to n) \\n        if (s(i-1) == \\'I\\') for (j <- 0 to i) dp(j+1)(i%2) = (dp(j)((i+1)%2) + dp(j)(i%2)) % mod\\n        else for (j <- 0 to i) dp(j+1)(i%2) = ((dp(i)((i+1)%2) + mod - dp(j)((i+1)%2)) % mod + dp(j)(i%2)) % mod\\n      dp(n+1)(n%2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def numPermsDISequence(s: String): Int = {\\n      val n = s.length\\n      val dp = Array.ofDim[Int](n+2, 2)\\n      val mod = 1000000007\\n      dp(1)(0) = 1\\n      for (i <- 1 to n) \\n        if (s(i-1) == \\'I\\') for (j <- 0 to i) dp(j+1)(i%2) = (dp(j)((i+1)%2) + dp(j)(i%2)) % mod\\n        else for (j <- 0 to i) dp(j+1)(i%2) = ((dp(i)((i+1)%2) + mod - dp(j)((i+1)%2)) % mod + dp(j)(i%2)) % mod\\n      dp(n+1)(n%2)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3513915,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n        int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\"I\" + S, S):\\n            dp = list(accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```\\n\\n```Java []\\nclass Solution {\\n\\tpublic int numPermsDISequence(String s) {\\n\\t\\tint length = s.length();\\n\\t\\tint mod = 1000000007;\\n\\t\\tint[] dp1 = new int[length + 1];\\n\\t\\tint[] dp2 = new int[length];\\n\\t\\tfor (int j = 0; j <= length; j++) {\\n\\t\\t\\tdp1[j] = 1;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'I\\') {\\n\\t\\t\\t\\tfor (int j = 0, curr = 0; j < length - i; j++) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int j = length - i - 1, curr = 0; j >= 0; j--) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j + 1]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp1 = Arrays.copyOf(dp2, length);\\n\\t\\t}\\n\\t\\treturn dp1[0];\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n        int numPermsDISequence(string S) {\\n        int n = S.length(), mod = 1e9 + 7;\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S[i] == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n};\\n```\n```Python3 []\\nfrom itertools import accumulate\\n\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        dp = [1] * (len(S) + 1)\\n        for a, b in zip(\"I\" + S, S):\\n            dp = list(accumulate(dp[:-1] if a == b else dp[-1:0:-1]))\\n        return dp[0] % (10**9 + 7)\\n```\n```Java []\\nclass Solution {\\n\\tpublic int numPermsDISequence(String s) {\\n\\t\\tint length = s.length();\\n\\t\\tint mod = 1000000007;\\n\\t\\tint[] dp1 = new int[length + 1];\\n\\t\\tint[] dp2 = new int[length];\\n\\t\\tfor (int j = 0; j <= length; j++) {\\n\\t\\t\\tdp1[j] = 1;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'I\\') {\\n\\t\\t\\t\\tfor (int j = 0, curr = 0; j < length - i; j++) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int j = length - i - 1, curr = 0; j >= 0; j--) {\\n\\t\\t\\t\\t\\tdp2[j] = curr = (curr + dp1[j + 1]) % mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp1 = Arrays.copyOf(dp2, length);\\n\\t\\t}\\n\\t\\treturn dp1[0];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466073,
                "title": "c-3ms-dp-top-down-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1));\\n        for(int i=0;i<=n;i++){\\n            dp[0][i]=1+i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=n-i;j++){\\n                long long ans=0;\\n                if(s[i-1]==\\'I\\'){\\n                    ans=dp[i-1][n+1-i]-dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                else{\\n                    ans+=1LL*dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                if(j>0) ans+=dp[i][j-1];\\n                ans%=mod;\\n                dp[i][j]=ans;\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1));\\n        for(int i=0;i<=n;i++){\\n            dp[0][i]=1+i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<=n-i;j++){\\n                long long ans=0;\\n                if(s[i-1]==\\'I\\'){\\n                    ans=dp[i-1][n+1-i]-dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                else{\\n                    ans+=1LL*dp[i-1][j];\\n                    ans=(ans+mod)%mod;\\n                }\\n                if(j>0) ans+=dp[i][j-1];\\n                ans%=mod;\\n                dp[i][j]=ans;\\n            }\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455905,
                "title": "o-n-2-dp-with-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- dp[j] in the i-th round memorizes the number of permutations ends with j for s[0:i].\\n\\n- When s[i] is \\'D\\', update the ndp[j] with sum(dp[j:i]), which increases each element larger than j by one in the prefix.\\n- When s[i] is \\'I\\', update ndp[j] with sum(dp[0:j-1]) while keeping the prefix.\\n- Make use of the sum of prefix to get any sum(dp[j:i]) in $$O(1)$$\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int numPermsDISequence(string s) {\\n      int n=s.size(),mod=1e9+7;\\n      vector<int> dp{1};\\n      for(int i=0;i<n;i++){\\n          vector<int> pre{0}; //pre[i]=sum(dp[0:i-1])\\n          int tmp=0;\\n          for(auto j:dp) pre.emplace_back((j+pre.back())%mod);\\n          vector<int> ndp;\\n          if(s[i]==\\'D\\') for(int j=0;j<=i+1;j++) ndp.emplace_back(pre.back()>pre[j]?pre.back()-pre[j]:pre.back()-(pre[j]-mod)); //sum(dp[j,i])\\n          else for(int j=0;j<=i+1;j++) ndp.emplace_back(pre[j]); //sum(dp[0],...,dp[j-1])\\n          dp=ndp;\\n      }\\n      int result=0;\\n      for(auto i:dp)  result=(result+i)%mod;\\n      return result;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numPermsDISequence(string s) {\\n      int n=s.size(),mod=1e9+7;\\n      vector<int> dp{1};\\n      for(int i=0;i<n;i++){\\n          vector<int> pre{0}; //pre[i]=sum(dp[0:i-1])\\n          int tmp=0;\\n          for(auto j:dp) pre.emplace_back((j+pre.back())%mod);\\n          vector<int> ndp;\\n          if(s[i]==\\'D\\') for(int j=0;j<=i+1;j++) ndp.emplace_back(pre.back()>pre[j]?pre.back()-pre[j]:pre.back()-(pre[j]-mod)); //sum(dp[j,i])\\n          else for(int j=0;j<=i+1;j++) ndp.emplace_back(pre[j]); //sum(dp[0],...,dp[j-1])\\n          dp=ndp;\\n      }\\n      int result=0;\\n      for(auto i:dp)  result=(result+i)%mod;\\n      return result;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228861,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        n, mod = len(s), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,val):\\n            if i == n:\\n                return 1\\n\\n            if s[i] == \"D\":\\n                if val == 0: return 0\\n                return dfs(i,val-1) + dfs(i+1,val-1)\\n\\n            if s[i] == \"I\":\\n                if val == n-i: return 0\\n                return dfs(i,val+1) + dfs(i+1,val)\\n\\n        return sum([dfs(0,j) for j in range(n+1)])%mod\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        n, mod = len(s), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,val):\\n            if i == n:\\n                return 1\\n\\n            if s[i] == \"D\":\\n                if val == 0: return 0\\n                return dfs(i,val-1) + dfs(i+1,val-1)\\n\\n            if s[i] == \"I\":\\n                if val == n-i: return 0\\n                return dfs(i,val+1) + dfs(i+1,val)\\n\\n        return sum([dfs(0,j) for j in range(n+1)])%mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200100,
                "title": "c-easy-solution-using-dp-backtraking-optimal-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O($$N*N*N$$)\\n\\n- Space complexity:O($$N*N$$)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    //TC=O(N*N*N)\\n    //SC=O(N*N)\\n    int find(int ind,int pre,string& s,int n,vector<bool>& vis,vector<vector<int>>& dp){\\n        if(ind==n){\\n            return 1;\\n        }\\n        if(dp[ind][pre+1]!=-1){\\n            return dp[ind][pre+1];\\n        }\\n        int way1=0,way2=0;\\n        if(pre==-1){\\n            for(int i=0;i<=n;i++){\\n                if(!vis[i]){\\n                    vis[i]=true;\\n                    way1=(way1+find(ind,i,s,n,vis,dp))%mod;\\n                    vis[i]=false;\\n                }\\n            }\\n            return way1%mod;\\n        }\\n        else{\\n            if(s[ind]==\\'D\\'){\\n                for(int i=0;i<=n;i++){\\n                    if(i<pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                            way1=(way1+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n                }\\n            }else{\\n                for(int i=0;i<=n;i++){\\n                    if(i>pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                           \\n                            way2=(way2+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return dp[ind][pre+1]=(way1+way2)%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,false);\\n        return find(0,-1,s,n,vis,dp);\\n    }\\n};\\n```\\n# AUTHOR:JAYESH BADGUJAR\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    //TC=O(N*N*N)\\n    //SC=O(N*N)\\n    int find(int ind,int pre,string& s,int n,vector<bool>& vis,vector<vector<int>>& dp){\\n        if(ind==n){\\n            return 1;\\n        }\\n        if(dp[ind][pre+1]!=-1){\\n            return dp[ind][pre+1];\\n        }\\n        int way1=0,way2=0;\\n        if(pre==-1){\\n            for(int i=0;i<=n;i++){\\n                if(!vis[i]){\\n                    vis[i]=true;\\n                    way1=(way1+find(ind,i,s,n,vis,dp))%mod;\\n                    vis[i]=false;\\n                }\\n            }\\n            return way1%mod;\\n        }\\n        else{\\n            if(s[ind]==\\'D\\'){\\n                for(int i=0;i<=n;i++){\\n                    if(i<pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                            way1=(way1+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n                }\\n            }else{\\n                for(int i=0;i<=n;i++){\\n                    if(i>pre){\\n                        if(!vis[i]){\\n                            vis[i]=true;\\n                           \\n                            way2=(way2+find(ind+1,i,s,n,vis,dp))%mod;\\n                            vis[i]=false;\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return dp[ind][pre+1]=(way1+way2)%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+2,-1));\\n        vector<bool> vis(n+1,false);\\n        return find(0,-1,s,n,vis,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177930,
                "title": "scala-clean-functional-dp",
                "content": "Let `dp[i][j]` be the number of permutations that `s[i:]` could form with the first number be the `j`th smallest candidate number.\\n\\nThen if `s[i] == \\'D\\'`, because for `dp[i][j]` we already choose the `j`th smallest possible value, we can only choose the candidate numbers before `j` for the `i+1`th position. So `dp[i][j] = dp[i + 1][0] + dp[i + 1][1] + ... + dp[i + 1][j - 1]`.\\n\\nThe same logic applies to the case when `s[i] == \\'I`. We can choose the `j + 1`th, `j + 2`th... candidate value for position `i + 1`.  Note that because `j`th value is taken, the `j + 1`th value in `i`\\'s candidate numbers will be the `j`th value in `i+1`\\'s candidate numbers. So `dp[i][j] = dp[i + 1][j] + dp[i + 1][j + 1] + ...`.\\n\\nBecause `dp[i][]` only depends on `dp[i + 1][]`, we can eliminate the first dimension of dp states to save some memory.\\n```Scala\\nobject Solution {\\n  def numPermsDISequence(s: String): Int = {\\n    val mod = (1e9 + 7).toInt\\n    def add(x: Int, y: Int) = ((x + y) % mod + mod) % mod\\n\\n    s.reverse.foldLeft(Vector(1)) {\\n      case (dp, \\'D\\') => Vector.tabulate(dp.size + 1)(j => (0 until j).map(dp).fold(0)(add))\\n      case (dp, \\'I\\') => Vector.tabulate(dp.size + 1)(j => (j until dp.size).map(dp).fold(0)(add))\\n      case _ => null\\n    }.reduce(add)\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n  def numPermsDISequence(s: String): Int = {\\n    val mod = (1e9 + 7).toInt\\n    def add(x: Int, y: Int) = ((x + y) % mod + mod) % mod\\n\\n    s.reverse.foldLeft(Vector(1)) {\\n      case (dp, \\'D\\') => Vector.tabulate(dp.size + 1)(j => (0 until j).map(dp).fold(0)(add))\\n      case (dp, \\'I\\') => Vector.tabulate(dp.size + 1)(j => (j until dp.size).map(dp).fold(0)(add))\\n      case _ => null\\n    }.reduce(add)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3094901,
                "title": "easy-c-beginner-friendly-dp-backtracking-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[202][202];\\n    int mod = 1000000007;\\n    int recur(string &s, int i, int n,int idx){\\n        if(idx==n-1){\\n            return 1;\\n        }\\n        if(dp[idx][i]!=-1)\\n            return dp[idx][i];\\n        \\n        int res = 0;\\n        if(s[idx]==\\'D\\'){\\n            for(int j=i-1;j>=0;j--){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0; \\n            }\\n        }\\n        else{\\n            for(int j=i+1;j<n;j++){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0;\\n            }\\n        }\\n        return dp[idx][i] = res;\\n    }\\n\\n    int numPermsDISequence(string s) {\\n        int n = s.size()+1;\\n        vis.resize(n,0);\\n        for(int i=0;i<202;i++){\\n            for(int j=0;j<202;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            vis[i] = 1;\\n            ans = (ans + (recur(s,i,n,0))%mod)%mod;\\n            vis[i] = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    int dp[202][202];\\n    int mod = 1000000007;\\n    int recur(string &s, int i, int n,int idx){\\n        if(idx==n-1){\\n            return 1;\\n        }\\n        if(dp[idx][i]!=-1)\\n            return dp[idx][i];\\n        \\n        int res = 0;\\n        if(s[idx]==\\'D\\'){\\n            for(int j=i-1;j>=0;j--){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0; \\n            }\\n        }\\n        else{\\n            for(int j=i+1;j<n;j++){\\n                if(vis[j])  continue;\\n                vis[j] = 1;\\n                res = (res + (recur(s,j,n,idx+1))%mod)%mod;\\n                vis[j] = 0;\\n            }\\n        }\\n        return dp[idx][i] = res;\\n    }\\n\\n    int numPermsDISequence(string s) {\\n        int n = s.size()+1;\\n        vis.resize(n,0);\\n        for(int i=0;i<202;i++){\\n            for(int j=0;j<202;j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            vis[i] = 1;\\n            ans = (ans + (recur(s,i,n,0))%mod)%mod;\\n            vis[i] = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066316,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the number of permutations of a string of length n that satisfy the condition that the string only contains \\'I\\' and \\'D\\' and where \\'I\\' represents increasing and \\'D\\' represents decreasing.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use Dynamic Programming to solve this problem. We create a 2D array dp[n+1][n+1] where dp[i][j] represent the number of permutations of the first i characters that end with j \\'I\\'s.\\n\\nWe iterate through the string one character at a time, and for each character, we check if it is an \\'I\\' or a \\'D\\'. If it is an \\'I\\', we update dp[i][j] using dp[i-1][k] where k is from j to i-1. If it is a \\'D\\', we update dp[i][j] using dp[i-1][k] where k is from 0 to j-1.\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }\\n    }\\n    int ans = 0;\\n    for (int i = 0; i <= n; i++)\\n        ans = (ans + dp[n][i]) % mod;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numPermsDISequence(char * s){\\n    int n = strlen(s), mod = 1e9 + 7;\\n    int dp[n + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        for (int j = 0; j <= i; j++)\\n        {\\n            if (s[i - 1] == \\'D\\')\\n                for (int k = j; k < i; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n            else\\n                for (int k = 0; k < j; k++)\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;\\n        }\\n    }\\n    int ans = 0;\\n    for (int i = 0; i <= n; i++)\\n        ans = (ans + dp[n][i]) % mod;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3007576,
                "title": "detailed-comments-for-an-o-n-2-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int numPermsDISequence(string s) {\\n        int N = s.size() + 1;\\n        vector<vector<int>> dp(N, vector<int>(N));\\n        const int mod = 1e9 + 7;\\n\\n        // dp[i][j] : answers for length=i+1 (using number [0,1,..,i]) that ends with j (j <= i)\\n        for (int j = 0; j < N; j++) {\\n            dp[0][j] = 1;\\n        }\\n\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                // when we append j to the array, in order to avoid duplicate, by default, all the elements >= j in the previous array will automatically increment by one\\n                // e.g. [2, 1, 0] + [1] => [3, 2, 0, 1]\\n\\n                if (s[i-1] == \\'I\\') {\\n                    // dp[i][j] = dp[i-1][0] + dp[i-1][1] + .. dp[i-1][j-1]\\n                    dp[i][j] = j ? dp[i-1][j-1] : 0;\\n                } else {\\n                    // dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + .. dp[i-1][i-1]\\n                    dp[i][j] = dp[i-1][i-1] - (j ? dp[i-1][j-1] : 0);\\n                }\\n            }\\n\\n            // change dp[i][j] to prefix sum so that we can have O(N^2) overall complexity instead of O(N^3)\\n            for (int j = 1; j <= i; j++) {\\n                dp[i][j] += dp[i][j-1];\\n                dp[i][j] %= mod;\\n                if (dp[i][j] < 0) {\\n                    dp[i][j] += mod;\\n                }\\n            }\\n        }\\n\\n        return dp[N-1][N-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int numPermsDISequence(string s) {\\n        int N = s.size() + 1;\\n        vector<vector<int>> dp(N, vector<int>(N));\\n        const int mod = 1e9 + 7;\\n\\n        // dp[i][j] : answers for length=i+1 (using number [0,1,..,i]) that ends with j (j <= i)\\n        for (int j = 0; j < N; j++) {\\n            dp[0][j] = 1;\\n        }\\n\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                // when we append j to the array, in order to avoid duplicate, by default, all the elements >= j in the previous array will automatically increment by one\\n                // e.g. [2, 1, 0] + [1] => [3, 2, 0, 1]\\n\\n                if (s[i-1] == \\'I\\') {\\n                    // dp[i][j] = dp[i-1][0] + dp[i-1][1] + .. dp[i-1][j-1]\\n                    dp[i][j] = j ? dp[i-1][j-1] : 0;\\n                } else {\\n                    // dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + .. dp[i-1][i-1]\\n                    dp[i][j] = dp[i-1][i-1] - (j ? dp[i-1][j-1] : 0);\\n                }\\n            }\\n\\n            // change dp[i][j] to prefix sum so that we can have O(N^2) overall complexity instead of O(N^3)\\n            for (int j = 1; j <= i; j++) {\\n                dp[i][j] += dp[i][j-1];\\n                dp[i][j] %= mod;\\n                if (dp[i][j] < 0) {\\n                    dp[i][j] += mod;\\n                }\\n            }\\n        }\\n\\n        return dp[N-1][N-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990982,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_perms_di_sequence(s: String) -> i32 {\\n        let n = s.len();\\n        let m = 1_000_000_007;\\n        let mut dp = vec![vec![0; n + 1]; n + 1];\\n        dp[0][0] = 1;\\n        for i in 1..=n {\\n            for j in 0..=i {\\n                if s.chars().nth(i - 1).unwrap() == \\'D\\' {\\n                    for k in j..=i - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                } else if j > 0 {\\n                    for k in 0..=j - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                }\\n            }\\n        }\\n        let mut res = 0;\\n        for i in 0..=n {\\n            res = res % m + dp[n][i] % m;\\n        }\\n        (res % m) as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_perms_di_sequence(s: String) -> i32 {\\n        let n = s.len();\\n        let m = 1_000_000_007;\\n        let mut dp = vec![vec![0; n + 1]; n + 1];\\n        dp[0][0] = 1;\\n        for i in 1..=n {\\n            for j in 0..=i {\\n                if s.chars().nth(i - 1).unwrap() == \\'D\\' {\\n                    for k in j..=i - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                } else if j > 0 {\\n                    for k in 0..=j - 1 {\\n                        dp[i][j] = dp[i][j] % m + dp[i - 1][k] % m;\\n                    }\\n                }\\n            }\\n        }\\n        let mut res = 0;\\n        for i in 0..=n {\\n            res = res % m + dp[n][i] % m;\\n        }\\n        (res % m) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2918004,
                "title": "python3-top-down-dp-o-n-2",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n,ans = len(s),0\\n        mod = 1_00_00_00_000 + 7\\n        memo = [[-1] * 201 for i in range(201)]\\n        def dp(ind,prevNum):\\n            if ind < 0:\\n                return 1\\n            if memo[ind][prevNum] != -1:\\n                return memo[ind][prevNum]\\n            val = 0\\n            if s[ind] == \\'D\\':\\n                for more in range(prevNum+1,n+1):\\n                    if more not in vis:\\n                        vis.add(more)\\n                        val += dp(ind-1,more)\\n                        vis.remove(more)\\n            else:\\n                for less in range(prevNum):\\n                    if less not in vis:\\n                        vis.add(less)\\n                        val += dp(ind-1,less)\\n                        vis.remove(less)\\n            memo[ind][prevNum] = val\\n            return memo[ind][prevNum]\\n        for i in range(n+1):\\n            vis = set([i])\\n            ans += dp(n-1,i)\\n        return ans % mod\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        n,ans = len(s),0\\n        mod = 1_00_00_00_000 + 7\\n        memo = [[-1] * 201 for i in range(201)]\\n        def dp(ind,prevNum):\\n            if ind < 0:\\n                return 1\\n            if memo[ind][prevNum] != -1:\\n                return memo[ind][prevNum]\\n            val = 0\\n            if s[ind] == \\'D\\':\\n                for more in range(prevNum+1,n+1):\\n                    if more not in vis:\\n                        vis.add(more)\\n                        val += dp(ind-1,more)\\n                        vis.remove(more)\\n            else:\\n                for less in range(prevNum):\\n                    if less not in vis:\\n                        vis.add(less)\\n                        val += dp(ind-1,less)\\n                        vis.remove(less)\\n            memo[ind][prevNum] = val\\n            return memo[ind][prevNum]\\n        for i in range(n+1):\\n            vis = set([i])\\n            ans += dp(n-1,i)\\n        return ans % mod\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862039,
                "title": "python-backtracking-works-and-easy-to-understand",
                "content": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)\\n\\n    def backtrack(self, s):  # with pruning and memo\\n        L = len(s)\\n        nums = set(range(-1, L + 1))  # dummy -1 as \\'pre\\', only happens when idx == 0 (in which case we don\\'t need var \\'pre\\')\\n\\n        @lru_cache(None)\\n        def backtrack(idx, pre):  # current index\\n            nums.remove(pre)\\n\\n            cnt = 0\\n            if not nums:            cnt = 1  # empty, it\\'s a valid permutation\\n            elif idx == 0:          cnt = sum(backtrack(idx + 1, num) for num in range(L + 1))\\n            elif s[idx - 1] == \\'D\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre) if num in nums)\\n            elif s[idx - 1] == \\'I\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre + 1, L + 1) if num in nums)\\n\\n            nums.add(pre)  # recover\\n            return cnt\\n\\n        return backtrack(0, -1)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, s):\\n        return self.backtrack(s) % (10**9 + 7)\\n\\n    def backtrack(self, s):  # with pruning and memo\\n        L = len(s)\\n        nums = set(range(-1, L + 1))  # dummy -1 as \\'pre\\', only happens when idx == 0 (in which case we don\\'t need var \\'pre\\')\\n\\n        @lru_cache(None)\\n        def backtrack(idx, pre):  # current index\\n            nums.remove(pre)\\n\\n            cnt = 0\\n            if not nums:            cnt = 1  # empty, it\\'s a valid permutation\\n            elif idx == 0:          cnt = sum(backtrack(idx + 1, num) for num in range(L + 1))\\n            elif s[idx - 1] == \\'D\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre) if num in nums)\\n            elif s[idx - 1] == \\'I\\': cnt = sum(backtrack(idx + 1, num) for num in range(pre + 1, L + 1) if num in nums)\\n\\n            nums.add(pre)  # recover\\n            return cnt\\n\\n        return backtrack(0, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789671,
                "title": "c-backtracking-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visited[201];\\n    int mod = 1e9+7;\\n    map<pair<int,int>,int>mp;\\n    int solve(int idx , int last,string &s){\\n        //base case\\n        if(idx<0)return 1;\\n        \\n        if(mp.count({idx,last}))\\n            return mp[{idx,last}];\\n        int ans = 0 ;\\n        \\n        //hash means any number can be insertd at last position\\n        if(s[idx]==\\'#\\'){\\n            for(int i=0;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        \\n        if(s[idx]==\\'D\\'){\\n            for(int i=last+1;i<s.size();i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }            \\n        }\\n        \\n        if(s[idx]==\\'I\\'){\\n            for(int i=0;i<last;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans = (ans + solve(idx-1,i,s))%mod;\\n                    visited[i]=0;\\n                }\\n            }             \\n        }\\n        \\n        return mp[{idx,last}] = ans;\\n        \\n    }\\n    int numPermsDISequence(string s) {\\n        s.push_back(\\'#\\');\\n        int n=s.size();\\n        return solve(n-1,0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788203,
                "title": "js-solution-dp",
                "content": "```\\nvar numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numPermsDISequence = function(s) {\\n    let mod = 10**9+7,res = 0\\n    const dp = new Array(s.length+1).fill().map(()=>new Array)\\n    dp[0][0]=1\\n    for(i=1;i<s.length+1;i++) {\\n        if(s[i-1]===\\'D\\') {\\n            dp[i][i]=0\\n            for(j=i-1;j>=0;j--) {\\n                dp[i][j]=(dp[i][j+1]+dp[i-1][j])%mod\\n            }\\n        } else {\\n            dp[i][0]=0\\n            for(j=1;j<=i;j++) {\\n                dp[i][j]=(dp[i][j-1]+dp[i-1][j-1])%mod\\n            }\\n        }\\n    }\\n    dp[s.length].map((e)=>{res+=e%mod})\\n    return res%mod\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2465388,
                "title": "c-beginner-friendly-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int solve(string &s, int index, vector<bool> &vis, int last, vector<vector<int> > &dp){\\n        //if we reach the last index, there will be single element left we can do this in one way.\\n        if(index == s.size()){\\n            return 1;\\n        }\\n        \\n        if(dp[index][last] != -1) return dp[index][last];\\n        \\n        //when we need less than last one\\n        long long cnt = 0;\\n        if(s[index] == \\'D\\'){\\n            for(int i=0; i<last; i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        //when we need greater than last one\\n        else{\\n            for(int i=last+1; i<=s.size(); i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        return dp[index][last] = cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        vector<bool> vis(s.size()+1, false);\\n        vector<vector<int> > dp(s.size()+2, vector<int>(s.size()+2, -1));\\n        \\n        //start with any number at first position, then apply conditions in function\\n        long long cnt = 0;\\n        for(int i=0; i<=s.size(); i++){\\n            vis[i] = true;\\n            cnt+=(solve(s, 0, vis, i, dp))%mod;\\n            vis[i] = false;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int solve(string &s, int index, vector<bool> &vis, int last, vector<vector<int> > &dp){\\n        //if we reach the last index, there will be single element left we can do this in one way.\\n        if(index == s.size()){\\n            return 1;\\n        }\\n        \\n        if(dp[index][last] != -1) return dp[index][last];\\n        \\n        //when we need less than last one\\n        long long cnt = 0;\\n        if(s[index] == \\'D\\'){\\n            for(int i=0; i<last; i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        //when we need greater than last one\\n        else{\\n            for(int i=last+1; i<=s.size(); i++){\\n                if(vis[i]) continue;\\n                vis[i] = true;\\n                cnt+=(solve(s, index+1, vis, i, dp))%mod;\\n                vis[i] = false;\\n            }\\n        }\\n        \\n        return dp[index][last] = cnt%mod;\\n    }\\n    int numPermsDISequence(string s) {\\n        vector<bool> vis(s.size()+1, false);\\n        vector<vector<int> > dp(s.size()+2, vector<int>(s.size()+2, -1));\\n        \\n        //start with any number at first position, then apply conditions in function\\n        long long cnt = 0;\\n        for(int i=0; i<=s.size(); i++){\\n            vis[i] = true;\\n            cnt+=(solve(s, 0, vis, i, dp))%mod;\\n            vis[i] = false;\\n        }\\n        \\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450477,
                "title": "java-time-o-n-2-space-o-n-3ms-2ms-dp-n-1",
                "content": "```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n```\\nfrom dp[][] to dp[]\\n```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint mod = 1000000007;\\n\\tint[] dp = new int[n+1];\\n\\tdp[0] = 1;\\n\\tint c, sum,prev;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor(int j = 0; j<=i; j++){\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+dp[j])%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t} \\n\\t\\t} else {\\n\\t\\t\\tc = dp[i-1]+mod;\\n\\t\\t\\tsum = c%mod;\\n\\t\\t\\tfor(int j = 0; j<=i; j++) {\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+(c-dp[j])%mod)%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t }\\n\\t\\t} \\n\\t}\\n\\treturn dp[n]%mod;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint[][] dp = new int [n+2][2];\\n\\tint mod = 1000000007;\\n\\tdp[1][0] = 1;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=(dp[j][(i+1)&1] + dp[j][i&1])%mod;  \\n\\t\\t} else {\\n\\t\\t\\tfor(int j = 0; j<=i; j++) dp[j+1][i&1]=((dp[i][(i+1)&1] + mod - dp[j][(i+1)&1])%mod + dp[j][i&1])%mod;\\n\\t\\t} \\n\\t}\\n\\treturn dp[n+1][n&1];\\n}\\n```\n```\\npublic int numPermsDISequence(String s) {\\n\\tint n = s.length();\\n\\tint mod = 1000000007;\\n\\tint[] dp = new int[n+1];\\n\\tdp[0] = 1;\\n\\tint c, sum,prev;\\n\\tfor(int i = 1; i<=n; i++){\\n\\t\\tif(s.charAt(i-1)==\\'I\\') {\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tfor(int j = 0; j<=i; j++){\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+dp[j])%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t} \\n\\t\\t} else {\\n\\t\\t\\tc = dp[i-1]+mod;\\n\\t\\t\\tsum = c%mod;\\n\\t\\t\\tfor(int j = 0; j<=i; j++) {\\n\\t\\t\\t\\tprev = sum;\\n\\t\\t\\t\\tsum = (sum+(c-dp[j])%mod)%mod;\\n\\t\\t\\t\\tdp[j] = prev;    \\n\\t\\t\\t }\\n\\t\\t} \\n\\t}\\n\\treturn dp[n]%mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352796,
                "title": "python3-solution",
                "content": "Solution, requires a bit of observation\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        myStore = [1]\\n        \\n        for index, val in enumerate(s):\\n            if val == 0:\\n                continue\\n            temp = []\\n            for i in range(index + 2):\\n                if val == \"I\":\\n                    curr = sum(myStore[i:])\\n                else:\\n                    curr = sum(myStore[:i])\\n                temp.append(curr)\\n            myStore = temp\\n        return sum(myStore) % (10**9+7)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        myStore = [1]\\n        \\n        for index, val in enumerate(s):\\n            if val == 0:\\n                continue\\n            temp = []\\n            for i in range(index + 2):\\n                if val == \"I\":\\n                    curr = sum(myStore[i:])\\n                else:\\n                    curr = sum(myStore[:i])\\n                temp.append(curr)\\n            myStore = temp\\n        return sum(myStore) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349395,
                "title": "java-solution",
                "content": "class Solution {\\n    private static final int mod = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % mod + numPerms(s, 0, i) % mod;\\n            seen[i] = 0;\\n        }\\n        return count % mod;\\n    }\\n    private int numPerms(String s, int j, int p){\\n        if(j == s.length())\\n            return 1;\\n        if(dp[j][p] != null) return dp[j][p];\\n        char ch = s.charAt(j);\\n        int count = 0;\\n        if(ch == \\'D\\'){\\n            for(int i=p-1; i >= 0; i--){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % mod + numPerms(s, j+1, i)  % mod;\\n                seen[i] = 0;\\n            }\\n        }else{\\n            for(int i=p+1; i <= s.length(); i++){\\n                if(seen[i] == 1)\\n                    continue;\\n                seen[i] = 1;\\n                count = count % mod + numPerms(s, j+1, i) % mod;\\n                seen[i] = 0;\\n            }\\n        }\\n        dp[j][p] = count % mod;\\n        return dp[j][p];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    private static final int mod = 1000000007;\\n    int[] seen = null;\\n    Integer[][] dp = null;\\n    public int numPermsDISequence(String s) {\\n        dp = new Integer[s.length()][s.length()+1];\\n        seen = new int[s.length()+1];\\n        int count = 0;\\n        for(int i=0; i <= s.length(); i++) {\\n            seen[i] = 1;\\n        \\tcount = count % mod + numPerms(s, 0, i) % mod;\\n            seen[i] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2246352,
                "title": "anyone-can-modify-this-bfs-approach-with-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n        queue<pair<string,unordered_set<int>>> q;\\n        unordered_set<int> v;\\n        string str=\"\";\\n        for(int i=0;i<=n;++i)\\n        {\\n            str=\"\";\\n            v.clear();\\n            str+=(i+\\'0\\');\\n            v.insert(i);\\n            q.push({str,v});\\n        }\\n        int i=0;\\n        unordered_set<string> visall;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            if(i==n)\\n            {\\n                return q.size();\\n            }\\n            while(sz--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(visall.find(temp.first)!=visall.end())\\n                {\\n                    continue;\\n                }\\n                if(s[i]==\\'D\\')\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'-1;j>=0;--j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n            }\\n                else\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'+1;j<=n;++j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string s) {\\n        int n=s.length();\\n        queue<pair<string,unordered_set<int>>> q;\\n        unordered_set<int> v;\\n        string str=\"\";\\n        for(int i=0;i<=n;++i)\\n        {\\n            str=\"\";\\n            v.clear();\\n            str+=(i+\\'0\\');\\n            v.insert(i);\\n            q.push({str,v});\\n        }\\n        int i=0;\\n        unordered_set<string> visall;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            if(i==n)\\n            {\\n                return q.size();\\n            }\\n            while(sz--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                if(visall.find(temp.first)!=visall.end())\\n                {\\n                    continue;\\n                }\\n                if(s[i]==\\'D\\')\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'-1;j>=0;--j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n            }\\n                else\\n                {\\n                    for(int j=temp.first.back()-\\'0\\'+1;j<=n;++j)\\n                    {\\n                        if(temp.second.find(j)==temp.second.end())\\n                        {\\n                            temp.first+=(j+\\'0\\');\\n                            temp.second.insert(j);\\n                            if(visall.find(temp.first)==visall.end())\\n                            {\\n                                q.push({temp.first,temp.second});\\n                            }\\n                            temp.second.erase(j);\\n                            temp.first.pop_back();\\n                        }\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246128,
                "title": "c-easy",
                "content": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // unordered_set<int>st;\\n    int perm(int i, int prev, int n, string &s, vector<vector<int>>&dp, vector<bool>&vis)\\n    {\\n        //cout<<\"HERE\"<<i<<\"\\\\n\";\\n        if(i<0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][prev] != -1)\\n        {\\n            return dp[i][prev];\\n        }\\n        \\n        int ways = 0;\\n        \\n        if(i == n)\\n        {\\n            for(int j=0; j<=n;j++)\\n            {\\n                int x = j;\\n                vis[x] = true;\\n                //cout<<x<<\"\\\\n\";\\n                ways = (ways + perm(i-1, x, n, s, dp, vis))%mod;\\n                //cout<<ways<<\" \"<<x<<\"\\\\n\";\\n                vis[x] = false;\\n            }\\n        }\\n        else\\n        {\\n            if(s[i] == \\'D\\')\\n            {\\n                for(int j=0; j<=n; j++)\\n                {\\n                    if(vis[j] == true) continue;\\n                    int x = j;\\n                    if(prev < x)\\n                    {\\n                        vis[x] = true;\\n                        ways = (ways + perm(i-1, x,n, s, dp, vis))%mod;\\n                        vis[x] = false;\\n                    }\\n                    \\n                }\\n            }\\n            else\\n            {\\n                for(int j=0; j<=n; j++)\\n                {\\n                    if(vis[j] == true) continue;\\n                    int x = j;\\n                    if(prev > x)\\n                    {\\n                        vis[x] = true;\\n                        ways = (ways + perm(i-1, x,n, s, dp, vis))%mod;\\n                        vis[x] = false;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[i][prev] = ways;\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool>vis(s.size()+10, -1);\\n        for(int i=0; i<= s.size();i++)\\n        {\\n            vis[i] = false;\\n            //cout<<i<<\"\\\\n\";\\n        }\\n        vector<vector<int>>dp(s.size()+10, vector<int>(s.size()+10, -1));\\n        return perm(s.size(), s.size()+5, s.size(), s, dp, vis);\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    // unordered_set<int>st;\\n    int perm(int i, int prev, int n, string &s, vector<vector<int>>&dp, vector<bool>&vis)\\n    {\\n        //cout<<\"HERE\"<<i<<\"\\\\n\";\\n        if(i<0)\\n        {\\n            return 1;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2245996,
                "title": "easy-c-solution-dp-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201];\\n    int m = 1e9+7;\\n    int helper(string &s, int i, vector<bool> &visit, int start){\\n        if(i==s.length()){\\n            return 1;\\n        }\\n        \\n        if(dp[i][start]!=-1){\\n            return dp[i][start];\\n        }\\n        if(s[i]==\\'D\\'){\\n            int ans = 0;\\n            for(int j = 0;j < start;j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n        else{\\n            int ans = 0;\\n            for(int j = start+1;j <= s.length();j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool> visit(s.length()+1,false);\\n        int ans = 0;\\n             memset(dp,-1,sizeof(dp));\\n        for(int i = 0; i <= s.length();i++){\\n            visit[i]=true;\\n       \\n            ans = (ans%m + helper(s,0,visit,i)%m)%m;\\n            visit[i]=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[201][201];\\n    int m = 1e9+7;\\n    int helper(string &s, int i, vector<bool> &visit, int start){\\n        if(i==s.length()){\\n            return 1;\\n        }\\n        \\n        if(dp[i][start]!=-1){\\n            return dp[i][start];\\n        }\\n        if(s[i]==\\'D\\'){\\n            int ans = 0;\\n            for(int j = 0;j < start;j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n        else{\\n            int ans = 0;\\n            for(int j = start+1;j <= s.length();j++){\\n            \\n                if(visit[j]==false){\\n                    visit[j]=true;\\n                    ans = (ans%m + helper(s,i+1,visit,j)%m)%m;\\n                    visit[j]=false;\\n                }\\n            }\\n            return dp[i][start] = ans;\\n        }\\n    }\\n    \\n    \\n    int numPermsDISequence(string s) {\\n        vector<bool> visit(s.length()+1,false);\\n        int ans = 0;\\n             memset(dp,-1,sizeof(dp));\\n        for(int i = 0; i <= s.length();i++){\\n            visit[i]=true;\\n       \\n            ans = (ans%m + helper(s,0,visit,i)%m)%m;\\n            visit[i]=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245756,
                "title": "easy-c-solution",
                "content": "```\\nusing ll = long long;\\n\\nll dp[205][205];\\nconst ll mod = 1e9 + 7;\\nint n;\\n\\nll solve(int index, string &s, vector<int> &v, int piche)\\n{\\n    if (index >= s.size())\\n        return 1;\\n\\n    if (dp[index][piche] != -1)\\n        return dp[index][piche];\\n\\n    dp[index][piche] = 0;\\n\\n    if (s[index] == \\'D\\')\\n    {\\n        for (int i = 0; i < piche; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n    else\\n    {\\n        for (int i = piche + 1; i < n + 1; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n\\n    return dp[index][piche] %= mod;\\n\\n}\\n\\nclass Solution\\n{\\n    public:\\n        int numPermsDISequence(string s)\\n        {\\n            memset(dp, -1, sizeof(dp));\\n            n=s.size();\\n            \\n            if(n==1)\\n                return 1;\\n            \\n            vector<int>v(n+1,0);\\n            \\n            ll ans=0;\\n            \\n            for(int i=0;i<=n;++i)\\n            {\\n                v[i]=1;\\n                ans+=solve(0,s,v,i);\\n                ans%=mod;\\n                v[i]=0;\\n            }\\n            return ans;\\n            \\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nusing ll = long long;\\n\\nll dp[205][205];\\nconst ll mod = 1e9 + 7;\\nint n;\\n\\nll solve(int index, string &s, vector<int> &v, int piche)\\n{\\n    if (index >= s.size())\\n        return 1;\\n\\n    if (dp[index][piche] != -1)\\n        return dp[index][piche];\\n\\n    dp[index][piche] = 0;\\n\\n    if (s[index] == \\'D\\')\\n    {\\n        for (int i = 0; i < piche; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n    else\\n    {\\n        for (int i = piche + 1; i < n + 1; ++i)\\n        {\\n            if (v[i] == 0)\\n            {\\n                v[i] = 1;\\n                dp[index][piche] += solve(index + 1, s, v, i);\\n                dp[index][piche] %= mod;\\n                v[i] = 0;\\n            }\\n        }\\n    }\\n\\n    return dp[index][piche] %= mod;\\n\\n}\\n\\nclass Solution\\n{\\n    public:\\n        int numPermsDISequence(string s)\\n        {\\n            memset(dp, -1, sizeof(dp));\\n            n=s.size();\\n            \\n            if(n==1)\\n                return 1;\\n            \\n            vector<int>v(n+1,0);\\n            \\n            ll ans=0;\\n            \\n            for(int i=0;i<=n;++i)\\n            {\\n                v[i]=1;\\n                ans+=solve(0,s,v,i);\\n                ans%=mod;\\n                v[i]=0;\\n            }\\n            return ans;\\n            \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172627,
                "title": "c-solution",
                "content": "```\\n//This is based on a couple others..\\n//I take no credit other than the obvious refactoring.\\n//I deliberately chose the one that seemed easier to understand, not the fastest.\\n\\npublic class Solution \\n{\\n    //Number of Permutations Table - Using long to avoid a lot of mod operations.\\n    long [,] np;\\n    int MOD;\\n    \\n    public void GetNumPermutationsEndingIn(int len, int end, int endStart, int endStop)\\n    {\\n        for(int k = endStart; k <= endStop; k++)\\n        {\\n            np[len,end] += np[len-1,k];\\n        }\\n        //This is just trying to keep the value from overflowing..\\n        if (np[len,end] > 0xFFFFFFFFFFFF)\\n        {\\n            np[len,end] = np[len,end]%this.MOD;\\n        }\\n    }\\n    \\n    public int NumPermsDISequence(string S) {\\n        int n = S.Length;\\n        this.MOD = 1000000000 + 7;\\n        this.np = new long[n+1,n+1];\\n        this.np[0,0] = 1;\\n        for(int len = 1; len <= n; len++)\\n        {\\n            for(int end = 0; end <= len; end++)\\n            {\\n                if(S[len-1] == \\'D\\')\\n                {\\n                    //Here the transformation is to decrease.  This means the previous MUST be bigger than this one.\\n                    //The starting point is apparently end not end-1 here to also include the number of permutations frm the previous as a starting point. \\n                    //The next np[len,end] is np[len-1,end] + np[len-1,end+1]... + np[len-1,len-1]\\n                    GetNumPermutationsEndingIn(len,end,  end/*prev end start*/, len-1/*prev end stop*/);\\n                }\\n                else\\n                {\\n                    //The next np[len,end] is np[len-1,0] + np[len-1,1]... + np[len-1,end-1]\\n                    GetNumPermutationsEndingIn(len,end,  0/*prev end start*/  , end-1/*prev end stop*/);\\n                }\\n            }\\n        }\\n        \\n        //To get the complete the complete set a simple sum is required.\\n        long res = 0;\\n        for(int i = 0; i <= n; i++)\\n        {\\n            res += np[n,i];\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//This is based on a couple others..\\n//I take no credit other than the obvious refactoring.\\n//I deliberately chose the one that seemed easier to understand, not the fastest.\\n\\npublic class Solution \\n{\\n    //Number of Permutations Table - Using long to avoid a lot of mod operations.\\n    long [,] np;\\n    int MOD;\\n    \\n    public void GetNumPermutationsEndingIn(int len, int end, int endStart, int endStop)\\n    {\\n        for(int k = endStart; k <= endStop; k++)\\n        {\\n            np[len,end] += np[len-1,k];\\n        }\\n        //This is just trying to keep the value from overflowing..\\n        if (np[len,end] > 0xFFFFFFFFFFFF)\\n        {\\n            np[len,end] = np[len,end]%this.MOD;\\n        }\\n    }\\n    \\n    public int NumPermsDISequence(string S) {\\n        int n = S.Length;\\n        this.MOD = 1000000000 + 7;\\n        this.np = new long[n+1,n+1];\\n        this.np[0,0] = 1;\\n        for(int len = 1; len <= n; len++)\\n        {\\n            for(int end = 0; end <= len; end++)\\n            {\\n                if(S[len-1] == \\'D\\')\\n                {\\n                    //Here the transformation is to decrease.  This means the previous MUST be bigger than this one.\\n                    //The starting point is apparently end not end-1 here to also include the number of permutations frm the previous as a starting point. \\n                    //The next np[len,end] is np[len-1,end] + np[len-1,end+1]... + np[len-1,len-1]\\n                    GetNumPermutationsEndingIn(len,end,  end/*prev end start*/, len-1/*prev end stop*/);\\n                }\\n                else\\n                {\\n                    //The next np[len,end] is np[len-1,0] + np[len-1,1]... + np[len-1,end-1]\\n                    GetNumPermutationsEndingIn(len,end,  0/*prev end start*/  , end-1/*prev end stop*/);\\n                }\\n            }\\n        }\\n        \\n        //To get the complete the complete set a simple sum is required.\\n        long res = 0;\\n        for(int i = 0; i <= n; i++)\\n        {\\n            res += np[n,i];\\n        }\\n        return (int)(res%MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053711,
                "title": "first-javascript-solution",
                "content": "```\\nfunction numPermsDISequence(s) {\\n    let mod = 1e9 + 7, dp = [[1], []], res = 0\\n\\n    for (let i = 1; i <= S.length; i++) {\\n        for (let j = 0; j <= i; j++) {\\n            let l = 0,  r = j\\n            if (s.charAt(i-1) === \\'D\\') {\\n                l = j, r = i\\n            }\\n            dp[1][j] = 0\\n            for (let k = l; k < r; k++) {\\n                dp[1][j] += dp[0][k]\\n                dp[1][j] %= mod\\n            }\\n        }\\n        [dp[0], dp[1]] = [dp[1], dp[0]]\\n    }\\n\\n    for (let cnt of dp.shift()) {\\n        res += cnt\\n        res %= mod\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction numPermsDISequence(s) {\\n    let mod = 1e9 + 7, dp = [[1], []], res = 0\\n\\n    for (let i = 1; i <= S.length; i++) {\\n        for (let j = 0; j <= i; j++) {\\n            let l = 0,  r = j\\n            if (s.charAt(i-1) === \\'D\\') {\\n                l = j, r = i\\n            }\\n            dp[1][j] = 0\\n            for (let k = l; k < r; k++) {\\n                dp[1][j] += dp[0][k]\\n                dp[1][j] %= mod\\n            }\\n        }\\n        [dp[0], dp[1]] = [dp[1], dp[0]]\\n    }\\n\\n    for (let cnt of dp.shift()) {\\n        res += cnt\\n        res %= mod\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053260,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int n,mod=1000000000+7;\\n    vector<vector<int>>mem;\\n    int solve(string &s,int index,int prev,vector<bool>&seen){\\n        if(index==n){\\n            return 1;\\n        } else if(mem[index][prev]!=-1){\\n            return mem[index][prev];\\n        } else {\\n            int ans=0;\\n            if(s[index]==\\'D\\'){\\n                for(int i=0;i<prev;i++){\\n                    if(!seen[i]){\\n                        seen[i]=true;\\n                        ans=(ans%mod+solve(s,index+1,i,seen)%mod)%mod;\\n                        seen[i]=false;\\n                    }\\n                }\\n            } else {\\n                for(int i=prev+1;i<=n;i++){\\n                    if(!seen[i]){\\n                        seen[i]=true;\\n                        ans=(ans%mod+solve(s,index+1,i,seen)%mod)%mod;\\n                        seen[i]=false;\\n                    }\\n                }\\n            }\\n            return mem[index][prev]=ans;\\n        }\\n    }\\npublic:\\n    int numPermsDISequence(string &s) {\\n        n=s.size();\\n        int ans=0;\\n        mem=vector<vector<int>>(n+1,vector<int>(n+1,-1));\\n        vector<bool>seen(n+1,false);\\n        for(int i=0;i<=n;i++){\\n            seen[i]=true;\\n            ans=(ans%mod+solve(s,0,i,seen)%mod)%mod;\\n            seen[i]=false;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    int n,mod=1000000000+7;\\n    vector<vector<int>>mem;\\n    int solve(string &s,int index,int prev,vector<bool>&seen){\\n        if(index==n){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1854816,
                "title": "python-solution-easy-explained-dp-well-writtten-code",
                "content": "Try putting Value at the position keeping in mind that the current value should be increasing or decreasing \\nTo check this check s[pos - 1] \\nNow since we cannot repeat any digit we should use a dictionary to keep in check what value we used so far .\\n\\nOnce you find the no. of answer having index  = i and last item = x , put it on dp\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def recursion(self,idx,s,prev,limit,val,used):\\n        if idx == limit + 1:\\n            return 1\\n        if (idx,prev) in self.dp:return self.dp[(idx,prev)]\\n        start = 0 if s[idx-1] == \\'D\\' else prev + 1\\n        end = prev -1 if s[idx-1] == \\'D\\' else limit\\n        ans = 0\\n        for i in range(start,end+1):\\n            if i in used and used[i]==True:continue\\n            used[i] = True\\n            ans+=self.recursion(idx+1,s,i,limit,val+str(i),used)\\n            used[i] = False\\n        self.dp[(idx,prev)]=ans\\n        return ans\\n    def numPermsDISequence(self, s: str) -> int:\\n        limit = len(s)\\n        ans = 0\\n        self.dp = {}\\n        for i in range(limit+1):\\n            ans+= self.recursion(1,s,i,limit,str(i),{i:True})\\n        return ans%1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def recursion(self,idx,s,prev,limit,val,used):\\n        if idx == limit + 1:\\n            return 1\\n        if (idx,prev) in self.dp:return self.dp[(idx,prev)]\\n        start = 0 if s[idx-1] == \\'D\\' else prev + 1\\n        end = prev -1 if s[idx-1] == \\'D\\' else limit\\n        ans = 0\\n        for i in range(start,end+1):\\n            if i in used and used[i]==True:continue\\n            used[i] = True\\n            ans+=self.recursion(idx+1,s,i,limit,val+str(i),used)\\n            used[i] = False\\n        self.dp[(idx,prev)]=ans\\n        return ans\\n    def numPermsDISequence(self, s: str) -> int:\\n        limit = len(s)\\n        ans = 0\\n        self.dp = {}\\n        for i in range(limit+1):\\n            ans+= self.recursion(1,s,i,limit,str(i),{i:True})\\n        return ans%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851457,
                "title": "memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[203][203];\\n    int mod=1e9+7;\\n    int solve(int index , string& s, vector<int> & visited , int prev){\\n        if(index==s.size()) return 1;\\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        int n=s.size();\\n        long long temp=0;\\n        if(s[index]==\\'D\\'){\\n            //0 to prev-1\\n            for(int i=0;i<=prev-1;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n\\n                    visited[i]=0;\\n                }\\n            }\\n        }else {\\n            //prev+1 to n\\n            for(int i=prev+1;i<=n;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=temp;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        int n=s.size();\\n        vector<int> visited(n+1,0);\\n        int count=0;\\n        for(int i=0;i<=n;i++){\\n            visited[i]=1;\\n            count= (count%mod+(long long)solve(0,s,visited,i)%mod)%mod;\\n            visited[i]=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[203][203];\\n    int mod=1e9+7;\\n    int solve(int index , string& s, vector<int> & visited , int prev){\\n        if(index==s.size()) return 1;\\n        if(dp[index][prev]!=-1) return dp[index][prev];\\n        int n=s.size();\\n        long long temp=0;\\n        if(s[index]==\\'D\\'){\\n            //0 to prev-1\\n            for(int i=0;i<=prev-1;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n\\n                    visited[i]=0;\\n                }\\n            }\\n        }else {\\n            //prev+1 to n\\n            for(int i=prev+1;i<=n;i++){\\n                if(visited[i]==0){\\n                    visited[i]=1;\\n                    temp=(temp%mod+(long long)solve(index+1,s,visited,i)%mod)%mod;\\n                    visited[i]=0;\\n                }\\n            }\\n        }\\n        return dp[index][prev]=temp;\\n    }\\n    int numPermsDISequence(string s) {\\n        memset(dp,-1,sizeof dp);\\n        int n=s.size();\\n        vector<int> visited(n+1,0);\\n        int count=0;\\n        for(int i=0;i<=n;i++){\\n            visited[i]=1;\\n            count= (count%mod+(long long)solve(0,s,visited,i)%mod)%mod;\\n            visited[i]=0;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307997,
                "title": "compiling-both-o-n-2-approaches",
                "content": "The first approach is based on [this](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)) post by lee215.\\n\\nIn both the cases we are avoiding looping through the values already looped through by the previous element by just using the previous values to make it O(n^2) instead of O(n^3).\\n```\\n// Runtime: 4ms\\nvoid firstApproach(string& s, int n, vvi&dp) {\\n        for (int i =0;i<=n;i++) dp[0][i] = 1;\\n        for (int i = 1;i<=n;i++) {\\n            if (s[i-1] == \\'I\\') {\\n                dp[i][0] = dp[i-1][0];\\n                for (int j=1;j<=n-i;j++) {\\n                    dp[i][j] = (dp[i][j-1] + dp[i-1][j])%mod; // summing dp[i-1][0..j]\\n                }\\n            } else {\\n                dp[i][n-i] = dp[i-1][n-i+1];\\n                for (int j=n-i-1;j>=0;j--) {\\n                    dp[i][j] = (dp[i][j+1] + dp[i-1][j+1])%mod; // summing dp[i-1][j+1...n-i+1]\\n                }\\n            }\\n        }\\n    }\\n```\\n\\n\\nThe second approach is based on the intuitions by wxd_sjtu [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation), another great explanation by ariawynn [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/186571/Python-O(N3)O(N2)-time-O(N)-space-DP-solution-with-clear-explanation-(no-%22relative-rank%22-stuff)).\\nA great visualisation for this approach is also provided by quadpixels [here](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/169126/Visualization-Key-to-the-DP-solution:-imagine-cutting-a-piece-of-paper-and-separating-the-halves)\\n\\n```\\n// Runtime: 4ms\\nvoid secondApproach(string& s, int n, vvi&dp) {\\n       for (int i=0;i<=n;i++) dp[0][i] = 1;\\n       for (int i = 1;i<=n;i++) {\\n           if (s[i-1] == \\'I\\') {\\n              dp[i][1] = dp[i-1][0];\\n               for (int j = 2;j<=i;j++) {\\n                   dp[i][j] = (dp[i][j-1] + dp[i-1][j-1])%mod; // summing dp[i-1][0...j-1]\\n               } \\n           } else {\\n               dp[i][i-1] = dp[i-1][i-1];\\n               for (int j = i-2;j>=0;j--) {\\n                   dp[i][j] = (dp[i][j+1] + dp[i-1][j])%mod; // summing dp[i-1][j...i-1]\\n               }\\n           }\\n       }\\n   }\\n```\\n\\nBoilerplate:\\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\nint mod = 1e9+7;\\nint numPermsDISequence(string& s) {\\n\\tint n = s.size();\\n\\tvvi dp = vvi(n+1, vi(n+1,0));\\n\\tfirstApproach(s, n, dp);\\n\\t//secondApproach(s, n, dp);\\n\\tint ans =0;\\n\\tfor (int i: dp[n]) ans = (ans + i)%mod;\\n\\treturn ans;\\n}\\n```\\n\\nJust a compilation, kudos to the original posters.\\n",
                "solutionTags": [],
                "code": "```\\n// Runtime: 4ms\\nvoid firstApproach(string& s, int n, vvi&dp) {\\n        for (int i =0;i<=n;i++) dp[0][i] = 1;\\n        for (int i = 1;i<=n;i++) {\\n            if (s[i-1] == \\'I\\') {\\n                dp[i][0] = dp[i-1][0];\\n                for (int j=1;j<=n-i;j++) {\\n                    dp[i][j] = (dp[i][j-1] + dp[i-1][j])%mod; // summing dp[i-1][0..j]\\n                }\\n            } else {\\n                dp[i][n-i] = dp[i-1][n-i+1];\\n                for (int j=n-i-1;j>=0;j--) {\\n                    dp[i][j] = (dp[i][j+1] + dp[i-1][j+1])%mod; // summing dp[i-1][j+1...n-i+1]\\n                }\\n            }\\n        }\\n    }\\n```\n```\\n// Runtime: 4ms\\nvoid secondApproach(string& s, int n, vvi&dp) {\\n       for (int i=0;i<=n;i++) dp[0][i] = 1;\\n       for (int i = 1;i<=n;i++) {\\n           if (s[i-1] == \\'I\\') {\\n              dp[i][1] = dp[i-1][0];\\n               for (int j = 2;j<=i;j++) {\\n                   dp[i][j] = (dp[i][j-1] + dp[i-1][j-1])%mod; // summing dp[i-1][0...j-1]\\n               } \\n           } else {\\n               dp[i][i-1] = dp[i-1][i-1];\\n               for (int j = i-2;j>=0;j--) {\\n                   dp[i][j] = (dp[i][j+1] + dp[i-1][j])%mod; // summing dp[i-1][j...i-1]\\n               }\\n           }\\n       }\\n   }\\n```\n```\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\nint mod = 1e9+7;\\nint numPermsDISequence(string& s) {\\n\\tint n = s.size();\\n\\tvvi dp = vvi(n+1, vi(n+1,0));\\n\\tfirstApproach(s, n, dp);\\n\\t//secondApproach(s, n, dp);\\n\\tint ans =0;\\n\\tfor (int i: dp[n]) ans = (ans + i)%mod;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1239404,
                "title": "c-easy",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    int mod = 1e9 + 7;\\n    map<pair<int,int>,int>dp;\\n    int countways(int id,int prev,vector<bool>&taken){\\n\\n        if(id==n+1){\\n            return 1;\\n        }\\n        if(dp.find({id,prev})!=dp.end()) return dp[{id,prev}];\\n        int ans = 0;\\n        if(s[id-1]==\\'D\\'){\\n            for(int i = 0;i<=prev;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        else{\\n            for(int i = prev+1;i<=n;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        return dp[{id,prev}] = ans%mod;\\n    }\\n    int numPermsDISequence(string _s) {\\n        s = _s;\\n        n = s.size();\\n        vector<bool>taken(n+1,false);\\n        int ans = 0;\\n        for(int i = 0;i<=n;i++){\\n            taken[i] = true;\\n            ans+=countways(1,i,taken)%mod;\\n            ans%=mod;\\n            taken[i] = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    string s;\\n    int mod = 1e9 + 7;\\n    map<pair<int,int>,int>dp;\\n    int countways(int id,int prev,vector<bool>&taken){\\n\\n        if(id==n+1){\\n            return 1;\\n        }\\n        if(dp.find({id,prev})!=dp.end()) return dp[{id,prev}];\\n        int ans = 0;\\n        if(s[id-1]==\\'D\\'){\\n            for(int i = 0;i<=prev;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        else{\\n            for(int i = prev+1;i<=n;i++){\\n                if(taken[i]==true) continue;\\n                taken[i] = true;\\n                ans+=countways(id+1,i,taken)%mod;\\n                ans%=mod;\\n                taken[i] = false;\\n            }\\n        }\\n        return dp[{id,prev}] = ans%mod;\\n    }\\n    int numPermsDISequence(string _s) {\\n        s = _s;\\n        n = s.size();\\n        vector<bool>taken(n+1,false);\\n        int ans = 0;\\n        for(int i = 0;i<=n;i++){\\n            taken[i] = true;\\n            ans+=countways(1,i,taken)%mod;\\n            ans%=mod;\\n            taken[i] = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210448,
                "title": "java-dp-o-n-3",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    Map<Integer, Integer> cache;\\n    public int numPermsDISequence(String s) {\\n        cache = new HashMap<>();\\n        return dpRec(s, 0, 0, s.length(), new boolean[s.length()+1]);\\n    }\\n    private int dpRec(String s, int i, int x, int y, boolean[] vis) {\\n        if(i == s.length()){\\n            int j;\\n            for(j = x; j <= y; j++) if(vis[j] == false) break;\\n            return (j <= y) ? 1 : 0;\\n        } \\n        int key = i*40000 + x*200 + y;\\n        if(cache.containsKey(key)) return cache.get(key);\\n        int count = 0;\\n        for(int j = x; j <= y; j++) {\\n            if(vis[j] == false) {\\n                vis[j] = true;\\n                count += (s.charAt(i) == \\'D\\') ? dpRec(s, i+1, 0, j-1, vis) : dpRec(s, i+1, j+1, s.length(), vis);\\n                count = count%MOD;\\n                vis[j] = false;\\n            }\\n        }\\n        cache.put(key, count);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    Map<Integer, Integer> cache;\\n    public int numPermsDISequence(String s) {\\n        cache = new HashMap<>();\\n        return dpRec(s, 0, 0, s.length(), new boolean[s.length()+1]);\\n    }\\n    private int dpRec(String s, int i, int x, int y, boolean[] vis) {\\n        if(i == s.length()){\\n            int j;\\n            for(j = x; j <= y; j++) if(vis[j] == false) break;\\n            return (j <= y) ? 1 : 0;\\n        } \\n        int key = i*40000 + x*200 + y;\\n        if(cache.containsKey(key)) return cache.get(key);\\n        int count = 0;\\n        for(int j = x; j <= y; j++) {\\n            if(vis[j] == false) {\\n                vis[j] = true;\\n                count += (s.charAt(i) == \\'D\\') ? dpRec(s, i+1, 0, j-1, vis) : dpRec(s, i+1, j+1, s.length(), vis);\\n                count = count%MOD;\\n                vis[j] = false;\\n            }\\n        }\\n        cache.put(key, count);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181145,
                "title": "java-bottom-up-solution-dp",
                "content": "Let\\'s define our dp first:\\ndp[i][j]=permutations with lenght i with last digit j. The trick is that when you are iterating from i=1 to i=n, you select different j from 0 to i. Then, for each one of those j, you need to sum the relevant DPs. If S.charAt(i-1)=\\'I\\', then the prev digit should have been less than the current. So, we use the left half (0,j-1). If it is \\'D\\', then the prev digit should have been greater than the current one. So, we use (j,i-1). At the end, we sum up the last row dp[n][...] which means all the permuations with length n ending in different digits. Since the result might be big, be careful of the required mods.\\n```\\n   public int numPermsDISequence(String S) {\\n        int mod = 1_000_000_007;\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) { // We start from 1 to\\n            char c = S.charAt(i - 1);\\n            for (int j = 0; j <= i; j++) { // curr: dp[i][...] prev dp[i-1][...]\\n                long sum = 0;\\n                if (c == \\'I\\') { // Increasing- the prev digit was less than the current->use prev(0,j-1)\\n                    for (int k = 0; k <= j - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                } else { // c==\\'D\\'- Decreasing- the prev digit was greater than the current->use prev(j,i-1)\\n                    for (int k = j; k <= i - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                }\\n                dp[i][j] = sum;\\n            }\\n        }\\n        Long res = 0L; // Sum the last row- dp[n][...]\\n        for (int i = 0; i <= n; i++) res = (res + dp[n][i]) % mod;\\n        res = res % mod;\\n        return res.intValue();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int numPermsDISequence(String S) {\\n        int mod = 1_000_000_007;\\n        int n = S.length();\\n        long[][] dp = new long[n + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) { // We start from 1 to\\n            char c = S.charAt(i - 1);\\n            for (int j = 0; j <= i; j++) { // curr: dp[i][...] prev dp[i-1][...]\\n                long sum = 0;\\n                if (c == \\'I\\') { // Increasing- the prev digit was less than the current->use prev(0,j-1)\\n                    for (int k = 0; k <= j - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                } else { // c==\\'D\\'- Decreasing- the prev digit was greater than the current->use prev(j,i-1)\\n                    for (int k = j; k <= i - 1; k++) sum = (sum + dp[i - 1][k]) % mod;\\n                }\\n                dp[i][j] = sum;\\n            }\\n        }\\n        Long res = 0L; // Sum the last row- dp[n][...]\\n        for (int i = 0; i <= n; i++) res = (res + dp[n][i]) % mod;\\n        res = res % mod;\\n        return res.intValue();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119442,
                "title": "python3-top-down-dp",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        n = len(S) + 1\\n        @lru_cache(maxsize = 40000)\\n        def dfs(lastPos, pos):\\n            total = 0\\n            if pos == 0:\\n                for i in range(n):\\n                    total += dfs(i, pos + 1)\\n                return total%1000000007\\n            letter = S[pos - 1]\\n            if pos == len(S):\\n                if letter == \\'I\\':\\n                    return 1 - lastPos\\n                else:\\n                    return lastPos\\n            else:\\n                if letter == \\'I\\':\\n                    for i in range(lastPos, n-pos):\\n                        total += dfs(i, pos + 1)\\n                else:\\n                    for i in range(lastPos):\\n                        total += dfs(i, pos + 1)\\n                        \\n                return total%1000000007\\n            \\n        return dfs(0,0)%1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        n = len(S) + 1\\n        @lru_cache(maxsize = 40000)\\n        def dfs(lastPos, pos):\\n            total = 0\\n            if pos == 0:\\n                for i in range(n):\\n                    total += dfs(i, pos + 1)\\n                return total%1000000007\\n            letter = S[pos - 1]\\n            if pos == len(S):\\n                if letter == \\'I\\':\\n                    return 1 - lastPos\\n                else:\\n                    return lastPos\\n            else:\\n                if letter == \\'I\\':\\n                    for i in range(lastPos, n-pos):\\n                        total += dfs(i, pos + 1)\\n                else:\\n                    for i in range(lastPos):\\n                        total += dfs(i, pos + 1)\\n                        \\n                return total%1000000007\\n            \\n        return dfs(0,0)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115156,
                "title": "java",
                "content": "```\\npublic int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numPermsDISequence(String S) {\\n        int n = S.length(), mod = (int)1e9 + 7;\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int j = 0; j <= n; j++) dp[0][j] = 1;\\n        for (int i = 0; i < n; i++)\\n            if (S.charAt(i) == \\'I\\')\\n                for (int j = 0, cur = 0; j < n - i; j++)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j]) % mod;\\n            else\\n                for (int j = n - i - 1, cur = 0; j >= 0; j--)\\n                    dp[i + 1][j] = cur = (cur + dp[i][j + 1]) % mod;\\n        return dp[n][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976437,
                "title": "c-dp-o-n-3",
                "content": "```\\n///v2[i][j] stores value of i!/((i-j)!*j!) \\n///v1[i][j] stores permutations for DI seq from j to j+i-1 \\n#define ll long long\\nclass Solution {\\npublic:\\n    ll p = 1e9+7;\\n    int numPermsDISequence(string s){\\n        ll n = s.size();\\n        vector < vector < ll > > v1( n+1 , vector<ll> ( n+1 , 1 ) );\\n        vector < vector < ll > > v2 = v1;\\n        for( int i = 1 ; i <= n ; i++) { \\n            for( int j = 0 ; j <= i ; j++) {\\n                if( j==0 || j==i ) v2[i][j] = 1 ;\\n                else v2[i][j] = ( v2[i-1][j-1] + v2[i-1][j] ) % p;\\n            }\\n        }\\n        for(ll i = 2 ; i <= n ; i++) {\\n            for(ll j = 0 ; j+i-1 < n ; j++) {\\n                v1[i][j] = 0 ;\\n                for(ll k = j ;k < i + j -1 ; k++) {\\n                    if( s[k] == \\'I\\' && s[k+1] == \\'D\\' ) {\\n                        v1[i][j] = ( v1[i][j] + ( ( v2[i][k+1-j] * v1[k-j][j] ) %p ) * v1[i+j-k-2][k+2] ) % p;\\n                    }\\n                }\\n                if( s[j] == \\'D\\' ) v1[i][j] = ( v1[i][j] + v1[i-1][j+1] ) %p;\\n                if( s[i+j-1] == \\'I\\' ) v1[i][j] = ( v1[i][j] + v1[i-1][j] ) %p;\\n            }\\n        }\\n        return v1[n][0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ll p = 1e9+7;\\n    int numPermsDISequence(string s){\\n        ll n = s.size();\\n        vector < vector < ll > > v1( n+1 , vector<ll> ( n+1 , 1 ) );\\n        vector < vector < ll > > v2 = v1;\\n        for( int i = 1 ; i <= n ; i++) { \\n            for( int j = 0 ; j <= i ; j++) {\\n                if( j==0 || j==i ) v2[i][j] = 1 ;\\n                else v2[i][j] = ( v2[i-1][j-1] + v2[i-1][j] ) % p;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 901920,
                "title": "cpp14-dp-solution",
                "content": "```\\n\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int dp[205][205];\\n        memset(dp , 0 ,sizeof dp) ;\\n        int n = S.length();\\n        for(int j = 1 ; j <= n + 1  ; ++j) dp[1][j] = 1;\\n\\n        for(int i = 2 ; i <= n + 1  ; ++i){\\n           // cout << \" i is \" << i << endl ; \\n            if(S[i - 2] == \\'D\\'){\\n                /// p[i] > p[i+1]\\n                int sum = 0;\\n                for(int j = n - i + 2 ; j >= 1 ; --j){\\n                    sum = sum + dp[i-1][j+1];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n            else if(S[i-2] == \\'I\\'){\\n                /// p[i] < p[i+1]\\n                int sum = 0;\\n                for(int j = 1 ; j <= n - i + 2 ; ++j){\\n                    sum = sum + dp[i-1][j];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n    \\n        }\\n        return dp[n+1][1] ;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int dp[205][205];\\n        memset(dp , 0 ,sizeof dp) ;\\n        int n = S.length();\\n        for(int j = 1 ; j <= n + 1  ; ++j) dp[1][j] = 1;\\n\\n        for(int i = 2 ; i <= n + 1  ; ++i){\\n           // cout << \" i is \" << i << endl ; \\n            if(S[i - 2] == \\'D\\'){\\n                /// p[i] > p[i+1]\\n                int sum = 0;\\n                for(int j = n - i + 2 ; j >= 1 ; --j){\\n                    sum = sum + dp[i-1][j+1];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n            else if(S[i-2] == \\'I\\'){\\n                /// p[i] < p[i+1]\\n                int sum = 0;\\n                for(int j = 1 ; j <= n - i + 2 ; ++j){\\n                    sum = sum + dp[i-1][j];\\n                    sum = sum % mod ;\\n                    dp[i][j] = sum ;\\n                }\\n            }\\n    \\n        }\\n        return dp[n+1][1] ;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 898513,
                "title": "java-dp-solution-time-compexity-o-n2-space-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int MOD = 1000000007;\\n        int N = S.length();\\n        int [] dp = new int [N+1];\\n        dp[0] =1;\\n        int sum = 0;\\n        for(int i =1;i<=N;i++){\\n            char ch = S.charAt(i-1);\\n            int [] dp2 = new int[N+1];\\n            if(ch == \\'I\\'){\\n                for(int j = 1;j<=i;j++)\\n                    dp2[j] = (dp2[j-1]+dp[j-1])%MOD;\\n            }\\n            else{\\n                 for(int j = i-1;j>=0;j--)\\n                    dp2[j] = (dp2[j+1]+dp[j])%MOD;\\n            }\\n            dp = dp2;\\n        }\\n        int ans = 0;\\n        for(int num : dp)\\n            ans = (ans+num)%MOD;\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        int MOD = 1000000007;\\n        int N = S.length();\\n        int [] dp = new int [N+1];\\n        dp[0] =1;\\n        int sum = 0;\\n        for(int i =1;i<=N;i++){\\n            char ch = S.charAt(i-1);\\n            int [] dp2 = new int[N+1];\\n            if(ch == \\'I\\'){\\n                for(int j = 1;j<=i;j++)\\n                    dp2[j] = (dp2[j-1]+dp[j-1])%MOD;\\n            }\\n            else{\\n                 for(int j = i-1;j>=0;j--)\\n                    dp2[j] = (dp2[j+1]+dp[j])%MOD;\\n            }\\n            dp = dp2;\\n        }\\n        int ans = 0;\\n        for(int num : dp)\\n            ans = (ans+num)%MOD;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876768,
                "title": "python-dp-o-n-2",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        M = 10**9 + 7\\n        C = [1] + [0 for _ in range(len(S))]\\n        for n, id in enumerate(list(S), start=2):\\n            if id == \\'I\\':\\n                C = [sum(C[j - 1] for j in range(1, k)) % M for\\n                     k in range(1, n + 1)]\\n            elif id == \\'D\\':\\n                C = [sum(C[j - 1] for j in range(k, n)) % M for\\n                     k in range(1, n + 1)]\\n        return sum(C) % M\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        M = 10**9 + 7\\n        C = [1] + [0 for _ in range(len(S))]\\n        for n, id in enumerate(list(S), start=2):\\n            if id == \\'I\\':\\n                C = [sum(C[j - 1] for j in range(1, k)) % M for\\n                     k in range(1, n + 1)]\\n            elif id == \\'D\\':\\n                C = [sum(C[j - 1] for j in range(k, n)) % M for\\n                     k in range(1, n + 1)]\\n        return sum(C) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866925,
                "title": "js-solution",
                "content": "```js\\n/**\\n * @param {string} S\\n * @return {number}\\n */\\nexport default (S) => {\\n  let dp = [];\\n  const len = S.length;\\n  const mod = Math.pow(10, 9) + 7;\\n  // S=DID\\n  // len = 4,\\u6240\\u4EE5\\u8FD9\\u91CC\\u67090\\uFF0C1\\uFF0C2\\uFF0C3\\u56DB\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\n  // dp[i][j] \\u8868\\u793Ai\\u4E2A\\u6570\\u5B57\\u653E\\u7F6E\\u5B8C\\u6BD5\\uFF0C\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u7B2Cj\\u4F4D\\u7684\\u4E2A\\u6570\\n  // \\u6BD4\\u5982d[3][0] \\u8868\\u793A\\u57280\\uFF0C1\\uFF0C2\\uFF0C3\\u4E2D\\u5DF2\\u7ECF\\u9009\\u62E9\\u4E86\\u4E09\\u4E2A\\u6570\\u5B57\\uFF0C\\u6309\\u7167DID\\u7684\\u8981\\u6C42\\u5DF2\\u7ECF\\u653E\\u7F6E\\u5B8C\\u6BD5\\u4E86\\uFF0C\\u7136\\u540E\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u4F4D\\u7F6E\\u4E3A0\\u7684\\u6570\\u5B57\\n  for (let i = 0; i <= len; i++) {\\n    dp[i] = [];\\n  }\\n  // \\u56E0\\u4E3A\\u67090\\uFF0C1\\uFF0C2\\uFF0C3 \\u56DB\\u4E2A\\u6570\\u5B57\\n  // dp[0][0] = 1, [0]\\n  // dp[0][1] = 1, [1]\\n  // dp[0][2] = 1, [2]\\n  // dp[0][3] = 1, [3]\\n  for (let i = 0; i <= len; i++) {\\n    dp[0][i] = 1;\\n  }\\n  // \\u8BA1\\u7B97dp[len][0]\\n  for (let i = 0; i < len; i++) {\\n    if (S.charAt(i) == \"I\") {\\n      // \\u56E0\\u4E3A\\u5DF2\\u7ECF\\u6709i\\u4E2A\\u6570\\u5B57\\u5DF2\\u7ECF\\u88AB\\u653E\\u7F6E\\u597D\\u4E86\\n      // \\u6BD4\\u5982\\u5F53i=0\\u7684\\u65F6\\u5019\\uFF0C\\u4E00\\u5171\\u9700\\u8981\\u653E0\\uFF0C1\\uFF0C2\\uFF0C3\\uFF0Ci=0\\uFF0C\\u5C31\\u662F\\u5DF2\\u7ECF0\\u7684\\u4F4D\\u7F6E\\u4E0A\\u5DF2\\u7ECF\\u653E\\u7F6E\\u4E86\\u4E00\\u4E2A\\u4E86\\uFF0C\\n      // \\u4E5F\\u5C31\\u662F\\u8BF4\\u8FD8\\u6709\\u4E09\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\u4E5F\\u5C31\\u662Flen-i\\n      for (let j = 0, cur = 0; j < len - i; j++) {\\n        // \\u53D6\\u6A21\\n        cur = cur + dp[i][j];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    } else {\\n      // \\u5F53S.charAt(i) == \"D\"\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u5C31\\u662F\\u9700\\u8981\\u964D\\u5E8F\\uFF0C\\n      // \\u6BD4\\u5982\\u67090\\uFF0C 1\\uFF0C2\\uFF0C3\\uFF0C \\u5982\\u679C\\u9700\\u8981\\u653E\\u7F6Edp[1][2],\\u5219\\u53EA\\u6709\\u4E00\\u79CD\\u53EF\\u80FD\\uFF0C\\u90A3\\u5C31\\u662F\\u7B49\\u4E8Edp[0][3],\\n      // \\u4E0D\\u7136\\u5982\\u679C\\u653E\\u7F6E\\u4E86dp[1][2]\\u7684\\u65F6\\u5019\\uFF0C\\u57282\\u7684\\u4F4D\\u7F6E\\u653E\\u7F6E\\u7684\\u5143\\u7D20\\u80AF\\u5B9A\\u6BD4\\u524D\\u9762\\u7684\\u5927\\uFF0C\\u4E5F\\u5C31\\u662F\\u4E0D\\u7B26\\u5408S.charAt(i) == \"D\"\\n      for (let j = len - i - 1, cur = 0; j >= 0; j--) {\\n        cur = cur + dp[i][j + 1];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    }\\n  }\\n  return dp[len][0];\\n};\\n\\n \\n\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string} S\\n * @return {number}\\n */\\nexport default (S) => {\\n  let dp = [];\\n  const len = S.length;\\n  const mod = Math.pow(10, 9) + 7;\\n  // S=DID\\n  // len = 4,\\u6240\\u4EE5\\u8FD9\\u91CC\\u67090\\uFF0C1\\uFF0C2\\uFF0C3\\u56DB\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\n  // dp[i][j] \\u8868\\u793Ai\\u4E2A\\u6570\\u5B57\\u653E\\u7F6E\\u5B8C\\u6BD5\\uFF0C\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u7B2Cj\\u4F4D\\u7684\\u4E2A\\u6570\\n  // \\u6BD4\\u5982d[3][0] \\u8868\\u793A\\u57280\\uFF0C1\\uFF0C2\\uFF0C3\\u4E2D\\u5DF2\\u7ECF\\u9009\\u62E9\\u4E86\\u4E09\\u4E2A\\u6570\\u5B57\\uFF0C\\u6309\\u7167DID\\u7684\\u8981\\u6C42\\u5DF2\\u7ECF\\u653E\\u7F6E\\u5B8C\\u6BD5\\u4E86\\uFF0C\\u7136\\u540E\\u5728\\u5269\\u4E0B\\u7684\\u6570\\u5B57\\u91CC\\u8FB9\\u9009\\u62E9\\u4F4D\\u7F6E\\u4E3A0\\u7684\\u6570\\u5B57\\n  for (let i = 0; i <= len; i++) {\\n    dp[i] = [];\\n  }\\n  // \\u56E0\\u4E3A\\u67090\\uFF0C1\\uFF0C2\\uFF0C3 \\u56DB\\u4E2A\\u6570\\u5B57\\n  // dp[0][0] = 1, [0]\\n  // dp[0][1] = 1, [1]\\n  // dp[0][2] = 1, [2]\\n  // dp[0][3] = 1, [3]\\n  for (let i = 0; i <= len; i++) {\\n    dp[0][i] = 1;\\n  }\\n  // \\u8BA1\\u7B97dp[len][0]\\n  for (let i = 0; i < len; i++) {\\n    if (S.charAt(i) == \"I\") {\\n      // \\u56E0\\u4E3A\\u5DF2\\u7ECF\\u6709i\\u4E2A\\u6570\\u5B57\\u5DF2\\u7ECF\\u88AB\\u653E\\u7F6E\\u597D\\u4E86\\n      // \\u6BD4\\u5982\\u5F53i=0\\u7684\\u65F6\\u5019\\uFF0C\\u4E00\\u5171\\u9700\\u8981\\u653E0\\uFF0C1\\uFF0C2\\uFF0C3\\uFF0Ci=0\\uFF0C\\u5C31\\u662F\\u5DF2\\u7ECF0\\u7684\\u4F4D\\u7F6E\\u4E0A\\u5DF2\\u7ECF\\u653E\\u7F6E\\u4E86\\u4E00\\u4E2A\\u4E86\\uFF0C\\n      // \\u4E5F\\u5C31\\u662F\\u8BF4\\u8FD8\\u6709\\u4E09\\u4E2A\\u6570\\u5B57\\u9700\\u8981\\u653E\\u7F6E\\uFF0C\\u4E5F\\u5C31\\u662Flen-i\\n      for (let j = 0, cur = 0; j < len - i; j++) {\\n        // \\u53D6\\u6A21\\n        cur = cur + dp[i][j];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    } else {\\n      // \\u5F53S.charAt(i) == \"D\"\\u7684\\u65F6\\u5019\\uFF0C\\u4E5F\\u5C31\\u662F\\u9700\\u8981\\u964D\\u5E8F\\uFF0C\\n      // \\u6BD4\\u5982\\u67090\\uFF0C 1\\uFF0C2\\uFF0C3\\uFF0C \\u5982\\u679C\\u9700\\u8981\\u653E\\u7F6Edp[1][2],\\u5219\\u53EA\\u6709\\u4E00\\u79CD\\u53EF\\u80FD\\uFF0C\\u90A3\\u5C31\\u662F\\u7B49\\u4E8Edp[0][3],\\n      // \\u4E0D\\u7136\\u5982\\u679C\\u653E\\u7F6E\\u4E86dp[1][2]\\u7684\\u65F6\\u5019\\uFF0C\\u57282\\u7684\\u4F4D\\u7F6E\\u653E\\u7F6E\\u7684\\u5143\\u7D20\\u80AF\\u5B9A\\u6BD4\\u524D\\u9762\\u7684\\u5927\\uFF0C\\u4E5F\\u5C31\\u662F\\u4E0D\\u7B26\\u5408S.charAt(i) == \"D\"\\n      for (let j = len - i - 1, cur = 0; j >= 0; j--) {\\n        cur = cur + dp[i][j + 1];\\n        if (cur > mod) {\\n          cur = cur % mod;\\n        }\\n        dp[i + 1][j] = cur;\\n      }\\n    }\\n  }\\n  return dp[len][0];\\n};\\n\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564801,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long giveres(int pos,int len,int choto, vector<vector<long long>>&dp,string &s){\\n        if(pos==len)\\n            return 1ll;\\n        long long &ret = dp[pos][choto];\\n        if(ret!=-1)\\n            return ret;\\n        ret = 0;\\n        if(s[pos-1]==\\'D\\'){\\n            for(int i = 1;i<=choto;i++){\\n                ret += giveres(pos+1,len,i-1,dp,s);\\n                if(ret>=mod)\\n                    ret%=-mod;\\n            }\\n        }\\n        else {\\n            for(int i = 1;i<=len-pos-choto;i++){\\n                ret += giveres(pos+1,len,i-1+choto,dp,s);\\n                if(ret>=mod)\\n                    ret %= mod;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    int numPermsDISequence(string S) {\\n        int len = S.size();\\n        vector<vector<long long>>dp(len+5,vector<long long>(len+5,-1));\\n        long long ans = 0;\\n        for(int i = 1;i<=len+1;i++){\\n            ans += giveres(1,len+1,i-1,dp,S);\\n            if(ans >= mod)\\n                ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long giveres(int pos,int len,int choto, vector<vector<long long>>&dp,string &s){\\n        if(pos==len)\\n            return 1ll;\\n        long long &ret = dp[pos][choto];\\n        if(ret!=-1)\\n            return ret;\\n        ret = 0;\\n        if(s[pos-1]==\\'D\\'){\\n            for(int i = 1;i<=choto;i++){\\n                ret += giveres(pos+1,len,i-1,dp,s);\\n                if(ret>=mod)\\n                    ret%=-mod;\\n            }\\n        }\\n        else {\\n            for(int i = 1;i<=len-pos-choto;i++){\\n                ret += giveres(pos+1,len,i-1+choto,dp,s);\\n                if(ret>=mod)\\n                    ret %= mod;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    int numPermsDISequence(string S) {\\n        int len = S.size();\\n        vector<vector<long long>>dp(len+5,vector<long long>(len+5,-1));\\n        long long ans = 0;\\n        for(int i = 1;i<=len+1;i++){\\n            ans += giveres(1,len+1,i-1,dp,S);\\n            if(ans >= mod)\\n                ans %= mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494725,
                "title": "rust-0ms-2-1mb-100",
                "content": "```rust\\n// translated from https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)\\npub fn num_perms_di_sequence(s: String) -> i32 {\\n    const MOD: i32 = 1_000_000_007;\\n    let n = s.len();\\n    let mut dp = vec![1; n + 1];\\n    let mut dp2 = vec![0; n];\\n//    println!(\"{:?}\", dp);\\n    for i in 0..n {\\n        if s[i..].chars().next().unwrap() == \\'I\\' {\\n            let mut cur = 0;\\n            for j in 0..n - i\\n            {\\n                cur = (cur + dp[j]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        } else {\\n            let mut cur = 0;\\n            for j in (0..n - i).rev() {\\n                cur = (cur + dp[j + 1]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        }\\n        dp[..n].copy_from_slice(&dp2[..n]);\\n//        println!(\"{:?}\", dp);\\n    }\\n    dp[0]\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n// translated from https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2)\\npub fn num_perms_di_sequence(s: String) -> i32 {\\n    const MOD: i32 = 1_000_000_007;\\n    let n = s.len();\\n    let mut dp = vec![1; n + 1];\\n    let mut dp2 = vec![0; n];\\n//    println!(\"{:?}\", dp);\\n    for i in 0..n {\\n        if s[i..].chars().next().unwrap() == \\'I\\' {\\n            let mut cur = 0;\\n            for j in 0..n - i\\n            {\\n                cur = (cur + dp[j]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        } else {\\n            let mut cur = 0;\\n            for j in (0..n - i).rev() {\\n                cur = (cur + dp[j + 1]) % MOD;\\n                dp2[j] = cur;\\n            }\\n        }\\n        dp[..n].copy_from_slice(&dp2[..n]);\\n//        println!(\"{:?}\", dp);\\n    }\\n    dp[0]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 443745,
                "title": "python3-divide-and-conquer-solution-slightly-quicker-than-official-divide-and-conquer-solution",
                "content": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.mod = 10 ** 9 + 7\\n\\n    @lru_cache(maxsize=None)\\n    def nCk(self, n, k):\\n        if k == 1: return n\\n        if k == 0 or n == k: return 1\\n        return self.nCk(n - 1, k - 1) + self.nCk(n - 1, k)\\n\\n    @lru_cache(maxsize=None)\\n    def numPermsDISequence(self, s: str) -> int:\\n        if len(s) <= 1: return 1\\n        n = len(s) + 1\\n        ans = 0\\n\\t\\t#Insert max number in every \\'DI\\' part, left and right part are choosed from left numbers\\n        for i in range(n - 1):\\n            if s[i:i + 2] == \\'ID\\': ans += self.nCk(n - 1, i + 1) * self.numPermsDISequence(s[:i]) * self.numPermsDISequence(s[i + 2:])\\n\\t\\t#Insert max number at start position if s[0] == \\'D\\'\\n        if s[0] == \\'D\\': ans += self.numPermsDISequence(s[1: n - 1])\\n\\t\\t#Same insert max number at end\\n        if s[n - 2] == \\'I\\': ans += self.numPermsDISequence(s[: n - 2])\\n        return ans % self.mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def __init__(self):\\n        self.mod = 10 ** 9 + 7\\n\\n    @lru_cache(maxsize=None)\\n    def nCk(self, n, k):\\n        if k == 1: return n\\n        if k == 0 or n == k: return 1\\n        return self.nCk(n - 1, k - 1) + self.nCk(n - 1, k)\\n\\n    @lru_cache(maxsize=None)\\n    def numPermsDISequence(self, s: str) -> int:\\n        if len(s) <= 1: return 1\\n        n = len(s) + 1\\n        ans = 0\\n\\t\\t#Insert max number in every \\'DI\\' part, left and right part are choosed from left numbers\\n        for i in range(n - 1):\\n            if s[i:i + 2] == \\'ID\\': ans += self.nCk(n - 1, i + 1) * self.numPermsDISequence(s[:i]) * self.numPermsDISequence(s[i + 2:])\\n\\t\\t#Insert max number at start position if s[0] == \\'D\\'\\n        if s[0] == \\'D\\': ans += self.numPermsDISequence(s[1: n - 1])\\n\\t\\t#Same insert max number at end\\n        if s[n - 2] == \\'I\\': ans += self.numPermsDISequence(s[: n - 2])\\n        return ans % self.mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436007,
                "title": "python-dp",
                "content": "dp  \\n**Subproblem definition**:  dp[n][j] = number of permutations or [0,1,2,3,4,5,..., n-2, n-1] that end with j \\n**How many subproblems** O(n^2)\\n**Recurrence** \\n1. dp[n][j] = sigma dp[n-1][b] for all a < j if the last evolution is an increase\\n2. dp[n][j] = sigma dp[n-1][a] for all j <=b < n - 1  if the last evolution is an increase\\n\\n\\n**Time per subproblem** O(n)\\n**Final Answer** sigma dp[n][j] for j in [0,1,2,3,..., n-2,n-1]\\n\\n\\n\\n\\n\\n\\n\\n```\\nMOD  = 10 ** 9 + 7\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        mem, nn = {}, len(S) + 1\\n        res = 0\\n        for n in range(1, nn + 1):\\n            for j in range(n):\\n                r = self.f(n, j, S, mem)\\n                if n == nn:\\n                    res += r\\n                    res %= MOD\\n        return res\\n    \\n    \\n    def f(self, n, j, s, mem):\\n        # if n == 0 : return 0\\n        if n == 1:  return 1 if j == 0 else 0\\n        if (n,j) not in mem:\\n            mem[(n,j)] = sum([self.f(n - 1, a, s, mem) for a in range(j,n - 1)] or [0]) % MOD if s[n - 2] == \\'D\\' else sum([self.f(n - 1, b, s, mem) for b in range(j)] or [0]) % MOD\\n        return mem[(n,j)] \\n```",
                "solutionTags": [],
                "code": "```\\nMOD  = 10 ** 9 + 7\\nclass Solution(object):\\n    def numPermsDISequence(self, S):\\n        mem, nn = {}, len(S) + 1\\n        res = 0\\n        for n in range(1, nn + 1):\\n            for j in range(n):\\n                r = self.f(n, j, S, mem)\\n                if n == nn:\\n                    res += r\\n                    res %= MOD\\n        return res\\n    \\n    \\n    def f(self, n, j, s, mem):\\n        # if n == 0 : return 0\\n        if n == 1:  return 1 if j == 0 else 0\\n        if (n,j) not in mem:\\n            mem[(n,j)] = sum([self.f(n - 1, a, s, mem) for a in range(j,n - 1)] or [0]) % MOD if s[n - 2] == \\'D\\' else sum([self.f(n - 1, b, s, mem) for b in range(j)] or [0]) % MOD\\n        return mem[(n,j)] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 404899,
                "title": "i-have-a-question",
                "content": "these solutions seem like that they don\\'t consider the repetition pattern like that:\\nwhen input is: DID\\nwe all know that (3, 0, 2, 1) is valid\\nhowever, just use the dp way, dp[m][n] = sum(dp[m - 1][j < n when input[pos] == \\'D\\']) or \\ndp[m][n] = sum(dp[m - 1][j > n when input[pos] == \\'I\\'] can\\'t guarantee the pattern (3, 0, 3, 1)happen\\ncause the result can be larger than we expect!!\\n",
                "solutionTags": [],
                "code": "these solutions seem like that they don\\'t consider the repetition pattern like that:\\nwhen input is: DID\\nwe all know that (3, 0, 2, 1) is valid\\nhowever, just use the dp way, dp[m][n] = sum(dp[m - 1][j < n when input[pos] == \\'D\\']) or \\ndp[m][n] = sum(dp[m - 1][j > n when input[pos] == \\'I\\'] can\\'t guarantee the pattern (3, 0, 3, 1)happen\\ncause the result can be larger than we expect!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 356234,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, s):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(s) + 1\\n        dp = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        dp[0][0] = 1\\n        for i in xrange(1,n):\\n            for j in xrange(i + 1):\\n                if s[i - 1] == \\'D\\':\\n                    for k in xrange(j,i):\\n                        dp[i][j] += dp[i - 1][k]\\n                elif s[i - 1] == \\'I\\':\\n                    for k in xrange(j):\\n                        dp[i][j] += dp[i - 1][k]\\n        return sum(dp[-1]) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numPermsDISequence(self, s):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        n = len(s) + 1\\n        dp = [[0 for _ in xrange(n)] for _ in xrange(n)]\\n        dp[0][0] = 1\\n        for i in xrange(1,n):\\n            for j in xrange(i + 1):\\n                if s[i - 1] == \\'D\\':\\n                    for k in xrange(j,i):\\n                        dp[i][j] += dp[i - 1][k]\\n                elif s[i - 1] == \\'I\\':\\n                    for k in xrange(j):\\n                        dp[i][j] += dp[i - 1][k]\\n        return sum(dp[-1]) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343312,
                "title": "share-my-python3-solutions-with-o-n-3-and-o-n-2",
                "content": "(1)O(n^3):\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        if S[0] == \\'D\\':\\n            dp[1][0] = 1\\n        elif S[0] == \\'I\\':\\n            dp[1][1] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    for k in range(j, i):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n                elif S[i-1] == \\'I\\':\\n                    for k in range(0, j):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n\\n        ret = 0\\n        for k in range(n+1):\\n            ret += dp[n][k]\\n            ret %= mod\\n\\n        return ret\\n```\\n\\n(2) O(n^2): using prefix sum to optimize\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        dp[0][0] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][i-1] - dp[i-1][j-1] + dp[i][j-1]) % mod\\n                    else:\\n                        dp[i][j] = dp[i-1][i-1]\\n                elif S[i-1] == \\'I\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % mod\\n        \\n        return dp[n][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        if S[0] == \\'D\\':\\n            dp[1][0] = 1\\n        elif S[0] == \\'I\\':\\n            dp[1][1] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    for k in range(j, i):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n                elif S[i-1] == \\'I\\':\\n                    for k in range(0, j):\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= mod\\n\\n        ret = 0\\n        for k in range(n+1):\\n            ret += dp[n][k]\\n            ret %= mod\\n\\n        return ret\\n```\n```\\nclass Solution:\\n    def numPermsDISequence(self, S: str) -> int:\\n        if not S:\\n            return 0\\n\\n        mod = 1000000007\\n        n = len(S)\\n        dp = []\\n        for i in range(n+1):\\n            dp.append([0] * (n+1))\\n        dp[0][0] = 1\\n\\n        for i in range(1, n+1):\\n            for j in range(i+1):\\n                if S[i-1] == \\'D\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][i-1] - dp[i-1][j-1] + dp[i][j-1]) % mod\\n                    else:\\n                        dp[i][j] = dp[i-1][i-1]\\n                elif S[i-1] == \\'I\\':\\n                    if j != 0:\\n                        dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % mod\\n        \\n        return dp[n][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317865,
                "title": "golang-dp-solution-o-n-2",
                "content": "I believe that everyone knows the following formula when **S[i-1] is \"D\"**,\\n```\\ndp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\\nSo,\\n```\\ndp[i][j-1] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\\n\\nAccordingly,\\n```\\ndp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n```\\nPlease note that dp[i][j-1] could be less than dp[i-1][j-1], because each intermediate result is modulo 1000000007, so we need to change the above formula a little bit as below for safety,\\n```\\ndp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n```\\n\\nSimilarly, we can easily get the following formula when S[i-1] is \"I\",\\n```\\ndp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n```\\n\\nSo the final solution is as below,\\n\\n```\\nfunc numPermsDISequence(S string) int {\\n    MOD := 1000000007\\n    N := len(S)\\n    dp := make([][]int, N+1)\\n    for i:=0; i<=N; i++ {\\n        dp[i] = make([]int, N+1)\\n    }\\n    \\n    for i:=0; i<=N; i++{\\n        dp[0][i] = 1\\n    }\\n    \\n    for i:=1; i<=N; i++ {\\n        for j:=0; j<=i; j++ {\\n            if S[i-1] == \\'D\\' {\\n                if j == 0 {\\n                    for k:=j; k<i; k++ {\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= MOD\\n                    }\\n                } else {\\n                    if dp[i][j-1] < dp[i-1][j-1] {\\n                        dp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n                    } else {\\n                        dp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n                    }\\n                    dp[i][j] %= MOD \\n                }\\n            } else {\\n                if j > 0 {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n                    dp[i][j] %= MOD\\n                }\\n            }\\n        }\\n    }\\n    \\n    ret := 0\\n    for i:=0; i<=N; i++ {\\n        ret += dp[N][i]\\n        ret %= MOD\\n    }\\n    \\n    return ret\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\n```\\ndp[i][j-1] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2] + ... + dp[i-1][i-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n```\n```\\ndp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n```\n```\\nfunc numPermsDISequence(S string) int {\\n    MOD := 1000000007\\n    N := len(S)\\n    dp := make([][]int, N+1)\\n    for i:=0; i<=N; i++ {\\n        dp[i] = make([]int, N+1)\\n    }\\n    \\n    for i:=0; i<=N; i++{\\n        dp[0][i] = 1\\n    }\\n    \\n    for i:=1; i<=N; i++ {\\n        for j:=0; j<=i; j++ {\\n            if S[i-1] == \\'D\\' {\\n                if j == 0 {\\n                    for k:=j; k<i; k++ {\\n                        dp[i][j] += dp[i-1][k]\\n                        dp[i][j] %= MOD\\n                    }\\n                } else {\\n                    if dp[i][j-1] < dp[i-1][j-1] {\\n                        dp[i][j] = dp[i][j-1] + MOD - dp[i-1][j-1]\\n                    } else {\\n                        dp[i][j] = dp[i][j-1] - dp[i-1][j-1]\\n                    }\\n                    dp[i][j] %= MOD \\n                }\\n            } else {\\n                if j > 0 {\\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\\n                    dp[i][j] %= MOD\\n                }\\n            }\\n        }\\n    }\\n    \\n    ret := 0\\n    for i:=0; i<=N; i++ {\\n        ret += dp[N][i]\\n        ret %= MOD\\n    }\\n    \\n    return ret\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308917,
                "title": "can-any-one-explain-the-proof-to-calculate-the-module-of-combination-in-the-second-solution",
                "content": "Can anyone please explain why we calculate inverse of factorial as pow(f, MOD-2, MOD) ? Thanks a lot.\\n\\n```\\n        facinv = [pow(f, MOD-2, MOD) for f in fac]\\n\\n        def binom(n, k):\\n            return fac[n] * facinv[n-k] % MOD * facinv[k] % MOD\\n```",
                "solutionTags": [],
                "code": "```\\n        facinv = [pow(f, MOD-2, MOD) for f in fac]\\n\\n        def binom(n, k):\\n            return fac[n] * facinv[n-k] % MOD * facinv[k] % MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 298593,
                "title": "c-beats-100-8ms-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        \\n\\tint max = S.size();\\n        if(max == 1)\\n            return 1;\\n\\tvector<long long> last(max + 1); // last[i] means when the end is i, the number of available\\n\\tif (S.at(0) == \\'D\\') {\\n\\t\\tlast[0] = 1;  \\n\\t} else {\\n\\t\\tlast[1] = 1;\\n\\t}\\n\\t\\n\\tfor (int i = 1; i < max; i++) { //i+1 means the len of array\\n\\t\\tif (S.at(i) == \\'D\\') {\\n\\t\\t\\tlast[i+1] = 0;\\n\\t\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\t\\tlast[j] = (last[j+1] + last[j]) % 1000000007; // last(i, j) = last(i-1, j) + last(i, j+1) ; \\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tlong long temp = last[0];\\n\\t\\t\\tlast[0] = 0;\\n\\t\\t\\tfor (int j = 1; j <= i + 1; j++) {\\n\\t\\t\\t\\tlong long x = last[j];\\n\\t\\t\\t\\tlast[j] = (temp + last[j - 1]) % 1000000007; //last(i, j) = last(i - 1, j - 1) + last(i, j - 1);\\n\\t\\t\\t\\ttemp = x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlong long ans = 0;\\n\\tfor (long long x : last)\\n\\t\\tans += x;\\n\\treturn ans % 1000000007;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        \\n\\tint max = S.size();\\n        if(max == 1)\\n            return 1;\\n\\tvector<long long> last(max + 1); // last[i] means when the end is i, the number of available\\n\\tif (S.at(0) == \\'D\\') {\\n\\t\\tlast[0] = 1;  \\n\\t} else {\\n\\t\\tlast[1] = 1;\\n\\t}\\n\\t\\n\\tfor (int i = 1; i < max; i++) { //i+1 means the len of array\\n\\t\\tif (S.at(i) == \\'D\\') {\\n\\t\\t\\tlast[i+1] = 0;\\n\\t\\t\\tfor (int j = i; j >= 0; j--) {\\n\\t\\t\\t\\tlast[j] = (last[j+1] + last[j]) % 1000000007; // last(i, j) = last(i-1, j) + last(i, j+1) ; \\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tlong long temp = last[0];\\n\\t\\t\\tlast[0] = 0;\\n\\t\\t\\tfor (int j = 1; j <= i + 1; j++) {\\n\\t\\t\\t\\tlong long x = last[j];\\n\\t\\t\\t\\tlast[j] = (temp + last[j - 1]) % 1000000007; //last(i, j) = last(i - 1, j - 1) + last(i, j - 1);\\n\\t\\t\\t\\ttemp = x;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlong long ans = 0;\\n\\tfor (long long x : last)\\n\\t\\tans += x;\\n\\treturn ans % 1000000007;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213523,
                "title": "c-dp-solution-o-n-2",
                "content": "```\\nconst int MOD = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        /**\\n            \\u72B6\\u6001\\u5B9A\\u4E49\\uFF1A   \\u8BBE f(i,j) \\u662F\\u5E8F\\u5217<0..i>\\u4EE5 \"\\u7B2Cj\\u5C0F\\u5143\\u7D20\" \\u4E3A\\u5C3E\\u65F6\\u7684\\u6709\\u6548\\u5E8F\\u5217\\u6570, 0<=j<=i\\n            \\u8F6C\\u79FB\\u65B9\\u7A0B\\uFF1A   f(i,j) = sum{ f(i-1,k) }, k < j \\u6216 k > j\\n            \\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A   f(0,0) = 1\\n        **/\\n        int n = S.size();\\n        vector<int> dp(n+1,0), sum(n+1,0), aux(n+1,0);\\n        sum[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            aux[0] = dp[0] = S[i-1]==\\'I\\' ? 0 : sum[i-1];\\n            for (int j = 1; j <= i; j++) {\\n                dp[j]  = S[i-1]==\\'I\\' ? sum[j-1] : (sum[i-1]-sum[j-1]+MOD)%MOD; \\n                aux[j] = (aux[j-1] + dp[j]) % MOD;\\n            }\\n            swap(aux, sum);\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int MOD = 1000000007;\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        /**\\n            \\u72B6\\u6001\\u5B9A\\u4E49\\uFF1A   \\u8BBE f(i,j) \\u662F\\u5E8F\\u5217<0..i>\\u4EE5 \"\\u7B2Cj\\u5C0F\\u5143\\u7D20\" \\u4E3A\\u5C3E\\u65F6\\u7684\\u6709\\u6548\\u5E8F\\u5217\\u6570, 0<=j<=i\\n            \\u8F6C\\u79FB\\u65B9\\u7A0B\\uFF1A   f(i,j) = sum{ f(i-1,k) }, k < j \\u6216 k > j\\n            \\u8FB9\\u754C\\u6761\\u4EF6\\uFF1A   f(0,0) = 1\\n        **/\\n        int n = S.size();\\n        vector<int> dp(n+1,0), sum(n+1,0), aux(n+1,0);\\n        sum[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            aux[0] = dp[0] = S[i-1]==\\'I\\' ? 0 : sum[i-1];\\n            for (int j = 1; j <= i; j++) {\\n                dp[j]  = S[i-1]==\\'I\\' ? sum[j-1] : (sum[i-1]-sum[j-1]+MOD)%MOD; \\n                aux[j] = (aux[j-1] + dp[j]) % MOD;\\n            }\\n            swap(aux, sum);\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211592,
                "title": "c-o-n-3",
                "content": "```\\nint numPermsDISequence(string S) {\\n   const long long mod = 1e9 + 7;\\n   vector<long long> pre(S.size() + 1, 1), cur;\\n   for (auto c : S) {\\n      cur = vector<long long>(pre.size() - 1);\\n      for (int j = 0; j < pre.size(); j++) {\\n         for (int k = 0; k < pre.size(); k++) {\\n            if (c == \\'D\\' && k >= j) continue;\\n            if (c == \\'I\\' && k <= j) continue;\\n            auto k1 = k > j ? k - 1 : k;\\n            cur[k1] += pre[j]; cur[k1] %= mod;\\n         }\\n      }\\n      pre = move(cur);\\n   }\\n   return accumulate(pre.begin(), pre.end(), 0ll) % mod;\\n}",
                "solutionTags": [],
                "code": "```\\nint numPermsDISequence(string S) {\\n   const long long mod = 1e9 + 7;\\n   vector<long long> pre(S.size() + 1, 1), cur;\\n   for (auto c : S) {\\n      cur = vector<long long>(pre.size() - 1);\\n      for (int j = 0; j < pre.size(); j++) {\\n         for (int k = 0; k < pre.size(); k++) {\\n            if (c == \\'D\\' && k >= j) continue;\\n            if (c == \\'I\\' && k <= j) continue;\\n            auto k1 = k > j ? k - 1 : k;\\n            cur[k1] += pre[j]; cur[k1] %= mod;\\n         }\\n      }\\n      pre = move(cur);\\n   }\\n   return accumulate(pre.begin(), pre.end(), 0ll) % mod;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 209226,
                "title": "python-o-n-2-and-o-n-space-96-63",
                "content": "```\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        l, r = 0, len(S)+1\\n        dp =  [1] * r\\n        for j in S:\\n            new = [0] * r\\n            if j == \\'D\\':\\n                r -= 1\\n                for u in range(r-1,l-1,-1):\\n                    new[u] = new[u+1] + dp[u+1]\\n            elif j == \\'I\\':\\n                l += 1\\n                for u in range(l,r):\\n                    new[u] = new[u-1] + dp[u-1]\\n            dp = new\\n        return dp[l] % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numPermsDISequence(self, S):\\n        l, r = 0, len(S)+1\\n        dp =  [1] * r\\n        for j in S:\\n            new = [0] * r\\n            if j == \\'D\\':\\n                r -= 1\\n                for u in range(r-1,l-1,-1):\\n                    new[u] = new[u+1] + dp[u+1]\\n            elif j == \\'I\\':\\n                l += 1\\n                for u in range(l,r):\\n                    new[u] = new[u-1] + dp[u-1]\\n            dp = new\\n        return dp[l] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199444,
                "title": "10-lines-c-time-o-n-2-space-o-n-with-remark",
                "content": "```C++\\n// K(s, x) = nums of perms with tail ranking x\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// G(s, 0) = 0\\n// G(s, x) = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len) = G(s, s.len + 1) - G(s, x)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1) = G(s, x)\\n\\n// G(s, x + 1) = G(s, x) + K(s, x)\\n\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        vector<int64_t> G = {0, 1};\\n        \\n        for (int s_len = 0; s_len < S.size(); ++s_len) {\\n            vector<int64_t> nG = {0};\\n            \\n            for (int x = 0; x <= s_len + 1; ++x) {\\n                int64_t k = S[s_len] == \\'I\\' ? G[s_len + 1] - G[x] : G[x];\\n                nG.push_back((nG.back() + k + 1000000007) % 1000000007);\\n            }\\n            \\n            G.swap(nG);\\n        }\\n        \\n        return G[S.size() + 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n// K(s, x) = nums of perms with tail ranking x\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// G(s, 0) = 0\\n// G(s, x) = K(s, 0) + K(s, 1) + ... + K(s, x - 1)\\n\\n// K(s + \\'I\\') = K(s, x) + K(s, x+1) + ... + K(s, s.len) = G(s, s.len + 1) - G(s, x)\\n// K(s + \\'D\\') = K(s, 0) + K(s, 1) + ... + K(s, x - 1) = G(s, x)\\n\\n// G(s, x + 1) = G(s, x) + K(s, x)\\n\\n\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        vector<int64_t> G = {0, 1};\\n        \\n        for (int s_len = 0; s_len < S.size(); ++s_len) {\\n            vector<int64_t> nG = {0};\\n            \\n            for (int x = 0; x <= s_len + 1; ++x) {\\n                int64_t k = S[s_len] == \\'I\\' ? G[s_len + 1] - G[x] : G[x];\\n                nG.push_back((nG.back() + k + 1000000007) % 1000000007);\\n            }\\n            \\n            G.swap(nG);\\n        }\\n        \\n        return G[S.size() + 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191960,
                "title": "java-beats-100",
                "content": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        if (S == null) {\\n            return 0;\\n        }\\n        int mod = (int) 1e9 + 7;\\n        int n = S.length() + 1;\\n        int[][] memo = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            memo[i][0] = 1;\\n        }\\n        int acc = 0;\\n        int up = 0;\\n        int down = S.length();\\n        for (int j = 1; j < n; j++) {\\n            if (S.charAt(j - 1) == \\'I\\') {\\n                up++;\\n                for (int i = up; i <= down; i++) {\\n                    memo[i][j] = (memo[i - 1][j] + memo[i - 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            } else {\\n                down--;\\n                for (int i = down; i >= up; i--) {\\n                    memo[i][j] = (memo[i + 1][j] + memo[i + 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            }\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numPermsDISequence(String S) {\\n        if (S == null) {\\n            return 0;\\n        }\\n        int mod = (int) 1e9 + 7;\\n        int n = S.length() + 1;\\n        int[][] memo = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            memo[i][0] = 1;\\n        }\\n        int acc = 0;\\n        int up = 0;\\n        int down = S.length();\\n        for (int j = 1; j < n; j++) {\\n            if (S.charAt(j - 1) == \\'I\\') {\\n                up++;\\n                for (int i = up; i <= down; i++) {\\n                    memo[i][j] = (memo[i - 1][j] + memo[i - 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            } else {\\n                down--;\\n                for (int i = down; i >= up; i--) {\\n                    memo[i][j] = (memo[i + 1][j] + memo[i + 1][j - 1]) % mod;\\n                    acc = memo[i][j];\\n                }\\n            }\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168647,
                "title": "c-stl-partial-sum-0ms",
                "content": "    class Solution {\\n    public:\\n        int numPermsDISequence(string S) {\\n            int n = S.size() + 1, d = 0, i = 0;\\n            vector<int> arr(n, 1);\\n            auto func = [](int a, int b) { return (a + b) % 1000000007; };\\n            for (char c : S) {\\n                if (c == \\'D\\') {\\n                    ++d;\\n                    partial_sum(arr.rbegin() + i, arr.rend() - d, arr.rbegin() + i, func);\\n                } else {\\n                    ++i;\\n                    partial_sum(arr.begin() + d, arr.end() - i, arr.begin() + d, func);\\n                }\\n            }\\n            return *(arr.begin() + d);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numPermsDISequence(string S) {\\n            int n = S.size() + 1, d = 0, i = 0;\\n            vector<int> arr(n, 1);\\n            auto func = [](int a, int b) { return (a + b) % 1000000007; }",
                "codeTag": "Java"
            },
            {
                "id": 168477,
                "title": "c-dp-solution-o-n-3-can-modify-to-o-n-2-with-some-thinking-process",
                "content": "It\\'s a \\'find a pattern\\' problem, but when you try to generate a dp formular, you first try to find a recursion formular. \\nIt basically uses an idea of mapping, if you use a 0, and you can reuse the result of 01234(for some thing like 4 char S \"DIDI\") as the result of 12345 (for some thing like 4 char S \"DIDI\") as the have same increase decrease pattern. So IDID  can be recusivaly caculated by I + DID.  You just think every possible starting num and find the correct count recusively.\\nThen you probably just want to find a dp pattern, the rule may change on some corner case as if you currently use a num, your next num (serve as a start num for a subproblem) is limited. But they do have a general pattern if you write down a 2d dp. I use a 2D dp and do it backward base on my recusion idea. You can presum or sum in for loop but I just leave it N^3.\\n```\\nint numPermsDISequence(string S) {\\n    \\n    vector<vector<long>> dp(S.size()+1,vector<long>(S.size(),0));\\n    int m = 1000000007;\\n    int n = S.size();\\n    \\n    if (S[n-1] == \\'D\\') {\\n        dp[0][n-1] = 0;\\n        dp[1][n-1] = 1;\\n    } else {\\n        dp[0][n-1] = 1;\\n        dp[1][n-1] = 0;\\n    }\\n    \\n    for (int j = n-2; j >= 0; j--) {\\n        if (S[j] == \\'D\\') {\\n            for (int i = 0; i <= n-j; i++) {\\n                for (int k = 0; k < i; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i <= n-j ; i++) {\\n                for (int k = i; k < n-j; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n    }\\n    \\n    long result = 0;\\n    for (int i = 0; i <= n; i++) {\\n        result += dp[i][0];\\n        result %= m;\\n    }\\n    \\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numPermsDISequence(string S) {\\n    \\n    vector<vector<long>> dp(S.size()+1,vector<long>(S.size(),0));\\n    int m = 1000000007;\\n    int n = S.size();\\n    \\n    if (S[n-1] == \\'D\\') {\\n        dp[0][n-1] = 0;\\n        dp[1][n-1] = 1;\\n    } else {\\n        dp[0][n-1] = 1;\\n        dp[1][n-1] = 0;\\n    }\\n    \\n    for (int j = n-2; j >= 0; j--) {\\n        if (S[j] == \\'D\\') {\\n            for (int i = 0; i <= n-j; i++) {\\n                for (int k = 0; k < i; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        } else {\\n            for (int i = 0; i <= n-j ; i++) {\\n                for (int k = i; k < n-j; k++) {\\n                    dp[i][j] += dp[k][j+1];\\n                    dp[i][j] %= m;\\n                }\\n            }\\n        }\\n    }\\n    \\n    long result = 0;\\n    for (int i = 0; i <= n; i++) {\\n        result += dp[i][0];\\n        result %= m;\\n    }\\n    \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168384,
                "title": "c-o-n-2-solution-with-only-one-1d-array-extremely-intuitive-detailed-thought-process",
                "content": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int MOD = 1e9 + 7;\\n        deque<int> memo;\\n        memo.push_back(1);\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'D\\') {\\n                memo.push_back(0);\\n                for (int j = i; j >= 0; j--) {\\n                    memo[j] = (memo[j] + memo[j + 1]) % MOD;\\n                }\\n            } else {\\n                assert(S[i] == \\'I\\');\\n                memo.push_front(0);\\n                for (int j = 1; j <= i + 1; j++) {\\n                    memo[j] = (memo[j] + memo[j - 1]) % MOD;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for (int num: memo) {\\n            sum = (sum + num) % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\nHow you derives the algorithm? Details below.\\n\\n# 1. Determine the parameters for DP\\nLet\\'s say you have already computed numPermsDISequence(3), can you compute numPermsDISequence(4)?\\nWe examine a sequence in numPermsDISequence(3), denoted by [ o o o ]. Imagine there are three pointers pointing to each of the token here. So we want to insert an item into the sequence. Let\\'s say S[4] = \"D\", how many ways can we insert the last item?\\nObviously, this depend on where the last pointer is pointing to. Let\\'s use bold token here to denote the item that the last of the  3 pointers points to, and \"I\" to denote how you insert the 4th item.\\n[ **o** o o ] -> [ I  **o** o o ]       1 way\\n[o **o** o ] -> [ I  o **o** o ]  [ o I **o** o ]       2 ways\\nso on so forth.\\nObviously, the number of ways you can insert the 4th token is dependent on where the 3rd pointer points to. So we need another parameter for DP purpose, which is the index of the last element in the array.\\n\\n# 2. Derive recursive formula\\nNow we have to start from scrach by redefining the function with an additional parameter we just described. Let\\'s say we have numPermsDISequence(3, *j*) for *j* in 0~2, which returns the ways of constructing length=3 sequence whose last element is *j*. For simplicity, Let F(*j*)=numPermsDISequence(3, *j*) and F\\'(*j*)=numPermsDISequence(4, *j*). How do we compute F\\'(*j*)? Again, let\\'s assume S[4] = \"D\".\\n\\nF\\'(0) will produces a sequence of [ I o o o ]. In order for that to happen, the bolden o can be any of the tokens after I. So:\\n\\n[ I **o** o o ]  [ I o **o** o ]  [ I o o  **o** ]\\nF\\'(0) = F(0) + F(1) + F(2)\\n\\nSimilarly, F\\'(1) = F(1) + F(2), F\\'(2) = F(2), F(3) = 0. Note that F(3) = 0 because there is no way you can produce [ o o o I ] no matter what.\\nLet n = 4. You have F\\'(j) = sum(F(k)) for k in j~n. To optimize sum computation, we simply compute from F\\'(n) to F\\'(0), because F\\'(k - 1) = sum( j= k-1 to n) = sum( j = k to n ) + F(k - 1) = F\\'(k) + F(k - 1)\\nIf we already have an array that maintains [ F(0), F(1), F(2) ], for the decreasing case, we only need to append a \"0\" to the **end of the array**, and then recompute F(2) ~ F(0) from **right to left**.\\n[ F(0), F(1), F(2), **F\\'(3) = 0** ]\\n[ F(0), F(1), **F\\'(3) + F(2)**, 0 ]\\n[ F(0), **F\\'(2) + F(1)**, F\\'(3) + F(2), 0 ]\\n[ **F\\'(1) + F(0)**, F\\'(2) + F(1), F\\'(3) + F(2), 0 ]\\n\\nWhen S[4] = \"I\". We simply mirror everything. We will push a 0 in the **start of the array** and then update sums from **left to right**.\\n\\nWe need a data structure to insert/remove an item at the beginning/end of array in O(1) time, and random access in O(1) time. Dynamic array will satisfy this requirement, which is deque in c++.\\n\\n# 3. Compute the result\\n\\nAt the end of the algorithm, numPermsDISequence(4) is simply ways of constructing arrays that the last element end in either 0, 1, 2 or 3. So result(4) = F\\'(0) + F\\'(1) + F\\'(2) + F\\'(3). We can use std::accumulate but due to the MOD requirement we have to compute it manually:(",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numPermsDISequence(string S) {\\n        int MOD = 1e9 + 7;\\n        deque<int> memo;\\n        memo.push_back(1);\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'D\\') {\\n                memo.push_back(0);\\n                for (int j = i; j >= 0; j--) {\\n                    memo[j] = (memo[j] + memo[j + 1]) % MOD;\\n                }\\n            } else {\\n                assert(S[i] == \\'I\\');\\n                memo.push_front(0);\\n                for (int j = 1; j <= i + 1; j++) {\\n                    memo[j] = (memo[j] + memo[j - 1]) % MOD;\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for (int num: memo) {\\n            sum = (sum + num) % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168300,
                "title": "dynamic-programming-o-n-3-solution",
                "content": "Use a helper function helper(start, end) to record the intermediate result in range [start... end]\\n```\\npublic class Solution {\\n    private static final int MOD = (int)1e9 + 7;\\n    private long[][] mem, c;\\n    private int n;\\n    public int numPermsDISequence(String S) {\\n        n = S.length();\\n        mem = new long[n + 1][n + 1];\\n        c = new long[n + 1][n + 1];\\n        return (int)helper(S, 0, n);\\n    }\\n\\n    private long helper(String s, int start, int end) {\\n        if (start >= end) return 1;\\n        if (mem[start][end] > 0) return mem[start][end];\\n        long res = 0;\\n        for (int i = start; i <= end; ++i) {\\n            boolean leftLess = (i == start) || s.charAt(i - 1) == \\'I\\';\\n            boolean rightLess = (i == end) || s.charAt(i) == \\'D\\';\\n            if (leftLess && rightLess) {\\n                long leftRes = helper(s, start, i - 1), rightRes = helper(s, i + 1, end);\\n                long prod = (leftRes * rightRes) % MOD;\\n                res += Comb(end - start, i - start) * prod;\\n                res %= MOD;\\n            }\\n        }\\n        return mem[start][end] = res;\\n    }\\n\\n    private long Comb(int n, int k) {\\n        if (k == 0 || n == k) return 1;\\n        if (c[n][k] > 0) return c[n][k];\\n        if (n == k) return 1;\\n        return c[n][k] = (Comb(n - 1, k - 1) + Comb(n - 1, k)) % MOD;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private static final int MOD = (int)1e9 + 7;\\n    private long[][] mem, c;\\n    private int n;\\n    public int numPermsDISequence(String S) {\\n        n = S.length();\\n        mem = new long[n + 1][n + 1];\\n        c = new long[n + 1][n + 1];\\n        return (int)helper(S, 0, n);\\n    }\\n\\n    private long helper(String s, int start, int end) {\\n        if (start >= end) return 1;\\n        if (mem[start][end] > 0) return mem[start][end];\\n        long res = 0;\\n        for (int i = start; i <= end; ++i) {\\n            boolean leftLess = (i == start) || s.charAt(i - 1) == \\'I\\';\\n            boolean rightLess = (i == end) || s.charAt(i) == \\'D\\';\\n            if (leftLess && rightLess) {\\n                long leftRes = helper(s, start, i - 1), rightRes = helper(s, i + 1, end);\\n                long prod = (leftRes * rightRes) % MOD;\\n                res += Comb(end - start, i - start) * prod;\\n                res %= MOD;\\n            }\\n        }\\n        return mem[start][end] = res;\\n    }\\n\\n    private long Comb(int n, int k) {\\n        if (k == 0 || n == k) return 1;\\n        if (c[n][k] > 0) return c[n][k];\\n        if (n == k) return 1;\\n        return c[n][k] = (Comb(n - 1, k - 1) + Comb(n - 1, k)) % MOD;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035286,
                "title": "p23-5",
                "content": "Puting n-1 and then putting nth\\nLet\\'s change the definition of dp matrix to make the calculation simple: let\\'s say dp[i][j] represents the number of permutation of number 0, 1, ... , i which ends with j. Also, it represents the answer of s.substring(0, i) which ends with j.\\nWe will have two conditions:\\n\\ns.charAt(i - 1) == \\'I\\': In this case, dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1]).\\ns.charAt(i - 1) == \\'D\\': In this case, dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1]).\\nImagine each time when appending the j to the previous permutations, you have to add 1 to each number in the previous permutation which is greater than or equals to j. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation (1, 0, 3, 2). We are trying to append 2. Now the (1, 0, 3, 2) changes to (1, 0, 4, 3) then appended with a 2. We have (1, 0, 4, 3, 2). Although the values change but the order and count don\\'t change.\\nWhy in case of D, <=l is used explanation\\nMethod:\\nstep 1.\\nfor the original permutation 1032, we add 1 to the digits that are larger than or equal to 2.\\n\\n1032->1043\\n  ^^\\nstep 2.\\nthen directly append 2 to 1043, i.e., 1043 -> 10432\\n\\nRemark on step 1:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival 2.\\n(2) More importantly, such operation on the digits will not break the original DI-rule. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward, you can validate yourself.",
                "solutionTags": [],
                "code": "Puting n-1 and then putting nth\\nLet\\'s change the definition of dp matrix to make the calculation simple: let\\'s say dp[i][j] represents the number of permutation of number 0, 1, ... , i which ends with j. Also, it represents the answer of s.substring(0, i) which ends with j.\\nWe will have two conditions:\\n\\ns.charAt(i - 1) == \\'I\\': In this case, dp[i][j] = sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1]).\\ns.charAt(i - 1) == \\'D\\': In this case, dp[i][j] = sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1]).\\nImagine each time when appending the j to the previous permutations, you have to add 1 to each number in the previous permutation which is greater than or equals to j. In this way, we keep the orders and counts of previous permutations and cumulate.\\n\\neg. We already have permutation (1, 0, 3, 2). We are trying to append 2. Now the (1, 0, 3, 2) changes to (1, 0, 4, 3) then appended with a 2. We have (1, 0, 4, 3, 2). Although the values change but the order and count don\\'t change.\\nWhy in case of D, <=l is used explanation\\nMethod:\\nstep 1.\\nfor the original permutation 1032, we add 1 to the digits that are larger than or equal to 2.\\n\\n1032->1043\\n  ^^\\nstep 2.\\nthen directly append 2 to 1043, i.e., 1043 -> 10432\\n\\nRemark on step 1:\\n(1) By performing add operation, 2 in the original permutation now becomes 3, and thus there is no duplicate element for the new arrival 2.\\n(2) More importantly, such operation on the digits will not break the original DI-rule. e.g., 1043 still keeps its old DI-rule, i.e., \"DID\". The proof is straight-forward, you can validate yourself.",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565857,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            },
            {
                "id": 1570469,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            },
            {
                "id": 1568500,
                "content": [
                    {
                        "username": "quadpixels",
                        "content": "After viewing the topics on this page I came to realize that one nice property of this problem is if we _increment elements that are greater than or equal to a certain value_ the D or I property will not be broken, as this only makes \"larger\" elements even larger.\\n\\nThis can be visualized by imagining cutting a piece of paper with the elements plotted on it, with the X axis being the index in a sequence, and the Y axis being the actual value, and then separate the two parts, as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/quadpixels/image_1536661881.png)\\n\\nImagine cutting a piece of paper with this plot on it along the blue lines and separate the two parts, and adding a new element to the end ------\\n\\nA _GIF_ version may be seen here: (it seems LeetCode discussion boards do not allow directly posting GIFs) [https://imgur.com/a/y5MreX8](https://imgur.com/a/y5MreX8)\\n\\n\\nFrom this point, it is easier to see where the dynamic programming essence comes in. Basically the number of solutions with length N+1 depends on, and can be derived from, the number of solutions with length N, as follows:\\n* We increment all elements that are greater than or equal to 0, and see if we can append 0 to the end of the sequence.\\n* We increment all elements that are greater than or equal to 1, and see if we can append 1 to the end of the sequence.\\n* ...\\n* We increment all elements that are greater than or equal to N+1, and see if we can append N+1 to the end of the sequence.\\n\\nThus the dynamic programming pattern.\\n(:"
                    },
                    {
                        "username": "orioncyngus",
                        "content": "lee215 had a different definition for dp[i][j], but it would be very unlikely for me to come up with his definition, so instead, I looked at the solutions that I think I could (or be more inclined to) have come up with in: \\n\\n(1) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/196939/Easy-to-understand-solution-with-detailed-explanation\\n\\nand\\n\\n(2) https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168612/Top-down-with-Memo-greater-Bottom-up-DP-greater-N3-DP-greater-N2-DP-greater-O(N)-space\\n\\n\\nIn both of these links `dp[i][j]` is defined as the number of permutations for `{0,1,..,i}` that ends in `j` that satisfies `s[0:i-1]`.\\n\\nAnd the transition function is:\\nif(s[i - 1] == \"I\") dp[i][j] = sum(dp[i-1][k]) from k = 0...j-1\\nif(s[i - 1] == \"D\") dp[i][j] = sum(dp[i-1][k]) from k = j...i-1\\n\\nI understand the idea of adding ones to all values `>= j` in the permutations for `dp[i-1][k]` and then appending `j`. I understand that this gives us valid permutations for `dp[i][j]` and that all the permutations in `dp[i-1][k]` are disjoint and hence summable. What I don\\'t understand is why this is sufficient? That is, how does this include all possible valid permutations? I have not seen a discussion that demonstrates why this transition function is sufficient. \\n\\nAt first, I thought perhaps the validity follows by induction, but by \"adding ones,\" I don\\'t think the proof can follow by induction, so I\\'m lost as to how to show this transition function is correct. \\n\\n"
                    },
                    {
                        "username": "lcgod",
                        "content": "![image](https://assets.leetcode.com/users/images/714aed02-bdd4-4bc9-8643-05ac27073110_1609729667.0158942.png)\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Matrix Block Sum",
        "question_content": "<p>Given a <code>m x n</code> matrix <code>mat</code> and an integer <code>k</code>, return <em>a matrix</em> <code>answer</code> <em>where each</em> <code>answer[i][j]</code> <em>is the sum of all elements</em> <code>mat[r][c]</code> <em>for</em>:</p>\n\n<ul>\n\t<li><code>i - k &lt;= r &lt;= i + k,</code></li>\n\t<li><code>j - k &lt;= c &lt;= j + k</code>, and</li>\n\t<li><code>(r, c)</code> is a valid position in the matrix.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n<strong>Output:</strong> [[12,21,16],[27,45,33],[24,39,28]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2\n<strong>Output:</strong> [[45,45,45],[45,45,45],[45,45,45]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;mat.length</code></li>\n\t<li><code>n ==&nbsp;mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n, k &lt;= 100</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 477041,
                "title": "java-prefix-sum-with-picture-explain-clean-code-o-m-n",
                "content": "**Similar problems:**\\n- [304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/discuss/572648/Java-Prefix-sum-with-Picture-explain-Clean-code)\\n- [1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold](https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold)\\n\\n**Image Explain**\\n![image](https://assets.leetcode.com/users/hiepit/image_1578762431.png)\\n\\n```java\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length, n = mat[0].length;\\n        int[][] sum = new int[m + 1][n + 1]; // sum[i][j] is sum of all elements from rectangle (0,0,i,j) as left, top, right, bottom corresponding\\n        for (int r = 1; r <= m; r++) {\\n            for (int c = 1; c <= n; c++) {\\n                sum[r][c] = mat[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];\\n            }\\n        }\\n        int[][] ans = new int[m][n];\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int r1 = Math.max(0, r - K), c1 = Math.max(0, c - K);\\n                int r2 = Math.min(m - 1, r + K), c2 = Math.min(n - 1, c + K);\\n                r1++; c1++; r2++; c2++; // Since `sum` start with 1 so we need to increase r1, c1, r2, c2 by 1\\n                ans[r][c] = sum[r2][c2] - sum[r2][c1-1] - sum[r1-1][c2] + sum[r1-1][c1-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Complexity:**\\n- Time: O(m\\\\*n), `m` is the number of rows, `n` is the number of columns of `mat`\\n- Space: O(m\\\\*n)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length, n = mat[0].length;\\n        int[][] sum = new int[m + 1][n + 1]; // sum[i][j] is sum of all elements from rectangle (0,0,i,j) as left, top, right, bottom corresponding\\n        for (int r = 1; r <= m; r++) {\\n            for (int c = 1; c <= n; c++) {\\n                sum[r][c] = mat[r - 1][c - 1] + sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];\\n            }\\n        }\\n        int[][] ans = new int[m][n];\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int r1 = Math.max(0, r - K), c1 = Math.max(0, c - K);\\n                int r2 = Math.min(m - 1, r + K), c2 = Math.min(n - 1, c + K);\\n                r1++; c1++; r2++; c2++; // Since `sum` start with 1 so we need to increase r1, c1, r2, c2 by 1\\n                ans[r][c] = sum[r2][c2] - sum[r2][c1-1] - sum[r1-1][c2] + sum[r1-1][c1-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500833,
                "title": "c-prefix-sum-with-explanation",
                "content": "This question is similar to a vector segment sum. \\n\\nTo extract sum of an arbitrary sub-array, we first form a prefix sum array.\\n[1, 2, 3, 4, 5] // original vector\\n[1, 3, 6, 10, 15] // prefix sum\\n\\nTo get sum of a sub array from index a to index b, sum(a, b), we can instead calculate prefix(b) - prefix(a-1)\\n\\nSimilar in 2D, we form prefix matrix, where sum[i][j] = sum of elements on top left of original matrix\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\n\\n[1, 3, 6]\\n[5, 12, 21]\\n[12, 27, 45]\\n\\nSimilarly, Sum of an arbitrary block from (i-K, j-K) to (i+K, j+K)\\nans(i, j) = prefix(i+K, j+K) - prefix(i+K, j-K-1) - prefix (i-K-1, j+K) + prefix(i-K-1, j-K-1);\\n\\n```\\nclass Solution {\\npublic: \\n    int sizeX, sizeY;\\n    int extractSum(int i, int j, const vector<vector<int> >& sum) {\\n        if (i < 0 || j < 0) return 0;\\n        if (i >= sizeX) i = sizeX - 1;\\n        if (j >= sizeY) j = sizeY - 1;\\n        return sum[i][j];\\n    }\\n        \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        sizeX = mat.size();\\n        sizeY = mat[0].size();\\n        \\n        vector<vector<int>> sum(sizeX, vector<int>(sizeY, 0));\\n        // Calculate prefix matrix \\n        for (int i = 0; i < sizeX; i++) {\\n            for (int j = 0; j < sizeY; j++) {\\n                sum[i][j] = mat[i][j] + extractSum(i-1, j, sum) + extractSum(i, j-1, sum) - extractSum(i-1, j-1, sum);\\n            }\\n        }\\n        \\n        // Use prefix matrix to calculate our sum\\n        vector<vector<int>> ans(sizeX, vector<int>(sizeY, 0));\\n        for (int i = 0; i < sizeX; i++) {\\n            for (int j = 0; j < sizeY; j++) {\\n                ans[i][j] = extractSum(i+K, j+K, sum) - extractSum(i+K, j-K-1,sum) - extractSum (i-K-1, j+K, sum) + extractSum(i-K-1, j-K-1, sum);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: \\n    int sizeX, sizeY;\\n    int extractSum(int i, int j, const vector<vector<int> >& sum) {\\n        if (i < 0 || j < 0) return 0;\\n        if (i >= sizeX) i = sizeX - 1;\\n        if (j >= sizeY) j = sizeY - 1;\\n        return sum[i][j];\\n    }\\n        \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        sizeX = mat.size();\\n        sizeY = mat[0].size();\\n        \\n        vector<vector<int>> sum(sizeX, vector<int>(sizeY, 0));\\n        // Calculate prefix matrix \\n        for (int i = 0; i < sizeX; i++) {\\n            for (int j = 0; j < sizeY; j++) {\\n                sum[i][j] = mat[i][j] + extractSum(i-1, j, sum) + extractSum(i, j-1, sum) - extractSum(i-1, j-1, sum);\\n            }\\n        }\\n        \\n        // Use prefix matrix to calculate our sum\\n        vector<vector<int>> ans(sizeX, vector<int>(sizeY, 0));\\n        for (int i = 0; i < sizeX; i++) {\\n            for (int j = 0; j < sizeY; j++) {\\n                ans[i][j] = extractSum(i+K, j+K, sum) - extractSum(i+K, j-K-1,sum) - extractSum (i-K-1, j+K, sum) + extractSum(i-K-1, j-K-1, sum);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482730,
                "title": "python-js-go-c-o-m-n-integral-image-dp-w-explanation",
                "content": "O( m*n ) sol. based on integral image technique ( 2D DP ).\\n\\n---\\n\\n**Explanation on integral image**:\\n\\nHere we use the technique of **integral image**, which is introduced to **speed up block computation**.\\n\\nAlso, this technique is practical and common in the field of matrix operation and image processing such as [filtering](https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3) and feature extraction.\\n\\nBlock sum formula on integral image.\\n **Block-sum** of **red rectangle** = **block-sum of D - block-sum of B - block-sum of C + block-sum of A**\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1579243522.png)\\n\\n---\\n\\n**Example** of integral image ( focus on the purple block ).\\n\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1579244254.png)\\n\\n\\n---\\n\\n**Implementation**:\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n\\n        # building integral image to speed up block sum computation\\n        for y in range(0, h):\\n            summation = 0\\n            \\n            for x in range(0, w):\\n                summation += mat[y][x]\\n                integral_image[y][x] = summation\\n                \\n                if y > 0:\\n                    integral_image[y][x] += integral_image[y-1][x]\\n        \\n        \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar matrixBlockSum = function(mat, k) {\\n    \\n    let [h, w] = [ mat.length, mat[0].length ];\\n    \\n    let integralImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    let outputImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for( let y = 0 ; y < h ; y++){\\n        let pixelSum = 0;\\n        \\n        for( let x = 0 ; x < w ;x++){\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if( y > 0 ){ \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for( let y = 0 ; y < h ; y++){\\n        \\n        let [minRow, maxRow] = [ Math.max(0, y-k), Math.min(h-1, y+k)];\\n        \\n        for( let x = 0 ; x < w ;x++){\\n            \\n            let [minCol, maxCol] = [ Math.max(0, x-k), Math.min(w-1, x+k)];\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n            \\n            \\n        }\\n    }\\n        \\n    return outputImg;\\n    \\n    \\n};\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\n    const int h = mat.size(), w = mat[0].size();\\n    \\n    vector< vector<int> > integralImg = vector< vector<int> >(h, vector< int >(w, 0) );\\n    vector< vector<int> > outputImg = vector< vector<int> >(h, vector< int >(w, 0) );\\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for( int y = 0 ; y < h ; y++){\\n        int pixelSum = 0;\\n        \\n        for( int x = 0 ; x < w ;x++){\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if( y > 0 ){ \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for( int y = 0 ; y < h ; y++){\\n        \\n        const int minRow = max(0, y-k), maxRow = min(h-1, y+k);\\n        \\n        for( int x = 0 ; x < w ;x++){\\n            \\n            const int minCol = max(0, x-k), maxCol = min(w-1, x+k);\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n        }\\n    }\\n        \\n    return outputImg;        \\n    }\\n};\\n```\\n\\n---\\n\\n**Go**:\\n\\n```\\nfunc create2DArray( h, w int) [][]int{\\n    \\n    matrix  := make( [][]int, h )\\n    row := make( []int, h * w)\\n    \\n    for y := 0 ; y < h ; y++{\\n        matrix[ y ] = row[ y*w : (y+1)*w ] \\n    }\\n    \\n    return matrix\\n}\\n\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n\\n\\nfunc matrixBlockSum(mat [][]int, k int) [][]int {\\n    \\n    h, w := len(mat), len(mat[0])\\n    \\n    integralImg  := create2DArray(h, w)\\n    outputImg := create2DArray(h, w)\\n    \\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for y := 0 ; y < h ; y++{\\n        pixelSum := 0;\\n        \\n        for  x := 0 ; x < w ;x++{\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if y > 0 { \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for y := 0 ; y < h ; y++{\\n        \\n        minRow := max(0, y-k)\\n        maxRow := min(h-1, y+k)\\n        \\n        for x := 0 ; x < w ;x++ {\\n            \\n            minCol := max(0, x-k)\\n            maxCol := min(w-1, x+k)\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n        }\\n    }\\n        \\n    return outputImg;        \\n    \\n\\n}\\n```\\n\\n---\\n\\nShare another implementation with update function in bottom-up\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        #-----------------------------------------\\n        def update(x, y):\\n            \\n            # add current pixel\\n            result = mat[y][x]\\n            \\n            if x:\\n                # add integral image of left pixel\\n                result += integral_image[y][x-1]\\n            \\n            if y:\\n                # add integral image of top pixel\\n                result +=  integral_image[y-1][x]\\n\\n            if x and y:\\n                # remove repeated part of top-left pixel\\n                result -=  integral_image[y-1][x-1]\\n            \\n            return result\\n        \\n        # ----------------------------------------\\n        # building integral image to speed up block sum computation\\n        for y in range(0, h):\\n            for x in range(0, w):\\n                integral_image[y][x] = update(x, y)\\n                \\n                \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\\n\\n</details>\\n\\n---\\n\\n**Implentation** with integral image building in top-down DP \\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        #-----------------------------------------\\n        def build_integral_image(x, y):\\n            \\n            if (x < 0) or (y < 0):\\n                \\n                ## base case:\\n                # zero for those pixels out of valid boundary\\n                return 0\\n            \\n            if integral_image[y][x]:\\n                ## base case:\\n                # direcly look-up table\\n                return integral_image[y][x]\\n            \\n            ## general cases\\n            # comptue and update integral image at (x, y)\\n            \\n            integral_image[y][x] = mat[y][x] + build_integral_image(x, y-1) + build_integral_image(x-1, y) - build_integral_image(x-1, y-1)\\n            \\n            return integral_image[y][x]\\n        \\n        # ----------------------------------------\\n        # building integral image to speed up block sum computation\\n        build_integral_image(w-1, h-1)\\n                \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\\n\\n</details>\\n\\n---\\n\\nRelated leetcode challenge:\\n[Leetcode #304 Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/)\\n\\n[Leetcode #303 Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable/)\\n\\n---\\n\\nReference:\\n[Integral Image in wikipedia](https://en.wikipedia.org/wiki/Summed-area_table)\\n\\n---\\n\\nFurther reading:\\n[1] [Integral Image in OpenCV API](https://docs.opencv.org/master/d5/de6/group__cudaarithm__reduce.html#ga07e5104eba4bf45212ac9dbc5bf72ba6)\\n\\n[2] [ImageJ: Integral Image Filter](https://imagej.net/Integral_Image_Filters)\\n\\n---\\n\\nThanks for your reading.\\n\\nWish you have a nice day.\\n\\nMeow~\\uD83D\\uDE3A",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n\\n        # building integral image to speed up block sum computation\\n        for y in range(0, h):\\n            summation = 0\\n            \\n            for x in range(0, w):\\n                summation += mat[y][x]\\n                integral_image[y][x] = summation\\n                \\n                if y > 0:\\n                    integral_image[y][x] += integral_image[y-1][x]\\n        \\n        \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\n```\\nvar matrixBlockSum = function(mat, k) {\\n    \\n    let [h, w] = [ mat.length, mat[0].length ];\\n    \\n    let integralImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    let outputImg = new Array(h).fill(0).map( () => new Array(w).fill(0) );\\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for( let y = 0 ; y < h ; y++){\\n        let pixelSum = 0;\\n        \\n        for( let x = 0 ; x < w ;x++){\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if( y > 0 ){ \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for( let y = 0 ; y < h ; y++){\\n        \\n        let [minRow, maxRow] = [ Math.max(0, y-k), Math.min(h-1, y+k)];\\n        \\n        for( let x = 0 ; x < w ;x++){\\n            \\n            let [minCol, maxCol] = [ Math.max(0, x-k), Math.min(w-1, x+k)];\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n            \\n            \\n        }\\n    }\\n        \\n    return outputImg;\\n    \\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\n    const int h = mat.size(), w = mat[0].size();\\n    \\n    vector< vector<int> > integralImg = vector< vector<int> >(h, vector< int >(w, 0) );\\n    vector< vector<int> > outputImg = vector< vector<int> >(h, vector< int >(w, 0) );\\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for( int y = 0 ; y < h ; y++){\\n        int pixelSum = 0;\\n        \\n        for( int x = 0 ; x < w ;x++){\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if( y > 0 ){ \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for( int y = 0 ; y < h ; y++){\\n        \\n        const int minRow = max(0, y-k), maxRow = min(h-1, y+k);\\n        \\n        for( int x = 0 ; x < w ;x++){\\n            \\n            const int minCol = max(0, x-k), maxCol = min(w-1, x+k);\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n        }\\n    }\\n        \\n    return outputImg;        \\n    }\\n};\\n```\n```\\nfunc create2DArray( h, w int) [][]int{\\n    \\n    matrix  := make( [][]int, h )\\n    row := make( []int, h * w)\\n    \\n    for y := 0 ; y < h ; y++{\\n        matrix[ y ] = row[ y*w : (y+1)*w ] \\n    }\\n    \\n    return matrix\\n}\\n\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n\\n\\nfunc matrixBlockSum(mat [][]int, k int) [][]int {\\n    \\n    h, w := len(mat), len(mat[0])\\n    \\n    integralImg  := create2DArray(h, w)\\n    outputImg := create2DArray(h, w)\\n    \\n    \\n    \\n    // building integral image to speed up block sum computation\\n    for y := 0 ; y < h ; y++{\\n        pixelSum := 0;\\n        \\n        for  x := 0 ; x < w ;x++{\\n            pixelSum += mat[y][x];\\n            integralImg[y][x] = pixelSum;\\n            \\n            if y > 0 { \\n                integralImg[y][x] += integralImg[y-1][x];\\n            }\\n        }\\n    }\\n    \\n    \\n    // compute block sum by looking-up integral image\\n    for y := 0 ; y < h ; y++{\\n        \\n        minRow := max(0, y-k)\\n        maxRow := min(h-1, y+k)\\n        \\n        for x := 0 ; x < w ;x++ {\\n            \\n            minCol := max(0, x-k)\\n            maxCol := min(w-1, x+k)\\n            \\n            outputImg[y][x] = integralImg[maxRow][maxCol];\\n            \\n            if( minRow > 0 ){\\n                outputImg[y][x] -= integralImg[minRow-1][maxCol];\\n            }\\n            \\n            if( minCol > 0 ){\\n                outputImg[y][x] -= integralImg[maxRow][minCol-1];\\n            }\\n            \\n            if( (minRow > 0) && (minCol > 0) ){\\n                outputImg[y][x] += integralImg[minRow-1][minCol-1];\\n            }\\n        }\\n    }\\n        \\n    return outputImg;        \\n    \\n\\n}\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        #-----------------------------------------\\n        def update(x, y):\\n            \\n            # add current pixel\\n            result = mat[y][x]\\n            \\n            if x:\\n                # add integral image of left pixel\\n                result += integral_image[y][x-1]\\n            \\n            if y:\\n                # add integral image of top pixel\\n                result +=  integral_image[y-1][x]\\n\\n            if x and y:\\n                # remove repeated part of top-left pixel\\n                result -=  integral_image[y-1][x-1]\\n            \\n            return result\\n        \\n        # ----------------------------------------\\n        # building integral image to speed up block sum computation\\n        for y in range(0, h):\\n            for x in range(0, w):\\n                integral_image[y][x] = update(x, y)\\n                \\n                \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n            \\n        h, w = len(mat), len( mat[0])\\n        integral_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        #-----------------------------------------\\n        def build_integral_image(x, y):\\n            \\n            if (x < 0) or (y < 0):\\n                \\n                ## base case:\\n                # zero for those pixels out of valid boundary\\n                return 0\\n            \\n            if integral_image[y][x]:\\n                ## base case:\\n                # direcly look-up table\\n                return integral_image[y][x]\\n            \\n            ## general cases\\n            # comptue and update integral image at (x, y)\\n            \\n            integral_image[y][x] = mat[y][x] + build_integral_image(x, y-1) + build_integral_image(x-1, y) - build_integral_image(x-1, y-1)\\n            \\n            return integral_image[y][x]\\n        \\n        # ----------------------------------------\\n        # building integral image to speed up block sum computation\\n        build_integral_image(w-1, h-1)\\n                \\n        \\n        # compute block sum by looking-up integral image\\n        output_image = [ [ 0 for y in range(w) ] for x in range(h) ]\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                min_row, max_row = max( 0, y-K), min( h-1, y+K)\\n                min_col, max_col = max( 0, x-K), min( w-1, x+K)\\n                \\n                output_image[y][x] = integral_image[max_row][max_col]\\n                \\n                if min_row > 0:\\n                    output_image[y][x] -= integral_image[min_row-1][max_col]\\n                \\n                if min_col > 0:\\n                    output_image[y][x] -= integral_image[max_row][min_col-1]\\n                    \\n                if min_col > 0 and min_row > 0:\\n                    output_image[y][x] += integral_image[min_row-1][min_col-1]\\n                \\n        return output_image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620405,
                "title": "easy-prefix-logic-explanation-with-matrix-example-python-soution",
                "content": "### Explanation:\\n\\nLets consider this Matrix to Explain with visualisation:\\n\\t\\n\\t1,   2,   3\\n\\t4,   5,   6\\n\\t7,   8,   9\\n\\n**Step 1:** Make a prefix-matrix where each row has prefix sum independent of any other row. Matrix will look like this:\\n\\t\\n\\t1,   3,   6\\n\\t4,   9,   15\\n\\t7,   15,  24\\n\\n**i.e.,**\\n\\n\\t1,   1+2,   1+2+3\\n\\t4,   4+5,   4+5+6\\n\\t7,   7+8,   7+8+9\\n\\n**Step 2:** Turn the prefix-matrix from **Step 1**  to another prefix-matrix but now column wise. This shlould be:\\n\\n\\t1,       3,         6\\n\\t1+4,     3+9,       6+15\\n\\t1+4+7,   3+9+15,    6+15+24\\n\\t\\n**i.e,**\\n\\t\\n\\t\\t1,   3,   6\\n\\t\\t5,   12,  21\\n\\t\\t12,  27,  45\\n\\nWhy did we perform above two steps? Must be thinking right? Let me Explain.\\n\\nSuppose we want a sum for the square block of diagonal *[11 to 22]* (as in r1c1 to r2c2) then we need to eliminate the block *[00 to 02]* and *[00 to 20]* from the sum present in last index of the block(we are calculating sum for), which is index *22* with value **45**.  Then add back the block which we eliminated twice, that is *[00 to 00]*. (whole operation is performed using prefix-matrix we generated in **Step 2**). Lets take a visual of what i meant:\\n\\n\\t1,   2,   3\\n\\t4\\n\\t7\\n\\t\\nis the part we need to remove from original matrix to get sum for non x values in:\\n\\n\\tx,   x,   x\\n\\tx,   5,   6\\n\\tx,   8,   9\\n\\n**So we do it by calculating total sum upto index *22* which is 45 (from prefix-matrix):**\\n**sum**=45\\n\\n**Now remove upper block:**\\n**sum**=45-(1+2+3) *(at index 02 in pefix-matrix)* = 39\\n\\n**Now remove left block:** \\n**sum**=39-(1+4+7) *(at index 20 in pefix-matrix)* = 27\\n\\n**As we can see \\'1\\' is removed twice we will add it once to balance:**\\n**sum**=27+(1) *(at index 00 in prefix-matrix)*  = 28 // extra added block can be aquired from position prefix-matrix[r-1][c-1] where r and c are starting index of required bolck whose sum we are calculating for.\\n\\nSo answer is 28 if your block for which sum to be calculated is:\\n\\t\\n\\tx,   x,   x\\n\\tx,   11,  12\\n\\tx,   21,  22\\n\\n### Code:\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        prefMat=[[0 for i in range(n)] for j in range(m)]\\n        #Step 1\\n\\t\\tfor i in range(m):\\n            prefMat[i][0]=mat[i][0]\\n            for j in range(1,n):\\n                prefMat[i][j]=prefMat[i][j-1]+mat[i][j]\\n        #Step 2        \\n        for i in range(n):\\n            prefMat[0][i]=prefMat[0][i]\\n            for j in range(1,m):\\n                prefMat[j][i]=prefMat[j-1][i]+prefMat[j][i]\\n        #Calculate\\n        for i in range(m):\\n            ru=max(i-k,0)\\n            rd=min(i+k,m-1)\\n            for j in range(n):\\n                cl=max(0,j-k)\\n                cr=min(n-1,j+k)\\n                value=prefMat[rd][cr]\\n                if ru-1>=0:\\n                    value-=prefMat[ru-1][cr]\\n                if cl-1>=0:\\n                    value-=prefMat[rd][cl-1]\\n                if ru-1>=0 and cl-1>=0:\\n                    value+=prefMat[ru-1][cl-1]\\n                \\n                mat[i][j]=value\\n        return mat\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        prefMat=[[0 for i in range(n)] for j in range(m)]\\n        #Step 1\\n\\t\\tfor i in range(m):\\n            prefMat[i][0]=mat[i][0]\\n            for j in range(1,n):\\n                prefMat[i][j]=prefMat[i][j-1]+mat[i][j]\\n        #Step 2        \\n        for i in range(n):\\n            prefMat[0][i]=prefMat[0][i]\\n            for j in range(1,m):\\n                prefMat[j][i]=prefMat[j-1][i]+prefMat[j][i]\\n        #Calculate\\n        for i in range(m):\\n            ru=max(i-k,0)\\n            rd=min(i+k,m-1)\\n            for j in range(n):\\n                cl=max(0,j-k)\\n                cr=min(n-1,j+k)\\n                value=prefMat[rd][cr]\\n                if ru-1>=0:\\n                    value-=prefMat[ru-1][cr]\\n                if cl-1>=0:\\n                    value-=prefMat[rd][cl-1]\\n                if ru-1>=0 and cl-1>=0:\\n                    value+=prefMat[ru-1][cl-1]\\n                \\n                mat[i][j]=value\\n        return mat\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549010,
                "title": "c-64-38-time-100-00-space-graph-illustration",
                "content": "I wrote the  [article](https://juejin.im/post/5e78172b51882549194990d6) in Chinese as well. \\n\\n---\\n\\n`mat[r][c] for i - K <= r <= i + K, j - K <= c <= j + K, and (r, c) is a valid position in the matrix` is actually a square centered at `(i,j)` and has side length of `2K+1`.  if `r < 0 ` or `r >= m`, `c < 0` or `c >= n`, it could become a rectangle or a smaller square.\\n\\nBelow is an example of a 3 * 3 matrix. `K = 1` in this case.\\n![image](https://assets.leetcode.com/users/oliwang/image_1584967433.png)\\n\\nSo, how can we find a uniform way to calculate the sum of the yellow cells? This is when I remembered prefix sum. Generating a prefix sum array for a 1D array is quite straight forward. In a 2D array, the calculation is slightly different. The value of `prefix_sum[i][j]` is the sum of the values in the rectangle where `(i,j)` and `(0,0)` are the two opposite corners.  This will help us avoid most of the repeating calculation.\\n\\nHaving calculated the prefix sum matrix, our problem becomes `prefix_sum[i+K][j+K]` minus the blue squares in the below graph. For example, `answer[2][2] = prefix_sum[2][2] - prefix_sum[0][2]-prefix_sum[2][0] + prefix_sum[0][0]`.\\n\\n![image](https://assets.leetcode.com/users/oliwang/image_1584968690.png)\\n\\n``` c++\\n\\n#include<iostream>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        vector<vector<int>> prefix_sum = prefixSum(mat);\\n        vector<vector<int>> answer = prefix_sum;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                int upper_i = ((i+K) >= mat.size()) ? (mat.size()-1) : (i+K);\\n                int upper_j = ((j+K) >= mat[0].size()) ? (mat[0].size()-1) : (j+K);\\n                \\n                int lower_i = ((i-K) <= 0 ) ? 0 : (i-K);\\n                int lower_j = ((j-K) <= 0 ) ? 0 : (j-K);\\n            \\n                \\n                answer[i][j] = prefix_sum[upper_i][upper_j] - ((lower_i == 0) ? 0 : prefix_sum[lower_i-1][upper_j]) - ((lower_j == 0) ? 0 : prefix_sum[upper_i][lower_j-1]) + ((lower_i == 0) || (lower_j == 0)  ? 0 : prefix_sum[lower_i-1][lower_j-1]);\\n            }\\n        }\\n    \\n        \\n        return answer;\\n        \\n    }\\n    \\n    vector<vector<int>> prefixSum(vector<vector<int>>& mat) {\\n        vector<vector<int>> prefix_sum = mat;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            int sum = 0;\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                sum = sum + mat[i][j];\\n                if (i > 0) {\\n                    prefix_sum[i][j] = sum + prefix_sum[i-1][j];\\n                } else {\\n                    prefix_sum[i][j] = sum;   \\n                }\\n            }\\n        }\\n        \\n        return prefix_sum;\\n    }\\n\\n};\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "``` c++\\n\\n#include<iostream>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        vector<vector<int>> prefix_sum = prefixSum(mat);\\n        vector<vector<int>> answer = prefix_sum;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                int upper_i = ((i+K) >= mat.size()) ? (mat.size()-1) : (i+K);\\n                int upper_j = ((j+K) >= mat[0].size()) ? (mat[0].size()-1) : (j+K);\\n                \\n                int lower_i = ((i-K) <= 0 ) ? 0 : (i-K);\\n                int lower_j = ((j-K) <= 0 ) ? 0 : (j-K);\\n            \\n                \\n                answer[i][j] = prefix_sum[upper_i][upper_j] - ((lower_i == 0) ? 0 : prefix_sum[lower_i-1][upper_j]) - ((lower_j == 0) ? 0 : prefix_sum[upper_i][lower_j-1]) + ((lower_i == 0) || (lower_j == 0)  ? 0 : prefix_sum[lower_i-1][lower_j-1]);\\n            }\\n        }\\n    \\n        \\n        return answer;\\n        \\n    }\\n    \\n    vector<vector<int>> prefixSum(vector<vector<int>>& mat) {\\n        vector<vector<int>> prefix_sum = mat;\\n        \\n        for (int i = 0; i < mat.size(); i++) {\\n            int sum = 0;\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                sum = sum + mat[i][j];\\n                if (i > 0) {\\n                    prefix_sum[i][j] = sum + prefix_sum[i-1][j];\\n                } else {\\n                    prefix_sum[i][j] = sum;   \\n                }\\n            }\\n        }\\n        \\n        return prefix_sum;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 821782,
                "title": "c-98-faster-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        vector<vector<int> > dp(matrix.size()+1,vector<int>(matrix[0].size()+1,0));\\n        //build the dp vector\\n        \\n        for (int i = 1; i < dp.size(); i++) {\\n            for (int j = 1; j < dp[0].size(); j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        \\n        \\n        //the result vector we are going to return\\n        vector<vector<int>> ans(matrix.size(),vector<int>(matrix[0].size(),0));\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                int m=matrix.size();\\n                int n=matrix[i].size();\\n                int r1=max(0,i-k)+1; //starting row coordinate of the block\\n                int c1=max(0,j-k)+1; //starting column coordinate of the block\\n                int r2= min(i+k+1,m); //ending row coordinate of the block\\n                int c2= min(j+k+1,n); // ending column coordinate of the block\\n                \\n                ans[i][j]=dp[r2][c2]+dp[r1-1][c1-1]-dp[r1-1][c2]-dp[r2][c1-1]; //value of the block calculated with the dp vector built\\n                \\n            }\\n        }\\n      return ans;  \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        vector<vector<int> > dp(matrix.size()+1,vector<int>(matrix[0].size()+1,0));\\n        //build the dp vector\\n        \\n        for (int i = 1; i < dp.size(); i++) {\\n            for (int j = 1; j < dp[0].size(); j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        \\n        \\n        //the result vector we are going to return\\n        vector<vector<int>> ans(matrix.size(),vector<int>(matrix[0].size(),0));\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                int m=matrix.size();\\n                int n=matrix[i].size();\\n                int r1=max(0,i-k)+1; //starting row coordinate of the block\\n                int c1=max(0,j-k)+1; //starting column coordinate of the block\\n                int r2= min(i+k+1,m); //ending row coordinate of the block\\n                int c2= min(j+k+1,n); // ending column coordinate of the block\\n                \\n                ans[i][j]=dp[r2][c2]+dp[r1-1][c1-1]-dp[r1-1][c2]-dp[r2][c1-1]; //value of the block calculated with the dp vector built\\n                \\n            }\\n        }\\n      return ans;  \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627291,
                "title": "detailed-explanation-of-optimal-substructure-and-subproblems-with-example",
                "content": "**Solution#1:** `O(cols * rows^2)` runtime and `O(rows*cols)` space complexity. (I kept the time complexity is little more, so that it\\'s easier to understand)\\n\\n**Idea:**\\n* Maintain a `rowPrefix` 2D array in which `rowPrefix[i][j]` is the prefix sum upto `j`th column in the `i`th row\\n* Now, let\\'s determine `ans[i][j]` (result)\\n* For given `i`, calculate `rowStart` and `rowEnd` (Keeping the validity of ranges according to boundary)\\n* Calculate `colStart` and `colEnd` (Keeping the validity of ranges according to boundary)\\n* iterate from `rowStart` to `rowEnd` and determine the sum of the sub-matrix using the `rowPrefix` submatrix\\n\\nFor example,\\n```\\n1 2 3                       1  (1+2=)3  (1+2+3=) 6\\n4 5 6   =>    rowPrefix =   4  (4+5=)9  (4+5+6=)15\\n7 8 9                       7  (7+8=)15 (7+8+9=)24\\n```\\n\\n```\\npublic int[][] matrixBlockSum(int[][] matrix, int K) {\\n\\tint rows = matrix.length,\\n\\t\\tcols = matrix[0].length;\\n\\n\\tint[][] rowPrefix = new int[rows][cols];\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\trowPrefix[i][j] = (j == 0)\\n\\t\\t\\t\\t? matrix[i][j]\\n\\t\\t\\t\\t: rowPrefix[i][j-1] + matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tint[][] ans = new int[rows][cols];\\n\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint rowStart = Math.max(0, i-K),\\n\\t\\t\\trowEnd = Math.min(rows-1, i+K);\\n\\n\\t\\t// System.out.println(\"rowStart: \" + rowStart + \" rowEnd: \" + rowEnd);\\n\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint colStart = Math.max(0, j-K),\\n\\t\\t\\t\\tcolEnd = Math.min(cols-1, j+K),\\n\\t\\t\\t\\tsum = 0;\\n\\n\\t\\t\\t// System.out.println(\"colStart: \" + colStart + \" colEnd: \" + colEnd);\\n\\t\\t\\tfor (int r = rowStart; r <= rowEnd; r++) {\\n\\t\\t\\t\\tsum += rowPrefix[r][colEnd] - (colStart > 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t? rowPrefix[r][colStart - 1]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: 0);\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(\"sum: \" + sum);\\n\\t\\t\\tans[i][j] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\n**Solution#2:** `O(cols * rows)` runtime and space complexity\\n\\n**Idea:**\\n* Expand the `prefixSum` matrix to contain the sum of all elements in the subarray from `0..i` and `0..j` i.e. `prefixSum[i][j]` = sum of all matrix elements from `[0,0]` to `[i,j]`\\n* For building such a prefixSum for 2D matrix, we will first build a rowPrefix matrix like the approach above, and then on top of it, we will add column prefixes.\\n* After that, let\\'s determine `ans[i][j]` (result)\\n* For given `i`, calculate `rowStart` and `rowEnd` (Keeping the validity of ranges according to boundary)\\n* Calculate `colStart` and `colEnd` (Keeping the validity of ranges according to boundary)\\n* To determine the sum of all elements from `[rowStart, colStart]` to `[rowEnd, colEnd]`, we will do the following:  ``` [rowEnd, colEnd] - [rowStart-1, colEnd] - [rowEnd, colStart-1] - [rowStart-1, colStart-1]```\\n\\t* Basically, we have the sum of submatrix from `[0,0]` to `[rowEnd, colEnd]`  and we are stripping off the upper strip `[rowStart-1, colEnd]` left strip `[rowEnd, colStart-1]`. While doing this, notice that, we subtracted, the sum of submatrix `[0,0]` to `[rowStart-1, colStart-1]` twice. So, we add it back again.\\n\\t* Now, add the boundary line sanitation to above mentioned formula. \\n```\\npublic int[][] matrixBlockSum(int[][] matrix, int K) {\\n\\tint rows = matrix.length,\\n\\t\\tcols = matrix[0].length;\\n\\n\\tint[][] prefixSum = new int[rows][cols];\\n\\n\\t// calculate row prefix sum first\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tprefixSum[i][j] = (j == 0)\\n\\t\\t\\t\\t? matrix[i][j]\\n\\t\\t\\t\\t: prefixSum[i][j-1] + matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\t// calculate the row and column prefix sum on top of row prefix sum\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tprefixSum[i][j] += prefixSum[i-1][j];\\n\\t\\t}\\n\\t}\\n\\n\\tint[][] ans = new int[rows][cols];\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint rowStart = Math.max(i-K, 0),\\n\\t\\t\\trowEnd = Math.min(i+K, rows-1);\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint colStart = Math.max(j-K, 0),\\n\\t\\t\\t\\tcolEnd = Math.min(j+K, cols-1);\\n\\n\\t\\t\\tans[i][j] = prefixSum[rowEnd][colEnd]\\n\\t\\t\\t\\t- (rowStart > 0\\n\\t\\t\\t\\t   ? prefixSum[rowStart - 1][colEnd]\\n\\t\\t\\t\\t   : 0) // upper strip\\n\\t\\t\\t\\t- (colStart > 0\\n\\t\\t\\t\\t  ? prefixSum[rowEnd][colStart - 1]\\n\\t\\t\\t\\t  : 0) // left strip\\n\\t\\t\\t\\t+ (rowStart > 0 && colStart > 0\\n\\t\\t\\t\\t  ? prefixSum[rowStart-1][colStart - 1]\\n\\t\\t\\t\\t  : 0); // left-top corner of the submatrix will be subtracted twice, so adding it once, so that it gets subtracted overall only once.\\n\\n\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\nPhew!! Long post!! If this was helpful to you, please upvote :)",
                "solutionTags": [],
                "code": "```\\n1 2 3                       1  (1+2=)3  (1+2+3=) 6\\n4 5 6   =>    rowPrefix =   4  (4+5=)9  (4+5+6=)15\\n7 8 9                       7  (7+8=)15 (7+8+9=)24\\n```\n```\\npublic int[][] matrixBlockSum(int[][] matrix, int K) {\\n\\tint rows = matrix.length,\\n\\t\\tcols = matrix[0].length;\\n\\n\\tint[][] rowPrefix = new int[rows][cols];\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\trowPrefix[i][j] = (j == 0)\\n\\t\\t\\t\\t? matrix[i][j]\\n\\t\\t\\t\\t: rowPrefix[i][j-1] + matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tint[][] ans = new int[rows][cols];\\n\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint rowStart = Math.max(0, i-K),\\n\\t\\t\\trowEnd = Math.min(rows-1, i+K);\\n\\n\\t\\t// System.out.println(\"rowStart: \" + rowStart + \" rowEnd: \" + rowEnd);\\n\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint colStart = Math.max(0, j-K),\\n\\t\\t\\t\\tcolEnd = Math.min(cols-1, j+K),\\n\\t\\t\\t\\tsum = 0;\\n\\n\\t\\t\\t// System.out.println(\"colStart: \" + colStart + \" colEnd: \" + colEnd);\\n\\t\\t\\tfor (int r = rowStart; r <= rowEnd; r++) {\\n\\t\\t\\t\\tsum += rowPrefix[r][colEnd] - (colStart > 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t? rowPrefix[r][colStart - 1]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: 0);\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(\"sum: \" + sum);\\n\\t\\t\\tans[i][j] = sum;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\n``` [rowEnd, colEnd] - [rowStart-1, colEnd] - [rowEnd, colStart-1] - [rowStart-1, colStart-1]```\n```\\npublic int[][] matrixBlockSum(int[][] matrix, int K) {\\n\\tint rows = matrix.length,\\n\\t\\tcols = matrix[0].length;\\n\\n\\tint[][] prefixSum = new int[rows][cols];\\n\\n\\t// calculate row prefix sum first\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tprefixSum[i][j] = (j == 0)\\n\\t\\t\\t\\t? matrix[i][j]\\n\\t\\t\\t\\t: prefixSum[i][j-1] + matrix[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\t// calculate the row and column prefix sum on top of row prefix sum\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tprefixSum[i][j] += prefixSum[i-1][j];\\n\\t\\t}\\n\\t}\\n\\n\\tint[][] ans = new int[rows][cols];\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint rowStart = Math.max(i-K, 0),\\n\\t\\t\\trowEnd = Math.min(i+K, rows-1);\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint colStart = Math.max(j-K, 0),\\n\\t\\t\\t\\tcolEnd = Math.min(j+K, cols-1);\\n\\n\\t\\t\\tans[i][j] = prefixSum[rowEnd][colEnd]\\n\\t\\t\\t\\t- (rowStart > 0\\n\\t\\t\\t\\t   ? prefixSum[rowStart - 1][colEnd]\\n\\t\\t\\t\\t   : 0) // upper strip\\n\\t\\t\\t\\t- (colStart > 0\\n\\t\\t\\t\\t  ? prefixSum[rowEnd][colStart - 1]\\n\\t\\t\\t\\t  : 0) // left strip\\n\\t\\t\\t\\t+ (rowStart > 0 && colStart > 0\\n\\t\\t\\t\\t  ? prefixSum[rowStart-1][colStart - 1]\\n\\t\\t\\t\\t  : 0); // left-top corner of the submatrix will be subtracted twice, so adding it once, so that it gets subtracted overall only once.\\n\\n\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1521997,
                "title": "python-two-approaches-easy-to-understand-w-explanation",
                "content": "### Approach 1: Brute Force\\n\\nThis is by far the simplest and shortest solution. How it works:\\n\\n- Loop through each ```(x, y)``` coordinate in the resultant array ```result```.\\n- At each ```result[x][y]```, get the appropriate subarray from the matrix ```mat```. I.e., for each ```(x, y)``` in ```result```, get the subarray ```mat[x-k:x+k+1][y-k:y+k+1]```. Then we need to factor in the matrix length and breadth:\\n\\n```python\\ndef getSubarray(mat: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\\n\\t\"\"\"\\n\\tPython pseudocode to obtain the following: mat[x-k:x+k+1][y-k:y+k+1].\\n\\tIf x - k < 0 --> Use index x = 0 instead\\n\\tIf y - k < 0 --> Use index y = 0 instead\\n\\tIf x + k >= len(mat) --> Use index x = len(mat)-1 instead\\n\\tIf y + k >- len(mat[0]) --> Use index y = len(mat[0])-1 instead\\n\\t\"\"\"\\n\\t# We can shorten this to:\\n\\treturn mat[max(x-k, 0):min(x+k+1, len(mat)][max(y-k, 0):min(y+k+1, len(mat[0])]\\n```\\n\\n- Compute the sum of the entire subarray and save into ```result[x][y]```.\\n\\n```python\\ndef sumOfSubarray(arr: List[List[int]]) -> int:\\n\\t\"\"\"\\n\\tPython pseudocode to calculate the sum of all the elements in the given array.\\n\\tresult = 0\\n\\tfor i in range(len(arr)):\\n\\t\\tfor j in range(len(arr[0])):\\n\\t\\t\\tresult += arr[i][j]\\n\\treturn result\\n\\t\"\"\"\\n\\t# We can shorten this to:\\n\\treturn sum(sum(arr[i]) for i in range(len(arr)))\\n```\\n\\nThat\\'s all. You can probably optimise the runtime using sliding window technique, but this approach is the easiest to come up with.\\n\\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        result = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                result[i][j] = sum(sum(mat[x][max(0, j-k):min(n, j+k+1)])\\n                                   for x in range(max(0, i-k), min(m, i+k+1)))\\n        return result\\n```\\n\\nTime Complexity: O(mnk^2), due to the nested sum functions.\\nSpace Complexity: O(1) auxillary space.\\nResult: Almost 2s runtime, 15MB used space. Not great, obviously.\\n\\n---\\n\\n### Approach 2: Prefix Sum\\n\\n[This blog](https://computersciencesource.wordpress.com/2010/09/03/computer-vision-the-integral-image/) describes the algorithm quite well. Essentially the algorithm consists of the following:\\n\\n- On our first pass through the matrix ```mat```, we obtain the cumulative sum of the elements above and to the left of the current element, including the element itself.\\n\\nI.e., for each ```(x, y)``` in ```mat```, we obtain ```sumOfSubarray(mat[:x+1][:y+1])``` (refer to the pseudocode above). The reason why we can do this in one pass is because of DP:\\n\\n```python\\ndef prefixSum(mat: List[List[int]]) -> List[List[int]]:\\n\\t\"\"\"\\n\\tPython pseudocode to obtain the prefix sum of the given array via DP.\\n\\t\"\"\"\\n\\tresult = mat[:][:]  # essentially copies the array\\n\\tfor i in range(len(mat)):\\n\\t\\tfor j in range(len(mat[0])):\\n\\t\\t\\tresult[i][j] += (result[i-1][j] if i > 0 else 0) + \\\\          # add prefix sum of (i-1, j), if it exists\\n\\t\\t\\t\\t\\t\\t\\t(result[i][j-1] if j > 0 else 0) + \\\\          # add prefix sum of (i, j-1), if it exists\\n\\t\\t\\t\\t\\t\\t\\t(result[i-1][j-1] if i > 0 and j > 0 else 0)  # subtract prefix sum of (i-1, j-1), if it exists\\n\\treturn result\\n```\\n\\n- Calculate the block sum at each ```(x, y)``` using the prefix sum.\\n\\nThe prefix sum is optimal for this task because we can actually **calculate the block sum from the prefix sum in O(1) time**, according to the formula ```S(D) + S(A) - S(B) - S(C)```. (Again, refer to [this blog](https://computersciencesource.wordpress.com/2010/09/03/computer-vision-the-integral-image/) for a more detailed explanation.) This ensures our code runs within O(mn) time, even at the cost of having to loop through the matrix again.\\n\\nAgain, we need to account for the matrix borders. Similar to approach 1, we can just replace all nonexistent matrix coordinates with 0, since the matrix ```mat``` only contains positive integers (```1 <= mat[i][j] <= 100```).\\n\\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n\\t\\t\\n\\t\\t# Calculate the prefix sum\\n        prefix = mat[:][:]  # essentially copies the entire array\\n        for i in range(m):\\n            for j in range(n):\\n                prefix[i][j] += (prefix[i-1][j] if i > 0 else 0) + \\\\          # add prefix sum of (i-1, j) if it exists\\n                                (prefix[i][j-1] if j > 0 else 0) - \\\\          # add prefix sum of (i, j-1) if it exists\\n                                (prefix[i-1][j-1] if i > 0 and j > 0 else 0)  # subtract prefix sum of (i-1, j-1) if it exists\\n\\t\\t\\n\\t\\t# Calculate the block sum from the prefix sum\\n        result = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                result[i][j] = prefix[min(i+k, m-1)][min(j+k, n-1)] + \\\\                  # S(D), bounded by m x n\\n                               (prefix[i-k-1][j-k-1] if i-k > 0 and j-k > 0 else 0) - \\\\  # S(A), if it exists\\n                               (prefix[i-k-1][min(j+k, n-1)] if i-k > 0 else 0) - \\\\      # S(B), if it exists\\n                               (prefix[min(i+k, m-1)][j-k-1] if j-k > 0 else 0)          # S(C), if it exists\\n        return result\\n\\t\\t# we could technically shorten the block sum calculation into one line of code, but that is super unreadable\\n```\\n\\nTime Complexity: O(mn), since the calculations performed in the nested loops are of O(1) time complexity.\\nSpace Complexity: O(mn) auxillary space, due to the prefix sum matrix.\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/65e45a40-3085-4431-aa16-0eaaeb25d119_1634276576.3804398.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```(x, y)```\n```result```\n```result[x][y]```\n```mat```\n```(x, y)```\n```result```\n```mat[x-k:x+k+1][y-k:y+k+1]```\n```python\\ndef getSubarray(mat: List[List[int]], x: int, y: int, k: int) -> List[List[int]]:\\n\\t\"\"\"\\n\\tPython pseudocode to obtain the following: mat[x-k:x+k+1][y-k:y+k+1].\\n\\tIf x - k < 0 --> Use index x = 0 instead\\n\\tIf y - k < 0 --> Use index y = 0 instead\\n\\tIf x + k >= len(mat) --> Use index x = len(mat)-1 instead\\n\\tIf y + k >- len(mat[0]) --> Use index y = len(mat[0])-1 instead\\n\\t\"\"\"\\n\\t# We can shorten this to:\\n\\treturn mat[max(x-k, 0):min(x+k+1, len(mat)][max(y-k, 0):min(y+k+1, len(mat[0])]\\n```\n```result[x][y]```\n```python\\ndef sumOfSubarray(arr: List[List[int]]) -> int:\\n\\t\"\"\"\\n\\tPython pseudocode to calculate the sum of all the elements in the given array.\\n\\tresult = 0\\n\\tfor i in range(len(arr)):\\n\\t\\tfor j in range(len(arr[0])):\\n\\t\\t\\tresult += arr[i][j]\\n\\treturn result\\n\\t\"\"\"\\n\\t# We can shorten this to:\\n\\treturn sum(sum(arr[i]) for i in range(len(arr)))\\n```\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        result = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                result[i][j] = sum(sum(mat[x][max(0, j-k):min(n, j+k+1)])\\n                                   for x in range(max(0, i-k), min(m, i+k+1)))\\n        return result\\n```\n```mat```\n```(x, y)```\n```mat```\n```sumOfSubarray(mat[:x+1][:y+1])```\n```python\\ndef prefixSum(mat: List[List[int]]) -> List[List[int]]:\\n\\t\"\"\"\\n\\tPython pseudocode to obtain the prefix sum of the given array via DP.\\n\\t\"\"\"\\n\\tresult = mat[:][:]  # essentially copies the array\\n\\tfor i in range(len(mat)):\\n\\t\\tfor j in range(len(mat[0])):\\n\\t\\t\\tresult[i][j] += (result[i-1][j] if i > 0 else 0) + \\\\          # add prefix sum of (i-1, j), if it exists\\n\\t\\t\\t\\t\\t\\t\\t(result[i][j-1] if j > 0 else 0) + \\\\          # add prefix sum of (i, j-1), if it exists\\n\\t\\t\\t\\t\\t\\t\\t(result[i-1][j-1] if i > 0 and j > 0 else 0)  # subtract prefix sum of (i-1, j-1), if it exists\\n\\treturn result\\n```\n```(x, y)```\n```S(D) + S(A) - S(B) - S(C)```\n```mat```\n```1 <= mat[i][j] <= 100```\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n\\t\\t\\n\\t\\t# Calculate the prefix sum\\n        prefix = mat[:][:]  # essentially copies the entire array\\n        for i in range(m):\\n            for j in range(n):\\n                prefix[i][j] += (prefix[i-1][j] if i > 0 else 0) + \\\\          # add prefix sum of (i-1, j) if it exists\\n                                (prefix[i][j-1] if j > 0 else 0) - \\\\          # add prefix sum of (i, j-1) if it exists\\n                                (prefix[i-1][j-1] if i > 0 and j > 0 else 0)  # subtract prefix sum of (i-1, j-1) if it exists\\n\\t\\t\\n\\t\\t# Calculate the block sum from the prefix sum\\n        result = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                result[i][j] = prefix[min(i+k, m-1)][min(j+k, n-1)] + \\\\                  # S(D), bounded by m x n\\n                               (prefix[i-k-1][j-k-1] if i-k > 0 and j-k > 0 else 0) - \\\\  # S(A), if it exists\\n                               (prefix[i-k-1][min(j+k, n-1)] if i-k > 0 else 0) - \\\\      # S(B), if it exists\\n                               (prefix[min(i+k, m-1)][j-k-1] if j-k > 0 else 0)          # S(C), if it exists\\n        return result\\n\\t\\t# we could technically shorten the block sum calculation into one line of code, but that is super unreadable\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561884,
                "title": "java-dp-solution-clean-code-o-m-n",
                "content": "```java\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] ans = new int[m][n];\\n        \\n        int[][] t = new int[m + 1][n + 1];\\n        \\n        for (int i = 1; i < t.length; i++) {\\n            for (int j = 1; j < t[0].length; j++) {\\n                t[i][j] = t[i - 1][j] + t[i][j - 1] + mat[i - 1][j - 1] - t[i - 1][j - 1];\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int r1 = Math.max(0, i - K) + 1;\\n                int c1 = Math.max(0, j - K) + 1;\\n                int r2 = Math.min(m, i + K + 1);\\n                int c2 = Math.min(n, j + K + 1);\\n                ans[i][j] = t[r2][c2] - t[r1 - 1][c2] - t[r2][c1 - 1] + t[r1 - 1][c1 - 1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] ans = new int[m][n];\\n        \\n        int[][] t = new int[m + 1][n + 1];\\n        \\n        for (int i = 1; i < t.length; i++) {\\n            for (int j = 1; j < t[0].length; j++) {\\n                t[i][j] = t[i - 1][j] + t[i][j - 1] + mat[i - 1][j - 1] - t[i - 1][j - 1];\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int r1 = Math.max(0, i - K) + 1;\\n                int c1 = Math.max(0, j - K) + 1;\\n                int r2 = Math.min(m, i + K + 1);\\n                int c2 = Math.min(n, j + K + 1);\\n                ans[i][j] = t[r2][c2] - t[r1 - 1][c2] - t[r2][c1 - 1] + t[r1 - 1][c1 - 1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499970,
                "title": "problem-explanation-in-python-step-by-step-o-m-n-98-speed-and-100-memory",
                "content": "In order to answer this problem we may use the following idea in the array:\\n\\n**input, K = 1**\\n|  |  |  |\\n|---|---|---|\\n| a | b | c |\\n| d | e | f |\\n| g | h | i |\\n| | | |\\n\\n**output:**\\n|   |   |   |\\n|---|---|---|\\n|(a+b)+(d+e)|       (a+b+c)+(d+e+f)|         (b+c) + (e+f)|\\n|(a+b)+(d+e)+(g+h)| (a+b+c)+(d+e+f)+(g+h+i)| (b+c) + (e+f) + (h+i)|\\n|(a+b)+(d+e)|       (d+e+f)+(g+h+i)|         (e+f) + (h+i)|\\n| | | |\\n\\nit\\'s pretty much the same as compute the sum for rows and then make\\nthe sum into the columns:\\n**rowSum:**\\n||||\\n|-|-|-|\\n|(a+b)| (a+b+c)| (b+c)|\\n|(d+e)| (d+e+f)| (e+f)|\\n|(g+h)| (g+h+i)| (h+i)|\\n||||\\n\\nand the output will be made such as:\\n```\\noutput[i][j] = sum{k from -K to K}(rowSum[i+k][j])\\n```\\n\\nNow the idea is how to compute fast that row sum (that by the way,\\nis the same thing of the column sum in the output but in Y axis).\\nwe may notice that:\\n```\\nrowSum[i][j] = sum{k from -K to K}(mat[i][j+k])\\nrowSum[i][j+1] = sum{k from -K to K}(mat[i][j+1+k])\\n```\\n  \\nbut that\\'s the same as: \\n```\\nrowSum[i][j+1] = sum{k from -K+1 to K+1}(mat[i][j+k]) \\n```\\n\\nand we can compute it by saying that \\n``` \\nrowSum[i][j+1] = (sum{k from -K to K}(mat[i][j+k]))-mat[i][j-K]+mat[i][j+K+1] \\nrowSum[i][j+1] = rowSum[i][j]-mat[i][j-K]+mat[i][j+K+1] \\n\\nlet j+1 = l \\nrowSum[i][l] = rowSum[i][l-1]-mat[i][l-K-1]+mat[i][l+K] \\n``` \\n \\nand now we have our DP to compute the row in complexity O(n), but\\nhow we compute m rows, the overral complexity is O(m*n), and in the\\nY axis there\\'s the same situation\\n\\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        rowSum = [[0 for _ in range(len(mat[i]))] for i in range(len(mat))]\\n        ans = [[0 for _ in range(len(mat[i]))] for i in range(len(mat))]\\n        \\n        # Compute the sum of every group in the row with a DP\\n        # complexity: O(m*n)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[i])):\\n                if j > 0:\\n                    rowSum[i][j] = rowSum[i][j-1]\\n                    a = mat[i][j-K-1] if j-K-1 >= 0 else 0 # or 0\\n                    b = mat[i][j+K] if j+K < len(mat[i]) else 0 # or 0\\n                    rowSum[i][j] += -a+b\\n                else:\\n                    for k in range(0, min(j+K+1, len(mat[i]))):\\n                        rowSum[i][j] += mat[i][k]\\n        \\n        # Uses the computed sum of rows to compute the sum\\n        # of the squares with the same DP but now for columns\\n        # complexity: O(m*n)\\n        for i in range(len(rowSum)):\\n            for j in range(len(rowSum[i])):\\n                if i > 0:\\n                    ans[i][j] = ans[i-1][j]\\n                    a = rowSum[i-K-1][j] if i-K-1 >= 0 else 0 # or 0\\n                    b = rowSum[i+K][j] if i+K < len(rowSum) else 0 # or 0\\n                    ans[i][j] += -a+b\\n                else:\\n                    for k in range(0, min(i+K+1, len(rowSum))):\\n                        ans[i][j] += rowSum[k][j]\\n        \\n        # total complexity: O(m*n)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\noutput[i][j] = sum{k from -K to K}(rowSum[i+k][j])\\n```\n```\\nrowSum[i][j] = sum{k from -K to K}(mat[i][j+k])\\nrowSum[i][j+1] = sum{k from -K to K}(mat[i][j+1+k])\\n```\n```\\nrowSum[i][j+1] = sum{k from -K+1 to K+1}(mat[i][j+k]) \\n```\n``` \\nrowSum[i][j+1] = (sum{k from -K to K}(mat[i][j+k]))-mat[i][j-K]+mat[i][j+K+1] \\nrowSum[i][j+1] = rowSum[i][j]-mat[i][j-K]+mat[i][j+K+1] \\n\\nlet j+1 = l \\nrowSum[i][l] = rowSum[i][l-1]-mat[i][l-K-1]+mat[i][l+K] \\n```\n```python\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        rowSum = [[0 for _ in range(len(mat[i]))] for i in range(len(mat))]\\n        ans = [[0 for _ in range(len(mat[i]))] for i in range(len(mat))]\\n        \\n        # Compute the sum of every group in the row with a DP\\n        # complexity: O(m*n)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[i])):\\n                if j > 0:\\n                    rowSum[i][j] = rowSum[i][j-1]\\n                    a = mat[i][j-K-1] if j-K-1 >= 0 else 0 # or 0\\n                    b = mat[i][j+K] if j+K < len(mat[i]) else 0 # or 0\\n                    rowSum[i][j] += -a+b\\n                else:\\n                    for k in range(0, min(j+K+1, len(mat[i]))):\\n                        rowSum[i][j] += mat[i][k]\\n        \\n        # Uses the computed sum of rows to compute the sum\\n        # of the squares with the same DP but now for columns\\n        # complexity: O(m*n)\\n        for i in range(len(rowSum)):\\n            for j in range(len(rowSum[i])):\\n                if i > 0:\\n                    ans[i][j] = ans[i-1][j]\\n                    a = rowSum[i-K-1][j] if i-K-1 >= 0 else 0 # or 0\\n                    b = rowSum[i+K][j] if i+K < len(rowSum) else 0 # or 0\\n                    ans[i][j] += -a+b\\n                else:\\n                    for k in range(0, min(i+K+1, len(rowSum))):\\n                        ans[i][j] += rowSum[k][j]\\n        \\n        # total complexity: O(m*n)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125935,
                "title": "c-prefix-sum-matrix-o-n-m-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf U have done [range-sum-query-2d-immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/description/) problem  this seems real easy if not then it is  a hell brain storming question  espacially for those who don\\'t have done matrix problems . Look at this for best explanation : [Expalantion for this Concept](https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/3122950/cprefix-sum-using-two-equations-of-matrixo1/)\\nAfter doing above There is just a liitle change which u will look direclty in code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum of 2D Matrix : Get this appraoch from [here](https://leetcode.com/problems/range-sum-query-2d-immutable/description/)\\nAnd **Also UPVOTE If FOUND HELPFULL**\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\n\\nint bound(int i, int j,const vector<vector<int>>&dp) {\\n      if (i < 0 || j < 0) return 0;\\n        if (i >= n) i = n - 1;\\n        if (j >= m) j = m- 1;\\n        return dp[i+1][j+1];\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n         n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>>dp;\\n        dp.resize(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i+1][j+1]=dp[i+1][j]+matrix[i][j]+dp[i][j+1]-dp[i][j];\\n            }\\n        }\\n        int i=1;\\n        cout<<bound(1,1,dp);\\n      vector<vector<int>>ans(n,vector<int>(m));\\n       for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                ans[i][j]=bound(i+k,j+k,dp)-bound(i-k-1,j+k,dp)-bound(i+k,j-k-1,dp)+bound(i-k-1,j-k-1,dp);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\n\\nint bound(int i, int j,const vector<vector<int>>&dp) {\\n      if (i < 0 || j < 0) return 0;\\n        if (i >= n) i = n - 1;\\n        if (j >= m) j = m- 1;\\n        return dp[i+1][j+1];\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n         n=matrix.size(),m=matrix[0].size();\\n        vector<vector<int>>dp;\\n        dp.resize(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i+1][j+1]=dp[i+1][j]+matrix[i][j]+dp[i][j+1]-dp[i][j];\\n            }\\n        }\\n        int i=1;\\n        cout<<bound(1,1,dp);\\n      vector<vector<int>>ans(n,vector<int>(m));\\n       for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                ans[i][j]=bound(i+k,j+k,dp)-bound(i-k-1,j+k,dp)-bound(i+k,j-k-1,dp)+bound(i-k-1,j-k-1,dp);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1152097,
                "title": "c-solution-beats-100-time-87-memory-using-cumulative-sum",
                "content": "1. Firstly, we calculate the cumulative sum upto indexes i & j and change the matrix elements into their cumulative sum.\\n2. Then we calculate the area of possible square or rectangle using cumulative sum calculated in the first step.\\n![image](https://assets.leetcode.com/users/images/2dd9f447-1866-462d-ab2a-70f13cfe555e_1618089334.5831802.png)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> ans( n,vector<int> (m, 0));\\n        for(int i=1; i<n; i++) mat[i][0] += mat[i-1][0];\\n        for(int i=1; i<m; i++) mat[0][i] += mat[0][i-1];\\n        for(int r=1; r<n; r++) for(int c = 1; c<m; c++)\\n                mat[r][c] += mat[r-1][c] + mat[r][c-1] - mat[r-1][c-1];\\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                int r_max = min(n-1,i+k), c_max = min(m-1,j+k);\\n                if (i>k && j>k) ans[i][j] = mat[r_max][c_max] + mat[i-k-1][j-k-1] \\n                        - mat[r_max][j-k-1] - mat[i-k-1][c_max];\\n                else if (i>k) ans[i][j] = mat[r_max][c_max] - mat[i-k-1][c_max];\\n                else if (j>k) ans[i][j] = mat[r_max][c_max] - mat[r_max][j-k-1];\\n                else ans[i][j] = mat[r_max][c_max];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/950b530f-b4dd-4fd4-b376-2e3f7a21e1bc_1618089527.711017.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> ans( n,vector<int> (m, 0));\\n        for(int i=1; i<n; i++) mat[i][0] += mat[i-1][0];\\n        for(int i=1; i<m; i++) mat[0][i] += mat[0][i-1];\\n        for(int r=1; r<n; r++) for(int c = 1; c<m; c++)\\n                mat[r][c] += mat[r-1][c] + mat[r][c-1] - mat[r-1][c-1];\\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                int r_max = min(n-1,i+k), c_max = min(m-1,j+k);\\n                if (i>k && j>k) ans[i][j] = mat[r_max][c_max] + mat[i-k-1][j-k-1] \\n                        - mat[r_max][j-k-1] - mat[i-k-1][c_max];\\n                else if (i>k) ans[i][j] = mat[r_max][c_max] - mat[i-k-1][c_max];\\n                else if (j>k) ans[i][j] = mat[r_max][c_max] - mat[r_max][j-k-1];\\n                else ans[i][j] = mat[r_max][c_max];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711729,
                "title": "python-dp-o-m-n",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        mat[:] = [[0] * (n + 1)] + [[0] + row for row in mat]\\n        res = [[0] * n for i in range(m)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1]\\n                \\n        for i in range(m):\\n            for j in range(n):\\n                r1, r2 = max(i - K, 0), min(i + K + 1, m)\\n                c1, c2 = max(j - K, 0), min(j + K + 1, n)\\n                res[i][j] = mat[r2][c2] - mat[r2][c1] - mat[r1][c2] + mat[r1][c1]\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        mat[:] = [[0] * (n + 1)] + [[0] + row for row in mat]\\n        res = [[0] * n for i in range(m)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mat[i][j] += mat[i - 1][j] + mat[i][j - 1] - mat[i - 1][j - 1]\\n                \\n        for i in range(m):\\n            for j in range(n):\\n                r1, r2 = max(i - K, 0), min(i + K + 1, m)\\n                c1, c2 = max(j - K, 0), min(j + K + 1, n)\\n                res[i][j] = mat[r2][c2] - mat[r2][c1] - mat[r1][c2] + mat[r1][c1]\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612738,
                "title": "100-100-dp-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int> >& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int> > dp(m+1,vector<int>(n+1));\\n        dp[0][0]=mat[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+mat[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+mat[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+mat[i][j];\\n            }\\n        }\\n        vector<vector<int> > ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=dp[min(i+k,m-1)][min(j+k,n-1)]-((j-k-1)>=0 ? dp[min(i+k,m-1)][j-k-1] : 0)-((i-k-1)>=0 ? dp[i-k-1][min(n-1,j+k)] : 0)+(((j-k-1)>=0 && (i-k-1)>=0) ? dp[i-k-1][j-k-1] : 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int> >& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int> > dp(m+1,vector<int>(n+1));\\n        dp[0][0]=mat[0][0];\\n        for(int i=1;i<n;i++){\\n            dp[0][i]=dp[0][i-1]+mat[0][i];\\n        }\\n        for(int i=1;i<m;i++){\\n            dp[i][0]=dp[i-1][0]+mat[i][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+mat[i][j];\\n            }\\n        }\\n        vector<vector<int> > ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=dp[min(i+k,m-1)][min(j+k,n-1)]-((j-k-1)>=0 ? dp[min(i+k,m-1)][j-k-1] : 0)-((i-k-1)>=0 ? dp[i-k-1][min(n-1,j+k)] : 0)+(((j-k-1)>=0 && (i-k-1)>=0) ? dp[i-k-1][j-k-1] : 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477045,
                "title": "java-precompute",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] ans = new int[m][n];\\n        int[][] pre = new int[m][n];\\n        for(int i = 0; i < m; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < n; j++) {\\n                sum += mat[i][j];\\n                pre[i][j] = sum;\\n            }\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int r1 = Math.max(0, i - k);\\n                int r2 = Math.min(m - 1, i + k);\\n                int c1 = Math.max(0, j - k); \\n                int c2 = Math.min(n - 1, j + k);\\n                for(int t = r1; t <= r2; t++) {\\n                    ans[i][j] += pre[t][c2];\\n                    if(c1 != 0) ans[i][j] -= pre[t][c1 - 1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] ans = new int[m][n];\\n        int[][] pre = new int[m][n];\\n        for(int i = 0; i < m; i++) {\\n            int sum = 0;\\n            for(int j = 0; j < n; j++) {\\n                sum += mat[i][j];\\n                pre[i][j] = sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2852898,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n    int m, n;\\npublic:\\n    int block_sum(int row, int col, vector<vector<int>>& prefix_sum, int k) {\\n        // relevant points are\\n        // bottom corner            -> row + k,     col + k\\n        // top corner               -> row - k,     col - k;\\n        // pre up corner            -> row - k - 1, col - k - 1;\\n        // right up corner          -> row - k - 1, col + k\\n        // left down corner         -> row + k,     col - k - 1\\n        // sum \\n        // value(bottom corner) - value(right up) - value(left down) + value(pre up corner);\\n        int bot_corner_row = min(row + k, m - 1);\\n        int bot_corner_col = min(col + k, n - 1);\\n        // Base block\\n        int res = prefix_sum[bot_corner_row][bot_corner_col];\\n        // Block 1 - Upper block\\n        if ((row - k - 1) >= 0) {\\n            int right_up_corner_col = min(col + k, n - 1);\\n            res -= prefix_sum[row - k - 1][right_up_corner_col];\\n        }\\n        // Block 2 - Left block\\n        if ((col - k - 1) >= 0) {\\n            int left_down_corner_row = min(row + k, m - 1);\\n            res -= prefix_sum[left_down_corner_row][col - k - 1];\\n        } \\n        // Block 3 - upper left block\\n        // Add if both Block 1 & 2 reduced its sum\\n        if (((row - k - 1) >= 0) && ((col - k - 1) >= 0)) {\\n            res += prefix_sum[row - k - 1][col - k - 1];\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        vector<vector<int>> prefix_sum(m, vector<int>(n, 0));\\n        vector<vector<int>> result(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            int row_sum = 0;\\n            for (int j = 0; j < n; ++j) {\\n                // Prefix sum is accumulated sum of row element + upper prefix sum cell\\n                row_sum += mat[i][j];\\n                prefix_sum[i][j] = row_sum;\\n                if (i > 0) {\\n                    prefix_sum[i][j] += prefix_sum[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result[i][j] = block_sum(i, j, prefix_sum, k);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\npublic:\\n    int block_sum(int row, int col, vector<vector<int>>& prefix_sum, int k) {\\n        // relevant points are\\n        // bottom corner            -> row + k,     col + k\\n        // top corner               -> row - k,     col - k;\\n        // pre up corner            -> row - k - 1, col - k - 1;\\n        // right up corner          -> row - k - 1, col + k\\n        // left down corner         -> row + k,     col - k - 1\\n        // sum \\n        // value(bottom corner) - value(right up) - value(left down) + value(pre up corner);\\n        int bot_corner_row = min(row + k, m - 1);\\n        int bot_corner_col = min(col + k, n - 1);\\n        // Base block\\n        int res = prefix_sum[bot_corner_row][bot_corner_col];\\n        // Block 1 - Upper block\\n        if ((row - k - 1) >= 0) {\\n            int right_up_corner_col = min(col + k, n - 1);\\n            res -= prefix_sum[row - k - 1][right_up_corner_col];\\n        }\\n        // Block 2 - Left block\\n        if ((col - k - 1) >= 0) {\\n            int left_down_corner_row = min(row + k, m - 1);\\n            res -= prefix_sum[left_down_corner_row][col - k - 1];\\n        } \\n        // Block 3 - upper left block\\n        // Add if both Block 1 & 2 reduced its sum\\n        if (((row - k - 1) >= 0) && ((col - k - 1) >= 0)) {\\n            res += prefix_sum[row - k - 1][col - k - 1];\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        vector<vector<int>> prefix_sum(m, vector<int>(n, 0));\\n        vector<vector<int>> result(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; ++i) {\\n            int row_sum = 0;\\n            for (int j = 0; j < n; ++j) {\\n                // Prefix sum is accumulated sum of row element + upper prefix sum cell\\n                row_sum += mat[i][j];\\n                prefix_sum[i][j] = row_sum;\\n                if (i > 0) {\\n                    prefix_sum[i][j] += prefix_sum[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result[i][j] = block_sum(i, j, prefix_sum, k);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477790,
                "title": "c-simple-prefix-sum-for-matrix-o-n-m",
                "content": "Observe that for any (i, j) the required sum would of the submatrix for the cells : `(i - k, j - k)` to `(i + k, j + k)` [Considering the bounds of the matrix].\\n\\nSo, use prefix sum technique to calculate the prefix sum in `dp` matrix and use it for evaluating required solution.\\n\\nTime : `O(n*m)`\\nSpace : `O(n*m)`\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> ans;\\n        int n = mat.size();\\n        if(n == 0)\\n            return ans;\\n        int m = mat[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                    dp[i][j] = mat[0][0];\\n                else if(i == 0)\\n                    dp[i][j] = dp[i][j-1] + mat[i][j];\\n                else if(j == 0)\\n                    dp[i][j] = dp[i - 1][j] + mat[i][j];\\n                else\\n                    dp[i][j] =  dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                int s = (i - k >= 0 ? i - k : 0), e = (j - k >= 0 ? j - k : 0);\\n                int s1 = (i + k < n ? i + k : n - 1), e1 = (j + k < m ? j + k : m - 1);\\n                \\n                int sum = dp[s1][e1];\\n                if(s >= 1 && e >= 1)\\n                    sum += dp[s - 1][e - 1];\\n                if(s >= 1)\\n                    sum -= dp[s-1][e1];\\n                if(e >= 1)\\n                    sum -= dp[s1][e - 1];\\n                mat[i][j] = sum;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> ans;\\n        int n = mat.size();\\n        if(n == 0)\\n            return ans;\\n        int m = mat[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                    dp[i][j] = mat[0][0];\\n                else if(i == 0)\\n                    dp[i][j] = dp[i][j-1] + mat[i][j];\\n                else if(j == 0)\\n                    dp[i][j] = dp[i - 1][j] + mat[i][j];\\n                else\\n                    dp[i][j] =  dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                int s = (i - k >= 0 ? i - k : 0), e = (j - k >= 0 ? j - k : 0);\\n                int s1 = (i + k < n ? i + k : n - 1), e1 = (j + k < m ? j + k : m - 1);\\n                \\n                int sum = dp[s1][e1];\\n                if(s >= 1 && e >= 1)\\n                    sum += dp[s - 1][e - 1];\\n                if(s >= 1)\\n                    sum -= dp[s-1][e1];\\n                if(e >= 1)\\n                    sum -= dp[s1][e - 1];\\n                mat[i][j] = sum;\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151689,
                "title": "beats-100-prefix-sum-tc-o-n-m-sc-o-n-m-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->PreFix sum will give solution in O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Prefix Sum.\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>presum;\\n    int solve(vector<vector<int>>&ans,int row1, int col1, int row2, int col2) {\\n        int sum=0;\\n        sum+=presum[row2][col2];\\n        if(col1>0) sum-=presum[row2][col1-1];\\n        if(row1>0) sum-=presum[row1-1][col2];\\n        if(col1>0 && row1>0) sum+=presum[row1-1][col1-1];\\n        return sum;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        presum=matrix;\\n        for(int i=1;i<n;i++)\\n            presum[0][i]+=presum[0][i-1];\\n        for(int i=1;i<m;i++)\\n            presum[i][0]+=presum[i-1][0];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                presum[i][j]+=presum[i-1][j]+presum[i][j-1]-presum[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=solve(ans,(i<k)?0:i-k,(j<k)?0:j-k,(i+k)>=m?m-1:i+k,(j+k)>=n?n-1:j+k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>presum;\\n    int solve(vector<vector<int>>&ans,int row1, int col1, int row2, int col2) {\\n        int sum=0;\\n        sum+=presum[row2][col2];\\n        if(col1>0) sum-=presum[row2][col1-1];\\n        if(row1>0) sum-=presum[row1-1][col2];\\n        if(col1>0 && row1>0) sum+=presum[row1-1][col1-1];\\n        return sum;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size(),n=matrix[0].size();\\n        presum=matrix;\\n        for(int i=1;i<n;i++)\\n            presum[0][i]+=presum[0][i-1];\\n        for(int i=1;i<m;i++)\\n            presum[i][0]+=presum[i-1][0];\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                presum[i][j]+=presum[i-1][j]+presum[i][j-1]-presum[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[i][j]=solve(ans,(i<k)?0:i-k,(j<k)?0:j-k,(i+k)>=m?m-1:i+k,(j+k)>=n?n-1:j+k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513557,
                "title": "javascript-dp-solution-beats-100-00",
                "content": "Run time - O (m*n)\\n```\\n\\nvar matrixBlockSum = function(mat, K) {\\n    // create DP Table matrix (m+1 * n+1)\\n    let dp = Array(mat.length + 1);\\n\\t// set first row value as 0\\n    dp[0] = Array(mat[0].length + 1).fill(0);\\n\\t\\n    // fill dp table with cumulative sum from (0,0) to (i,j)\\n    for(let i = 0; i < mat.length; i++){\\n        dp[i+1] = [0];\\n        for(let j = 0; j < mat[0].length; j++){\\n            dp[i+1][j+1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n        }\\n    }\\n    // find sum of r, c cells (cells in square) using DP table (inclusion/exclusion)\\n    for(let i = 0; i < mat.length; i++){\\n        for(let j = 0; j < mat[0].length;j++){\\n            let r1 = Math.max(0, i - K), r2 = Math.min(mat.length - 1, i + K);\\n            let c1 = Math.max(0, j - K), c2 = Math.min(mat[0].length - 1, j + K);\\n            // r1++; r2++; c1++; c2++;\\n            mat[i][j] = dp[r2 + 1][c2 + 1] - dp[r1][c2 + 1] - dp[r2 + 1][c1] + dp[r1][c1]\\n        }\\n    }\\n    // used mat as result matrix\\n    return mat;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nvar matrixBlockSum = function(mat, K) {\\n    // create DP Table matrix (m+1 * n+1)\\n    let dp = Array(mat.length + 1);\\n\\t// set first row value as 0\\n    dp[0] = Array(mat[0].length + 1).fill(0);\\n\\t\\n    // fill dp table with cumulative sum from (0,0) to (i,j)\\n    for(let i = 0; i < mat.length; i++){\\n        dp[i+1] = [0];\\n        for(let j = 0; j < mat[0].length; j++){\\n            dp[i+1][j+1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n        }\\n    }\\n    // find sum of r, c cells (cells in square) using DP table (inclusion/exclusion)\\n    for(let i = 0; i < mat.length; i++){\\n        for(let j = 0; j < mat[0].length;j++){\\n            let r1 = Math.max(0, i - K), r2 = Math.min(mat.length - 1, i + K);\\n            let c1 = Math.max(0, j - K), c2 = Math.min(mat[0].length - 1, j + K);\\n            // r1++; r2++; c1++; c2++;\\n            mat[i][j] = dp[r2 + 1][c2 + 1] - dp[r1][c2 + 1] - dp[r2 + 1][c1] + dp[r1][c1]\\n        }\\n    }\\n    // used mat as result matrix\\n    return mat;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477275,
                "title": "c-concise-solution",
                "content": "```\\nclass Solution\\n{\\n    vector<vector<int>> mat;\\npublic:\\n    int get_rectangle_sum(int x, int y, int p, int q);\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k);\\n};\\n\\nint Solution :: get_rectangle_sum(int x, int y, int p, int q)\\n{\\n    int top_left = x and y ? mat[x-1][y-1] : 0;\\n    int top_right = x ? mat[x-1][q] : 0;\\n    int bot_left = y ? mat[p][y-1] : 0;\\n    int bot_right = mat[p][q];\\n    \\n    \\n    int sum = bot_right - top_right;\\n    sum -= (bot_left - top_left);\\n    \\n    return sum;\\n}\\n\\nvector<vector<int>> Solution :: matrixBlockSum(vector<vector<int>>& input_matrix, int k)\\n{\\n    // Serious Bug (Due to Name Collision)\\n    this->mat = input_matrix;\\n    \\n    int row = mat.size();\\n    int col = mat[0].size();\\n    \\n    // Convert to partial sum\\n    for(int i = 0; i < row; i++)\\n    {\\n        int running_sum = 0;\\n        for(int j = 0; j < col; j++)\\n        {\\n            running_sum += mat[i][j];\\n            mat[i][j] = running_sum + (i ? mat[i-1][j] : 0);\\n        }\\n    }\\n    \\n    vector<vector<int>> res(row, vector<int>(col, 0));\\n    \\n    for(int i = 0; i < row; i++)\\n    {\\n        for(int j = 0; j < col; j++)\\n        {\\n            int x = i-k, y = j-k;\\n            int p = i+k, q = j+k;\\n            \\n            res[i][j] = get_rectangle_sum(max(0,x), max(0,y), min(row - 1, p), min(col - 1, q));\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    vector<vector<int>> mat;\\npublic:\\n    int get_rectangle_sum(int x, int y, int p, int q);\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k);\\n};\\n\\nint Solution :: get_rectangle_sum(int x, int y, int p, int q)\\n{\\n    int top_left = x and y ? mat[x-1][y-1] : 0;\\n    int top_right = x ? mat[x-1][q] : 0;\\n    int bot_left = y ? mat[p][y-1] : 0;\\n    int bot_right = mat[p][q];\\n    \\n    \\n    int sum = bot_right - top_right;\\n    sum -= (bot_left - top_left);\\n    \\n    return sum;\\n}\\n\\nvector<vector<int>> Solution :: matrixBlockSum(vector<vector<int>>& input_matrix, int k)\\n{\\n    // Serious Bug (Due to Name Collision)\\n    this->mat = input_matrix;\\n    \\n    int row = mat.size();\\n    int col = mat[0].size();\\n    \\n    // Convert to partial sum\\n    for(int i = 0; i < row; i++)\\n    {\\n        int running_sum = 0;\\n        for(int j = 0; j < col; j++)\\n        {\\n            running_sum += mat[i][j];\\n            mat[i][j] = running_sum + (i ? mat[i-1][j] : 0);\\n        }\\n    }\\n    \\n    vector<vector<int>> res(row, vector<int>(col, 0));\\n    \\n    for(int i = 0; i < row; i++)\\n    {\\n        for(int j = 0; j < col; j++)\\n        {\\n            int x = i-k, y = j-k;\\n            int p = i+k, q = j+k;\\n            \\n            res[i][j] = get_rectangle_sum(max(0,x), max(0,y), min(row - 1, p), min(col - 1, q));\\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502618,
                "title": "python3-simple-and-very-fast-with-prefix-sums-of-prefix-sums",
                "content": "## Introduction\\n\\nEasy and clean approach in Python3:\\n\\n1. Compute prefix sums on the input matrix across columns for each row\\n2. Compute prefix sums **on the prefix sums** across rows for each column.\\n3. Update every cell in the input matrix using #2 above in O(1) runtime regardless of K\\n\\n**Runtime**: O(m * n) * O(1)\\n**Storage**: O(m * n)\\n\\n*Note: Because we are reusing the input `mat` for the output storage, we only use `n * m` extra storage in this implementation.  Also, we could use clever approaches to do all of this inplace if needed. :)*\\n\\n## Approach\\nThe important realization for this approach is as follows:\\n\\nWe have a columnar prefix sum of a prefix sum of rows for the matrix. That means that any given cell `(y, x)` in this \"prefix prefix sum\" (call it `DP`) contains the total sum from cells 0 to x, 0 to y.  Using the same approach as Prefix Sum subtraction to get sub-sums in a 1d array, we can do this in a 2d array as well, but with a small adjustment to deal with double-counting numbers.\\n\\nGiven a cell at `(y, x)` and a `k` value, we can come up with the min and max cells that represent the sub-matrix.  We need to find `(y1,x1)` and `(y2,x2`) by using `k` as an offset, and repespecting the max and min values of each dimension.\\n\\n```\\nx1 = max(0, j-k)\\nx2 = min(j+k, m-1)\\ny1 = max(0, i-k)\\ny2 = min(i+k, n-1)\\n```\\n\\nTo determine the sub-matrix sub, we use the following simple formula:\\n\\n`subsum = DP[y2][x2] - DP[y2][x1-1] - DPS[y1-1][x2] + DPS[y1-1][x1-1]`\\n\\n\\n\\n## Example\\n\\nTake the sample input matrix below with 5 columns and 7 rows.\\n\\n![image](https://assets.leetcode.com/users/images/63dc10d8-c29c-403b-a093-6469d98e7726_1661825409.936886.png)\\n\\nWe can compute the prefix sums per row to get the following result. We simply add the subtotal starting from position to each cell from left to right.  For example, in row `0`, we start with `1`, add `8` to get `9`, and `9` to get `18`, add `8` to get `26`, and add `6` to get `32`.\\n\\n![image](https://assets.leetcode.com/users/images/9541cf22-9b4c-4374-b0e6-00d47b50d4c5_1661825526.9198332.png)\\n\\nWe can now compute prefix sums on this set of prefix sums, but going top-to-bottom this time.\\n\\n![image](https://assets.leetcode.com/users/images/83d435a0-8a1b-4b6c-bafe-0119f81ba33f_1661826391.938828.png)\\n\\nNow, if we want to know the total of all cells in the original matrix, we just read it from `DP[6][4]` as `183`. \\n\\nAssume we want to get the total sub-area of a cell at `y=2`, `x=2`, with `k=1`.  That would mean we need:\\n\\n`x1 = 1, y1 = 1, x2 = 3, y2 = 3`\\n\\nBy simple inspection of the input matrix, we observe the total as `46`.  \\n\\n![image](https://assets.leetcode.com/users/images/3689fde1-d360-411e-ac36-e3580d15dd90_1661824837.394279.png)\\n\\nNow, let\\'s look at the Prefix Prefix Sum array to look up the answer that way\\n\\n![image](https://assets.leetcode.com/users/images/fc932ffe-b0fa-4aeb-b460-412cd4b73022_1661826773.2453089.png)\\n\\n`subsum = DP[y2][x2] - DP[y2][x1-1] - DPS[y1-1][x2] + DPS[y1-1][x1-1]`\\n`subsum = DP[3][3] - DP[3][0] - DPS[0][3] + DPS[0][0]`\\n`subsum = 81 - 10 - 26 + 1`\\n`subsum = 46`\\n\\nNote that these lookups are constant time, so it\\'s very efficient to do it per cell in the input matrix.\\n\\n## Code\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        dp = [[mat[i][j] for j in range(m)] for i in range(n)]\\n\\n        # Prefix Sums Left to Right\\n        for i in range(n):\\n            for j in range(m):\\n                dp[i][j] += (dp[i][j-1] if j > 0 else 0)\\n        \\n        # Prefix Sums of Sums Top to Bottom\\n        for j in range(m):\\n            for i in range(n):\\n                dp[i][j] += (dp[i-1][j] if i > 0 else 0)\\n                        \\n        # Update input Mat with sum per cell\\n        for i in range(n):\\n            for j in range(m):\\n                x1, x2 = max(0, j-k), min(j+k, m-1)\\n                y1, y2 = max(0, i-k), min(i+k, n-1)\\n                dy = dp[y1-1][x2] if y1 > 0 else 0\\n                dx = dp[y2][x1-1] if x1 > 0 else 0\\n                dz = dp[y1-1][x1-1] if (x1 > 0 and y1 > 0) else 0\\n                mat[i][j] = dp[y2][x2] - dy - dx + dz\\n\\n        return mat\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nx1 = max(0, j-k)\\nx2 = min(j+k, m-1)\\ny1 = max(0, i-k)\\ny2 = min(i+k, n-1)\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        dp = [[mat[i][j] for j in range(m)] for i in range(n)]\\n\\n        # Prefix Sums Left to Right\\n        for i in range(n):\\n            for j in range(m):\\n                dp[i][j] += (dp[i][j-1] if j > 0 else 0)\\n        \\n        # Prefix Sums of Sums Top to Bottom\\n        for j in range(m):\\n            for i in range(n):\\n                dp[i][j] += (dp[i-1][j] if i > 0 else 0)\\n                        \\n        # Update input Mat with sum per cell\\n        for i in range(n):\\n            for j in range(m):\\n                x1, x2 = max(0, j-k), min(j+k, m-1)\\n                y1, y2 = max(0, i-k), min(i+k, n-1)\\n                dy = dp[y1-1][x2] if y1 > 0 else 0\\n                dx = dp[y2][x1-1] if x1 > 0 else 0\\n                dz = dp[y1-1][x1-1] if (x1 > 0 and y1 > 0) else 0\\n                mat[i][j] = dp[y2][x2] - dy - dx + dz\\n\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723821,
                "title": "java-prefixsum",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int rows = mat.length, cols = mat[0].length;\\n        int[][] prefixSum = new int[rows+1][cols+1];\\n        for (int i = 1; i <=rows; i++)\\n            for (int j = 1; j<=cols; j++)\\n                prefixSum[i][j] = mat[i-1][j-1] - prefixSum[i-1][j-1] + prefixSum[i-1][j] + prefixSum[i][j-1];\\n        \\n        int[][] result = new int[rows][cols];\\n        for (int i=0; i<rows;i++)\\n            for (int j =0; j < cols; j++){\\n                int i_min = i-k>= 0? i-k:0;\\n                int i_max = Math.min(i+k, rows-1);\\n                int j_min = j-k>=0? j-k:0;\\n                int j_max = Math.min(j+k, cols-1);\\n                result[i][j] = prefixSum[i_min][j_min]+prefixSum[i_max+1][j_max+1] - prefixSum[i_max+1][j_min] -prefixSum[i_min][j_max+1];\\n            }\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int rows = mat.length, cols = mat[0].length;\\n        int[][] prefixSum = new int[rows+1][cols+1];\\n        for (int i = 1; i <=rows; i++)\\n            for (int j = 1; j<=cols; j++)\\n                prefixSum[i][j] = mat[i-1][j-1] - prefixSum[i-1][j-1] + prefixSum[i-1][j] + prefixSum[i][j-1];\\n        \\n        int[][] result = new int[rows][cols];\\n        for (int i=0; i<rows;i++)\\n            for (int j =0; j < cols; j++){\\n                int i_min = i-k>= 0? i-k:0;\\n                int i_max = Math.min(i+k, rows-1);\\n                int j_min = j-k>=0? j-k:0;\\n                int j_max = Math.min(j+k, cols-1);\\n                result[i][j] = prefixSum[i_min][j_min]+prefixSum[i_max+1][j_max+1] - prefixSum[i_max+1][j_min] -prefixSum[i_min][j_max+1];\\n            }\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572339,
                "title": "c-solution-using-prefix-sum-of-matrix",
                "content": "First, we need to calculate the prefix matrix of the given matrix. Then we can make changes to each element in it according to given \\'k\\'.\\nFor prefix matrix, pre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]\\n\\n**Time and Space Complexities :** Time Complexity : O(mxn), Auxiliary Space : O(mxn)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(), n=mat[0].size();\\n        //calculating prefix-sum of matrix - prefix[i][j] = prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i>0) mat[i][j] += mat[i-1][j];\\n                if(j>0) mat[i][j] += mat[i][j-1];\\n                if(i>0 && j>0) mat[i][j] -= mat[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        \\n        //calculating matrix block sum\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int r0=max(0, i-k), c0=max(0, j-k), r1=min(m-1, i+k), c1=min(n-1, j+k);\\n                \\n                ans[i][j] = mat[r1][c1];\\n                if(r0>0) ans[i][j] -= mat[r0-1][c1];\\n                if(c0>0) ans[i][j] -= mat[r1][c0-1];\\n                if(r0>0 && c0>0) ans[i][j] += mat[r0-1][c0-1];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nIf you like my solution, please upvote :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(), n=mat[0].size();\\n        //calculating prefix-sum of matrix - prefix[i][j] = prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i>0) mat[i][j] += mat[i-1][j];\\n                if(j>0) mat[i][j] += mat[i][j-1];\\n                if(i>0 && j>0) mat[i][j] -= mat[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        \\n        //calculating matrix block sum\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int r0=max(0, i-k), c0=max(0, j-k), r1=min(m-1, i+k), c1=min(n-1, j+k);\\n                \\n                ans[i][j] = mat[r1][c1];\\n                if(r0>0) ans[i][j] -= mat[r0-1][c1];\\n                if(c0>0) ans[i][j] -= mat[r1][c0-1];\\n                if(r0>0 && c0>0) ans[i][j] += mat[r0-1][c0-1];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543109,
                "title": "c-straight-forward-easy-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k)\\n    {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c, 0));\\n        for (int i = 0; i < r; ++i)\\n        {\\n            for (int j = 0; j < c; ++j)\\n            {\\n                int val = 0;\\n                int minrow = i - k;\\n                int maxrow = i + k;\\n                int mincol = j - k;\\n                int maxcol = j + k;\\n                while (minrow < 0) ++minrow;\\n                while (maxrow > (r - 1)) --maxrow;\\n                while (mincol < 0) ++mincol;\\n                while (maxcol > (c - 1)) --maxcol;\\n                for (int p = minrow; p <= maxrow; ++p)\\n                {\\n                    for (int q = mincol; q <= maxcol; ++q)\\n                    {\\n                        val += mat[p][q];\\n                    }\\n                }\\n                ans[i][j] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k)\\n    {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c, 0));\\n        for (int i = 0; i < r; ++i)\\n        {\\n            for (int j = 0; j < c; ++j)\\n            {\\n                int val = 0;\\n                int minrow = i - k;\\n                int maxrow = i + k;\\n                int mincol = j - k;\\n                int maxcol = j + k;\\n                while (minrow < 0) ++minrow;\\n                while (maxrow > (r - 1)) --maxrow;\\n                while (mincol < 0) ++mincol;\\n                while (maxcol > (c - 1)) --maxcol;\\n                for (int p = minrow; p <= maxrow; ++p)\\n                {\\n                    for (int q = mincol; q <= maxcol; ++q)\\n                    {\\n                        val += mat[p][q];\\n                    }\\n                }\\n                ans[i][j] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522510,
                "title": "c-using-prefix-sum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        //use prefix sum for every row\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sum+=mat[i][j];\\n                mat[i][j]=sum;\\n            }\\n        }\\n        int minRow,minCol,maxRow,maxCol,currSum;\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                minRow=max(0,i-k);\\n                maxRow=min(m-1,i+k);\\n                minCol=max(0,j-k);\\n                maxCol=min(n-1,j+k);\\n                //now for every row get the sum of arr between minCol and maxCol\\n                currSum=0;\\n                for(int k=minRow;k<=maxRow;k++)\\n                {\\n                    currSum+=mat[k][maxCol];\\n                    if(minCol>0)\\n                        currSum-=mat[k][minCol-1];\\n                }\\n                ans[i][j]=currSum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        //use prefix sum for every row\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                sum+=mat[i][j];\\n                mat[i][j]=sum;\\n            }\\n        }\\n        int minRow,minCol,maxRow,maxCol,currSum;\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                minRow=max(0,i-k);\\n                maxRow=min(m-1,i+k);\\n                minCol=max(0,j-k);\\n                maxCol=min(n-1,j+k);\\n                //now for every row get the sum of arr between minCol and maxCol\\n                currSum=0;\\n                for(int k=minRow;k<=maxRow;k++)\\n                {\\n                    currSum+=mat[k][maxCol];\\n                    if(minCol>0)\\n                        currSum-=mat[k][minCol-1];\\n                }\\n                ans[i][j]=currSum;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221745,
                "title": "java-prefix-sum-approach-99-faster",
                "content": "The general approach would for every cell of i and j get the possible range of row and column then add all the cell. But in this case it will take very long time and can cause TLE. So we need to come up with the batter approach.\\n\\nSo we will use the prefix sum approach like for an example ->\\n1 2 3 4\\n4 5 6 7\\n8 9 8 7\\nthis is matrix first we are going add all the elements by its row like mat[i][j] += mat[i][j-1]\\n1  3   6  10\\n4  9  15 22\\n8 17 25 32\\nthen we are adding all elements as per itscolums like mat[i][j] += mat[i-1][j]\\n 1    3    6   10\\n 5   12  21  32\\n13  29  46  64\\n\\nThe Idea is, when we get a range of upper limit and lower limit then we can use this addition value so that we will not loop though again and again for every cell\\n\\n##### How does it work ->\\nlet consider this exaple\\n![image](https://assets.leetcode.com/users/images/85b57ea3-9bb9-4566-adca-f47c1249d06d_1621608724.7525039.png)\\nas per some randome value lets say we need to add this rectangle then we can get the value directly which is highlighted in hexagonal cell.\\nSo we can say\\n```\\nif(i_low <= 0 &&  j_low <= 0) result[i][j] = mat[i_up][j_up];\\n```\\nnow consider this,\\n![image](https://assets.leetcode.com/users/images/8a8f4487-6e5a-40d9-aa01-c64e3fa5dda7_1621608974.3861787.png)\\nif we need to add this rectangle then we can say value heighlighted in hexagonal - value highlighted in circle cause that the extra addition added in the hexagonal highlighted value.\\nSo\\n```\\nif(i_low <= 0) result[i][j] = mat[i_up][j_up] - mat[i_up][j_low-1];\\n```\\nNow consider this,\\n![image](https://assets.leetcode.com/users/images/c84f3378-bb83-46c4-930b-5aedef9b81ab_1621609312.8315823.png)\\nif we need to add this matrix then the value will be, value highlighted in hexagonal - value highlighted in circle same as previous. So,\\n```\\nif(j_low <= 0) result[i][j] = mat[i_up][j_up] - mat[i_low-1][j_up];\\n```\\nNow consider this one,\\n![image](https://assets.leetcode.com/users/images/b2cd7180-d9cc-4863-ae89-e9901e25db6d_1621609878.505047.png)\\nif i_low and j_low both are not less or equal to zero then it would be like, after subtracting 2 circle values from the hexagonal value we need to add the value highlighted with star because that\\'s the common value (intersaction part) we are subtracting towice so we need to add it again once.\\n```\\n// if i_ow and j_low are not <= 0\\nresult[i][j] = mat[i_up][j_up] - mat[i_up][j_low-1] - mat[i_low-1][j_up] + mat[i_low-1][j_low-1];\\n```\\n\\nand this is the total code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int n = mat.length, m = mat[0].length;\\n        int[][] result = new int[n][m];\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 1 ; j < m ; j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        for(int j = 0 ; j < m ; j++){\\n            for(int i = 1 ; i < n ; i++){\\n                mat[i][j] += mat[i-1][j];\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                int i_low = i-k, i_up = i+k;\\n                int j_low = j-k, j_up = j+k;\\n\\t\\t\\t\\t// if i_up and j_up is exceeding the range then we have to make it as the maximum possible range in the matrix.\\n                if(i_up >= n) i_up = n-1;\\n                if(j_up >= m) j_up = m-1;\\n                if(i_low <= 0 && j_low <= 0){\\n                    result[i][j] = mat[i_up][j_up];\\n                } else if(i_low <= 0){\\n                    result[i][j] = mat[i_up][j_up]-mat[i_up][j_low-1];\\n                } else if(j_low <= 0){\\n                    result[i][j] = mat[i_up][j_up]-mat[i_low-1][j_up];\\n                } else result[i][j] = mat[i_up][j_up]-mat[i_up][j_low-1]-\\n                    mat[i_low-1][j_up]+mat[i_low-1][j_low-1];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nTC --> Linear Time Complexity\\nSC --> Also  linear as we are storing the values into result matrix\\n![image](https://assets.leetcode.com/users/images/c29981dc-116e-48ff-a826-cb09e71cf12c_1621610434.64838.png)\\n### Thank You, Happy Learning....",
                "solutionTags": [],
                "code": "```\\nif(i_low <= 0 &&  j_low <= 0) result[i][j] = mat[i_up][j_up];\\n```\n```\\nif(i_low <= 0) result[i][j] = mat[i_up][j_up] - mat[i_up][j_low-1];\\n```\n```\\nif(j_low <= 0) result[i][j] = mat[i_up][j_up] - mat[i_low-1][j_up];\\n```\n```\\n// if i_ow and j_low are not <= 0\\nresult[i][j] = mat[i_up][j_up] - mat[i_up][j_low-1] - mat[i_low-1][j_up] + mat[i_low-1][j_low-1];\\n```\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int n = mat.length, m = mat[0].length;\\n        int[][] result = new int[n][m];\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 1 ; j < m ; j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        for(int j = 0 ; j < m ; j++){\\n            for(int i = 1 ; i < n ; i++){\\n                mat[i][j] += mat[i-1][j];\\n            }\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                int i_low = i-k, i_up = i+k;\\n                int j_low = j-k, j_up = j+k;\\n\\t\\t\\t\\t// if i_up and j_up is exceeding the range then we have to make it as the maximum possible range in the matrix.\\n                if(i_up >= n) i_up = n-1;\\n                if(j_up >= m) j_up = m-1;\\n                if(i_low <= 0 && j_low <= 0){\\n                    result[i][j] = mat[i_up][j_up];\\n                } else if(i_low <= 0){\\n                    result[i][j] = mat[i_up][j_up]-mat[i_up][j_low-1];\\n                } else if(j_low <= 0){\\n                    result[i][j] = mat[i_up][j_up]-mat[i_low-1][j_up];\\n                } else result[i][j] = mat[i_up][j_up]-mat[i_up][j_low-1]-\\n                    mat[i_low-1][j_up]+mat[i_low-1][j_low-1];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884851,
                "title": "c-o-m-n-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n            int n=mat.size(),m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n                for(int j=1;j<m;j++){\\n                        mat[i][j]+=mat[i][j-1];\\n                }\\n        }\\n            for(int i=0;i<m;i++){\\n                for(int j=1;j<n;j++){\\n                        mat[j][i]+=mat[j-1][i];\\n                }\\n        }\\n            vector<vector<int> > ans(n,vector<int>(m,0));\\n            for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                            int x1=max(-1,i-K-1),y1=max(-1,j-K-1),x2=min(n-1,i+K),y2=min(m-1,j+K);\\n                            if(x1==-1 && y1==-1){\\n                                    ans[i][j]=mat[x2][y2];\\n                            }\\n                            else if(x1==-1 || y1==-1){\\n                                    if(x1==-1)\\n                                            x1=x2;\\n                                    if(y1==-1)\\n                                            y1=y2;\\n                                    ans[i][j]=mat[x2][y2]-mat[x1][y1];\\n                            }\\n                            else\\n                                    ans[i][j]=mat[x2][y2]+mat[x1][y1]-mat[x1][y2]-mat[x2][y1];\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n            int n=mat.size(),m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n                for(int j=1;j<m;j++){\\n                        mat[i][j]+=mat[i][j-1];\\n                }\\n        }\\n            for(int i=0;i<m;i++){\\n                for(int j=1;j<n;j++){\\n                        mat[j][i]+=mat[j-1][i];\\n                }\\n        }\\n            vector<vector<int> > ans(n,vector<int>(m,0));\\n            for(int i=0;i<n;i++){\\n                    for(int j=0;j<m;j++){\\n                            int x1=max(-1,i-K-1),y1=max(-1,j-K-1),x2=min(n-1,i+K),y2=min(m-1,j+K);\\n                            if(x1==-1 && y1==-1){\\n                                    ans[i][j]=mat[x2][y2];\\n                            }\\n                            else if(x1==-1 || y1==-1){\\n                                    if(x1==-1)\\n                                            x1=x2;\\n                                    if(y1==-1)\\n                                            y1=y2;\\n                                    ans[i][j]=mat[x2][y2]-mat[x1][y1];\\n                            }\\n                            else\\n                                    ans[i][j]=mat[x2][y2]+mat[x1][y1]-mat[x1][y2]-mat[x2][y1];\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520251,
                "title": "python-solution-with-visualized-explanations-for-integrated-images",
                "content": "The key idea here is integrated image, a widely used technique in the field of image processing.\\n\\n![image](https://assets.leetcode.com/users/xuawai/image_1582632235.png)\\n\\nAnd the sum of a sub-matrix `S = A[1][1] + A[1][2] + A[2][1] + A[2][2]` can be calculated as `S = S1 - S2 - S3 + S4 = B[2][2]-B[2][0]-B[0][2]+B[0][0]`, which is th basis of our solution.\\n\\n![image](https://assets.leetcode.com/users/xuawai/image_1582632240.png)\\n\\n----\\n\\nSince `(r, c)` might be an invalid position in the matrix, we expand the matrix first to save the effort dealing with boundary conditions. For more details, refer to the codes. \\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat, K: int):\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        /* expand the m*n matrix to (m+2*(K+1))*(n+2*(K+1)) matrix */\\n        def expand(mat, K):\\n            new_mat = [[0 for _ in range(n + 2 * (K + 1))] for _ in range(m + 2 * (K + 1))]\\n            for i in range(m):\\n                for j in range(n):\\n                    new_mat[i + K + 1][j + K + 1] = mat[i][j]\\n            return new_mat\\n\\n        mat = expand(mat, K)\\n        /* compute the integrated image */\\n        for i in range(m + 2 * (K + 1)):\\n            for j in range(n + 2 * (K + 1)):\\n                top_v = mat[i - 1][j] if i - 1 >= 0 else 0\\n                left_v = mat[i][j - 1] if j - 1 >= 0 else 0\\n                top_left_v = mat[i - 1][j - 1] if i - 1 >= 0 and j - 1 >= 0 else 0\\n                mat[i][j] = mat[i][j] + top_v + left_v - top_left_v\\n\\n        /* compute the sum of each sub-matrix for answer[i][j].\\n         No boundary conditions have to be considered since we have expanded the original matrix\\n\\t\\t*/\\n        ans = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                ans[i][j] = mat[i + (K+1) + K][j + (K+1) + K] - mat[i + (K+1) + K][j]\\\\\\n                            - mat[i][j + (K+1) + K] + mat[i][j]\\n        return ans\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat, K: int):\\n        m = len(mat)\\n        n = len(mat[0])\\n\\n        /* expand the m*n matrix to (m+2*(K+1))*(n+2*(K+1)) matrix */\\n        def expand(mat, K):\\n            new_mat = [[0 for _ in range(n + 2 * (K + 1))] for _ in range(m + 2 * (K + 1))]\\n            for i in range(m):\\n                for j in range(n):\\n                    new_mat[i + K + 1][j + K + 1] = mat[i][j]\\n            return new_mat\\n\\n        mat = expand(mat, K)\\n        /* compute the integrated image */\\n        for i in range(m + 2 * (K + 1)):\\n            for j in range(n + 2 * (K + 1)):\\n                top_v = mat[i - 1][j] if i - 1 >= 0 else 0\\n                left_v = mat[i][j - 1] if j - 1 >= 0 else 0\\n                top_left_v = mat[i - 1][j - 1] if i - 1 >= 0 and j - 1 >= 0 else 0\\n                mat[i][j] = mat[i][j] + top_v + left_v - top_left_v\\n\\n        /* compute the sum of each sub-matrix for answer[i][j].\\n         No boundary conditions have to be considered since we have expanded the original matrix\\n\\t\\t*/\\n        ans = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                ans[i][j] = mat[i + (K+1) + K][j + (K+1) + K] - mat[i + (K+1) + K][j]\\\\\\n                            - mat[i][j + (K+1) + K] + mat[i][j]\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 477219,
                "title": "short-python",
                "content": "Of course with prefix sums, as always, so O(mn).\\n```\\nfrom itertools import accumulate as acc\\n\\nclass Solution:\\n    def matrixBlockSum(self, A, K):\\n        m, n = len(A), len(A[0])\\n        ps = [*zip(*map(acc, zip(*map(acc, A))))]\\n        def s(i, j):\\n            return i >= 0 <= j and ps[min(i, m-1)][min(j, n-1)]\\n        return [[s(i+K, j+K) - s(i-K-1, j+K) - s(i+K, j-K-1) + s(i-K-1, j-K-1)\\n                 for j in range(n)] for i in range(m)]\\n```\\nFirst I compute prefix sums, so that `ps[i][j]` is the sum of the submatrix from top-left to (i, j):\\n```\\n     A:                 ps:\\n[[1, 2, 3],      [( 1,  3,  6),\\n [4, 5, 6],  =>   ( 5, 12, 21),\\n [7, 8, 9]]       (12, 27, 45)]\\n```\\nFor example `ps[1][1] = 12` = 1+2+4+5.\\n\\nMy helper `s` looks up the `ps` value and adjusts out-of-bounds requests.\\n\\nAnd then I just compute the requested submatrix sums the usual way by combining four prefix sums.",
                "solutionTags": [],
                "code": "```\\nfrom itertools import accumulate as acc\\n\\nclass Solution:\\n    def matrixBlockSum(self, A, K):\\n        m, n = len(A), len(A[0])\\n        ps = [*zip(*map(acc, zip(*map(acc, A))))]\\n        def s(i, j):\\n            return i >= 0 <= j and ps[min(i, m-1)][min(j, n-1)]\\n        return [[s(i+K, j+K) - s(i-K-1, j+K) - s(i+K, j-K-1) + s(i-K-1, j-K-1)\\n                 for j in range(n)] for i in range(m)]\\n```\n```\\n     A:                 ps:\\n[[1, 2, 3],      [( 1,  3,  6),\\n [4, 5, 6],  =>   ( 5, 12, 21),\\n [7, 8, 9]]       (12, 27, 45)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477083,
                "title": "python-numpy-solution",
                "content": "```\\nimport numpy as np\\nclass Solution(object):\\n    def matrixBlockSum(self, mat, K):\\n        mat2 = np.array(mat)\\n        m,n = len(mat), len(mat[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                LCi, UCi = max(0,i-K), min(m,i+K)\\n                LCj, UCj = max(0,j-K), min(m,j+K)\\n                mat[i][j] = np.sum(mat2[LCi:UCi+1,LCj:UCj+1])\\n                \\n        return mat\\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nclass Solution(object):\\n    def matrixBlockSum(self, mat, K):\\n        mat2 = np.array(mat)\\n        m,n = len(mat), len(mat[0])\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                LCi, UCi = max(0,i-K), min(m,i+K)\\n                LCj, UCj = max(0,j-K), min(m,j+K)\\n                mat[i][j] = np.sum(mat2[LCi:UCi+1,LCj:UCj+1])\\n                \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484196,
                "title": "java-fast-solution-o-mn",
                "content": "![image](https://assets.leetcode.com/users/images/231cba59-fa97-41fd-b1eb-db0144d2a42a_1632532391.2037432.jpeg)\\nAbout how to calcuate specific sum, you can find the solution from the problem 304:https://leetcode.com/problems/range-sum-query-2d-immutable/submissions/\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] sum = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    sum[i][j] = mat[i][j];\\n                }else if(i == 0){\\n                    sum[0][j] = sum[0][j - 1] + mat[i][j];\\n                }else if(j == 0){\\n                    sum[i][0] = sum[i - 1][j] + mat[i][j];\\n                }else{\\n                    sum[i][j] = mat[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int[][] result = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            int iLow = Math.max(i - k, 0);\\n            int iHigh = Math.min(i + k, m - 1);\\n            for(int j = 0; j < n; j++){\\n                int jLow = Math.max(j - k, 0);\\n                int jHigh = Math.min(j + k, n - 1);\\n                if(iLow == 0 && jLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh];\\n                }\\n                else if(iLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iHigh][jLow - 1];\\n                }\\n                else if(jLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iLow - 1][jHigh];\\n                }else{\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iHigh][jLow - 1] - sum[iLow - 1][jHigh] + sum[iLow - 1][jLow - 1];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] sum = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == 0 && j == 0){\\n                    sum[i][j] = mat[i][j];\\n                }else if(i == 0){\\n                    sum[0][j] = sum[0][j - 1] + mat[i][j];\\n                }else if(j == 0){\\n                    sum[i][0] = sum[i - 1][j] + mat[i][j];\\n                }else{\\n                    sum[i][j] = mat[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int[][] result = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            int iLow = Math.max(i - k, 0);\\n            int iHigh = Math.min(i + k, m - 1);\\n            for(int j = 0; j < n; j++){\\n                int jLow = Math.max(j - k, 0);\\n                int jHigh = Math.min(j + k, n - 1);\\n                if(iLow == 0 && jLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh];\\n                }\\n                else if(iLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iHigh][jLow - 1];\\n                }\\n                else if(jLow == 0){\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iLow - 1][jHigh];\\n                }else{\\n                    result[i][j] = sum[iHigh][jHigh] - sum[iHigh][jLow - 1] - sum[iLow - 1][jHigh] + sum[iLow - 1][jLow - 1];\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450572,
                "title": "2-c-solution-explained-one-with-dp-and-one-without-dp",
                "content": "# **Brute force**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t//m and n are the size of the matrix (m * n)\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        vector<vector<int>> res(m);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t//start point of the rectangle to add for current res (so the most left-top value to add)\\n\\t\\t\\t\\t//note : when i - k or j - k is less than 0 set them to 0 to avoid errors\\n                int start_i = max(i - k, 0);\\n                int start_j = max(j - k, 0);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//end point of the rectangle to add for current res (so the most right-bottom value to add)\\n\\t\\t\\t\\t//note : when i + k is more than m set it to m - 1 to avoid errors\\n\\t\\t\\t\\t//note : when j + k is more than n set it to n - 1 to avoid errors\\n\\t\\t\\t\\tint end_i = min(i + k, m - 1);\\n                int end_j = min(j + k, n - 1);\\n\\n\\t\\t\\t     //temp is used to get the sum of the rectangle to add ( from the most left-top value to add to the most right-bottom value to add)\\n\\t\\t\\t\\t int temp = 0;\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t//start the loop from the most left-top value to add to the most right-bottom value to add\\n\\t\\t\\t\\t//and add the value gotten from the loop to temp \\n                for (int i2 = start_i; i2 <= end_i; i2++) {\\n                    for (int j2 = start_j; j2 <= end_j; j2++) {\\n                        temp += mat[i2][j2];\\n                    }\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//save temp to res[i]\\n                res[i].push_back(temp);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n# **Solution with dp**\\n##### a graphic example of this code \\n\\n`mat =` ![image](https://assets.leetcode.com/users/images/234e98d6-434b-49a3-bc33-d33e13792eb4_1631032286.5834684.png)\\n\\nprefix is the sum of all value on the its left and top values\\n`prefix  =`![image](https://assets.leetcode.com/users/images/fe9f070e-5c55-4fd8-b2e8-5db3d80bc4c6_1631032590.110889.png) \\nexample steps to get prefix \\n\\t1   = 1![image](https://assets.leetcode.com/users/images/cfd78e47-38ad-4b9a-b6ca-dde2f118fe70_1631032780.6209137.png)\\n3   = 1 + 2 ![image](https://assets.leetcode.com/users/images/a54b950b-29c2-4a16-b253-26f80a25b9ee_1631032813.739592.png)\\n6   = 1 + 2 + 3 ![image](https://assets.leetcode.com/users/images/bfa5d3db-892c-4d8d-ab36-d1e9789fd926_1631032834.894085.png)\\n5   = 1 + 4![image](https://assets.leetcode.com/users/images/c3e2cd7c-9a9a-4071-871b-f85feec8135b_1631032850.5958931.png)\\n12 = 1+ 2 +4 +5![image](https://assets.leetcode.com/users/images/3a02c080-71c0-4117-bf08-3bcad0f78863_1631032892.6218936.png)\\n...\\n\\n`k  = 1   ` `mat =` ![image](https://assets.leetcode.com/users/images/234e98d6-434b-49a3-bc33-d33e13792eb4_1631032286.5834684.png)     `prefix  =`![image](https://assets.leetcode.com/users/images/fe9f070e-5c55-4fd8-b2e8-5db3d80bc4c6_1631032590.110889.png)  `dp = `![image](https://assets.leetcode.com/users/images/04e4a05b-7ab3-4808-9cdd-80f99da9b021_1631033116.2625937.png)  \\n \\n example of step to get dp[2][2] (the last one on the bot-right)\\n*  we want this part![image](https://assets.leetcode.com/users/images/754c1718-e7a7-4cbb-b7f7-2e0b86a16873_1631033419.5090227.png)\\n*  so we get `prefix[2][2]` which is equal to 45 so the sum of all matrix ![image](https://assets.leetcode.com/users/images/5e49b9a9-b6e9-479a-be9a-c02d9599635e_1631033363.605127.png)\\n* from that we remove the top part ![image](https://assets.leetcode.com/users/images/be1ec77a-981f-4ac6-8a8d-ea0aed446aca_1631033449.1404293.png)\\n* then we remove the left part ![image](https://assets.leetcode.com/users/images/7bc15293-eb4d-42ea-8544-ab6ab4d9a62f_1631033472.9346817.png)\\n* since we remove the top left part twice we need to add it back ![image](https://assets.leetcode.com/users/images/10e4a526-a078-4de9-8055-fba6a30ca427_1631033525.752147.png)\\n* now we get the part that we want. \\n\\n\\n```\\n class Solution {\\n public:\\n     vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t //m and n are the size of the matrix (m * n)\\n         int m = mat.size(), n = mat[0].size();\\n\\t\\t \\n\\t\\t //see above to know what prefix is\\n         vector<vector<int>> prefix(m,vector<int> (n));\\n\\n         for (int i = 0; i < m; i++) {\\n             int sum = 0;\\n             for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t//sum is sum of all value of the left of mat[i][j] (include mat[i][j])\\n                 sum += mat[i][j];\\n\\t\\t\\t\\t //prefix is the sum of all value above and left of prefix[i][j] (include mat([i][j])\\n                 prefix[i][j] = sum + prefix[max(i - 1,0)][j];\\n             }\\n         }\\n\\n         vector<vector<int>> dp(m,vector<int>(n));\\n         for (int i = 0; i < m; i++) {\\n             for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t //index of the most top value to add\\n                 int start_i = i - k;\\n                 //index of the most left value to add\\n\\t\\t\\t\\t int start_j = j - k;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindex of the most bottom value to add\\n                 int end_i = min(i + k, m - 1);\\n\\t\\t\\t\\t index of the most right value to add \\n                 int end_j = min(j + k, n - 1);\\n\\n                 int extraPart = 0;\\n\\t\\t\\t\\t //if start_i is less than 1 means that there ins\\'t any extra part on the top\\n                 if (start_i > 0)extraPart += prefix[start_i - 1][end_j];\\n\\t\\t\\t\\t //if start_j is less than 1 means that there isn\\'t any extra part on the left\\n                 if (start_j > 0)extraPart += prefix[end_i][start_j - 1];\\n\\n                 //this is the part that extraPart count 2 times (so this part will delete 2 times, instead of 1, so we need to add it back)\\n                 int PartToAdd = 0;\\n\\t\\t\\t\\t //if start_i or start_j is less than 1 means that there isn\\'t a part that is delete twice\\n\\t\\t\\t\\t //because if start_i is less than 1 means we dind\\'t delete anything of the top, same for start_j (instead of the top, this case the left part)\\n                 if (start_i > 0 && start_j > 0)PartToAdd += prefix[start_i - 1][start_j - 1];\\n\\n                 dp[i][j] = prefix[end_i][end_j] - extraPart + PartToAdd;\\n             }\\n         }\\n\\n\\n         return dp;\\n     }\\n };\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t//m and n are the size of the matrix (m * n)\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        vector<vector<int>> res(m);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t//start point of the rectangle to add for current res (so the most left-top value to add)\\n\\t\\t\\t\\t//note : when i - k or j - k is less than 0 set them to 0 to avoid errors\\n                int start_i = max(i - k, 0);\\n                int start_j = max(j - k, 0);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//end point of the rectangle to add for current res (so the most right-bottom value to add)\\n\\t\\t\\t\\t//note : when i + k is more than m set it to m - 1 to avoid errors\\n\\t\\t\\t\\t//note : when j + k is more than n set it to n - 1 to avoid errors\\n\\t\\t\\t\\tint end_i = min(i + k, m - 1);\\n                int end_j = min(j + k, n - 1);\\n\\n\\t\\t\\t     //temp is used to get the sum of the rectangle to add ( from the most left-top value to add to the most right-bottom value to add)\\n\\t\\t\\t\\t int temp = 0;\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t//start the loop from the most left-top value to add to the most right-bottom value to add\\n\\t\\t\\t\\t//and add the value gotten from the loop to temp \\n                for (int i2 = start_i; i2 <= end_i; i2++) {\\n                    for (int j2 = start_j; j2 <= end_j; j2++) {\\n                        temp += mat[i2][j2];\\n                    }\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//save temp to res[i]\\n                res[i].push_back(temp);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```\\n class Solution {\\n public:\\n     vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t //m and n are the size of the matrix (m * n)\\n         int m = mat.size(), n = mat[0].size();\\n\\t\\t \\n\\t\\t //see above to know what prefix is\\n         vector<vector<int>> prefix(m,vector<int> (n));\\n\\n         for (int i = 0; i < m; i++) {\\n             int sum = 0;\\n             for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t//sum is sum of all value of the left of mat[i][j] (include mat[i][j])\\n                 sum += mat[i][j];\\n\\t\\t\\t\\t //prefix is the sum of all value above and left of prefix[i][j] (include mat([i][j])\\n                 prefix[i][j] = sum + prefix[max(i - 1,0)][j];\\n             }\\n         }\\n\\n         vector<vector<int>> dp(m,vector<int>(n));\\n         for (int i = 0; i < m; i++) {\\n             for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t //index of the most top value to add\\n                 int start_i = i - k;\\n                 //index of the most left value to add\\n\\t\\t\\t\\t int start_j = j - k;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tindex of the most bottom value to add\\n                 int end_i = min(i + k, m - 1);\\n\\t\\t\\t\\t index of the most right value to add \\n                 int end_j = min(j + k, n - 1);\\n\\n                 int extraPart = 0;\\n\\t\\t\\t\\t //if start_i is less than 1 means that there ins\\'t any extra part on the top\\n                 if (start_i > 0)extraPart += prefix[start_i - 1][end_j];\\n\\t\\t\\t\\t //if start_j is less than 1 means that there isn\\'t any extra part on the left\\n                 if (start_j > 0)extraPart += prefix[end_i][start_j - 1];\\n\\n                 //this is the part that extraPart count 2 times (so this part will delete 2 times, instead of 1, so we need to add it back)\\n                 int PartToAdd = 0;\\n\\t\\t\\t\\t //if start_i or start_j is less than 1 means that there isn\\'t a part that is delete twice\\n\\t\\t\\t\\t //because if start_i is less than 1 means we dind\\'t delete anything of the top, same for start_j (instead of the top, this case the left part)\\n                 if (start_i > 0 && start_j > 0)PartToAdd += prefix[start_i - 1][start_j - 1];\\n\\n                 dp[i][j] = prefix[end_i][end_j] - extraPart + PartToAdd;\\n             }\\n         }\\n\\n\\n         return dp;\\n     }\\n };\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182021,
                "title": "simple-c-solution-with-video",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        vector<vector<int>>a(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int x=-k;x<=k;x++){\\n                    if(i+x>=0 && i+x<n){\\n                        int l=max(j-k,0);\\n                        int r=j+k+1;\\n                        a[i+x][l]+=mat[i][j];\\n                        if(r<m) a[i+x][r]-=mat[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=0;\\n            for(int j=0;j<m;j++){\\n                sum+=a[i][j];\\n                a[i][j]=sum;\\n            }\\n        }\\n        re-\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        vector<vector<int>>a(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int x=-k;x<=k;x++){\\n                    if(i+x>=0 && i+x<n){\\n                        int l=max(j-k,0);\\n                        int r=j+k+1;\\n                        a[i+x][l]+=mat[i][j];\\n                        if(r<m) a[i+x][r]-=mat[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum=0;\\n            for(int j=0;j<m;j++){\\n                sum+=a[i][j];\\n                a[i][j]=sum;\\n            }\\n        }\\n        re-\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147882,
                "title": "2ms-100-faster-dp-solution-concept-of-prefix-sum-in-2-d-array",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    int n,m;\\n    int dp[][];\\n    int findSum(int r,int s,int p,int q){\\n        return dp[r+1][s+1]-dp[r+1][q]-dp[p][s+1]+dp[p][q];\\n    }\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        this.n=mat.length;\\n        this.m=mat[0].length;\\n         dp=new int[n+1][m+1];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                dp[i+1][j+1]=mat[i][j]+dp[i][j+1]+dp[i+1][j]-dp[i][j];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n                mat[i][j]=findSum(i+k<n ? i+k : n-1,j+k<m ? j+k : m-1,i-k>=0 ? i-k : 0 , j-k>=0 ? j-k : 0);\\n        }\\n        return mat;\\n    }\\n}\\n```\\nTime : O(n*m) \\nSpace: O(n*m)\\n***please,upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n,m;\\n    int dp[][];\\n    int findSum(int r,int s,int p,int q){\\n        return dp[r+1][s+1]-dp[r+1][q]-dp[p][s+1]+dp[p][q];\\n    }\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        this.n=mat.length;\\n        this.m=mat[0].length;\\n         dp=new int[n+1][m+1];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                dp[i+1][j+1]=mat[i][j]+dp[i][j+1]+dp[i+1][j]-dp[i][j];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n                mat[i][j]=findSum(i+k<n ? i+k : n-1,j+k<m ? j+k : m-1,i-k>=0 ? i-k : 0 , j-k>=0 ? j-k : 0);\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838172,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length, n = mat[0].length;\\n        int dp[][] = new int[m+1][n+1];\\n        int ans[][] = new int[m][n];\\n        computePrefix(dp,mat,m,n);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               int r1 = Math.max(0, i - K), c1 = Math.max(0, j - K);\\n               int r2 = Math.min(m - 1, i + K), c2 = Math.min(n - 1, j + K);   \\n               ans[i][j] = rangeSum(dp,r1,c1,r2,c2);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void computePrefix(int[][]dp,int[][]mat,int m, int n){\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1];\\n    }\\n    \\n    int rangeSum(int[][]dp,int r1,int c1, int r2, int c2){\\n        r1++; c1++; r2++; c2++;\\n        return dp[r2][c2] - dp[r1-1][c2] - dp[r2][c1-1] + dp[r1-1][c1-1];\\n    }\\n}\\n```\\n\\nPrefix sum technique on 2D matrix with amazing video link (Problem num 304)\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/discuss/836388/java-prefix-sum-inplace",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length, n = mat[0].length;\\n        int dp[][] = new int[m+1][n+1];\\n        int ans[][] = new int[m][n];\\n        computePrefix(dp,mat,m,n);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               int r1 = Math.max(0, i - K), c1 = Math.max(0, j - K);\\n               int r2 = Math.min(m - 1, i + K), c2 = Math.min(n - 1, j + K);   \\n               ans[i][j] = rangeSum(dp,r1,c1,r2,c2);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void computePrefix(int[][]dp,int[][]mat,int m, int n){\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++)\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1];\\n    }\\n    \\n    int rangeSum(int[][]dp,int r1,int c1, int r2, int c2){\\n        r1++; c1++; r2++; c2++;\\n        return dp[r2][c2] - dp[r1-1][c2] - dp[r2][c1-1] + dp[r1-1][c1-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831195,
                "title": "javascript-typescript-solution",
                "content": "// JS\\n// Runtime: 100 ms, faster than 83.15% of JavaScript online submissions for Matrix Block Sum.\\n// Memory Usage: 39.9 MB, less than 20.22% of JavaScript online submissions for Matrix Block Sum.\\n```\\nvar matrixBlockSum = function (mat, K) {\\n  const dp = [\\n    Array(mat[0].length + 1).fill(0),\\n    ...mat.map((row) => [0, ...row]),\\n  ];\\n\\n  for (let i = 0; i < mat.length; i++) {\\n    for (let j = 0; j < mat[0].length; j++) {\\n      dp[i + 1][j + 1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n    }\\n  }\\n\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  for (let i = 1; i < dp.length; i++) {\\n    const r1 = Math.max(0, i - K - 1);\\n    const r2 = Math.min(m, i + K);\\n    for (let j = 1; j < dp[0].length; j++) {\\n      const c1 = Math.max(0, j - K - 1);\\n      const c2 = Math.min(n, j + K);\\n\\n      mat[i - 1][j - 1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1];\\n    }\\n  }\\n\\n  return mat;\\n};\\n```\\n\\n// TS\\n// Runtime: 100 ms, faster than 100.00% of TypeScript online submissions for Matrix Block Sum.\\n// Memory Usage: 40.6 MB, less than 100.00% of TypeScript online submissions for Matrix Block Sum.\\n```\\nfunction matrixBlockSum(mat: number[][], K: number): number[][] {\\n  const dp: number[][] = [\\n    Array(mat[0].length + 1).fill(0),\\n    ...mat.map((row) => [0, ...row]),\\n  ];\\n\\n  for (let i = 0; i < mat.length; i++) {\\n    for (let j = 0; j < mat[0].length; j++) {\\n      dp[i + 1][j + 1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n    }\\n  }\\n\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  for (let i = 1; i < dp.length; i++) {\\n    const r1 = Math.max(0, i - K - 1);\\n    const r2 = Math.min(m, i + K);\\n    for (let j = 1; j < dp[0].length; j++) {\\n      const c1 = Math.max(0, j - K - 1);\\n      const c2 = Math.min(n, j + K);\\n\\n      mat[i - 1][j - 1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1];\\n    }\\n  }\\n\\n  return mat;\\n}\\n```\\n\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar matrixBlockSum = function (mat, K) {\\n  const dp = [\\n    Array(mat[0].length + 1).fill(0),\\n    ...mat.map((row) => [0, ...row]),\\n  ];\\n\\n  for (let i = 0; i < mat.length; i++) {\\n    for (let j = 0; j < mat[0].length; j++) {\\n      dp[i + 1][j + 1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n    }\\n  }\\n\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  for (let i = 1; i < dp.length; i++) {\\n    const r1 = Math.max(0, i - K - 1);\\n    const r2 = Math.min(m, i + K);\\n    for (let j = 1; j < dp[0].length; j++) {\\n      const c1 = Math.max(0, j - K - 1);\\n      const c2 = Math.min(n, j + K);\\n\\n      mat[i - 1][j - 1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1];\\n    }\\n  }\\n\\n  return mat;\\n};\\n```\n```\\nfunction matrixBlockSum(mat: number[][], K: number): number[][] {\\n  const dp: number[][] = [\\n    Array(mat[0].length + 1).fill(0),\\n    ...mat.map((row) => [0, ...row]),\\n  ];\\n\\n  for (let i = 0; i < mat.length; i++) {\\n    for (let j = 0; j < mat[0].length; j++) {\\n      dp[i + 1][j + 1] = mat[i][j] + dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\\n    }\\n  }\\n\\n  const m = mat.length;\\n  const n = mat[0].length;\\n\\n  for (let i = 1; i < dp.length; i++) {\\n    const r1 = Math.max(0, i - K - 1);\\n    const r2 = Math.min(m, i + K);\\n    for (let j = 1; j < dp[0].length; j++) {\\n      const c1 = Math.max(0, j - K - 1);\\n      const c2 = Math.min(n, j + K);\\n\\n      mat[i - 1][j - 1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1];\\n    }\\n  }\\n\\n  return mat;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826274,
                "title": "c-prefix-sum-solution",
                "content": "Runtime: 16 ms, faster than 89.46% of C++ online submissions for Matrix Block Sum.\\nMemory Usage: 9.3 MB, less than 97.16% of C++ online submissions for Matrix Block Sum.\\n\\nSolve using prefix sum of row wise sum and then colum wise sum.\\n```\\nGiven Matrix:\\n\\n1, 2, 3\\n4, 5, 6\\n7, 8, 9\\n\\nPrefix Sum matrix:\\n\\n1, 2, 3                     1, 3, 6                               1, 3, 6\\n4, 5, 6       Row Sum ->    4 ,9, 15          Column Sum->        5, 12, 21\\n7, 8, 9                     7, 15, 24                             12, 27, 45 \\n\\nThen exclude and include index based on conditions.\\n\\nGiven K, there is lr,hr and lc,hc for index i and j of Matrix\\nResult [i][j] = mat[hr][hc] - mat[hr][lc-1] - mat[lr-1][hc] + mat[lr-1][lc-1]\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int max(int a, int b)\\n    {\\n        return a>b?a:b;\\n    }\\n    int min(int a, int b)\\n    {\\n        return a<b?a:b;\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        \\n        int r = mat.size();\\n        int c = mat[0].size();\\n        vector<vector<int>> res(r,vector<int>(c));\\n        \\n        int sum = 0;\\n        for(int i=0;i<r;i++)\\n        {\\n            sum = 0;\\n            for(int j=0;j<c;j++)\\n            {\\n                sum+= mat[i][j];\\n                if(i>0)mat[i][j] = mat[i-1][j] + sum;\\n                else mat[i][j] = sum;\\n            }\\n        }\\n\\n        int lower_i;\\n        int lower_j;\\n        int upper_i;\\n        int upper_j;\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                lower_i = max(0,i-K);\\n                upper_i = min(i+K,r-1);\\n                lower_j = max(0,j-K);\\n                upper_j = min(j+K,c-1);\\n                \\n                res[i][j] = mat[upper_i][upper_j] - ((lower_j==0)?0:mat[upper_i][lower_j-1]) - ((lower_i==0)?0:mat[lower_i-1][upper_j]) + ((lower_i==0 || lower_j==0)?0:mat[lower_i-1][lower_j-1]);\\n            }         \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nGiven Matrix:\\n\\n1, 2, 3\\n4, 5, 6\\n7, 8, 9\\n\\nPrefix Sum matrix:\\n\\n1, 2, 3                     1, 3, 6                               1, 3, 6\\n4, 5, 6       Row Sum ->    4 ,9, 15          Column Sum->        5, 12, 21\\n7, 8, 9                     7, 15, 24                             12, 27, 45 \\n\\nThen exclude and include index based on conditions.\\n\\nGiven K, there is lr,hr and lc,hc for index i and j of Matrix\\nResult [i][j] = mat[hr][hc] - mat[hr][lc-1] - mat[lr-1][hc] + mat[lr-1][lc-1]\\n```\n```\\nclass Solution {\\npublic:\\n    int max(int a, int b)\\n    {\\n        return a>b?a:b;\\n    }\\n    int min(int a, int b)\\n    {\\n        return a<b?a:b;\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        \\n        int r = mat.size();\\n        int c = mat[0].size();\\n        vector<vector<int>> res(r,vector<int>(c));\\n        \\n        int sum = 0;\\n        for(int i=0;i<r;i++)\\n        {\\n            sum = 0;\\n            for(int j=0;j<c;j++)\\n            {\\n                sum+= mat[i][j];\\n                if(i>0)mat[i][j] = mat[i-1][j] + sum;\\n                else mat[i][j] = sum;\\n            }\\n        }\\n\\n        int lower_i;\\n        int lower_j;\\n        int upper_i;\\n        int upper_j;\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                lower_i = max(0,i-K);\\n                upper_i = min(i+K,r-1);\\n                lower_j = max(0,j-K);\\n                upper_j = min(j+K,c-1);\\n                \\n                res[i][j] = mat[upper_i][upper_j] - ((lower_j==0)?0:mat[upper_i][lower_j-1]) - ((lower_i==0)?0:mat[lower_i-1][upper_j]) + ((lower_i==0 || lower_j==0)?0:mat[lower_i-1][lower_j-1]);\\n            }         \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457291,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> answer(mat.size(), vector<int>(mat[0].size()));\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.size()) {\\n                    rowEnd = mat.size() - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].size()) {\\n                    colEnd = mat[0].size() - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n    int blockSum(vector<vector<int>>& mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> answer(mat.size(), vector<int>(mat[0].size()));\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.size()) {\\n                    rowEnd = mat.size() - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].size()) {\\n                    colEnd = mat[0].size() - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n    int blockSum(vector<vector<int>>& mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421407,
                "title": "c-easy-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n```\\n1. Create a 2D vector sum of size (row+1) x (col+1) and initialize all elements to 0.\\n\\n2. Compute the prefix sum of the input matrix mat and store the results in sum using the formula:\\n\\n    sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1]\\n\\n3. Create a 2D vector ans of size row x col and initialize all elements to 0.\\n\\n4. For each element ans[i][j] in the output matrix:\\n\\n    Compute the coordinates of the submatrix to sum over using the variables x1, y1, x2, and y2, where:\\n\\n    x1 = max(0, i-k)\\n    y1 = max(0, j-k)\\n    x2 = min(row, i+k+1)\\n    y2 = min(col, j+k+1)\\n\\n5. Compute the sum of the submatrix using the prefix sum stored in sum and store the result in ans[i][j] using the formula:\\n\\n    ans[i][j] = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1]\\nReturn the output matrix ans.\\n\\n\\n\\n```\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        \\n        // Create a 2D vector to store the prefix sum\\n        vector<vector<int>> sum(row+1, vector<int>(col+1, 0));\\n\\n        // Compute prefix sum\\n        for(int i=1; i<=row; i++) {\\n            for(int j=1; j<=col; j++) {\\n                // Compute the sum of the submatrix from (0, 0) to (i-1, j-1)\\n                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1];\\n            }\\n        }\\n\\n        // Compute answer\\n        vector<vector<int>> ans(row, vector<int>(col, 0));\\n        for(int i=0; i<row; i++) {\\n            for(int j=0; j<col; j++) {\\n                // Compute the coordinates of the submatrix\\n                int x1 = max(0, i-k);\\n                int y1 = max(0, j-k);\\n                int x2 = min(row, i+k+1);\\n                int y2 = min(col, j+k+1);\\n\\n                // Compute the sum of the submatrix using the prefix sum\\n                ans[i][j] = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nPlease upvote if you find this helpful!",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n1. Create a 2D vector sum of size (row+1) x (col+1) and initialize all elements to 0.\\n\\n2. Compute the prefix sum of the input matrix mat and store the results in sum using the formula:\\n\\n    sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1]\\n\\n3. Create a 2D vector ans of size row x col and initialize all elements to 0.\\n\\n4. For each element ans[i][j] in the output matrix:\\n\\n    Compute the coordinates of the submatrix to sum over using the variables x1, y1, x2, and y2, where:\\n\\n    x1 = max(0, i-k)\\n    y1 = max(0, j-k)\\n    x2 = min(row, i+k+1)\\n    y2 = min(col, j+k+1)\\n\\n5. Compute the sum of the submatrix using the prefix sum stored in sum and store the result in ans[i][j] using the formula:\\n\\n    ans[i][j] = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1]\\nReturn the output matrix ans.\\n\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        \\n        // Create a 2D vector to store the prefix sum\\n        vector<vector<int>> sum(row+1, vector<int>(col+1, 0));\\n\\n        // Compute prefix sum\\n        for(int i=1; i<=row; i++) {\\n            for(int j=1; j<=col; j++) {\\n                // Compute the sum of the submatrix from (0, 0) to (i-1, j-1)\\n                sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i-1][j-1];\\n            }\\n        }\\n\\n        // Compute answer\\n        vector<vector<int>> ans(row, vector<int>(col, 0));\\n        for(int i=0; i<row; i++) {\\n            for(int j=0; j<col; j++) {\\n                // Compute the coordinates of the submatrix\\n                int x1 = max(0, i-k);\\n                int y1 = max(0, j-k);\\n                int x2 = min(row, i+k+1);\\n                int y2 = min(col, j+k+1);\\n\\n                // Compute the sum of the submatrix using the prefix sum\\n                ans[i][j] = sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151656,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Brute force appoarch-->\\n\\n# Approach\\n<!-- Iterate through each grid and perform the query -->\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(n*m)^2\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum(int r1,int c1,int r2,int c2,vector<vector<int>>& mat){\\n        int res=0;\\n        for(int i=r1;i<=r2;i++){\\n            for(int j=c1;j<=c2;j++)\\n              res+=mat[i][j];\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int r1=i-k<0?0:i-k;\\n               int r2=i+k>=n?n-1:i+k;\\n               int c1=j-k<0?0:j-k;\\n                int c2=j+k>=m?m-1:j+k;\\n                ans[i][j]=sum(r1,c1,r2,c2,mat);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(int r1,int c1,int r2,int c2,vector<vector<int>>& mat){\\n        int res=0;\\n        for(int i=r1;i<=r2;i++){\\n            for(int j=c1;j<=c2;j++)\\n              res+=mat[i][j];\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int r1=i-k<0?0:i-k;\\n               int r2=i+k>=n?n-1:i+k;\\n               int c1=j-k<0?0:j-k;\\n                int c2=j+k>=m?m-1:j+k;\\n                ans[i][j]=sum(r1,c1,r2,c2,mat);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303421,
                "title": "python-faster-than-99-o-m-n-dynamic-programming",
                "content": "* First create **a table** where each element equals **the sum of all the elements** that is **left or above** to it (including itself).\\n* Then use this table to **calculate each position**, the trick is mat[i][j]=table[rol1][col1]-table[rol1][col2]-table[rol2][col1]+table[rol2][col2] as the following picture shows( here suppose **K=1**).\\n![image](https://assets.leetcode.com/users/images/f32ade49-1d7f-4754-8745-259864e4cb07_1658222708.851402.png)\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat, K: int) -> List[List[int]]:\\n        m,n=len(mat),len(mat[0])\\n        table = [[0]*(n+1) for _ in range(m+1)]\\n        # res=table.copy()\\n        for i in range(m):\\n            for j in range(n):\\n                table[i+1][j+1]=mat[i][j]+table[i+1][j]+table[i][j+1]-table[i][j]\\n        for i in range(m):\\n            for j in range(n):\\n                rol1=i+K+1 if i+K+1<m+1 else m\\n                rol2=i-K if i-K>=0 else 0\\n                col1=j+K+1 if j+K+1<n+1 else n\\n                col2=j-K if j-K>=0 else 0\\n                mat[i][j]=table[rol1][col1]-table[rol1][col2]-table[rol2][col1]+table[rol2][col2]\\n        return mat\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat, K: int) -> List[List[int]]:\\n        m,n=len(mat),len(mat[0])\\n        table = [[0]*(n+1) for _ in range(m+1)]\\n        # res=table.copy()\\n        for i in range(m):\\n            for j in range(n):\\n                table[i+1][j+1]=mat[i][j]+table[i+1][j]+table[i][j+1]-table[i][j]\\n        for i in range(m):\\n            for j in range(n):\\n                rol1=i+K+1 if i+K+1<m+1 else m\\n                rol2=i-K if i-K>=0 else 0\\n                col1=j+K+1 if j+K+1<n+1 else n\\n                col2=j-K if j-K>=0 else 0\\n                mat[i][j]=table[rol1][col1]-table[rol1][col2]-table[rol2][col1]+table[rol2][col2]\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014863,
                "title": "java-separate-row-and-column-calculations-faster-than-99",
                "content": "We can firstly consider only the rows: traverse each row, and calculate the sum of (2k + 1) numbers for each entry. Store these row sums in an mn matrix rowSum[][].\\n\\nAnd then use the same method for the columns. Traverse each column, and calculate the sum of (2k + 1) numbers from rowSum[][].\\n\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m][n];\\n        int[][] rowSum = new int[m][n];\\n        \\n        // firstly, calculate the row sum\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (j == 0) {\\n                    for (int l = 0; l <= k && l < n; l++) {\\n                        rowSum[i][j] += mat[i][l];\\n                    }\\n                } else {\\n                    int next = 0, prev = 0;\\n                    if (j+k < n) next = mat[i][j+k];\\n                    if (j-1-k >= 0) prev = mat[i][j-1-k];\\n\\n                    rowSum[i][j] = rowSum[i][j-1] + next - prev;\\n                }\\n            }\\n        }\\n        \\n        // secondly, calculate the column sum\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (i == 0) {\\n                    for (int l = 0; l <= k && l < m; l++) {\\n                        dp[i][j] += rowSum[l][j];\\n                    }\\n                } else {\\n                    int next = 0, prev = 0;\\n                    if (i+k < m) next = rowSum[i+k][j];\\n                    if (i-1-k >= 0) prev = rowSum[i-1-k][j];\\n\\n                    dp[i][j] = dp[i-1][j] + next - prev;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m][n];\\n        int[][] rowSum = new int[m][n];\\n        \\n        // firstly, calculate the row sum\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (j == 0) {\\n                    for (int l = 0; l <= k && l < n; l++) {\\n                        rowSum[i][j] += mat[i][l];\\n                    }\\n                } else {\\n                    int next = 0, prev = 0;\\n                    if (j+k < n) next = mat[i][j+k];\\n                    if (j-1-k >= 0) prev = mat[i][j-1-k];\\n\\n                    rowSum[i][j] = rowSum[i][j-1] + next - prev;\\n                }\\n            }\\n        }\\n        \\n        // secondly, calculate the column sum\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (i == 0) {\\n                    for (int l = 0; l <= k && l < m; l++) {\\n                        dp[i][j] += rowSum[l][j];\\n                    }\\n                } else {\\n                    int next = 0, prev = 0;\\n                    if (i+k < m) next = rowSum[i+k][j];\\n                    if (i-1-k >= 0) prev = rowSum[i-1-k][j];\\n\\n                    dp[i][j] = dp[i-1][j] + next - prev;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904651,
                "title": "explained-c-dynamic-programming-solution-using-prefix-sum-2d-o-n-m",
                "content": "**Explanation**\\n1. First, we will create a 2D vector named dp where `dp[i][j]` is the sum of all cells from `(0,0)` to `(i,j)`.\\n2. Then we will build our ans vector, where `ans[i][j] = dp[i+k][j+k] - dp[i-k-1][j+k] - dp[i+k][j-k-1] + dp[i-k-1][j-k-1];`\\n3. Finally return the vector `ans`.\\n**Don\\'t forget to upvote if this help you !**\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> prefix(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                prefix[i][j] = (j > 0 ? prefix[i][j-1] + mat[i][j] : mat[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<int>>dp(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + prefix[i][j];\\n            }\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                int top_row = min(i + k, n - 1), top_col = min(j + k, m - 1);\\n                int down_row_top_col = (i - k - 1 < 0 ? 0 : dp[i-k-1][top_col]);\\n                int top_row_down_col = ( j -k - 1 < 0 ? 0 : dp[top_row][j-k-1]);\\n                int down_row_down_col = ( i- k - 1 < 0 || j - k -1 < 0 ? 0 : dp[i-k-1][j-k-1]);\\n                \\n                ans[i][j] = dp[top_row][top_col] - down_row_top_col - top_row_down_col + down_row_down_col;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> prefix(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                prefix[i][j] = (j > 0 ? prefix[i][j-1] + mat[i][j] : mat[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<int>>dp(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + prefix[i][j];\\n            }\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for (int i = 0 ; i < n ; i++){\\n            for (int j = 0 ; j < m ; j++){\\n                int top_row = min(i + k, n - 1), top_col = min(j + k, m - 1);\\n                int down_row_top_col = (i - k - 1 < 0 ? 0 : dp[i-k-1][top_col]);\\n                int top_row_down_col = ( j -k - 1 < 0 ? 0 : dp[top_row][j-k-1]);\\n                int down_row_down_col = ( i- k - 1 < 0 || j - k -1 < 0 ? 0 : dp[i-k-1][j-k-1]);\\n                \\n                ans[i][j] = dp[top_row][top_col] - down_row_top_col - top_row_down_col + down_row_down_col;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746375,
                "title": "c-frefixsum-in-matrix-3ms-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k) {\\n\\t\\t\\tint m = mat.size(), n = mat[0].size();\\n\\n\\t\\t\\tvector<vector<int>> ans(m, vector<int>(n));\\n\\t\\t\\tvector<vector<int>> prefix_sum(105, vector<int>(105));\\n\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint x = i + 1, y = j + 1;\\n\\t\\t\\t\\t\\tprefix_sum[x][y] = mat[i][j] + prefix_sum[x][y - 1] + prefix_sum[x - 1][y] - prefix_sum[x - 1][y - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint r1, r2, c1, c2;\\n\\t\\t\\t\\t\\tr1 = ((i - k >= 0) ? i - k : 0);\\n\\t\\t\\t\\t\\tc1 = ((j - k >= 0) ? j - k : 0);\\n\\t\\t\\t\\t\\tr2 = ((i + k <= m - 1) ? i + k : m - 1);\\n\\t\\t\\t\\t\\tc2 = ((j + k <= n - 1) ? j + k : n - 1);\\n\\n\\t\\t\\t\\t\\tans[i][j] = prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r1][c2 + 1] - prefix_sum[r2 + 1][c1] + prefix_sum[r1][c1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k) {\\n\\t\\t\\tint m = mat.size(), n = mat[0].size();\\n\\n\\t\\t\\tvector<vector<int>> ans(m, vector<int>(n));\\n\\t\\t\\tvector<vector<int>> prefix_sum(105, vector<int>(105));\\n\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tint x = i + 1, y = j + 1;\\n\\t\\t\\t\\t\\tprefix_sum[x][y] = mat[i][j] + prefix_sum[x][y - 1] + prefix_sum[x - 1][y] - prefix_sum[x - 1][y - 1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1716889,
                "title": "python-prefix",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        #calculate the value sum with mat[0][0] as top left corner, and mat[i][j] as the bottom right corner and store in dp matrix\\n        #res[i][j] is the sum of the square with mat[i-k][j-k] as the top right corner and mat[i+k][j+k] as the bottom right corner\\n        #square sum of row1co1 as top left and row2col2 as the bottom right = dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\\n        #O(m*n) time and space\\n        \\n        m, n = len(mat), len(mat[0])\\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] + mat[i][j] - dp[i][j]\\n                \\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                row1, row2 = max(0, i - k), min(i + k, m-1)\\n                col1, col2 = max(0, j - k), min(j + k, n-1)\\n                res[i][j] = dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\\n        \\n        return res\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        #calculate the value sum with mat[0][0] as top left corner, and mat[i][j] as the bottom right corner and store in dp matrix\\n        #res[i][j] is the sum of the square with mat[i-k][j-k] as the top right corner and mat[i+k][j+k] as the bottom right corner\\n        #square sum of row1co1 as top left and row2col2 as the bottom right = dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\\n        #O(m*n) time and space\\n        \\n        m, n = len(mat), len(mat[0])\\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] + mat[i][j] - dp[i][j]\\n                \\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                row1, row2 = max(0, i - k), min(i + k, m-1)\\n                col1, col2 = max(0, j - k), min(j + k, n-1)\\n                res[i][j] = dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1]\\n        \\n        return res\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357430,
                "title": "python-o-mn-easy-using-slicing",
                "content": "```class Solution(object):\\n    def matrixBlockSum(self, mat, k):\\n         \\n        col = len(mat[0])\\n        row=len(mat)\\n        new_mat = [[0]*col for i in range(0,row)]\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                new_mat[i][j] = sum([sum(ele[max(j-k,0):min(j+k+1,col)]) for ele in mat[max(i-k,0):min(i+k+1,row)]])\\n                \\n        return new_mat",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution(object):\\n    def matrixBlockSum(self, mat, k):\\n         \\n        col = len(mat[0])\\n        row=len(mat)\\n        new_mat = [[0]*col for i in range(0,row)]\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                new_mat[i][j] = sum([sum(ele[max(j-k,0):min(j+k+1,col)]) for ele in mat[max(i-k,0):min(i+k+1,row)]])\\n                \\n        return new_mat",
                "codeTag": "Java"
            },
            {
                "id": 1235611,
                "title": "c-easy-cumulative-sum-dp",
                "content": "12ms\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int> > dp(m+1,vector<int>(n+1,0));\\n        //build the dp vector\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        \\n        \\n     \\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                int r1=max(0,i-k)+1; //starting row coordinate of the block\\n                int c1=max(0,j-k)+1; //starting column coordinate of the block\\n                int r2= min(i+k+1,m); //ending row coordinate of the block\\n                int c2= min(j+k+1,n); // ending column coordinate of the block\\n                \\n                ans[i][j]=dp[r2][c2]+dp[r1-1][c1-1]-dp[r1-1][c2]-dp[r2][c1-1]; //value of the block calculated with the dp vector built\\n                \\n            }\\n        }\\n      return ans;  \\n        \\n        \\n    }\\n};\\n\\n/*\\n    Given Matrix:\\n\\n    1, 2, 3\\n    4, 5, 6\\n    7, 8, 9\\n\\n    Prefix Sum matrix:\\n\\n    1, 2, 3                     1, 3, 6                               1, 3, 6\\n    4, 5, 6       Row Sum ->    4 ,9, 15          Column Sum->        5, 12, 21     -> final dp matrix\\n    7, 8, 9                     7, 15, 24                             12, 27, 45 \\n    \\n    To get sum of a sub array from index a to index b, sum(a, b), we can instead calculate prefix(b) - prefix(a-1)\\n    \\n    Similarly, Sum of an arbitrary block from (i-K, j-K) to (i+K, j+K)\\nans(i, j) = prefix(i+K, j+K) - prefix(i+K, j-K-1) - prefix (i-K-1, j+K) + prefix(i-K-1, j-K-1);\\n\\n*/",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int> > dp(m+1,vector<int>(n+1,0));\\n        //build the dp vector\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + matrix[i - 1][j - 1] - dp[i - 1][j - 1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1167795,
                "title": "c-4ms-beats-98-74",
                "content": "\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        /*\\n        1 2 3 \\n        4 5 6\\n        7 8 9\\n            \\n        result matrix\\n        12 21 16\\n        27 45 33\\n        24 39 28\\n        \\n        prefix matrix\\n        1  3  6\\n        5  12 21\\n        12 27 45\\n        \\n        \\n        */\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        \\n        vector<vector<int>> sum = mat, res = mat;\\n        \\n        for (int i = 1; i < c; ++i)\\n        {\\n            sum[0][i] += sum[0][i - 1];\\n        }\\n        for (int i = 1; i < r; ++i)\\n        {\\n            sum[i][0] += sum[i - 1][0];\\n        }\\n        \\n        for (int i = 1; i < r; ++i)\\n        {\\n            for (int j = 1; j < c; ++j)\\n            {\\n                sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\\n            }\\n        }\\n\\n        for (int i = 0; i < r; ++i)\\n        {\\n            for (int j = 0; j < c; ++j)\\n            {\\n                int north = i - k <= 0 ? 0 : i - k;\\n                int south = i + k >= r ? r - 1 : i + k;\\n                \\n                int west = j - k <= 0 ? 0 : j - k;\\n                int east = j + k >= c ? c - 1 : j + k;\\n                \\n                res[i][j] = sum[south][east];\\n                \\n                if (north != 0)\\n                {\\n                    res[i][j] -= sum[north - 1][east];\\n                }\\n                if (west != 0)\\n                {\\n                    res[i][j] -= sum[south][west - 1];\\n                }\\n                if (north != 0 and west != 0)\\n                {\\n                    res[i][j] += sum[north - 1][west - 1];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        /*\\n        1 2 3 \\n        4 5 6\\n        7 8 9\\n            \\n        result matrix\\n        12 21 16\\n        27 45 33\\n        24 39 28\\n        \\n        prefix matrix\\n        1  3  6\\n        5  12 21\\n        12 27 45\\n        \\n        \\n        */\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        \\n        vector<vector<int>> sum = mat, res = mat;\\n        \\n        for (int i = 1; i < c; ++i)\\n        {\\n            sum[0][i] += sum[0][i - 1];\\n        }\\n        for (int i = 1; i < r; ++i)\\n        {\\n            sum[i][0] += sum[i - 1][0];\\n        }\\n        \\n        for (int i = 1; i < r; ++i)\\n        {\\n            for (int j = 1; j < c; ++j)\\n            {\\n                sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\\n            }\\n        }\\n\\n        for (int i = 0; i < r; ++i)\\n        {\\n            for (int j = 0; j < c; ++j)\\n            {\\n                int north = i - k <= 0 ? 0 : i - k;\\n                int south = i + k >= r ? r - 1 : i + k;\\n                \\n                int west = j - k <= 0 ? 0 : j - k;\\n                int east = j + k >= c ? c - 1 : j + k;\\n                \\n                res[i][j] = sum[south][east];\\n                \\n                if (north != 0)\\n                {\\n                    res[i][j] -= sum[north - 1][east];\\n                }\\n                if (west != 0)\\n                {\\n                    res[i][j] -= sum[south][west - 1];\\n                }\\n                if (north != 0 and west != 0)\\n                {\\n                    res[i][j] += sum[north - 1][west - 1];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 809144,
                "title": "c-dynamic-programming-sol-o-n2-similar-to-304-range-sum-query-2d-immutable",
                "content": "Similar to #304 Range Sum Query 2D-Immutable first solve that then do this.\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=1;i<n;i++){\\n            mat[i][0]+=mat[i-1][0];\\n        }\\n        for(int j=1;j<m;j++){\\n            mat[0][j]+=mat[0][j-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=(mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1]);\\n            }\\n        }\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int r1=max(0,i-k),r2=min(n-1,i+k);\\n                int c1=max(0,j-k),c2=min(m-1,j+k);\\n                if(r1!=0 && c1!=0){\\n                    ans[i][j]=mat[r2][c2]-mat[r2][c1-1]-mat[r1-1][c2]+mat[r1-1][c1-1];\\n                }else if(r1==0 && c1==0){\\n                    ans[i][j]=mat[r2][c2];\\n                }else if(r1==0){\\n                    ans[i][j]=mat[r2][c2]-mat[r2][c1-1];\\n                }else if(c1==0){\\n                    ans[i][j]=mat[r2][c2]-mat[r1-1][c2];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=1;i<n;i++){\\n            mat[i][0]+=mat[i-1][0];\\n        }\\n        for(int j=1;j<m;j++){\\n            mat[0][j]+=mat[0][j-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=(mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1]);\\n            }\\n        }\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int r1=max(0,i-k),r2=min(n-1,i+k);\\n                int c1=max(0,j-k),c2=min(m-1,j+k);\\n                if(r1!=0 && c1!=0){\\n                    ans[i][j]=mat[r2][c2]-mat[r2][c1-1]-mat[r1-1][c2]+mat[r1-1][c1-1];\\n                }else if(r1==0 && c1==0){\\n                    ans[i][j]=mat[r2][c2];\\n                }else if(r1==0){\\n                    ans[i][j]=mat[r2][c2]-mat[r2][c1-1];\\n                }else if(c1==0){\\n                    ans[i][j]=mat[r2][c2]-mat[r1-1][c2];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725648,
                "title": "python-3-explanation-diagram-192-ms",
                "content": "* This problem is asking us to build an `answer` matrix by drawing out boxes from each current point with a width and height of `K`.\\n* This problem is visualised for the first example given in the question, with `K=1`:\\n\\n![image](https://assets.leetcode.com/users/images/2ee753c9-efe2-4847-80bb-4fd79cc69aae_1594209444.6316206.png)\\n\\n* The brute-force method requires solving **overlapping sub-problems** multiple times. So here a Dynamic Programming approach should be followed.\\n* We can *store* the results for our overlapping sub-problems by using a cumulative sum.\\n* Each entry `i, j` in `cumulativeSum` stores the sum from drawing a box from `row=0, col=0` to `row=i, col=j`.\\n* This problem can therefore be broken down into two sub-problems:\\n1. How do we build a cumulative sum matrix?\\n2. How do we use this cumulative sum matrix?\\n\\n* In the first example given, we need to build a `cumulativeSum` matrix that looks like:\\n\\n```\\nK=1\\nmat = [\\n\\t[1, 2, 3],\\n\\t[4, 5, 6],\\n\\t[7, 8, 9]\\n]\\ncumulativeSum = [\\n\\t[1 , 3 , 6 ],\\n\\t[5 , 12, 21],\\n\\t[12, 27, 45]\\n]\\nanswer = [\\n\\t[12, 21, 16],\\n\\t[27, 45, 33],\\n\\t[24, 39, 28]\\n]\\n```\\n* To build a `cumulativeSum` matrix we can re-use the previous results in the matrix, working from the top left corner.\\n```\\ndef getCumulativeSum(mat: List[List[int]], m: int, n: int) -> List[List[int]]:\\n\\tcumulativeSum = [[None for _ in range(n)] for _ in range(m)]\\n    cumulativeSum[0][0] = mat[0][0] # Base case.\\n        \\n    # For the 0th row and 0th column, you just add what\\'s left or above the current point in the cumulativeSum matrix.\\n    for c in range(1, n):\\n\\t\\tcumulativeSum[0][c] = cumulativeSum[0][c - 1] + mat[0][c]\\n\\tfor r in range(1, m):\\n\\t\\tcumulativeSum[r][0] = cumulativeSum[r - 1][0] + mat[r][0]\\n        \\n\\t# For other rows and columns, add what\\'s above, what\\'s to the left, and subtract what\\'s above & to the left respectively.\\n    for r in range(1, m):\\n\\t\\tfor c in range(1, n):\\n\\t\\t\\tcumulativeSum[r][c] = mat[r][c] + cumulativeSum[r-1][c] + cumulativeSum[r][c-1] - cumulativeSum[r-1][c-1]\\n                \\n\\treturn cumulativeSum\\n```\\n* We can then use the entries in `cumulativeSum` by taking the bottom-right-most element of the box drawn by adding or taking away `K` from the current index.\\n* This is illustrated easily by considering some examples in the visualisation at the top:\\n1. For `row=0, col=0` of `answer` (circled in red), the box drawn for `K=1` is the red box in `mat`. The sum of this red box is just `cumulativeSum[1][1]`.\\n2. For `row=0, col=2` of `answer` (circled in yellow), the box drawn for `K=1` is the yellow box in `mat`. The sum of this yellow box is `cumulativeSum[1][2] - cumulativeSum[1][0]` because we want to ignore the sum of `mat[0][0] + mat[1][0]`.\\n3. For `row=2, col=2` of `answer` (circled in purple), the box drawn for `K=1` is the purple box in `mat`. The sum of this purple box is `cumulativeSum[2][2] - cumulativeSum[0][2] - cumulativeSum[2][0] + cumulativeSum[0][0]`.\\n```\\ndef matrixBlockSum(mat: List[List[int]], K: int) -> List[List[int]]:\\n\\tm, n = len(mat), len(mat[0])\\n        \\n    cumulativeSum = getCumulativeSum(mat, m, n)\\n        \\n    answer = [[None for _ in range(n)] for _ in range(m)]\\n        \\n    for r in range(m):\\n\\t\\tfor c in range(n):\\n\\t\\t\\t# Tuples of (row, col) that are JUST outside of the box drawn by:\\n            # (i - K <= r <= i + k) & (j - k <= c <= j + k)\\n\\t\\t\\t# Be careful to not go out of the range of mat by using min().\\n            bottomLeft = (min(r + K, m - 1), c - K - 1)\\n            topLeft = (r - K - 1, c - K - 1)\\n            topRight = (r - K - 1, min(c + K, n - 1))\\n                                \\n            # Adjust these points if they go outside of the matrix, if they do, set to None.\\n            bottomLeft = None if any(x < 0 for x in bottomLeft) else bottomLeft\\n            topLeft = None if any(x < 0 for x in topLeft) else topLeft\\n            topRight = None if any(x < 0 for x in topRight) else topRight\\n                \\n            # Find the bottom-right-most point drawn by the box (mentioned above).\\n            # It must be capped to the bottom-right-most point of the matrix in case it overshoots.\\n            toAddRow, toAddCol = (min(r + K, m - 1), min(c + K, n - 1))\\n            toAdd = cumulativeSum[toAddRow][toAddCol]\\n                \\n            answerValue = toAdd\\n            if bottomLeft is not None:\\n\\t\\t\\t\\tanswerValue -= cumulativeSum[bottomLeft[0]][bottomLeft[1]]\\n\\t\\t\\tif topRight is not None:\\n\\t\\t\\t\\tanswerValue -= cumulativeSum[topRight[0]][topRight[1]]\\n\\t\\t\\tif all(point is not None for point in [bottomLeft, topRight, topLeft]):\\n\\t\\t\\t\\tanswerValue += cumulativeSum[topLeft[0]][topLeft[1]]\\n                \\n\\t\\t\\tanswer[r][c] = answerValue\\n        \\n\\treturn answer\\n```",
                "solutionTags": [],
                "code": "```\\nK=1\\nmat = [\\n\\t[1, 2, 3],\\n\\t[4, 5, 6],\\n\\t[7, 8, 9]\\n]\\ncumulativeSum = [\\n\\t[1 , 3 , 6 ],\\n\\t[5 , 12, 21],\\n\\t[12, 27, 45]\\n]\\nanswer = [\\n\\t[12, 21, 16],\\n\\t[27, 45, 33],\\n\\t[24, 39, 28]\\n]\\n```\n```\\ndef getCumulativeSum(mat: List[List[int]], m: int, n: int) -> List[List[int]]:\\n\\tcumulativeSum = [[None for _ in range(n)] for _ in range(m)]\\n    cumulativeSum[0][0] = mat[0][0] # Base case.\\n        \\n    # For the 0th row and 0th column, you just add what\\'s left or above the current point in the cumulativeSum matrix.\\n    for c in range(1, n):\\n\\t\\tcumulativeSum[0][c] = cumulativeSum[0][c - 1] + mat[0][c]\\n\\tfor r in range(1, m):\\n\\t\\tcumulativeSum[r][0] = cumulativeSum[r - 1][0] + mat[r][0]\\n        \\n\\t# For other rows and columns, add what\\'s above, what\\'s to the left, and subtract what\\'s above & to the left respectively.\\n    for r in range(1, m):\\n\\t\\tfor c in range(1, n):\\n\\t\\t\\tcumulativeSum[r][c] = mat[r][c] + cumulativeSum[r-1][c] + cumulativeSum[r][c-1] - cumulativeSum[r-1][c-1]\\n                \\n\\treturn cumulativeSum\\n```\n```\\ndef matrixBlockSum(mat: List[List[int]], K: int) -> List[List[int]]:\\n\\tm, n = len(mat), len(mat[0])\\n        \\n    cumulativeSum = getCumulativeSum(mat, m, n)\\n        \\n    answer = [[None for _ in range(n)] for _ in range(m)]\\n        \\n    for r in range(m):\\n\\t\\tfor c in range(n):\\n\\t\\t\\t# Tuples of (row, col) that are JUST outside of the box drawn by:\\n            # (i - K <= r <= i + k) & (j - k <= c <= j + k)\\n\\t\\t\\t# Be careful to not go out of the range of mat by using min().\\n            bottomLeft = (min(r + K, m - 1), c - K - 1)\\n            topLeft = (r - K - 1, c - K - 1)\\n            topRight = (r - K - 1, min(c + K, n - 1))\\n                                \\n            # Adjust these points if they go outside of the matrix, if they do, set to None.\\n            bottomLeft = None if any(x < 0 for x in bottomLeft) else bottomLeft\\n            topLeft = None if any(x < 0 for x in topLeft) else topLeft\\n            topRight = None if any(x < 0 for x in topRight) else topRight\\n                \\n            # Find the bottom-right-most point drawn by the box (mentioned above).\\n            # It must be capped to the bottom-right-most point of the matrix in case it overshoots.\\n            toAddRow, toAddCol = (min(r + K, m - 1), min(c + K, n - 1))\\n            toAdd = cumulativeSum[toAddRow][toAddCol]\\n                \\n            answerValue = toAdd\\n            if bottomLeft is not None:\\n\\t\\t\\t\\tanswerValue -= cumulativeSum[bottomLeft[0]][bottomLeft[1]]\\n\\t\\t\\tif topRight is not None:\\n\\t\\t\\t\\tanswerValue -= cumulativeSum[topRight[0]][topRight[1]]\\n\\t\\t\\tif all(point is not None for point in [bottomLeft, topRight, topLeft]):\\n\\t\\t\\t\\tanswerValue += cumulativeSum[topLeft[0]][topLeft[1]]\\n                \\n\\t\\t\\tanswer[r][c] = answerValue\\n        \\n\\treturn answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 631096,
                "title": "python-easy-to-understand-solution",
                "content": "A standard template you can follow when solving 2D prefix/range problems. \\n```py\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        h, w = len(mat), len(mat[0])\\n        \\n        data = [[0 for i in range(w)] for j in range(h)]\\n        \\n        # precompute the matrix sums\\n        for i in range(h):\\n            for j in range(w):\\n                res = 0\\n                if(i > 0): res += data[i-1][j]\\n                if(j > 0): res += data[i][j-1]\\n                if(i > 0 and j > 0): res -= data[i-1][j-1]\\n                \\n                res += mat[i][j]\\n                data[i][j] = res\\n        \\n        for i in range(h):\\n            for j in range(w):\\n                x1, y1, x2, y2 = max(i-K,0), max(j-K,0), min(i+K,h-1), min(j+K,w-1)\\n                \\n                # find the sum of elements in between x1, y1 and x2,y2 (inclusive)\\n                res = data[x2][y2]\\n                if(x1 > 0): res -= data[x1-1][y2]\\n                if(y1 > 0): res -= data[x2][y1-1]\\n                if(x1 > 0 and y1 > 0): res += data[x1-1][y1-1]\\n                \\n                mat[i][j] = res\\n        \\n        return mat\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        h, w = len(mat), len(mat[0])\\n        \\n        data = [[0 for i in range(w)] for j in range(h)]\\n        \\n        # precompute the matrix sums\\n        for i in range(h):\\n            for j in range(w):\\n                res = 0\\n                if(i > 0): res += data[i-1][j]\\n                if(j > 0): res += data[i][j-1]\\n                if(i > 0 and j > 0): res -= data[i-1][j-1]\\n                \\n                res += mat[i][j]\\n                data[i][j] = res\\n        \\n        for i in range(h):\\n            for j in range(w):\\n                x1, y1, x2, y2 = max(i-K,0), max(j-K,0), min(i+K,h-1), min(j+K,w-1)\\n                \\n                # find the sum of elements in between x1, y1 and x2,y2 (inclusive)\\n                res = data[x2][y2]\\n                if(x1 > 0): res -= data[x1-1][y2]\\n                if(y1 > 0): res -= data[x2][y1-1]\\n                if(x1 > 0 and y1 > 0): res += data[x1-1][y1-1]\\n                \\n                mat[i][j] = res\\n        \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478050,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int[][] temp = new int[n + 1][m + 1];\\n        for (int i = 0; i < n; i++) {\\n            temp[i + 1][1] = temp[i][1] + mat[i][0];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            temp[1][i + 1] = temp[1][i] + mat[0][i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                temp[i + 1][j + 1] = temp[i][j + 1] + temp[i + 1][j] - temp[i][j] + mat[i][j];\\n            }\\n        }\\n        int[][] res = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int x1 = i - K >= 0 ? i - K : 0;\\n                int y1 = j - K >= 0 ? j - K : 0;\\n                int x2 = i + K + 1<= n ? i + K + 1 : n;\\n                int y2 = j + K + 1<= m ? j + K + 1 : m;\\n                res[i][j] = temp[x2][y2] - temp[x2][y1] - temp[x1][y2] + temp[x1][y1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int[][] temp = new int[n + 1][m + 1];\\n        for (int i = 0; i < n; i++) {\\n            temp[i + 1][1] = temp[i][1] + mat[i][0];\\n        }\\n        for (int i = 0; i < m; i++) {\\n            temp[1][i + 1] = temp[1][i] + mat[0][i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                temp[i + 1][j + 1] = temp[i][j + 1] + temp[i + 1][j] - temp[i][j] + mat[i][j];\\n            }\\n        }\\n        int[][] res = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int x1 = i - K >= 0 ? i - K : 0;\\n                int y1 = j - K >= 0 ? j - K : 0;\\n                int x2 = i + K + 1<= n ? i + K + 1 : n;\\n                int y2 = j + K + 1<= m ? j + K + 1 : m;\\n                res[i][j] = temp[x2][y2] - temp[x2][y1] - temp[x1][y2] + temp[x1][y1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477029,
                "title": "dp-java",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int [][]dp = new int[m+1][n+1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j+1] = mat[i][j] + dp[i][j+1] + dp[i+1][j] - dp[i][j];\\n            }\\n        }\\n        int [][]ans = new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int l = Math.max(0, j - K);\\n                int r = Math.min(n-1, j + K)+1;\\n                int u = Math.max(0, i - K);\\n                int d = Math.min(m-1, i + K)+1;\\n                ans[i][j] = dp[d][r] - dp[d][l] - dp[u][r] + dp[u][l];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int [][]dp = new int[m+1][n+1];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                dp[i+1][j+1] = mat[i][j] + dp[i][j+1] + dp[i+1][j] - dp[i][j];\\n            }\\n        }\\n        int [][]ans = new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int l = Math.max(0, j - K);\\n                int r = Math.min(n-1, j + K)+1;\\n                int u = Math.max(0, i - K);\\n                int d = Math.min(m-1, i + K)+1;\\n                ans[i][j] = dp[d][r] - dp[d][l] - dp[u][r] + dp[u][l];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241051,
                "title": "c-solution-with-comments-and-diagram",
                "content": "first we\\'ll create prefix sum matrix (in this case named \"pre\" ).\\n.\\n.\\n.\\n.\\nnow to find sum of shaded region\\n![image](https://assets.leetcode.com/users/images/110e8f9f-e45d-486b-800c-53c4ab80b208_1677607180.5857232.jpeg)\\n.\\n.\\n.\\n.\\nwe\\'ll subtract section A and section B to sum till now and add section C as it is subtracted twice\\n![image](https://assets.leetcode.com/users/images/293c82e7-0d54-44b4-a22c-dc4ba7a7ee94_1677607258.4063761.jpeg)\\nie, in this case, sum of shaded region = 45- 12- 6+ 1\\n.\\n.\\n.\\n.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        // prefix sum\\n        int m= mat.size(), n= mat[0].size(), temp;\\n        vector<vector<int>> pre(m+1, vector<int> (n+1, 0));\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                pre[i+1][j+1]= mat[i][j]+pre[i][j+1]+pre[i+1][j]-pre[i][j];\\n            \\n        \\n        // creating ans matrix using prefix sum matrix(pre)\\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int iup= max(0,i-k), idown= min(m-1,i+k), jleft= max(0,j-k), jright= min(n-1, j+k);\\n                temp= pre[idown+1][jright+1]  -pre[idown+1][jleft]  -pre[iup][jright+1]  +pre[iup][jleft];\\n                ans[i][j]= temp;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        // prefix sum\\n        int m= mat.size(), n= mat[0].size(), temp;\\n        vector<vector<int>> pre(m+1, vector<int> (n+1, 0));\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                pre[i+1][j+1]= mat[i][j]+pre[i][j+1]+pre[i+1][j]-pre[i][j];\\n            \\n        \\n        // creating ans matrix using prefix sum matrix(pre)\\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int iup= max(0,i-k), idown= min(m-1,i+k), jleft= max(0,j-k), jright= min(n-1, j+k);\\n                temp= pre[idown+1][jright+1]  -pre[idown+1][jleft]  -pre[iup][jright+1]  +pre[iup][jleft];\\n                ans[i][j]= temp;\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160155,
                "title": "java-solution-1-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            for(int i = 1; i < m; i++) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res[i][j] = getSum(mat, i, j, k);\\n            }\\n        }\\n\\n        return res;\\n    }\\n    private int getSum(int[][] mat, int i, int j, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int endRow = Math.min(m - 1, i + k);\\n        int endCol = Math.min(n - 1, j + k);\\n\\n        int sum = mat[endRow][endCol];\\n        int n1 = (j - k - 1 >= 0) ? mat[endRow][j - k - 1] : 0;\\n        int n2 = (i - k - 1 >= 0) ? mat[i - k - 1][endCol] : 0;\\n        int n3 = (j - k - 1 >= 0 && i - k - 1 >= 0) ? mat[i - k - 1][j - k - 1] : 0;\\n\\n        return sum - n1 - n2 + n3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            for(int i = 1; i < m; i++) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                res[i][j] = getSum(mat, i, j, k);\\n            }\\n        }\\n\\n        return res;\\n    }\\n    private int getSum(int[][] mat, int i, int j, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int endRow = Math.min(m - 1, i + k);\\n        int endCol = Math.min(n - 1, j + k);\\n\\n        int sum = mat[endRow][endCol];\\n        int n1 = (j - k - 1 >= 0) ? mat[endRow][j - k - 1] : 0;\\n        int n2 = (i - k - 1 >= 0) ? mat[i - k - 1][endCol] : 0;\\n        int n3 = (j - k - 1 >= 0 && i - k - 1 >= 0) ? mat[i - k - 1][j - k - 1] : 0;\\n\\n        return sum - n1 - n2 + n3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144858,
                "title": "simple-traverse",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> res(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++) {\\n                int sum = 0;\\n                for (int r = max(0, i - k); r < min(n, i + k + 1); r++)\\n                    for (int c = max(0, j - k); c < min(m, j + k + 1); c++) \\n                        sum += mat[r][c];\\n                res[i][j] = sum;\\n            }\\n        return res;         \\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> res(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++) {\\n                int sum = 0;\\n                for (int r = max(0, i - k); r < min(n, i + k + 1); r++)\\n                    for (int c = max(0, j - k); c < min(m, j + k + 1); c++) \\n                        sum += mat[r][c];\\n                res[i][j] = sum;\\n            }\\n        return res;         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702062,
                "title": "c-clean-code-with-comments-and-explaination",
                "content": "1. declare a 2d vector t. t[i][j] means total sum for the rectangle from (0,0) to (i, j). \\n2.  loop through matrix, find max values of x2, x1, y2, y1 acc to k. readjust the value if they fall out of matrix range.\\n3.   the k matrix sum would be  rectangle (x1,y1) to (x2, y2) which can be calculated using t matrix . \\n \\n\\n ```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        \\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<vector<int>> t( m, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if( i == 0 && j == 0) t[i][j] = mat[i][j];\\n                else if( i == 0 ) t[i][j] = t[i][j-1] + mat[i][j];\\n                else if( j == 0 ) t[i][j] = t[i-1][j] + mat[i][j];\\n                else t[i][j] = mat[i][j] + t[i-1][j] + t[i][j-1] - t[i-1][j-1];\\n            }\\n        }\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                \\n                int x1 = max(0, i-k);\\n                int y1 = max(0, j-k);\\n                \\n                int x2 = min(i + k, m-1);\\n                int y2 = min(j + k, n-1);\\n                \\n                res[i][j] = t[x2][y2] - ( x1 > 0 ? t[x1-1][y2] : 0) - ( y1 > 0 ? t[x2][y1-1] : 0 ) + ( (x1 > 0 && y1 > 0) ? t[x1-1][y1-1] : 0 );  \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        \\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<vector<int>> t( m, vector<int> (n, 0));\\n        \\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if( i == 0 && j == 0) t[i][j] = mat[i][j];\\n                else if( i == 0 ) t[i][j] = t[i][j-1] + mat[i][j];\\n                else if( j == 0 ) t[i][j] = t[i-1][j] + mat[i][j];\\n                else t[i][j] = mat[i][j] + t[i-1][j] + t[i][j-1] - t[i-1][j-1];\\n            }\\n        }\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                \\n                int x1 = max(0, i-k);\\n                int y1 = max(0, j-k);\\n                \\n                int x2 = min(i + k, m-1);\\n                int y2 = min(j + k, n-1);\\n                \\n                res[i][j] = t[x2][y2] - ( x1 > 0 ? t[x1-1][y2] : 0) - ( y1 > 0 ? t[x2][y1-1] : 0 ) + ( (x1 > 0 && y1 > 0) ? t[x1-1][y1-1] : 0 );  \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645671,
                "title": "java-solution-with-hard-code-loop-array",
                "content": "\\n# Approach\\nLoop Array \\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n     \\n        int[][] res = new int[mat.length][mat[0].length];\\n        \\n        for (int i = 0; i < mat.length; i++)\\n            for (int j = 0; j < mat[0].length; j++)\\n                res[i][j]=sumMat(k,mat,i,j);\\n\\n        return res;\\n    }\\n\\n    int sumMat(int k, int[][] mat, int i, int j) {\\n        int sum = 0;\\n\\n        for (int a = i - k; a <= i + k; a++)\\n            if (a >= 0 && mat.length > a)\\n                for (int b = j - k; b <= j + k; b++)\\n                    if (b >= 0 && mat[0].length > b)\\n                        sum+=mat[a][b];\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n     \\n        int[][] res = new int[mat.length][mat[0].length];\\n        \\n        for (int i = 0; i < mat.length; i++)\\n            for (int j = 0; j < mat[0].length; j++)\\n                res[i][j]=sumMat(k,mat,i,j);\\n\\n        return res;\\n    }\\n\\n    int sumMat(int k, int[][] mat, int i, int j) {\\n        int sum = 0;\\n\\n        for (int a = i - k; a <= i + k; a++)\\n            if (a >= 0 && mat.length > a)\\n                for (int b = j - k; b <= j + k; b++)\\n                    if (b >= 0 && mat[0].length > b)\\n                        sum+=mat[a][b];\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557036,
                "title": "time-and-space-90-and-80-beats-constant-space-time-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int i,j,m = mat.size(),n = mat[0].size();\\n        for(i = 0; i < m ;i++){\\n            for(j = 0; j < n; j++){\\n                if(i==0&&j==0)continue;\\n                else if(i==0){\\n                    mat[i][j] += mat[i][j-1];\\n                }else if(j==0){\\n                    mat[i][j] += mat[i-1][j];\\n                }else{\\n                    mat[i][j] += mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1];\\n                }\\n            }\\n        }\\n        int a,b,c,d;\\n        vector<vector<int>> ans(m,vector<int> (n));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                a = max(i-k,0);\\n                b = max(0,j-k);\\n                c = min(i+k,m-1);\\n                d = min(j+k,n-1);\\n                if(a==0&&b==0){\\n                    ans[i][j] = mat[c][d];\\n                }else if(a==0){\\n                    ans[i][j] = mat[c][d]-mat[c][b-1];\\n                }else if(b==0){\\n                    ans[i][j] = mat[c][d]-mat[a-1][d];\\n                }else{\\n                    ans[i][j] = mat[c][d]+mat[a-1][b-1]-mat[a-1][d]-mat[c][b-1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int i,j,m = mat.size(),n = mat[0].size();\\n        for(i = 0; i < m ;i++){\\n            for(j = 0; j < n; j++){\\n                if(i==0&&j==0)continue;\\n                else if(i==0){\\n                    mat[i][j] += mat[i][j-1];\\n                }else if(j==0){\\n                    mat[i][j] += mat[i-1][j];\\n                }else{\\n                    mat[i][j] += mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1];\\n                }\\n            }\\n        }\\n        int a,b,c,d;\\n        vector<vector<int>> ans(m,vector<int> (n));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                a = max(i-k,0);\\n                b = max(0,j-k);\\n                c = min(i+k,m-1);\\n                d = min(j+k,n-1);\\n                if(a==0&&b==0){\\n                    ans[i][j] = mat[c][d];\\n                }else if(a==0){\\n                    ans[i][j] = mat[c][d]-mat[c][b-1];\\n                }else if(b==0){\\n                    ans[i][j] = mat[c][d]-mat[a-1][d];\\n                }else{\\n                    ans[i][j] = mat[c][d]+mat[a-1][b-1]-mat[a-1][d]-mat[c][b-1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547723,
                "title": "python-solution-do-304-first",
                "content": "Then you can copy and paste!\\n```\\nclass Solution:\\n    # First go back to Leetcode 304. Range Sum Query 2D - Immutable\\n    # Prepare the prefix sum matrix first\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        prefix_sum = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                prefix_sum[i][j] = prefix_sum[i-1][j] + prefix_sum[i][j-1] + mat[i-1][j-1] - prefix_sum[i-1][j-1]\\n        \\n        result = [[0 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                row1, col1 = max(0, i-k), max(0,j-k)\\n                row2, col2 = min(m-1, i+k), min(n-1,j+k)\\n                result[i][j] = prefix_sum[row2+1][col2+1] - prefix_sum[row1][col2+1] - prefix_sum[row2+1][col1] + prefix_sum[row1][col1]\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # First go back to Leetcode 304. Range Sum Query 2D - Immutable\\n    # Prepare the prefix sum matrix first\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        prefix_sum = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                prefix_sum[i][j] = prefix_sum[i-1][j] + prefix_sum[i][j-1] + mat[i-1][j-1] - prefix_sum[i-1][j-1]\\n        \\n        result = [[0 for i in range(n)] for j in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                row1, col1 = max(0, i-k), max(0,j-k)\\n                row2, col2 = min(m-1, i+k), min(n-1,j+k)\\n                result[i][j] = prefix_sum[row2+1][col2+1] - prefix_sum[row1][col2+1] - prefix_sum[row2+1][col1] + prefix_sum[row1][col1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372339,
                "title": "python-comulative-sum-array",
                "content": "Comulative sum array is like a prefix sum array (1D), but for 2D arrays.\\n\\nThis is the same as [304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/). \\n\\nLet\\'s quickly look at an example:\\nInput:\\n```\\n1  2  3\\n4  5  6\\n7  8  9\\n```\\n\\nYou create comulative sum array and add 0 paddings, to ease edge case calculations:\\n```\\n0  0  0  0\\n0  1  3  6\\n0  5 12 21\\n0 12 27 45\\n```\\n\\nNow imagine that you need to get in O(1) sum of any rectangular part of the original array:\\n\\nYou calc rectange sum for **each** matrix[r][c] element:\\ne.g. you are at [3][5], k = 2, so you calc sum of rectangle at x1y1 [3-2][5-2] to x2y2[3+2][5+2] and store it in res[3][5]\\n\\n![image](https://assets.leetcode.com/users/images/f20b6ebf-b645-4012-ab4d-017582252751_1659501890.2643135.png)\\n*The picture is not mine, It just depicts what I need:*\\n\\nThis\\n```\\n0  0  0  0\\n0\\n0\\n0\\n```\\npadding is used to avoid pesky out-of-boundary-cases.\\n\\nBack to our example:\\nYou\\'d like to calc quickly sum of \\n```\\n5 6\\n8 9\\n```\\n\\nAccording to the picture above you do the following math:\\n`45 - 12 - 6 + 1 = 28`, and according to `5 + 6 + 8 + 9 = 28`.\\n\\n**That\\'s it.**\\n\\n**Like and subscribe (c) ???**\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, matrix: List[List[int]], k: int) -> List[List[int]]:\\n        ROWS, COLS = len(matrix), len(matrix[0])\\n        \\n        prefix_sums = [[0] * (COLS + 1) for _ in range(ROWS + 1)]\\n        \\n        for r in range(1, ROWS + 1):\\n            for c in range(1, COLS + 1):\\n                prefix_sums[r][c] = prefix_sums[r - 1][c] + prefix_sums[r][c - 1] + \\\\\\n                    matrix[r - 1][c - 1] - prefix_sums[r - 1][c - 1]\\n\\n        res = [[0] * COLS for _ in range(ROWS)]\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                res[r][c] = prefix_sums[min(r + k + 1, ROWS)][min(c + k + 1, COLS)] - \\\\\\n                    prefix_sums[max(r - k, 0)][min(c + k + 1, COLS)] - \\\\\\n                    prefix_sums[min(r + k + 1, ROWS)][max(c - k, 0)] + \\\\\\n                    prefix_sums[max(r - k, 0)][max(c - k, 0)]\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n1  2  3\\n4  5  6\\n7  8  9\\n```\n```\\n0  0  0  0\\n0  1  3  6\\n0  5 12 21\\n0 12 27 45\\n```\n```\\n0  0  0  0\\n0\\n0\\n0\\n```\n```\\n5 6\\n8 9\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, matrix: List[List[int]], k: int) -> List[List[int]]:\\n        ROWS, COLS = len(matrix), len(matrix[0])\\n        \\n        prefix_sums = [[0] * (COLS + 1) for _ in range(ROWS + 1)]\\n        \\n        for r in range(1, ROWS + 1):\\n            for c in range(1, COLS + 1):\\n                prefix_sums[r][c] = prefix_sums[r - 1][c] + prefix_sums[r][c - 1] + \\\\\\n                    matrix[r - 1][c - 1] - prefix_sums[r - 1][c - 1]\\n\\n        res = [[0] * COLS for _ in range(ROWS)]\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                res[r][c] = prefix_sums[min(r + k + 1, ROWS)][min(c + k + 1, COLS)] - \\\\\\n                    prefix_sums[max(r - k, 0)][min(c + k + 1, COLS)] - \\\\\\n                    prefix_sums[min(r + k + 1, ROWS)][max(c - k, 0)] + \\\\\\n                    prefix_sums[max(r - k, 0)][max(c - k, 0)]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936092,
                "title": "c-using-prefix-sum-and-dp-with-time-and-space-o-rxc",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) mat[i][j] += mat[i][j-1];\\n                else if(j==0) mat[i][j] += mat[i-1][j];\\n                else mat[i][j] += (mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1]);\\n            }\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int mir = max(i-k,0);\\n                int mic = max(j-k,0);\\n                int mar = min(i+k,n-1);\\n                int mac = min(j+k,m-1);\\n                \\n                if(mir==0 && mic==0) ans[i][j] = mat[mar][mac];\\n                else if(mir==0) ans[i][j] = mat[mar][mac] - mat[mar][mic-1];\\n                else if(mic==0) ans[i][j] = mat[mar][mac] - mat[mir-1][mac];\\n                else ans[i][j] = mat[mar][mac] - mat[mar][mic-1] - mat[mir-1][mac] + mat[mir-1][mic-1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0) continue;\\n                else if(i==0) mat[i][j] += mat[i][j-1];\\n                else if(j==0) mat[i][j] += mat[i-1][j];\\n                else mat[i][j] += (mat[i-1][j]+mat[i][j-1]-mat[i-1][j-1]);\\n            }\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int mir = max(i-k,0);\\n                int mic = max(j-k,0);\\n                int mar = min(i+k,n-1);\\n                int mac = min(j+k,m-1);\\n                \\n                if(mir==0 && mic==0) ans[i][j] = mat[mar][mac];\\n                else if(mir==0) ans[i][j] = mat[mar][mac] - mat[mar][mic-1];\\n                else if(mic==0) ans[i][j] = mat[mar][mac] - mat[mir-1][mac];\\n                else ans[i][j] = mat[mar][mac] - mat[mar][mic-1] - mat[mir-1][mac] + mat[mir-1][mic-1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704940,
                "title": "javascript-beats-84-in-memory-brute-force",
                "content": "```\\n/**\\n * @param {number[][]} mat\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar matrixBlockSum = function(mat, k) {\\n    var outputMatrix=[];\\n    for(var i=0; i<mat.length; i++)\\n        {\\n            var tempArr=[];\\n            for(var j=0; j<mat[i].length; j++)\\n                    tempArr.push((calcSum(mat, k, i, j)));\\n                \\n            outputMatrix.push(tempArr);\\n        }\\n    return outputMatrix;\\n};\\n\\nfunction calcSum(mat, k, i, j)\\n{\\n    var r= ((i-k)>0)?i-k:0;\\n    var r1=((i+k)<mat.length)?i+k:mat.length-1;\\n    var c1=((j+k)<mat[0].length)?j+k:mat[0].length-1;\\n    var sum=0;\\n    while(r<=r1)\\n        {\\n            var c= ((j-k)>0)?j-k:0;\\n            while(c<=c1)\\n                    sum+=mat[r][c++];      \\n            r++;\\n        }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar matrixBlockSum = function(mat, k) {\\n    var outputMatrix=[];\\n    for(var i=0; i<mat.length; i++)\\n        {\\n            var tempArr=[];\\n            for(var j=0; j<mat[i].length; j++)\\n                    tempArr.push((calcSum(mat, k, i, j)));\\n                \\n            outputMatrix.push(tempArr);\\n        }\\n    return outputMatrix;\\n};\\n\\nfunction calcSum(mat, k, i, j)\\n{\\n    var r= ((i-k)>0)?i-k:0;\\n    var r1=((i+k)<mat.length)?i+k:mat.length-1;\\n    var c1=((j+k)<mat[0].length)?j+k:mat[0].length-1;\\n    var sum=0;\\n    while(r<=r1)\\n        {\\n            var c= ((j-k)>0)?j-k:0;\\n            while(c<=c1)\\n                    sum+=mat[r][c++];      \\n            r++;\\n        }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1622887,
                "title": "c-dp-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 1; j < n; ++j) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        for(int j = 0; j < n; ++j) {\\n            for(int i = 1; i < m; ++i) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int l = j - k, r = j + k, t = i - k, b = i + k;\\n                int prefixTop = t <= 0 ? 0 : mat[t - 1][min(r, n - 1)];\\n                int prefixLeft = l <= 0 ? 0 : mat[min(b, m - 1)][l - 1];\\n                int prefixTopLeft = t > 0 && l > 0 ? mat[t - 1][l - 1] : 0;\\n                \\n                ans[i][j] = mat[min(b, m - 1)][min(r, n - 1)] - prefixTop - prefixLeft + prefixTopLeft; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> ans(m, vector<int> (n));\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 1; j < n; ++j) {\\n                mat[i][j] += mat[i][j - 1];\\n            }\\n        }\\n        for(int j = 0; j < n; ++j) {\\n            for(int i = 1; i < m; ++i) {\\n                mat[i][j] += mat[i - 1][j];\\n            }\\n        }\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int l = j - k, r = j + k, t = i - k, b = i + k;\\n                int prefixTop = t <= 0 ? 0 : mat[t - 1][min(r, n - 1)];\\n                int prefixLeft = l <= 0 ? 0 : mat[min(b, m - 1)][l - 1];\\n                int prefixTopLeft = t > 0 && l > 0 ? mat[t - 1][l - 1] : 0;\\n                \\n                ans[i][j] = mat[min(b, m - 1)][min(r, n - 1)] - prefixTop - prefixLeft + prefixTopLeft; \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498515,
                "title": "python-dp-based-2-approaches-93-5",
                "content": "Both are DP approaches.\\n\\n**Approach 1**: Calculate sum for each index mat[index, index-k:index+k+1]. Peform this using the  value of previous  sum  already calculated and also taking care of the boundary conditions.\\n\\nTimewise: 58.6%\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        M, N = len(mat), len(mat[0])\\n        dp = [[0 for _ in range(N)] for _ in range(M)]\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                MIN = max(0, i-k)\\n                MAX = min(i+k, M-1)\\n                if i == 0:\\n                    for k in range(MIN, MAX+1):\\n                        dp[i][j] += mat[k][j]\\n                else:\\n                    SUB = 0 if MIN == 0 else mat[MIN-1][j]\\n                    ADD = 0 if i+k >= M else mat[MAX][j]\\n                    dp[i][j] += dp[i-1][j] - SUB + ADD\\n        \\n\\t\\t\\n        res = [[0 for _ in range(N)] for _ in range(M)]\\n        for i in range(M):\\n            for j in range(N):\\n                MIN = max(0, j-k)\\n                MAX = min(j+k, N-1)\\n                if j == 0:\\n                    for k in range(MIN, MAX+1):\\n                        res[i][j] += dp[i][k]\\n                else:\\n                    SUB = 0 if MIN == 0 else dp[i][MIN-1]\\n                    ADD = 0 if j+k >= N else dp[i][MAX]\\n                    res[i][j] += res[i][j-1] - SUB + ADD\\n        \\n        return res\\n```\\n\\n\\n**Approach 2**: Using prefix sum. Calculate the prefix sum for all indexes and then calculate the result by subtracting the portion that is not in range of (i-k,i+k),(j-k,j+k).\\n\\nTimwise this  is superior: 93.5%\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        M, N = len(mat), len(mat[0])\\n        # For prefix  sum\\n        dp = [[0 for _ in range(N)] for _ in range(M)]\\n        \\n        dp[0][0] = mat[0][0]\\n        # row\\n        for i in range(1, M):\\n            dp[i][0] = dp[i-1][0] + mat[i][0]\\n            \\n        # column\\n        for j in range(1, N):\\n            dp[0][j] = dp[0][j-1] + mat[0][j]\\n        \\n        # remaining\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                dp[i][j] = mat[i][j] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\\n        \\n        \\n        res = [[0 for _ in range(N)] for _ in range(M)]\\n        for i in range(M):\\n            for j in range(N):\\n                MIN_i, MIN_j = max(0, i-k), max(0, j-k)\\n                MAX_i, MAX_j = min(i+k, M-1), min(j+k, N-1)\\n                if MIN_i > 0 and MIN_j > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MIN_i-1][MAX_j]-dp[MAX_i][MIN_j-1]+dp[MIN_i-1][MIN_j-1]\\n                elif MIN_i > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MIN_i-1][MAX_j]\\n                elif MIN_j > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MAX_i][MIN_j-1]\\n                else:\\n                    res[i][j] = dp[MAX_i][MAX_j]\\n        \\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        M, N = len(mat), len(mat[0])\\n        dp = [[0 for _ in range(N)] for _ in range(M)]\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                MIN = max(0, i-k)\\n                MAX = min(i+k, M-1)\\n                if i == 0:\\n                    for k in range(MIN, MAX+1):\\n                        dp[i][j] += mat[k][j]\\n                else:\\n                    SUB = 0 if MIN == 0 else mat[MIN-1][j]\\n                    ADD = 0 if i+k >= M else mat[MAX][j]\\n                    dp[i][j] += dp[i-1][j] - SUB + ADD\\n        \\n\\t\\t\\n        res = [[0 for _ in range(N)] for _ in range(M)]\\n        for i in range(M):\\n            for j in range(N):\\n                MIN = max(0, j-k)\\n                MAX = min(j+k, N-1)\\n                if j == 0:\\n                    for k in range(MIN, MAX+1):\\n                        res[i][j] += dp[i][k]\\n                else:\\n                    SUB = 0 if MIN == 0 else dp[i][MIN-1]\\n                    ADD = 0 if j+k >= N else dp[i][MAX]\\n                    res[i][j] += res[i][j-1] - SUB + ADD\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        M, N = len(mat), len(mat[0])\\n        # For prefix  sum\\n        dp = [[0 for _ in range(N)] for _ in range(M)]\\n        \\n        dp[0][0] = mat[0][0]\\n        # row\\n        for i in range(1, M):\\n            dp[i][0] = dp[i-1][0] + mat[i][0]\\n            \\n        # column\\n        for j in range(1, N):\\n            dp[0][j] = dp[0][j-1] + mat[0][j]\\n        \\n        # remaining\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                dp[i][j] = mat[i][j] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\\n        \\n        \\n        res = [[0 for _ in range(N)] for _ in range(M)]\\n        for i in range(M):\\n            for j in range(N):\\n                MIN_i, MIN_j = max(0, i-k), max(0, j-k)\\n                MAX_i, MAX_j = min(i+k, M-1), min(j+k, N-1)\\n                if MIN_i > 0 and MIN_j > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MIN_i-1][MAX_j]-dp[MAX_i][MIN_j-1]+dp[MIN_i-1][MIN_j-1]\\n                elif MIN_i > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MIN_i-1][MAX_j]\\n                elif MIN_j > 0:\\n                    res[i][j] = dp[MAX_i][MAX_j]-dp[MAX_i][MIN_j-1]\\n                else:\\n                    res[i][j] = dp[MAX_i][MAX_j]\\n        \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481232,
                "title": "faster-than-100-c-submissions-easy-to-understand-prefix-sum",
                "content": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        /*\\n        mat[3][3] = {\\n            {1,2,3},\\n            {4,5,6},\\n            {7,8,9}\\n        };\\n        */\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        /*\\n\\t\\tPrefix sum on rows\\n        mat[3][3] = {\\n            {1,3,6},\\n            {4,9,15},\\n            {7,15,24}\\n        };\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n        /*\\n\\t\\tPrefix sum on cols\\n        mat[3][3] = {\\n            {1,3,6},\\n            {5,12,21},\\n            {12,27,45}\\n        };\\n        */\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++){\\n            vector<int> ans_i(n);\\n            int first_row = i-k,last_row = i+k;\\n            for(int j=0;j<n;j++){ \\n                int first_col = j-k, last_col = j+k;\\n                last_row = (last_row>m-1)?m-1:last_row;\\n                last_col = (last_col>n-1)?n-1:last_col;\\n                ans_i[j] = mat[last_row][last_col];\\n                if(first_row-1 >= 0 && first_col-1 >=0){ ans_i[j] += mat[first_row-1][first_col-1]; }\\n                if(first_row-1 >=0){ ans_i[j] -= mat[first_row-1][last_col]; }\\n                if(first_col-1 >=0){ ans_i[j] -= mat[last_row][first_col-1]; }\\n            }\\n            ans.push_back(ans_i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        /*\\n        mat[3][3] = {\\n            {1,2,3},\\n            {4,5,6},\\n            {7,8,9}\\n        };\\n        */\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        /*\\n\\t\\tPrefix sum on rows\\n        mat[3][3] = {\\n            {1,3,6},\\n            {4,9,15},\\n            {7,15,24}\\n        };\\n        */\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n        /*\\n\\t\\tPrefix sum on cols\\n        mat[3][3] = {\\n            {1,3,6},\\n            {5,12,21},\\n            {12,27,45}\\n        };\\n        */\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++){\\n            vector<int> ans_i(n);\\n            int first_row = i-k,last_row = i+k;\\n            for(int j=0;j<n;j++){ \\n                int first_col = j-k, last_col = j+k;\\n                last_row = (last_row>m-1)?m-1:last_row;\\n                last_col = (last_col>n-1)?n-1:last_col;\\n                ans_i[j] = mat[last_row][last_col];\\n                if(first_row-1 >= 0 && first_col-1 >=0){ ans_i[j] += mat[first_row-1][first_col-1]; }\\n                if(first_row-1 >=0){ ans_i[j] -= mat[first_row-1][last_col]; }\\n                if(first_col-1 >=0){ ans_i[j] -= mat[last_row][first_col-1]; }\\n            }\\n            ans.push_back(ans_i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478007,
                "title": "c-solution-time-o-nm",
                "content": "Time complexity: O(nm)\\nspace complexity: O(nm)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j];\\n                if(i>0)\\n                    dp[i][j]+=dp[i-1][j];\\n                if(j>0)dp[i][j]+=dp[i][j-1];\\n                if(i>0&&j>0)dp[i][j]-=dp[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                // cout<<dp[i][j]<<\" \";\\n                int lfx=max(0,j-k);\\n                int rtx=min(m-1,j+k);\\n                int lfy=max(0,i-k);\\n                int rty=min(n-1,i+k);\\n                mat[i][j]=dp[rty][rtx];\\n                if(lfy>0)mat[i][j]-=dp[lfy-1][rtx];\\n                if(lfx>0)mat[i][j]-=dp[rty][lfx-1];\\n                if(lfy>0&&lfx>0)mat[i][j]+=dp[lfy-1][lfx-1];\\n                \\n            }\\n            // cout<<endl;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j];\\n                if(i>0)\\n                    dp[i][j]+=dp[i-1][j];\\n                if(j>0)dp[i][j]+=dp[i][j-1];\\n                if(i>0&&j>0)dp[i][j]-=dp[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                // cout<<dp[i][j]<<\" \";\\n                int lfx=max(0,j-k);\\n                int rtx=min(m-1,j+k);\\n                int lfy=max(0,i-k);\\n                int rty=min(n-1,i+k);\\n                mat[i][j]=dp[rty][rtx];\\n                if(lfy>0)mat[i][j]-=dp[lfy-1][rtx];\\n                if(lfx>0)mat[i][j]-=dp[rty][lfx-1];\\n                if(lfy>0&&lfx>0)mat[i][j]+=dp[lfy-1][lfx-1];\\n                \\n            }\\n            // cout<<endl;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1437029,
                "title": "prefix-sum-java",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                sum+=mat[i][j];\\n                mat[i][j]=sum;\\n            }\\n        }\\n        int[][] ans=new int[mat.length][mat[0].length];\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                int rowStart=i-k<0?0:i-k;\\n                int rowEnd=i+k>=mat.length?mat.length-1:i+k;\\n                int colStart=j-k<0?0:j-k;\\n                int colEnd=j+k>=mat[0].length?mat[0].length-1:j+k;\\n                int sum=0;\\n                for(int v=rowStart;v<=rowEnd;v++){\\n                    sum+=mat[v][colEnd];\\n                    if(colStart!=0) sum-=mat[v][colStart-1];\\n                }\\n                ans[i][j]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                sum+=mat[i][j];\\n                mat[i][j]=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1378690,
                "title": "python-faster-than-99-84ms-time-o-n-m",
                "content": "```Python\\ndef solveRow(row, k):\\n    \\'\\'\\'\\n    O(n)\\n    Where n is the number of elements in the row\\n    \\'\\'\\'\\n    n = len(row)\\n    k = min(k, n)\\n    newRow = []\\n    right = k\\n    left = 0\\n    total = sum(row[0: right + 1])\\n    newRow.append(total)\\n    \\n    for index in range(1, n):\\n        if index > k:\\n            total -= row[left]\\n            left += 1\\n        \\n        if index < n - k:\\n            right += 1\\n            total += row[right]\\n        newRow.append(total)\\n        \\n    return newRow\\n    \\n\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        ans = [solveRow(row,k) for row in mat]   # O(n*m)\\n        ans = [solveRow(x, k) for x in zip(*ans)] # O(n*m)  Transpose\\n        return [list(x) for x in zip(*ans)] # Transpose again\\n\\n```\\n![image](https://assets.leetcode.com/users/images/aa8b440c-9cb1-49f6-9887-f0155c688ed8_1627911629.6227188.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\ndef solveRow(row, k):\\n    \\'\\'\\'\\n    O(n)\\n    Where n is the number of elements in the row\\n    \\'\\'\\'\\n    n = len(row)\\n    k = min(k, n)\\n    newRow = []\\n    right = k\\n    left = 0\\n    total = sum(row[0: right + 1])\\n    newRow.append(total)\\n    \\n    for index in range(1, n):\\n        if index > k:\\n            total -= row[left]\\n            left += 1\\n        \\n        if index < n - k:\\n            right += 1\\n            total += row[right]\\n        newRow.append(total)\\n        \\n    return newRow\\n    \\n\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        ans = [solveRow(row,k) for row in mat]   # O(n*m)\\n        ans = [solveRow(x, k) for x in zip(*ans)] # O(n*m)  Transpose\\n        return [list(x) for x in zip(*ans)] # Transpose again\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257786,
                "title": "java-prefix-sum-with-explanation",
                "content": "**Idea:** When the query is for cell `(i, j)`, you actually look for cell `(i + k, j + k)` i.e. the bottom right corner of the required block. The rest of the question is same as [Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable). \\n\\nCalculate prefix-sum matrix of the matrix. Then subtract out-of-boundary top and right rectangles (prefix sum cells corresponding to them), then add back intersection of these 2 rectangles as you\\'ve subtracted the intersection twice. \\n\\nExplanation of this logic is in [Approach#4 of Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable) and also in this [CV article](https://computersciencesource.wordpress.com/2010/09/03/computer-vision-the-integral-image/).\\n\\n**T/S:** O(mn), where m x n are the dimensions of the matrix.\\n\\n```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\tvar prefixSum = getPrefixSum(mat);\\n\\tvar m = mat.length;\\n\\tvar n = mat[0].length;\\n\\tvar blockSum = new int[mat.length][mat[0].length];\\n\\t\\n\\tfor (var i = 0; i < m; i++) {\\n\\t\\tfor (var j = 0; j < n; j++) {\\n\\n\\t\\t\\tvar bottomRightX = Math.min(m, i + 1 + k);\\n\\t\\t\\tvar bottomRightY = Math.min(n, j + 1 + k);\\n\\n\\t\\t\\tvar topLeftX = Math.max(0, i - k);\\n\\t\\t\\tvar topLeftY = Math.max(0, j - k);\\n\\n\\t\\t\\tblockSum[i][j] = prefixSum[bottomRightX][bottomRightY] // bottom right corner\\n\\t\\t\\t\\t\\t- prefixSum[bottomRightX][topLeftY] // top neighbor of block\\n\\t\\t\\t\\t\\t- prefixSum[topLeftX][bottomRightY] // left neighbor of block\\n\\t\\t\\t\\t\\t+ prefixSum[topLeftX][topLeftY]; // intersection of top and left neighbors\\n\\t\\t}\\n\\t}\\n\\treturn blockSum;\\n}\\n\\nprivate int[][] getPrefixSum(int[][] mat) {\\n\\tvar prefixSum = new int[mat.length + 1][mat[0].length + 1];\\n\\tfor (var i = 1; i < prefixSum.length; i++)\\n\\t\\tfor (var j = 1; j < prefixSum[0].length; j++)\\n\\t\\t\\tprefixSum[i][j] = prefixSum[i][j - 1]\\n\\t\\t\\t\\t\\t+ prefixSum[i - 1][j]\\n\\t\\t\\t\\t\\t- prefixSum[i - 1][j - 1]\\n\\t\\t\\t\\t\\t+ mat[i - 1][j - 1];\\n\\treturn prefixSum;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\tvar prefixSum = getPrefixSum(mat);\\n\\tvar m = mat.length;\\n\\tvar n = mat[0].length;\\n\\tvar blockSum = new int[mat.length][mat[0].length];\\n\\t\\n\\tfor (var i = 0; i < m; i++) {\\n\\t\\tfor (var j = 0; j < n; j++) {\\n\\n\\t\\t\\tvar bottomRightX = Math.min(m, i + 1 + k);\\n\\t\\t\\tvar bottomRightY = Math.min(n, j + 1 + k);\\n\\n\\t\\t\\tvar topLeftX = Math.max(0, i - k);\\n\\t\\t\\tvar topLeftY = Math.max(0, j - k);\\n\\n\\t\\t\\tblockSum[i][j] = prefixSum[bottomRightX][bottomRightY] // bottom right corner\\n\\t\\t\\t\\t\\t- prefixSum[bottomRightX][topLeftY] // top neighbor of block\\n\\t\\t\\t\\t\\t- prefixSum[topLeftX][bottomRightY] // left neighbor of block\\n\\t\\t\\t\\t\\t+ prefixSum[topLeftX][topLeftY]; // intersection of top and left neighbors\\n\\t\\t}\\n\\t}\\n\\treturn blockSum;\\n}\\n\\nprivate int[][] getPrefixSum(int[][] mat) {\\n\\tvar prefixSum = new int[mat.length + 1][mat[0].length + 1];\\n\\tfor (var i = 1; i < prefixSum.length; i++)\\n\\t\\tfor (var j = 1; j < prefixSum[0].length; j++)\\n\\t\\t\\tprefixSum[i][j] = prefixSum[i][j - 1]\\n\\t\\t\\t\\t\\t+ prefixSum[i - 1][j]\\n\\t\\t\\t\\t\\t- prefixSum[i - 1][j - 1]\\n\\t\\t\\t\\t\\t+ mat[i - 1][j - 1];\\n\\treturn prefixSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248856,
                "title": "c-prefix-row-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(),m=mat[0].size();\\n        int row[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0){\\n                    row[i][j]=mat[i][j];\\n                }\\n                else{\\n                    row[i][j]=row[i][j-1]+mat[i][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                mat[i][j]=0;\\n                for(int l=max(0,i-k);l<=min(n-1,i+k);l++){\\n                mat[i][j]+=row[l][min(m-1,j+k)]-((j-k-1<0)?0:row[l][max(0,j-k-1)]);\\n                \\n              }\\n                \\n          }\\n        }\\n        return mat;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(),m=mat[0].size();\\n        int row[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0){\\n                    row[i][j]=mat[i][j];\\n                }\\n                else{\\n                    row[i][j]=row[i][j-1]+mat[i][j];\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                mat[i][j]=0;\\n                for(int l=max(0,i-k);l<=min(n-1,i+k);l++){\\n                mat[i][j]+=row[l][min(m-1,j+k)]-((j-k-1<0)?0:row[l][max(0,j-k-1)]);\\n                \\n              }\\n                \\n          }\\n        }\\n        return mat;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209634,
                "title": "matrix-block-sum-python-prefix-sum-simple-implementation-dynamic-programming",
                "content": "First we make a prefix sum array and than just simple implementation \\n```\\nclass Solution:\\n    \\n    import sys\\n    input = sys.stdin.readline\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n= len(mat)\\n        \\n        m = len(mat[0])\\n        \\n        pre=[ [ 0 for i in range(m)] for j in range(n) ]\\n        \\n        \\n        pre[0][0] = mat[0][0]\\n        \\n        \\n        for i in range(1,m):\\n            \\n            pre[0][i] += pre[0][i-1] + mat[0][i]\\n            \\n        for j in range(1,n):\\n            \\n            pre[j][0] += pre[j-1][0] + mat[j][0]\\n            \\n        \\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                \\n                pre[i][j] += pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]+mat[i][j]\\n                \\n        \\n        result = [[ 0 for i in range(m)] for j in range(n) ]\\n        \\n        \\n        for i in range(n):\\n            for j in range(m):\\n                \\n                \\n                r1=  min(i+k,n-1)\\n                c1 = min(j+k , m-1)\\n                \\n                \\n                result[i][j]= pre[r1][c1]\\n                \\n                \\n                \\n                if i-k>0:\\n                    result[i][j] -= pre[i-k-1][c1] # we have to delete extra sum\\n                    \\n                if j-k>0:\\n                    result[i][j] -= pre[r1][j-k-1] # we have to delete extra sum\\n                    \\n                    \\n                if i-k>0 and j-k>0:\\n                    \\n                    result[i][j] += pre[i-k-1][j-k-1] # because we have deleted common sum two times\\n                    \\n        return result\\n                    \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \\n    import sys\\n    input = sys.stdin.readline\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n= len(mat)\\n        \\n        m = len(mat[0])\\n        \\n        pre=[ [ 0 for i in range(m)] for j in range(n) ]\\n        \\n        \\n        pre[0][0] = mat[0][0]\\n        \\n        \\n        for i in range(1,m):\\n            \\n            pre[0][i] += pre[0][i-1] + mat[0][i]\\n            \\n        for j in range(1,n):\\n            \\n            pre[j][0] += pre[j-1][0] + mat[j][0]\\n            \\n        \\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                \\n                pre[i][j] += pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]+mat[i][j]\\n                \\n        \\n        result = [[ 0 for i in range(m)] for j in range(n) ]\\n        \\n        \\n        for i in range(n):\\n            for j in range(m):\\n                \\n                \\n                r1=  min(i+k,n-1)\\n                c1 = min(j+k , m-1)\\n                \\n                \\n                result[i][j]= pre[r1][c1]\\n                \\n                \\n                \\n                if i-k>0:\\n                    result[i][j] -= pre[i-k-1][c1] # we have to delete extra sum\\n                    \\n                if j-k>0:\\n                    result[i][j] -= pre[r1][j-k-1] # we have to delete extra sum\\n                    \\n                    \\n                if i-k>0 and j-k>0:\\n                    \\n                    result[i][j] += pre[i-k-1][j-k-1] # because we have deleted common sum two times\\n                    \\n        return result\\n                    \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168483,
                "title": "easy-to-understand-solution-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector <vector<int>> cache, ans;\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int r = mat.size(), c = mat[0].size();\\n        cache.resize(r, vector<int>(c, 0));\\n        ans.resize(r, vector<int>(c, 0));\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                cache[i][j] = mat[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 1; j < c; j++) {\\n                cache[i][j] += cache[i][j-1];\\n            }\\n        }\\n        \\n        for(int j = 0; j < c; j++) {\\n            for(int i = 1; i < r; i++) {\\n                cache[i][j] += cache[i-1][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                int tr = i - k - 1, tc = j - k - 1;\\n                int br = min(r - 1, i + k), bc = min(c - 1, j + k);\\n                \\n                int removeSum = 0;\\n                \\n                if(tc >= 0) removeSum += cache[br][tc];\\n                if(tr >= 0) removeSum += cache[tr][bc];\\n\\n                if(tr >= 0 and tc >= 0) removeSum -= cache[tr][tc];\\n                \\n                ans[i][j] = cache[br][bc] - removeSum;\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector <vector<int>> cache, ans;\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int r = mat.size(), c = mat[0].size();\\n        cache.resize(r, vector<int>(c, 0));\\n        ans.resize(r, vector<int>(c, 0));\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                cache[i][j] = mat[i][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 1; j < c; j++) {\\n                cache[i][j] += cache[i][j-1];\\n            }\\n        }\\n        \\n        for(int j = 0; j < c; j++) {\\n            for(int i = 1; i < r; i++) {\\n                cache[i][j] += cache[i-1][j];\\n            }\\n        }\\n        \\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                int tr = i - k - 1, tc = j - k - 1;\\n                int br = min(r - 1, i + k), bc = min(c - 1, j + k);\\n                \\n                int removeSum = 0;\\n                \\n                if(tc >= 0) removeSum += cache[br][tc];\\n                if(tr >= 0) removeSum += cache[tr][bc];\\n\\n                if(tr >= 0 and tc >= 0) removeSum -= cache[tr][tc];\\n                \\n                ans[i][j] = cache[br][bc] - removeSum;\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151268,
                "title": "java-prefix-sum-dynamic-programming-o-n-2-solution-faster-than-95-of-submissions",
                "content": "```\\nclass Solution {\\npublic static int[][] matrixBlockSum(int[][] mat, int k) {\\n        int r = mat.length;\\n        int c = mat[0].length;\\n        int[][] sum = new int[r][c];\\n        int[][] ans = new int[r][c];\\n        sum[0][0]=mat[0][0];\\n        for(int i = 1;i<r;i++) {\\n            sum[i][0]=mat[i][0]+sum[i-1][0];\\n        }\\n        for(int i = 1;i<c;i++) {\\n            sum[0][i]=mat[0][i]+sum[0][i-1];\\n        }\\n        for(int i = 1;i<r;i++) {\\n            for(int j = 1;j<c;j++) {\\n               sum[i][j]+=(mat[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]);\\n            }   \\n        }\\n\\t\\t\\n        int r1,c1,r2,c2;\\n        // (r1c1) is top left corner and (r2,c2) is bottom-right corner of sub-matrix \\n\\t\\t\\n\\t\\tfor(int i = 0;i<r;i++) {\\n            for(int j = 0;j<c;j++) {\\n                r1 = Math.max(0,i-k);\\n                r2 = Math.min(r-1,i+k);\\n                c1 = Math.max(0,j-k);\\n                c2 = Math.min(c-1,j+k);\\n                ans[i][j] = sum[r2][c2];\\n                if(r1>0 && c1>0) {\\n                    ans[i][j]-=(sum[r1-1][c2]+sum[r2][c1-1]-sum[r1-1][c1-1]);\\n                }\\n                else if(r1>0) {\\n                    ans[i][j]-=(sum[r1-1][c2]);\\n                }\\n                else if(c1>0) {\\n                    ans[i][j]-=sum[r2][c1-1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\t\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic static int[][] matrixBlockSum(int[][] mat, int k) {\\n        int r = mat.length;\\n        int c = mat[0].length;\\n        int[][] sum = new int[r][c];\\n        int[][] ans = new int[r][c];\\n        sum[0][0]=mat[0][0];\\n        for(int i = 1;i<r;i++) {\\n            sum[i][0]=mat[i][0]+sum[i-1][0];\\n        }\\n        for(int i = 1;i<c;i++) {\\n            sum[0][i]=mat[0][i]+sum[0][i-1];\\n        }\\n        for(int i = 1;i<r;i++) {\\n            for(int j = 1;j<c;j++) {\\n               sum[i][j]+=(mat[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]);\\n            }   \\n        }\\n\\t\\t\\n        int r1,c1,r2,c2;\\n        // (r1c1) is top left corner and (r2,c2) is bottom-right corner of sub-matrix \\n\\t\\t\\n\\t\\tfor(int i = 0;i<r;i++) {\\n            for(int j = 0;j<c;j++) {\\n                r1 = Math.max(0,i-k);\\n                r2 = Math.min(r-1,i+k);\\n                c1 = Math.max(0,j-k);\\n                c2 = Math.min(c-1,j+k);\\n                ans[i][j] = sum[r2][c2];\\n                if(r1>0 && c1>0) {\\n                    ans[i][j]-=(sum[r1-1][c2]+sum[r2][c1-1]-sum[r1-1][c1-1]);\\n                }\\n                else if(r1>0) {\\n                    ans[i][j]-=(sum[r1-1][c2]);\\n                }\\n                else if(c1>0) {\\n                    ans[i][j]-=sum[r2][c1-1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081223,
                "title": "short",
                "content": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& m, int K) \\n{       \\n\\tint N(size(m)), M(size(m[0]));\\n\\tfor(auto i{0}; i<N; ++i)\\n\\t\\tfor(auto j{0}; j<M; ++j)\\n\\t\\t\\tm[i][j] += (i ? m[i-1][j] : 0) + (j ? m[i][j-1] : 0) - (i and j ? m[i-1][j-1] : 0);\\n\\n    vector out(N, vector(M, 0));  \\n\\tfor(auto i{0}; i<N; ++i)\\n\\t\\tfor(auto j{0}; j<M; ++j)\\n\\t\\t{\\n\\t\\t\\tauto bi{min(i+K, N-1)}, bj{min(j+K, M-1)}, ui{max(i-K, 0)}, uj{max(j-K, 0)};\\n\\t\\t\\tout[i][j] = m[bi][bj] - (ui ? m[ui-1][bj] : 0) - (uj ? m[bi][uj-1] : 0) + (ui and uj ? m[ui-1][uj-1] : 0);\\n\\t\\t}\\n\\n\\treturn out;\\n}\\n```\\n`ui` - upper `i`;\\n`uj` - upper `j`;\\n`bi` - bottom `i`;\\n`bj` - bottom `j`.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/48561368-819b-4c0c-932f-5c6086717a10_1614196016.36988.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& m, int K) \\n{       \\n\\tint N(size(m)), M(size(m[0]));\\n\\tfor(auto i{0}; i<N; ++i)\\n\\t\\tfor(auto j{0}; j<M; ++j)\\n\\t\\t\\tm[i][j] += (i ? m[i-1][j] : 0) + (j ? m[i][j-1] : 0) - (i and j ? m[i-1][j-1] : 0);\\n\\n    vector out(N, vector(M, 0));  \\n\\tfor(auto i{0}; i<N; ++i)\\n\\t\\tfor(auto j{0}; j<M; ++j)\\n\\t\\t{\\n\\t\\t\\tauto bi{min(i+K, N-1)}, bj{min(j+K, M-1)}, ui{max(i-K, 0)}, uj{max(j-K, 0)};\\n\\t\\t\\tout[i][j] = m[bi][bj] - (ui ? m[ui-1][bj] : 0) - (uj ? m[bi][uj-1] : 0) + (ui and uj ? m[ui-1][uj-1] : 0);\\n\\t\\t}\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010493,
                "title": "java-o-m-n-runtime-using-sum-matrix",
                "content": "Let\\'s imagine we have a box, and we want to shade in as much of that box at any given point given the boundaries. Let\\'s say we\\'re given a sum matrix, which tells us the sum of all elements above and to the left of us. Then we can use some algebra to calculate the box around any given point. \\n\\nTo do this, we go as far right as we can before we hit our position `j + K`. We also go as far down as we can, which is `i + K`. This is represented as the `minimum` of `M-1` and `i+K` , and `N-1` and `j+K`. Because our sum matrix is shifted 1 to the right to avoid the case where our left boundary is out of the matrix, we add all values in our math by 1 index. Then we need to start removing all of the stuff that\\'s outside our boundary to the left. This is done similarly, in which if the left boundary `j-K-1` or the top boundary `i-K-1` exists, we subtract everything from there. But because we subtracted some elements twice, we have to add back all the top left elements that overlapped by adding `(i-K, j-K)`.\\n\\nTo help visualize this, a good exercise is to plot points A, B, C, D on paper, and shade in the boxes that we\\'re adding and subtracting. The code is short and simple, but try to recreate it yourself!\\n\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int M = mat.length, N = mat[0].length;\\n        int[][] res = new int[M][N], sum = new int[M+1][N+1];\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                sum[i+1][j+1] = mat[i][j] + sum[i+1][j] + sum[i][j+1] - sum[i][j];\\n            }\\n        }\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                int A = Math.max(0, i-K), B = Math.max(0, j-K), C = Math.min(M, i+K+1), D = Math.min(N, j+K+1);\\n                res[i][j] = sum[C][D] - sum[A][D] - sum[C][B] + sum[A][B];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        int M = mat.length, N = mat[0].length;\\n        int[][] res = new int[M][N], sum = new int[M+1][N+1];\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                sum[i+1][j+1] = mat[i][j] + sum[i+1][j] + sum[i][j+1] - sum[i][j];\\n            }\\n        }\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                int A = Math.max(0, i-K), B = Math.max(0, j-K), C = Math.min(M, i+K+1), D = Math.min(N, j+K+1);\\n                res[i][j] = sum[C][D] - sum[A][D] - sum[C][B] + sum[A][B];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975548,
                "title": "java-96-faster-using-pre-calcualted-sum-matrix",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int M = mat.length;\\n        int N = mat[0].length;\\n        \\n        int[][] dp = new int[M+1][N+1];\\n        for(int i=0;i<M;i++) {\\n            for(int j=0;j<N;j++) {\\n                dp[i+1][j+1] = mat[i][j] + dp[i][j+1] + dp[i+1][j] - dp[i][j];\\n            }\\n        }\\n        \\n        for(int i=0;i<M;i++) {\\n            for(int j=0;j<N;j++) {\\n                \\n                int r1 = Math.max(0, i-K);\\n                int c1 = Math.max(0, j-K);\\n                int r2 = Math.min(M-1, i+K);\\n                int c2 = Math.min(N-1, j+K);\\n                \\n                mat[i][j] = dp[r2+1][c2+1] -dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int M = mat.length;\\n        int N = mat[0].length;\\n        \\n        int[][] dp = new int[M+1][N+1];\\n        for(int i=0;i<M;i++) {\\n            for(int j=0;j<N;j++) {\\n                dp[i+1][j+1] = mat[i][j] + dp[i][j+1] + dp[i+1][j] - dp[i][j];\\n            }\\n        }\\n        \\n        for(int i=0;i<M;i++) {\\n            for(int j=0;j<N;j++) {\\n                \\n                int r1 = Math.max(0, i-K);\\n                int c1 = Math.max(0, j-K);\\n                int r2 = Math.min(M-1, i+K);\\n                int c2 = Math.min(N-1, j+K);\\n                \\n                mat[i][j] = dp[r2+1][c2+1] -dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950320,
                "title": "simple-python-solution",
                "content": "simply code up the instructions\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n\\t\\t# initialize the output\\n        answer = [[0 for j in range(n)] for i in range(m)]\\n        \\n\\t\\t# code up the instructions with the max/min trick\\n        for i in range(m):\\n            for j in range(n):\\n                answer[i][j] = sum(\\n                    mat[r][c] for r in range(max(0, i-K), min(m, i+K+1)) \\n                              for c in range(max(0, j - K), min(n, j+K+1))\\n                )\\n        \\n        return answer\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n\\t\\t# initialize the output\\n        answer = [[0 for j in range(n)] for i in range(m)]\\n        \\n\\t\\t# code up the instructions with the max/min trick\\n        for i in range(m):\\n            for j in range(n):\\n                answer[i][j] = sum(\\n                    mat[r][c] for r in range(max(0, i-K), min(m, i+K+1)) \\n                              for c in range(max(0, j - K), min(n, j+K+1))\\n                )\\n        \\n        return answer\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 943647,
                "title": "c-95-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        int m = mat.size();\\n        if(m == 0) return mat;\\n        int n = mat[0].size();\\n        if(n == 0) return mat;\\n        \\n        dp = vector<vector<int>> (m+1, vector<int> (n+1, 0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] - dp[i][j] + mat[i][j];\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mat[i][j] = helper(i-K, i+K, j-K, j+K, m, n);\\n            }\\n        }\\n        return mat;\\n    }\\n    int helper(int iMin, int iMax, int jMin, int jMax, int m, int n)\\n    {\\n        iMin = iMin < 0 ? 0 : iMin;\\n        iMax = iMax >= m ? m-1 : iMax;\\n        jMin = jMin < 0 ? 0 : jMin;\\n        jMax = jMax >= n ? n-1 : jMax;\\n        return dp[iMax+1][jMax+1] + dp[iMin][jMin] - dp[iMax+1][jMin] - dp[iMin][jMax+1]; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        int m = mat.size();\\n        if(m == 0) return mat;\\n        int n = mat[0].size();\\n        if(n == 0) return mat;\\n        \\n        dp = vector<vector<int>> (m+1, vector<int> (n+1, 0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] - dp[i][j] + mat[i][j];\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                mat[i][j] = helper(i-K, i+K, j-K, j+K, m, n);\\n            }\\n        }\\n        return mat;\\n    }\\n    int helper(int iMin, int iMax, int jMin, int jMax, int m, int n)\\n    {\\n        iMin = iMin < 0 ? 0 : iMin;\\n        iMax = iMax >= m ? m-1 : iMax;\\n        jMin = jMin < 0 ? 0 : jMin;\\n        jMax = jMax >= n ? n-1 : jMax;\\n        return dp[iMax+1][jMax+1] + dp[iMin][jMin] - dp[iMax+1][jMin] - dp[iMin][jMax+1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910337,
                "title": "clean-java-code-with-explanation-beats-97",
                "content": "The idea here is to calculate a prefix sum of the 2D Array. Any cell in prefixSum represents the sum of all values formed by the rectangle (0,0) and(i,j). \\n\\nIllustration\\n\\n![image](https://assets.leetcode.com/users/images/65722fe3-7503-4af2-a98d-f3217658056f_1603669488.6309206.png)\\n\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] prefixSum = new int[m][n];\\n        int[][] result = new int[m][n];\\n        \\n        prefixSum[0][0] = mat[0][0];\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            prefixSum[i][0] = mat[i][0] + prefixSum[i-1][0];    \\n        }\\n        \\n        for(int j=1; j<n; j++)\\n        {\\n            prefixSum[0][j] = mat[0][j] + prefixSum[0][j-1];    \\n        }\\n            \\n        for(int i=1; i<m; i++)\\n        {\\n            for(int j=1; j<n; j++)\\n            {\\n                prefixSum[i][j] = mat[i][j] + prefixSum[i-1][j] + prefixSum[i][j-1] - prefixSum[i-1][j-1];\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                int r1 = Math.max(0, i-K);\\n                int c1 = Math.max(0, j-K);\\n                int r2 = Math.min(m-1, i+K);\\n                int c2 = Math.min(n-1, j+K);\\n                \\n                result[i][j] = prefixSum[r2][c2];\\n                \\n                if(r1 > 0)\\n                    result[i][j] -= prefixSum[r1-1][c2];             \\n                \\n                if(c1 > 0)\\n                    result[i][j] -= prefixSum[r2][c1-1];             \\n                \\n                if(r1 > 0 && c1 > 0)\\n                    result[i][j] += prefixSum[r1-1][c1-1];          \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[][] prefixSum = new int[m][n];\\n        int[][] result = new int[m][n];\\n        \\n        prefixSum[0][0] = mat[0][0];\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            prefixSum[i][0] = mat[i][0] + prefixSum[i-1][0];    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 873441,
                "title": "o-m-n-python-without-indices",
                "content": "It\\'s always the `i`s and `j`s that trip me up when solving this type of problem, so I thought I\\'d implement a solution in Python that doesn\\'t use any `i`s or `j`s at all, using some of the tools found in the `itertools` module.\\n\\nSay `K == 1`, then for each row, we first want to compute the sums of overlapping groups of `3` -- that\\'s `2*K + 1`. Here\\'s an example. It\\'s convenient to bookend the row with `K` zeroes.\\n\\n```txt\\nrow = [4, 2, 9, 1]\\nsummed_row = [6 15, 12, 10]\\n\\n  0   4   2   9   1   0\\n  0 + 4 + 2             = 6\\n      4 + 2 + 9         = 15\\n          2 + 9 + 1     = 12\\n              9 + 1 + 0 = 10\\n```\\n\\nYou might notice as we go from one sum to the next, we only have to subtract one value at the left end, and add one value at the right end. We can do this efficiently by using a FIFO queue to keep track of the values in the current sum. This is what the `sums` generator does in the implementation below.\\n\\nOnce we\\'ve done this for each row, we have a new matrix, and are half way to solving the problem. We\\'ve summed row-wise; we now need to sum column-wise. To do this, we just transpose the new matrix, apply this process again, and transpose it back.\\n\\n```python\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, K):\\n        def sums(iterable):\\n            queue = collections.deque()\\n            total = 0\\n            bookended_iterable = itertools.chain(\\n                itertools.repeat(0, K),\\n                iterable,\\n                itertools.repeat(0, K),\\n            )\\n            for value in bookended_iterable:\\n                queue.append(value)\\n                total += value\\n                if len(queue) == 2*K + 1:\\n                    yield total\\n                    total -= queue.popleft()\\n        new_mat_1 = (sums(row) for row in mat)\\n        new_mat_2 = (sums(row) for row in zip(*new_mat_1))\\n        return [list(row) for row in zip(*new_mat_2)]\\n```\\n\\nHere\\'s another implementation along similar lines. This one is actually a little bit faster because all the iteration is done inside `map` and `itertools` functions, which are all implemented in C. In fact, last I checked, this scored 100% for runtime.\\n\\n```python\\nfrom itertools  import accumulate, chain, repeat, tee, islice\\nfrom operator   import sub\\n\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, K):\\n        def sums(iterable):\\n            bookended = chain(repeat(0, K), iterable, repeat(0, K))\\n            it1, it2 = tee(accumulate(bookended, initial=0))\\n            return map(sub, islice(it1, 2*K+1, None), it2)\\n        new_mat_1 = map(sums, mat)\\n        new_mat_2 = map(sums, zip(*new_mat_1))\\n        return list(map(list, zip(*new_mat_2)))\\n```\\n\\nAnd finally, a one-liner using numpy/scipy. This isn\\'t fast enough for the test-cases unfortunately:\\n\\n```python\\nimport numpy as np\\nfrom scipy.ndimage import convolve\\n\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, k):\\n        return convolve(mat, np.ones((2*k+1, 2*k+1)), mode=\\'constant\\')\\n```",
                "solutionTags": [],
                "code": "```txt\\nrow = [4, 2, 9, 1]\\nsummed_row = [6 15, 12, 10]\\n\\n  0   4   2   9   1   0\\n  0 + 4 + 2             = 6\\n      4 + 2 + 9         = 15\\n          2 + 9 + 1     = 12\\n              9 + 1 + 0 = 10\\n```\n```python\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, K):\\n        def sums(iterable):\\n            queue = collections.deque()\\n            total = 0\\n            bookended_iterable = itertools.chain(\\n                itertools.repeat(0, K),\\n                iterable,\\n                itertools.repeat(0, K),\\n            )\\n            for value in bookended_iterable:\\n                queue.append(value)\\n                total += value\\n                if len(queue) == 2*K + 1:\\n                    yield total\\n                    total -= queue.popleft()\\n        new_mat_1 = (sums(row) for row in mat)\\n        new_mat_2 = (sums(row) for row in zip(*new_mat_1))\\n        return [list(row) for row in zip(*new_mat_2)]\\n```\n```python\\nfrom itertools  import accumulate, chain, repeat, tee, islice\\nfrom operator   import sub\\n\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, K):\\n        def sums(iterable):\\n            bookended = chain(repeat(0, K), iterable, repeat(0, K))\\n            it1, it2 = tee(accumulate(bookended, initial=0))\\n            return map(sub, islice(it1, 2*K+1, None), it2)\\n        new_mat_1 = map(sums, mat)\\n        new_mat_2 = map(sums, zip(*new_mat_1))\\n        return list(map(list, zip(*new_mat_2)))\\n```\n```python\\nimport numpy as np\\nfrom scipy.ndimage import convolve\\n\\nclass Solution:\\n    \\n    def matrixBlockSum(self, mat, k):\\n        return convolve(mat, np.ones((2*k+1, 2*k+1)), mode=\\'constant\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856544,
                "title": "easy-to-read-code-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pref_sum(n, vector<int>(m, 0)), res(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pref_sum[i][j] = mat[i][j];\\n                if (i - 1 >= 0) pref_sum[i][j] += pref_sum[i - 1][j];\\n                if (j - 1 >= 0) pref_sum[i][j] += pref_sum[i][j - 1];\\n                if (i - 1 >= 0 && j - 1 >= 0) pref_sum[i][j] -= pref_sum[i - 1][j - 1];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int x1 = max(i - k, 0), y1 = max(j - k, 0), x2 = min(i + k, n - 1), y2 = min(j + k, m - 1);\\n                res[i][j] = pref_sum[x2][y2];\\n                if (x1 - 1 >= 0) res[i][j] -= pref_sum[x1 - 1][y2];\\n                if (y1 - 1 >= 0) res[i][j] -= pref_sum[x2][y1 - 1];\\n                if (x1 - 1 >= 0 && y1 - 1 >= 0) res[i][j] += pref_sum[x1 - 1][y1 - 1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pref_sum(n, vector<int>(m, 0)), res(n, vector<int>(m, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pref_sum[i][j] = mat[i][j];\\n                if (i - 1 >= 0) pref_sum[i][j] += pref_sum[i - 1][j];\\n                if (j - 1 >= 0) pref_sum[i][j] += pref_sum[i][j - 1];\\n                if (i - 1 >= 0 && j - 1 >= 0) pref_sum[i][j] -= pref_sum[i - 1][j - 1];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int x1 = max(i - k, 0), y1 = max(j - k, 0), x2 = min(i + k, n - 1), y2 = min(j + k, m - 1);\\n                res[i][j] = pref_sum[x2][y2];\\n                if (x1 - 1 >= 0) res[i][j] -= pref_sum[x1 - 1][y2];\\n                if (y1 - 1 >= 0) res[i][j] -= pref_sum[x2][y1 - 1];\\n                if (x1 - 1 >= 0 && y1 - 1 >= 0) res[i][j] += pref_sum[x1 - 1][y1 - 1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847598,
                "title": "o-n-2-time-complexity-python-solution-using-prefix-sum",
                "content": "```\\nclass Solution(object):\\n    def matrixBlockSum(self, mat, K):\\n        n = len(mat)\\n        m = len(mat[0])\\n        dp = [[0 for i in range(m+1)] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                dp[i][j] = mat[i-1][j-1] + dp[i-1][j]  + dp[i][j-1] - dp[i-1][j-1] \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                r1 = max(i-K-1,0)\\n                c1 = max(j-K-1,0)\\n                r2 = min(i+K,n)\\n                c2 = min(j+K,m)\\n                mat[i-1][j-1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1]\\n        return mat\\n\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution(object):\\n    def matrixBlockSum(self, mat, K):\\n        n = len(mat)\\n        m = len(mat[0])\\n        dp = [[0 for i in range(m+1)] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                dp[i][j] = mat[i-1][j-1] + dp[i-1][j]  + dp[i][j-1] - dp[i-1][j-1] \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                r1 = max(i-K-1,0)\\n                c1 = max(j-K-1,0)\\n                r2 = min(i+K,n)\\n                c2 = min(j+K,m)\\n                mat[i-1][j-1] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1]\\n        return mat\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 812592,
                "title": "c-solution-easy-to-understand-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int give(int num,int n)\\n    {\\n        if(num < 0)\\n            return 0;\\n        if(num>=n)\\n            return n-1;\\n        return num;\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        \\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        for(int i=0;i<mat.size();i++)\\n            for(int j=1;j<mat[0].size();j++)\\n                mat[i][j]+=mat[i][j-1];\\n        \\n        for(int i=0;i<mat[0].size();i++)\\n            for(int j=1;j<mat.size();j++)\\n                mat[j][i]+=mat[j-1][i];\\n        \\n        vector<vector<int>> ans;        \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            vector<int> v;\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                int val = 0;\\n                val+=mat[give(i+k,n)][give(j+k,m)];\\n                if(i > k)\\n                    val-=mat[give(i-k-1,n)][give(j+k,m)];\\n                if(j > k)\\n                    val-=mat[give(i+k,n)][give(j-k-1,m)];\\n                if(i>k and j>k)\\n                    val+=mat[give(i-k-1,n)][give(j-k-1,m)];\\n                \\n                v.push_back(val);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int give(int num,int n)\\n    {\\n        if(num < 0)\\n            return 0;\\n        if(num>=n)\\n            return n-1;\\n        return num;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 733714,
                "title": "super-clean-python-o-n-m-solution",
                "content": "**Super Clean Python | O(n * m) solution**\\n\\nClean Python Code reaching the solution in an organized manner. It looks like a college homework lol.\\n\\n```\\nfmax     = lambda x,y: x if x>y else y # 33% Faster than Python\\'s Built-in MAX Function\\nfmin     = lambda x,y: x if x<y else y # Idem for MIN Function\\ninizero  = lambda r,c: [[0]*c for _ in range(r)]\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        r,c = len(mat), len(mat[0])\\n        #\\n        # -----------------------------------\\n        #         Range Sums Up to [i,j]\\n        # -----------------------------------\\n        #\\n        Sum    = inizero(r,c)\\n        #\\n        # First Row Initilization\\n        s = 0\\n        for j in range(c):\\n            s        += mat[0][j]\\n            Sum[0][j] = s\\n        #\\n        # First Column Initilization\\n        s = 0\\n        for i in range(r):\\n            s        += mat[i][0]\\n            Sum[i][0] = s\\n        #\\n        # Center Range\\n        for i in range(1,r):\\n            for j in range(1,c):\\n                Sum[i][j] = mat[i][j] + Sum[i-1][j] + Sum[i][j-1] - Sum[i-1][j-1]\\n        #\\n        # -----------------------------------\\n        #         Final Answer\\n        # -----------------------------------\\n        res = inizero(r,c)\\n        for i in range(r):\\n            for j in range(c):\\n                i1,j1 = fmax(0  ,i-K),fmax(0  ,j-K)\\n                i2,j2 = fmin(r-1,i+K),fmin(c-1,j+K)\\n                #\\n                a = Sum[i2][j2]\\n                if i1>0:\\n                    a -= Sum[i1-1][j2]\\n                    if j1>0:\\n                        a += Sum[i1-1][j1-1] # This was being subtracted twice\\n                if j1>0:\\n                    a -= Sum[i2][j1-1]\\n                res[i][j] = a\\n        #\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfmax     = lambda x,y: x if x>y else y # 33% Faster than Python\\'s Built-in MAX Function\\nfmin     = lambda x,y: x if x<y else y # Idem for MIN Function\\ninizero  = lambda r,c: [[0]*c for _ in range(r)]\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        r,c = len(mat), len(mat[0])\\n        #\\n        # -----------------------------------\\n        #         Range Sums Up to [i,j]\\n        # -----------------------------------\\n        #\\n        Sum    = inizero(r,c)\\n        #\\n        # First Row Initilization\\n        s = 0\\n        for j in range(c):\\n            s        += mat[0][j]\\n            Sum[0][j] = s\\n        #\\n        # First Column Initilization\\n        s = 0\\n        for i in range(r):\\n            s        += mat[i][0]\\n            Sum[i][0] = s\\n        #\\n        # Center Range\\n        for i in range(1,r):\\n            for j in range(1,c):\\n                Sum[i][j] = mat[i][j] + Sum[i-1][j] + Sum[i][j-1] - Sum[i-1][j-1]\\n        #\\n        # -----------------------------------\\n        #         Final Answer\\n        # -----------------------------------\\n        res = inizero(r,c)\\n        for i in range(r):\\n            for j in range(c):\\n                i1,j1 = fmax(0  ,i-K),fmax(0  ,j-K)\\n                i2,j2 = fmin(r-1,i+K),fmin(c-1,j+K)\\n                #\\n                a = Sum[i2][j2]\\n                if i1>0:\\n                    a -= Sum[i1-1][j2]\\n                    if j1>0:\\n                        a += Sum[i1-1][j1-1] # This was being subtracted twice\\n                if j1>0:\\n                    a -= Sum[i2][j1-1]\\n                res[i][j] = a\\n        #\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572515,
                "title": "c-solution-very-precise-beats-100-memory",
                "content": "First we calculate the required prefix sum for the entire matrix.\\nThen we store the required block sum in ans[i][j] taking care of boundary cases.\\nSee pictures for better visualisation.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& a, int k) {\\n        int m=a.size();\\n        int n=a[0].size();\\n        \\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]+a[i-1][j-1]-dp[i-1][j-1];\\n            }\\n        }\\n         \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                int x=dp[min(m,i+k)][min(n,j+k)];\\n                int y=dp[max(0,i-k-1)][min(n,j+k)];\\n                int w=dp[min(m,i+k)][max(0,j-k-1)];\\n                int z=dp[max(0,i-k-1)][max(0,j-k-1)];\\n                \\n                ans[i-1][j-1]=x+z-(y+w);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& a, int k) {\\n        int m=a.size();\\n        int n=a[0].size();\\n        \\n        vector<vector<int>>dp(m+1,vector<int>(n+1,0));\\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]+a[i-1][j-1]-dp[i-1][j-1];\\n            }\\n        }\\n         \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                int x=dp[min(m,i+k)][min(n,j+k)];\\n                int y=dp[max(0,i-k-1)][min(n,j+k)];\\n                int w=dp[min(m,i+k)][max(0,j-k-1)];\\n                int z=dp[max(0,i-k-1)][max(0,j-k-1)];\\n                \\n                ans[i-1][j-1]=x+z-(y+w);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485815,
                "title": "c-understandable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n\\t\\tint M = mat.size();\\n\\t\\tint N = mat[0].size();\\n\\t\\tvector<vector<int>> ans(M, vector<int>(N, 0));\\n\\t\\tfor (int i = 0; i < mat.size(); i++) {\\n\\t\\t\\tfor (int j = 0; j < mat[i].size(); j++) {\\n\\t\\t\\t\\tint rLower = ((i - K) < 0 ? 0 : (i - K));\\n\\t\\t\\t\\tint rUpper = (i + K) >= mat.size() ? (mat.size() - 1) : (i + K);\\n\\t\\t\\t\\tint cLower = ((j - K) < 0 ? 0 : (j - K));\\n\\t\\t\\t\\tint cUpper = (j + K) >= mat[i].size() ? (mat[i].size() - 1) : (j + K);\\n\\t\\t\\t\\tgetRangeSum(mat, rLower, rUpper, cLower, cUpper, i, j, ans);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvoid getRangeSum(vector<vector<int>> &mat, int rL, int rU, int cL, int cU, int i, int j, vector<vector<int>>& ans) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (int r = rL; r <= rU; r++) {\\n\\t\\t\\tfor (int c = cL; c <= cU; c++) {\\n\\t\\t\\t\\tsum += mat[r][c];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[i][j] += sum;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n\\t\\tint M = mat.size();\\n\\t\\tint N = mat[0].size();\\n\\t\\tvector<vector<int>> ans(M, vector<int>(N, 0));\\n\\t\\tfor (int i = 0; i < mat.size(); i++) {\\n\\t\\t\\tfor (int j = 0; j < mat[i].size(); j++) {\\n\\t\\t\\t\\tint rLower = ((i - K) < 0 ? 0 : (i - K));\\n\\t\\t\\t\\tint rUpper = (i + K) >= mat.size() ? (mat.size() - 1) : (i + K);\\n\\t\\t\\t\\tint cLower = ((j - K) < 0 ? 0 : (j - K));\\n\\t\\t\\t\\tint cUpper = (j + K) >= mat[i].size() ? (mat[i].size() - 1) : (j + K);\\n\\t\\t\\t\\tgetRangeSum(mat, rLower, rUpper, cLower, cUpper, i, j, ans);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvoid getRangeSum(vector<vector<int>> &mat, int rL, int rU, int cL, int cU, int i, int j, vector<vector<int>>& ans) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (int r = rL; r <= rU; r++) {\\n\\t\\t\\tfor (int c = cL; c <= cU; c++) {\\n\\t\\t\\t\\tsum += mat[r][c];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[i][j] += sum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485225,
                "title": "python3-short-and-fast-88ms-double-sliding-window",
                "content": "# Explanation\\nFirst take the matrix and build a matrix of sliding column sums.\\n\\nThen for that resulting matrix, build a matrix of sliding row sums.\\n\\nSo for example, with K=1:\\n```\\n1  2  3    +cols    5  7  9    +rows   12 21 16\\n4  5  6    ---->   12 15 18    ---->   27 45 33\\n7  8  9            11 13 15            24 39 28\\n```\\n\\nNote that we could do rows first, then columns. The order is arbritrary.\\n\\n# Code\\n\\n```python\\nclass Solution:\\n  def matrixBlockSum(self, grid: List[List[int]], K: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    \\n    # build a matrix of sliding window sums for each row\\n    dp = [[0] * w for _ in range(h)]    \\n    for x in range(w):\\n      dp[0][x] = sum(row[x] for row in grid[0:min(h, K+1)])\\n      for i in range(1, h):\\n        dp[i][x] = dp[i-1][x] + (grid[K+i][x] if K+i < h else 0) - (grid[i-K-1][x] if 0 < i-K else 0)\\n    \\n    # build a matrix of sliding window sums for each column of that matrix\\n    for y in range(h):\\n      grid[y][0] = sum(dp[y][0:min(w, K+1)])\\n      for i in range(1, w):\\n        grid[y][i] = grid[y][i-1] + (dp[y][K+i] if K+i < w else 0) - (dp[y][i-K-1] if 0 < i-K else 0)\\n\\n    return grid\\n```",
                "solutionTags": [],
                "code": "```\\n1  2  3    +cols    5  7  9    +rows   12 21 16\\n4  5  6    ---->   12 15 18    ---->   27 45 33\\n7  8  9            11 13 15            24 39 28\\n```\n```python\\nclass Solution:\\n  def matrixBlockSum(self, grid: List[List[int]], K: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    \\n    # build a matrix of sliding window sums for each row\\n    dp = [[0] * w for _ in range(h)]    \\n    for x in range(w):\\n      dp[0][x] = sum(row[x] for row in grid[0:min(h, K+1)])\\n      for i in range(1, h):\\n        dp[i][x] = dp[i-1][x] + (grid[K+i][x] if K+i < h else 0) - (grid[i-K-1][x] if 0 < i-K else 0)\\n    \\n    # build a matrix of sliding window sums for each column of that matrix\\n    for y in range(h):\\n      grid[y][0] = sum(dp[y][0:min(w, K+1)])\\n      for i in range(1, w):\\n        grid[y][i] = grid[y][i-1] + (dp[y][K+i] if K+i < w else 0) - (dp[y][i-K-1] if 0 < i-K else 0)\\n\\n    return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483611,
                "title": "java-with-explanation-beats-96",
                "content": "class Solution {\\n     /**\\n    Take the element iend and jend and subtract  mat[istart - 1][jend]\\n    and mat[iend][jstart - 1] elemnt from it. since mat[istart-1][jstart-1] is subtracted\\n    twice just add itt once more\\n    */\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int[][] dp = new int[mat.length][mat[0].length ];\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        //col wise addition\\n        for(int i=0; i< row; i++){\\n            for( int j =1; j < col; j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        //row wise addition\\n        for(int i=1; i< row; i++){\\n            for( int j =0; j < col; j++){\\n                mat[i][j] += mat[i-1][j];\\n            }\\n        }\\n        \\n        int istart, iend, jstart, jend;\\n        int case1 = 0, case2=0, case3=0;\\n        for(int i=0; i < row; i++){\\n            for(int j=0; j < col; j++){\\n                istart = i - K >0 ? i-K : 0;\\n                iend = i + K < row-1 ? i+K : row-1;\\n                jstart = j - K >0 ? j-K : 0;\\n                jend = j + K < col-1 ? j+K : col-1;\\n                \\n                //iend - K ith index on jth col - case1\\n                //jend - K th index on ith row - case2\\n                \\n                case1 =case2=case3=0;\\n                if(istart - 1 >= 0){\\n                    case1 = mat[istart - 1][jend];\\n                }\\n                 \\n                if(jstart - 1 >=0 ){\\n                    case2 = mat[iend][jstart - 1];\\n                }\\n                if(istart - 1 >=0 && jstart-1>=0){\\n                    case3 = mat[istart-1][jstart-1];\\n                }\\n                int jind = jstart-K >0 ? jstart - K : 0;\\n               \\n                dp[i][j]= mat[iend][jend] - case1 - case2 + case3;\\n            }\\n        }\\n        return dp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     /**\\n    Take the element iend and jend and subtract  mat[istart - 1][jend]\\n    and mat[iend][jstart - 1] elemnt from it. since mat[istart-1][jstart-1] is subtracted\\n    twice just add itt once more\\n    */\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int[][] dp = new int[mat.length][mat[0].length ];\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        //col wise addition\\n        for(int i=0; i< row; i++){\\n            for( int j =1; j < col; j++){\\n                mat[i][j] += mat[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 482820,
                "title": "matrix-block-sum-in-java",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        int [][] arr= new int[m][n];\\n        \\n        for(int i=0; i<m ; i++)\\n        { \\n            for(int j=0; j<n ;j++)\\n            {   \\n                int sum=0;\\n              \\n                 for(int r=  Math.max(0,i-K); r<=i+K  && r<m; r++)\\n               {\\n                      for(int c=  Math.max(0,j-K); c<=j+K && c<n ;c++)\\n                  {   \\n                \\n                       sum=sum+mat[r][c];\\n                        \\n                    }\\n                      \\n               }\\n                 arr[i][j]=sum;\\n        \\n    }\\n}\\n        \\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int K) {\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        int [][] arr= new int[m][n];\\n        \\n        for(int i=0; i<m ; i++)\\n        { \\n            for(int j=0; j<n ;j++)\\n            {   \\n                int sum=0;\\n              \\n                 for(int r=  Math.max(0,i-K); r<=i+K  && r<m; r++)\\n               {\\n                      for(int c=  Math.max(0,j-K); c<=j+K && c<n ;c++)\\n                  {   \\n                \\n                       sum=sum+mat[r][c];\\n                        \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 477031,
                "title": "c-2d-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        std::vector<std::vector<int>>  ret;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        std::vector<std::vector<int>> dp(m+1,std::vector<int>(n+1,0));\\n        for(int i = 1; i <= mat.size(); i++)\\n        {\\n            for(int j = 1; j <= mat[0].size(); j++)\\n            {\\n                dp[i][j] = mat[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\\n            }\\n        }\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            std::vector<int> temp;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                int rBegin = std::max(0,i - K);\\n                int rEnd = std::min(m-1,i + K);\\n                int cBegin = std::max(0,j - K);\\n                int cEnd = std::min(n - 1, j+K);\\n                int value = dp[rEnd+1][cEnd+1] - dp[rEnd+1][cBegin] - dp[rBegin][cEnd+1] + dp[rBegin][cBegin];\\n                temp.push_back(value);\\n            }\\n            ret.push_back(temp);\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        std::vector<std::vector<int>>  ret;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        std::vector<std::vector<int>> dp(m+1,std::vector<int>(n+1,0));\\n        for(int i = 1; i <= mat.size(); i++)\\n        {\\n            for(int j = 1; j <= mat[0].size(); j++)\\n            {\\n                dp[i][j] = mat[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\\n            }\\n        }\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            std::vector<int> temp;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                int rBegin = std::max(0,i - K);\\n                int rEnd = std::min(m-1,i + K);\\n                int cBegin = std::max(0,j - K);\\n                int cEnd = std::min(n - 1, j+K);\\n                int value = dp[rEnd+1][cEnd+1] - dp[rEnd+1][cBegin] - dp[rBegin][cEnd+1] + dp[rBegin][cBegin];\\n                temp.push_back(value);\\n            }\\n            ret.push_back(temp);\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515360,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[][]=new int[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                int rowS=i-k;\\n                int rowE=i+k;\\n                int colS=j-k;\\n                int colE=j+k;\\n\\n                if(rowS<0){\\n                    rowS=0;\\n                }\\n                if(rowE>=n){\\n                    rowE=n-1;\\n                }\\n\\n                if(colS<0){\\n                    colS=0;\\n                }\\n                if(colE>=m){\\n                    colE=m-1;\\n                }\\n\\n                ans[i][j]=sum(rowS,rowE,colS,colE,mat);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int sum(int rowS,int rowE,int colS,int colE,int[][] mat){\\n        int sum=0;\\n\\n        for(int i=rowS;i<=rowE;i++){\\n            for(int j=colS;j<=colE;j++){\\n                sum+=mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[][]=new int[n][m];\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\n                int rowS=i-k;\\n                int rowE=i+k;\\n                int colS=j-k;\\n                int colE=j+k;\\n\\n                if(rowS<0){\\n                    rowS=0;\\n                }\\n                if(rowE>=n){\\n                    rowE=n-1;\\n                }\\n\\n                if(colS<0){\\n                    colS=0;\\n                }\\n                if(colE>=m){\\n                    colE=m-1;\\n                }\\n\\n                ans[i][j]=sum(rowS,rowE,colS,colE,mat);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int sum(int rowS,int rowE,int colS,int colE,int[][] mat){\\n        int sum=0;\\n\\n        for(int i=rowS;i<=rowE;i++){\\n            for(int j=colS;j<=colE;j++){\\n                sum+=mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456842,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] answer = new int[mat.length][mat[0].length];\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.length) {\\n                    rowEnd = mat.length - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].length) {\\n                    colEnd = mat[0].length - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] answer = new int[mat.length][mat[0].length];\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.length) {\\n                    rowEnd = mat.length - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].length) {\\n                    colEnd = mat[0].length - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417283,
                "title": "simple-prefix-sum-with-explanation-c-python",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pref(n+1, vector<int>(m+1, 0));\\n        // Calculating prefix sum\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n                // note that while counting for [i-1][j] and [i][j-1];\\n                // pref[i-1][j-1] will be added twice. So we reduce it once.\\n                pref[i][j] = mat[i-1][j-1] + pref[i-1][j] + pref[i][j-1] - pref[i-1][j-1];\\n            }\\n        }\\n\\n        // Find the sum of the elements specified in the K-block\\n        vector<vector<int>> res(n, vector<int>(m, 0));\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                // checking for all pairs to be in bounds.\\n                int r1 = max(0, i-k);\\n                int c1 = max(0, j-k);\\n                int r2 = min(n-1, i+k);\\n                int c2 = min(m-1, j+k);\\n                // finding res[i][j] = bottom right - bottom left - top right + top left\\n                res[i][j] = pref[r2+1][c2+1] - pref[r2+1][c1] - pref[r1][c2+1] + pref[r1][c1];\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```\\nPython code for the same: \\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        pref = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                pref[i][j] = mat[i - 1][j - 1] + pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1]\\n\\n        res = [[0] * m for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                r1 = max(0, i - k)\\n                c1 = max(0, j - k)\\n                r2 = min(n - 1, i + k)\\n                c2 = min(m - 1, j + k)\\n                res[i][j] = pref[r2 + 1][c2 + 1] - pref[r2 + 1][c1] - pref[r1][c2 + 1] + pref[r1][c1]\\n\\n        return res\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n- Space complexity: $$O(n+m)$$",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pref(n+1, vector<int>(m+1, 0));\\n        // Calculating prefix sum\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n                // note that while counting for [i-1][j] and [i][j-1];\\n                // pref[i-1][j-1] will be added twice. So we reduce it once.\\n                pref[i][j] = mat[i-1][j-1] + pref[i-1][j] + pref[i][j-1] - pref[i-1][j-1];\\n            }\\n        }\\n\\n        // Find the sum of the elements specified in the K-block\\n        vector<vector<int>> res(n, vector<int>(m, 0));\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                // checking for all pairs to be in bounds.\\n                int r1 = max(0, i-k);\\n                int c1 = max(0, j-k);\\n                int r2 = min(n-1, i+k);\\n                int c2 = min(m-1, j+k);\\n                // finding res[i][j] = bottom right - bottom left - top right + top left\\n                res[i][j] = pref[r2+1][c2+1] - pref[r2+1][c1] - pref[r1][c2+1] + pref[r1][c1];\\n            }\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        pref = [[0] * (m + 1) for _ in range(n + 1)]\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                pref[i][j] = mat[i - 1][j - 1] + pref[i - 1][j] + pref[i][j - 1] - pref[i - 1][j - 1]\\n\\n        res = [[0] * m for _ in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                r1 = max(0, i - k)\\n                c1 = max(0, j - k)\\n                r2 = min(n - 1, i + k)\\n                c2 = min(m - 1, j + k)\\n                res[i][j] = pref[r2 + 1][c2 + 1] - pref[r2 + 1][c1] - pref[r1][c2 + 1] + pref[r1][c1]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697196,
                "title": "beats-96-c-t-c-o-n-m-pre-computation-prefixsum-rowcolumn",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& arr, int k) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n        vector<vector<int>> answer(n,vector<int>(m,0));\\n        \\n        //Pre-Computation (PrefixSum-Row)\\n        for(int i = 0;i<n;++i){\\n            for(int j = m-1;j>0;--j){\\n                arr[i][j-1]+=arr[i][j];\\n            }\\n        }\\n        //Pre-Computation (PrefixSum-RowCol)\\n        for(int i = 0;i<m;++i){\\n            for(int j = n-1;j>0;--j){\\n                arr[j-1][i]+=arr[j][i];\\n            }\\n        }\\n\\n        //Answer\\n        for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < m; ++j)\\n        {\\n            int p = max(0, i - k);\\n            int q = max(0, j - k);\\n            answer[i][j] = arr[p][q];\\n            if (j + k + 1 < m)\\n            {\\n                answer[i][j] -= arr[p][j + k + 1];\\n            }\\n            if (i + k + 1 < n)\\n            {\\n                if (j + k + 1 < m)\\n                {\\n                    answer[i][j] -= (arr[i + k + 1][q] - arr[i + k + 1][j + k + 1]);\\n                }\\n                else\\n                {\\n                    answer[i][j] -= arr[i + k + 1][q];\\n                }\\n            }\\n        }\\n    }\\n    return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& arr, int k) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n        vector<vector<int>> answer(n,vector<int>(m,0));\\n        \\n        //Pre-Computation (PrefixSum-Row)\\n        for(int i = 0;i<n;++i){\\n            for(int j = m-1;j>0;--j){\\n                arr[i][j-1]+=arr[i][j];\\n            }\\n        }\\n        //Pre-Computation (PrefixSum-RowCol)\\n        for(int i = 0;i<m;++i){\\n            for(int j = n-1;j>0;--j){\\n                arr[j-1][i]+=arr[j][i];\\n            }\\n        }\\n\\n        //Answer\\n        for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < m; ++j)\\n        {\\n            int p = max(0, i - k);\\n            int q = max(0, j - k);\\n            answer[i][j] = arr[p][q];\\n            if (j + k + 1 < m)\\n            {\\n                answer[i][j] -= arr[p][j + k + 1];\\n            }\\n            if (i + k + 1 < n)\\n            {\\n                if (j + k + 1 < m)\\n                {\\n                    answer[i][j] -= (arr[i + k + 1][q] - arr[i + k + 1][j + k + 1]);\\n                }\\n                else\\n                {\\n                    answer[i][j] -= arr[i + k + 1][q];\\n                }\\n            }\\n        }\\n    }\\n    return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697161,
                "title": "c-prefix-sum-too-easy-solution",
                "content": "[**1314. Matrix Block Sum**](https://leetcode.com/problems/matrix-block-sum/)\\n\\n**`Time Complexity : O(m*n)`**\\n**`Space Complexity : O(m*n)`**\\n\\n```\\n\\t vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>>v(m+1, vector<int>(n+1));\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                v[i+1][j+1]=mat[i][j]+v[i+1][j]+v[i][j+1]-v[i][j];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n;j++){\\n                int r1=i-k<0?0:i-k;\\n                int r2=i+k>=m?m-1:i+k;\\n                int c1=j-k<0?0:j-k;\\n                int c2=j+k>=n?n-1:j+k;\\n                mat[i][j]=v[r2+1][c2+1]-v[r1][c2+1]-v[r2+1][c1]+v[r1][c1];\\n            }\\n        }\\n        return mat;\\n    }\\n```\\n***Happy Coding :)***\\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>>v(m+1, vector<int>(n+1));\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                v[i+1][j+1]=mat[i][j]+v[i+1][j]+v[i][j+1]-v[i][j];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n;j++){\\n                int r1=i-k<0?0:i-k;\\n                int r2=i+k>=m?m-1:i+k;\\n                int c1=j-k<0?0:j-k;\\n                int c2=j+k>=n?n-1:j+k;\\n                mat[i][j]=v[r2+1][c2+1]-v[r1][c2+1]-v[r2+1][c1]+v[r1][c1];\\n            }\\n        }\\n        return mat;\\n    }\\n```\n```\\nif(liked(\\u2764\\uFE0F)==true) Upvote(\\u2B06\\uFE0F);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn Thank You\\uD83D\\uDE01;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651950,
                "title": "brute-force-matrix-block-sum-better-than-20-submission-java",
                "content": "class Solution {\\n    \\n    public int helper(int[][] mat, int x, int y, int k){\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i<mat.length; i++){\\n            \\n            for(int j = 0; j<mat[0].length; j++){\\n                \\n                if(x-k <= i && i <= x+k && y-k <= j && j <= y+k){\\n                    sum += mat[i][j];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        \\n        int[][] ans = new int[mat.length][mat[0].length];\\n        \\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                ans[i][j] = helper(mat, i, j, k);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int helper(int[][] mat, int x, int y, int k){\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i<mat.length; i++){\\n            \\n            for(int j = 0; j<mat[0].length; j++){\\n                \\n                if(x-k <= i && i <= x+k && y-k <= j && j <= y+k){\\n                    sum += mat[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2642852,
                "title": "python3-solved-using-prefix-sum",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(m^2*n)\\n    #Space-Complexity: O(m*n)\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        prefix_sum = [[None for _ in range(n)] for z in range(m)]\\n        for a in range(m):\\n            prefix_sum[a][0] = mat[a][0]\\n        #for each row, initialize the prefix sum!\\n        for i in range(0, m, 1):\\n            for j in range(1, n, 1):\\n                prefix_sum[i][j] = prefix_sum[i][j-1] + mat[i][j]\\n        #now, for each entry of mat (r,c), we need to get sum of all elements in (r- k) <= row <= r + k\\n        #and columns s.t. c - k <= col <= c + k!\\n        \\n        #we have to not consider rows that are out of bounds!\\n        ans = [[-100 for _ in range(n)] for _ in range(m)]\\n        #we will fill up this answer as we go!\\n        \\n        for r in range(m):\\n            for j in range(n):\\n                #for the current ans[r][j] entry we are answering for, we can compute the\\n                #lowest and highest in-bounds value for row-wise and column-wise!\\n                lr, hr = max(0, r - k), min(r + k, m - 1)\\n                lc, hc = max(0, j - k), min(j + k, n - 1)\\n                total = 0 \\n                for row in range(lr, hr + 1):\\n                    subtraction = None\\n                    if(lc == 0):\\n                        subtraction = 0\\n                    else:\\n                        subtraction = prefix_sum[row][lc-1]\\n                    sub_sum = prefix_sum[row][hc] - subtraction\\n                    total += sub_sum\\n                ans[r][j] = total\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(m^2*n)\\n    #Space-Complexity: O(m*n)\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        prefix_sum = [[None for _ in range(n)] for z in range(m)]\\n        for a in range(m):\\n            prefix_sum[a][0] = mat[a][0]\\n        #for each row, initialize the prefix sum!\\n        for i in range(0, m, 1):\\n            for j in range(1, n, 1):\\n                prefix_sum[i][j] = prefix_sum[i][j-1] + mat[i][j]\\n        #now, for each entry of mat (r,c), we need to get sum of all elements in (r- k) <= row <= r + k\\n        #and columns s.t. c - k <= col <= c + k!\\n        \\n        #we have to not consider rows that are out of bounds!\\n        ans = [[-100 for _ in range(n)] for _ in range(m)]\\n        #we will fill up this answer as we go!\\n        \\n        for r in range(m):\\n            for j in range(n):\\n                #for the current ans[r][j] entry we are answering for, we can compute the\\n                #lowest and highest in-bounds value for row-wise and column-wise!\\n                lr, hr = max(0, r - k), min(r + k, m - 1)\\n                lc, hc = max(0, j - k), min(j + k, n - 1)\\n                total = 0 \\n                for row in range(lr, hr + 1):\\n                    subtraction = None\\n                    if(lc == 0):\\n                        subtraction = 0\\n                    else:\\n                        subtraction = prefix_sum[row][lc-1]\\n                    sub_sum = prefix_sum[row][hc] - subtraction\\n                    total += sub_sum\\n                ans[r][j] = total\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2495663,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn matrix_block_sum(mat: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let n = mat.len();\\n        let m = mat[0].len();\\n        let k = k as usize;\\n        let mut memo = vec![vec![0;m+1];n+1];\\n        for i in 0..n {\\n            for j in 0..m {\\n                memo[i+1][j+1] = memo[i+1][j] + memo[i][j+1] - memo[i][j] + mat[i][j];\\n            }\\n        }\\n        \\n        let mut result = vec![vec![0;m];n];\\n        for i in 0..n {\\n            for j in 0..m {\\n                let i_min = i.saturating_sub(k);\\n                let i_max = std::cmp::min(i+k, n-1);\\n                let j_min = j.saturating_sub(k);\\n                let j_max = std::cmp::min(j+k, m-1);\\n\\n                result[i][j] = memo[i_max+1][j_max+1] - memo[i_max+1][j_min]\\n                    - memo[i_min][j_max+1] + memo[i_min][j_min];\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn matrix_block_sum(mat: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n        let n = mat.len();\\n        let m = mat[0].len();\\n        let k = k as usize;\\n        let mut memo = vec![vec![0;m+1];n+1];\\n        for i in 0..n {\\n            for j in 0..m {\\n                memo[i+1][j+1] = memo[i+1][j] + memo[i][j+1] - memo[i][j] + mat[i][j];\\n            }\\n        }\\n        \\n        let mut result = vec![vec![0;m];n];\\n        for i in 0..n {\\n            for j in 0..m {\\n                let i_min = i.saturating_sub(k);\\n                let i_max = std::cmp::min(i+k, n-1);\\n                let j_min = j.saturating_sub(k);\\n                let j_max = std::cmp::min(j+k, m-1);\\n\\n                result[i][j] = memo[i_max+1][j_max+1] - memo[i_max+1][j_min]\\n                    - memo[i_min][j_max+1] + memo[i_min][j_min];\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485584,
                "title": "inclusion-exclusion-principle",
                "content": "Hi, Are there other similar questions involving Inclusion Exclusion principle? I found Range Sum 2d, 1d similar too.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2463288,
                "title": "python3-matrix-block-sum-using-simple-for-loops",
                "content": "class Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                r2=min(i+k,m-1)\\n                r1=max(i-k,0)\\n                c2=min(j+k,n-1)\\n                c1=max(j-k,0)\\n                sum1=0\\n                for z in range(r1,r2+1):\\n                    sum1=sum1+sum(mat[z][c1:c2+1])      \\n                res[i][j]=sum1\\n        return (res)",
                "solutionTags": [],
                "code": "class Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        res = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                r2=min(i+k,m-1)\\n                r1=max(i-k,0)\\n                c2=min(j+k,n-1)\\n                c1=max(j-k,0)\\n                sum1=0\\n                for z in range(r1,r2+1):\\n                    sum1=sum1+sum(mat[z][c1:c2+1])      \\n                res[i][j]=sum1\\n        return (res)",
                "codeTag": "Java"
            },
            {
                "id": 2442879,
                "title": "c-prefix-sum-tc-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                mat[i][j]=mat[i][j]+mat[i-1][j];\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                int row_s = i-k;\\n                int col_s = j-k;\\n                int row_e = i+k;\\n                int col_e = j+k;\\n                \\n                if(row_e>=m) row_e=m-1;\\n                if(col_e>=n) col_e=n-1;\\n                \\n                int tot = mat[row_e][col_e];\\n                \\n                int temp = 0;\\n                \\n                if(row_s-1>=0){\\n                    temp+=mat[row_s-1][col_e];\\n                } \\n                if(col_s-1>=0){\\n                    temp+=mat[row_e][col_s-1];\\n                }\\n                if(row_s-1>=0 && col_s-1>=0) {\\n                    temp-=mat[row_s-1][col_s-1];\\n                }\\n                \\n                tot = tot-temp;\\n                \\n                ans[i][j]=tot;\\n            }\\n        }\\n        \\n        // for(int i=0;i<m;i++) {\\n        //     for(int j=0;j<n;j++) {\\n        //         cout<<ans[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                mat[i][j]=mat[i][j]+mat[i-1][j];\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>>ans(m,vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                int row_s = i-k;\\n                int col_s = j-k;\\n                int row_e = i+k;\\n                int col_e = j+k;\\n                \\n                if(row_e>=m) row_e=m-1;\\n                if(col_e>=n) col_e=n-1;\\n                \\n                int tot = mat[row_e][col_e];\\n                \\n                int temp = 0;\\n                \\n                if(row_s-1>=0){\\n                    temp+=mat[row_s-1][col_e];\\n                } \\n                if(col_s-1>=0){\\n                    temp+=mat[row_e][col_s-1];\\n                }\\n                if(row_s-1>=0 && col_s-1>=0) {\\n                    temp-=mat[row_s-1][col_s-1];\\n                }\\n                \\n                tot = tot-temp;\\n                \\n                ans[i][j]=tot;\\n            }\\n        }\\n        \\n        // for(int i=0;i<m;i++) {\\n        //     for(int j=0;j<n;j++) {\\n        //         cout<<ans[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2427295,
                "title": "easy-to-understand-solution-c",
                "content": "**Intuition:** Here sum matrix is used to find out the sum of all the elements in the previous rows including current row and all previous column elements including current column. \\nThen what I do in the second for loop is that I actually add the entry for that cell in sum matrix and then subtract the sum of the out of range rows above the current cell and then again subtract the sum of out of range columns to the left of the current cell. Since the common part of these 2 subtracted parts is getting subtracted twice, we add it again. \\nTime complexity: O(mn) \\nSpace Complexity: O(mn) (for sum matrix)\\nwhere m and n are the row size and column size of the matrix given.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> sum(m,vector<int> (n,0)),ans(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                sum[i][j]=mat[i][j];\\n                if(i-1>=0) sum[i][j]+=sum[i-1][j];\\n                if(j-1>=0) sum[i][j]+=sum[i][j-1];\\n                if(i-1>=0 && j-1>=0) sum[i][j]-=sum[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int temp=0;\\n                temp+=sum[min(i+k,m-1)][min(j+k,n-1)];\\n                if(j-k-1>=0) temp-=sum[min(i+k,m-1)][j-k-1];\\n                if(i-k-1>=0) temp-=sum[max(i-k-1,0)][min(j+k,n-1)];\\n                if(i-k-1>=0 && j-k-1>=0) temp+=sum[max(i-k-1,0)][max(j-k-1,0)];\\n                ans[i][j]=temp;\\n            }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you this helped you!",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<int>> sum(m,vector<int> (n,0)),ans(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                sum[i][j]=mat[i][j];\\n                if(i-1>=0) sum[i][j]+=sum[i-1][j];\\n                if(j-1>=0) sum[i][j]+=sum[i][j-1];\\n                if(i-1>=0 && j-1>=0) sum[i][j]-=sum[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                int temp=0;\\n                temp+=sum[min(i+k,m-1)][min(j+k,n-1)];\\n                if(j-k-1>=0) temp-=sum[min(i+k,m-1)][j-k-1];\\n                if(i-k-1>=0) temp-=sum[max(i-k-1,0)][min(j+k,n-1)];\\n                if(i-k-1>=0 && j-k-1>=0) temp+=sum[max(i-k-1,0)][max(j-k-1,0)];\\n                ans[i][j]=temp;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397613,
                "title": "c-bruteforce",
                "content": "![image](https://assets.leetcode.com/users/images/11a8fb2c-9246-4c42-8e8a-f168278c72f7_1659957737.559068.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\tint m=mat.size();\\n\\t\\t\\tint n=mat[0].size();\\n\\t\\t\\tvector<vector<int>>grid(m,vector<int>(n,0));\\n\\t\\t\\tfor(int r=0;r<m;r++){\\n\\t\\t\\t\\tfor(int c=0;c<n;c++){\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\tfor(int i=max(r-k,0);i<=min(r+k,m-1);i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=max(c-k,0);j<=min(c+k,n-1);j++){\\n\\t\\t\\t\\t\\t\\t\\tsum+=mat[i][j];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgrid[r][c]=sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn grid;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\tint m=mat.size();\\n\\t\\t\\tint n=mat[0].size();\\n\\t\\t\\tvector<vector<int>>grid(m,vector<int>(n,0));\\n\\t\\t\\tfor(int r=0;r<m;r++){\\n\\t\\t\\t\\tfor(int c=0;c<n;c++){\\n\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\tfor(int i=max(r-k,0);i<=min(r+k,m-1);i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=max(c-k,0);j<=min(c+k,n-1);j++){\\n\\t\\t\\t\\t\\t\\t\\tsum+=mat[i][j];\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2350180,
                "title": "c-o-n-m-optimized-clean-code-prefixsum",
                "content": "***If you understood the solution, Please upvote the solution***\\n\\nIdea : Based on Inclusion, Exclusion and Prefix Sum\\nFirst creating a prefix sum matrix which is named as ```grid``` in the code, ```grid[i][j]``` represents the sum of every element till i and j in the initial matrix.\\n\\nNow creating a answer matrix, each element of this will be calculated as\\n1. The sum of the maximum index possible, ie ``` maxRow=min(i+k,n-1),maxCol=min(j+k,m-1) ```\\n2. The difference of ```i-k-1,maxCol``` index, if it is valid\\n3. The difference of ```maxRow,j-k-1``` index, if it is valid\\n4. And the addition of ```i-k-1,j-k-1``` index, as from step 2 and 3 this was subtracted twice and we alredy had one of these from step 1, so now our answer is less by  ```i-k-1,j-k-1``` index, therefore adding it to balance\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(),m=mat[0].size();\\n        \\n        vector<vector<int>>grid(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int minus=(i-1>=0 && j-1>=0)?grid[i-1][j-1]:0;\\n                int add1=(i-1>=0)?grid[i-1][j]:0;\\n                int add2=(j-1>=0)?grid[i][j-1]:0;\\n                grid[i][j]=mat[i][j]+add1+add2-minus;\\n            }\\n        }\\n        \\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int maxRow=min(i+k,n-1),maxCol=min(j+k,m-1);\\n                int base=grid[maxRow][maxCol];\\n                base-=(i-k-1>=0)?grid[i-k-1][maxCol]:0;\\n                base-=(j-k-1>=0)?grid[maxRow][j-k-1]:0;\\n                base+=(i-k-1>=0 && j-k-1>=0)?grid[i-k-1][j-k-1]:0;\\n                ans[i][j]=base;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```grid```\n```grid[i][j]```\n``` maxRow=min(i+k,n-1),maxCol=min(j+k,m-1) ```\n```i-k-1,maxCol```\n```maxRow,j-k-1```\n```i-k-1,j-k-1```\n```i-k-1,j-k-1```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(),m=mat[0].size();\\n        \\n        vector<vector<int>>grid(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int minus=(i-1>=0 && j-1>=0)?grid[i-1][j-1]:0;\\n                int add1=(i-1>=0)?grid[i-1][j]:0;\\n                int add2=(j-1>=0)?grid[i][j-1]:0;\\n                grid[i][j]=mat[i][j]+add1+add2-minus;\\n            }\\n        }\\n        \\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int maxRow=min(i+k,n-1),maxCol=min(j+k,m-1);\\n                int base=grid[maxRow][maxCol];\\n                base-=(i-k-1>=0)?grid[i-k-1][maxCol]:0;\\n                base-=(j-k-1>=0)?grid[maxRow][j-k-1]:0;\\n                base+=(i-k-1>=0 && j-k-1>=0)?grid[i-k-1][j-k-1]:0;\\n                ans[i][j]=base;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292090,
                "title": "my-java-solution",
                "content": "```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n        int i = mat.length, j = mat[0].length;\\n        int[][] answer = new int[i][j];\\n        int rLowerBound, rUpperBound, r;\\n        int cLowerBound, cUpperBound, c;\\n        int num;\\n\\n        for (r = 0; r < i; r++) {\\n            for (c = 0; c < j; c++) {\\n                rLowerBound = r - k;\\n                rUpperBound = r + k;\\n                rLowerBound = Math.max(rLowerBound, 0);\\n                rUpperBound = Math.min(rUpperBound, i - 1);\\n\\n                cLowerBound = c - k;\\n                cUpperBound = c + k;\\n                cLowerBound = Math.max(cLowerBound, 0);\\n                cUpperBound = Math.min(cUpperBound, j - 1);\\n\\n                num = 0;\\n                for (int indexR = rLowerBound; indexR <= rUpperBound; indexR++) {\\n                    for (int indexC = cLowerBound; indexC <= cUpperBound; indexC++) {\\n                        num += mat[indexR][indexC];\\n                    }\\n                }\\n\\n                answer[r][c] = num;\\n            }\\n        }\\n        return answer;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n        int i = mat.length, j = mat[0].length;\\n        int[][] answer = new int[i][j];\\n        int rLowerBound, rUpperBound, r;\\n        int cLowerBound, cUpperBound, c;\\n        int num;\\n\\n        for (r = 0; r < i; r++) {\\n            for (c = 0; c < j; c++) {\\n                rLowerBound = r - k;\\n                rUpperBound = r + k;\\n                rLowerBound = Math.max(rLowerBound, 0);\\n                rUpperBound = Math.min(rUpperBound, i - 1);\\n\\n                cLowerBound = c - k;\\n                cUpperBound = c + k;\\n                cLowerBound = Math.max(cLowerBound, 0);\\n                cUpperBound = Math.min(cUpperBound, j - 1);\\n\\n                num = 0;\\n                for (int indexR = rLowerBound; indexR <= rUpperBound; indexR++) {\\n                    for (int indexC = cLowerBound; indexC <= cUpperBound; indexC++) {\\n                        num += mat[indexR][indexC];\\n                    }\\n                }\\n\\n                answer[r][c] = num;\\n            }\\n        }\\n        return answer;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2281598,
                "title": "c-prefix-sum-time-o-m-n",
                "content": "This question is very similar to **[304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/matrix-block-sum/)**. I don\\'t kown how to solve the **Prefix Sum** questions at first. But when I meet some of them. I get two ideas about this kind of problems.\\n\\n * If the question asks we to do something form the edges (the front or back of an array, the leaves or head of a tree, the edges of a matrix...), we could consider to do it with prefix sum.\\n * If the question asks we to get something continous especially sum, we could consider prefix sum because we could use subtraction to get all continous sum.\\n * ...\\n\\nThis is my ideas. I am working hard to learn it, too. So if you have other idea or if I have any wrong, welcome to talk and point out!\\n\\nMy full code is as follows:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> dp(m, vector<int> (n, 0));\\n        for(int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                mat[i][j] += (i == 0 ? 0 : mat[i - 1][j]) + (j == 0 ? 0 : mat[i][j - 1]) - (i == 0 || j == 0 ? 0 : mat[i - 1][j - 1]);\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int r1 = i - k > 0 ? i - k - 1 : -1;\\n                int r2 = i + k < m ? i + k : m - 1;\\n                int c1 = j - k > 0 ? j - k - 1 : -1;\\n                int c2 = j + k < n ? j + k : n - 1;\\n                dp[i][j] = mat[r2][c2] - (c1 == -1 ? 0 : mat[r2][c1]) - (r1 == -1 ? 0 : mat[r1][c2]) + (r1 == -1 || c1 == -1 ? 0 : mat[r1][c1]);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```\\n\\nTime complexity:  O(m\\\\*n)\\nSpace complexity:  O(m\\\\*n)\\n\\n**PLEASE UPVOTE IF HOPEFUL TO YOU, THANKS!!!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> dp(m, vector<int> (n, 0));\\n        for(int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                mat[i][j] += (i == 0 ? 0 : mat[i - 1][j]) + (j == 0 ? 0 : mat[i][j - 1]) - (i == 0 || j == 0 ? 0 : mat[i - 1][j - 1]);\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int r1 = i - k > 0 ? i - k - 1 : -1;\\n                int r2 = i + k < m ? i + k : m - 1;\\n                int c1 = j - k > 0 ? j - k - 1 : -1;\\n                int c2 = j + k < n ? j + k : n - 1;\\n                dp[i][j] = mat[r2][c2] - (c1 == -1 ? 0 : mat[r2][c1]) - (r1 == -1 ? 0 : mat[r1][c2]) + (r1 == -1 || c1 == -1 ? 0 : mat[r1][c1]);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248821,
                "title": "easy-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size()-1, n=mat[0].size()-1;\\n        vector<vector<int>> sum_vector(m+1, vector<int>(n+1,0));\\n        \\n        for(int i=0; i<=m; ++i){\\n            int row = 0;\\n            for(int j=0; j<=n; ++j){\\n                row += mat[i][j];\\n                if(i!=0)    sum_vector[i][j] = sum_vector[i-1][j];\\n                sum_vector[i][j] += row;\\n            }\\n        }\\n        \\n        int rstart, rend, cstart, cend;\\n        \\n        for(int i=0; i<=m; ++i)\\n            for(int j=0; j<=n; ++j){\\n                \\n                rstart=i-k, rend=i+k, cstart=j-k, cend=j+k;\\n                \\n                if(rstart<0) rstart=0;\\n                if(rend>m) rend=m;\\n                if(cstart<0) cstart=0;\\n                if(cend>n) cend=n;\\n                \\n                if(rstart==0 and cstart==0) mat[i][j] = sum_vector[rend][cend];\\n                else if(rstart==0) mat[i][j] = sum_vector[rend][cend] - sum_vector[rend][cstart-1];\\n                else if(cstart==0) mat[i][j] = sum_vector[rend][cend] - sum_vector[rstart-1][cend];\\n                else mat[i][j] = sum_vector[rend][cend]\\n                                  - sum_vector[rend][cstart-1] \\n                                  - sum_vector[rstart-1][cend]\\n                                  + sum_vector[rstart-1][cstart-1];\\n            }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size()-1, n=mat[0].size()-1;\\n        vector<vector<int>> sum_vector(m+1, vector<int>(n+1,0));\\n        \\n        for(int i=0; i<=m; ++i){\\n            int row = 0;\\n            for(int j=0; j<=n; ++j){\\n                row += mat[i][j];\\n                if(i!=0)    sum_vector[i][j] = sum_vector[i-1][j];\\n                sum_vector[i][j] += row;\\n            }\\n        }\\n        \\n        int rstart, rend, cstart, cend;\\n        \\n        for(int i=0; i<=m; ++i)\\n            for(int j=0; j<=n; ++j){\\n                \\n                rstart=i-k, rend=i+k, cstart=j-k, cend=j+k;\\n                \\n                if(rstart<0) rstart=0;\\n                if(rend>m) rend=m;\\n                if(cstart<0) cstart=0;\\n                if(cend>n) cend=n;\\n                \\n                if(rstart==0 and cstart==0) mat[i][j] = sum_vector[rend][cend];\\n                else if(rstart==0) mat[i][j] = sum_vector[rend][cend] - sum_vector[rend][cstart-1];\\n                else if(cstart==0) mat[i][j] = sum_vector[rend][cend] - sum_vector[rstart-1][cend];\\n                else mat[i][j] = sum_vector[rend][cend]\\n                                  - sum_vector[rend][cstart-1] \\n                                  - sum_vector[rstart-1][cend]\\n                                  + sum_vector[rstart-1][cstart-1];\\n            }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236760,
                "title": "c-easy-dp-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        if(n==1 && n==m)\\n            return mat;\\n        \\n        vector<vector<int> > ans(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n                mat[i][j] += mat[i][j-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int x = i>k?i-k:0;\\n                int y = i+k<n?i+k:n-1;\\n                for(int q=x;q<=y;q++)\\n                {\\n                    if(j<=k && j+k>=m)\\n                        ans[i][j] += mat[q][m-1];\\n                    else if(j<=k && j+k<m)\\n                        ans[i][j] += mat[q][j+k];\\n                    else if(j>k && j+k<m)\\n                        ans[i][j] += mat[q][j+k]-mat[q][j-k-1];\\n                    else if(j>k && j+k>=m)\\n                        ans[i][j] += mat[q][m-1]-mat[q][j-k-1];\\n                        \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        if(n==1 && n==m)\\n            return mat;\\n        \\n        vector<vector<int> > ans(n,vector<int> (m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n                mat[i][j] += mat[i][j-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int x = i>k?i-k:0;\\n                int y = i+k<n?i+k:n-1;\\n                for(int q=x;q<=y;q++)\\n                {\\n                    if(j<=k && j+k>=m)\\n                        ans[i][j] += mat[q][m-1];\\n                    else if(j<=k && j+k<m)\\n                        ans[i][j] += mat[q][j+k];\\n                    else if(j>k && j+k<m)\\n                        ans[i][j] += mat[q][j+k]-mat[q][j-k-1];\\n                    else if(j>k && j+k>=m)\\n                        ans[i][j] += mat[q][m-1]-mat[q][j-k-1];\\n                        \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200931,
                "title": "python-slow-but-intuitive-solution",
                "content": "**\\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F Up Vote If You Like My Answers \\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F**\\n\\nWhen in an interview, it helps to start with a line of though and not rush into making it optimized at the first time.\\n\\nThis is my **slow** solution just to help people who need the first concept.\\n\\nThe idea is to check each row that is ```i-k <= row <= i+k``` and sum the element in the range ``` j-k:<= col <= j+k```.\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        ans = []\\n        for i in range(len(mat)):\\n            temp_row = []\\n            for j in range(len(mat[0])):           \\n                i_start = max(i-k,0)\\n                i_end = min(i+k,len(mat)-1)\\n                j_start = max(j-k,0)\\n                j_end = min(j+k,len(mat)-1)\\n                temp = 0\\n                while i_start<=i_end:\\n                    temp += sum(mat[i_start][j_start:j_end+1])\\n                    i_start += 1\\n                temp_row.append(temp)\\n            ans.append(temp_row)\\n        return ans\\n\\n```",
                "solutionTags": [],
                "code": "```i-k <= row <= i+k```\n``` j-k:<= col <= j+k```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        ans = []\\n        for i in range(len(mat)):\\n            temp_row = []\\n            for j in range(len(mat[0])):           \\n                i_start = max(i-k,0)\\n                i_end = min(i+k,len(mat)-1)\\n                j_start = max(j-k,0)\\n                j_end = min(j+k,len(mat)-1)\\n                temp = 0\\n                while i_start<=i_end:\\n                    temp += sum(mat[i_start][j_start:j_end+1])\\n                    i_start += 1\\n                temp_row.append(temp)\\n            ans.append(temp_row)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176131,
                "title": "prefix-sum-simple-solution-c",
                "content": "No need to explain dry run once you will surely understand the solution\\n\\n**Upvote if you understood**\\n```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        vector<vector<int>> sum(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                sum[i][j]=mat[i-1][j-1]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int si=(i-k<0)?0:i-k;\\n                int sj=(j-k<0)?0:j-k;\\n                \\n                int ei=(i+k>=m)?m-1:i+k;\\n                int ej=(j+k>=n)?n-1:j+k;\\n                si++,sj++,ei++,ej++;\\n                ans[i][j]=sum[ei][ej]-sum[si-1][ej]-sum[ei][sj-1]+sum[si-1][sj-1];\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n,0));\\n        vector<vector<int>> sum(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                sum[i][j]=mat[i-1][j-1]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int si=(i-k<0)?0:i-k;\\n                int sj=(j-k<0)?0:j-k;\\n                \\n                int ei=(i+k>=m)?m-1:i+k;\\n                int ej=(j+k>=n)?n-1:j+k;\\n                si++,sj++,ei++,ej++;\\n                ans[i][j]=sum[ei][ej]-sum[si-1][ej]-sum[ei][sj-1]+sum[si-1][sj-1];\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2118428,
                "title": "matrix-block-sum-java-prefix-sum-range-sum-2d-logic",
                "content": "#### **Matrix Block Sum**\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        \\n        int n = mat.length, m = mat[0].length, r1, c1, r2, c2;\\n        int[][] preSum = new int[n+1][m+1];\\n        for (int i=1; i<=n; i++) {\\n            for (int j=1; j<=m; j++) {\\n                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + mat[i-1][j-1] - preSum[i-1][j-1];\\n            }\\n        }\\n        \\n        int[][] result = new int[n][m];\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                r1 = Math.max(i-k, 0);\\n                c1 = Math.max(j-k, 0);\\n                r2 = Math.min(i+k, n-1);\\n                c2 = Math.min(j+k, m-1);\\n                result[i][j] = preSum[r2+1][c2+1] - preSum[r1][c2+1] - preSum[r2+1][c1] + preSum[r1][c1]; \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        \\n        int n = mat.length, m = mat[0].length, r1, c1, r2, c2;\\n        int[][] preSum = new int[n+1][m+1];\\n        for (int i=1; i<=n; i++) {\\n            for (int j=1; j<=m; j++) {\\n                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + mat[i-1][j-1] - preSum[i-1][j-1];\\n            }\\n        }\\n        \\n        int[][] result = new int[n][m];\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                r1 = Math.max(i-k, 0);\\n                c1 = Math.max(j-k, 0);\\n                r2 = Math.min(i+k, n-1);\\n                c2 = Math.min(j+k, m-1);\\n                result[i][j] = preSum[r2+1][c2+1] - preSum[r1][c2+1] - preSum[r2+1][c1] + preSum[r1][c1]; \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051995,
                "title": "python-o-mn-2-pass-sliding-window-98",
                "content": "https://leetcode.com/submissions/detail/702345541/\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        s1 = [[0 for j in range(n)] for i in range(m)]\\n        s2 = [[0 for j in range(n)] for i in range(m)]\\n        # For each row, do a sliding window summing: add the value that \"comes into window\"\\n\\t\\t# and subtract the value \"going out of the window\".\\n        for i in range(m):\\n            x = sum(mat[i][0:k])\\n            for j in range(n):\\n                if j + k < n:\\n                    x += mat[i][j+k]\\n                if j - k - 1 >= 0:\\n                    x -= mat[i][j-k-1]\\n                s1[i][j] = x\\n        # Now do the same in columns\\n        for j in range(n):\\n            x = sum(s1[z][j] for z in range(min(m, k)))\\n            for i in range(m):\\n                if i + k < m:\\n                    x += s1[i+k][j]\\n                if i - k - 1 >= 0:\\n                    x -= s1[i-k-1][j]\\n                s2[i][j] = x\\n        return s2\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        s1 = [[0 for j in range(n)] for i in range(m)]\\n        s2 = [[0 for j in range(n)] for i in range(m)]\\n        # For each row, do a sliding window summing: add the value that \"comes into window\"\\n\\t\\t# and subtract the value \"going out of the window\".\\n        for i in range(m):\\n            x = sum(mat[i][0:k])\\n            for j in range(n):\\n                if j + k < n:\\n                    x += mat[i][j+k]\\n                if j - k - 1 >= 0:\\n                    x -= mat[i][j-k-1]\\n                s1[i][j] = x\\n        # Now do the same in columns\\n        for j in range(n):\\n            x = sum(s1[z][j] for z in range(min(m, k)))\\n            for i in range(m):\\n                if i + k < m:\\n                    x += s1[i+k][j]\\n                if i - k - 1 >= 0:\\n                    x -= s1[i-k-1][j]\\n                s2[i][j] = x\\n        return s2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026877,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] prefix, int k) {\\n        int m = prefix.length;\\n        int n = prefix[0].length;\\n        for (int i = 1; i < n;i++) prefix[0][i] += prefix[0][i-1];\\n        for (int i = 1; i < m; i++){\\n            prefix[i][0] += prefix[i-1][0];\\n            for (int j = 1; j < n;j++) prefix[i][j] += prefix[i-1][j] + prefix[i][j -1] - prefix[i-1][j-1];\\n        }int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int ar = Math.min(i + k, m - 1);\\n                int ac = Math.min(j + k, n - 1);\\n                int ir = i - k - 1;\\n                int ic = j - k - 1;\\n                int m1 = ir >= 0? prefix[ir][ac] : 0;\\n                int m2 = ic >= 0? prefix[ar][ic] : 0;\\n                int a1 = ir >= 0 && ic >= 0? prefix[ir][ic] : 0;\\n                res[i][j] += prefix[ar][ac] - m1 - m2 + a1;        \\n            }\\n        }return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] prefix, int k) {\\n        int m = prefix.length;\\n        int n = prefix[0].length;\\n        for (int i = 1; i < n;i++) prefix[0][i] += prefix[0][i-1];\\n        for (int i = 1; i < m; i++){\\n            prefix[i][0] += prefix[i-1][0];\\n            for (int j = 1; j < n;j++) prefix[i][j] += prefix[i-1][j] + prefix[i][j -1] - prefix[i-1][j-1];\\n        }int[][] res = new int[m][n];\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                int ar = Math.min(i + k, m - 1);\\n                int ac = Math.min(j + k, n - 1);\\n                int ir = i - k - 1;\\n                int ic = j - k - 1;\\n                int m1 = ir >= 0? prefix[ir][ac] : 0;\\n                int m2 = ic >= 0? prefix[ar][ic] : 0;\\n                int a1 = ir >= 0 && ic >= 0? prefix[ir][ic] : 0;\\n                res[i][j] += prefix[ar][ac] - m1 - m2 + a1;        \\n            }\\n        }return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977955,
                "title": "c-easy-solution-naive-optimal",
                "content": "**NAIVE**\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\t   int r=mat.size(),c=mat[0].size();\\n\\t\\t\\t\\t\\tvector<vector<int>> ans(r,vector<int>(c,0));\\n\\t\\t\\t  for(int i=0;i<r;i++){\\n\\t\\t\\t\\t  for(int j=0;j<c;j++){\\n\\t\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\t  for(int i1=i-k;i1<=i+k;i1++){\\n\\t\\t\\t\\t\\t\\t  if(i1>=0 && i1<r){\\n\\t\\t\\t\\t\\t\\t  for(int j1=j-k;j1<=j+k;j1++){\\n\\t\\t\\t\\t\\t\\t\\t   if(j1>=0 && j1<c){\\n\\t\\t\\t\\t\\t\\t\\t\\t   sum+=mat[i1][j1];\\n\\t\\t\\t\\t\\t\\t\\t   }    \\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  ans[i][j]=sum;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t  }\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\n\\t\\n **OPTIMAL**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\t   int r=mat.size(),c=mat[0].size();\\n\\t\\t\\t   vector<vector<int>> dp(r,vector<int>(c,0));\\n\\n\\t\\t\\t //filling dp matrix\\n\\t\\t\\t for(int i=0;i<r;i++){\\n\\t\\t\\t\\t for(int j=0;j<c;j++){\\n\\t\\t\\t\\t\\t  if(i==0 or j==0){\\n\\t\\t\\t\\t\\t\\t   if(i==0 && j==0) dp[i][j]=mat[i][j];\\n\\t\\t\\t\\t\\t\\t   else if(i==0) dp[i][j]=mat[i][j]+dp[i][j-1];\\n\\t\\t\\t\\t\\t\\t   else if(j==0) dp[i][j]=mat[i][j]+dp[i-1][j];\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+mat[i][j];\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\n\\t\\t\\t vector<vector<int>> ans(r, vector<int>(c));\\n\\t\\t\\t//computing answer\\n\\t\\t\\tfor(int i=0;i<r;i++){\\n\\t\\t\\t\\tfor(int j=0;j<c;j++){\\n\\t\\t\\t\\t   int rmax=min(r-1,i+k);\\n\\t\\t\\t\\t   int rmin=max(0,i-k);\\n\\t\\t\\t\\t   int cmax=min(c-1,j+k);\\n\\t\\t\\t\\t   int cmin=max(0,j-k);\\n\\n\\t\\t\\t\\t   if(rmin==0 && cmin==0) ans[i][j]=dp[rmax][cmax];\\n\\t\\t\\t\\t   else if(rmin==0) ans[i][j]=dp[rmax][cmax]-dp[rmax][cmin-1];\\n\\t\\t\\t\\t   else if(cmin==0) ans[i][j]=dp[rmax][cmax]-dp[rmin-1][cmax];\\n\\t\\t\\t\\t   else ans[i][j]=dp[rmax][cmax]-dp[rmax][cmin-1]-dp[rmin-1][cmax]\\n\\t\\t\\t\\t\\t\\t\\t\\t  +dp[rmin-1][cmin-1];\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n**NOTE**: You can further save space in optimal solution by just updating mat instead of creating DP !\\n\\nPlease DO **UPVOTE** \\u2B06\\uFE0F If It was **Helpful** !\\n",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n\\t\\t\\t   int r=mat.size(),c=mat[0].size();\\n\\t\\t\\t\\t\\tvector<vector<int>> ans(r,vector<int>(c,0));\\n\\t\\t\\t  for(int i=0;i<r;i++){\\n\\t\\t\\t\\t  for(int j=0;j<c;j++){\\n\\t\\t\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\t\\t  for(int i1=i-k;i1<=i+k;i1++){\\n\\t\\t\\t\\t\\t\\t  if(i1>=0 && i1<r){\\n\\t\\t\\t\\t\\t\\t  for(int j1=j-k;j1<=j+k;j1++){\\n\\t\\t\\t\\t\\t\\t\\t   if(j1>=0 && j1<c){\\n\\t\\t\\t\\t\\t\\t\\t\\t   sum+=mat[i1][j1];\\n\\t\\t\\t\\t\\t\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1974903,
                "title": "python-easy-to-understand-with-notes-80-less-memory",
                "content": "```\\n/*\\n    approach: \\n    create a matrix of sum where sum[i][j]th element is the sum\\n    of all the elements from mat[0][0] to mat[i][j]\\n    sum[0][0] = arr[0][0]\\n    for i = 0, sum[0][j] = arr[0][j] + sum[0][j-1]\\n    for j = 0, sum[i][0] = arr[i][0] + sum[i-1][0]\\n    for i>1 and j>1\\n    sum[i][j] = arr[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] for i in [1, n] and j in [1, n]\\n    \\n    given matrix\\n    1 2 3\\n    4 5 6\\n    7 8 9\\n    \\n    sum matrix\\n    1 3 6\\n    5 12 21\\n    11 27 45\\n    \\n    for i = 2, j = 1\\n    start_row = 1, start_col = 0\\n    end_row = 2, end_col = 2\\n    sum[i][j] = sum[2][2] - sum[start_row-1][end_col]\\n    \\n    now to create the result matrix, \\n    for i, j get 4 values, \\n    start_row, start_col, end_row, end_col\\n    if start_row == 0 and start_col == 0:\\n      sum[i][j] = sum[end_row][end_col]\\n      \\n    elif start_row == 0 and start_col != 0:\\n      sum[i][j] = sum[end_row][end_col] - sum[end_row][start_col-1]\\n    \\n    elif start_row != 0 and start_col == 0:\\n      sum[i][j] = sum[end_row][end_col] - sum[start_row-1][end_col]\\n      \\n    else:\\n      sum[i][j] = sum[end_row][end_col] - sum[start_row-1][end_col] - sum[end_row][start_col-1]\\n                  + sum[start_row-1][start_col-1]\\n                  \\n*/\\n```\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        mat_sum = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        result = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        mat_sum[0][0] = mat[0][0]\\n        for i in range(1, len(mat)):\\n            mat_sum[i][0] = mat_sum[i-1][0] + mat[i][0]\\n        for i in range(1, len(mat[0])):\\n            mat_sum[0][i] = mat_sum[0][i-1] + mat[0][i]\\n            \\n        for i in range(1, len(mat)):\\n            for j in range(1, len(mat[0])):\\n                mat_sum[i][j] = mat_sum[i-1][j] + mat_sum[i][j-1] + mat[i][j] - mat_sum[i-1][j-1]\\n                \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                # get the matrix for which we need to get the sum\\n                start_row = max(i - k, 0)\\n                end_row = min(i + k, len(mat)-1)\\n                start_col = max(j - k, 0)\\n                end_col = min(j + k, len(mat[0])-1)\\n                if start_row-1<0 and start_col-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col]\\n                elif start_row-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[end_row][start_col-1]\\n                elif start_col-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[start_row-1][end_col]\\n                else:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[start_row-1][end_col] - mat_sum[end_row][start_col-1] + mat_sum[start_row-1][start_col-1]\\n        # print(result)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n/*\\n    approach: \\n    create a matrix of sum where sum[i][j]th element is the sum\\n    of all the elements from mat[0][0] to mat[i][j]\\n    sum[0][0] = arr[0][0]\\n    for i = 0, sum[0][j] = arr[0][j] + sum[0][j-1]\\n    for j = 0, sum[i][0] = arr[i][0] + sum[i-1][0]\\n    for i>1 and j>1\\n    sum[i][j] = arr[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] for i in [1, n] and j in [1, n]\\n    \\n    given matrix\\n    1 2 3\\n    4 5 6\\n    7 8 9\\n    \\n    sum matrix\\n    1 3 6\\n    5 12 21\\n    11 27 45\\n    \\n    for i = 2, j = 1\\n    start_row = 1, start_col = 0\\n    end_row = 2, end_col = 2\\n    sum[i][j] = sum[2][2] - sum[start_row-1][end_col]\\n    \\n    now to create the result matrix, \\n    for i, j get 4 values, \\n    start_row, start_col, end_row, end_col\\n    if start_row == 0 and start_col == 0:\\n      sum[i][j] = sum[end_row][end_col]\\n      \\n    elif start_row == 0 and start_col != 0:\\n      sum[i][j] = sum[end_row][end_col] - sum[end_row][start_col-1]\\n    \\n    elif start_row != 0 and start_col == 0:\\n      sum[i][j] = sum[end_row][end_col] - sum[start_row-1][end_col]\\n      \\n    else:\\n      sum[i][j] = sum[end_row][end_col] - sum[start_row-1][end_col] - sum[end_row][start_col-1]\\n                  + sum[start_row-1][start_col-1]\\n                  \\n*/\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        mat_sum = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        result = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        mat_sum[0][0] = mat[0][0]\\n        for i in range(1, len(mat)):\\n            mat_sum[i][0] = mat_sum[i-1][0] + mat[i][0]\\n        for i in range(1, len(mat[0])):\\n            mat_sum[0][i] = mat_sum[0][i-1] + mat[0][i]\\n            \\n        for i in range(1, len(mat)):\\n            for j in range(1, len(mat[0])):\\n                mat_sum[i][j] = mat_sum[i-1][j] + mat_sum[i][j-1] + mat[i][j] - mat_sum[i-1][j-1]\\n                \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                # get the matrix for which we need to get the sum\\n                start_row = max(i - k, 0)\\n                end_row = min(i + k, len(mat)-1)\\n                start_col = max(j - k, 0)\\n                end_col = min(j + k, len(mat[0])-1)\\n                if start_row-1<0 and start_col-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col]\\n                elif start_row-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[end_row][start_col-1]\\n                elif start_col-1<0:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[start_row-1][end_col]\\n                else:\\n                    result[i][j] = mat_sum[end_row][end_col] - mat_sum[start_row-1][end_col] - mat_sum[end_row][start_col-1] + mat_sum[start_row-1][start_col-1]\\n        # print(result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929669,
                "title": "java-dp-faster-than-96",
                "content": "```\\nclass Solution {\\n    /*\\n    1  2  3  4  5\\n    6  7  8  9  10\\n    11 12 13 14 15\\n    16 17 18 19 20\\n    \\n    dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j-1] - dp[i - 1][j - 1];\\n    result[i - 1][j - 1] = dp[i + k][j + k] - dp[i + k][j - k - 1] - dp[i - k - 1][j + k] + dp[i - k - 1][j - k - 1]\\n    */\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int maxX = Math.min(m, i + k);\\n                int maxY = Math.min(n, j + k);\\n                int x = Math.max(0, i - k - 1) ;\\n                int y = Math.max(0, j - k - 1) ;\\n                mat[i - 1][j - 1] = dp[maxX][maxY] - dp[maxX][y] - dp[x][maxY] +  dp[x][y];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    1  2  3  4  5\\n    6  7  8  9  10\\n    11 12 13 14 15\\n    16 17 18 19 20\\n    \\n    dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j-1] - dp[i - 1][j - 1];\\n    result[i - 1][j - 1] = dp[i + k][j + k] - dp[i + k][j - k - 1] - dp[i - k - 1][j + k] + dp[i - k - 1][j - k - 1]\\n    */\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\\n            }\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                int maxX = Math.min(m, i + k);\\n                int maxY = Math.min(n, j + k);\\n                int x = Math.max(0, i - k - 1) ;\\n                int y = Math.max(0, j - k - 1) ;\\n                mat[i - 1][j - 1] = dp[maxX][maxY] - dp[maxX][y] - dp[x][maxY] +  dp[x][y];\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898387,
                "title": "easy-c-solution-using-prefix-sum-matrix",
                "content": "# **Concept:- First build a 2D matrix dp where dp[i][j]= sum of all the cells from (0,0) to (i,j).**\\n# **Now the answer[i][j] = dp[i+k][j+k]-dp[i-k-1][j+k]-dp[i+k][j-k-1]+dp[i-k-1][j-k-1]**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>>dp(mat.size(),vector<int>(mat[0].size())),prefix(mat.size(),vector<int>(mat[0].size())),ans(mat.size(),vector<int>(mat[0].size()));\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[i].size();j++) {\\n                prefix[i][j]=(j>0?prefix[i][j-1]+mat[i][j]:mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[0].size();j++) {\\n                dp[i][j]=(i>0?dp[i-1][j]:0)+prefix[i][j];\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[i].size();j++) {\\n                int row_top=(i+k<mat.size()?i+k:mat.size()-1);\\n                int col_top=(j+k<mat[0].size()?j+k:mat[0].size()-1);\\n                int ar=(i-k-1<0?0:dp[i-k-1][col_top]);\\n                int ac=(j-k-1<0?0:dp[row_top][j-k-1]);\\n                int arc=(i-k-1<0 || j-k-1<0?0:dp[i-k-1][j-k-1]);\\n                \\n                ans[i][j]=dp[row_top][col_top]-ar-ac+arc;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>>dp(mat.size(),vector<int>(mat[0].size())),prefix(mat.size(),vector<int>(mat[0].size())),ans(mat.size(),vector<int>(mat[0].size()));\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[i].size();j++) {\\n                prefix[i][j]=(j>0?prefix[i][j-1]+mat[i][j]:mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[0].size();j++) {\\n                dp[i][j]=(i>0?dp[i-1][j]:0)+prefix[i][j];\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[i].size();j++) {\\n                int row_top=(i+k<mat.size()?i+k:mat.size()-1);\\n                int col_top=(j+k<mat[0].size()?j+k:mat[0].size()-1);\\n                int ar=(i-k-1<0?0:dp[i-k-1][col_top]);\\n                int ac=(j-k-1<0?0:dp[row_top][j-k-1]);\\n                int arc=(i-k-1<0 || j-k-1<0?0:dp[i-k-1][j-k-1]);\\n                \\n                ans[i][j]=dp[row_top][col_top]-ar-ac+arc;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857515,
                "title": "c-neat-code-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> ans(mat.size(), vector<int>(mat[0].size(), 0));\\n        for(int i = 0; i < mat.size(); ++i){\\n            for(int j = 0; j < mat[i].size(); ++j){\\n                if(i == 0 and j == 0){\\n                    continue;\\n                }else if(i == 0){\\n                    mat[i][j] += mat[i][j-1];\\n                }else if(j == 0){\\n                    mat[i][j] += mat[i-1][j];\\n                }else{\\n                    mat[i][j] += (mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < mat.size(); ++i){\\n            for(int j = 0; j < mat[i].size(); ++j){\\n                int r1 = (i - k >= 0) ? i - k : 0;\\n                int c1 = (j - k >= 0) ? j - k : 0;\\n                int r2 = (i + k < mat.size()) ? i + k : mat.size() - 1;\\n                int c2 = (j + k < mat[0].size()) ? j + k : mat[0].size() - 1;\\n                if(r1 == 0 and c1 == 0){\\n                    ans[i][j] = mat[r2][c2];\\n                }else if(r1 == 0){\\n                    ans[i][j] = mat[r2][c2] - mat[r2][c1-1];\\n                }else if(c1 == 0){\\n                    ans[i][j] = mat[r2][c2] - mat[r1-1][c2];\\n                }else{\\n                    ans[i][j] = mat[r2][c2] - mat[r1-1][c2] - mat[r2][c1-1] + mat[r1-1][c1-1];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        vector<vector<int>> ans(mat.size(), vector<int>(mat[0].size(), 0));\\n        for(int i = 0; i < mat.size(); ++i){\\n            for(int j = 0; j < mat[i].size(); ++j){\\n                if(i == 0 and j == 0){\\n                    continue;\\n                }else if(i == 0){\\n                    mat[i][j] += mat[i][j-1];\\n                }else if(j == 0){\\n                    mat[i][j] += mat[i-1][j];\\n                }else{\\n                    mat[i][j] += (mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1]);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < mat.size(); ++i){\\n            for(int j = 0; j < mat[i].size(); ++j){\\n                int r1 = (i - k >= 0) ? i - k : 0;\\n                int c1 = (j - k >= 0) ? j - k : 0;\\n                int r2 = (i + k < mat.size()) ? i + k : mat.size() - 1;\\n                int c2 = (j + k < mat[0].size()) ? j + k : mat[0].size() - 1;\\n                if(r1 == 0 and c1 == 0){\\n                    ans[i][j] = mat[r2][c2];\\n                }else if(r1 == 0){\\n                    ans[i][j] = mat[r2][c2] - mat[r2][c1-1];\\n                }else if(c1 == 0){\\n                    ans[i][j] = mat[r2][c2] - mat[r1-1][c2];\\n                }else{\\n                    ans[i][j] = mat[r2][c2] - mat[r1-1][c2] - mat[r2][c1-1] + mat[r1-1][c1-1];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846258,
                "title": "easy-to-understand-java-code",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int rl,ru,cl,cu,sum;\\n        int u= mat.length;\\n        int v= mat[0].length;\\n        int [][] ans = new int[u][v];       \\n        for(int i=0;i<u;i++){\\n            for(int j=0;j<v;j++){\\n                rl=(i-k)<0?0:(i-k);\\n                cl=(j-k)<0?0:(j-k);\\n                ru=(i+k)<mat.length-1?(i+k):mat.length-1;\\n                cu=(j+k)<mat[0].length-1?(j+k):mat[0].length-1;\\n                sum=0;\\n                for(int r=rl;r<=ru;r++){\\n                    for(int c=cl;c<=cu;c++){\\n                        sum+=mat[r][c];\\n                    }                    \\n                }\\n                ans[i][j]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int rl,ru,cl,cu,sum;\\n        int u= mat.length;\\n        int v= mat[0].length;\\n        int [][] ans = new int[u][v];       \\n        for(int i=0;i<u;i++){\\n            for(int j=0;j<v;j++){\\n                rl=(i-k)<0?0:(i-k);\\n                cl=(j-k)<0?0:(j-k);\\n                ru=(i+k)<mat.length-1?(i+k):mat.length-1;\\n                cu=(j+k)<mat[0].length-1?(j+k):mat[0].length-1;\\n                sum=0;\\n                for(int r=rl;r<=ru;r++){\\n                    for(int c=cl;c<=cu;c++){\\n                        sum+=mat[r][c];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1799507,
                "title": "python-easy-to-read-and-understand-range-query-sum-2d",
                "content": "```\\nclass Solution:\\n    def sumRegion(self, matrix, row1, col1, row2, col2):\\n        ans = 0\\n        for i in range(row1, row2+1):\\n            x1 = matrix[i][col2]\\n            x2 = 0 if col1 == 0 else matrix[i][col1-1]\\n            ans += x1-x2\\n        return ans\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        t = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            sums = 0\\n            for j in range(n):\\n                sums += mat[i][j]\\n                t[i][j] = sums\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                r1, r2 = max(0, i-k), min(m-1, i+k)\\n                c1, c2 = max(0, j-k), min(n-1, j+k)\\n                mat[i][j] = self.sumRegion(t, r1, c1, r2, c2)\\n        \\n        return mat",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumRegion(self, matrix, row1, col1, row2, col2):\\n        ans = 0\\n        for i in range(row1, row2+1):\\n            x1 = matrix[i][col2]\\n            x2 = 0 if col1 == 0 else matrix[i][col1-1]\\n            ans += x1-x2\\n        return ans\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        t = [[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            sums = 0\\n            for j in range(n):\\n                sums += mat[i][j]\\n                t[i][j] = sums\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                r1, r2 = max(0, i-k), min(m-1, i+k)\\n                c1, c2 = max(0, j-k), min(n-1, j+k)\\n                mat[i][j] = self.sumRegion(t, r1, c1, r2, c2)\\n        \\n        return mat",
                "codeTag": "Java"
            },
            {
                "id": 1780151,
                "title": "matrix-block-sum-solution-java",
                "content": "class Solution {\\n   public int[][] matrixBlockSum(int[][] mat, int K) {\\n    int m = mat.length, n = mat[0].length;\\n    int[][] rangeSum = new int[m + 1][n + 1];\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            rangeSum[i + 1][j + 1] = rangeSum[i + 1][j] + rangeSum[i][j + 1] - rangeSum[i][j] + mat[i][j];\\n    int[][] ans = new int[m][n];\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int r1 = Math.max(0, i - K), c1 = Math.max(0, j - K), r2 = Math.min(m, i + K + 1), c2 = Math.min(n, j + K + 1);\\n            ans[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] - rangeSum[r1][c2] + rangeSum[r1][c1];\\n        }\\n    return ans;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   public int[][] matrixBlockSum(int[][] mat, int K) {\\n    int m = mat.length, n = mat[0].length;\\n    int[][] rangeSum = new int[m + 1][n + 1];\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            rangeSum[i + 1][j + 1] = rangeSum[i + 1][j] + rangeSum[i][j + 1] - rangeSum[i][j] + mat[i][j];\\n    int[][] ans = new int[m][n];\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int r1 = Math.max(0, i - K), c1 = Math.max(0, j - K), r2 = Math.min(m, i + K + 1), c2 = Math.min(n, j + K + 1);\\n            ans[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] - rangeSum[r1][c2] + rangeSum[r1][c1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1705596,
                "title": "c-simple-and-elegant-solution-o-n-m",
                "content": "```\\nclass Solution {\\n\\n    // Returns 0 for out of bound indices access;\\nprivate:\\n    int getValue(vector<vector<int>>& mat, int i, int j){\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        if(i<0 ||i>=M ||j<0||j>=N) return 0;\\n        \\n        return mat[i][j];\\n    }\\n    // Returns border value for out of bound indices access if called\\nprivate:\\n    int getValueCap(vector<vector<int>>& mat, int i, int j){\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        if(i<0 ||j<0) return 0;\\n        i = min(i,M-1);\\n        j = min(j,N-1);\\n        return mat[i][j];\\n    }\\n\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        // Converting to cumulative sum array;\\n        for(int i = 0;i<M;i++)\\n            for(int j=0;j<N;j++)\\n                mat[i][j] += ( getValue(mat, i-1,j) + getValue(mat, i,j-1) - getValue(mat, i-1,j-1) );\\n        \\n        vector<vector<int>> result(M, vector<int>(N));\\n        // result[i][j] = mat[i+k][j+k] - mat[i+k][j-k-1] - mat[i-k-1][j+k] + mat[i-k-1][j-k-1]\\n        for(int i = 0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                int r1 = i-k, r2 = i+k;\\n                int c1 = j-k, c2 = j+k;\\n                int val = getValueCap(mat,r2,c2);\\n                val += getValueCap(mat, r1-1, c1-1);\\n                val -= getValueCap(mat, r2, c1-1);\\n                val -= getValueCap(mat, r1-1, c2);\\n                result[i][j] = val;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Returns 0 for out of bound indices access;\\nprivate:\\n    int getValue(vector<vector<int>>& mat, int i, int j){\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        if(i<0 ||i>=M ||j<0||j>=N) return 0;\\n        \\n        return mat[i][j];\\n    }\\n    // Returns border value for out of bound indices access if called\\nprivate:\\n    int getValueCap(vector<vector<int>>& mat, int i, int j){\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        if(i<0 ||j<0) return 0;\\n        i = min(i,M-1);\\n        j = min(j,N-1);\\n        return mat[i][j];\\n    }\\n\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int M = mat.size();\\n        int N = mat[0].size();\\n        // Converting to cumulative sum array;\\n        for(int i = 0;i<M;i++)\\n            for(int j=0;j<N;j++)\\n                mat[i][j] += ( getValue(mat, i-1,j) + getValue(mat, i,j-1) - getValue(mat, i-1,j-1) );\\n        \\n        vector<vector<int>> result(M, vector<int>(N));\\n        // result[i][j] = mat[i+k][j+k] - mat[i+k][j-k-1] - mat[i-k-1][j+k] + mat[i-k-1][j-k-1]\\n        for(int i = 0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                int r1 = i-k, r2 = i+k;\\n                int c1 = j-k, c2 = j+k;\\n                int val = getValueCap(mat,r2,c2);\\n                val += getValueCap(mat, r1-1, c1-1);\\n                val -= getValueCap(mat, r2, c1-1);\\n                val -= getValueCap(mat, r1-1, c2);\\n                result[i][j] = val;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656876,
                "title": "prefix-sum-meaningful-variable-names",
                "content": "Here is the image which helps to understand prefix sum in matrix:\\n\\n![image](https://assets.leetcode.com/users/images/c0f1961f-0037-410f-b364-189f02d4b374_1640881207.2176192.png)\\n\\nAs far as we add or subtract `OA` sector twice (because it\\'s a part of `OB` and `OC`), we need adjust our answer. Other stuff is straightforward. \\nDo not hesitate asking questions.\\n\\n```javascript\\nfunction matrixBlockSum(mat, k) {\\n    const rows = mat.length, cols = mat[0].length;\\n    const sums = Array.from(mat, (row) => Array.from(row));\\n    \\n    // calc prefix sums\\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            sums[row][col] += \\n                (sums[row][col - 1] ?? 0) // left sum\\n                + (sums[row - 1]?.[col] ?? 0) // top sum\\n                - (sums[row - 1]?.[col - 1] ?? 0); // diagonal sum\\n        }\\n    }\\n    const answer = Array.from(mat, () => new Array(cols).fill(0));\\n    \\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            const top = row - k - 1,\\n                  left = col - k - 1,\\n                  right = Math.min(cols - 1, col + k),\\n                  bottom = Math.min(rows - 1, row + k);\\n            \\n            answer[row][col] = sums[bottom][right];\\n            if (top >= 0) {\\n                answer[row][col] -= sums[top][right];\\n            }\\n            if (left >= 0) {\\n                answer[row][col] -= sums[bottom][left];\\n            }\\n            if (top >= 0 && left >= 0) {\\n                answer[row][col] += sums[top][left];\\n            }\\n        }\\n    }\\n    \\n    return answer;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```javascript\\nfunction matrixBlockSum(mat, k) {\\n    const rows = mat.length, cols = mat[0].length;\\n    const sums = Array.from(mat, (row) => Array.from(row));\\n    \\n    // calc prefix sums\\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            sums[row][col] += \\n                (sums[row][col - 1] ?? 0) // left sum\\n                + (sums[row - 1]?.[col] ?? 0) // top sum\\n                - (sums[row - 1]?.[col - 1] ?? 0); // diagonal sum\\n        }\\n    }\\n    const answer = Array.from(mat, () => new Array(cols).fill(0));\\n    \\n    for (let row = 0; row < rows; row++) {\\n        for (let col = 0; col < cols; col++) {\\n            const top = row - k - 1,\\n                  left = col - k - 1,\\n                  right = Math.min(cols - 1, col + k),\\n                  bottom = Math.min(rows - 1, row + k);\\n            \\n            answer[row][col] = sums[bottom][right];\\n            if (top >= 0) {\\n                answer[row][col] -= sums[top][right];\\n            }\\n            if (left >= 0) {\\n                answer[row][col] -= sums[bottom][left];\\n            }\\n            if (top >= 0 && left >= 0) {\\n                answer[row][col] += sums[top][left];\\n            }\\n        }\\n    }\\n    \\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1648797,
                "title": "python3-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m,n=len(mat),len(mat[0])\\n        new=mat[:][:]\\n        for i in range(m):\\n            for j in range(n):\\n                if i-1>=0: new[i][j]+=new[i-1][j]\\n                if j-1>=0: new[i][j]+=new[i][j-1]\\n                if i-1>=0 and j-1>=0: new[i][j]-=new[i-1][j-1]\\n                    \\n        res=[[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                res[i][j]+=new[min(m-1,i+k)][min(n-1,j+k)]\\n                res[i][j]-=new[i-k-1][min(n-1,j+k)] if i-k>0 else 0\\n                res[i][j]-=new[min(m-1,i+k)][j-k-1] if j-k>0 else 0\\n                res[i][j]+=new[i-k-1][j-k-1] if i-k>0 and j-k>0 else 0\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m,n=len(mat),len(mat[0])\\n        new=mat[:][:]\\n        for i in range(m):\\n            for j in range(n):\\n                if i-1>=0: new[i][j]+=new[i-1][j]\\n                if j-1>=0: new[i][j]+=new[i][j-1]\\n                if i-1>=0 and j-1>=0: new[i][j]-=new[i-1][j-1]\\n                    \\n        res=[[0 for _ in range(n)] for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                res[i][j]+=new[min(m-1,i+k)][min(n-1,j+k)]\\n                res[i][j]-=new[i-k-1][min(n-1,j+k)] if i-k>0 else 0\\n                res[i][j]-=new[min(m-1,i+k)][j-k-1] if j-k>0 else 0\\n                res[i][j]+=new[i-k-1][j-k-1] if i-k>0 and j-k>0 else 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611038,
                "title": "c-row-based-sliding-window-prefix-sum-solution-32-ms",
                "content": "![image](https://assets.leetcode.com/users/images/0bffdb50-741c-4b44-9002-c0da4e56adec_1638979800.6208327.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<vector<int>> answer(m, vector<int>(n));\\n        \\n        //cumulative sum\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]=mat[i][j-1]+mat[i][j];\\n            }\\n        }\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int l=i-k;l<=i+k;l++)\\n                {\\n                    if(l>=0 && l<m)\\n                    {\\n                        if(j+k<n)\\n                            answer[i][j]+=mat[l][j+k];\\n                        else\\n                            answer[i][j]+=mat[l][n-1];\\n                        \\n                        if(j-k>0)\\n                            answer[i][j]-=mat[l][j-k-1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<vector<int>> answer(m, vector<int>(n));\\n        \\n        //cumulative sum\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                mat[i][j]=mat[i][j-1]+mat[i][j];\\n            }\\n        }\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                for(int l=i-k;l<=i+k;l++)\\n                {\\n                    if(l>=0 && l<m)\\n                    {\\n                        if(j+k<n)\\n                            answer[i][j]+=mat[l][j+k];\\n                        else\\n                            answer[i][j]+=mat[l][n-1];\\n                        \\n                        if(j-k>0)\\n                            answer[i][j]-=mat[l][j-k-1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587446,
                "title": "c-o-m-n-solution-with-brief-command",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> res(m, vector<int>(n)), dp(m, vector<int>(n));\\n        dp = mat;\\n        for (int i = 0; i < m; ++i) { //build dp for row\\n            for (int j = 1; j < n; ++j) {\\n                dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 1; i < m; ++i) { //build dp for column\\n                dp[i][j] += dp[i-1][j];\\n            }\\n        }\\n        for (int i = 0; i < m; ++i) { //need to check if left top index is zero or not\\n            int i_min = i - k < 0 ? 0 : i - k;\\n            int i_max = i + k >= m ? m - 1 : i + k;\\n            for (int j = 0; j < n; ++j) {\\n                int j_min = j - k < 0 ? 0 : j - k;\\n                int j_max = j + k >= n ? n - 1 : j + k;\\n                if (!i_min && !j_min) res[i][j] = dp[i_max][j_max];\\n                else if (!i_min) res[i][j] = dp[i_max][j_max] - dp[i_max][j_min-1];\\n                else if (!j_min) res[i][j] = dp[i_max][j_max] - dp[i_min-1][j_max];\\n                else res[i][j] = dp[i_max][j_max] - dp[i_max][j_min-1] - dp[i_min-1][j_max] + dp[i_min-1][j_min-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<vector<int>> res(m, vector<int>(n)), dp(m, vector<int>(n));\\n        dp = mat;\\n        for (int i = 0; i < m; ++i) { //build dp for row\\n            for (int j = 1; j < n; ++j) {\\n                dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        for (int j = 0; j < n; ++j) {\\n            for (int i = 1; i < m; ++i) { //build dp for column\\n                dp[i][j] += dp[i-1][j];\\n            }\\n        }\\n        for (int i = 0; i < m; ++i) { //need to check if left top index is zero or not\\n            int i_min = i - k < 0 ? 0 : i - k;\\n            int i_max = i + k >= m ? m - 1 : i + k;\\n            for (int j = 0; j < n; ++j) {\\n                int j_min = j - k < 0 ? 0 : j - k;\\n                int j_max = j + k >= n ? n - 1 : j + k;\\n                if (!i_min && !j_min) res[i][j] = dp[i_max][j_max];\\n                else if (!i_min) res[i][j] = dp[i_max][j_max] - dp[i_max][j_min-1];\\n                else if (!j_min) res[i][j] = dp[i_max][j_max] - dp[i_min-1][j_max];\\n                else res[i][j] = dp[i_max][j_max] - dp[i_max][j_min-1] - dp[i_min-1][j_max] + dp[i_min-1][j_min-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586168,
                "title": "c-dp-solution-100",
                "content": "Store the prefix Sum and then use prefix sum to find answer for each element.\\nTC-O(m*n)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(), m=mat[0].size();\\n        int dp[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j];\\n                if(i>0&&j>0)\\n                    dp[i][j]-=dp[i-1][j-1];\\n                if(i>0)\\n                    dp[i][j]+=dp[i-1][j];\\n                if(j>0)\\n                    dp[i][j]+=dp[i][j-1];\\n            }\\n        }\\n        vector<vector<int>>ans(n, vector<int>(m));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int row1=i-k-1;\\n                int row2=min(n-1,i+k);\\n                int col1=j-k-1;\\n                int col2=min(m-1, j+k);\\n                ans[i][j]=dp[row2][col2];\\n                if(row1>=0)\\n                    ans[i][j]-=dp[row1][col2];\\n                if(col1>=0)\\n                    ans[i][j]-=dp[row2][col1];\\n                if(row1>=0 && col1>=0)\\n                    ans[i][j]+=dp[row1][col1];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n=mat.size(), m=mat[0].size();\\n        int dp[n][m];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=mat[i][j];\\n                if(i>0&&j>0)\\n                    dp[i][j]-=dp[i-1][j-1];\\n                if(i>0)\\n                    dp[i][j]+=dp[i-1][j];\\n                if(j>0)\\n                    dp[i][j]+=dp[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1551665,
                "title": "java-96-dp-solution-with-comments-o-m-n-runtime",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\t\\t\\tint m = mat.length;\\n\\t\\t\\tint n = mat[0].length;\\n\\t\\t\\tint[][] result = new int[m][n];\\n\\n\\t\\t\\t// the horizontal presum matrix where preSum[i][j] holds \\n\\t\\t\\t// the sum of mat[i][0] + ... + mat[i][j-1]\\n\\t\\t\\t// note that preSum[i][0] is 0 so that preSum[i][j2+1] - preSum[i][j1]\\n\\t\\t\\t// would give us the sum of mat[i][j1] + ... + mat[i][j2]\\n\\t\\t\\tint[][] preSumH = new int[m][n+1];\\n\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 1; j <= n; j++) {\\n\\t\\t\\t\\t\\tpreSumH[i][j] = preSumH[i][j-1] + mat[i][j-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// populate the first row of the result\\n\\t\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\t\\tfor(int x = 0; x <= k; x++) {\\n\\t\\t\\t\\t\\tresult[0][j] += preSumH[x][Math.min(n, j+k+1)] - preSumH[x][Math.max(0, j-k)];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// finally the recurrence relationship is that result[i][j] is simply result[i-1][j]\\n\\t\\t\\t// removing the sum of top row of result[i-1][j] block\\n\\t\\t\\t// and adding the sum of bottom row of result[i][j] block\\n\\t\\t\\tfor(int i = 1; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\tresult[i][j] = result[i-1][j];\\n\\t\\t\\t\\t\\tif(i - 1 - k >= 0) {\\n\\t\\t\\t\\t\\t\\tresult[i][j] -= preSumH[i - 1 - k][Math.min(n, j+k+1)] - preSumH[i - 1 - k][Math.max(0, j-k)];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(i + k < m) {\\n\\t\\t\\t\\t\\t\\tresult[i][j] += preSumH[i+k][Math.min(n, j+k+1)] - preSumH[i+k][Math.max(0, j-k)];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\t\\t\\tint m = mat.length;\\n\\t\\t\\tint n = mat[0].length;\\n\\t\\t\\tint[][] result = new int[m][n];\\n\\n\\t\\t\\t// the horizontal presum matrix where preSum[i][j] holds \\n\\t\\t\\t// the sum of mat[i][0] + ... + mat[i][j-1]\\n\\t\\t\\t// note that preSum[i][0] is 0 so that preSum[i][j2+1] - preSum[i][j1]\\n\\t\\t\\t// would give us the sum of mat[i][j1] + ... + mat[i][j2]\\n\\t\\t\\tint[][] preSumH = new int[m][n+1];\\n\\n\\t\\t\\tfor(int i = 0; i < m; i++) {\\n\\t\\t\\t\\tfor(int j = 1; j <= n; j++) {\\n\\t\\t\\t\\t\\tpreSumH[i][j] = preSumH[i][j-1] + mat[i][j-1];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1540546,
                "title": "clean-fast-java-solution-o-n-2-time-and-space-3ms",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] matSum = new int[mat.length + 1][mat[0].length + 1];\\n        int[][] retMat = new int[mat.length][mat[0].length];\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            int sum = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                sum += mat[i][j];\\n                matSum[i + 1][j + 1] = sum + matSum[i][j + 1]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                int rb = Math.min(j + k, mat[0].length - 1);\\n                int lb = Math.max(j - k, 0);\\n                int tb = Math.max(i - k, 0);\\n                int bb = Math.min(i + k, mat.length - 1);\\n                \\n                retMat[i][j] = matSum[bb + 1][rb + 1] - matSum[tb][rb + 1] - matSum[bb + 1][lb] + matSum[tb][lb];\\n            }\\n        }\\n        \\n        return retMat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] matSum = new int[mat.length + 1][mat[0].length + 1];\\n        int[][] retMat = new int[mat.length][mat[0].length];\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            int sum = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                sum += mat[i][j];\\n                matSum[i + 1][j + 1] = sum + matSum[i][j + 1]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            for (int j = 0; j < mat[0].length; j++) {\\n                int rb = Math.min(j + k, mat[0].length - 1);\\n                int lb = Math.max(j - k, 0);\\n                int tb = Math.max(i - k, 0);\\n                int bb = Math.min(i + k, mat.length - 1);\\n                \\n                retMat[i][j] = matSum[bb + 1][rb + 1] - matSum[tb][rb + 1] - matSum[bb + 1][lb] + matSum[tb][lb];\\n            }\\n        }\\n        \\n        return retMat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539762,
                "title": "c-prefixsum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int>> rangeSum(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                rangeSum[i][j] = rangeSum[i - 1][j] + rangeSum[i][j - 1] \\n                    - rangeSum[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int r1 = max(i - k, 0);\\n                int c1 = max(j - k, 0);\\n                int r2 = min(i + k + 1, m);\\n                int c2 = min(j + k + 1, n);\\n                res[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] -\\n                    rangeSum[r1][c2] + rangeSum[r1][c1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int>> rangeSum(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                rangeSum[i][j] = rangeSum[i - 1][j] + rangeSum[i][j - 1] \\n                    - rangeSum[i - 1][j - 1] + matrix[i - 1][j - 1];\\n            }\\n        }\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int r1 = max(i - k, 0);\\n                int c1 = max(j - k, 0);\\n                int r2 = min(i + k + 1, m);\\n                int c2 = min(j + k + 1, n);\\n                res[i][j] = rangeSum[r2][c2] - rangeSum[r2][c1] -\\n                    rangeSum[r1][c2] + rangeSum[r1][c1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524791,
                "title": "python3-self-explanatory-prefix-sum-based-solution",
                "content": "## How to calculate block-sum with prefix-sum\\n1. First calculate a prefix sum matrix for next step\\'s use\\n\\t- define dp[i][j] to be prefix sum of rectangle from (0,0) to (i,j).\\n\\t- to calculate prefix sum, let\\'s say we want to calculate position **d** in the commented example matrix (**see diagram below**), we first add prefix sum of position **b** and **c**, then subtract prefix sum at **a** since it was calculated twice.\\n\\t- then we add matrix value at itself mat[**d**]\\n2. After we have the *prefix sum* matrix ready, we can calculate *block sum* matrix using *prefix sum* matrix.\\n3. Let\\'s say to calculate *block sum* at position **d** (say the position is **[i][j]**) with **k**. It is the prefix sum of:\\n\\t- +*lower right point* **[i+k][j+k]**\\n\\t-  -*upper right point* **[i-k-1][j+k]**\\n\\t-  -*lower left point* **[i+k][j-k-1]** \\n\\t-  +*upper left point* **[i-k-1][j-k-1]** (since the area was subtracted twice)\\n4. **Notice** here we want to avoid position falls outside the matrix valid region:\\n\\t- lower right point should be at max position at prefix sum matrix\\'s lower right corner.\\n\\t- upper right point should be set to zero only when row is less than 0, column should max at right border.\\n\\t- lower left point should be set to zero only when column is less than 0, row should max at bottom border.\\n\\nconsider this matrix for example:\\n```\\n        [+][ ][ ][-]\\n        [ ][a][b][ ] \\n\\t\\t[ ][c][d][ ]           \\n        [-][ ][ ][+]\\n\\t\\t\\n\\t\\tprefix sum: dp[d] = dp[b] + dp[c] - dp[a] + mat[d]\\n\\t\\t\\n                            lower_right     upper_right      lower_left         upper_left\\n        block_sum[(i,j)] = dp[i+k, j+k] - dp[i-k-1, j+k] - dp[i+k, j-k-1] - dp[i-k-1, j-k-1]\\n\\t\\t(with k)\\n```\\n\\n## Solution beat 83% runtime\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \"\"\"\\n        [+][ ][ ][-]\\n        [ ][a][b][ ] \\n        [ ][c][d][ ] dp[d] = dp[b] + dp[c] - dp[a] + mat[d]\\n        [-][ ][ ][+]\\n                                lower_right     upper_right     lower_left        upper_left\\n        block_sum[(i,j), k] = dp[i+k, j+k] - dp[i-k-1, j+k] - dp[i+k, j-k-1] - dp[i-k-1, j-k-1]\\n        \"\"\"\\n        # dp[i][j] is the prefix sum of all elemnt before i, j\\n        dp = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        # init dp\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                # init dp left & upper border\\n                if i == 0 and j == 0:\\n                    dp[i][j] = mat[i][j]\\n                    continue\\n                elif i == 0:\\n                    dp[i][j] = mat[i][j] + dp[i][j-1]\\n                    continue\\n                elif j == 0:\\n                    dp[i][j] = mat[i][j] + dp[i-1][j]\\n                    continue\\n                    \\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i][j]\\n        \\n        # for m in mat:\\n        #     print(m)\\n        # print(\"--------------\")\\n        # for i in dp:\\n        #     print(i)\\n            \\n        res = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        # calculate block sum\\n        row_max = len(res) - 1\\n        col_max = len(res[0]) - 1\\n        for i in range(len(res)):\\n            for j in range(len(res[0])):\\n                lower_right = dp[min(i+k, row_max)][min(j+k, col_max)]\\n                upper_left = 0 if (i-k-1<0 or j-k-1<0) else dp[i-k-1][j-k-1]\\n                lower_left = 0 if (j-k-1<0) else dp[min(i+k, row_max)][j-k-1]\\n                upper_right = 0 if (i-k-1<0) else dp[i-k-1][min(j+k, col_max)]\\n                \\n                res[i][j] = lower_right - upper_right - lower_left + upper_left\\n                \\n        return res\\n            \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n        [+][ ][ ][-]\\n        [ ][a][b][ ] \\n\\t\\t[ ][c][d][ ]           \\n        [-][ ][ ][+]\\n\\t\\t\\n\\t\\tprefix sum: dp[d] = dp[b] + dp[c] - dp[a] + mat[d]\\n\\t\\t\\n                            lower_right     upper_right      lower_left         upper_left\\n        block_sum[(i,j)] = dp[i+k, j+k] - dp[i-k-1, j+k] - dp[i+k, j-k-1] - dp[i-k-1, j-k-1]\\n\\t\\t(with k)\\n```\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        \"\"\"\\n        [+][ ][ ][-]\\n        [ ][a][b][ ] \\n        [ ][c][d][ ] dp[d] = dp[b] + dp[c] - dp[a] + mat[d]\\n        [-][ ][ ][+]\\n                                lower_right     upper_right     lower_left        upper_left\\n        block_sum[(i,j), k] = dp[i+k, j+k] - dp[i-k-1, j+k] - dp[i+k, j-k-1] - dp[i-k-1, j-k-1]\\n        \"\"\"\\n        # dp[i][j] is the prefix sum of all elemnt before i, j\\n        dp = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        # init dp\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                # init dp left & upper border\\n                if i == 0 and j == 0:\\n                    dp[i][j] = mat[i][j]\\n                    continue\\n                elif i == 0:\\n                    dp[i][j] = mat[i][j] + dp[i][j-1]\\n                    continue\\n                elif j == 0:\\n                    dp[i][j] = mat[i][j] + dp[i-1][j]\\n                    continue\\n                    \\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i][j]\\n        \\n        # for m in mat:\\n        #     print(m)\\n        # print(\"--------------\")\\n        # for i in dp:\\n        #     print(i)\\n            \\n        res = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        # calculate block sum\\n        row_max = len(res) - 1\\n        col_max = len(res[0]) - 1\\n        for i in range(len(res)):\\n            for j in range(len(res[0])):\\n                lower_right = dp[min(i+k, row_max)][min(j+k, col_max)]\\n                upper_left = 0 if (i-k-1<0 or j-k-1<0) else dp[i-k-1][j-k-1]\\n                lower_left = 0 if (j-k-1<0) else dp[min(i+k, row_max)][j-k-1]\\n                upper_right = 0 if (i-k-1<0) else dp[i-k-1][min(j+k, col_max)]\\n                \\n                res[i][j] = lower_right - upper_right - lower_left + upper_left\\n                \\n        return res\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511154,
                "title": "java-simple-idea-but-trivial-not-bad-performance",
                "content": "idea is straight forward.\\n\\nimaging there is a box (center is i, j)  in `mat`, what you need is get sum of the box and put in `ans` with same i, j\\n\\n1. calculate first one\\n2. for first row, calculate from left to right (image move the box left to right), baseed on the left one, decrease if there is a colum out of the box, increase if there is a colum included.\\n3. for the rest, calculate based on upper one. decrease if there is a row out of the box, increase if there is a row included in\\n\\nNode: trivial but works and straight forword\\n\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        \\n        int [][] ans = new int [row][col];\\n        \\n        // init fist one\\n        for (int i = 0; i < row && i <= k; i++) {\\n            for (int j = 0; j < col && j <= k; j++) {\\n                ans[0][0] += mat[i][j];\\n            }\\n        }\\n        \\n\\n        \\n        for (int i = 0; i < row; i++) {\\n            int rTop = i - k;\\n            int rBot = i + k;\\n            \\n            for (int j = 0; j < col; j++) {\\n                // skip first one\\n                if (i==0 && j==0) continue;\\n                \\n                // get range\\n                int cLeft = j - k;\\n                int cRight = j + k;\\n                \\n                if (i == 0) {\\n                    // first line, left to right\\n                    ans[i][j] = ans[i][j - 1];\\n                    if (rTop <= 0) rTop = 0;\\n                    if (rBot >= row) rBot = row - 1;\\n\\t\\t\\t\\t\\t\\n                    if (cLeft > 0) {\\n                        for (int q = rTop; q <= rBot; q++) {\\n                            ans[i][j] -= mat[q][cLeft - 1];\\n                        }\\n                    }\\n                    if (cRight <= col - 1) {\\n                        for (int q = rTop; q <= rBot; q++) {\\n                            ans[i][j] += mat[q][cRight];\\n                        }\\n                    }\\n                }else {\\n                    // not firest line\\n                    ans[i][j] = ans[i - 1][j];\\n                    if (cLeft < 0) cLeft = 0;\\n                    if (cRight >= col) cRight = col - 1;\\n\\t\\t\\t\\t\\t\\n                    if (rTop > 0) {\\n                        for (int q = cLeft; q <= cRight; q++) {\\n                            ans[i][j] -= mat[rTop - 1][q]; \\n                        }\\n                    }\\n                    if (rBot <= row - 1) {\\n                        for (int q = cLeft; q <= cRight; q++) {\\n                            ans[i][j] += mat[rBot][q];\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        \\n        int [][] ans = new int [row][col];\\n        \\n        // init fist one\\n        for (int i = 0; i < row && i <= k; i++) {\\n            for (int j = 0; j < col && j <= k; j++) {\\n                ans[0][0] += mat[i][j];\\n            }\\n        }\\n        \\n\\n        \\n        for (int i = 0; i < row; i++) {\\n            int rTop = i - k;\\n            int rBot = i + k;\\n            \\n            for (int j = 0; j < col; j++) {\\n                // skip first one\\n                if (i==0 && j==0) continue;\\n                \\n                // get range\\n                int cLeft = j - k;\\n                int cRight = j + k;\\n                \\n                if (i == 0) {\\n                    // first line, left to right\\n                    ans[i][j] = ans[i][j - 1];\\n                    if (rTop <= 0) rTop = 0;\\n                    if (rBot >= row) rBot = row - 1;\\n\\t\\t\\t\\t\\t\\n                    if (cLeft > 0) {\\n                        for (int q = rTop; q <= rBot; q++) {\\n                            ans[i][j] -= mat[q][cLeft - 1];\\n                        }\\n                    }\\n                    if (cRight <= col - 1) {\\n                        for (int q = rTop; q <= rBot; q++) {\\n                            ans[i][j] += mat[q][cRight];\\n                        }\\n                    }\\n                }else {\\n                    // not firest line\\n                    ans[i][j] = ans[i - 1][j];\\n                    if (cLeft < 0) cLeft = 0;\\n                    if (cRight >= col) cRight = col - 1;\\n\\t\\t\\t\\t\\t\\n                    if (rTop > 0) {\\n                        for (int q = cLeft; q <= cRight; q++) {\\n                            ans[i][j] -= mat[rTop - 1][q]; \\n                        }\\n                    }\\n                    if (rBot <= row - 1) {\\n                        for (int q = cLeft; q <= cRight; q++) {\\n                            ans[i][j] += mat[rBot][q];\\n                        }\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498803,
                "title": "python-dynamic-programming-method-easy-to-read",
                "content": "Hi,\\n\\nThis method is inspired by the hints provided with the problem. If you have any question feel free to ask.\\n\\n```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        \\n        \"\"\"\\n        dp[i][j] is the sum of mat[r][c] for 0 <= r <= i and 0 <= c <= j\\n        \"\"\"\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        dp[0][0] = mat[0][0]\\n        \\n        # First column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i - 1][0] + mat[i][0]\\n            \\n        # First row\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j - 1] + mat[0][j]\\n          \\n        # Inside\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] =  mat[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\\n        \\n        \"\"\"\\n        k = 1, Calcul of answer[2][2]\\n        \\n        1 2 3                 1 2 3   1 _ _   1 2 3   1 _ _\\n        4 5 6  -->  5 6  -->  4 5 6 - 4 _ _ - _ _ _ + _ _ _  -->  28\\n        7 8 9       8 9       7 8 9   7 _ _   _ _ _   _ _ _\\n                           bottom-right     top_right\\n                                    bottom-left      top_left\\n        \"\"\"\\n        answer = [[0 for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            top, bottom = i - k - 1, min(m - 1, i + k)\\n            for j in range(n):\\n                left, right = j - k - 1, min(n - 1, j + k)\\n                top_left = dp[top][left] if top >= 0 and left >= 0 else 0\\n                top_right = dp[top][right] if top >= 0 else 0\\n                bottom_left = dp[bottom][left] if left >= 0 else 0\\n                bottom_right = dp[bottom][right]\\n                \\n                answer[i][j] = bottom_right - bottom_left - top_right + top_left \\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        \\n        \"\"\"\\n        dp[i][j] is the sum of mat[r][c] for 0 <= r <= i and 0 <= c <= j\\n        \"\"\"\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        dp[0][0] = mat[0][0]\\n        \\n        # First column\\n        for i in range(1, m):\\n            dp[i][0] = dp[i - 1][0] + mat[i][0]\\n            \\n        # First row\\n        for j in range(1, n):\\n            dp[0][j] = dp[0][j - 1] + mat[0][j]\\n          \\n        # Inside\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] =  mat[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\\n        \\n        \"\"\"\\n        k = 1, Calcul of answer[2][2]\\n        \\n        1 2 3                 1 2 3   1 _ _   1 2 3   1 _ _\\n        4 5 6  -->  5 6  -->  4 5 6 - 4 _ _ - _ _ _ + _ _ _  -->  28\\n        7 8 9       8 9       7 8 9   7 _ _   _ _ _   _ _ _\\n                           bottom-right     top_right\\n                                    bottom-left      top_left\\n        \"\"\"\\n        answer = [[0 for j in range(n)] for i in range(m)]\\n        for i in range(m):\\n            top, bottom = i - k - 1, min(m - 1, i + k)\\n            for j in range(n):\\n                left, right = j - k - 1, min(n - 1, j + k)\\n                top_left = dp[top][left] if top >= 0 and left >= 0 else 0\\n                top_right = dp[top][right] if top >= 0 else 0\\n                bottom_left = dp[bottom][left] if left >= 0 else 0\\n                bottom_right = dp[bottom][right]\\n                \\n                answer[i][j] = bottom_right - bottom_left - top_right + top_left \\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394523,
                "title": "c-prefix-sum-easy-to-understand-solution",
                "content": "**Runtime: 4 ms, faster than 99.10% of C++ online submissions for Matrix Block Sum.\\nMemory Usage: 9.2 MB, less than 91.97% of C++ online submissions for Matrix Block Sum.**\\n```\\n\\nclass Solution {\\npublic:\\n    int sizeX,sizeY;\\n\\t\\n    int getA(int i,int j,vector<vector<int>>& sum){\\n        if(i<0||j<0){return 0;}\\n        if(i >= sizeX ){i = sizeX-1;}\\n        if(j >= sizeY ){j = sizeY-1;}\\n        return sum[i][j];\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        sizeX = mat.size();\\n        sizeY = mat[0].size();\\n                        \\n        for(int i=0;i<sizeX;i++){\\n            for(int j=1;j<sizeY;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i=0;i<sizeY;i++){\\n            for(int j=1;j<sizeX;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n\\n        vector<vector<int>> ans(sizeX,vector<int>(sizeY,0));\\n        for(int i=0;i<sizeX;i++){\\n            for(int j=0;j<sizeY;j++){\\n                ans[i][j] = getA(i+k,j+k,mat) - getA(i-k-1,j+k,mat) - getA(i+k,j-k-1,mat) + getA(i-k-1,j-k-1,mat);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int sizeX,sizeY;\\n\\t\\n    int getA(int i,int j,vector<vector<int>>& sum){\\n        if(i<0||j<0){return 0;}\\n        if(i >= sizeX ){i = sizeX-1;}\\n        if(j >= sizeY ){j = sizeY-1;}\\n        return sum[i][j];\\n    }\\n    \\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        sizeX = mat.size();\\n        sizeY = mat[0].size();\\n                        \\n        for(int i=0;i<sizeX;i++){\\n            for(int j=1;j<sizeY;j++){\\n                mat[i][j] += mat[i][j-1];\\n            }\\n        }\\n        \\n        for(int i=0;i<sizeY;i++){\\n            for(int j=1;j<sizeX;j++){\\n                mat[j][i] += mat[j-1][i];\\n            }\\n        }\\n\\n        vector<vector<int>> ans(sizeX,vector<int>(sizeY,0));\\n        for(int i=0;i<sizeX;i++){\\n            for(int j=0;j<sizeY;j++){\\n                ans[i][j] = getA(i+k,j+k,mat) - getA(i-k-1,j+k,mat) - getA(i+k,j-k-1,mat) + getA(i-k-1,j-k-1,mat);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380721,
                "title": "clean-java-code-using-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        for(int i =0;i<mat.length;i++){\\n            for(int j =0;j<mat[0].length;j++){\\n                if(i==0&&j==0) continue;\\n                else if(i==0){\\n                    mat[i][j]+=mat[i][j-1];\\n                }else if(j==0){\\n                    mat[i][j]+=mat[i-1][j];\\n                }else{\\n                    mat[i][j]+=(mat[i][j-1]+mat[i-1][j]-mat[i-1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int ans[][] = new int[mat.length][mat[0].length];\\n        for(int i =0;i<ans.length;i++){\\n            for(int j =0;j<ans[0].length;j++){\\n                int first_corner_i = Math.max(0,i-k);\\n                int first_corner_j = Math.max(0,j-k);\\n                int second_corner_i = Math.min(mat.length-1,i+k);\\n                int second_corner_j = Math.min(mat[0].length-1,j+k);\\n                \\n                int sum = mat[second_corner_i][second_corner_j];\\n                \\n                if(first_corner_i-1>=0){\\n                    sum-=mat[first_corner_i-1][second_corner_j];\\n                }\\n                \\n                if(first_corner_j-1>=0){\\n                    sum-=mat[second_corner_i][first_corner_j-1];\\n                }\\n                \\n                if(first_corner_i-1>=0&&first_corner_j-1>=0){\\n                    sum+=mat[first_corner_i-1][first_corner_j-1];\\n                }\\n                \\n                ans[i][j] = sum;\\n             }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        for(int i =0;i<mat.length;i++){\\n            for(int j =0;j<mat[0].length;j++){\\n                if(i==0&&j==0) continue;\\n                else if(i==0){\\n                    mat[i][j]+=mat[i][j-1];\\n                }else if(j==0){\\n                    mat[i][j]+=mat[i-1][j];\\n                }else{\\n                    mat[i][j]+=(mat[i][j-1]+mat[i-1][j]-mat[i-1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int ans[][] = new int[mat.length][mat[0].length];\\n        for(int i =0;i<ans.length;i++){\\n            for(int j =0;j<ans[0].length;j++){\\n                int first_corner_i = Math.max(0,i-k);\\n                int first_corner_j = Math.max(0,j-k);\\n                int second_corner_i = Math.min(mat.length-1,i+k);\\n                int second_corner_j = Math.min(mat[0].length-1,j+k);\\n                \\n                int sum = mat[second_corner_i][second_corner_j];\\n                \\n                if(first_corner_i-1>=0){\\n                    sum-=mat[first_corner_i-1][second_corner_j];\\n                }\\n                \\n                if(first_corner_j-1>=0){\\n                    sum-=mat[second_corner_i][first_corner_j-1];\\n                }\\n                \\n                if(first_corner_i-1>=0&&first_corner_j-1>=0){\\n                    sum+=mat[first_corner_i-1][first_corner_j-1];\\n                }\\n                \\n                ans[i][j] = sum;\\n             }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327800,
                "title": "python-3-yummy-and-easy-to-follow-brute-force-o-k-2-m-n",
                "content": "```class Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        copy = [[0]*len(mat[0]) for _ in mat]\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                total = 0\\n                # quadratic wrt k\\n                for r in range(max(0,i-k), min(i+k+1, len(mat))):\\n                    for c in range(max(0,j-k), min(j+k+1,len(mat[0]))):\\n                        total += mat[r][c]\\n                copy[i][j] = total\\n        return copy\\n```\\n\\nEnjoy :\\')",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        copy = [[0]*len(mat[0]) for _ in mat]\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                total = 0\\n                # quadratic wrt k\\n                for r in range(max(0,i-k), min(i+k+1, len(mat))):\\n                    for c in range(max(0,j-k), min(j+k+1,len(mat[0]))):\\n                        total += mat[r][c]\\n                copy[i][j] = total\\n        return copy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305882,
                "title": "c-clean-code",
                "content": "\\n```\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size(); \\n        vector<vector<int>> sum = mat, res = mat;\\n        for(int j = 1; j < n; ++j) {\\n            for(int i = 0; i < m; ++i) \\n                sum[i][j] += sum[i][j - 1];\\n        }\\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) \\n                sum[i][j] += sum[i - 1][j];\\n        }\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int max_r = i + k >= m ? m - 1 : i + k;\\n                int max_c = j + k >= n ? n - 1 : j + k;\\n                res[i][j] = sum[max_r][max_c];\\n                if(j - k > 0) res[i][j] -= sum[max_r][j - k - 1];\\n                if(i - k > 0) res[i][j] -= sum[i - k - 1][max_c];\\n                if((i - k > 0) && (j - k > 0)) res[i][j] += sum[i - k - 1][j - k - 1];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int m = mat.size(), n = mat[0].size(); \\n        vector<vector<int>> sum = mat, res = mat;\\n        for(int j = 1; j < n; ++j) {\\n            for(int i = 0; i < m; ++i) \\n                sum[i][j] += sum[i][j - 1];\\n        }\\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) \\n                sum[i][j] += sum[i - 1][j];\\n        }\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                int max_r = i + k >= m ? m - 1 : i + k;\\n                int max_c = j + k >= n ? n - 1 : j + k;\\n                res[i][j] = sum[max_r][max_c];\\n                if(j - k > 0) res[i][j] -= sum[max_r][j - k - 1];\\n                if(i - k > 0) res[i][j] -= sum[i - k - 1][max_c];\\n                if((i - k > 0) && (j - k > 0)) res[i][j] += sum[i - k - 1][j - k - 1];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269317,
                "title": "c-simple-prefix-sum-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        vector<vector<int>>row,col;\\n        \\n        \\n        //prefix sum row-wise\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            vector<int>v;\\n            for(int j=0;j<m;j++)\\n            {\\n               sum+=matrix[i][j];\\n               v.push_back(sum);\\n            }\\n            row.push_back(v);\\n        }\\n\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                 int start=max(i-k,0);//row start pos\\n                 int end=min(i+k+1,n);//row end pos\\n                \\n                 int start1=max(j-k,0);//col start pos\\n                 int end1=min(j+k,m-1);//col end pos\\n                \\n                \\n                \\n                      int t=0;\\n                for(int f=start;f<end;f++)\\n                {\\n              \\n                    if(start1-1>=0)\\n                    {\\n                        t-=row[f][start1-1];\\n                    }\\n                    \\n                    t+=row[f][end1];\\n                }\\n                ans[i][j]=t;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6f30c13d-3756-472d-9f6b-d1dfe226f22d_1623576443.8117292.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& matrix, int k) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        vector<vector<int>>row,col;\\n        \\n        \\n        //prefix sum row-wise\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            vector<int>v;\\n            for(int j=0;j<m;j++)\\n            {\\n               sum+=matrix[i][j];\\n               v.push_back(sum);\\n            }\\n            row.push_back(v);\\n        }\\n\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                 int start=max(i-k,0);//row start pos\\n                 int end=min(i+k+1,n);//row end pos\\n                \\n                 int start1=max(j-k,0);//col start pos\\n                 int end1=min(j+k,m-1);//col end pos\\n                \\n                \\n                \\n                      int t=0;\\n                for(int f=start;f<end;f++)\\n                {\\n              \\n                    if(start1-1>=0)\\n                    {\\n                        t-=row[f][start1-1];\\n                    }\\n                    \\n                    t+=row[f][end1];\\n                }\\n                ans[i][j]=t;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266094,
                "title": "1314-sum-of-rect-i-k-j-k-i-k-j-k-se-ne-sw-nw",
                "content": "---\\n\\n- Sometimes it becomes an obsession :D\\n\\n---\\n\\n**Algo**\\n\\n- We have a matrix  `m rows  x  n columns`\\n- We need sum of all elements in a rectangle, that is part of the matrix\\n- Rectangle is from   `[i-k, j-k]`  point to   `[i+k][j+k]`\\n- Since we need to do this for all i & j, we need a better plan to be fast\\n- Assume somehow we did sums of all below rectangles:\\n  - [0,0, 0,0],   [0,0, 0,1],   [0,0, 0,2] <------------------ summing from left gets us this\\n  - [0,0, 1,0],   **[0,0, 1,1],   [0,0, 1,2]**\\n  - [0,0, 2,0],   **[0,0, 2,1],   [0,0, 2,2]**\\n  - ---- above can be got by adding curr + above element\\n- Now to get sum of rectangle **[0,0, 22]** is   [0,0, 2,2]   -  [0,0, 2,0] - [0,0, 0,2]   + [0,0, 0,0] (because this got remove twice)\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Step1 - Add/ Subtract prefix sums**\\n\\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n        let memo = Array.from({ length: m }, () => new Array(n));\\n\\n        for (let i = 0; i < M.length; i++) {\\n            let prefixSum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                prefixSum += M[i][j];\\n                memo[i][j] = prefixSum;\\n            }\\n        }\\n\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                let sum = 0;\\n                for (let k = i - K; k <= i + K; k++) {\\n                    if (k >= 0 && k < m) {\\n                        sum +=\\n                                              memo[k][Math.min(j + K, n - 1)] -\\n                            (j - K - 1 >= 0 ? memo[k][j - K - 1             ] : 0);\\n                    }\\n                }\\n                M[i][j] = sum;\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/890bda7b-77d5-44ca-b405-f4517852bd13_1623468682.631645.png)\\n\\n---\\n\\n**Step2 - Add/ Subtract Matrix sums**\\n\\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n\\n        // let to right sums  (prefix sums)\\n        let memo = Array.from({ length: m }, () => new Array(n));\\n        for (let i = 0; i < M.length; i++) {\\n            let sum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                sum += M[i][j];\\n                memo[i][j] = sum;\\n            }\\n        }\\n\\n        // rectangular sums\\n        for (let i = 1; i < M.length; i++) {\\n            for (let j = 0; j < M[i].length; j++) {\\n                memo[i][j] += memo[i - 1][j];\\n            }\\n        }\\n\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                let iminusK = i - K - 1; // this is only for subtracting top/left/top-left rectangle\\n                let jminusK = j - K - 1; // this is only for subtracting top/left/top-left rectangle\\n                let iplusK = Math.min(i + K, m - 1); // take as much as possible on down\\n                let jplusK = Math.min(j + K, n - 1); // take as much as possible on right\\n\\n                // prettier-ignore\\n                {\\n                    let SE =                                memo[iplusK] [jplusK]     ;\\n                    let NE = iminusK >= 0                 ? memo[iminusK][jplusK]  : 0;\\n                    let SW =                 jminusK >= 0 ? memo[iplusK][jminusK]  : 0;\\n                    let NW = iminusK >= 0 && jminusK >= 0 ? memo[iminusK][jminusK] : 0;\\n                    M[i][j] = SE - (NE + SW - NW);\\n                }\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/826b2358-055c-41ed-8ca4-8c79fb24280a_1623468346.1044695.png)\\n\\n---\\n\\n**Step3 - Add/ Subtract Matrix sums - optimized memo, extra left column & top row to reduce conditions**\\n\\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n\\n        // let to right sums  (prefix sums)\\n        let memo = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));\\n        for (let i = 0; i < M.length; i++) {\\n            let sum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                sum += M[i][j];\\n                memo[i + 1][j + 1] = sum;\\n            }\\n        }\\n\\n        // rectangular sums\\n        for (let i = 1; i < M.length; i++) {\\n            for (let j = 0; j < M[i].length; j++) {\\n                memo[i + 1][j + 1] += memo[i][j + 1];\\n            }\\n        }\\n\\n        for (let i = 1; i <= m; i++) {\\n            for (let j = 1; j <= n; j++) {\\n                let iminusK = Math.max(i - K - 1, 0); // this is only for subtracting top/left/top-left rectangle\\n                let jminusK = Math.max(j - K - 1, 0); // this is only for subtracting top/left/top-left rectangle\\n                let iplusK = Math.min(i + K, m); // take as much as possible on down\\n                let jplusK = Math.min(j + K, n); // take as much as possible on right\\n\\n                {\\n                    let SE = memo[iplusK][jplusK];\\n                    let NE = memo[iminusK][jplusK];\\n                    let SW = memo[iplusK][jminusK];\\n                    let NW = memo[iminusK][jminusK];\\n\\n                    M[i - 1][j - 1] = SE - (NE + SW - NW);\\n                }\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e9fc662a-4817-4d27-9d70-281395fe8f8c_1623468290.707332.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n        let memo = Array.from({ length: m }, () => new Array(n));\\n\\n        for (let i = 0; i < M.length; i++) {\\n            let prefixSum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                prefixSum += M[i][j];\\n                memo[i][j] = prefixSum;\\n            }\\n        }\\n\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                let sum = 0;\\n                for (let k = i - K; k <= i + K; k++) {\\n                    if (k >= 0 && k < m) {\\n                        sum +=\\n                                              memo[k][Math.min(j + K, n - 1)] -\\n                            (j - K - 1 >= 0 ? memo[k][j - K - 1             ] : 0);\\n                    }\\n                }\\n                M[i][j] = sum;\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n\\n        // let to right sums  (prefix sums)\\n        let memo = Array.from({ length: m }, () => new Array(n));\\n        for (let i = 0; i < M.length; i++) {\\n            let sum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                sum += M[i][j];\\n                memo[i][j] = sum;\\n            }\\n        }\\n\\n        // rectangular sums\\n        for (let i = 1; i < M.length; i++) {\\n            for (let j = 0; j < M[i].length; j++) {\\n                memo[i][j] += memo[i - 1][j];\\n            }\\n        }\\n\\n        for (let i = 0; i < m; i++) {\\n            for (let j = 0; j < n; j++) {\\n                let iminusK = i - K - 1; // this is only for subtracting top/left/top-left rectangle\\n                let jminusK = j - K - 1; // this is only for subtracting top/left/top-left rectangle\\n                let iplusK = Math.min(i + K, m - 1); // take as much as possible on down\\n                let jplusK = Math.min(j + K, n - 1); // take as much as possible on right\\n\\n                // prettier-ignore\\n                {\\n                    let SE =                                memo[iplusK] [jplusK]     ;\\n                    let NE = iminusK >= 0                 ? memo[iminusK][jplusK]  : 0;\\n                    let SW =                 jminusK >= 0 ? memo[iplusK][jminusK]  : 0;\\n                    let NW = iminusK >= 0 && jminusK >= 0 ? memo[iminusK][jminusK] : 0;\\n                    M[i][j] = SE - (NE + SW - NW);\\n                }\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```\n```\\nclass DP {\\n    matrixBlockSum(M, K) {\\n        let m = M.length;\\n        let n = M[0].length;\\n\\n        // let to right sums  (prefix sums)\\n        let memo = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));\\n        for (let i = 0; i < M.length; i++) {\\n            let sum = 0;\\n            for (let j = 0; j < M[i].length; j++) {\\n                sum += M[i][j];\\n                memo[i + 1][j + 1] = sum;\\n            }\\n        }\\n\\n        // rectangular sums\\n        for (let i = 1; i < M.length; i++) {\\n            for (let j = 0; j < M[i].length; j++) {\\n                memo[i + 1][j + 1] += memo[i][j + 1];\\n            }\\n        }\\n\\n        for (let i = 1; i <= m; i++) {\\n            for (let j = 1; j <= n; j++) {\\n                let iminusK = Math.max(i - K - 1, 0); // this is only for subtracting top/left/top-left rectangle\\n                let jminusK = Math.max(j - K - 1, 0); // this is only for subtracting top/left/top-left rectangle\\n                let iplusK = Math.min(i + K, m); // take as much as possible on down\\n                let jplusK = Math.min(j + K, n); // take as much as possible on right\\n\\n                {\\n                    let SE = memo[iplusK][jplusK];\\n                    let NE = memo[iminusK][jplusK];\\n                    let SW = memo[iplusK][jminusK];\\n                    let NW = memo[iminusK][jminusK];\\n\\n                    M[i - 1][j - 1] = SE - (NE + SW - NW);\\n                }\\n            }\\n        }\\n\\n        return M;\\n    }\\n}\\n\\nvar matrixBlockSum = function (M, K) {\\n    let dp = new DP();\\n    return dp.matrixBlockSum(M, K);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250670,
                "title": "easy-solution-using-prefix-sum-dp",
                "content": "```\\nclass Solution {\\n\\n    int query(vector<vector<int>>& dp, int sr , int sc , int er , int ec)\\n    {\\n        if(sr == 0 && sc != 0)\\n            return dp[er][ec] - dp[er][sc-1];\\n        if(sr != 0 && sc == 0)\\n            return dp[er][ec] - dp[sr-1][ec];\\n        if(sr == 0 && sc == 0)\\n            return dp[er][ec];\\n        else\\n            return dp[er][ec] - dp[er][sc-1] - dp[sr-1][ec] + dp[sr-1][sc-1];\\n           \\n    }\\n    \\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        vector<vector<int>>dp(n , vector<int>(m , 0))  , fin(n , vector<int>(m , 0));\\n        \\n        dp[0][0] = mat[0][0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i][0] = dp[i-1][0] + mat[i][0];\\n        }\\n        for(int j=1;j<m;j++)\\n        {\\n            dp[0][j] = dp[0][j-1] + mat[0][j];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] + mat[i][j] - dp[i-1][j-1];\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int sr , sc , er , ec;\\n                sr = max(0 , i-k);\\n                sc = max(0 , j-k);\\n                er = min(i+k , n-1);\\n                ec = min(j+k , m-1);\\n                fin[i][j] = query(dp , sr , sc , er , ec);\\n            }\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int query(vector<vector<int>>& dp, int sr , int sc , int er , int ec)\\n    {\\n        if(sr == 0 && sc != 0)\\n            return dp[er][ec] - dp[er][sc-1];\\n        if(sr != 0 && sc == 0)\\n            return dp[er][ec] - dp[sr-1][ec];\\n        if(sr == 0 && sc == 0)\\n            return dp[er][ec];\\n        else\\n            return dp[er][ec] - dp[er][sc-1] - dp[sr-1][ec] + dp[sr-1][sc-1];\\n           \\n    }\\n    \\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        vector<vector<int>>dp(n , vector<int>(m , 0))  , fin(n , vector<int>(m , 0));\\n        \\n        dp[0][0] = mat[0][0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i][0] = dp[i-1][0] + mat[i][0];\\n        }\\n        for(int j=1;j<m;j++)\\n        {\\n            dp[0][j] = dp[0][j-1] + mat[0][j];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1] + mat[i][j] - dp[i-1][j-1];\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int sr , sc , er , ec;\\n                sr = max(0 , i-k);\\n                sc = max(0 , j-k);\\n                er = min(i+k , n-1);\\n                ec = min(j+k , m-1);\\n                fin[i][j] = query(dp , sr , sc , er , ec);\\n            }\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242482,
                "title": "java-o-n-2-with-explanation",
                "content": "Basic idea is to calcualte the cumulative sum of each cell (i,j). Cumulative cell is sum of all cells in rectangular block -> (0, 0) to (i, j)\\nFor a given cell, cumulative cell (i, j) can be formed recursively as\\ncsum(i, j) = val(i, j) + csum(i - 1, j) + csum (i, j - 1) - csum(i - 1, j - 1);\\nWhy we are subtracting csum(i - 1, j - 1), reason is it is being added twice as part of csum(i - 1, j) and csum (i, j - 1)\\n\\nSay we performed above and created a 2d array of cumulative sums dp[][].\\n\\ndp[i][j] gives cumulative sum from (0,0) to (i, j)\\n\\nOnce we have cumulative sums, for each cell again we follow the same procedure. For given cell (i, j), all four corners at limit k are\\ntop left (i - k, j - k), top right (i - k, j + k), bottom left (i + k, j - k), bottom right (i + k, j + k)\\n\\nFor cell (i,j) answer is cumulative sum of rectangle (i - k, j - k) to (i + k, j + k). We can calculate the sum of this rectangle using the dp array we created. \\n\\nAnswer is cumulative sum of the rectangle (0, 0) to bottom right (i + k, j + k) - csum from (0,0) to top right (i - k - 1, j + k) - csum from (0,0) to bottom left (i + k, j - k - 1) + csum from (0,0) to (i - k - 1, j - k - 1).\\n\\nAgain why are we add csum from (0,0) to (i - k - 1, j - k - 1), cause it is removed twice once in csum from (0,0) to top right (i - k - 1, j + k) and then in csum from (0,0) to bottom left (i + k, j - k - 1)\\n\\n```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\tint m = mat.length, n = mat[0].length;\\n\\tint[][] dp = new int[m][n];\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0;j < n; j++){\\n\\t\\t\\tif(i > 0){\\n\\t\\t\\t\\tdp[i][j] += dp[i - 1][j];\\n\\t\\t\\t\\tif(j > 0){\\n\\t\\t\\t\\t\\tdp[i][j] -= dp[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(j > 0){\\n\\t\\t\\t\\tdp[i][j] += dp[i][j - 1];\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] += mat[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tint lri = Math.min(m - 1, i + k), lrj = Math.min(n - 1, j + k);\\n\\t\\t\\tint llj = Math.max(0, j - k);\\n\\t\\t\\tint uli = Math.max(0, i - k);\\n\\t\\t\\tmat[i][j] = dp[lri][lrj];\\n\\t\\t\\tif(llj - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] -= dp[lri][llj - 1];\\n\\t\\t\\t}\\n\\t\\t\\tif(uli - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] -= dp[uli - 1][lrj];\\n\\t\\t\\t}\\n\\t\\t\\tif(uli - 1 >= 0 && llj - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] += dp[uli - 1][llj - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mat;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] matrixBlockSum(int[][] mat, int k) {\\n\\tint m = mat.length, n = mat[0].length;\\n\\tint[][] dp = new int[m][n];\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0;j < n; j++){\\n\\t\\t\\tif(i > 0){\\n\\t\\t\\t\\tdp[i][j] += dp[i - 1][j];\\n\\t\\t\\t\\tif(j > 0){\\n\\t\\t\\t\\t\\tdp[i][j] -= dp[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(j > 0){\\n\\t\\t\\t\\tdp[i][j] += dp[i][j - 1];\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][j] += mat[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tint lri = Math.min(m - 1, i + k), lrj = Math.min(n - 1, j + k);\\n\\t\\t\\tint llj = Math.max(0, j - k);\\n\\t\\t\\tint uli = Math.max(0, i - k);\\n\\t\\t\\tmat[i][j] = dp[lri][lrj];\\n\\t\\t\\tif(llj - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] -= dp[lri][llj - 1];\\n\\t\\t\\t}\\n\\t\\t\\tif(uli - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] -= dp[uli - 1][lrj];\\n\\t\\t\\t}\\n\\t\\t\\tif(uli - 1 >= 0 && llj - 1 >= 0){\\n\\t\\t\\t\\tmat[i][j] += dp[uli - 1][llj - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn mat;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233629,
                "title": "python-with-prefix-sum-and-dp",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        \\n        \\n        for row in range(m):\\n            for col in range(n):\\n                if row == 0:\\n                    continue\\n                else:\\n                    mat[row][col] = mat[row-1][col] + mat[row][col]\\n                    \\n        for row in range(m):\\n            for col in range(n):\\n                if col == 0:\\n                    continue\\n                else:\\n                    mat[row][col] = mat[row][col-1] + mat[row][col]\\n    \\n        ans = [[0] * n for _ in range(m)]\\n        \\n        for row in range(m):\\n            for col in range(n):\\n                n_row = min(row + k, m - 1)\\n                n_col = min(col + k, n - 1)\\n                right_top_row = row - k - 1\\n                right_top_col = n_col\\n                \\n                left_bot_row = n_row\\n                left_bot_col = col - k - 1\\n                \\n                left_top_row = row - k - 1\\n                left_top_col = col - k - 1\\n                \\n                target_val = mat[n_row][n_col]\\n                right_top = 0\\n                left_bot = 0\\n                left_top = 0\\n                \\n                if right_top_row >= 0:\\n                    right_top = mat[right_top_row][right_top_col]\\n                    \\n                if left_bot_col >= 0:\\n                    left_bot = mat[left_bot_row][left_bot_col]\\n                    \\n                if left_top_row >= 0 and left_top_col >= 0:\\n                    left_top = mat[left_top_row][left_top_col]\\n                    \\n                ans[row][col] = target_val - right_top - left_bot + left_top\\n        return ans\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        \\n        \\n        for row in range(m):\\n            for col in range(n):\\n                if row == 0:\\n                    continue\\n                else:\\n                    mat[row][col] = mat[row-1][col] + mat[row][col]\\n                    \\n        for row in range(m):\\n            for col in range(n):\\n                if col == 0:\\n                    continue\\n                else:\\n                    mat[row][col] = mat[row][col-1] + mat[row][col]\\n    \\n        ans = [[0] * n for _ in range(m)]\\n        \\n        for row in range(m):\\n            for col in range(n):\\n                n_row = min(row + k, m - 1)\\n                n_col = min(col + k, n - 1)\\n                right_top_row = row - k - 1\\n                right_top_col = n_col\\n                \\n                left_bot_row = n_row\\n                left_bot_col = col - k - 1\\n                \\n                left_top_row = row - k - 1\\n                left_top_col = col - k - 1\\n                \\n                target_val = mat[n_row][n_col]\\n                right_top = 0\\n                left_bot = 0\\n                left_top = 0\\n                \\n                if right_top_row >= 0:\\n                    right_top = mat[right_top_row][right_top_col]\\n                    \\n                if left_bot_col >= 0:\\n                    left_bot = mat[left_bot_row][left_bot_col]\\n                    \\n                if left_top_row >= 0 and left_top_col >= 0:\\n                    left_top = mat[left_top_row][left_top_col]\\n                    \\n                ans[row][col] = target_val - right_top - left_bot + left_top\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1228090,
                "title": "concise-solution-c-98-faster-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int left = (j==0) ? 0 : mat[i][j-1]; //top rectangle\\n                int top = (i==0) ? 0 : mat[i-1][j]; //left rectangle\\n                int diag = (i==0 || j==0) ? 0 : mat[i-1][j-1]; // top-left square\\n                mat[i][j] += left + top - diag;\\n            }\\n        }\\n        vector<vector<int>>ans(n, vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int i1 = max(i-k,0) , j1 = max(j-k,0);    // top indices\\n                int i2 = min(i+k,n-1) , j2 = min(j+k,m-1);  // bottom indices\\n                \\n                int left = (j1==0) ? 0 : mat[i2][j1-1];\\n                int top = (i1==0) ? 0 : mat[i1-1][j2];\\n                int diag = (i1==0 || j1==0) ? 0 : mat[i1-1][j1-1];\\n                ans[i][j] = mat[i2][j2] - top - left + diag;    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int left = (j==0) ? 0 : mat[i][j-1]; //top rectangle\\n                int top = (i==0) ? 0 : mat[i-1][j]; //left rectangle\\n                int diag = (i==0 || j==0) ? 0 : mat[i-1][j-1]; // top-left square\\n                mat[i][j] += left + top - diag;\\n            }\\n        }\\n        vector<vector<int>>ans(n, vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int i1 = max(i-k,0) , j1 = max(j-k,0);    // top indices\\n                int i2 = min(i+k,n-1) , j2 = min(j+k,m-1);  // bottom indices\\n                \\n                int left = (j1==0) ? 0 : mat[i2][j1-1];\\n                int top = (i1==0) ? 0 : mat[i1-1][j2];\\n                int diag = (i1==0 || j1==0) ? 0 : mat[i1-1][j1-1];\\n                ans[i][j] = mat[i2][j2] - top - left + diag;    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189786,
                "title": "c-easy-understanding",
                "content": "```\\n vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int rows=mat.size(),col=mat[0].size();\\n        vector<vector<int>> ans(rows+1,vector<int>(col+1,0));\\n        for(int i=1;i<rows+1;i++)\\n            for(int j=1;j<col+1;j++)\\n                ans[i][j]=mat[i-1][j-1]+ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];\\n        for(int i=1;i<rows+1;i++)\\n            for(int j=1;j<col+1;j++)\\n            {\\n                int minRow =i-k-1>0?i-k-1:0;\\n                int maxRow=i+k<rows?i+k:rows;\\n                int minCol= j-k-1>0?j-k-1:0;\\n                int maxCol=j+k<col?j+k:col;\\n                 mat[i-1][j-1]=ans[minRow][minCol]+ans[maxRow][maxCol]-ans[minRow][maxCol]-ans[maxRow][minCol];\\n            }\\n        return mat;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int rows=mat.size(),col=mat[0].size();\\n        vector<vector<int>> ans(rows+1,vector<int>(col+1,0));\\n        for(int i=1;i<rows+1;i++)\\n            for(int j=1;j<col+1;j++)\\n                ans[i][j]=mat[i-1][j-1]+ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];\\n        for(int i=1;i<rows+1;i++)\\n            for(int j=1;j<col+1;j++)\\n            {\\n                int minRow =i-k-1>0?i-k-1:0;\\n                int maxRow=i+k<rows?i+k:rows;\\n                int minCol= j-k-1>0?j-k-1:0;\\n                int maxCol=j+k<col?j+k:col;\\n                 mat[i-1][j-1]=ans[minRow][minCol]+ans[maxRow][maxCol]-ans[minRow][maxCol]-ans[maxRow][minCol];\\n            }\\n        return mat;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166550,
                "title": "c-short-prefix-sum",
                "content": "Area of shaded region = Area till region 1 - Area 2 - Area 3 + Area 4\\n[Note : region 2 and 3 are squares including region 4]\\n![image](https://assets.leetcode.com/users/images/280e9e1d-ef56-442f-b2f1-695e65e3066b_1618842951.4908242.png)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int r = mat.size(), c = mat[0].size();\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        vector<vector<int>> arr = mat;\\n        \\n        for(int i=0; i<r-1; i++)\\n            arr[i+1][0] += arr[i][0]; \\n        \\n        for(int j=0; j<c-1; j++)\\n            arr[0][j+1] += arr[0][j];\\n        \\n        for(int i=1; i<r; i++)\\n            for(int j=1; j<c; j++)\\n                arr[i][j] = arr[i-1][j] + arr[i][j-1] + arr[i][j] - arr[i-1][j-1];\\n        \\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++){\\n                int lr = min(i+k, r-1), lc = min(j+k, c-1), ur=max(0, i-k-1), uc = max(0, j-k-1);\\n                res[i][j] = arr[lr][lc] - ((i-k-1>=0) ? arr[i-k-1][lc]:0) - ((j-k-1>=0) ? arr[lr][j-k-1]:0) + ((i-k-1>=0 && j-k-1>=0) ? arr[i-k-1][j-k-1]:0);\\n            }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n        int r = mat.size(), c = mat[0].size();\\n        vector<vector<int>> res(r, vector<int>(c, 0));\\n        vector<vector<int>> arr = mat;\\n        \\n        for(int i=0; i<r-1; i++)\\n            arr[i+1][0] += arr[i][0]; \\n        \\n        for(int j=0; j<c-1; j++)\\n            arr[0][j+1] += arr[0][j];\\n        \\n        for(int i=1; i<r; i++)\\n            for(int j=1; j<c; j++)\\n                arr[i][j] = arr[i-1][j] + arr[i][j-1] + arr[i][j] - arr[i-1][j-1];\\n        \\n        for(int i=0; i<r; i++)\\n            for(int j=0; j<c; j++){\\n                int lr = min(i+k, r-1), lc = min(j+k, c-1), ur=max(0, i-k-1), uc = max(0, j-k-1);\\n                res[i][j] = arr[lr][lc] - ((i-k-1>=0) ? arr[i-k-1][lc]:0) - ((j-k-1>=0) ? arr[lr][j-k-1]:0) + ((i-k-1>=0 && j-k-1>=0) ? arr[i-k-1][j-k-1]:0);\\n            }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157753,
                "title": "python-matrix-row-col-prefix-solution",
                "content": "class Solution:\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        def prefix_sum(mat):\\n\\n            ans = []\\n\\n            for i in range(len(mat)):\\n\\n                temp = []\\n\\n                for j in range(len(mat[0])):\\n\\n                    if not temp:\\n\\n                        temp.append(mat[i][j])\\n\\n                    else:\\n                        temp.append(mat[i][j] + temp[-1])\\n\\n                ans.append(temp)\\n\\n            return ans\\n\\n\\n        def prefix_col(mat):\\n\\n            for i in range(1,len(mat)):\\n\\n                for j in  range(len(mat[0])):\\n\\n                    mat[i][j] += mat[i-1][j]\\n\\n            return mat\\n\\n        def find_sum(x2,y2,x1,y1,mat):\\n\\n            x2,y2 = min(len(mat)-1,x2),min(len(mat[0])-1,y2)\\n            x1,y1 = max(x1,0),max(y1,0)\\n\\n            sm = mat[x2][y2]\\n\\n            if x1-1 >= 0:\\n                sm -= mat[x1-1][y2]\\n\\n            if y1-1 >= 0:\\n                sm -= mat[x2][y1-1]\\n\\n            if x1-1 >=0 and y1-1 >=0:\\n                sm += mat[x1-1][y1-1]\\n\\n            return sm\\n\\n\\n        def block_sum(mat,k):\\n\\n            ans = []\\n\\n            for i in range(len(mat)):\\n\\n                temp = []\\n\\n                for j in range(len(mat[0])):\\n\\n                    temp.append(find_sum(i+k,j+k,i-k,j-k,mat))\\n\\n                ans.append(temp)\\n\\n            return ans\\n        \\n\\n        ult_mat = prefix_col(prefix_sum(mat))\\n        return block_sum(ult_mat,K)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        \\n        def prefix_sum(mat):\\n\\n            ans = []\\n\\n            for i in range(len(mat)):\\n\\n                temp = []\\n\\n                for j in range(len(mat[0])):\\n\\n                    if not temp:\\n\\n                        temp.append(mat[i][j])\\n\\n                    else:\\n                        temp.append(mat[i][j] + temp[-1])\\n\\n                ans.append(temp)\\n\\n            return ans\\n\\n\\n        def prefix_col(mat):\\n\\n            for i in range(1,len(mat)):\\n\\n                for j in  range(len(mat[0])):\\n\\n                    mat[i][j] += mat[i-1][j]\\n\\n            return mat\\n\\n        def find_sum(x2,y2,x1,y1,mat):\\n\\n            x2,y2 = min(len(mat)-1,x2),min(len(mat[0])-1,y2)\\n            x1,y1 = max(x1,0),max(y1,0)\\n\\n            sm = mat[x2][y2]\\n\\n            if x1-1 >= 0:\\n                sm -= mat[x1-1][y2]\\n\\n            if y1-1 >= 0:\\n                sm -= mat[x2][y1-1]\\n\\n            if x1-1 >=0 and y1-1 >=0:\\n                sm += mat[x1-1][y1-1]\\n\\n            return sm\\n\\n\\n        def block_sum(mat,k):\\n\\n            ans = []\\n\\n            for i in range(len(mat)):\\n\\n                temp = []\\n\\n                for j in range(len(mat[0])):\\n\\n                    temp.append(find_sum(i+k,j+k,i-k,j-k,mat))\\n\\n                ans.append(temp)\\n\\n            return ans\\n        \\n\\n        ult_mat = prefix_col(prefix_sum(mat))\\n        return block_sum(ult_mat,K)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1138023,
                "title": "simple-dp-solution",
                "content": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        pre_sum = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                pre_sum[i][j] = mat[i-1][j-1]+pre_sum[i-1][j]+pre_sum[i][j-1]-pre_sum[i-1][j-1]\\n        ans = [[0]*n for _ in range(m)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                start_r = max(i-K, 1)\\n                start_c = max(j-K, 1)\\n                end_r = min(i+K, m)\\n                end_c = min(j+K, n)\\n                ans[i-1][j-1] = pre_sum[end_r][end_c] - pre_sum[start_r-1][end_c] - pre_sum[end_r][start_c-1] + pre_sum[start_r-1][start_c-1]\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        pre_sum = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                pre_sum[i][j] = mat[i-1][j-1]+pre_sum[i-1][j]+pre_sum[i][j-1]-pre_sum[i-1][j-1]\\n        ans = [[0]*n for _ in range(m)]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                start_r = max(i-K, 1)\\n                start_c = max(j-K, 1)\\n                end_r = min(i+K, m)\\n                end_c = min(j+K, n)\\n                ans[i-1][j-1] = pre_sum[end_r][end_c] - pre_sum[start_r-1][end_c] - pre_sum[end_r][start_c-1] + pre_sum[start_r-1][start_c-1]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1133196,
                "title": "c-dynamic-solved-with-design-class",
                "content": "```\\n// Help Class to do calculation\\n/* Idea is to calculate area. which can be calculated with formula\\n\\t   Sum(ABCD)=Sum(OD)\\u2212Sum(OB)\\u2212Sum(OC)+Sum(OA)\\n\\t   For example we have this matrix\\n\\t\\tO--|--|--|--|--|\\n\\t\\t|--|--A--|--|--B\\n\\t\\t|--|--|--|--|--|\\n\\t\\t|--|--|--|--|--|\\n\\t\\t|--|--C--|--|--D */\\nclass MatrixManipulation {\\n\\tpublic:\\n\\t\\tvector<vector<pair<int,int>>> matrix;\\n\\n\\t\\tMatrixManipulation(vector<vector<int>>& matrix) {\\n\\t\\t\\t/* Init matrix with prefix sum. I used pair because we may need the original numbers of the matrix. Not in this problem but generally*/\\n\\t\\t\\tif (matrix.size() == 0 || matrix[0].size() == 0) return;\\n\\t        for (int i = 0; i < matrix.size(); i++) {\\n\\t            int liniarSum = 0;\\n\\t            vector<pair<int,int>> v;\\n\\n\\t            for (int j = 0; j < matrix[i].size(); j++) {\\n\\t                liniarSum += matrix[i][j];\\n\\t                if (i != 0) {\\n\\t                    pair<int,int> inter = {matrix[i][j], liniarSum + this->matrix[i-1][j].second};\\n\\t                    v.push_back(inter);\\n\\t                } else {\\n\\t                    pair<int,int> inter = {matrix[i][j], liniarSum};\\n\\t                    v.push_back(inter);\\n\\t                }\\n\\t            }\\n\\t            this->matrix.push_back(v);\\n\\t        }\\n\\t\\t}\\n\\n\\t\\tint sumRegion(int row1, int col1, int row2, int col2) {\\n\\t        int completArea = this->matrix[row2][col2].second;  // Sum(OD) is from (0,0) -> (row2, col2); \\n\\t        int top = 0; \\t\\t\\t\\t\\t\\t\\t\\t\\t   // SUM(OB);\\n\\t        int left = 0; \\t\\t\\t\\t\\t\\t\\t\\t\\t  // SUM(OC)\\n\\t        int duplicate = 0;\\n\\t        if (row1 != 0) { \\t\\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            top = this->matrix[row1-1][col2].second; // SUM(OB) is from (0,0) -> (row1-1, col2);\\n\\t        }\\n\\t        if (col1 != 0) { \\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            left = this->matrix[row2][col1-1].second; // SUM(OC) is from (0,0) -> (row2, col1-1);\\n\\t        }\\n\\t        if (row1 != 0 && col1 != 0) {\\n\\t        \\t\\t\\t\\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            duplicate = this->matrix[row1-1][col1-1].second; // SUM(OA) if from (0,0) -> (row1-1, col1 - 1);\\n\\t            /* duplicate is 2 times extract from area because of top and left. This part is intersection part of this 2 area \\n\\t               that\\'s why is needed to add it back. */\\n\\t        } \\n\\t        return completArea - top - left + duplicate; \\n\\t    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        // Preparing matrix to work with.\\n        MatrixManipulation matrix(mat);\\n        std::vector<std::vector<int>> ans;\\n        int vertical = mat.size() - 1;\\n        int horizontal = mat[0].size() - 1;\\n        for(int i = 0; i < mat.size(); i++) {\\n            std::vector<int> v;\\n            for(int j = 0; j < mat[i].size(); j++) {\\n                // Init left top corner\\n                int verticalTopLeft = i - K;\\n                int horizontalTopLeft = j - K;\\n\\n                // Init right bottom corner\\n                int verticalBottRight = i + K;\\n                int horizontalBottRight = j + K;\\n\\n                if (verticalTopLeft < 0) {\\n                    verticalTopLeft = 0;\\n                }\\n\\n                if (horizontalTopLeft < 0) {\\n                    horizontalTopLeft = 0;\\n                }\\n\\n                if (verticalBottRight > vertical) {\\n                    verticalBottRight = vertical;\\n                }\\n\\n                if(horizontalBottRight > horizontal) {\\n                    horizontalBottRight = horizontal;\\n                }\\n                v.push_back(matrix.sumRegion(verticalTopLeft, horizontalTopLeft, verticalBottRight, horizontalBottRight));\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Help Class to do calculation\\n/* Idea is to calculate area. which can be calculated with formula\\n\\t   Sum(ABCD)=Sum(OD)\\u2212Sum(OB)\\u2212Sum(OC)+Sum(OA)\\n\\t   For example we have this matrix\\n\\t\\tO--|--|--|--|--|\\n\\t\\t|--|--A--|--|--B\\n\\t\\t|--|--|--|--|--|\\n\\t\\t|--|--|--|--|--|\\n\\t\\t|--|--C--|--|--D */\\nclass MatrixManipulation {\\n\\tpublic:\\n\\t\\tvector<vector<pair<int,int>>> matrix;\\n\\n\\t\\tMatrixManipulation(vector<vector<int>>& matrix) {\\n\\t\\t\\t/* Init matrix with prefix sum. I used pair because we may need the original numbers of the matrix. Not in this problem but generally*/\\n\\t\\t\\tif (matrix.size() == 0 || matrix[0].size() == 0) return;\\n\\t        for (int i = 0; i < matrix.size(); i++) {\\n\\t            int liniarSum = 0;\\n\\t            vector<pair<int,int>> v;\\n\\n\\t            for (int j = 0; j < matrix[i].size(); j++) {\\n\\t                liniarSum += matrix[i][j];\\n\\t                if (i != 0) {\\n\\t                    pair<int,int> inter = {matrix[i][j], liniarSum + this->matrix[i-1][j].second};\\n\\t                    v.push_back(inter);\\n\\t                } else {\\n\\t                    pair<int,int> inter = {matrix[i][j], liniarSum};\\n\\t                    v.push_back(inter);\\n\\t                }\\n\\t            }\\n\\t            this->matrix.push_back(v);\\n\\t        }\\n\\t\\t}\\n\\n\\t\\tint sumRegion(int row1, int col1, int row2, int col2) {\\n\\t        int completArea = this->matrix[row2][col2].second;  // Sum(OD) is from (0,0) -> (row2, col2); \\n\\t        int top = 0; \\t\\t\\t\\t\\t\\t\\t\\t\\t   // SUM(OB);\\n\\t        int left = 0; \\t\\t\\t\\t\\t\\t\\t\\t\\t  // SUM(OC)\\n\\t        int duplicate = 0;\\n\\t        if (row1 != 0) { \\t\\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            top = this->matrix[row1-1][col2].second; // SUM(OB) is from (0,0) -> (row1-1, col2);\\n\\t        }\\n\\t        if (col1 != 0) { \\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            left = this->matrix[row2][col1-1].second; // SUM(OC) is from (0,0) -> (row2, col1-1);\\n\\t        }\\n\\t        if (row1 != 0 && col1 != 0) {\\n\\t        \\t\\t\\t\\t\\t\\t\\t\\t\\t  // to avoid index out of bounds.\\n\\t            duplicate = this->matrix[row1-1][col1-1].second; // SUM(OA) if from (0,0) -> (row1-1, col1 - 1);\\n\\t            /* duplicate is 2 times extract from area because of top and left. This part is intersection part of this 2 area \\n\\t               that\\'s why is needed to add it back. */\\n\\t        } \\n\\t        return completArea - top - left + duplicate; \\n\\t    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int K) {\\n        // Preparing matrix to work with.\\n        MatrixManipulation matrix(mat);\\n        std::vector<std::vector<int>> ans;\\n        int vertical = mat.size() - 1;\\n        int horizontal = mat[0].size() - 1;\\n        for(int i = 0; i < mat.size(); i++) {\\n            std::vector<int> v;\\n            for(int j = 0; j < mat[i].size(); j++) {\\n                // Init left top corner\\n                int verticalTopLeft = i - K;\\n                int horizontalTopLeft = j - K;\\n\\n                // Init right bottom corner\\n                int verticalBottRight = i + K;\\n                int horizontalBottRight = j + K;\\n\\n                if (verticalTopLeft < 0) {\\n                    verticalTopLeft = 0;\\n                }\\n\\n                if (horizontalTopLeft < 0) {\\n                    horizontalTopLeft = 0;\\n                }\\n\\n                if (verticalBottRight > vertical) {\\n                    verticalBottRight = vertical;\\n                }\\n\\n                if(horizontalBottRight > horizontal) {\\n                    horizontalBottRight = horizontal;\\n                }\\n                v.push_back(matrix.sumRegion(verticalTopLeft, horizontalTopLeft, verticalBottRight, horizontalBottRight));\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120894,
                "title": "c-o-n-m-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n    \\n        if(mat.empty())\\n            return {};\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        for(int i=1;i<n;i++)\\n            mat[i][0] += mat[i-1][0];\\n        \\n        for(int j=1;j<m;j++)\\n            mat[0][j] += mat[0][j-1];\\n        \\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++)\\n                mat[i][j] += mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1];\\n        }\\n        \\n        vector<vector<int> >res(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                \\n                int upI = min(n-1,i+k);\\n                int upJ = min(m-1,j+k);\\n                \\n                res[i][j] = mat[upI][upJ];\\n                \\n                if(j-k-1 >= 0)\\n                    res[i][j] -= mat[upI][j-k-1];\\n                \\n                if(i-k-1 >= 0)\\n                    res[i][j] -= mat[i-k-1][upJ];\\n                \\n                if(j-k-1 >= 0 && i-k-1 >= 0)\\n                    res[i][j] += mat[i-k-1][j-k-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {\\n    \\n        if(mat.empty())\\n            return {};\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        for(int i=1;i<n;i++)\\n            mat[i][0] += mat[i-1][0];\\n        \\n        for(int j=1;j<m;j++)\\n            mat[0][j] += mat[0][j-1];\\n        \\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++)\\n                mat[i][j] += mat[i-1][j] + mat[i][j-1] - mat[i-1][j-1];\\n        }\\n        \\n        vector<vector<int> >res(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                \\n                int upI = min(n-1,i+k);\\n                int upJ = min(m-1,j+k);\\n                \\n                res[i][j] = mat[upI][upJ];\\n                \\n                if(j-k-1 >= 0)\\n                    res[i][j] -= mat[upI][j-k-1];\\n                \\n                if(i-k-1 >= 0)\\n                    res[i][j] -= mat[i-k-1][upJ];\\n                \\n                if(j-k-1 >= 0 && i-k-1 >= 0)\\n                    res[i][j] += mat[i-k-1][j-k-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564684,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1832600,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1566925,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1575426,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1844400,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1790606,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1574294,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1929781,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1724000,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1720905,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1564684,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1832600,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1566925,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1575426,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1844400,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1790606,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1574294,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1929781,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1724000,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            },
            {
                "id": 1720905,
                "content": [
                    {
                        "username": "KevBear",
                        "content": "Yeah, so I\\'m obviously a newbie but I\\'m happy I was able to get the first question done in the contest! It\\'s the first time I got the first question done.\\nThis question though is confusing. The hardest thing I\\'m finding is that I don\\'t even understand what this is asking for. Does anyone have that issue where the question itself is confusing?\\n\\nPlease tell me this is normal for newbies and you all experienced this before! :-)"
                    },
                    {
                        "username": "Balgur",
                        "content": "I\\'ve answered 200+ questions and I can\\'t figure out what its asking without looking elsewhere."
                    },
                    {
                        "username": "dotexe3301",
                        "content": "tell me your approach , how you solve it\\n\\ni am also a newbie but unable to making a logic behind it,\\n\\n:-)"
                    },
                    {
                        "username": "jekatigr",
                        "content": "Just some visualization for `k=2`:\\n\\n<img src=\"https://user-images.githubusercontent.com/2889932/225158952-9e70409d-207f-44d3-a7de-274b2d7a0b92.png\" height=\"2000\" width=\"350\" />\\n\\nsum(7) = 117\\nsum(37) = 750\\nsum(53) = 1325"
                    },
                    {
                        "username": "Balgur",
                        "content": "Thanks, I figured the question was asking something like this but I couldn\\'t figure it out from just reading it."
                    },
                    {
                        "username": "ashish15678",
                        "content": "thanks bro (\\u2310\\u25A0_\\u25A0)"
                    },
                    {
                        "username": "ashishkumarguptacse",
                        "content": "hey , can anyone explain me this question ?"
                    },
                    {
                        "username": "Balgur",
                        "content": "I think this visual helps.\\n\\nhttps://leetcode.com/problems/matrix-block-sum/description/comments/1832600"
                    },
                    {
                        "username": "ConvexChull",
                        "content": "If i were to go 3 weeks back i remember cursing  these matrix sum type dynamic programming question  So i understand the pain.\\n\\nYou should know only one concept  for these type of questions that is -\\n\\n* You should know how to do prefix sum  on 2D array .\\n* Using paper/white board drawing as there is a lot of adding and subtraction of squares here and there and proper visulaization HELPS A LOT.\\n\\nThere are a lot of good resources out there on net  so no need for me to explain it here . \\n\\nAfter learning  and implementing it by yourself  then try to solve \\n\\n\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nthen try matrix block sum .\\n\\nHope it helps\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The linked problem is very helpful, thank you!!"
                    },
                    {
                        "username": "Msey",
                        "content": "if Google would ask me this question some day I will ask them to put it to Google translate first"
                    },
                    {
                        "username": "aadarshgupta10082002",
                        "content": "very good Question on the bsis of Indices and  Time Complexity."
                    },
                    {
                        "username": "adarshprince95",
                        "content": "yes"
                    },
                    {
                        "username": "claverru",
                        "content": "This is just a convolution with:\\n* `Filter F[k, k] = 1 `for all `k in [0, 2*K+1)`\\n* Same padding (half padding).\\n* Stride 1."
                    },
                    {
                        "username": "ryuichist",
                        "content": "what a boring and tedious question. what\\'s the point of it?"
                    },
                    {
                        "username": "District_12",
                        "content": "The point is that bruteforce solution is super slow."
                    },
                    {
                        "username": "no-username",
                        "content": "All the solutions I see talk about prefix sum on 2D array. I understand how to use prefix sum and it will help to compute answer for bottom right cell. So prefix sum looks at only cells which are in top left part of matrix. Which is correct for bottom right cell because it is the end of matrix. So no need to consider cells which are below bottom right. However, cells which are are in center, all four sides have cells which we need to count. If we just use prefix sum, why do we get correct answer? "
                    },
                    {
                        "username": "xeniawann",
                        "content": "We can still use prefix sum, just need to consider some overlapping/intersection. The pictures in this official solution explain it well: https://leetcode.com/problems/range-sum-query-2d-immutable/solutions/127813/range-sum-query-2d-immutable/\\nYou can just look at the pictures, no need to read other text."
                    },
                    {
                        "username": "RootOfMinus1",
                        "content": "Bro why would you use a jagged array instead of a 2d array (especially in C#) \\uD83E\\uDD26"
                    }
                ]
            }
        ]
    },
    {
        "title": "Swapping Nodes in a Linked List",
        "question_content": "<p>You are given the <code>head</code> of a linked list, and an integer <code>k</code>.</p>\n\n<p>Return <em>the head of the linked list after <strong>swapping</strong> the values of the </em><code>k<sup>th</sup></code> <em>node from the beginning and the </em><code>k<sup>th</sup></code> <em>node from the end (the list is <strong>1-indexed</strong>).</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/linked1.jpg\" style=\"width: 400px; height: 112px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 2\n<strong>Output:</strong> [1,4,3,2,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [7,9,6,6,7,8,3,0,9,5], k = 5\n<strong>Output:</strong> [7,9,6,6,8,7,3,0,9,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1009800,
                "title": "c-j-p3-one-pass",
                "content": "> **Important:** The problem description specifically asks to swap values, not nodes themselves. \\n\\nWhen we reach `k`-th node, we set `n1` to the current node, and `n2` - to the head.\\n\\nWe continue traversing the list, but now we also move `n2`. When we reach the end, `n2` will points to `k`-th node from end.\\n**C++**\\n> **Important:** The problem description specifically asks to swap values, not nodes themselves. \\n> ... because many folks do not read/miss the note above above...\\n```cpp\\nListNode* swapNodes(ListNode* head, int k) {\\n    ListNode *n1 = nullptr, *n2 = nullptr;\\n    for (auto p = head; p != nullptr; p = p->next) {\\n        n2 = n2 == nullptr ? nullptr : n2->next;\\n        if (--k == 0) {\\n            n1 = p;\\n            n2 = head;\\n        }\\n    }\\n\\t// The problem description specifically asks to swap values, not nodes themselves. \\n    swap(n1->val, n2->val);\\n    return head;\\n}\\n```\\n**Java**\\n> **Important:** The problem description specifically asks to swap values, not nodes themselves. \\n> ... yeah, again - will also add this note for the Python solution below...\\n```java\\npublic ListNode swapNodes(ListNode head, int k) {\\n    ListNode n1 = null, n2 = null;\\n    for (var p = head; p != null; p = p.next) {\\n        n2 = n2 == null ? null : n2.next;\\n        if (--k == 0) {\\n            n1 = p;\\n            n2 = head;\\n        }\\n    }\\n\\t// The problem description specifically asks to swap values, not nodes themselves. \\n    var tmp = n1.val;\\n    n1.val = n2.val;\\n    n2.val = tmp;\\n    return head;\\n}\\n```\\n**Python 3**\\n> **Important:** The problem description specifically asks to swap values, not nodes themselves. \\n> ... I love you, Python folk...\\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        n1, n2, p = None, None, head\\n        while p is not None:\\n            k -= 1\\n            n2 = None if n2 == None else n2.next\\n            if k == 0:\\n                n1 = p\\n                n2 = head\\n            p = p.next\\n\\t\\t# The problem description specifically asks to swap values, not nodes themselves. \\n        n1.val, n2.val = n2.val, n1.val\\n        return head\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* swapNodes(ListNode* head, int k) {\\n    ListNode *n1 = nullptr, *n2 = nullptr;\\n    for (auto p = head; p != nullptr; p = p->next) {\\n        n2 = n2 == nullptr ? nullptr : n2->next;\\n        if (--k == 0) {\\n            n1 = p;\\n            n2 = head;\\n        }\\n    }\\n\\t// The problem description specifically asks to swap values, not nodes themselves. \\n    swap(n1->val, n2->val);\\n    return head;\\n}\\n```\n```java\\npublic ListNode swapNodes(ListNode head, int k) {\\n    ListNode n1 = null, n2 = null;\\n    for (var p = head; p != null; p = p.next) {\\n        n2 = n2 == null ? null : n2.next;\\n        if (--k == 0) {\\n            n1 = p;\\n            n2 = head;\\n        }\\n    }\\n\\t// The problem description specifically asks to swap values, not nodes themselves. \\n    var tmp = n1.val;\\n    n1.val = n2.val;\\n    n2.val = tmp;\\n    return head;\\n}\\n```\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        n1, n2, p = None, None, head\\n        while p is not None:\\n            k -= 1\\n            n2 = None if n2 == None else n2.next\\n            if k == 0:\\n                n1 = p\\n                n2 = head\\n            p = p.next\\n\\t\\t# The problem description specifically asks to swap values, not nodes themselves. \\n        n1.val, n2.val = n2.val, n1.val\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054370,
                "title": "python-3-swapping-nodes-swapping-values-one-pass-fully-explained",
                "content": "# Swapping Values \\n**This question can be very easily solved if we only swap the value in the nodes. Follow the bellow steps to swap the values :-**\\n1. Find the k-th node from the front.\\n2. Find the k-th last element using two poiners method.\\n3. Swap their values.\\n4. Return the head of the Linked List\\n\\n**CODE-** \\n```\\ndef swapNodes(self, head: ListNode, k: int) -> ListNode:\\n\\tfirst = last = head\\n\\tfor i in range(1, k):\\n\\t\\tfirst = first.next\\n\\t\\t\\n\\tnull_checker = first \\n\\twhile null_checker.next:\\n\\t\\tlast = last.next\\n\\t\\tnull_checker = null_checker.next\\n\\tfirst.val, last.val = last.val, first.val\\n\\treturn head\\n```\\n\\n________________________________________________________________________\\n\\n# Swapping Nodes\\n**Here, the very first step will be to find the K-th first and K-th last nodes.** \\nWhile doing so, we also need to store the addresses of previous nodes of the K-th first and K-th last nodes in two poiners. \\n\\nTo make it less confusing, here\\'s a breakdown.\\n`left `=  Kth node of the Linked List\\n`pre_left`= the previous node to `left`\\n`right` = Kth node of the LinkedList from the end\\n`pre_right` = the previous node to `right`\\n\\n![image](https://assets.leetcode.com/users/images/17d4544d-3878-4b66-8174-24bac3042bf7_1612680483.3206403.png)\\n*The above image illustrates for K=2*\\n\\nNow we need to swap node `left` with node `right`.\\n\\nLet\\'s do it in 2 simple steps -\\n\\n![image](https://assets.leetcode.com/users/images/ba2d57fa-fcde-473f-b84b-d46769b52154_1612683694.1706145.png)\\n\\n - Assign `right` and `left` to `pre_left.next` and `pre_right.next` respectively. \\n\\n![image](https://assets.leetcode.com/users/images/34bd70d8-dd79-4115-bad4-82f6168a5ce7_1612683839.3985584.png)\\n- Swap `left.next` and `right.next`\\n\\n\\n**Finally the list should look like this**\\n![image](https://assets.leetcode.com/users/images/7d976691-1298-4b5b-831e-8efdb94680b2_1612686128.0938554.png)\\n\\n\\nNow that we have visualized the basic idea behind swapping the Nodes, let\\'s address **the elephant in the room**.\\n\\nYou see, I have never mentioned how we\\'ll be initializing the `pre_left` and `pre_right` variables or infact any variables. In case of `left` and `right`, we\\'ll initialize them with the address of head. `left=right=head` will do the job. Now comming to the `pre_left` and `pre_right`.\\n\\nIf we initialize them with `None`, the code wont give correct results for k=1.\\nThis is because `left` will point to the head of the linked list and `pre_left` will point to `None`. We won\\'t be able to perform step 1 of swapping the nodes as `pre_left.next` will be an invalid statement.\\n\\nTo solve this issue, we can introduce a dummy node whose next will point to the head of the linked list. Something like this,\\n![image](https://assets.leetcode.com/users/images/9b525520-3c34-433e-a4e8-062b66299166_1612691138.129771.png)\\n\\nOnce we\\'re done with creating the dummy node and initializing appropriately, we can go back to finding the K-th and K-th last nodes in the list.\\n![image](https://assets.leetcode.com/users/images/12da8bbf-9e41-4a5e-bb90-1c355f7cdecf_1612691326.0675864.png)\\n \\n Now perform **step 1 of swapping** `left` and `right`\\n ![image](https://assets.leetcode.com/users/images/8ef6918a-cc15-4ceb-81a2-a19cc3f7b1e8_1612693251.2216604.png)\\n\\n **Step 2 of swapping**\\n ![image](https://assets.leetcode.com/users/images/79ca2971-48aa-47de-8ccf-7873b487bb62_1612693391.5791454.png)\\n *NOTE - Node 1 is pointing to `None` because `right.next` was pointing to `None`.*\\n \\n Also **keep in mind** that in cases where `k` points to the middle element of the LinkedList, i.e where `left == right`, return back the head of the LinkedList. The following image illustrates what i\\'m trying to say.\\n \\n![image](https://assets.leetcode.com/users/images/47a4f615-4fce-492a-b900-9ba557a0df86_1612694263.041833.png)\\nIn such a cases there is no need to perform any swapping of nodes. Simply return the head or `dummy.next`.\\n \\n **And we are done!**\\nUsing the dummy node will always give the correct result. Return back `dummy.next` instead of `head` as it\\'ll always point to the starting node.\\n \\n **CODE**\\n \\n\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        dummy = pre_right = pre_left = ListNode(next=head)\\n        right = left = head\\n        for i in range(k-1):\\n            pre_left = left\\n            left = left.next\\n        \\n        null_checker = left\\n        \\n        while null_checker.next:\\n            pre_right = right\\n            right = right.next\\n            null_checker = null_checker.next\\n            \\n        if left == right:\\n            return head\\n        \\n        pre_left.next, pre_right.next = right, left\\n        left.next, right.next = right.next, left.next\\n        return dummy.next        \\n\\n\\n**I Hope this helped. If so, an Upvote will be really Awesome.** \\uD83D\\uDE0A\\nBtw this was my first time I\\'m sharing an answer in LeetCode.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef swapNodes(self, head: ListNode, k: int) -> ListNode:\\n\\tfirst = last = head\\n\\tfor i in range(1, k):\\n\\t\\tfirst = first.next\\n\\t\\t\\n\\tnull_checker = first \\n\\twhile null_checker.next:\\n\\t\\tlast = last.next\\n\\t\\tnull_checker = null_checker.next\\n\\tfirst.val, last.val = last.val, first.val\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1009918,
                "title": "java-two-pointers-detailed-explanation-o-n-time-o-1-space",
                "content": "## Approach\\nOur main task is to **determine the locations of the nodes** whose values are to be swapped. This can be done by traversing the list using two pointers - *fast* and *slow*, with a certain distance between them. The pointers move one node at a time. The distance should be chosen such that:\\n- when *slow* is at *head*, *fast* points at the first node for swapping\\n- when *fast* is at the end, *slow* points at the second node for swapping\\n\\n## Example\\n\\nLet\\'s take this example:\\n\\n```\\n[1, 2, 3, 4, 5], k = 2\\n```\\n\\nIt\\'s easy to see that we have to swap *2* and *4*. Let\\'s implement that.\\n\\nWe traverse this list with *fast* and *slow*.\\n\\nIt is convenient to choose the initial position for *slow* to be at *head*, e.g. *1*. If we choose *fast* to be *k* nodes after *slow* - at *3* - we miss the node *2*. Therefore, we put *fast* *k-1* nodes after *slow*. This means that the first node for swapping is at the initial position of *fast*.\\n\\nWhen *fast* is at *5*, *slow* is at *4*, which is the second node whose value will be swapped. In other words, we save the second node for swapping when *fast* reaches the last node (*fast.next* is *null*). For that, the distance between *slow* and *fast* must be constant; this is achieved by moving them both one node at a time until *fast* reaches the end.\\n\\n## Algorithm\\n\\nLet\\'s use two more pointers *first* and *second*, denoting the nodes for swapping\\n\\n1. Put *slow* at *head*, and put *fast* *k-1* nodes after *slow*.\\n2. *first* = *fast*.\\n3. If *fast* isn\\'t already at the last node, move *slow* and *fast* one node further until *fast.next == null*\\n4. *second* = *slow*\\n5. Swap the values of *first* and *second*\\n\\n## Implementation\\n\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\t\\t\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode first = head, second = head;\\n        \\n\\t\\t// Put fast (k-1) nodes after slow\\n        for(int i = 0; i < k - 1; ++i)\\n            fast = fast.next;\\n            \\n\\t\\t// Save the node for swapping\\n        first = fast;\\n\\n\\t\\t// Move until the end of the list\\n        while(fast.next != null) {\\n\\t\\t\\tslow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // Save the second node for swapping\\n\\t\\t// Note that the pointer second isn\\'t necessary: we could use slow for swapping as well\\n\\t\\t// However, having second improves readability\\n        second = slow;\\n\\t\\t\\n\\t\\t// Swap values\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n## Discussion\\nWe traverse the list only once, therefore the time complexity is *O(n)*\\nWe store only 4 pointers for every list; thus, the space complexity is constant: *O(1)*\\n\\n## Update\\nKeeping in mind the constraints ```1 <= k <= n <= 105```, the line ```if (head == null)``` isn\\'t needed here, and ```while (fast != null && fast.next != null)``` can be replaced by a simple ``while (fast.next != null)```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[1, 2, 3, 4, 5], k = 2\\n```\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\t\\t\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode first = head, second = head;\\n        \\n\\t\\t// Put fast (k-1) nodes after slow\\n        for(int i = 0; i < k - 1; ++i)\\n            fast = fast.next;\\n            \\n\\t\\t// Save the node for swapping\\n        first = fast;\\n\\n\\t\\t// Move until the end of the list\\n        while(fast.next != null) {\\n\\t\\t\\tslow = slow.next;\\n            fast = fast.next;\\n        }\\n        \\n        // Save the second node for swapping\\n\\t\\t// Note that the pointer second isn\\'t necessary: we could use slow for swapping as well\\n\\t\\t// However, having second improves readability\\n        second = slow;\\n\\t\\t\\n\\t\\t// Swap values\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n        \\n        return head;\\n    }\\n}\\n```\n```1 <= k <= n <= 105```\n```if (head == null)```\n```while (fast != null && fast.next != null)```",
                "codeTag": "Java"
            },
            {
                "id": 3525152,
                "title": "c-one-pass-easy-and-explained-approach",
                "content": "# **PLEASE UPVOTE\\uD83D\\uDC4D**\\n# Approach\\n- ##### To solve this problem in one pass, we can use a two-pointer approach.\\n- ##### First, we can initialize two pointers, left_ptr and right_ptr, both pointing to the head of the linked list. We can then move the right_ptr k-2 steps forward.\\n\\n- ##### After this, we can move both left_ptr and right_ptr forward simultaneously until right_ptr reaches the end of the list.\\n- ##### At this point, left_ptr will be pointing to the kth node from the beginning, and end_ptr will be pointing to the kth node from the end.\\n\\n- ##### We can then swap the values of these two nodes, and return the head of the linked list.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE\\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *left_ptr = head, *right_ptr = head;\\n        for (int i = 0; i < k-1; i++) {\\n            right_ptr = right_ptr->next;\\n        }\\n        \\n        ListNode *end_ptr = right_ptr;\\n        while (right_ptr->next) {\\n            left_ptr = left_ptr->next;\\n            right_ptr = right_ptr->next;\\n        }\\n        \\n        swap(end_ptr->val, left_ptr->val);\\n        \\n        return head;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/593c0559-644c-43cf-95fc-b18138253456_1684110070.1871367.png)",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *left_ptr = head, *right_ptr = head;\\n        for (int i = 0; i < k-1; i++) {\\n            right_ptr = right_ptr->next;\\n        }\\n        \\n        ListNode *end_ptr = right_ptr;\\n        while (right_ptr->next) {\\n            left_ptr = left_ptr->next;\\n            right_ptr = right_ptr->next;\\n        }\\n        \\n        swap(end_ptr->val, left_ptr->val);\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108879,
                "title": "c-super-simple-one-pass-short-solution",
                "content": "We traverse the list until we reach the kth node.\\nThen we set \"kth\" to that node to remember it, set ptr2 to head and continue traversing the list, while we move both ptr1 and ptr2.\\nWhen ptr1 reaches the end - ptr2 is on the (n-k)th node.\\nNow we swap \"kth\" and \"ptr2\" and we\\'re done!\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *ptr1 = head, *ptr2 = head, *kth = NULL;\\n        while (--k)\\n            ptr1 = ptr1->next;\\n        \\n        kth = ptr1;\\n        ptr1 = ptr1->next;\\n        \\n        while (ptr1) {\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n        }\\n        swap(ptr2->val, kth->val);\\n        return head;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *ptr1 = head, *ptr2 = head, *kth = NULL;\\n        while (--k)\\n            ptr1 = ptr1->next;\\n        \\n        kth = ptr1;\\n        ptr1 = ptr1->next;\\n        \\n        while (ptr1) {\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n        }\\n        swap(ptr2->val, kth->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912205,
                "title": "c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left = head;\\n        ListNode* right = head;\\n        ListNode* curr = head;\\n        \\n        int counter = 1;\\n        while(curr!=NULL){\\n            if (counter<k){\\n                left = left->next;\\n            }\\n            if (counter>k){\\n                right = right->next;\\n            }\\n            curr = curr->next;\\n            counter++;\\n        }\\n        //swap values\\n        int temp = left->val;\\n        left->val = right->val;\\n        right->val = temp;\\n        \\n        return head;\\n    }\\n};\\n```\\nIdea of solution is to have two pointers: a left pointer and a right pointer\\nInitialize both to the head, and a counter variable\\n\\nLeft pointer:\\nIterate through the Linked list, and while the counter is less than k, increment the left pointer.\\nAfter the counter greater than or equal to k, we do not want to move the left pointer anymore since it is in the desired position.\\n\\nRight pointer:\\nThe right pointer should not start moving until our counter exceeds k, this way the right pointer \\'lags\\' behind the current pointer by k nodes. \\nAfter counter exceeds k, we increment it each iteration together with the current pointer, keeping the k node lag\\n\\nAfter current reaches end of the list, we can swap the values in the left and right node to get our result\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left = head;\\n        ListNode* right = head;\\n        ListNode* curr = head;\\n        \\n        int counter = 1;\\n        while(curr!=NULL){\\n            if (counter<k){\\n                left = left->next;\\n            }\\n            if (counter>k){\\n                right = right->next;\\n            }\\n            curr = curr->next;\\n            counter++;\\n        }\\n        //swap values\\n        int temp = left->val;\\n        left->val = right->val;\\n        right->val = temp;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013859,
                "title": "python3-visualization-two-pointers-solution-with-explanation",
                "content": "### Initial State\\nThere are 2 pointers named **fast** and **slow** pointing to the first node of the Linked List.\\n\\n![image](https://assets.leetcode.com/users/images/745bf275-c2e7-4ef3-bc62-c234f63705ab_1610489475.588092.png)\\n\\n\\n### Phase 1\\nMove **fast** k-1 times. Now **fast** points to the kth node from the beginning. Marked this node **first**. \\n\\n![image](https://assets.leetcode.com/users/images/d46e8209-7a44-474a-bf71-e34a1412a22a_1610489761.6970868.png)\\n\\n### Phase 2\\nMove **fast** and **slow** together until **fast** points to the last node. Now **slow** points to the kth node from the end.\\n\\n![image](https://assets.leetcode.com/users/images/dd6b809c-96a1-4882-8b7e-da44f522fabe_1610489896.2848048.png)\\n\\n### Last\\n\\nSwap values of **slow** and **first**.\\n\\n## Code\\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n\\t\\n\\t    # Initial State\\n        slow, fast = head, head\\n\\t\\t\\n\\t\\t# Phase 1\\n        for _ in range(k - 1):\\n            fast = fast.next\\n        first = fast\\n\\n        # Phase 2\\n        while fast.next:\\n            slow, fast = slow.next, fast.next\\n\\t\\t\\n\\t\\t# Last\\n        first.val, slow.val = slow.val, first.val\\n\\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n\\t\\n\\t    # Initial State\\n        slow, fast = head, head\\n\\t\\t\\n\\t\\t# Phase 1\\n        for _ in range(k - 1):\\n            fast = fast.next\\n        first = fast\\n\\n        # Phase 2\\n        while fast.next:\\n            slow, fast = slow.next, fast.next\\n\\t\\t\\n\\t\\t# Last\\n        first.val, slow.val = slow.val, first.val\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110270,
                "title": "7-lines-c-1-pass-no-value-swapping",
                "content": "This is a classical but still popular interview question. **When this problem is asked during a live interview, the interviewer usually disallows copying or overwriting values (e.g. \"imagine each node is 5MB-sized value\").** Instead, poor interviewees are forced to manipulate pointers! Those who actually tried this in practice know how many edge cases needed to be handled, including the case where one of the nodes matching list head or tail or nodes being next to each other or the same, or first value appearing on the right of second.\\n\\nToday I\\'m presenting a solution which I have incrementally perfected over 15 years. It accomplishes the goal in a single pass, only changes pointers (not values), and does it in a way which handles all edge cases without needing to be explicitly taken care of.\\n\\nThe solution is C++ specific. You won\\'t be able to replicate it in Java or Python or C#.\\n\\n```c++\\nListNode **a = &head, **b = &head;\\nwhile (--k) { a = &(*a)->next; }\\nListNode *x = (*a)->next;\\nwhile (x) { x = x->next; b = &(*b)->next; }\\nswap(*a, *b);\\nswap((*a)->next, (*b)->next);\\nreturn head;\\n```\\nYep. That\\'s all there is to it. Still unsure that something like this could possibly work? \\n\\nFirstly, finding Kth node `a` is straightforward, but how can `b` (Kth from end) be found in the same pass, without knowing the list size? Classical two-pointer approach is used - where we have a pointer to `b` lagging behind `x` on exactly `k` steps and we continue our list traversal until `x` reaches the end. This leaves `b` pointing to the right place. And we traversed list only once. This shouldn\\'t surprize anyone so far, this part of the solution is well-known.\\n\\nSecond aspect is that instead of single-indirection pointers (such as `ListNode*`) the double-indirection pointers (`ListNode**`) are used.  That means instead of typical `current = current->next` code, we have to write  `current = &(*current)->next`.  Not a big difference in the readability or semantic of the code, but this allows to avoid explicit tracking of predecessors of nodes `a` and `b`, since the addresses of incoming `next` pointers would be automatically held in the local variables `a` and `b`. This also \"magically\" handles the edge case when `head` needs to be changed: `head` pointer can in fact be swapped by one of the `swap`s in the code.\\n\\nFinally, to swap two nodes, we need to adjust pointers, namely swap two \"incoming\" edges to the first and second nodes, as well as two \"outgoing\" edges. This is achieved by two `swap()` calls: `*a` and `*b` denote \"incoming\" edges and `(*a)->next` and `(*b)->next` are \"outgoing\" edges.  Note that the ordering of these swaps is important, since only this arrangement handles a case where nodes `a` and `b` are neighbours. However, relative position of both nodes doesn\\'t matter, as `a` and `b` appear in swaps symmetrically. If `a` and `b` are the same, this has no detrimental effect.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nListNode **a = &head, **b = &head;\\nwhile (--k) { a = &(*a)->next; }\\nListNode *x = (*a)->next;\\nwhile (x) { x = x->next; b = &(*b)->next; }\\nswap(*a, *b);\\nswap((*a)->next, (*b)->next);\\nreturn head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1911996,
                "title": "python-simple-solution-with-explanation",
                "content": "### Intuition\\n\\nWe want to find the <code>k<sup>th</sup></code> node from the left and the <code>k<sup>th</sup></code> node from the right, and swap their values.\\n\\nFirstly, since the linked list is 1-indexed (as given in the problem statement), **the <code>k<sup>th</sup></code> node from the left is `k-1` nodes to the right of the given `head` node**. Hence, finding the <code>k<sup>th</sup></code> node from the left is trivial:\\n\\n```python\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        l = head  # left node\\n        for _ in range(k-1):\\n            l = l.next\\n        # the rest of the code logic here\\n```\\n\\nBut how do we find the <code>k<sup>th</sup></code> node from the right? Since we do not know the length of the linked list, it would seem as if we would have to find the tail node, and iterate backwards from there.\\n\\nThankfully, in the process of iterating through the linked list to find the tail node, we can have **a pointer pointing to the node that is `k-1` nodes to the left of the pointer searching for the tail node**. This way, we will know which node is the <code>k<sup>th</sup></code> node from the right (i.e., the *right* node) once we have found the tail node.\\n\\nOnce we have both nodes, swapping their values is trivial. Note that **the problem statement specifies that only the values need to be swapped**, which makes implementation much simpler. To perform actual node swapping, please refer to [my comment](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/discuss/1911996/Python-Simple-Solution-with-Explanation/1335887) below.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        # Find kth node from left\\n        l = r = head\\n        for _ in range(k-1):\\n            l = l.next\\n        # Find kth node from right\\n        # by finding tail node\\n        tail = l\\n        while tail.next:\\n            r, tail = r.next, tail.next\\n        # Swap values and return\\n        l.val, r.val = r.val, l.val\\n        return head\\n```\\n\\n**TC: O(n)**, where `n` is the length of the linked list, since we iterate through the entire linked list to find the tail node.\\n**SC: O(1)**; three pointers are used.\\n\\n Please upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        l = head  # left node\\n        for _ in range(k-1):\\n            l = l.next\\n        # the rest of the code logic here\\n```\n```python\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        # Find kth node from left\\n        l = r = head\\n        for _ in range(k-1):\\n            l = l.next\\n        # Find kth node from right\\n        # by finding tail node\\n        tail = l\\n        while tail.next:\\n            r, tail = r.next, tail.next\\n        # Swap values and return\\n        l.val, r.val = r.val, l.val\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912231,
                "title": "3-approaches-swapping-values-and-swapping-nodes-with-image-explanation",
                "content": "[Leetcode](https://leetcode.com/) [1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/).\\n\\nHere shows **3** Approaches to slove this problem: **ArrayList** and **Two Pointers**.\\n\\n# Intuition\\n\\nSince the $\\\\texttt{ListNode}$ only contain values, we can just just **swap the values** of two nodes. It\\'s very easy. All we need to do is to find these two nodes and swap their values.\\n\\nIf we swap nodes, it will be more difficult than swap values.\\n\\n\\n# ArrayList(Swapping Values)\\n\\nWe can use an $\\\\texttt{ArrayList}$ to record all the nodes of the linked list. We can just **swap the values** of two nodes.\\n\\n```java\\n    // BF List time: O(n) space: O(n)\\n    public static ListNode swapNodes_bf_list(ListNode head, int k) {\\n        ListNode pNode = head;\\n        List<ListNode> nodeList = new ArrayList<>();\\n\\t\\t// store these nodes.\\n        while (pNode != null) {\\n            nodeList.add(pNode);\\n            pNode = pNode.next;\\n        }\\n\\n\\t\\t// swap their values.\\n        int len = nodeList.size();\\n        int temp = nodeList.get(k - 1).val;\\n        nodeList.get(k - 1).val = nodeList.get(len - k).val;\\n        nodeList.get(len - k).val = temp;\\n\\n        return head;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# Two Pointers(Swapping Values)\\n\\nThe space complexity of Method $1$ is $O(n)$. We can use **Two Pointers** to make it to $O(1)$. \\n\\nJust follow the bellow steps: \\n\\n1. Find the $k-th$ node from the front which is left.\\n2. Make left node as the current node, right node from the front, when the current node reach end, right node is just the $k-th$ last element.\\n3. Swap their values.\\n\\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static ListNode swapNodes_tp(ListNode head, int k) {\\n        ListNode left = head;\\n        ListNode right = head;\\n        int cnt = 0;\\n\\t\\t// find the k-th node\\n        while (left != null) {\\n            cnt++;\\n            if (cnt == k) {\\n                break;\\n            }\\n            left = left.next;\\n        }\\n\\n\\t\\t// find the k-th last element\\n        ListNode pNode = left;\\n        while (pNode.next != null) {\\n            pNode = pNode.next;\\n            right = right.next;\\n        }\\n\\n\\t\\t// swap their values.\\n        int temp = left.val;\\n        left.val = right.val;\\n        right.val = temp;\\n\\n        return head;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Two Pointers(Swapping Nodes)\\n\\nIn fact, Swapping Nodes will be more difficult. There are some **corner cases**.\\n\\nWe need to store both the previous and current nodes of these two nodes, denoted them as $\\\\textit{preLeft}$ and $\\\\textit{preRight}$.\\n\\nHowever, here are **3** corner cases, as the bellow image shows.\\n\\n![Swap Nodes](https://assets.leetcode.com/users/images/acadded9-a300-434b-b293-e892f705d450_1649040671.0614367.png)\\n\\nWe must handle these **3** cases.\\n\\n```java\\n    // Two Pointers Swap Nodes time: O(n) space: O(1)\\n    public static ListNode swapNodes_tp_swapNode(ListNode head, int k) {\\n        ListNode dummyNode = new ListNode(0);\\n        dummyNode.next = head;\\n        ListNode preLeft = dummyNode;\\n        ListNode left = head;\\n        ListNode preRight = dummyNode;\\n        ListNode right = head;\\n\\n\\t\\t// find the k-th node\\n        for (int i = 1; i < k; i++) {\\n            preLeft = preLeft.next;\\n            left = left.next;\\n        }\\n\\n\\t\\t// find the k-th last node\\n        ListNode curNode = left;\\n        while (curNode.next != null) {\\n            curNode = curNode.next;\\n            preRight = preRight.next;\\n            right = right.next;\\n        }\\n\\n        ListNode tempNode = left.next;\\n\\t\\t// if right is the left neighbor of left\\n        if (preLeft == right) {\\n            preRight.next = left;\\n            left.next = right;\\n            right.next = tempNode;\\n        } else if (left == preRight) { // if left is the right neighbor of left\\n            left.next = right.next;\\n            preLeft.next = right;\\n            right.next = left;\\n        } else { // common cases.\\n            preLeft.next = right;\\n            left.next = right.next;\\n            preRight.next = left;\\n            right.next = tempNode;\\n        }\\n\\n        return dummyNode.next;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```java\\n    // BF List time: O(n) space: O(n)\\n    public static ListNode swapNodes_bf_list(ListNode head, int k) {\\n        ListNode pNode = head;\\n        List<ListNode> nodeList = new ArrayList<>();\\n\\t\\t// store these nodes.\\n        while (pNode != null) {\\n            nodeList.add(pNode);\\n            pNode = pNode.next;\\n        }\\n\\n\\t\\t// swap their values.\\n        int len = nodeList.size();\\n        int temp = nodeList.get(k - 1).val;\\n        nodeList.get(k - 1).val = nodeList.get(len - k).val;\\n        nodeList.get(len - k).val = temp;\\n\\n        return head;\\n    }\\n```\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static ListNode swapNodes_tp(ListNode head, int k) {\\n        ListNode left = head;\\n        ListNode right = head;\\n        int cnt = 0;\\n\\t\\t// find the k-th node\\n        while (left != null) {\\n            cnt++;\\n            if (cnt == k) {\\n                break;\\n            }\\n            left = left.next;\\n        }\\n\\n\\t\\t// find the k-th last element\\n        ListNode pNode = left;\\n        while (pNode.next != null) {\\n            pNode = pNode.next;\\n            right = right.next;\\n        }\\n\\n\\t\\t// swap their values.\\n        int temp = left.val;\\n        left.val = right.val;\\n        right.val = temp;\\n\\n        return head;\\n    }\\n```\n```java\\n    // Two Pointers Swap Nodes time: O(n) space: O(1)\\n    public static ListNode swapNodes_tp_swapNode(ListNode head, int k) {\\n        ListNode dummyNode = new ListNode(0);\\n        dummyNode.next = head;\\n        ListNode preLeft = dummyNode;\\n        ListNode left = head;\\n        ListNode preRight = dummyNode;\\n        ListNode right = head;\\n\\n\\t\\t// find the k-th node\\n        for (int i = 1; i < k; i++) {\\n            preLeft = preLeft.next;\\n            left = left.next;\\n        }\\n\\n\\t\\t// find the k-th last node\\n        ListNode curNode = left;\\n        while (curNode.next != null) {\\n            curNode = curNode.next;\\n            preRight = preRight.next;\\n            right = right.next;\\n        }\\n\\n        ListNode tempNode = left.next;\\n\\t\\t// if right is the left neighbor of left\\n        if (preLeft == right) {\\n            preRight.next = left;\\n            left.next = right;\\n            right.next = tempNode;\\n        } else if (left == preRight) { // if left is the right neighbor of left\\n            left.next = right.next;\\n            preLeft.next = right;\\n            right.next = left;\\n        } else { // common cases.\\n            preLeft.next = right;\\n            left.next = right.next;\\n            preRight.next = left;\\n            right.next = tempNode;\\n        }\\n\\n        return dummyNode.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009811,
                "title": "one-pass-time-o-n-space-o-1-real-node-swapping-not-just-changing-value",
                "content": "In real world, the value stored in each node might not just be of an integer value. So swapping the node references is justified.\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n\\n        ListNode firstPrev = dummy;\\n        for (int i = 0; i < k - 1; i++) {\\n            firstPrev = firstPrev.next;\\n        }\\n\\n        ListNode secondPrev = dummy;\\n        ListNode advanced = firstPrev.next.next;\\n        while (advanced != null) {\\n            secondPrev = secondPrev.next;\\n            advanced = advanced.next;\\n        }\\n\\n        ListNode first = firstPrev.next;\\n        ListNode second = secondPrev.next;\\n        ListNode firstNodeAfter = first.next;\\n        ListNode secondNodeAfter = second.next;\\n        \\n        if (second.next == first) {\\n            secondPrev.next = first;\\n            first.next = second;\\n            second.next = firstNodeAfter;\\n        } else if (secondPrev == first) {\\n            firstPrev.next = second;\\n            second.next = first;\\n            first.next = secondNodeAfter;\\n        } else {\\n            firstPrev.next = second;\\n            second.next = firstNodeAfter;\\n            secondPrev.next = first;\\n            first.next = secondNodeAfter;\\n        }\\n\\n\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n\\n        ListNode firstPrev = dummy;\\n        for (int i = 0; i < k - 1; i++) {\\n            firstPrev = firstPrev.next;\\n        }\\n\\n        ListNode secondPrev = dummy;\\n        ListNode advanced = firstPrev.next.next;\\n        while (advanced != null) {\\n            secondPrev = secondPrev.next;\\n            advanced = advanced.next;\\n        }\\n\\n        ListNode first = firstPrev.next;\\n        ListNode second = secondPrev.next;\\n        ListNode firstNodeAfter = first.next;\\n        ListNode secondNodeAfter = second.next;\\n        \\n        if (second.next == first) {\\n            secondPrev.next = first;\\n            first.next = second;\\n            second.next = firstNodeAfter;\\n        } else if (secondPrev == first) {\\n            firstPrev.next = second;\\n            second.next = first;\\n            first.next = secondNodeAfter;\\n        } else {\\n            firstPrev.next = second;\\n            second.next = firstNodeAfter;\\n            secondPrev.next = first;\\n            first.next = secondNodeAfter;\\n        }\\n\\n\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108911,
                "title": "python-no-need-in-two-pointers-explained",
                "content": "Let us just do what is asked in this problem in two stages:\\n1. Find `n` - total number of elements in our linked list, also check when we meet element number `k` during this traversal and save it result to node `l`.\\n2. During second traversal just do `n-k` steps and save result to `r`.\\n\\nFinally, just change values of nodes `l` and `r`.\\n\\n**Complexity**: Time complexity is `O(n)`, more specifially we did `n + n - k = 2n-k` steps when we traverse our list. Space complexity is `O(1)`.\\n\\n**Duscussion** Let us compare it with what is probably expected as the best solution here: make `k` steps using pointer `r`, put `l` to head; then continue to traverse both pointers until `r` will reach end, than `l` will be in exactly needed place. What is total number of step we done here: It is `k` + `(n-k)*2` = suprise what `2n - k`, exactly the same number of steps we do as in simple approach where you do not need to think at all. So, if you get this problem during interview and after providing this solution interviewer say that there is also Two Pointer solution, explain to him that you solution have exaclty the same complexities and working exactly the same. And so-called one-pass solutions and two-pass solutions are the same.\\n\\n```\\nclass Solution:\\n    def swapNodes(self, head, k):\\n        n = 0\\n        beg = head\\n        while beg:\\n            if n == k-1: l = beg\\n            beg = beg.next\\n            n += 1\\n        \\n        r = head\\n        for m in range(n-k):\\n            r = r.next\\n                \\n        l.val, r.val = r.val, l.val\\n        return head\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head, k):\\n        n = 0\\n        beg = head\\n        while beg:\\n            if n == k-1: l = beg\\n            beg = beg.next\\n            n += 1\\n        \\n        r = head\\n        for m in range(n-k):\\n            r = r.next\\n                \\n        l.val, r.val = r.val, l.val\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108935,
                "title": "js-python-java-c-short-simple-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIt\\'s important to notice that the instructions don\\'t specify that we have to actually swap the *nodes*, just the *values*. So the only thing remaining is to just find both nodes.\\n\\nSince we don\\'t know how long the linked list is, we\\'ll have to iterate to the end of it before we can possibly find the second node to swap out. But to make things easier, we don\\'t have to find and store the length and then calculate the difference, we can just take advantage of the fact that the distance from the **k**th node to the end is the same as the distance from the beginning to the **k**th node from the end.\\n\\n![Visual 1](https://i.imgur.com/oQ76PFv.png)\\n\\nWe can move the first list (**A**) forward to the **k**th node, making sure to store it in a variable (**nodeK**), then start our staggered list (**B**) and iterate both until **A** ends, at which point we should be at the **k**th node from the end.\\n\\nThen we just swap the values and **return head**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe code for all four languages is almost exactly the same.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **484ms / 73.5MB** (beats 99% / 89%).\\n```javascript\\nvar swapNodes = function(head, k) {\\n    let A = head, B = head, K, temp\\n    for (let i = 1; i < k; i++) A = A.next\\n    K = A, A = A.next\\n    while (A) A = A.next, B = B.next\\n    temp = K.val, K.val = B.val, B.val = temp\\n    return head\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **996ms / 48.7MB** (beats 99% / 97%).\\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        A, B = head, head\\n        for i in range(1, k): A = A.next\\n        nodeK, A = A, A.next\\n        while A: A, B = A.next, B.next\\n        nodeK.val, B.val = B.val, nodeK.val\\n        return head\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 64.5MB** (beats 100% / 88%).\\n```java\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode A = head, B = head, nodeK;\\n        for (int i = 1; i < k; i++) A = A.next;\\n        nodeK = A;\\n        A = A.next;\\n        while (A != null) {\\n            A = A.next;\\n            B = B.next;\\n        }\\n        int temp = nodeK.val;\\n        nodeK.val = B.val;\\n        B.val = temp;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **572ms / 180.0MB** (beats 94% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *A = head, *B = head, *nodeK;\\n        for (int i = 1; i < k; i++) A = A->next;\\n        nodeK = A, A = A->next;\\n        while (A) A = A->next, B = B->next;\\n        int temp = nodeK->val;\\n        nodeK->val = B->val, B->val = temp;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar swapNodes = function(head, k) {\\n    let A = head, B = head, K, temp\\n    for (let i = 1; i < k; i++) A = A.next\\n    K = A, A = A.next\\n    while (A) A = A.next, B = B.next\\n    temp = K.val, K.val = B.val, B.val = temp\\n    return head\\n};\\n```\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        A, B = head, head\\n        for i in range(1, k): A = A.next\\n        nodeK, A = A, A.next\\n        while A: A, B = A.next, B.next\\n        nodeK.val, B.val = B.val, nodeK.val\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode A = head, B = head, nodeK;\\n        for (int i = 1; i < k; i++) A = A.next;\\n        nodeK = A;\\n        A = A.next;\\n        while (A != null) {\\n            A = A.next;\\n            B = B.next;\\n        }\\n        int temp = nodeK.val;\\n        nodeK.val = B.val;\\n        B.val = temp;\\n        return head;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *A = head, *B = head, *nodeK;\\n        for (int i = 1; i < k; i++) A = A->next;\\n        nodeK = A, A = A->next;\\n        while (A) A = A->next, B = B->next;\\n        int temp = nodeK->val;\\n        nodeK->val = B->val, B->val = temp;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525672,
                "title": "simple-solution-2ms-beats-99-9-easy-to-understand-java-c-kotlin-javascript-c-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the list twice - once to find the kth node from the beginning, and then again to find the kth node from the end. After the two nodes are identified, their values can be swapped.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First initializes two pointers left and right to point to the head of the list. It then moves the left pointer k-1 times to reach the k-th node from the beginning of the list. At this point, left points to the node that needs to be swapped.\\n\\n- The function then initializes a new pointer curr to point to the same node as left. It then moves curr forward until it reaches the end of the list, while also moving right pointer to point to the kth node from the end of the list. Once curr reaches the end of the list, right will point to the kth node from the end.\\n\\n- Finally, the swap the values of the two nodes pointed to by left and right, and returns the head of the modified list.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode left=head,rigth=head;\\n        for(int i=1;i<k;i++)\\n        left=left.next;\\n        ListNode curr = left;\\n        while(curr.next!=null){\\n            curr = curr.next;\\n            rigth=rigth.next;\\n        }\\n        int t = left.val;\\n        left.val = rigth.val;\\n        rigth.val =t;\\n        return head;\\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n          ListNode *left = head, *right = head;\\n    for(int i = 1; i < k; i++)\\n        left = left->next;\\n    ListNode *curr = left;\\n    while(curr->next != nullptr){\\n        curr = curr->next;\\n        right = right->next;\\n    }\\n    int t = left->val;\\n    left->val = right->val;\\n    right->val = t;\\n    return head;\\n    }\\n};\\n```\\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar swapNodes = function(head, k) {\\n\\n      if (!head) {\\n        return null;\\n    }\\n    let left = head, right = head;\\n    for (let i = 1; i < k; i++) {\\n        left = left.next;\\n    }\\n    let curr = left;\\n    while (curr.next) {\\n        curr = curr.next;\\n        right = right.next;\\n    }\\n    let temp = left.val;\\n    left.val = right.val;\\n    right.val = temp;\\n    return head;\\n    \\n};\\n```\\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapNodes(head: ListNode?, k: Int): ListNode? {\\n         if (head == null) {\\n            return null\\n        }\\n        var left = head\\n        var right = head\\n        for (i in 1 until k) {\\n            left = left?.next\\n        }\\n        var curr = left\\n        while (curr?.next != null) {\\n            curr = curr.next\\n            right = right?.next\\n        }\\n        val temp = left?.`val`\\n        left?.`val` = right?.`val`\\n        right?.`val` = temp\\n        return head\\n    }\\n}\\n```\\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapNodes(ListNode head, int k) {\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        ListNode left = head, right = head;\\n        for (int i = 1; i < k; i++) {\\n            left = left.next;\\n        }\\n        ListNode curr = left;\\n        while (curr.next != null) {\\n            curr = curr.next;\\n            right = right.next;\\n        }\\n        int temp = left.val;\\n        left.val = right.val;\\n        right.val = temp;\\n        return head;\\n    }\\n}\\n```\\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapNodes(struct ListNode* head, int k){\\n\\n struct ListNode *left = head, *right = head;\\n    for(int i = 1; i < k; i++)\\n        left = left->next;\\n    struct ListNode *curr = left;\\n    while(curr->next != NULL){\\n        curr = curr->next;\\n        right = right->next;\\n    }\\n    int t = left->val;\\n    left->val = right->val;\\n    right->val = t;\\n    return head;\\n}\\n```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUpvotes Are Encouraging",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode left=head,rigth=head;\\n        for(int i=1;i<k;i++)\\n        left=left.next;\\n        ListNode curr = left;\\n        while(curr.next!=null){\\n            curr = curr.next;\\n            rigth=rigth.next;\\n        }\\n        int t = left.val;\\n        left.val = rigth.val;\\n        rigth.val =t;\\n        return head;\\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n          ListNode *left = head, *right = head;\\n    for(int i = 1; i < k; i++)\\n        left = left->next;\\n    ListNode *curr = left;\\n    while(curr->next != nullptr){\\n        curr = curr->next;\\n        right = right->next;\\n    }\\n    int t = left->val;\\n    left->val = right->val;\\n    right->val = t;\\n    return head;\\n    }\\n};\\n```\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar swapNodes = function(head, k) {\\n\\n      if (!head) {\\n        return null;\\n    }\\n    let left = head, right = head;\\n    for (let i = 1; i < k; i++) {\\n        left = left.next;\\n    }\\n    let curr = left;\\n    while (curr.next) {\\n        curr = curr.next;\\n        right = right.next;\\n    }\\n    let temp = left.val;\\n    left.val = right.val;\\n    right.val = temp;\\n    return head;\\n    \\n};\\n```\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapNodes(head: ListNode?, k: Int): ListNode? {\\n         if (head == null) {\\n            return null\\n        }\\n        var left = head\\n        var right = head\\n        for (i in 1 until k) {\\n            left = left?.next\\n        }\\n        var curr = left\\n        while (curr?.next != null) {\\n            curr = curr.next\\n            right = right?.next\\n        }\\n        val temp = left?.`val`\\n        left?.`val` = right?.`val`\\n        right?.`val` = temp\\n        return head\\n    }\\n}\\n```\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapNodes(ListNode head, int k) {\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        ListNode left = head, right = head;\\n        for (int i = 1; i < k; i++) {\\n            left = left.next;\\n        }\\n        ListNode curr = left;\\n        while (curr.next != null) {\\n            curr = curr.next;\\n            right = right.next;\\n        }\\n        int temp = left.val;\\n        left.val = right.val;\\n        right.val = temp;\\n        return head;\\n    }\\n}\\n```\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapNodes(struct ListNode* head, int k){\\n\\n struct ListNode *left = head, *right = head;\\n    for(int i = 1; i < k; i++)\\n        left = left->next;\\n    struct ListNode *curr = left;\\n    while(curr->next != NULL){\\n        curr = curr->next;\\n        right = right->next;\\n    }\\n    int t = left->val;\\n    left->val = right->val;\\n    right->val = t;\\n    return head;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109029,
                "title": "swapping-nodes-in-a-linked-list-short-easy-w-explanation-one-pass",
                "content": "# ***Solution - I (Two-pass)***\\n\\n* Iterate over the linked list once to find the length `len` of the linked list. \\n* In the second iteration, again start from the head and this time assign the **`kthNode`** and **`kthNodeFromEnd`** when the iteration reaches `k-1` and `len-k` index respectively.\\n* Finally, swap the values and return **`head`**.\\n\\n```\\nListNode* swapNodes(ListNode* head, int k) {        \\n\\tListNode *kthNode = NULL, *kthNodeFromEnd = NULL, *iter = head;\\n\\tint len = 0, idx = 0;\\n\\twhile(iter)\\n\\t\\titer = iter -> next, len++;\\n\\titer = head;\\n\\twhile(iter){\\n\\t\\tif(idx == k - 1) kthNode = iter;\\n\\t\\tif(idx == len - k) kthNodeFromEnd = iter;\\n\\t\\tif(kthNode && kthNodeFromEnd) break;\\n\\t\\titer = iter -> next, idx++;\\n\\t}   \\n\\tswap(kthNode -> val, kthNodeFromEnd -> val);\\n\\treturn head;\\n}\\n```\\n\\n**Time Complexity :** `O(N)`, required for iterating over the linked list, where `N` is the number of nodes in linked list.\\n**Space Complexity :** `O(1)`, since only constant space is used.\\n\\n\\n![image](https://assets.leetcode.com/users/images/90ab89a8-c38d-47ef-93a7-9c23748ff810_1615718763.3802006.png)\\n\\n\\n\\n--------\\n-------\\n\\n\\n# ***Solution - II (Single-pass)***\\n\\nWe can directly swap the values of kth node and kthFromEnd node in a single pass. We will use a `iter` pointer to iterate over the linked list.\\n\\n* We will first iterate till the `kth` node and assign this to the **`kthNode`** pointer.\\n\\n * Initialise the **`kthNodeFromEnd`** pointer to the given head of list. Now, the gap between the **`iter`** and **`kthNodeFromEnd`** is k (since we have already iterated the `iter` pointer k times). Just iterate both the pointers, till `iter` reaches the last node. The gap between them will still be k meaning **`kthNodeFromEnd`** is correctly at its position.\\n * Just swap the values and return **`head`** pointer.\\n\\n```\\nListNode* swapNodes(ListNode* head, int k) {        \\n\\tListNode *kthNode, *kthNodeFromEnd = head, *iter = head;\\n\\twhile(--k)\\n\\t\\titer = iter -> next;\\n\\tkthNode = iter;\\n\\twhile(iter -> next)\\n\\t\\titer = iter -> next, kthNodeFromEnd = kthNodeFromEnd -> next;\\n\\tswap(kthNode -> val, kthNodeFromEnd -> val);\\n\\treturn head;\\n}\\n```\\n\\n**Time Complexity :** `O(N)` While this complexity is same as previous, **the constant factor is reduced by half**.\\n**Space Complexity :** `O(1)`, since only constant space is used.\\n\\n![image](https://assets.leetcode.com/users/images/1250cad9-f847-4e20-bddc-a0581954118c_1615718630.5036893.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* swapNodes(ListNode* head, int k) {        \\n\\tListNode *kthNode = NULL, *kthNodeFromEnd = NULL, *iter = head;\\n\\tint len = 0, idx = 0;\\n\\twhile(iter)\\n\\t\\titer = iter -> next, len++;\\n\\titer = head;\\n\\twhile(iter){\\n\\t\\tif(idx == k - 1) kthNode = iter;\\n\\t\\tif(idx == len - k) kthNodeFromEnd = iter;\\n\\t\\tif(kthNode && kthNodeFromEnd) break;\\n\\t\\titer = iter -> next, idx++;\\n\\t}   \\n\\tswap(kthNode -> val, kthNodeFromEnd -> val);\\n\\treturn head;\\n}\\n```\n```\\nListNode* swapNodes(ListNode* head, int k) {        \\n\\tListNode *kthNode, *kthNodeFromEnd = head, *iter = head;\\n\\twhile(--k)\\n\\t\\titer = iter -> next;\\n\\tkthNode = iter;\\n\\twhile(iter -> next)\\n\\t\\titer = iter -> next, kthNodeFromEnd = kthNodeFromEnd -> next;\\n\\tswap(kthNode -> val, kthNodeFromEnd -> val);\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009861,
                "title": "clean-python-3-one-pass",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        walker = runner = head\\n        for _ in range(k - 1):\\n            runner = runner.next\\n        first, runner = runner, runner.next\\n        while runner:\\n            walker = walker.next\\n            runner = runner.next\\n        walker.val, first.val = first.val, walker.val\\n        return head\\n```\\n\\nIf we are asked to swap nodes instead of only values\\n```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        walker = runner = first = dummy = ListNode(next=head)\\n        for i in range(k):\\n            first = runner\\n            runner = runner.next\\n        while runner.next:\\n            walker = walker.next\\n            runner = runner.next\\n        left, right = first.next, walker.next\\n        if right.next is left:\\n            left, right = right, left\\n            first, walker = walker, first\\n        left_next, right_next = left.next, right.next\\n        if left_next is right:\\n            first.next = right\\n            right.next = left\\n            left.next = right_next\\n        else:\\n            first.next, walker.next = right, left\\n            right.next, left.next = left_next, right_next\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        walker = runner = head\\n        for _ in range(k - 1):\\n            runner = runner.next\\n        first, runner = runner, runner.next\\n        while runner:\\n            walker = walker.next\\n            runner = runner.next\\n        walker.val, first.val = first.val, walker.val\\n        return head\\n```\n```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        walker = runner = first = dummy = ListNode(next=head)\\n        for i in range(k):\\n            first = runner\\n            runner = runner.next\\n        while runner.next:\\n            walker = walker.next\\n            runner = runner.next\\n        left, right = first.next, walker.next\\n        if right.next is left:\\n            left, right = right, left\\n            first, walker = walker, first\\n        left_next, right_next = left.next, right.next\\n        if left_next is right:\\n            first.next = right\\n            right.next = left\\n            left.next = right_next\\n        else:\\n            first.next, walker.next = right, left\\n            right.next, left.next = left_next, right_next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525481,
                "title": "c-easy-approach-two-pointers-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUpvote if you find helpfull!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Two pointers named as, Left and right in which left pointer will point kth element from starting and right pointer will point to kth element from ending.\\nswap the value of both pointers and return head.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left=head;\\n        ListNode* right= head;\\n        ListNode* curr= head;\\n\\n        int n=1;\\n        while(curr!=NULL)\\n        {\\n            if(n<k) left= left->next;\\n            if(n>k) right= right->next;\\n\\n            curr= curr->next;\\n            n++;\\n        }\\n        swap(left->val, right->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left=head;\\n        ListNode* right= head;\\n        ListNode* curr= head;\\n\\n        int n=1;\\n        while(curr!=NULL)\\n        {\\n            if(n<k) left= left->next;\\n            if(n>k) right= right->next;\\n\\n            curr= curr->next;\\n            n++;\\n        }\\n        swap(left->val, right->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525202,
                "title": "easy-solution-of-java-100-faster-code-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode itr=head;\\n        int count=1;\\n        while(count++<k){\\n          itr=itr.next;      \\n        }\\n        ListNode first=itr;\\n        ListNode second=head;\\n\\n        while(itr.next!=null){\\n          itr=itr.next;      \\n          second=second.next;\\n        }\\n\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode itr=head;\\n        int count=1;\\n        while(count++<k){\\n          itr=itr.next;      \\n        }\\n        ListNode first=itr;\\n        ListNode second=head;\\n\\n        while(itr.next!=null){\\n          itr=itr.next;      \\n          second=second.next;\\n        }\\n\\n        int temp=first.val;\\n        first.val=second.val;\\n        second.val=temp;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110298,
                "title": "simple-javascript-solution-with-comments",
                "content": "Please upvote if this helps :-)\\n```\\nvar swapNodes = function(head, k) {\\n    let node = head, first = head, second = head;\\n    for (let i = 1; i < k; i++) {\\n        node = node.next;\\n        second = second.next;\\n    };\\n\\n    while (second.next !== null) {\\n        second = second.next;\\n        first = first.next;\\n    };\\n    \\n    let temp = first.val;\\n    first.val = node.val;\\n    node.val = temp;\\n    return head;\\n};\\n```\\n**Explanation:**\\nWe start with three variables: node, first, and second\\nthe variable node will be the kth node in the list; first and second will help us find the kth node from the end\\n\\n**1. Find our kth node (from the beginning)**\\nStarting with a for loop where i = 1 since the list is 1-indexed, we will set node to the next until we find our kth node.\\nWe will do the same with **second**.\\n\\n**2. Find our kth node from the end**\\nOnce we have our kth node, we just need to find the kth node from the end.\\nTo do this, you can use a **2 pointer method** with first and second. We know that the node we need is *k nodes away from the last node* in the list. Since the second pointer is at the kth node, and the first pointer is at head, they are already k nodes away. \\nWe can continue to traverse first and second pointers until the second pointer reaches null, (the end of the list). At this point, first will be pointing at the kth node from the end.\\n\\n**3. Swap them**\\nTemporarily store the value of **first**\\nReassign **first.val** to be **node.val**\\nFinally, assign **node.val** to be **temp**\\nWe can then return the head.",
                "solutionTags": [],
                "code": "```\\nvar swapNodes = function(head, k) {\\n    let node = head, first = head, second = head;\\n    for (let i = 1; i < k; i++) {\\n        node = node.next;\\n        second = second.next;\\n    };\\n\\n    while (second.next !== null) {\\n        second = second.next;\\n        first = first.next;\\n    };\\n    \\n    let temp = first.val;\\n    first.val = node.val;\\n    node.val = temp;\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110017,
                "title": "c-single-pass-2-pointer-solution-explained-100-time-95-space",
                "content": "Cool one that I wanted to try and tackle using as little memory as possible and of course with a single pass.\\n\\nTo do so, we start updating `head` to be equal to a new `ListNode` with an arbitrary value and the previous `head` as a `next` node - basically we create a new node, prepend it to `head` and then call it `head`. This will avoid a few annoying edge cases and will allow us to swap nodes also when one of them is the very first one.\\n\\nWe will then declare 3 more `ListNode` pointers to help us - all initialised to be the new value of `head`:\\n* `prev1` and `prev2` are the pointers nodes that we are going to put right before the ones we want to swap (since it is a single-linked list, that is how you do the trick);\\n* `curr` is our running pointers.\\n\\nWe will then first of all locate `prev1` to the right place, looping `k ` times and advancing both `prev1` and `curr`.\\n\\nOne extra step for `curr` and then we will have it moved by `k` times from the original `head`, so that we can find `prev2` with the second loop, that we will have advance as long as `curr->next != NULL` (since `prev2` has to stop one step before the second node to swap).\\n\\nAnd now the swapping logic - I did not want to go lazy with just a call to `swap`, so I did it manually: we will have first to check if we have the edge case in which `prev1->next == prev2` (ie: the 2 nodes to swap are following each other), otherwise we proceed with a more general method, recycling `curr` as a support variable to do the operation saving memory, as described in minute steps.\\n\\nIn either case, once done, we can just return `head->next` and be done with it :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        // repositioning head\\n        head = new ListNode(-1, head);\\n        // support variables\\n        ListNode *prev1 = head, *prev2 = head, *curr = head;\\n        // finding prev1\\n        while (--k) {\\n            prev1 = prev1->next;\\n            curr = curr->next;\\n        }\\n        curr = curr->next;\\n        // finding prev2\\n        while (curr->next) {\\n            prev2 = prev2->next;\\n            curr = curr->next;\\n        }\\n        // switching nodes, with n1 = prev1->next and n2 = prev2->next:\\n        // edge case: n1->next = n2\\n        if (prev1->next == prev2) {\\n            // storing n2 in curr\\n            curr = prev2->next;\\n            // attaching n2->next right after n1\\n            prev1->next->next = prev2->next->next;\\n            // attaching n1 after n2\\n            curr->next = prev1->next;\\n            // attaching n2 to prev1\\n            prev1->next = curr;\\n            return head->next;\\n        }\\n        // storing n1 in curr\\n        curr = prev1->next;\\n        // attaching n2 right after prev1\\n        prev1->next = prev2->next;\\n        // since prev1 is no longer needed, we will use it to store next2 = n2->next\\n        prev1 = prev2->next->next;\\n        // finishing splicing n2 in place\\n        prev2->next->next = curr->next;\\n        // adding n1 after prev2\\n        prev2->next = curr;\\n        // connecting n2->next riht after n1\\n        curr->next = prev1;\\n        return head->next;\\n    }\\n};\\n```\\n\\n[Smarter approach by 0xF4](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/discuss/1110270/).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        // repositioning head\\n        head = new ListNode(-1, head);\\n        // support variables\\n        ListNode *prev1 = head, *prev2 = head, *curr = head;\\n        // finding prev1\\n        while (--k) {\\n            prev1 = prev1->next;\\n            curr = curr->next;\\n        }\\n        curr = curr->next;\\n        // finding prev2\\n        while (curr->next) {\\n            prev2 = prev2->next;\\n            curr = curr->next;\\n        }\\n        // switching nodes, with n1 = prev1->next and n2 = prev2->next:\\n        // edge case: n1->next = n2\\n        if (prev1->next == prev2) {\\n            // storing n2 in curr\\n            curr = prev2->next;\\n            // attaching n2->next right after n1\\n            prev1->next->next = prev2->next->next;\\n            // attaching n1 after n2\\n            curr->next = prev1->next;\\n            // attaching n2 to prev1\\n            prev1->next = curr;\\n            return head->next;\\n        }\\n        // storing n1 in curr\\n        curr = prev1->next;\\n        // attaching n2 right after prev1\\n        prev1->next = prev2->next;\\n        // since prev1 is no longer needed, we will use it to store next2 = n2->next\\n        prev1 = prev2->next->next;\\n        // finishing splicing n2 in place\\n        prev2->next->next = curr->next;\\n        // adding n1 after prev2\\n        prev2->next = curr;\\n        // connecting n2->next riht after n1\\n        curr->next = prev1;\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525464,
                "title": "o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n  * In order to be able to swap the nodes (instead of the values) we find the *parents* of the nodes to swap.\\n  * To handle the edges case of swapping `1st` nodes, we use a dumb `base` nodes as the parent of the head node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  ListNode* swapNodes(ListNode* head, int k) {\\n    ListNode base;\\n    base.next = head;\\n    ListNode* a = &base;\\n    while (k > 1) {\\n      --k;\\n      a = a->next;\\n    }  // Now a is the parent of the kth node.\\n\\n    ListNode* b = &base;\\n    ListNode* end = a->next->next;\\n    while (end != nullptr) {\\n      b = b->next;\\n      end = end->next;\\n    }  // Now b is the parent of the -kth node.\\n    if (a != b) {\\n      swap(a->next, b->next);\\n      swap(a->next->next, b->next->next);\\n    }\\n    return base.next;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  ListNode* swapNodes(ListNode* head, int k) {\\n    ListNode base;\\n    base.next = head;\\n    ListNode* a = &base;\\n    while (k > 1) {\\n      --k;\\n      a = a->next;\\n    }  // Now a is the parent of the kth node.\\n\\n    ListNode* b = &base;\\n    ListNode* end = a->next->next;\\n    while (end != nullptr) {\\n      b = b->next;\\n      end = end->next;\\n    }  // Now b is the parent of the -kth node.\\n    if (a != b) {\\n      swap(a->next, b->next);\\n      swap(a->next->next, b->next->next);\\n    }\\n    return base.next;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070524,
                "title": "go-one-pass-with-two-pointers",
                "content": "```\\nfunc swapNodes(head *ListNode, k int) *ListNode {\\n    kthFromStart, kthFromEnd := head, head\\n    for node := head; node != nil; node = node.Next {\\n        k--\\n        if k == 0 {\\n            kthFromStart = node\\n        }\\n        if k < 0 {\\n            kthFromEnd = kthFromEnd.Next\\n        }\\n    }\\n    kthFromStart.Val, kthFromEnd.Val = kthFromEnd.Val, kthFromStart.Val\\n    return head\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc swapNodes(head *ListNode, k int) *ListNode {\\n    kthFromStart, kthFromEnd := head, head\\n    for node := head; node != nil; node = node.Next {\\n        k--\\n        if k == 0 {\\n            kthFromStart = node\\n        }\\n        if k < 0 {\\n            kthFromEnd = kthFromEnd.Next\\n        }\\n    }\\n    kthFromStart.Val, kthFromEnd.Val = kthFromEnd.Val, kthFromStart.Val\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526154,
                "title": "python-java-elegant-short-fast-slow-pointers-one-pass",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        first = second = head\\n        for _ in range(k - 1):\\n            first = first.next\\n\\n        tail = first\\n        while tail.next:\\n            second = second.next\\n            tail = tail.next\\n\\n        first.val, second.val = second.val, first.val\\n        return head\\n```\\n```java []\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode first = head, second = head;\\n\\n        for (int i = 0; i < k - 1; ++i)\\n            first = first.next;\\n\\n        ListNode tail = first;\\n        while (tail.next != null) {\\n            second = second.next;\\n            tail = tail.next;\\n        }\\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        first = second = head\\n        for _ in range(k - 1):\\n            first = first.next\\n\\n        tail = first\\n        while tail.next:\\n            second = second.next\\n            tail = tail.next\\n\\n        first.val, second.val = second.val, first.val\\n        return head\\n```\n```java []\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode first = head, second = head;\\n\\n        for (int i = 0; i < k - 1; ++i)\\n            first = first.next;\\n\\n        ListNode tail = first;\\n        while (tail.next != null) {\\n            second = second.next;\\n            tail = tail.next;\\n        }\\n\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912091,
                "title": "simple-easy-c-java-solution",
                "content": "![image](https://assets.leetcode.com/users/images/63995ec3-0e58-4ccb-9240-f228f52bb953_1649036790.6485543.png)\\n\\n**C++ Solution**\\n**Time complexcity O(n)**\\n```\\nListNode* swapNodes(ListNode* head, int k) \\n    {\\n        ListNode *first;\\n        ListNode *p=head;\\n        \\n        while(--k) p=p->next;            // loop run k-1 times\\n        \\n        first=p;\\n        ListNode *second=head;\\n        while(p->next)\\n        {\\n            p=p->next;\\n            second=second->next;\\n        }\\n        swap(first->val,second->val);\\n        return head;\\n        \\n    }\\n```\\n\\n**Java Solution**\\n**Time complexcity O(n)**\\n```\\npublic ListNode swapNodes(ListNode head, int k) \\n    {\\n        ListNode first;\\n        ListNode p=head;\\n        while(--k!=0) p=p.next;          // run loop k-1 times\\n        \\n        first=p;\\n        ListNode second=head;\\n        while(p.next!=null)\\n        {\\n            p=p.next;\\n            second=second.next;\\n        }\\n        \\n        // swap\\n        int d=first.val;\\n        first.val=second.val;\\n        second.val=d;\\n        \\n        return head;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nListNode* swapNodes(ListNode* head, int k) \\n    {\\n        ListNode *first;\\n        ListNode *p=head;\\n        \\n        while(--k) p=p->next;            // loop run k-1 times\\n        \\n        first=p;\\n        ListNode *second=head;\\n        while(p->next)\\n        {\\n            p=p->next;\\n            second=second->next;\\n        }\\n        swap(first->val,second->val);\\n        return head;\\n        \\n    }\\n```\n```\\npublic ListNode swapNodes(ListNode head, int k) \\n    {\\n        ListNode first;\\n        ListNode p=head;\\n        while(--k!=0) p=p.next;          // run loop k-1 times\\n        \\n        first=p;\\n        ListNode second=head;\\n        while(p.next!=null)\\n        {\\n            p=p.next;\\n            second=second.next;\\n        }\\n        \\n        // swap\\n        int d=first.val;\\n        first.val=second.val;\\n        second.val=d;\\n        \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912047,
                "title": "beginner-friendly-java-solution",
                "content": "Using two pointers to locate k th index element and the element needs to be swapped.\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode fast = head, second = head, first = head;\\n        for(int i=0; i<k-1; i++)    fast = fast.next;\\n        first = fast;\\n        while(fast.next != null){\\n            fast = fast.next;\\n            second = second.next;\\n        }\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n        return head;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode fast = head, second = head, first = head;\\n        for(int i=0; i<k-1; i++)    fast = fast.next;\\n        first = fast;\\n        while(fast.next != null){\\n            fast = fast.next;\\n            second = second.next;\\n        }\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n        return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402092,
                "title": "java-solution-explained-2ms-faster-than-100-solution-0-n-time-linear",
                "content": "```\\nclass Solution \\n{\\n    public ListNode swapNodes(ListNode head, int k) \\n    {\\n        ListNode curr = head;\\n        ListNode pointer1 = head;\\n        ListNode pointer2= head;\\n        int count = 1;\\n        \\n        while( curr != null )\\n        {\\n            if( count < k )\\n            {\\n                pointer1 = pointer1.next;\\n            }\\n            if( count > k )\\n            {\\n                pointer2 = pointer2.next;\\n            }\\n            curr = curr.next;\\n            count++;\\n        }\\n        \\n        int temp = pointer1.val;\\n        pointer1.val = pointer2.val;\\n        pointer2.val = temp;\\n        \\n        return head;\\n    }\\n}\\n/*\\n\\nCreated a pointer which traverses till the end of the linkedlist\\nCreated pointer1 which will stop after reaching kth element\\nCreated pointer2 which will have a delayed start by kth number\\nSwap values of pointer1 and pointer2\\n\\nTime Complexity O(n)\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution \\n{\\n    public ListNode swapNodes(ListNode head, int k) \\n    {\\n        ListNode curr = head;\\n        ListNode pointer1 = head;\\n        ListNode pointer2= head;\\n        int count = 1;\\n        \\n        while( curr != null )\\n        {\\n            if( count < k )\\n            {\\n                pointer1 = pointer1.next;\\n            }\\n            if( count > k )\\n            {\\n                pointer2 = pointer2.next;\\n            }\\n            curr = curr.next;\\n            count++;\\n        }\\n        \\n        int temp = pointer1.val;\\n        pointer1.val = pointer2.val;\\n        pointer2.val = temp;\\n        \\n        return head;\\n    }\\n}\\n/*\\n\\nCreated a pointer which traverses till the end of the linkedlist\\nCreated pointer1 which will stop after reaching kth element\\nCreated pointer2 which will have a delayed start by kth number\\nSwap values of pointer1 and pointer2\\n\\nTime Complexity O(n)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033533,
                "title": "ultra-clean-python-high-speed",
                "content": "**Ultra Clean Python | High Speed**\\n\\n```\\nclass Solution:\\n    def swapNodes(self, head, k):\\n        \\n        n  =  head\\n        for _ in range(k-1):\\n            n  =  n.next\\n        \\n        a  =  n\\n        b  =  head\\n        \\n        while n.next:\\n            b  =  b.next\\n            n  =  n.next\\n        \\n        a.val, b.val  =  b.val, a.val\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head, k):\\n        \\n        n  =  head\\n        for _ in range(k-1):\\n            n  =  n.next\\n        \\n        a  =  n\\n        b  =  head\\n        \\n        while n.next:\\n            b  =  b.next\\n            n  =  n.next\\n        \\n        a.val, b.val  =  b.val, a.val\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913025,
                "title": "easy-to-understand-javascript-typescript-solution-with-explanation-comments",
                "content": "upvote if it helps :)\\n\\n```\\n  // initialize\\n  let first = head\\n  let second = head\\n  let endDummy = head\\n  \\n  // get kth node from beginning. move endDummy to k\\n  for (let i = 1; i < k; i++) {\\n    first = first.next\\n    endDummy = endDummy.next\\n  }\\n  \\n  // get kth node from end. move endDummy to end,\\n  // if we reach endDummy end it means we also found kth node from end in second variable\\n  // cuz diff between second and endDummy exactly k nodes thanks to previous cycle\\n  while(endDummy.next) {\\n    second = second.next\\n    endDummy = endDummy.next\\n  }\\n  \\n  // swap values. also we can use temp var\\n  [first.val, second.val] = [second.val, first.val]\\n  \\n  return head\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n  // initialize\\n  let first = head\\n  let second = head\\n  let endDummy = head\\n  \\n  // get kth node from beginning. move endDummy to k\\n  for (let i = 1; i < k; i++) {\\n    first = first.next\\n    endDummy = endDummy.next\\n  }\\n  \\n  // get kth node from end. move endDummy to end,\\n  // if we reach endDummy end it means we also found kth node from end in second variable\\n  // cuz diff between second and endDummy exactly k nodes thanks to previous cycle\\n  while(endDummy.next) {\\n    second = second.next\\n    endDummy = endDummy.next\\n  }\\n  \\n  // swap values. also we can use temp var\\n  [first.val, second.val] = [second.val, first.val]\\n  \\n  return head\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1109200,
                "title": "java-simple-and-easy-to-understand-2-ms-faster-than-99-89-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        \\n        ListNode curr =  head;\\n        \\n        //find the node\\n        ListNode kthNode = null;\\n        int i = 1;\\n        while(curr != null){\\n            if(i == k){\\n                kthNode = curr;\\n                break;\\n            }\\n            i++;\\n            curr = curr.next;\\n        }\\n        \\n        //find kth node from last\\n        ListNode slow = head;\\n        ListNode fast = kthNode;\\n        while(fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        ListNode kthNodeFromLast = slow;\\n        \\n        //swapping value kth node from beginning  to the end\\n        int temp = kthNode.val;\\n        kthNode.val = kthNodeFromLast.val;\\n        kthNodeFromLast.val = temp;\\n\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        \\n        ListNode curr =  head;\\n        \\n        //find the node\\n        ListNode kthNode = null;\\n        int i = 1;\\n        while(curr != null){\\n            if(i == k){\\n                kthNode = curr;\\n                break;\\n            }\\n            i++;\\n            curr = curr.next;\\n        }\\n        \\n        //find kth node from last\\n        ListNode slow = head;\\n        ListNode fast = kthNode;\\n        while(fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        ListNode kthNodeFromLast = slow;\\n        \\n        //swapping value kth node from beginning  to the end\\n        int temp = kthNode.val;\\n        kthNode.val = kthNodeFromLast.val;\\n        kthNodeFromLast.val = temp;\\n\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525879,
                "title": "very-easy-fast-c-soln-beginner-friendly",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is quite simple, just traverse the linked list and count its length. Then find the place(count-k+1) fron last which needed to be swapped with kth place. Once you know both the place, just iterate the forloop once again and find both the nodes. once you are done just swap their values.\\n\\n**Please upVote if it helps.**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  o(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        int count = 0;\\n        ListNode* curr = head;\\n        while(curr)\\n        {\\n            count++;\\n            curr = curr->next;\\n        }\\n        int n = count - k + 1;\\n        ListNode* begin = NULL, *end = NULL;\\n        count = 0;\\n        curr = head;\\n        while(curr)\\n        {\\n            count++;\\n            if(count == k)\\n            {\\n                begin = curr;\\n            }\\n            if(count == n)\\n            {\\n                end = curr;\\n            }\\n            if(end != NULL && begin != NULL)\\n              break;\\n            curr = curr->next;\\n        }\\n        swap(begin->val,end->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        int count = 0;\\n        ListNode* curr = head;\\n        while(curr)\\n        {\\n            count++;\\n            curr = curr->next;\\n        }\\n        int n = count - k + 1;\\n        ListNode* begin = NULL, *end = NULL;\\n        count = 0;\\n        curr = head;\\n        while(curr)\\n        {\\n            count++;\\n            if(count == k)\\n            {\\n                begin = curr;\\n            }\\n            if(count == n)\\n            {\\n                end = curr;\\n            }\\n            if(end != NULL && begin != NULL)\\n              break;\\n            curr = curr->next;\\n        }\\n        swap(begin->val,end->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525153,
                "title": "java-simple-list-traversal-10-lines-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Traverse the list and compute its length `n`.\\n2. Traverse the list again and find the `k`th and `n+1-k`th nodes.\\n3. Swap the values of the two nodes.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public ListNode swapNodes(ListNode head, int k) {\\n    var n = 0;\\n    for (var ptr = head; ptr != null; ptr = ptr.next, n++);\\n\\n    ListNode a = null, b = null, ptr = head;\\n    for (var i=1; i<=n; i++, ptr = ptr.next) {\\n      if (i == k) a = ptr;\\n      if (i == n+1-k) b = ptr;\\n    }\\n    var tmp = a.val;\\n    a.val = b.val;\\n    b.val = tmp;\\n\\n    return head;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n  public ListNode swapNodes(ListNode head, int k) {\\n    var n = 0;\\n    for (var ptr = head; ptr != null; ptr = ptr.next, n++);\\n\\n    ListNode a = null, b = null, ptr = head;\\n    for (var i=1; i<=n; i++, ptr = ptr.next) {\\n      if (i == k) a = ptr;\\n      if (i == n+1-k) b = ptr;\\n    }\\n    var tmp = a.val;\\n    a.val = b.val;\\n    b.val = tmp;\\n\\n    return head;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912823,
                "title": "c-easy-explanation-step-by-step-commented-solution",
                "content": "Firstly initalise four ListNode pointer and point them on kth, (k-1)th node from start and kth, (k-1)th node from end\\nNow just swap the nodes and return the head pointer\\n\\n| PLEASE UPVOTE IF YOU LIKE THE SOLUTION |\\n\\n```\\nclass Solution {\\npublic:\\n    int findLen(ListNode *head){\\n        int len=0;\\n        while(head){\\n            len++;\\n            head=head->next;\\n        }\\n        return len;\\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        int n=findLen(head);  // first calculate lenght of Linked_List\\n\\t\\t\\n        // if the kth node is middle element then we dont need to swap it\\n\\t\\tif((2*k-1)==n)return head;\\n        \\n        \\n        // Initialise two pointer Node which will point to the kth Node and (k-1)th node from start as we require x_prev to update (k-1)th next to correct Node\\n        ListNode *x=head;\\n        ListNode *x_prev=NULL;  \\n        int cnt=k-1; // here we initialise cnt with k-1 to get kth node as we take 0 index LL\\n        while(cnt--){\\n            x_prev=x;\\n            x=x->next;\\n        }\\n        \\n//         similarly initialise two pointer node which will point to kth ndie and (k-1)th node from end\\n        ListNode *y=head;\\n        ListNode *y_prev=NULL;\\n        cnt=n-k;\\n        while(cnt--){\\n            y_prev=y;\\n            y=y->next;\\n        }\\n        \\n//         now x node point to kth node and x_prev point to (k-1)th node form start and y and y_prev from end\\n        \\n//         now just swap the nodes\\n        if(x_prev){\\n            x_prev->next=y;\\n        }\\n        if(y_prev){\\n            y_prev->next=x;\\n        }\\n        ListNode *t=x->next;\\n        x->next=y->next;\\n        y->next=t;\\n        \\n        \\n//         here if k==1 then y node point to head\\n        if(k==1)return y;\\n//         if k==n then x node point to head\\n        \\n//         otherwise return head\\n        if(k==n)return x;\\n        return head;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLen(ListNode *head){\\n        int len=0;\\n        while(head){\\n            len++;\\n            head=head->next;\\n        }\\n        return len;\\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        int n=findLen(head);  // first calculate lenght of Linked_List\\n\\t\\t\\n        // if the kth node is middle element then we dont need to swap it\\n\\t\\tif((2*k-1)==n)return head;\\n        \\n        \\n        // Initialise two pointer Node which will point to the kth Node and (k-1)th node from start as we require x_prev to update (k-1)th next to correct Node\\n        ListNode *x=head;\\n        ListNode *x_prev=NULL;  \\n        int cnt=k-1; // here we initialise cnt with k-1 to get kth node as we take 0 index LL\\n        while(cnt--){\\n            x_prev=x;\\n            x=x->next;\\n        }\\n        \\n//         similarly initialise two pointer node which will point to kth ndie and (k-1)th node from end\\n        ListNode *y=head;\\n        ListNode *y_prev=NULL;\\n        cnt=n-k;\\n        while(cnt--){\\n            y_prev=y;\\n            y=y->next;\\n        }\\n        \\n//         now x node point to kth node and x_prev point to (k-1)th node form start and y and y_prev from end\\n        \\n//         now just swap the nodes\\n        if(x_prev){\\n            x_prev->next=y;\\n        }\\n        if(y_prev){\\n            y_prev->next=x;\\n        }\\n        ListNode *t=x->next;\\n        x->next=y->next;\\n        y->next=t;\\n        \\n        \\n//         here if k==1 then y node point to head\\n        if(k==1)return y;\\n//         if k==n then x node point to head\\n        \\n//         otherwise return head\\n        if(k==n)return x;\\n        return head;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912420,
                "title": "single-traversal-optimised-way-fully-explained-best-approach",
                "content": "**Explanation**\\nFirstly, we need to find (1) length of linked list and the source and target indexes. Then we get the initial values of founded indexes. Finally, swap the values of known indexes.\\n\\n**Complexity**\\n\\n* Time O(N+N+N)=O(N)\\n* Space O(N)\\n```\\n//please upvote, if you like my solution :)\\nListNode* swapNodes(ListNode* head, int k) {\\n        ListNode*ptr1 = head,*ptr2 = head , *kth = NULL;\\n        while(--k){\\n            ptr1 = ptr1->next;\\n        }\\n        kth = ptr1;\\n        ptr1 = ptr1->next;\\n        while(ptr1){\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n        }\\n        swap(kth->val,ptr2->val);\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n//please upvote, if you like my solution :)\\nListNode* swapNodes(ListNode* head, int k) {\\n        ListNode*ptr1 = head,*ptr2 = head , *kth = NULL;\\n        while(--k){\\n            ptr1 = ptr1->next;\\n        }\\n        kth = ptr1;\\n        ptr1 = ptr1->next;\\n        while(ptr1){\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n        }\\n        swap(kth->val,ptr2->val);\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526020,
                "title": "two-pointer-solution-easy-to-understand",
                "content": "# Approach\\nHere\\'s an explanation of the approach used in the given code:\\n\\n1. The method begins by initializing a variable `node` to reference the head of the linked list, and another variable `count` to keep track of the total number of nodes in the list.\\n2. A while loop is used to traverse the linked list until the last node is reached. In each iteration, the count is incremented, and the `node` variable is updated to reference the next node in the list.\\n3. After the loop, the `node` variable will be pointing to the last node, and the `count` variable will hold the total number of nodes in the linked list.\\n4. Next, the `node` variable is reset to reference the head of the list. This is done to start from the beginning of the list for the swapping operation.\\n5. Another variable `temp` is created and initialized to reference the head node. This variable will be used to locate the `k`th node from the end of the list.\\n6. Two for loops are used to position the `node` and `temp` variables at the `k`th node from the beginning and end respectively.\\n   - The first for loop runs `k-1` times, each time updating the `node` variable to reference the next node.\\n   - The second for loop runs `count - k` times, moving the `temp` variable `count - k` positions ahead from the head.\\n7. At this point, the `node` variable references the `k`th node from the beginning, and the `temp` variable references the `k`th node from the end.\\n8. The values of the two nodes are swapped by swapping their `val` fields. This is done by storing the value of the `node` in a temporary variable `tempn`, then assigning the value of `temp` to `node.val`, and finally assigning the value of `tempn` to `temp.val`.\\n9. After the swap, the method returns the head of the modified linked list.\\n   \\nOverall, this approach first finds the total number of nodes in the linked list, and then uses two pointers (`node` and `temp`) to locate the nodes to be swapped. It performs the swap by exchanging their values.\\n\\n# Complexity\\n- Time complexity:\\n    - The overall time complexity of the code is O(n).\\n- Space complexity:\\n    - The space complexity of the code is O(1), indicating constant space usage.\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode node=head;\\n        int count=0;\\n        while(node.next!=null)\\n        {\\n            count++;\\n            node=node.next;\\n        }\\n        node =head;        \\n        ListNode temp=head;\\n        for(int i=0;i<k-1;i++)\\n            node=node.next;\\n        \\n        for(int i=0;i<=count-k;i++)\\n            temp=temp.next;\\n            \\n        int tempn=node.val;\\n        node.val=temp.val;\\n        temp.val=tempn;\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode node=head;\\n        int count=0;\\n        while(node.next!=null)\\n        {\\n            count++;\\n            node=node.next;\\n        }\\n        node =head;        \\n        ListNode temp=head;\\n        for(int i=0;i<k-1;i++)\\n            node=node.next;\\n        \\n        for(int i=0;i<=count-k;i++)\\n            temp=temp.next;\\n            \\n        int tempn=node.val;\\n        node.val=temp.val;\\n        temp.val=tempn;\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525861,
                "title": "easy-java-solution-2ms-beats-99-56-beginner-friendly-approach",
                "content": "# Intuition\\nWe can traverse the list twice. In the first traversal, we can find the kth node from the beginning of the list, and in the second traversal, we can find the kth node from the end of the list. Once we have found both nodes, we can simply swap their values.\\n\\n# Approach\\n- Initialize three variables temp, a, and b to the head of the list.\\n- Initialize a counter variable c to 0.\\n- Traverse the list using a while loop that continues until temp is null:\\na. Increment the counter c.\\nb. If c is equal to k, store the current node in a.\\nc. Move temp to the next node.\\n- Reset temp to the head of the list.\\n- Traverse the list again using a for loop that runs from 1 to c:\\na. If i is equal to c + 1 - k, store the current node in b.\\nb. Move temp to the next node.\\n- Swap the values of a and b and return the modified list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */ \\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n    ListNode temp = head,a = head,b = head;\\n        int c = 0;\\n        while(temp != null){ \\n            c++;\\n            if(c == k) a = temp;\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        for(int i=1;i<=c;i++){\\n            if(i == (c + 1 - k)){ \\n                b = temp;\\n                break;\\n            }\\n            temp = temp.next;\\n        }\\n        int t = a.val;\\n        a.val = b.val;\\n        b.val = t;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */ \\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n    ListNode temp = head,a = head,b = head;\\n        int c = 0;\\n        while(temp != null){ \\n            c++;\\n            if(c == k) a = temp;\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        for(int i=1;i<=c;i++){\\n            if(i == (c + 1 - k)){ \\n                b = temp;\\n                break;\\n            }\\n            temp = temp.next;\\n        }\\n        int t = a.val;\\n        a.val = b.val;\\n        b.val = t;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912067,
                "title": "c-step-by-step-explanation",
                "content": "```\\nAlgorithm\\n---------\\n* Step1: Find length of LinkedList\\n* Step2: Fix one pointer at K distance from Beg and another at K distance from End\\n* Step3: Swap\\n* Step4: Return head\\n\\nComplexities\\n------------\\n* Time: O(n)\\n* Space: O(1)\\n```\\n```\\nclass Solution {\\npublic:\\n    int findLength(ListNode* head) {\\n        int len = 0;\\n        while(head) {\\n            head = head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        //compute Length\\n        int len = findLength(head);\\n        \\n        //position begPtr at K distance from beg\\n        ListNode *begPtr = head;\\n        for(int i = 0; i < k - 1; i++) begPtr = begPtr->next;\\n        \\n        //position endPtr at K distance from end\\n        ListNode *endPtr = head;\\n        for(int i = 0; i < len - k; i++) endPtr = endPtr->next;\\n        \\n        //swap\\n        swap(begPtr->val, endPtr->val);\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nAlgorithm\\n---------\\n* Step1: Find length of LinkedList\\n* Step2: Fix one pointer at K distance from Beg and another at K distance from End\\n* Step3: Swap\\n* Step4: Return head\\n\\nComplexities\\n------------\\n* Time: O(n)\\n* Space: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int findLength(ListNode* head) {\\n        int len = 0;\\n        while(head) {\\n            head = head->next;\\n            len++;\\n        }\\n        return len;\\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        //compute Length\\n        int len = findLength(head);\\n        \\n        //position begPtr at K distance from beg\\n        ListNode *begPtr = head;\\n        for(int i = 0; i < k - 1; i++) begPtr = begPtr->next;\\n        \\n        //position endPtr at K distance from end\\n        ListNode *endPtr = head;\\n        for(int i = 0; i < len - k; i++) endPtr = endPtr->next;\\n        \\n        //swap\\n        swap(begPtr->val, endPtr->val);\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912048,
                "title": "beginner-friendly-javascript-solution",
                "content": "Using two pointers to locate k th index element and the element needs to be swapped.\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar swapNodes = function(head, k) {\\n    let fast = head, second = head, first = head\\n    for(let i=0; i<k-1; i++)    fast = fast.next\\n    first = fast\\n    while(fast.next != null){\\n        fast = fast.next\\n        second = second.next\\n    }\\n    let temp = first.val\\n    first.val = second.val\\n    second.val = temp\\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar swapNodes = function(head, k) {\\n    let fast = head, second = head, first = head\\n    for(let i=0; i<k-1; i++)    fast = fast.next\\n    first = fast\\n    while(fast.next != null){\\n        fast = fast.next\\n        second = second.next\\n    }\\n    let temp = first.val\\n    first.val = second.val\\n    second.val = temp\\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791983,
                "title": "swapping-nodes-in-a-linked-list-c",
                "content": "class Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n\\t\\tListNode *ptr=head;\\n        int x=0;\\n        while(ptr->next!=NULL){         \\n            ptr=ptr->next;\\n            x++;\\n        }             \\n              ListNode *curr=head;\\n              for(int i = 0 ; i<k-1 ; i++){                 \\n                  curr=curr->next;             \\n              }\\n             \\n              ListNode *curr2=head;\\n             for(int i = 0 ; i<x-k+1 ; i++) {\\n                   curr2=curr2->next;                \\n              }\\n              swap(curr->val,curr2->val);\\n              return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n\\t\\tListNode *ptr=head;\\n        int x=0;\\n        while(ptr->next!=NULL){         \\n            ptr=ptr->next;\\n            x++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1641567,
                "title": "very-easy-o-n-solution-in-js-with-clear-explanation-beginner-friendly",
                "content": "Time complexity: O(n)\\nSpace Complexity: O(1)\\n\\n\\n**IDEA:**\\n\\n1. Create dummy node and set next to head(given).\\n2. Take 2 pointers **slow** and **fast** and set to dummy node created in step 1.\\n3. Advance fast pointer **k** times, now this is our \"firstNode\", whose value need to be swapped.\\n4. Now advance **slow** and **fast** pointers till fast is null. At the end slow will point to node which is **n - k** from end. Hence we have our \"secondNode\".\\n5. Lastly swap the values of \"firstNode\" and \"secondNode\".\\n\\n**Note**: we are not exactly using slow and fast pointer, just like we do to calculate middle of linked list. Its just that one pointer is k times behind the other pointer.\\n\\n```\\n\\nvar swapNodes = function(head, k) {\\n\\tconst newHead = new ListNode(0, head);\\n    \\n    let slow = newHead, fast = newHead;\\n    let firstNode = null, secondNode = null;\\n    \\n    while(k > 0) {\\n        fast = fast.next;\\n        k -= 1;\\n    }\\n    \\n    firstNode = fast;\\n    \\n     while(fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    secondNode = slow;\\n    \\n    let temp = secondNode.val;\\n    secondNode.val = firstNode.val;\\n    firstNode.val = temp;\\n    \\n    return newHead.next;\\n}\\n\\n```\\n\\nHope it help!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar swapNodes = function(head, k) {\\n\\tconst newHead = new ListNode(0, head);\\n    \\n    let slow = newHead, fast = newHead;\\n    let firstNode = null, secondNode = null;\\n    \\n    while(k > 0) {\\n        fast = fast.next;\\n        k -= 1;\\n    }\\n    \\n    firstNode = fast;\\n    \\n     while(fast) {\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    \\n    secondNode = slow;\\n    \\n    let temp = secondNode.val;\\n    secondNode.val = firstNode.val;\\n    firstNode.val = temp;\\n    \\n    return newHead.next;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1096722,
                "title": "python-super-easy-to-understand-o-n-time-o-1-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        length, curr = 1, head\\n        while curr:\\n            length += 1\\n            curr = curr.next\\n        length -= k\\n        v1, v2 = head, head\\n        while length > 1:\\n            length -= 1\\n            v1 = v1.next\\n        while k > 1:\\n            k -= 1\\n            v2 = v2.next\\n        v1.val, v2.val = v2.val, v1.val\\n        return head\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        length, curr = 1, head\\n        while curr:\\n            length += 1\\n            curr = curr.next\\n        length -= k\\n        v1, v2 = head, head\\n        while length > 1:\\n            length -= 1\\n            v1 = v1.next\\n        while k > 1:\\n            k -= 1\\n            v2 = v2.next\\n        v1.val, v2.val = v2.val, v1.val\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009779,
                "title": "python-cpp-c-easy-solution-with-explanation-accepted",
                "content": "\\n\\n**Explanation**\\nFirstly, we need to find (1) length of linked list and the source and target indexes. Then we get the initial values of founded indexes. Finally, swap the values of known indexes.\\n\\n**Complexity**\\n\\nTime ```O(N+N+N)=O(N)```\\nSpace ```O(N)```\\n\\n**Python:**\\n```\\ndef swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        n, tmp = 0,head\\n        while tmp:\\n            n += 1\\n            tmp = tmp.next\\n        ind_1, ind_2 = k, n-k+1\\n        if ind_1 == ind_2:\\n            return head\\n        \\n        n, tmp = 0, head\\n        val_1, val_2=0, 0\\n        while tmp:\\n            n+=1\\n            if n==ind_1:\\n                val_1 = tmp.val\\n            if n==ind_2:\\n                val_2 = tmp.val\\n            tmp = tmp.next\\n        \\n        n, tmp = 0, head\\n        while tmp:\\n            n += 1\\n            if n==ind_1:\\n                tmp.val = val_2\\n            if n==ind_2:\\n                tmp.val = val_1\\n            tmp = tmp.next\\n        \\n        return head\\n        \\n```\\n**C++**\\n\\n```\\nListNode* swapNodes(ListNode* head, int k) {\\n        int n = 0; \\n        ListNode* tmp = head;\\n        while (tmp){\\n            n += 1;\\n            tmp = tmp->next;\\n        }\\n        int ind_1= k, ind_2 = n-k+1;\\n        if (ind_1 == ind_2)\\n            return head;\\n        \\n        n = 0; \\n        tmp = head;\\n        int val_1=0, val_2=0;\\n        while (tmp){\\n            n+=1;\\n            if (n==ind_1)\\n                val_1 = tmp->val;\\n            if (n==ind_2)\\n                val_2 = tmp->val;\\n            tmp = tmp->next;\\n        }\\n        n = 0; \\n        tmp = head;\\n        while (tmp){\\n            n += 1;\\n            if (n==ind_1)\\n                tmp->val = val_2;\\n            if (n==ind_2)\\n                tmp->val = val_1;\\n            tmp = tmp->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C"
                ],
                "code": "```O(N+N+N)=O(N)```\n```O(N)```\n```\\ndef swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        n, tmp = 0,head\\n        while tmp:\\n            n += 1\\n            tmp = tmp.next\\n        ind_1, ind_2 = k, n-k+1\\n        if ind_1 == ind_2:\\n            return head\\n        \\n        n, tmp = 0, head\\n        val_1, val_2=0, 0\\n        while tmp:\\n            n+=1\\n            if n==ind_1:\\n                val_1 = tmp.val\\n            if n==ind_2:\\n                val_2 = tmp.val\\n            tmp = tmp.next\\n        \\n        n, tmp = 0, head\\n        while tmp:\\n            n += 1\\n            if n==ind_1:\\n                tmp.val = val_2\\n            if n==ind_2:\\n                tmp.val = val_1\\n            tmp = tmp.next\\n        \\n        return head\\n        \\n```\n```\\nListNode* swapNodes(ListNode* head, int k) {\\n        int n = 0; \\n        ListNode* tmp = head;\\n        while (tmp){\\n            n += 1;\\n            tmp = tmp->next;\\n        }\\n        int ind_1= k, ind_2 = n-k+1;\\n        if (ind_1 == ind_2)\\n            return head;\\n        \\n        n = 0; \\n        tmp = head;\\n        int val_1=0, val_2=0;\\n        while (tmp){\\n            n+=1;\\n            if (n==ind_1)\\n                val_1 = tmp->val;\\n            if (n==ind_2)\\n                val_2 = tmp->val;\\n            tmp = tmp->next;\\n        }\\n        n = 0; \\n        tmp = head;\\n        while (tmp){\\n            n += 1;\\n            if (n==ind_1)\\n                tmp->val = val_2;\\n            if (n==ind_2)\\n                tmp->val = val_1;\\n            tmp = tmp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1913252,
                "title": "2-pointers-python",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        front, last = head,head\\n        while k>1:\\n            front = front.next\\n            k-=1\\n        left = front\\n        while left.next!=None:\\n            left = left.next\\n            last = last.next\\n        front.val, last.val = last.val, front.val\\n        return head\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        front, last = head,head\\n        while k>1:\\n            front = front.next\\n            k-=1\\n        left = front\\n        while left.next!=None:\\n            left = left.next\\n            last = last.next\\n        front.val, last.val = last.val, front.val\\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912057,
                "title": "beginner-friendly-python-solution",
                "content": "Using two pointers to locate k th index element and the element needs to be swapped.\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def swapNodes(self, head, k):\\n        first = fast = second = head\\n        for i in range(1, k):\\n            fast = fast.next\\n        first = fast\\n        while fast.next:\\n            fast = fast.next\\n            second = second.next\\n        first.val, second.val = second.val, first.val\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def swapNodes(self, head, k):\\n        first = fast = second = head\\n        for i in range(1, k):\\n            fast = fast.next\\n        first = fast\\n        while fast.next:\\n            fast = fast.next\\n            second = second.next\\n        first.val, second.val = second.val, first.val\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150568,
                "title": "very-easy-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        if(head==NULL or head->next==NULL) {\\n            return head;\\n        }\\n        \\n        int val = k;\\n        \\n        ListNode* temp1 = head;\\n        while(k>1) {\\n            temp1 = temp1->next;\\n            k--;\\n        }\\n        \\n        ListNode*temp2 = head;\\n        int count = 1;\\n        while(temp2) {\\n            temp2 = temp2->next;\\n            count++;\\n        }\\n        \\n        ListNode*temp3 = head;\\n        int end = count - val;\\n        while(end>1 and temp3->next) {\\n            temp3 = temp3->next;\\n            end--;\\n        }\\n        \\n        swap(temp1->val, temp3->val);\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        if(head==NULL or head->next==NULL) {\\n            return head;\\n        }\\n        \\n        int val = k;\\n        \\n        ListNode* temp1 = head;\\n        while(k>1) {\\n            temp1 = temp1->next;\\n            k--;\\n        }\\n        \\n        ListNode*temp2 = head;\\n        int count = 1;\\n        while(temp2) {\\n            temp2 = temp2->next;\\n            count++;\\n        }\\n        \\n        ListNode*temp3 = head;\\n        int end = count - val;\\n        while(end>1 and temp3->next) {\\n            temp3 = temp3->next;\\n            end--;\\n        }\\n        \\n        swap(temp1->val, temp3->val);\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109467,
                "title": "java-swap-nodes-not-values-explained",
                "content": "**Problem**\\nSay the linked list is:\\n\\n```. . . -> p1 -> x -> n1 -> . . . -> p2 -> y -> n2 -> . . .```\\n\\nour goal is to swap nodes ```x``` and ```y``` so that it becomes:\\n\\n```. . . -> p1 -> y -> n1 -> . . . -> p2 -> x -> n2 -> . . .```\\n\\n**Solution**\\n1. Insert a dummy head in the beginning. Doing so helps avoid special check for the case when head node has to be swapped and hence head of the list gets changed. With this trick, we can simply return ```dummy.next``` for all cases.\\n2. Locate the nodes ```x``` and ```y``` and their corresponding previous nodes, ```p1``` and ```p2```.\\n\\t- To find previous node ```p1``` to ```k```\\'th node from the beginning ```x```:\\n\\t\\t- Initialize ```p1``` with dummy head and move it ```k - 1``` times\\n\\t- To find previous node ```p2``` to ```k```\\'th node from the end ```y```:\\n\\t\\t- Initialize a node ```ahead``` with dummy head and move it ```k + 1``` times\\n\\t\\t- Now initialize ```p2``` with dummy head and keep moving both ```ahead``` and ```p2``` one node at a time till ```ahead``` is not null\\n3. Now that we have ```p1``` and ```p2``` (and consequently ```x (= p1.next)``` and ```y (= p2.next)```), we need to carefully update the pointers without losing reference to desired nodes. Pen and paper might be helpful at this point; actually use them for all linked list problems :)\\n\\t- If ```p1``` and ```p2``` are the same, that would mean ```x``` and ```y``` are the same nodes, so do nothing.\\n\\t- Else:\\n\\t\\t- p1.next = y\\n\\t\\t- p2.next = x\\n\\t\\t- n2 = y.next\\n\\t\\t- y.next = x.next\\n\\t\\t- x.next = n2\\n\\n```\\npublic ListNode swapNodes(ListNode head, int k) {\\n    ListNode dummy = new ListNode(-1, head), p1 = dummy;\\n    for(int i = 0; i < k - 1; i++) {\\n        p1 = p1.next;\\n    }\\n    ListNode ahead = dummy, p2 = dummy;\\n    for(int i = 0; i < k + 1; i++) {\\n        ahead = ahead.next;\\n    }\\n    while(ahead != null) {\\n        ahead = ahead.next;\\n        p2 = p2.next;\\n    }\\n    if(p1 != p2) {\\n        ListNode x = p1.next, y = p2.next;\\n        p1.next = y;\\n        p2.next = x;\\n        ListNode n2 = y.next;\\n        y.next = x.next;\\n        x.next = n2;\\n    }\\n    return dummy.next;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```. . . -> p1 -> x -> n1 -> . . . -> p2 -> y -> n2 -> . . .```\n```x```\n```y```\n```. . . -> p1 -> y -> n1 -> . . . -> p2 -> x -> n2 -> . . .```\n```dummy.next```\n```x```\n```y```\n```p1```\n```p2```\n```p1```\n```k```\n```x```\n```p1```\n```k - 1```\n```p2```\n```k```\n```y```\n```ahead```\n```k + 1```\n```p2```\n```ahead```\n```p2```\n```ahead```\n```p1```\n```p2```\n```x (= p1.next)```\n```y (= p2.next)```\n```p1```\n```p2```\n```x```\n```y```\n```\\npublic ListNode swapNodes(ListNode head, int k) {\\n    ListNode dummy = new ListNode(-1, head), p1 = dummy;\\n    for(int i = 0; i < k - 1; i++) {\\n        p1 = p1.next;\\n    }\\n    ListNode ahead = dummy, p2 = dummy;\\n    for(int i = 0; i < k + 1; i++) {\\n        ahead = ahead.next;\\n    }\\n    while(ahead != null) {\\n        ahead = ahead.next;\\n        p2 = p2.next;\\n    }\\n    if(p1 != p2) {\\n        ListNode x = p1.next, y = p2.next;\\n        p1.next = y;\\n        p2.next = x;\\n        ListNode n2 = y.next;\\n        y.next = x.next;\\n        x.next = n2;\\n    }\\n    return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526818,
                "title": "recursion-c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int x = 0;\\n    ListNode* q;\\n    void solve(ListNode* p, int &k){\\n        if(p==NULL){\\n            x = -1;\\n            return;\\n        }\\n        solve(p->next,k);\\n        k--;\\n        if(k==0){\\n            swap(p->val,q->val);\\n            return;\\n        }\\n        q = q->next;\\n\\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        q = head;\\n        solve(head,k);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x = 0;\\n    ListNode* q;\\n    void solve(ListNode* p, int &k){\\n        if(p==NULL){\\n            x = -1;\\n            return;\\n        }\\n        solve(p->next,k);\\n        k--;\\n        if(k==0){\\n            swap(p->val,q->val);\\n            return;\\n        }\\n        q = q->next;\\n\\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        q = head;\\n        solve(head,k);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187763,
                "title": "two-pointer-c-approach",
                "content": "**Idea of solution is to have two pointers:** a left pointer and a right pointer\\nInitialize both to the head, and a counter variable\\n\\n**Left pointer:**\\nIterate through the Linked list, and while the counter is less than k, increment the left pointer.\\nAfter the counter greater than or equal to k, we do not want to move the left pointer anymore since it is in the desired position.\\n\\n**Right pointer:**\\nThe right pointer should not start moving until our counter exceeds k, this way the right pointer \\'lags\\' behind the current pointer by k nodes.\\nAfter counter exceeds k, we increment it each iteration together with the current pointer, keeping the k node lag\\n\\nAfter current reaches end of the list, we can swap the values in the left and right node to get our result\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        int n=0;\\n        ListNode* temp=head,*left=head,*right=head;\\n        while(temp)\\n        {\\n            n++;\\n            if(n<k)\\n            {\\n                left=left->next;\\n            }\\n            if(n>k)\\n            {\\n                right=right->next;\\n            }\\n            temp=temp->next;\\n            \\n        }      \\n        swap(left->val,right->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        int n=0;\\n        ListNode* temp=head,*left=head,*right=head;\\n        while(temp)\\n        {\\n            n++;\\n            if(n<k)\\n            {\\n                left=left->next;\\n            }\\n            if(n>k)\\n            {\\n                right=right->next;\\n            }\\n            temp=temp->next;\\n            \\n        }      \\n        swap(left->val,right->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914347,
                "title": "swapping-nodes-in-a-linked-list-basic",
                "content": "<--- MY FIRST POST ---->\\nThis is the most basic approach one would think of at first. To make it more easier i have converted the problem to 0-indexed. I used two pointers front and back to point the nodes and then swap their values in end.\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int lenght( ListNode* h)\\n    {\\n        int c=0;\\n        while(h)\\n        {\\n            c+=1;\\n            h=h->next;\\n        }\\n        return c;\\n        \\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        if(k==0)\\n            return head;\\n        if(head==NULL)\\n            return NULL;\\n        \\n        int len=lenght(head);\\n        if(len==1)\\n            return head;\\n        int front=k-1;\\n        int back=len-k;\\n        int num1=INT_MIN,num2=INT_MIN;\\n        ListNode *f,*b,* p=head;\\n        int count =0;\\n        while(p)\\n        {\\n            if(front==back)\\n                return head;\\n            \\n            if(count==front){\\n                f=p;\\n                cout<<p->val<<front<<endl;\\n                num1=p-> val;}\\n           else  if(count==back){\\n               b=p;\\n               cout<<p->val<<back<<endl;\\n                num2=p->val;}\\n            count+=1;\\n            p=p->next;\\n        }\\n        f->val=num2;\\n        b->val=num1;\\n        return head;\\n    \\n    }\\n};\\n```\\nThanks Please upvote.",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int lenght( ListNode* h)\\n    {\\n        int c=0;\\n        while(h)\\n        {\\n            c+=1;\\n            h=h->next;\\n        }\\n        return c;\\n        \\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        if(k==0)\\n            return head;\\n        if(head==NULL)\\n            return NULL;\\n        \\n        int len=lenght(head);\\n        if(len==1)\\n            return head;\\n        int front=k-1;\\n        int back=len-k;\\n        int num1=INT_MIN,num2=INT_MIN;\\n        ListNode *f,*b,* p=head;\\n        int count =0;\\n        while(p)\\n        {\\n            if(front==back)\\n                return head;\\n            \\n            if(count==front){\\n                f=p;\\n                cout<<p->val<<front<<endl;\\n                num1=p-> val;}\\n           else  if(count==back){\\n               b=p;\\n               cout<<p->val<<back<<endl;\\n                num2=p->val;}\\n            count+=1;\\n            p=p->next;\\n        }\\n        f->val=num2;\\n        b->val=num1;\\n        return head;\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1913059,
                "title": "concise-single-pass-solution-with-explanation-time-o-n-space-o-1",
                "content": "Here is the approach:\\n1. Find the `k`-th node and keep a reference to it (`a`).\\n2. Keep going until the end of the list, but this time with two pointers (see the picture below the code).\\n3. Swap the values and return the original `head`.\\n\\n```csharp\\npublic class Solution\\n{\\n    public ListNode SwapNodes(ListNode head, int k)\\n    {\\n        var h = head;\\n\\n        while (--k > 0) h = h.next;\\n        var (a, b) = (h, head);\\n\\n        while (h.next != null) (h, b) = (h.next, b.next);\\n        (a.val, b.val) = (b.val, a.val);\\n\\n        return head;\\n    }\\n}\\n```\\n\\nAbout the picture: Its upper part represents the state before the second while loop. The lower part represents the state after the second while loop:\\n![image](https://assets.leetcode.com/users/images/2c5d7b4f-33f2-440d-b13e-7ae463a7e40b_1649064078.6884098.png)\\n\\nSee the distance between `second` and `cur`? It\\'s `k`, so when `cur` reaches the end of the list, `second` stops at the `(end - k)`-th node. Now the values of `first` and `second` can be swapped.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public ListNode SwapNodes(ListNode head, int k)\\n    {\\n        var h = head;\\n\\n        while (--k > 0) h = h.next;\\n        var (a, b) = (h, head);\\n\\n        while (h.next != null) (h, b) = (h.next, b.next);\\n        (a.val, b.val) = (b.val, a.val);\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912021,
                "title": "swapping-nodes-java-solution",
                "content": "\\n\\n```\\nclass Solution {\\n  public ListNode swapNodes(ListNode head, int k) {\\n    ListNode val = new ListNode(-1, head), p1 = val;\\n    for(int i = 0; i < k - 1; i++) {\\n        p1 = p1.next;\\n    }\\n    ListNode ahead = val, p2 = val;\\n    for(int i = 0; i < k + 1; i++) {\\n        ahead = ahead.next;\\n    }\\n    while(ahead != null) {\\n        ahead = ahead.next;\\n        p2 = p2.next;\\n    }\\n    if(p1 != p2) {\\n        ListNode x = p1.next, y = p2.next;\\n        p1.next = y;\\n        p2.next = x;\\n        ListNode n2 = y.next;\\n        y.next = x.next;\\n        x.next = n2;\\n    }\\n    return val.next;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n  public ListNode swapNodes(ListNode head, int k) {\\n    ListNode val = new ListNode(-1, head), p1 = val;\\n    for(int i = 0; i < k - 1; i++) {\\n        p1 = p1.next;\\n    }\\n    ListNode ahead = val, p2 = val;\\n    for(int i = 0; i < k + 1; i++) {\\n        ahead = ahead.next;\\n    }\\n    while(ahead != null) {\\n        ahead = ahead.next;\\n        p2 = p2.next;\\n    }\\n    if(p1 != p2) {\\n        ListNode x = p1.next, y = p2.next;\\n        p1.next = y;\\n        p2.next = x;\\n        ListNode n2 = y.next;\\n        y.next = x.next;\\n        x.next = n2;\\n    }\\n    return val.next;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775192,
                "title": "c-single-pass-solution-o-n-time-o-1-space",
                "content": "**Approch:**\\n1. Increment the ptr1 upto kth node and save this node in \\'kth\\' pointer\\n2. Now ptr1 has to travel n-k nodes to reach the end node.\\n3. Incremenet ptr2 until ptr1 reaches to the end node.\\n4. Eventually ptr2 has travelled n-k nodes. Hence swap values of ptr2 and kth pointer.\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        ListNode *ptr1 = head, *ptr2 = head, *kth = NULL;\\n        \\n        while(k > 1)\\n        {\\n            ptr1 = ptr1->next;\\n            k--;\\n        }\\n        kth = ptr1;\\n        \\n        while(ptr1->next != NULL)\\n        {\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n        }\\n        swap(kth->val, ptr2->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        ListNode *ptr1 = head, *ptr2 = head, *kth = NULL;\\n        \\n        while(k > 1)\\n        {\\n            ptr1 = ptr1->next;\\n            k--;\\n        }\\n        kth = ptr1;\\n        \\n        while(ptr1->next != NULL)\\n        {\\n            ptr1 = ptr1->next;\\n            ptr2 = ptr2->next;\\n        }\\n        swap(kth->val, ptr2->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366214,
                "title": "optimized-solution-o-n-time-swapping-of-nodes-in-java",
                "content": "\\'\\'\\'\\nFind the position of both the nodes, first node is at position `k ` and second node is at position  `(length of linked list) - k + 1`. \\nMake connections while swapping the nodes.\\n\\n**Java Solution**\\n\\n    public ListNode swapNodes(ListNode head, int k) {\\n\\t\\n        if(head == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n        \\n        ListNode temp = head;\\n        ListNode prev = null;\\n    \\tListNode firstNode = null;\\n    \\tListNode firstNodePrev = null;\\n    \\tListNode secondNode = null;\\n    \\tListNode secondNodePrev = null;\\n    \\t\\n    \\tint n = length(head) - k + 1;    \\t\\n    \\tint m = k;\\n    \\twhile(temp != null) {\\n    \\t\\tif(m-- > 0) {\\n    \\t\\t\\tfirstNodePrev = prev;\\n    \\t\\t\\tfirstNode = temp;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(n-- > 0) {\\n    \\t\\t\\tsecondNodePrev = prev;\\n    \\t\\t\\tsecondNode = temp;\\n    \\t\\t}\\n            prev = temp;\\n    \\t\\ttemp = temp.next;\\n    \\t}\\n        \\n        if(firstNodePrev != null) {\\n\\t        firstNodePrev.next = secondNode;\\n\\t    }\\n\\t    else{\\n\\t        head = secondNode;\\n\\t    }\\n\\t    \\n        if(secondNodePrev != null) {\\n\\t        secondNodePrev.next = firstNode;\\n\\t    }\\n\\t    else{\\n\\t        head = firstNode;\\n\\t    }\\n\\t    \\n        ListNode temp1=secondNode.next;\\n\\t    secondNode.next=firstNode.next;\\n\\t    firstNode.next=temp1;\\n\\t    return head;  \\t\\n    }\\n    \\n    public int length(ListNode head) {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null)\\n        {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "\\'\\'\\'\\nFind the position of both the nodes, first node is at position `k ` and second node is at position  `(length of linked list) - k + 1`. \\nMake connections while swapping the nodes.\\n\\n**Java Solution**\\n\\n    public ListNode swapNodes(ListNode head, int k) {\\n\\t\\n        if(head == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n        \\n        ListNode temp = head;\\n        ListNode prev = null;\\n    \\tListNode firstNode = null;\\n    \\tListNode firstNodePrev = null;\\n    \\tListNode secondNode = null;\\n    \\tListNode secondNodePrev = null;\\n    \\t\\n    \\tint n = length(head) - k + 1;    \\t\\n    \\tint m = k;\\n    \\twhile(temp != null) {\\n    \\t\\tif(m-- > 0) {\\n    \\t\\t\\tfirstNodePrev = prev;\\n    \\t\\t\\tfirstNode = temp;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif(n-- > 0) {\\n    \\t\\t\\tsecondNodePrev = prev;\\n    \\t\\t\\tsecondNode = temp;\\n    \\t\\t}\\n            prev = temp;\\n    \\t\\ttemp = temp.next;\\n    \\t}\\n        \\n        if(firstNodePrev != null) {\\n\\t        firstNodePrev.next = secondNode;\\n\\t    }\\n\\t    else{\\n\\t        head = secondNode;\\n\\t    }\\n\\t    \\n        if(secondNodePrev != null) {\\n\\t        secondNodePrev.next = firstNode;\\n\\t    }\\n\\t    else{\\n\\t        head = firstNode;\\n\\t    }\\n\\t    \\n        ListNode temp1=secondNode.next;\\n\\t    secondNode.next=firstNode.next;\\n\\t    firstNode.next=temp1;\\n\\t    return head;  \\t\\n    }\\n    \\n    public int length(ListNode head) {\\n        ListNode temp = head;\\n        int count = 0;\\n        while (temp != null)\\n        {\\n            count++;\\n            temp = temp.next;\\n        }\\n        return count;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1109559,
                "title": "cpp-single-pass-solution-o-n-time-constant-space-easy-to-understand",
                "content": "Space Complexity - O(1)\\nTime Complexity  - O(n) ; where n is the number of nodes in the linked list\\nThree Pointers - Single Pass\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left = nullptr, *right = nullptr, *trav = head;\\n        while(trav){\\n            if(right) right = right->next;\\n            if(--k == 0){\\n                left = trav;\\n                right = head;\\n            }\\n            trav = trav->next;\\n        }\\n        swap(left->val,right->val);\\n        return head;\\n    }\\n};\\n```\\n\\n1. We use trav to traverse the linked list\\n2. Left will be assigned the kth node when trav arrives there. This can be done by decrementing k and checking if it turned 0\\n3. At that time we can assign right as head so now the distance between trav and right will be k nodes (k-1 at the time of first assigning head to right and then k when we increment the trav node).\\n4. When trav reaches the end and becomes null right will be at the (n-k)th node: where n is the length of the linked list.\\n5. Then we can swap the values and return the head.\\n\\n<em>Note: We should iterate right only after it is assigned the value. And we check this before incrementing trav to get the position correct after first assigning</em>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left = nullptr, *right = nullptr, *trav = head;\\n        while(trav){\\n            if(right) right = right->next;\\n            if(--k == 0){\\n                left = trav;\\n                right = head;\\n            }\\n            trav = trav->next;\\n        }\\n        swap(left->val,right->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108994,
                "title": "o-n-easy-solution-c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<ListNode*> vect;\\n        ListNode* tmp=head;\\n        while(tmp)\\n        {\\n            vect.push_back(tmp);\\n            tmp=tmp->next;\\n        }\\n        int t1=vect[k-1]->val;\\n        vect[k-1]->val=vect[vect.size()-k]->val;\\n        vect[vect.size()-k]->val=t1;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<ListNode*> vect;\\n        ListNode* tmp=head;\\n        while(tmp)\\n        {\\n            vect.push_back(tmp);\\n            tmp=tmp->next;\\n        }\\n        int t1=vect[k-1]->val;\\n        vect[k-1]->val=vect[vect.size()-k]->val;\\n        vect[vect.size()-k]->val=t1;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108936,
                "title": "swapping-nodes-in-a-linked-list-js-python-java-c-short-simple-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIt\\'s important to notice that the instructions don\\'t specify that we have to actually swap the *nodes*, just the *values*. So the only thing remaining is to just find both nodes.\\n\\nSince we don\\'t know how long the linked list is, we\\'ll have to iterate to the end of it before we can possibly find the second node to swap out. But to make things easier, we don\\'t have to find and store the length and then calculate the difference, we can just take advantage of the fact that the distance from the **k**th node to the end is the same as the distance from the beginning to the **k**th node from the end.\\n\\n![Visual 1](https://i.imgur.com/oQ76PFv.png)\\n\\nWe can move the first list (**A**) forward to the **k**th node, making sure to store it in a variable (**nodeK**), then start our staggered list (**B**) and iterate both until **A** ends, at which point we should be at the **k**th node from the end.\\n\\nThen we just swap the values and **return head**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe code for all four languages is almost exactly the same.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **484ms / 73.5MB** (beats 99% / 89%).\\n```javascript\\nvar swapNodes = function(head, k) {\\n    let A = head, B = head, K, temp\\n    for (let i = 1; i < k; i++) A = A.next\\n    K = A, A = A.next\\n    while (A) A = A.next, B = B.next\\n    temp = K.val, K.val = B.val, B.val = temp\\n    return head\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **996ms / 48.7MB** (beats 99% / 97%).\\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        A, B = head, head\\n        for i in range(1, k): A = A.next\\n        nodeK, A = A, A.next\\n        while A: A, B = A.next, B.next\\n        nodeK.val, B.val = B.val, nodeK.val\\n        return head\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 64.5MB** (beats 100% / 88%).\\n```java\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode A = head, B = head, nodeK;\\n        for (int i = 1; i < k; i++) A = A.next;\\n        nodeK = A;\\n        A = A.next;\\n        while (A != null) {\\n            A = A.next;\\n            B = B.next;\\n        }\\n        int temp = nodeK.val;\\n        nodeK.val = B.val;\\n        B.val = temp;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **572ms / 180.0MB** (beats 94% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *A = head, *B = head, *nodeK;\\n        for (int i = 1; i < k; i++) A = A->next;\\n        nodeK = A, A = A->next;\\n        while (A) A = A->next, B = B->next;\\n        int temp = nodeK->val;\\n        nodeK->val = B->val, B->val = temp;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar swapNodes = function(head, k) {\\n    let A = head, B = head, K, temp\\n    for (let i = 1; i < k; i++) A = A.next\\n    K = A, A = A.next\\n    while (A) A = A.next, B = B.next\\n    temp = K.val, K.val = B.val, B.val = temp\\n    return head\\n};\\n```\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        A, B = head, head\\n        for i in range(1, k): A = A.next\\n        nodeK, A = A, A.next\\n        while A: A, B = A.next, B.next\\n        nodeK.val, B.val = B.val, nodeK.val\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode A = head, B = head, nodeK;\\n        for (int i = 1; i < k; i++) A = A.next;\\n        nodeK = A;\\n        A = A.next;\\n        while (A != null) {\\n            A = A.next;\\n            B = B.next;\\n        }\\n        int temp = nodeK.val;\\n        nodeK.val = B.val;\\n        B.val = temp;\\n        return head;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *A = head, *B = head, *nodeK;\\n        for (int i = 1; i < k; i++) A = A->next;\\n        nodeK = A, A = A->next;\\n        while (A) A = A->next, B = B->next;\\n        int temp = nodeK->val;\\n        nodeK->val = B->val, B->val = temp;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009823,
                "title": "java-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode start = head;\\n        ListNode end   = null;\\n        int len =0;\\n        while(start.next!=null) {\\n            \\n            start = start.next;\\n            len++;\\n            \\n        }\\n       \\n        len = len -k+1;;\\n        start = head;\\n        end = head;\\n        while(k-->1){\\n            start = start.next;\\n            \\n        }\\n        while(len-->0){\\n            end = end.next;\\n        }\\n       \\n        int swap = start.val;\\n        start.val = end.val;\\n        end.val = swap;\\n        \\n        \\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode start = head;\\n        ListNode end   = null;\\n        int len =0;\\n        while(start.next!=null) {\\n            \\n            start = start.next;\\n            len++;\\n            \\n        }\\n       \\n        len = len -k+1;;\\n        start = head;\\n        end = head;\\n        while(k-->1){\\n            start = start.next;\\n            \\n        }\\n        while(len-->0){\\n            end = end.next;\\n        }\\n       \\n        int swap = start.val;\\n        start.val = end.val;\\n        end.val = swap;\\n        \\n        \\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529863,
                "title": "c-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n      ListNode* left_ptr=head;\\n      ListNode* count_ptr=head;\\n\\n      int count=0;\\n      while(count_ptr->next!=NULL)\\n      {\\n          count++;\\n          count_ptr=count_ptr->next;\\n      }\\n      \\n      for(int i=0;i<k-1;i++)\\n      {\\n          left_ptr=left_ptr->next;\\n      }\\n      int len=(count-k)+1;\\n   \\n      ListNode* right_ptr=head;\\n      for(int i=0;i<len;i++)\\n      {\\n          right_ptr=right_ptr->next;\\n      }\\n      swap(left_ptr->val,right_ptr->val);\\n      return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n      ListNode* left_ptr=head;\\n      ListNode* count_ptr=head;\\n\\n      int count=0;\\n      while(count_ptr->next!=NULL)\\n      {\\n          count++;\\n          count_ptr=count_ptr->next;\\n      }\\n      \\n      for(int i=0;i<k-1;i++)\\n      {\\n          left_ptr=left_ptr->next;\\n      }\\n      int len=(count-k)+1;\\n   \\n      ListNode* right_ptr=head;\\n      for(int i=0;i<len;i++)\\n      {\\n          right_ptr=right_ptr->next;\\n      }\\n      swap(left_ptr->val,right_ptr->val);\\n      return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526484,
                "title": "rust-elegant-trait-iterators-solution-48-lines-beats-83-runtime-and-memory-no-extra-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCut the list into sublists:\\n* a = before n1\\n* n1\\n* b = between n1 and n2\\n* n2\\n* c = after n2\\n\\nThen combine them as `[a, n2, b, n1, c]`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a trait for an elegant solution.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::iter::successors;\\n\\n// // Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//     pub val: i32,\\n//     pub next: Option<Box<ListNode>>,\\n// }\\n//\\n// impl ListNode {\\n//     #[inline]\\n//     fn new(val: i32) -> Self {\\n//         ListNode { next: None, val }\\n//     }\\n// }\\n\\ntrait ExtendedList {\\n    fn last(&mut self) -> &mut Self;\\n    fn join(self, b: Self) -> Self;\\n    fn cut_at(&mut self, k: usize) -> Self;\\n}\\n\\nimpl ExtendedList for Option<Box<ListNode>> {\\n    fn last(&mut self) -> &mut Self {\\n        if self.is_some() {\\n            self.as_mut().unwrap().next.last()\\n        } else {\\n            self\\n        }\\n    }\\n    fn join(mut self, other: Self) -> Self {\\n        *self.last() = other;\\n        self\\n    }\\n    fn cut_at(&mut self, k: usize) -> Self {\\n        if k > 0 {\\n            self.as_mut()?.next.cut_at(k - 1)\\n        } else {\\n            self.take()\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn swap_nodes(mut head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let n = successors(head.as_ref(), |node| node.next.as_ref()).count();\\n\\n        if k == n as i32 + 1 - k {\\n            return head;\\n        }\\n\\n        let (i1, i2) = (k as usize - 1, n - k as usize);\\n        let (i1, i2) = (i1.min(i2), i1.max(i2));\\n\\n        let mut a = head;\\n        let mut n1 = a.cut_at(i1);\\n        let mut b = n1.cut_at(1);\\n        let mut n2 = b.cut_at(i2 - i1 - 1);\\n        let mut c = n2.cut_at(1);\\n\\n        a.join(n2).join(b).join(n1).join(c)\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::iter::successors;\\n\\n// // Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//     pub val: i32,\\n//     pub next: Option<Box<ListNode>>,\\n// }\\n//\\n// impl ListNode {\\n//     #[inline]\\n//     fn new(val: i32) -> Self {\\n//         ListNode { next: None, val }\\n//     }\\n// }\\n\\ntrait ExtendedList {\\n    fn last(&mut self) -> &mut Self;\\n    fn join(self, b: Self) -> Self;\\n    fn cut_at(&mut self, k: usize) -> Self;\\n}\\n\\nimpl ExtendedList for Option<Box<ListNode>> {\\n    fn last(&mut self) -> &mut Self {\\n        if self.is_some() {\\n            self.as_mut().unwrap().next.last()\\n        } else {\\n            self\\n        }\\n    }\\n    fn join(mut self, other: Self) -> Self {\\n        *self.last() = other;\\n        self\\n    }\\n    fn cut_at(&mut self, k: usize) -> Self {\\n        if k > 0 {\\n            self.as_mut()?.next.cut_at(k - 1)\\n        } else {\\n            self.take()\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn swap_nodes(mut head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let n = successors(head.as_ref(), |node| node.next.as_ref()).count();\\n\\n        if k == n as i32 + 1 - k {\\n            return head;\\n        }\\n\\n        let (i1, i2) = (k as usize - 1, n - k as usize);\\n        let (i1, i2) = (i1.min(i2), i1.max(i2));\\n\\n        let mut a = head;\\n        let mut n1 = a.cut_at(i1);\\n        let mut b = n1.cut_at(1);\\n        let mut n2 = b.cut_at(i2 - i1 - 1);\\n        let mut c = n2.cut_at(1);\\n\\n        a.join(n2).join(b).join(n1).join(c)\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525549,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode*st;\\n        int c=0;\\n        st=head;\\n\\n        ListNode* v1,*v2;\\n\\n        while(st!=NULL){\\n            c++;\\n            if(c==k){\\n                v1=st;\\n            }\\n            st=st->next;\\n        }\\n        cout<<c<<endl;\\n\\n        c=c-k;\\n        st=head;\\n\\n        while(st and c){\\n            st=st->next;\\n            c--;\\n\\n        }\\n\\n        v2=st;\\n        \\n        int t=v1->val;\\n        v1->val=v2->val;\\n        v2->val=t;\\n\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode*st;\\n        int c=0;\\n        st=head;\\n\\n        ListNode* v1,*v2;\\n\\n        while(st!=NULL){\\n            c++;\\n            if(c==k){\\n                v1=st;\\n            }\\n            st=st->next;\\n        }\\n        cout<<c<<endl;\\n\\n        c=c-k;\\n        st=head;\\n\\n        while(st and c){\\n            st=st->next;\\n            c--;\\n\\n        }\\n\\n        v2=st;\\n        \\n        int t=v1->val;\\n        v1->val=v2->val;\\n        v2->val=t;\\n\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3251515,
                "title": "python3-easy-solution-by-converting-linkedlist-into-list",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        lst[k-1],lst[-k]=lst[-k],lst[k-1]\\n        a = ListNode(0)\\n        temp = a\\n        for i in lst:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n```\\n![image.png](https://assets.leetcode.com/users/images/a5d9ad2e-b472-4822-a7cb-4296d1d37f41_1677839989.0434792.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        lst[k-1],lst[-k]=lst[-k],lst[k-1]\\n        a = ListNode(0)\\n        temp = a\\n        for i in lst:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544079,
                "title": "most-optimal-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if (head == null) {\\n        return head;\\n    }\\n    \\n    ListNode fast = head;\\n    ListNode front = head;\\n    while (k > 1) {\\n        fast = fast.next;\\n        front = front.next;\\n        k--;\\n    }\\n    \\n    ListNode back = head;\\n    while (fast.next != null) {\\n        back = back.next;\\n        fast = fast.next;\\n    }\\n    \\n    int val = front.val;\\n    front.val = back.val;\\n    back.val = val;\\n    \\n    return head;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if (head == null) {\\n        return head;\\n    }\\n    \\n    ListNode fast = head;\\n    ListNode front = head;\\n    while (k > 1) {\\n        fast = fast.next;\\n        front = front.next;\\n        k--;\\n    }\\n    \\n    ListNode back = head;\\n    while (fast.next != null) {\\n        back = back.next;\\n        fast = fast.next;\\n    }\\n    \\n    int val = front.val;\\n    front.val = back.val;\\n    back.val = val;\\n    \\n    return head;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125822,
                "title": "java-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode fast=head,slow=head,len=head;\\n        int size=0;\\n        if(head==null) return null;\\n/*----------------------------------------------------------------------------*/\\n        while(len!=null){ //measure length of linkedlist\\n            size++;\\n            len=len.next;\\n        }\\n/*----------------------------------------------------------------------------*/\\n        int n=size-k;\\n        for(int i=0;i<n;i++){ //to place pointer at kth node from the end\\n            fast=fast.next;\\n        }\\n/*----------------------------------------------------------------------------*/\\n        for(int i=1;i<k;i++){ //to place pointer at kth node from the start\\n            slow=slow.next;\\n        }\\n/*----------------------------------------------------------------------------*/\\n        int temp=fast.val;  //swapping values at respective nodes\\n        fast.val=slow.val;\\n        slow.val=temp;\\n        return head;\\n    }\\n}\\n```\\n**Please UPVOTE if you understand my code and comment your best approach**",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode fast=head,slow=head,len=head;\\n        int size=0;\\n        if(head==null) return null;\\n/*----------------------------------------------------------------------------*/\\n        while(len!=null){ //measure length of linkedlist\\n            size++;\\n            len=len.next;\\n        }\\n/*----------------------------------------------------------------------------*/\\n        int n=size-k;\\n        for(int i=0;i<n;i++){ //to place pointer at kth node from the end\\n            fast=fast.next;\\n        }\\n/*----------------------------------------------------------------------------*/\\n        for(int i=1;i<k;i++){ //to place pointer at kth node from the start\\n            slow=slow.next;\\n        }\\n/*----------------------------------------------------------------------------*/\\n        int temp=fast.val;  //swapping values at respective nodes\\n        fast.val=slow.val;\\n        slow.val=temp;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912195,
                "title": "simple-approach-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *temp=head;\\n        int count=0;\\n        while(++count<k){\\n            temp=temp->next;\\n        }\\n        ListNode *start=temp;\\n        ListNode *temp2=head;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        swap(start->val,temp2->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *temp=head;\\n        int count=0;\\n        while(++count<k){\\n            temp=temp->next;\\n        }\\n        ListNode *start=temp;\\n        ListNode *temp2=head;\\n        while(temp->next!=NULL){\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        swap(start->val,temp2->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573954,
                "title": "c-easy-logic-top-99-explained-commented",
                "content": "#### ***Explanation:***\\n***1.*** I will find the length of string\\n***2.*** I will get 2 positions to swap i.e. k and length-k-1 (0 based indexing) \\n***3.*** Storing their values and pointers\\n***4.*** At the end, I will swap the values of the pointer\\n\\n***Here is the code for above steps:***\\n```\\nclass Solution {\\npublic:\\n    int length(ListNode* head) { // to find the length of linked list\\n        int count = 0;\\n        while (head){\\n            count++;\\n            head = head->next;\\n        }\\n        return count;\\n    }\\n    \\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        int val1, val2, i=0, sz = length(head);\\n        \\n        if (sz == 1)\\n            return head;\\n        \\n        k--; // for making it 1 based indexing to 0 based indexing (for easy understanding)\\n        \\n        if (k==(sz/2) and sz%2) // if its exactly middle element in the list, then return head coz no need of swapping\\n            return head;\\n         \\n        ListNode* curr = head;\\n        ListNode *cur1, *cur2;\\n        \\n        while(curr){\\n            if (i==k) {  // 1st node to swap\\n                val1 = curr->val;\\n                cur1 = curr;\\n            }\\n            else if (i==(sz-k-1)){ // 2nd node to swap\\n                val2 = curr->val;\\n                cur2 = curr;\\n            }\\n            \\n            curr = curr->next;\\n            i++;\\n        }\\n        \\n        cur1->val = val2; // exchanging the values with each other \\n        cur2->val = val1;\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n***Time Complexity:*** O(N) --> Each Node in the list is visited once.\\n***Space Complexity:*** O(1) --> Contant space is used for this solution\\nWhere, N = Length of the input list.\\n\\nPlease Upvote If you liked it \\u263A\\uFE0F!! It keeps me motivated to post solutions like these.\\nIf there are any suggestions / questions / mistakes in my post, comment below.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode* head) { // to find the length of linked list\\n        int count = 0;\\n        while (head){\\n            count++;\\n            head = head->next;\\n        }\\n        return count;\\n    }\\n    \\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        int val1, val2, i=0, sz = length(head);\\n        \\n        if (sz == 1)\\n            return head;\\n        \\n        k--; // for making it 1 based indexing to 0 based indexing (for easy understanding)\\n        \\n        if (k==(sz/2) and sz%2) // if its exactly middle element in the list, then return head coz no need of swapping\\n            return head;\\n         \\n        ListNode* curr = head;\\n        ListNode *cur1, *cur2;\\n        \\n        while(curr){\\n            if (i==k) {  // 1st node to swap\\n                val1 = curr->val;\\n                cur1 = curr;\\n            }\\n            else if (i==(sz-k-1)){ // 2nd node to swap\\n                val2 = curr->val;\\n                cur2 = curr;\\n            }\\n            \\n            curr = curr->next;\\n            i++;\\n        }\\n        \\n        cur1->val = val2; // exchanging the values with each other \\n        cur2->val = val1;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482440,
                "title": "java-simple-solution-faster-than-100-solution",
                "content": "**Using 2 pointer  fast and slow \\nRuntime: 2 ms\\nMemory Usage: 64.6 MB\\nfaster than 100.00% of Java**\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        \\n        ListNode fast=head; \\n        ListNode slow=head;  \\n        int count=1;\\n        while(fast !=null && count <k){ \\n            fast=fast.next;\\n            count++;\\n        }\\n\\t\\t//move fast k-1 time ahead of slow \\n        ListNode fkth=fast;\\n        while(fast.next !=null ){\\n            fast=fast.next; \\n            slow=slow.next;\\n        }\\n\\t\\t//fast.next=null\\n\\t\\t//slow is equal to kth from end of the list\\n        //swapping\\n       int temp=fkth.val;\\n       fkth.val=slow.val;\\n       slow.val=temp;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        \\n        ListNode fast=head; \\n        ListNode slow=head;  \\n        int count=1;\\n        while(fast !=null && count <k){ \\n            fast=fast.next;\\n            count++;\\n        }\\n\\t\\t//move fast k-1 time ahead of slow \\n        ListNode fkth=fast;\\n        while(fast.next !=null ){\\n            fast=fast.next; \\n            slow=slow.next;\\n        }\\n\\t\\t//fast.next=null\\n\\t\\t//slow is equal to kth from end of the list\\n        //swapping\\n       int temp=fkth.val;\\n       fkth.val=slow.val;\\n       slow.val=temp;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109117,
                "title": "python3-easy-soln-swapping-nodes-in-a-linked-list",
                "content": "```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        res = []\\n        curr =  head\\n        \\n        while curr is not None:\\n            res.append(curr)\\n            curr = curr.next\\n        res[k-1].val, res[len(res)-k].val = res[len(res)-k].val, res[k-1].val\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        res = []\\n        curr =  head\\n        \\n        while curr is not None:\\n            res.append(curr)\\n            curr = curr.next\\n        res[k-1].val, res[len(res)-k].val = res[len(res)-k].val, res[k-1].val\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009949,
                "title": "python3-via-array",
                "content": "**Algo**\\nCollect values in an array and swap the corresponding indices. Recreate a linked list from the updated array. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        vals = []\\n        node = head\\n        while node: \\n            vals.append(node.val)\\n            node = node.next \\n            \\n        vals[k-1], vals[-k] = vals[-k], vals[k-1]\\n        dummy = node = ListNode()\\n        for x in vals:\\n            node.next = node = ListNode(x)\\n        return dummy.next \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`\\n\\nEdited on 3/14/2021\\nDirectly swap node values. \\n```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        node = n1 = n2 = head \\n        while node: \\n            if k == 1: n1 = node \\n            if k <= 0: n2 = n2.next \\n            node = node.next\\n            k -= 1\\n        n1.val, n2.val = n2.val, n1.val\\n        return head \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        vals = []\\n        node = head\\n        while node: \\n            vals.append(node.val)\\n            node = node.next \\n            \\n        vals[k-1], vals[-k] = vals[-k], vals[k-1]\\n        dummy = node = ListNode()\\n        for x in vals:\\n            node.next = node = ListNode(x)\\n        return dummy.next \\n```\n```\\nclass Solution:\\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\\n        node = n1 = n2 = head \\n        while node: \\n            if k == 1: n1 = node \\n            if k <= 0: n2 = n2.next \\n            node = node.next\\n            k -= 1\\n        n1.val, n2.val = n2.val, n1.val\\n        return head \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009773,
                "title": "java-o-n",
                "content": "```\\npublic ListNode swapNodes(ListNode head, int k) {\\n\\tListNode current = head, KthNodeFromStart, KthNodeFromEnd = head;\\n\\tfor (int i=0; i<k-1; i++)\\n\\t\\tcurrent = current.next;     // find kth Node\\n\\tKthNodeFromStart = current;\\n\\twhile(current.next != null) {\\n\\t\\tKthNodeFromEnd = KthNodeFromEnd.next;   // find kth Node from end\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\tint temp = KthNodeFromStart.val;    // Swap values\\n\\tKthNodeFromStart.val = KthNodeFromEnd.val;\\n\\tKthNodeFromEnd.val = temp;\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode swapNodes(ListNode head, int k) {\\n\\tListNode current = head, KthNodeFromStart, KthNodeFromEnd = head;\\n\\tfor (int i=0; i<k-1; i++)\\n\\t\\tcurrent = current.next;     // find kth Node\\n\\tKthNodeFromStart = current;\\n\\twhile(current.next != null) {\\n\\t\\tKthNodeFromEnd = KthNodeFromEnd.next;   // find kth Node from end\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\tint temp = KthNodeFromStart.val;    // Swap values\\n\\tKthNodeFromStart.val = KthNodeFromEnd.val;\\n\\tKthNodeFromEnd.val = temp;\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542383,
                "title": "java-list-swapping-nodes-in-a-linked-list",
                "content": "\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n        public int findLast(ListNode head, int k) {\\n        ListNode tmp = head;\\n        int count = 0;\\n        while (tmp != null)\\n        {\\n            count++;\\n            tmp = tmp.next;\\n        }\\n        return count;\\n    }\\n\\n    public ListNode swapNodes(ListNode head, int k) {\\n        int size =  findLast(head, k);\\n        int i = 1;\\n        ListNode firstS = null;\\n        ListNode secondS = null;\\n        ListNode tmp = head;\\n        while (tmp != null)\\n        {\\n            if (i == k)\\n                firstS = tmp;\\n            if (i == size - k + 1)\\n                secondS = tmp;\\n            tmp = tmp.next;\\n            i++;\\n        }\\n        int g = firstS.val;\\n        firstS.val = secondS.val;\\n        secondS.val = g;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n        public int findLast(ListNode head, int k) {\\n        ListNode tmp = head;\\n        int count = 0;\\n        while (tmp != null)\\n        {\\n            count++;\\n            tmp = tmp.next;\\n        }\\n        return count;\\n    }\\n\\n    public ListNode swapNodes(ListNode head, int k) {\\n        int size =  findLast(head, k);\\n        int i = 1;\\n        ListNode firstS = null;\\n        ListNode secondS = null;\\n        ListNode tmp = head;\\n        while (tmp != null)\\n        {\\n            if (i == k)\\n                firstS = tmp;\\n            if (i == size - k + 1)\\n                secondS = tmp;\\n            tmp = tmp.next;\\n            i++;\\n        }\\n        int g = firstS.val;\\n        firstS.val = secondS.val;\\n        secondS.val = g;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527766,
                "title": "easy-to-understand-c-swaping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n    if(head->next==NULL){\\n        return head;\\n    }\\n    ListNode*temp=head;\\n    int s=0;\\n    while(temp!=NULL){\\n        temp=temp->next;\\n        s++;\\n    }\\n    ListNode*n1=head;\\n      int t=1;\\n      while(t!=k){\\n         n1=n1->next;\\n         t++;\\n      }\\n      ListNode*n2=head;\\n      t=1;\\n      while(t!=s+1-k){\\n          n2=n2->next;\\n          t++;\\n      }\\n      swap(n1->val,n2->val);\\n      return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n    if(head->next==NULL){\\n        return head;\\n    }\\n    ListNode*temp=head;\\n    int s=0;\\n    while(temp!=NULL){\\n        temp=temp->next;\\n        s++;\\n    }\\n    ListNode*n1=head;\\n      int t=1;\\n      while(t!=k){\\n         n1=n1->next;\\n         t++;\\n      }\\n      ListNode*n2=head;\\n      t=1;\\n      while(t!=s+1-k){\\n          n2=n2->next;\\n          t++;\\n      }\\n      swap(n1->val,n2->val);\\n      return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527480,
                "title": "java-beats-99-99-easiest-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode node = new ListNode(0); \\n        node.next = head;\\n        ListNode slow = node;\\n        ListNode fast = node;\\n        for (int i = 0; i < k; i++) {\\n            fast = fast.next;\\n        }\\n        ListNode node1 = fast; \\n        while (fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n\\n        ListNode node2 = slow.next;\\n        int temp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = temp;\\n\\n        return node.next; \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode node = new ListNode(0); \\n        node.next = head;\\n        ListNode slow = node;\\n        ListNode fast = node;\\n        for (int i = 0; i < k; i++) {\\n            fast = fast.next;\\n        }\\n        ListNode node1 = fast; \\n        while (fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n\\n        ListNode node2 = slow.next;\\n        int temp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = temp;\\n\\n        return node.next; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526670,
                "title": "c-easy-approach-two-pointers-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to know where each node is located in the linked list in order to swap the kth node from the beginning with the kth node from the end. By traversing the linked list once, we can determine the location of the kth node from the start. The linked list\\'s head is where we begin, and we go forward k - 1 nodes. The kth node from the start is the node we reach.\\n\\nWe can traverse the linked list once more, starting from the kth node from the beginning, to get the kth node from the end. Two pointers, one at the kth node and the other at the linked list\\'s head, can be kept. Until the second pointer reaches the end of the list, both pointers are advanced simultaneously. The initial pointer will then be referring to the kth node from the end at this time.\\n\\nWe can swap their values and return the head of the linked list once we have located the kth node from the beginning and the kth node from the end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Find the kth node from the start of the list by traversing the linked list.\\n- Find the kth node from the end of the linked list by traversing it once more.\\n- Swap the values of the two nodes.\\n- Return the head of the linked list.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *left = head, *right = head;\\n        for (int i = 0; i < k-1; i++) \\n            right = right -> next;\\n        ListNode *last = right;\\n        while (right -> next) {\\n            left = left -> next;\\n            right = right -> next;\\n        }\\n        swap(last -> val, left -> val);\\n        return head;\\n    }\\n};\\n```\\n\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *left = head, *right = head;\\n        for (int i = 0; i < k-1; i++) \\n            right = right -> next;\\n        ListNode *last = right;\\n        while (right -> next) {\\n            left = left -> next;\\n            right = right -> next;\\n        }\\n        swap(last -> val, left -> val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526010,
                "title": "python3-beats-94-95-with-explanation-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = head\\n        for _ in range(k-1):\\n            curr = curr.next\\n        # curr is reached to first desired node \\n\\n        # save it as first to exchange val later \\n        first = curr\\n\\n        # initialize sec node to head\\n        second = head \\n\\n        # when curr reaches the end , second will be at desired node\\n        while curr.next:\\n            curr = curr.next\\n            second = second.next\\n        \\n        # so then just swap the values if first and second node \\n        first.val, second.val = second.val, first.val \\n\\n        # return head \\n        return head\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = head\\n        for _ in range(k-1):\\n            curr = curr.next\\n        # curr is reached to first desired node \\n\\n        # save it as first to exchange val later \\n        first = curr\\n\\n        # initialize sec node to head\\n        second = head \\n\\n        # when curr reaches the end , second will be at desired node\\n        while curr.next:\\n            curr = curr.next\\n            second = second.next\\n        \\n        # so then just swap the values if first and second node \\n        first.val, second.val = second.val, first.val \\n\\n        # return head \\n        return head\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525941,
                "title": "python-easy-to-understand-one-pass",
                "content": "# Approach\\n1. We take two pointers - one at the kth node from beginning (k_beg) and one from the end (k_end). \\n2. Start with a temporary variable (temp) and move it to next node (k-1) times to reach the kth node from begninning (k_beg). \\n3. Now we move k_end and temp till temp reaches the last node in the list and k_end reaches at the kth node from the end of the list.\\n4. Swap the values in k_beg and k_end\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        k_beg, k_end, temp = head, head, head\\n        for i in range(k-1):\\n            temp = temp.next\\n        k_beg = temp\\n        while temp.next:\\n            k_end = k_end.next\\n            temp = temp.next\\n        k_beg.val, k_end.val = k_end.val, k_beg.val\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        k_beg, k_end, temp = head, head, head\\n        for i in range(k-1):\\n            temp = temp.next\\n        k_beg = temp\\n        while temp.next:\\n            k_end = k_end.next\\n            temp = temp.next\\n        k_beg.val, k_end.val = k_end.val, k_beg.val\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525455,
                "title": "kotlin-swap-values-not-nodes",
                "content": "#### Join me on Telegram\\nhttps://t.me/leetcode_daily_unstoppable/213\\n#### Problem TLDR\\nSwap the values of the head-tail k\\'th ListNodes.\\n#### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we aren\\'t asked to swap nodes, the problem is to find nodes.\\n\\n#### Approach\\n<!-- Describe your approach to solving the problem. -->\\nTravel the `fast` pointer at `k` distance, then move both `fast` and `two` nodes until `fast` reaches the end.\\n#### Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n#### Code\\n```\\n    fun swapNodes(head: ListNode?, k: Int): ListNode? {\\n        var fast = head\\n        for (i in 1..k - 1) fast = fast?.next\\n        val one = fast\\n        var two = head\\n        while (fast?.next != null) {\\n            two = two?.next\\n            fast = fast?.next\\n        }\\n        one?.`val` = two?.`val`.also { two?.`val` = one?.`val` }\\n        return head\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun swapNodes(head: ListNode?, k: Int): ListNode? {\\n        var fast = head\\n        for (i in 1..k - 1) fast = fast?.next\\n        val one = fast\\n        var two = head\\n        while (fast?.next != null) {\\n            two = two?.next\\n            fast = fast?.next\\n        }\\n        one?.`val` = two?.`val`.also { two?.`val` = one?.`val` }\\n        return head\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525449,
                "title": "java-solution-for-swapping-nodes-in-a-linked-list-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution uses two pointers, first and second, to locate the kth node from the beginning and the kth node from the end. It then swaps their values to achieve the desired result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a dummy node and set its next pointer to the head of the linked list.\\n2. Initialize the first and second pointers to the dummy node.\\n3. Move the first pointer to the kth node from the beginning by iterating k positions.\\n4. Move the second pointer to the kth node from the end by iterating k positions ahead of first.\\n5. Swap the values of the first and second nodes.\\n6. Return the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n1. The solution performs two passes over the linked list:\\n- The first pass moves the first pointer to the kth node from the beginning.\\n- The second pass moves the second pointer to the kth node from the end.\\n2. Both passes require traversing the linked list once, resulting in a time complexity of O(n), where n is the number of nodes in the linked list.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses a constant amount of additional space to store the dummy node and the pointers.\\nHence, the space complexity is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode first = dummy;\\n        ListNode second = dummy;\\n\\n        // Move first pointer to the kth node from the beginning\\n        for (int i = 0; i < k; i++) {\\n            first = first.next;\\n        }\\n\\n        // Move second pointer k positions ahead of first (kth node from the end)\\n        ListNode temp = first;\\n        while (temp != null) {\\n            temp = temp.next;\\n            second = second.next;\\n        }\\n\\n        // Swap the values of the first and second nodes\\n        int tempVal = first.val;\\n        first.val = second.val;\\n        second.val = tempVal;\\n\\n        return dummy.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        ListNode first = dummy;\\n        ListNode second = dummy;\\n\\n        // Move first pointer to the kth node from the beginning\\n        for (int i = 0; i < k; i++) {\\n            first = first.next;\\n        }\\n\\n        // Move second pointer k positions ahead of first (kth node from the end)\\n        ListNode temp = first;\\n        while (temp != null) {\\n            temp = temp.next;\\n            second = second.next;\\n        }\\n\\n        // Swap the values of the first and second nodes\\n        int tempVal = first.val;\\n        first.val = second.val;\\n        second.val = tempVal;\\n\\n        return dummy.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525325,
                "title": "c-two-pointers-faster-easy-to-understands",
                "content": "* ***Using Two Pointers***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        // declare a dummy node\\n        \\n        ListNode* dummy = new ListNode(0);\\n        \\n        // point dummy -> next to head\\n        \\n        dummy -> next = head;\\n        \\n        // declare a tail pointer and point to dummy\\n        \\n        ListNode* tail = dummy;\\n        \\n        // move the curr pointer (k - 1) times\\n        \\n        // this will maintain a gap of (k - 1) between curr and tail pointer\\n        \\n        ListNode* curr = head;\\n        \\n        while(k > 1)\\n        {\\n            curr = curr -> next;\\n            \\n            k--;\\n        }\\n        \\n        // store the address in start pointer\\n        \\n        ListNode* start = curr;\\n        \\n        // maintaing a gap of (k - 1) between curr and tail, move both pointer\\n        \\n        while(curr)\\n        {\\n            tail = tail -> next;\\n            \\n            curr = curr -> next;\\n        }\\n        \\n        // store the address of kth node from end\\n        \\n        ListNode* end = tail;\\n        \\n        // swap the values\\n        \\n        swap(start -> val, end -> val);\\n        \\n        // dummy -> next will be head\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        // declare a dummy node\\n        \\n        ListNode* dummy = new ListNode(0);\\n        \\n        // point dummy -> next to head\\n        \\n        dummy -> next = head;\\n        \\n        // declare a tail pointer and point to dummy\\n        \\n        ListNode* tail = dummy;\\n        \\n        // move the curr pointer (k - 1) times\\n        \\n        // this will maintain a gap of (k - 1) between curr and tail pointer\\n        \\n        ListNode* curr = head;\\n        \\n        while(k > 1)\\n        {\\n            curr = curr -> next;\\n            \\n            k--;\\n        }\\n        \\n        // store the address in start pointer\\n        \\n        ListNode* start = curr;\\n        \\n        // maintaing a gap of (k - 1) between curr and tail, move both pointer\\n        \\n        while(curr)\\n        {\\n            tail = tail -> next;\\n            \\n            curr = curr -> next;\\n        }\\n        \\n        // store the address of kth node from end\\n        \\n        ListNode* end = tail;\\n        \\n        // swap the values\\n        \\n        swap(start -> val, end -> val);\\n        \\n        // dummy -> next will be head\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525125,
                "title": "daily-leetcoding-challenge-may-day-15",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2600655,
                "title": "java-solution-runtime-faster-than-100-00-of-java-online-submissions-for-swapping-nodes",
                "content": "class Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n    \\n        \\n        ListNode curr = head;\\n        ListNode n1 = head;\\n        ListNode n2 = head;\\n        int count = 1;\\n        \\n        while(curr != null){\\n            if(count < k)\\n                n1 = n1.next;\\n            if(count > k)\\n                n2 = n2.next;\\n            \\n            curr = curr.next;\\n            count++;\\n        }\\n       \\n        int store = n1.val;\\n        n1.val = n2.val;\\n        n2.val = store;\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n    \\n        \\n        ListNode curr = head;\\n        ListNode n1 = head;\\n        ListNode n2 = head;\\n        int count = 1;\\n        \\n        while(curr != null){\\n            if(count < k)\\n                n1 = n1.next;\\n            if(count > k)\\n                n2 = n2.next;\\n            \\n            curr = curr.next;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2257465,
                "title": "java-2-pointer-including-algorithm",
                "content": "# Algorithm\\nLet\\'s use two more pointers fn and curr, denoting the nodes for swapping\\n\\n1. Put curr at head, and put prev k-1 nodes after slow.\\n2. fn = prev\\n3. If prev isn\\'t already at the last node, move curr and prevt one node further until prev.next == null\\n4. Swap the values of curr and fn\\n\\n\\n# JAVA CODE\\n\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n      ListNode prev = head, curr = head, fn = head;\\n       for(int i = 0; i < k - 1; i ++) {\\n         prev = prev.next;\\n       }\\n      fn = prev;\\n      \\n      while(prev.next != null) {\\n        prev = prev.next;\\n        curr = curr.next;\\n      }\\n      \\n      int temp = fn.val;\\n      fn.val = curr.val;\\n      curr.val = temp;\\n      \\n      return head;\\n    }\\n}\\n```\\n\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n      ListNode prev = head, curr = head, fn = head;\\n       for(int i = 0; i < k - 1; i ++) {\\n         prev = prev.next;\\n       }\\n      fn = prev;\\n      \\n      while(prev.next != null) {\\n        prev = prev.next;\\n        curr = curr.next;\\n      }\\n      \\n      int temp = fn.val;\\n      fn.val = curr.val;\\n      curr.val = temp;\\n      \\n      return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188008,
                "title": "go-o-n-with-length",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapNodes(head *ListNode, k int) *ListNode {\\n    if head == nil {return nil}\\n\\n    length, tmp, firstNode, secondNode := 0, head, head, head\\n\\n    for tmp != nil {\\n        length++\\n        \\n        if length == k {\\n            firstNode = tmp\\n        }\\n        \\n        tmp = tmp.Next\\n    }\\n    \\n    run := head\\n    count := 0\\n    for run != nil {\\n        count++\\n        if count == length + 1 - k {\\n            secondNode = run\\n        }\\n        \\n        run = run.Next\\n    }\\n    \\n    firstNode.Val, secondNode.Val = secondNode.Val, firstNode.Val\\n    return head\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapNodes(head *ListNode, k int) *ListNode {\\n    if head == nil {return nil}\\n\\n    length, tmp, firstNode, secondNode := 0, head, head, head\\n\\n    for tmp != nil {\\n        length++\\n        \\n        if length == k {\\n            firstNode = tmp\\n        }\\n        \\n        tmp = tmp.Next\\n    }\\n    \\n    run := head\\n    count := 0\\n    for run != nil {\\n        count++\\n        if count == length + 1 - k {\\n            secondNode = run\\n        }\\n        \\n        run = run.Next\\n    }\\n    \\n    firstNode.Val, secondNode.Val = secondNode.Val, firstNode.Val\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058018,
                "title": "python-easy-solution-one-pass-iterative-two-pointers",
                "content": "**Please upvote if you find it useful**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        # searching kth node\\n        first=head\\n        for i in range(k-1):\\n            first=first.next\\n        \\n        #searching kth node form the end\\n        last=head\\n        fast=first.next\\n        while fast:\\n            last=last.next\\n            fast=fast.next\\n        \\n        #swapping their values\\n        last.val,first.val=first.val,last.val\\n\\n        return head\\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        # searching kth node\\n        first=head\\n        for i in range(k-1):\\n            first=first.next\\n        \\n        #searching kth node form the end\\n        last=head\\n        fast=first.next\\n        while fast:\\n            last=last.next\\n            fast=fast.next\\n        \\n        #swapping their values\\n        last.val,first.val=first.val,last.val\\n\\n        return head\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034870,
                "title": "c-easy-to-understand-using-pointers-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* curr=head;\\n        for(int i=1;i<k;i++){\\n            curr=curr->next;\\n        }\\n        ListNode* p1=head;\\n        ListNode* p2=curr->next;\\n        \\n        while(p1!=NULL && p2!=NULL){\\n            p1=p1->next;\\n            p2=p2->next;    \\n        }\\n        swap(curr->val,p1->val);\\n        return head;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* curr=head;\\n        for(int i=1;i<k;i++){\\n            curr=curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1923679,
                "title": "swapping-nodes-in-linked-list-simple-in-c",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n       ListNode*kth=head,*t,*ptr=head;\\n        for(int i=0;i<k-1;i++)// first find the kth node\\n        {\\n            kth=kth->next; // kth points the first kth node\\n        }\\n        t=kth;\\n        while(t->next!=NULL)\\n        {\\n            ptr=ptr->next; // ptr points the last kth node\\n            t=t->next;\\n        }\\n        int temp=kth->val;  // swap the val\\n        kth->val=ptr->val;\\n        ptr->val=temp;\\n        return  head;\\'\\'\\'\\n    }\\n};\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n       ListNode*kth=head,*t,*ptr=head;\\n        for(int i=0;i<k-1;i++)// first find the kth node\\n        {\\n            kth=kth->next; // kth points the first kth node\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1916298,
                "title": "one-pass-python-solution-with-explanation",
                "content": "We define 2 pointers, <b>front</b> and <b>back</b>. Let front move forward <b>k</b> steps. Then, move both <b>front</b> and <b>back</b> forward until <b>front</b> reaches the end of the linked list. We can then track the <b>k</b>th element counted from start and end respectively. Mathematically, since the <b>front</b> pointer has moved k steps, there remains <b>n-k</b> steps to be moved (where <b>n</b> is the length of the linked list), which is the index of the <b>k</b>th element counted from end. Notice that in this algorithm, we don\\'t even need to calculate the length of the linked list.\\n\\nCode in Python: \\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        front,back=head,head\\n        for i in range(k-1):\\n            front=front.next\\n        begin=front\\n        while front.next:\\n            front=front.next\\n            back=back.next\\n        end=back\\n        begin.val,end.val=end.val,begin.val\\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "We define 2 pointers, <b>front</b> and <b>back</b>. Let front move forward <b>k</b> steps. Then, move both <b>front</b> and <b>back</b> forward until <b>front</b> reaches the end of the linked list. We can then track the <b>k</b>th element counted from start and end respectively. Mathematically, since the <b>front</b> pointer has moved k steps, there remains <b>n-k</b> steps to be moved (where <b>n</b> is the length of the linked list), which is the index of the <b>k</b>th element counted from end. Notice that in this algorithm, we don\\'t even need to calculate the length of the linked list.\\n\\nCode in Python: \\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        front,back=head,head\\n        for i in range(k-1):\\n            front=front.next\\n        begin=front\\n        while front.next:\\n            front=front.next\\n            back=back.next\\n        end=back\\n        begin.val,end.val=end.val,begin.val\\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 1914894,
                "title": "rust-swap-the-actual-nodes",
                "content": "Many rust solutions only swap the values, which I guess is ok, or drain the list to a vector, and then rebuild it. Instead I want to show how to swap the actuall nodes of the list. \\n\\nThe algorithm is:\\n\\n1. Count the number of nodes in the list\\n2. Split the list in 3 parts\\n    1. Part 0: all the nodes before the first node to swap\\n    2. Part 1: all the nodes between the first and second nodes to swap\\n    3. Part 2: all the nodes after the second node to swap\\n3. Concatenate the 3 parts after swapping the two nodes\\n\\n\\n\\n```rust\\n#[derive(PartialEq, Eq, Clone, Debug)]\\npub struct ListNode {\\n    pub val: i32,\\n    pub next: Option<Box<ListNode>>,\\n}\\n\\nimpl ListNode {\\n    #[inline]\\n    fn new(val: i32) -> Self {\\n        ListNode { next: None, val }\\n    }\\n}\\n\\npub fn swap_nodes(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n    assert!(k > 0);\\n    // make it 0-indexed\\n    let k = (k - 1) as usize;\\n\\n    let length = length(head.as_ref());\\n    if length == 0 {\\n        return head;\\n    }\\n\\n    let node_idx_a = k.min(length - k - 1);\\n    let node_idx_b = k.max(length - k - 1);\\n    if node_idx_a == node_idx_b {\\n        return head;\\n    }\\n\\n    // part-0 consists of all the nodes before the first node to swap\\n    let mut part_0 = head;\\n    let mut tail_0 = &mut part_0;\\n\\n    for _ in 0..node_idx_a {\\n        tail_0 = &mut tail_0.as_mut().unwrap().next;\\n    }\\n\\n    let mut node_1 = tail_0.take().unwrap();\\n\\n    // part-1 consists of all the nodes after the first node to swap and before the second node to swap\\n    let mut part_1 = node_1.next.take();\\n    let mut tail_1 = &mut part_1;\\n\\n    // we add + 1 because we have taken one node outside the loop\\n    for _ in node_idx_a + 1..node_idx_b {\\n        tail_1 = &mut tail_1.as_mut().unwrap().next;\\n    }\\n\\n    let mut node_2 = tail_1.take().unwrap();\\n    node_1.next = node_2.next.take(); // part 2: all the remaining nodes\\n    *tail_1 = Some(node_1);\\n    node_2.next = part_1;\\n    *tail_0 = Some(node_2);\\n\\n    part_0\\n}\\n\\nfn length(head: Option<&Box<ListNode>>) -> usize {\\n    let mut node = head;\\n    let mut len = 0;\\n\\n    while let Some(n) = node.take() {\\n        node = n.next.as_ref();\\n        len += 1;\\n    }\\n\\n    len\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n#[derive(PartialEq, Eq, Clone, Debug)]\\npub struct ListNode {\\n    pub val: i32,\\n    pub next: Option<Box<ListNode>>,\\n}\\n\\nimpl ListNode {\\n    #[inline]\\n    fn new(val: i32) -> Self {\\n        ListNode { next: None, val }\\n    }\\n}\\n\\npub fn swap_nodes(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n    assert!(k > 0);\\n    // make it 0-indexed\\n    let k = (k - 1) as usize;\\n\\n    let length = length(head.as_ref());\\n    if length == 0 {\\n        return head;\\n    }\\n\\n    let node_idx_a = k.min(length - k - 1);\\n    let node_idx_b = k.max(length - k - 1);\\n    if node_idx_a == node_idx_b {\\n        return head;\\n    }\\n\\n    // part-0 consists of all the nodes before the first node to swap\\n    let mut part_0 = head;\\n    let mut tail_0 = &mut part_0;\\n\\n    for _ in 0..node_idx_a {\\n        tail_0 = &mut tail_0.as_mut().unwrap().next;\\n    }\\n\\n    let mut node_1 = tail_0.take().unwrap();\\n\\n    // part-1 consists of all the nodes after the first node to swap and before the second node to swap\\n    let mut part_1 = node_1.next.take();\\n    let mut tail_1 = &mut part_1;\\n\\n    // we add + 1 because we have taken one node outside the loop\\n    for _ in node_idx_a + 1..node_idx_b {\\n        tail_1 = &mut tail_1.as_mut().unwrap().next;\\n    }\\n\\n    let mut node_2 = tail_1.take().unwrap();\\n    node_1.next = node_2.next.take(); // part 2: all the remaining nodes\\n    *tail_1 = Some(node_1);\\n    node_2.next = part_1;\\n    *tail_0 = Some(node_2);\\n\\n    part_0\\n}\\n\\nfn length(head: Option<&Box<ListNode>>) -> usize {\\n    let mut node = head;\\n    let mut len = 0;\\n\\n    while let Some(n) = node.take() {\\n        node = n.next.as_ref();\\n        len += 1;\\n    }\\n\\n    len\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914867,
                "title": "javascript",
                "content": "\\tlet start = head;\\n    let len = 0, l, count=0, first, second;\\n    \\n    if(!head.next) return head;\\n    \\n// obtain the required node value from end of the list    \\n    \\n\\twhile(start){\\n        start = start.next;\\n        len++;\\n    }\\n    l = len-k;\\n    \\n    if(k === l+1) return head;\\n    \\n// extract the values in required nodes of the list\\n\\n\\t   let begin = head;\\n\\t   while(begin){\\n        count++;\\n        if(count === k){\\n            first = begin.val;\\n        } else if(count === l+1){\\n            second = begin.val;\\n        }\\n        begin = begin.next;\\n    }\\n        \\n// swapping the node values\\n\\n\\t\\tbegin = head;\\n\\t\\tcount = 0;\\n    \\n    while(begin){\\n        count++;\\n        if(count === k) begin.val = second;\\n        else if(count === l+1) begin.val = first;\\n        begin = begin.next;\\n    }\\n    return head;",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "\\tlet start = head;\\n    let len = 0, l, count=0, first, second;\\n    \\n    if(!head.next) return head;\\n    \\n// obtain the required node value from end of the list    \\n    \\n\\twhile(start){\\n        start = start.next;\\n        len++;\\n    }\\n    l = len-k;\\n    \\n    if(k === l+1) return head;\\n    \\n// extract the values in required nodes of the list\\n\\n\\t   let begin = head;\\n\\t   while(begin){\\n        count++;\\n        if(count === k){\\n            first = begin.val;\\n        } else if(count === l+1){\\n            second = begin.val;\\n        }\\n        begin = begin.next;\\n    }\\n        \\n// swapping the node values\\n\\n\\t\\tbegin = head;\\n\\t\\tcount = 0;\\n    \\n    while(begin){\\n        count++;\\n        if(count === k) begin.val = second;\\n        else if(count === l+1) begin.val = first;\\n        begin = begin.next;\\n    }\\n    return head;",
                "codeTag": "Unknown"
            },
            {
                "id": 1914586,
                "title": "c-easy-to-understand-comments-daily-leetcoding-challenge-april-day-4",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) \\n    {\\n        // initializing the left and right nodes that we will be going to swap\\n        ListNode* left = head;\\n        ListNode* right = head;\\n        \\n        ListNode* curr = head;          // taking the head of LL in a temp node for iterating\\n        \\n        // these are the counters that will count the value from beggining and ending\\n        int beg_cnt = 1;\\n        int end_cnt = 1;\\n        \\n        // deriving the left kth value from beggining\\n        while(curr)\\n        {\\n            // while does not reach to the kth value\\n            if(beg_cnt < k)\\n            {\\n                left = left->next;\\n            }\\n            \\n            beg_cnt++;\\n            end_cnt++;\\n            curr = curr->next;\\n        }\\n        \\n        curr = head;\\n        beg_cnt = 1;\\n        \\n        // deriving the right kth value from the end\\n        while(curr)\\n        {\\n            // while does not reach to the ((total-k)==Kth value from ending)\\n            if(beg_cnt < (end_cnt-k))\\n            {\\n                right = right->next;\\n            }\\n            beg_cnt++;\\n            curr = curr->next;\\n        }\\n        \\n        // swapping both left and right\\n        int temp = left->val;\\n        left->val = right->val;\\n        right->val = temp;\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Please Upvote If It Helps**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) \\n    {\\n        // initializing the left and right nodes that we will be going to swap\\n        ListNode* left = head;\\n        ListNode* right = head;\\n        \\n        ListNode* curr = head;          // taking the head of LL in a temp node for iterating\\n        \\n        // these are the counters that will count the value from beggining and ending\\n        int beg_cnt = 1;\\n        int end_cnt = 1;\\n        \\n        // deriving the left kth value from beggining\\n        while(curr)\\n        {\\n            // while does not reach to the kth value\\n            if(beg_cnt < k)\\n            {\\n                left = left->next;\\n            }\\n            \\n            beg_cnt++;\\n            end_cnt++;\\n            curr = curr->next;\\n        }\\n        \\n        curr = head;\\n        beg_cnt = 1;\\n        \\n        // deriving the right kth value from the end\\n        while(curr)\\n        {\\n            // while does not reach to the ((total-k)==Kth value from ending)\\n            if(beg_cnt < (end_cnt-k))\\n            {\\n                right = right->next;\\n            }\\n            beg_cnt++;\\n            curr = curr->next;\\n        }\\n        \\n        // swapping both left and right\\n        int temp = left->val;\\n        left->val = right->val;\\n        right->val = temp;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914215,
                "title": "swapping-nodes-in-a-linked-list-bf-o-n",
                "content": "Solution:\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* curr=head,*ptr=head;\\n        if(head==NULL)\\n            return NULL;\\n        int c=0;\\n        while(curr!=NULL){\\n            c++;\\n            curr=curr->next;\\n            \\n        }\\n         c++;//Length calculated,O(n)\\n        curr=head;\\n        int z=k;\\n        for(int i=1;i<k;i++)\\n            curr=curr->next;//Pointer to kth node from start\\n        for(int i=1;i<c-k;i++)\\n            ptr=ptr->next;//Pointer to kth node from end\\n          swap(curr->val,ptr->val);\\n       return head;\\n        \\n    }\\n    \\n};",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* curr=head,*ptr=head;\\n        if(head==NULL)\\n            return NULL;\\n        int c=0;\\n        while(curr!=NULL){\\n            c++;\\n            curr=curr->next;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1913056,
                "title": "c-1-pass-only-99-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* p =head;\\n        \\n        ListNode* p1 =head; \\n        ListNode* p2 =head;\\n        \\n        while(p->next){\\n            if(--k==0){\\n                p1=p;\\n                p2=head;\\n            }\\n            p=p->next;\\n            p2=p2->next;\\n        }\\n        swap(p1->val,p2->val);\\n        return head;\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/f19ae36e-80f3-4c45-81c9-a70390f5baab_1649061715.99721.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* p =head;\\n        \\n        ListNode* p1 =head; \\n        ListNode* p2 =head;\\n        \\n        while(p->next){\\n            if(--k==0){\\n                p1=p;\\n                p2=head;\\n            }\\n            p=p->next;\\n            p2=p2->next;\\n        }\\n        swap(p1->val,p2->val);\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913043,
                "title": "c-first-approach-in-mind-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<int> v;   //vector v to store all values of linked list\\n        ListNode *cur=head;\\n        while(cur!=NULL){\\n            v.push_back(cur->val);\\n            cur=cur->next;\\n        }\\n        swap(v[k-1],v[v.size()-k]);   //now swap kth value of vector\\n        ListNode *ans=head;      \\n        head=ans;                       \\n        int i=0;\\n        while(ans!=NULL){        //changing list values to updated swaped values \\n            ans->val=v[i];\\n            i++;\\n            ans=ans->next;\\n        }\\n        return head;              //finally returning head \\n    }\\n};\\n```\\nTC: O(size of list) \\nSC: O(size of list)\\nIf you like like the solution,please upvote :)\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<int> v;   //vector v to store all values of linked list\\n        ListNode *cur=head;\\n        while(cur!=NULL){\\n            v.push_back(cur->val);\\n            cur=cur->next;\\n        }\\n        swap(v[k-1],v[v.size()-k]);   //now swap kth value of vector\\n        ListNode *ans=head;      \\n        head=ans;                       \\n        int i=0;\\n        while(ans!=NULL){        //changing list values to updated swaped values \\n            ans->val=v[i];\\n            i++;\\n            ans=ans->next;\\n        }\\n        return head;              //finally returning head \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912907,
                "title": "c-o-n-solution-two-pointers-approach",
                "content": "**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    //Use 2 pointers approach\\n    ListNode* swapNodes(ListNode* head, int k) \\n    {\\n        ListNode *left = head; \\n        ListNode *right = head; \\n        ListNode *curr = head;\\n        int counter = 1;\\n        \\n        //keeping left pointer to the k nodes from left\\n        //and right pointer to the k nodes from right\\n        while(curr!=NULL)\\n        {\\n            if(counter<k)\\n                left=left->next;\\n            \\n            if(counter>k)\\n                right=right->next;\\n            \\n            counter++;\\n            curr=curr->next;\\n        }\\n        \\n        //swap the values\\n        int temp = left->val;\\n        left->val = right->val;\\n        right->val = temp;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use 2 pointers approach\\n    ListNode* swapNodes(ListNode* head, int k) \\n    {\\n        ListNode *left = head; \\n        ListNode *right = head; \\n        ListNode *curr = head;\\n        int counter = 1;\\n        \\n        //keeping left pointer to the k nodes from left\\n        //and right pointer to the k nodes from right\\n        while(curr!=NULL)\\n        {\\n            if(counter<k)\\n                left=left->next;\\n            \\n            if(counter>k)\\n                right=right->next;\\n            \\n            counter++;\\n            curr=curr->next;\\n        }\\n        \\n        //swap the values\\n        int temp = left->val;\\n        left->val = right->val;\\n        right->val = temp;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912732,
                "title": "c-one-pass-super-easy",
                "content": "\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* p=head, *ff=head, *ss=head;\\n        for(int i=1;i<k;i++)\\n            p=p->next;\\n        ff= p;\\n        while(p->next)\\n        {\\n            p=p->next;\\n            ss=ss->next;\\n        }\\n        swap(ff->val,ss->val);\\n        return head;\\n    }\\n};\\n```\\n**If You find it difficult to understand, use pen & paper, you will feel it.**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* p=head, *ff=head, *ss=head;\\n        for(int i=1;i<k;i++)\\n            p=p->next;\\n        ff= p;\\n        while(p->next)\\n        {\\n            p=p->next;\\n            ss=ss->next;\\n        }\\n        swap(ff->val,ss->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912576,
                "title": "python-easy-3-solutions-explained",
                "content": "**Solution 1:** Iterative Approach\\n1. Find the ```length```  and ```Kth node from start```\\n2. Find the ```Kth node from back```\\n3. Swap ```Kth node from start``` and  ```Kth node from back```\\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        def kFromStartAndlength(head,k):\\n            kthNode,count = None, 0\\n            while head:\\n                count += 1\\n                if count == k: kthNode = head\\n                head = head.next\\n            return kthNode, count\\n        \\n        kthNode, length = kFromStartAndlength(head,k)\\n        right = head\\n        for i in range(length - k):\\n            right = right.next\\n        right.val, kthNode.val = kthNode.val, right.val\\n        \\n        return head\\n```\\n***\\n```Time Complexity: O(N)```\\n***\\n\\n**Solution 2** Three pointers iterative | One sweep\\n1. Find the ```kthNodeFromStart``` by iterating from start.\\n2. Take a pointer ```itr``` and point it to ```kthNodeFromStart```\\n3. take another pointer ```kthNodeFromEnd``` pointing at ```head```\\n4. Iterate both until ```itr``` points to the last node. Why? because ```itr``` started from ```kthNodeFromStart```  and ```kthNodeFromEnd``` pointer started from ```head```, So when ```itr``` reach the end , ```kthNodeFromEnd``` pointer will exactly point at kth  Node from end.\\n5. Swap ```kthNodeFromStart```  and ```kthNodeFromEnd```\\n\\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        kthNodeFromStart = head \\n        for i in range(k-1):\\n            kthNodeFromStart = kthNodeFromStart.next\\n            \\n        kthNodeFromEnd, itr = head, kthNodeFromStart\\n        while itr.next:\\n            kthNodeFromEnd = kthNodeFromEnd.next\\n            itr = itr.next\\n        kthNodeFromStart.val, kthNodeFromEnd.val = kthNodeFromEnd.val, kthNodeFromStart.val\\n        return head\\n```\\n***\\n```Time Complexity: O(N)```\\n***\\n\\n**Solution 3** Recursive Approach two pointers\\n1. Take two pointers ```left``` and ```right```\\n2. Move the ```right``` pointer all the way to the end recursively\\n3. Move the ```left``` while returning from recursion\\n4. Swap ```left``` and ```right``` at kth position.\\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        self.left, self.k = ListNode(-1,head), k\\n        def traverse(right):\\n            if right is None: return right\\n            traverse(right.next)\\n            self.k -= 1\\n            self.left = self.left.next\\n            if not self.k: self.left.val, right.val = right.val, self.left.val\\n            return right\\n        return traverse(head)\\n```\\n***\\n```Time Complexity: O(N)```\\n***\\n\\n***If you have any doubts or a better solution please do comment below.***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```length```\n```Kth node from start```\n```Kth node from back```\n```Kth node from start```\n```Kth node from back```\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        def kFromStartAndlength(head,k):\\n            kthNode,count = None, 0\\n            while head:\\n                count += 1\\n                if count == k: kthNode = head\\n                head = head.next\\n            return kthNode, count\\n        \\n        kthNode, length = kFromStartAndlength(head,k)\\n        right = head\\n        for i in range(length - k):\\n            right = right.next\\n        right.val, kthNode.val = kthNode.val, right.val\\n        \\n        return head\\n```\n```Time Complexity: O(N)```\n```kthNodeFromStart```\n```itr```\n```kthNodeFromStart```\n```kthNodeFromEnd```\n```head```\n```itr```\n```itr```\n```kthNodeFromStart```\n```kthNodeFromEnd```\n```head```\n```itr```\n```kthNodeFromEnd```\n```kthNodeFromStart```\n```kthNodeFromEnd```\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        kthNodeFromStart = head \\n        for i in range(k-1):\\n            kthNodeFromStart = kthNodeFromStart.next\\n            \\n        kthNodeFromEnd, itr = head, kthNodeFromStart\\n        while itr.next:\\n            kthNodeFromEnd = kthNodeFromEnd.next\\n            itr = itr.next\\n        kthNodeFromStart.val, kthNodeFromEnd.val = kthNodeFromEnd.val, kthNodeFromStart.val\\n        return head\\n```\n```Time Complexity: O(N)```\n```left```\n```right```\n```right```\n```left```\n```left```\n```right```\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        self.left, self.k = ListNode(-1,head), k\\n        def traverse(right):\\n            if right is None: return right\\n            traverse(right.next)\\n            self.k -= 1\\n            self.left = self.left.next\\n            if not self.k: self.left.val, right.val = right.val, self.left.val\\n            return right\\n        return traverse(head)\\n```\n```Time Complexity: O(N)```",
                "codeTag": "Java"
            },
            {
                "id": 1912502,
                "title": "python-easy-understanding-two-pointers",
                "content": "![image](https://assets.leetcode.com/users/images/b52a028a-d1df-42a0-9783-9fb137468041_1649049385.9471781.png)\\n\\n\\n\\n````\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head:\\n            return head\\n        curr = head\\n        for i in range(k-1):\\n            curr = curr.next\\n        slow = head\\n        fast = curr\\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        slow.val, curr.val = curr.val, slow.val\\n        return head\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "````\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        if not head:\\n            return head\\n        curr = head\\n        for i in range(k-1):\\n            curr = curr.next\\n        slow = head\\n        fast = curr\\n        while fast.next:\\n            slow = slow.next\\n            fast = fast.next\\n        slow.val, curr.val = curr.val, slow.val\\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912011,
                "title": "python-simple-and-easy-solution",
                "content": "\\n\\n```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = tail = ListNode(0, head)\\n        kFromFront = kFromLast = dummy\\n        n = 0\\n        \\n        while(tail.next):\\n            n += 1\\n            if(n <= k):\\n                kFromFront = kFromFront.next\\n            if(n >= k):\\n                kFromLast = kFromLast.next\\n            tail = tail.next\\n        \\n        kFromFront.val, kFromLast.val = kFromLast.val, kFromFront.val\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = tail = ListNode(0, head)\\n        kFromFront = kFromLast = dummy\\n        n = 0\\n        \\n        while(tail.next):\\n            n += 1\\n            if(n <= k):\\n                kFromFront = kFromFront.next\\n            if(n >= k):\\n                kFromLast = kFromLast.next\\n            tail = tail.next\\n        \\n        kFromFront.val, kFromLast.val = kFromLast.val, kFromFront.val\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788357,
                "title": "100-ms-8-mb-best-go-lang-solution",
                "content": "```\\nfunc swapNodes(head *ListNode, k int) *ListNode {\\n    firstswap := head\\n    i := 0\\n    for i < k-1 {\\n        firstswap = firstswap.Next\\n        i++\\n    }\\n    \\n    secondswap := head\\n    for fast := firstswap.Next; fast != nil; fast = fast.Next {\\n        secondswap = secondswap.Next\\n    }\\n    \\n    firstswap.Val, secondswap.Val = secondswap.Val, firstswap.Val\\n    return head\\n}",
                "solutionTags": [
                    "Go",
                    "Iterator"
                ],
                "code": "```\\nfunc swapNodes(head *ListNode, k int) *ListNode {\\n    firstswap := head\\n    i := 0\\n    for i < k-1 {\\n        firstswap = firstswap.Next\\n        i++\\n    }\\n    \\n    secondswap := head\\n    for fast := firstswap.Next; fast != nil; fast = fast.Next {\\n        secondswap = secondswap.Next\\n    }\\n    \\n    firstswap.Val, secondswap.Val = secondswap.Val, firstswap.Val\\n    return head\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1757568,
                "title": "c-simple-two-pointerapproach",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        ListNode *ptr = head;\\n        \\n        for(int i=0 ; i<k-1 ; i++) ptr = ptr->next;\\n        \\n        ListNode* slow = head ;\\n        ListNode * fast = ptr->next;\\n        \\n        while(fast){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        swap(slow->val , ptr->val);\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        ListNode *ptr = head;\\n        \\n        for(int i=0 ; i<k-1 ; i++) ptr = ptr->next;\\n        \\n        ListNode* slow = head ;\\n        ListNode * fast = ptr->next;\\n        \\n        while(fast){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n        \\n        swap(slow->val , ptr->val);\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674431,
                "title": "python-pointers",
                "content": "```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        slow, mid, fast = head, head, head\\n        \\n\\t\\tmoving the first ponter to the kth node\\n        for i in range(k-1):\\n            fast = fast.next\\n            slow = slow.next\\n        \\n\\t\\t#Moving second the pointer to the kth node from the back\\n        while fast.next:\\n            fast = fast.next\\n            mid = mid.next\\n        \\n\\t\\t#swapping values\\n        temp = slow.val\\n        slow.val = mid.val\\n        mid.val = temp\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        slow, mid, fast = head, head, head\\n        \\n\\t\\tmoving the first ponter to the kth node\\n        for i in range(k-1):\\n            fast = fast.next\\n            slow = slow.next\\n        \\n\\t\\t#Moving second the pointer to the kth node from the back\\n        while fast.next:\\n            fast = fast.next\\n            mid = mid.next\\n        \\n\\t\\t#swapping values\\n        temp = slow.val\\n        slow.val = mid.val\\n        mid.val = temp\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581762,
                "title": "swapping-nodes-in-a-ll-c-easy-code",
                "content": "**Feel free to ask any doubt in the comments section. Please upvote if you liked my answer.**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *detect_end = head, *first = head, *last = head;\\n        while(--k)\\n        {\\n            first = first->next;\\n            detect_end = detect_end->next;\\n        }\\n        while(detect_end->next)\\n        {\\n            last = last->next;\\n            detect_end = detect_end->next;\\n        }\\n        swap(first->val,last->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *detect_end = head, *first = head, *last = head;\\n        while(--k)\\n        {\\n            first = first->next;\\n            detect_end = detect_end->next;\\n        }\\n        while(detect_end->next)\\n        {\\n            last = last->next;\\n            detect_end = detect_end->next;\\n        }\\n        swap(first->val,last->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519754,
                "title": "actual-pointer-s-swaping-swaping-values-won-t-be-accepted-in-the-interview",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    #define Node ListNode \\n    int lengthLL(Node * head )\\n    {\\n        if(!head)\\n            return 0;\\n        return 1 + lengthLL(head->next);\\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        Node * prev1 = NULL;\\n        Node * curr1 = head;\\n        Node * prev2 = NULL;\\n        Node * curr2 = head;\\n        Node * curr = head;\\n        Node * prev = NULL;\\n        \\n        int cnt1 = 1;\\n        int cnt2 = 1;\\n        int n = lengthLL(head) + 1;\\n        while(curr != NULL)\\n        {\\n            \\n            if(cnt1 == k )\\n            {\\n                prev1 = prev;\\n                curr1 = curr;\\n            }\\n            if(cnt2 == n - k)\\n            {\\n                prev2 = prev;\\n                curr2 = curr;\\n            }\\n            \\n            prev=  curr ;\\n            cnt1++;\\n            cnt2++;\\n            curr = curr->next;\\n        }\\n        \\n        \\n        if(prev1 == NULL)\\n        {\\n            prev2->next = curr1;\\n            head = curr2;\\n        }\\n       else  if(prev2 == NULL)\\n        {\\n            prev1->next = curr2;\\n            head = curr1;\\n        }\\n        \\n        else \\n        {\\n            prev1->next = curr2;\\n            prev2->next = curr1;\\n        }\\n        \\n        \\n        swap(curr1->next, curr2->next);\\n        \\n        return head ;\\n        \\n              \\n    \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    #define Node ListNode \\n    int lengthLL(Node * head )\\n    {\\n        if(!head)\\n            return 0;\\n        return 1 + lengthLL(head->next);\\n    }\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        \\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        Node * prev1 = NULL;\\n        Node * curr1 = head;\\n        Node * prev2 = NULL;\\n        Node * curr2 = head;\\n        Node * curr = head;\\n        Node * prev = NULL;\\n        \\n        int cnt1 = 1;\\n        int cnt2 = 1;\\n        int n = lengthLL(head) + 1;\\n        while(curr != NULL)\\n        {\\n            \\n            if(cnt1 == k )\\n            {\\n                prev1 = prev;\\n                curr1 = curr;\\n            }\\n            if(cnt2 == n - k)\\n            {\\n                prev2 = prev;\\n                curr2 = curr;\\n            }\\n            \\n            prev=  curr ;\\n            cnt1++;\\n            cnt2++;\\n            curr = curr->next;\\n        }\\n        \\n        \\n        if(prev1 == NULL)\\n        {\\n            prev2->next = curr1;\\n            head = curr2;\\n        }\\n       else  if(prev2 == NULL)\\n        {\\n            prev1->next = curr2;\\n            head = curr1;\\n        }\\n        \\n        else \\n        {\\n            prev1->next = curr2;\\n            prev2->next = curr1;\\n        }\\n        \\n        \\n        swap(curr1->next, curr2->next);\\n        \\n        return head ;\\n        \\n              \\n    \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263719,
                "title": "java-two-pointer-solution-o-n-time-o-1-space-fastest-of-all",
                "content": "Explanation : Go K-steps ahead of head. Now, there\\'s K distance between Head and current node. So, here we have got our first node for swap. Now, start from head and curr node and go till end. Now, again our 2 pointers are at K distance from each other, but at the end. This gives us another node for swap. Just swap its values and you are done. Easy understanding.\\n\\nPlease UPVOTE if you like my solution. :)\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode fast = head;\\n        \\n        while(k>1){\\n            fast = fast.next;\\n            k--;\\n        }\\n        ListNode swap = fast;\\n        ListNode slow = head;\\n        while(fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        int temp = slow.val;\\n        slow.val = swap.val;\\n        swap.val = temp;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode fast = head;\\n        \\n        while(k>1){\\n            fast = fast.next;\\n            k--;\\n        }\\n        ListNode swap = fast;\\n        ListNode slow = head;\\n        while(fast.next != null){\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        int temp = slow.val;\\n        slow.val = swap.val;\\n        swap.val = temp;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139459,
                "title": "java-one-pass-super-easy-beat-100",
                "content": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode fast = dummy;\\n        ListNode slow = dummy;\\n        ListNode tempNode = null;\\n        while (k-- > 0) {\\n            fast = fast.next;\\n        }\\n        tempNode = fast;\\n        while (fast != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        int temp = slow.val;\\n        slow.val = tempNode.val;\\n        tempNode.val = temp;\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode fast = dummy;\\n        ListNode slow = dummy;\\n        ListNode tempNode = null;\\n        while (k-- > 0) {\\n            fast = fast.next;\\n        }\\n        tempNode = fast;\\n        while (fast != null) {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        int temp = slow.val;\\n        slow.val = tempNode.val;\\n        tempNode.val = temp;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109328,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn swap_nodes(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut v = Vec::new();\\n        {\\n            let mut node = &head;\\n            while let Some(n) = node {\\n                v.push(n.val);\\n                node = &n.next;\\n            }\\n        }\\n        let len = v.len();\\n        v.swap(k as usize - 1, len - k as usize);\\n        let mut answer = None;\\n        for &n in v.iter().rev() {\\n            answer = Some(Box::new(ListNode {\\n                val: n,\\n                next: answer,\\n            }));\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn swap_nodes(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut v = Vec::new();\\n        {\\n            let mut node = &head;\\n            while let Some(n) = node {\\n                v.push(n.val);\\n                node = &n.next;\\n            }\\n        }\\n        let len = v.len();\\n        v.swap(k as usize - 1, len - k as usize);\\n        let mut answer = None;\\n        for &n in v.iter().rev() {\\n            answer = Some(Box::new(ListNode {\\n                val: n,\\n                next: answer,\\n            }));\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1109053,
                "title": "ruby-o-n-time-o-1-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @param {Integer} k\\n# @return {ListNode}\\ndef swap_nodes(head, k)\\n  first_k, last_k, current = nil, nil, head\\n  \\n  (k-1).times{current = current.next}\\n  \\n  first_k = current\\n  last_k, current = head, current.next\\n  \\n  while current\\n    current, last_k = current.next, last_k.next\\n  end\\n  \\n  first_k.val, last_k.val = last_k.val, first_k.val\\n  \\n  head\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @param {Integer} k\\n# @return {ListNode}\\ndef swap_nodes(head, k)\\n  first_k, last_k, current = nil, nil, head\\n  \\n  (k-1).times{current = current.next}\\n  \\n  first_k = current\\n  last_k, current = head, current.next\\n  \\n  while current\\n    current, last_k = current.next, last_k.next\\n  end\\n  \\n  first_k.val, last_k.val = last_k.val, first_k.val\\n  \\n  head\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108946,
                "title": "java-easy-single-traversal-on-list-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode first = null;\\n        ListNode last = null;\\n        int i = 1;\\n        ListNode node = head;\\n        while (node != null){\\n            if (i == k){\\n                first = node;\\n                last = head;\\n            }\\n            else if (i > k){\\n                last = last.next;\\n            }\\n            node = node.next;\\n            i++;\\n        }\\n        \\n        int temp = first.val;\\n        first.val = last.val;\\n        last.val = temp;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode first = null;\\n        ListNode last = null;\\n        int i = 1;\\n        ListNode node = head;\\n        while (node != null){\\n            if (i == k){\\n                first = node;\\n                last = head;\\n            }\\n            else if (i > k){\\n                last = last.next;\\n            }\\n            node = node.next;\\n            i++;\\n        }\\n        \\n        int temp = first.val;\\n        first.val = last.val;\\n        last.val = temp;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058229,
                "title": "java-o-n-99-68-fast-simple-solution",
                "content": "```\\npublic ListNode swapNodes(ListNode head, int k) {\\n        ListNode a = head, b = head, c= head;\\n        while(--k>0){ // move k steps forward, leave b behind and move a till end\\n            a = a.next;\\n            b = b.next;\\n        }\\n        while(a.next!=null){ // start moving c once a reaches end , c is k times behind\\n            a=a.next;\\n            c = c.next;\\n        }\\n        int t = b.val; // swap values of b and c\\n        b.val = c.val;\\n        c.val = t;\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode swapNodes(ListNode head, int k) {\\n        ListNode a = head, b = head, c= head;\\n        while(--k>0){ // move k steps forward, leave b behind and move a till end\\n            a = a.next;\\n            b = b.next;\\n        }\\n        while(a.next!=null){ // start moving c once a reaches end , c is k times behind\\n            a=a.next;\\n            c = c.next;\\n        }\\n        int t = b.val; // swap values of b and c\\n        b.val = c.val;\\n        c.val = t;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1012141,
                "title": "c-one-pass",
                "content": "If you notice, question talk about swapping value (not node). it makes it pretty easy. We keep reference for Kth node from start and trailing K node and swap it\\'s value. \\n\\n```\\nListNode startK =null,trailing = null,current=head;\\n        int i=1;\\n        \\n        while(current!=null)\\n        {\\n            \\n            if(trailing!=null)\\n            {\\n                trailing = trailing.next;\\n            }\\n            \\n            if (i==k)\\n            {\\n                startK=current;                \\n                trailing=head;\\n            }\\n            \\n            \\n            current = current.next;\\n            i++;\\n        }\\n        \\n        i = startK.val;\\n        startK.val = trailing.val;\\n        trailing.val = i;\\n        return head;\\n```",
                "solutionTags": [],
                "code": "```\\nListNode startK =null,trailing = null,current=head;\\n        int i=1;\\n        \\n        while(current!=null)\\n        {\\n            \\n            if(trailing!=null)\\n            {\\n                trailing = trailing.next;\\n            }\\n            \\n            if (i==k)\\n            {\\n                startK=current;                \\n                trailing=head;\\n            }\\n            \\n            \\n            current = current.next;\\n            i++;\\n        }\\n        \\n        i = startK.val;\\n        startK.val = trailing.val;\\n        trailing.val = i;\\n        return head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010068,
                "title": "c-6-line",
                "content": "```\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<ListNode*> v;\\n        while(head){\\n            v.push_back(head);\\n            head = head->next;\\n        }\\n        swap(v[k-1]->val, v[v.size()-k]->val);\\n        return v[0];\\n    }",
                "solutionTags": [],
                "code": "```\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<ListNode*> v;\\n        while(head){\\n            v.push_back(head);\\n            head = head->next;\\n        }\\n        swap(v[k-1]->val, v[v.size()-k]->val);\\n        return v[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3874965,
                "title": "94-beats-simple-brute-force-swapping-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* curr = head;\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head;\\n        int cnt1 = 1;\\n        int cnt2 = 1;\\n        int length = 0;\\n        while(curr != NULL){\\n            length++;\\n            curr = curr->next;\\n        }\\n        while(cnt1 < k){\\n            temp1 = temp1->next;\\n            cnt1++;\\n        }\\n        while(cnt2 < length-k+1){\\n            temp2 = temp2->next;\\n            cnt2++;\\n        }\\n        swap(temp1->val , temp2->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* curr = head;\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head;\\n        int cnt1 = 1;\\n        int cnt2 = 1;\\n        int length = 0;\\n        while(curr != NULL){\\n            length++;\\n            curr = curr->next;\\n        }\\n        while(cnt1 < k){\\n            temp1 = temp1->next;\\n            cnt1++;\\n        }\\n        while(cnt2 < length-k+1){\\n            temp2 = temp2->next;\\n            cnt2++;\\n        }\\n        swap(temp1->val , temp2->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855744,
                "title": "python-3-swap-real-nodes-beats-99-661ms",
                "content": "```python3 []\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode(0, head)\\n        cur = dummy\\n        # k-1 because need to find node before k\\'th\\n        for _ in range(k-1):\\n            cur = cur.next\\n        nodeBefore1 = cur\\n        \\n        # because need find node before k-th node from the end take one move to forward\\n        cur = cur.next \\n        nodeBefore2 = dummy\\n        while cur.next:\\n            cur = cur.next\\n            nodeBefore2 = nodeBefore2.next\\n\\n        nodeBefore1.next, nodeBefore2.next = nodeBefore2.next, nodeBefore1.next\\n        nodeBefore1.next.next, nodeBefore2.next.next = nodeBefore2.next.next, nodeBefore1.next.next\\n        \\n        return dummy.next\\n```\\n![Screenshot 2023-08-03 at 05.30.00.png](https://assets.leetcode.com/users/images/24bf8eb0-67e7-406e-8ec7-b2b4b7a35338_1691030124.827642.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        dummy = ListNode(0, head)\\n        cur = dummy\\n        # k-1 because need to find node before k\\'th\\n        for _ in range(k-1):\\n            cur = cur.next\\n        nodeBefore1 = cur\\n        \\n        # because need find node before k-th node from the end take one move to forward\\n        cur = cur.next \\n        nodeBefore2 = dummy\\n        while cur.next:\\n            cur = cur.next\\n            nodeBefore2 = nodeBefore2.next\\n\\n        nodeBefore1.next, nodeBefore2.next = nodeBefore2.next, nodeBefore1.next\\n        nodeBefore1.next.next, nodeBefore2.next.next = nodeBefore2.next.next, nodeBefore1.next.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854755,
                "title": "c-easy-solution-beginner-friendly",
                "content": "put all the values of linked lists in an array then swap the elements.then change the values of linked lists to the values in array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<int> arr;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            arr.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        int temp1 = arr[k-1];\\n        arr[k-1] = arr[arr.size() - k];\\n        arr[arr.size() - k] = temp1;\\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = arr[i];\\n            i++;\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<int> arr;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            arr.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        int temp1 = arr[k-1];\\n        arr[k-1] = arr[arr.size() - k];\\n        arr[arr.size() - k] = temp1;\\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = arr[i];\\n            i++;\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784366,
                "title": "easy-java-solution-100",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode node1 = head;\\n        ListNode node2 = head;\\n        ListNode temp2 = head;\\n        for(int i=1; i<k; i++){\\n            node1 = node1.next;   //This is node to be swapped\\n        }\\n        ListNode temp = node1;\\n        while(temp.next!=null){\\n            temp = temp.next;\\n            node2 = node2.next;\\n        }\\n        int valHolder = node1.val;\\n        node1.val = node2.val;\\n        node2.val = valHolder;\\n\\n        return head;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode node1 = head;\\n        ListNode node2 = head;\\n        ListNode temp2 = head;\\n        for(int i=1; i<k; i++){\\n            node1 = node1.next;   //This is node to be swapped\\n        }\\n        ListNode temp = node1;\\n        while(temp.next!=null){\\n            temp = temp.next;\\n            node2 = node2.next;\\n        }\\n        int valHolder = node1.val;\\n        node1.val = node2.val;\\n        node2.val = valHolder;\\n\\n        return head;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772985,
                "title": "easy-java-solution-beats-100-two-approach-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the kth node from the start and from the end of the linked list and replace their values. We will get our resultant linked list.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n//################## FIRST APPROACH ####################\\n\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        \\n        ListNode first = head;\\n        ListNode second = head;\\n        ListNode ans = head;\\n\\n        for(int i = 1; i < k; i++) {\\n            first = first.next;\\n        }\\n        ListNode temp = first;\\n\\n        while(temp.next != null) {\\n            second = second.next;\\n            temp = temp.next;\\n        }\\n        \\n        int temporary = first.val;\\n        first.val = second.val;\\n        second.val = temporary;\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n//less efficient way, the one given in the hints\\n//################## SECOND APPROACH ####################\\n\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n\\n        int length = 0;\\n        ListNode temp = head;\\n\\n        while(temp != null) {\\n            temp = temp.next;\\n            length++;\\n        }\\n\\n        int[] arr = new int[length];\\n        temp = head;\\n\\n        for(int i = 0; i < length; i++) {\\n            arr[i] = temp.val;\\n            temp = temp.next;\\n        }\\n\\n        int temporary = arr[k - 1];\\n        arr[k - 1] = arr[arr.length - k];\\n        arr[arr.length - k] = temporary;\\n\\n        temp = head;\\n        ListNode ans = temp;\\n\\n        for(int i = 0; i < length; i++) {\\n            temp.next = new ListNode(arr[i]);\\n            temp = temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/38f577cd-2d32-452f-8dbb-79fc67d94762_1689501292.0826573.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n//################## FIRST APPROACH ####################\\n\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        \\n        ListNode first = head;\\n        ListNode second = head;\\n        ListNode ans = head;\\n\\n        for(int i = 1; i < k; i++) {\\n            first = first.next;\\n        }\\n        ListNode temp = first;\\n\\n        while(temp.next != null) {\\n            second = second.next;\\n            temp = temp.next;\\n        }\\n        \\n        int temporary = first.val;\\n        first.val = second.val;\\n        second.val = temporary;\\n        \\n        return ans;\\n    }\\n}\\n\\n\\n//less efficient way, the one given in the hints\\n//################## SECOND APPROACH ####################\\n\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n\\n        int length = 0;\\n        ListNode temp = head;\\n\\n        while(temp != null) {\\n            temp = temp.next;\\n            length++;\\n        }\\n\\n        int[] arr = new int[length];\\n        temp = head;\\n\\n        for(int i = 0; i < length; i++) {\\n            arr[i] = temp.val;\\n            temp = temp.next;\\n        }\\n\\n        int temporary = arr[k - 1];\\n        arr[k - 1] = arr[arr.length - k];\\n        arr[arr.length - k] = temporary;\\n\\n        temp = head;\\n        ListNode ans = temp;\\n\\n        for(int i = 0; i < length; i++) {\\n            temp.next = new ListNode(arr[i]);\\n            temp = temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762599,
                "title": "c-easy-to-understand-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* front=head;\\n        ListNode* f=head;\\n        while(--k){\\n            f=f->next;\\n            front=front->next;\\n        }\\n        ListNode* back=head;\\n        while(f->next!=NULL){\\n            f=f->next;\\n            back=back->next;\\n        }\\n        swap(front->val,back->val);\\n        return head;\\n      }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* front=head;\\n        ListNode* f=head;\\n        while(--k){\\n            f=f->next;\\n            front=front->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3589931,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) \\n    {\\n        ListNode *left_ptr = head, *right_ptr = head;\\n        for (int i = 0; i < k-1; i++) {\\n            right_ptr = right_ptr->next;\\n        }\\n        ListNode *end_ptr = right_ptr;\\n        while (right_ptr->next) \\n        {\\n            left_ptr = left_ptr->next;\\n            right_ptr = right_ptr->next;\\n        }\\n        swap(end_ptr->val, left_ptr->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) \\n    {\\n        ListNode *left_ptr = head, *right_ptr = head;\\n        for (int i = 0; i < k-1; i++) {\\n            right_ptr = right_ptr->next;\\n        }\\n        ListNode *end_ptr = right_ptr;\\n        while (right_ptr->next) \\n        {\\n            left_ptr = left_ptr->next;\\n            right_ptr = right_ptr->next;\\n        }\\n        swap(end_ptr->val, left_ptr->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579215,
                "title": "c-sln-easy-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* temp;\\n        temp=head;\\n        int cnt=0;\\n        while(temp!=0){\\n            cnt++;\\n            temp=temp->next;\\n        }\\n \\n        ListNode *slow, *fast;\\n        slow=head;\\n        fast=head;\\n        int p=1;\\n        while(p!=k){\\n            slow=slow->next;\\n            p++;\\n            \\n        }\\n        p=1;\\n        int t=(cnt-k+1);\\n        while(p!=t){\\n            fast=fast->next;\\n            p++;\\n        }\\n\\n        swap(slow->val ,fast->val);\\n        return head;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        ListNode* temp;\\n        temp=head;\\n        int cnt=0;\\n        while(temp!=0){\\n            cnt++;\\n            temp=temp->next;\\n        }\\n \\n        ListNode *slow, *fast;\\n        slow=head;\\n        fast=head;\\n        int p=1;\\n        while(p!=k){\\n            slow=slow->next;\\n            p++;\\n            \\n        }\\n        p=1;\\n        int t=(cnt-k+1);\\n        while(p!=t){\\n            fast=fast->next;\\n            p++;\\n        }\\n\\n        swap(slow->val ,fast->val);\\n        return head;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528360,
                "title": "c-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left=head;ListNode* right=head;\\n        for(int i=0;i<k-1;i++){\\n            left=left->next;\\n        }\\n        ListNode* ee=left;\\n        while(left->next){\\n            left=left->next;\\n            right=right->next;\\n        }\\n        swap(ee->val,right->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left=head;ListNode* right=head;\\n        for(int i=0;i<k-1;i++){\\n            left=left->next;\\n        }\\n        ListNode* ee=left;\\n        while(left->next){\\n            left=left->next;\\n            right=right->next;\\n        }\\n        swap(ee->val,right->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528304,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the linkedlist`\\n\\n# Code\\nImperative:\\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\\n        sentinal_head = i = j = ListNode(next=head)\\n        \\n        for _ in range(k - 1): j = j.next\\n        k_begin = j\\n        \\n        j = j.next\\n        while j and j.next: i, j = i.next, j.next\\n        k_end = i\\n\\n        b, e = k_begin.next, k_end.next\\n        k_begin.next, k_end.next = e, b\\n        b.next, e.next = e.next, b.next\\n        \\n        return sentinal_head.next\\n\\n\\n```\\n\\nFunctional:\\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\\n        \\n        def iter_ll(ll: ListNode | None) -> Iterator[ListNode]:\\n            while ll: yield ll; ll = ll.next\\n        \\n        T = TypeVar(\\'T\\')\\n        def last(xs: Iterable[T]) -> T:\\n            return reduce(lambda _, x: x, xs)\\n        \\n        sentinal_head = ListNode(next=head)\\n        xs, ys = iter_ll(sentinal_head), iter_ll(sentinal_head)\\n\\n        k_begin = next(islice(ys, k - 1, None))\\n        k_end = last(zip(xs, ys))[0]\\n\\n        b, e = k_begin.next, k_end.next\\n        k_begin.next, k_end.next = e, b\\n        b.next, e.next = e.next, b.next\\n        \\n        return sentinal_head.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\\n        sentinal_head = i = j = ListNode(next=head)\\n        \\n        for _ in range(k - 1): j = j.next\\n        k_begin = j\\n        \\n        j = j.next\\n        while j and j.next: i, j = i.next, j.next\\n        k_end = i\\n\\n        b, e = k_begin.next, k_end.next\\n        k_begin.next, k_end.next = e, b\\n        b.next, e.next = e.next, b.next\\n        \\n        return sentinal_head.next\\n\\n\\n```\n```python\\nclass Solution:\\n    def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\\n        \\n        def iter_ll(ll: ListNode | None) -> Iterator[ListNode]:\\n            while ll: yield ll; ll = ll.next\\n        \\n        T = TypeVar(\\'T\\')\\n        def last(xs: Iterable[T]) -> T:\\n            return reduce(lambda _, x: x, xs)\\n        \\n        sentinal_head = ListNode(next=head)\\n        xs, ys = iter_ll(sentinal_head), iter_ll(sentinal_head)\\n\\n        k_begin = next(islice(ys, k - 1, None))\\n        k_end = last(zip(xs, ys))[0]\\n\\n        b, e = k_begin.next, k_end.next\\n        k_begin.next, k_end.next = e, b\\n        b.next, e.next = e.next, b.next\\n        \\n        return sentinal_head.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527940,
                "title": "optimised-solution-using-three-pointers-clean-code-with-explanation",
                "content": "\\n\\n# Approach\\nWe start by creating three pointers, first, second, and curr, all pointing to the head of the linked list. We then traverse the linked list using curr until we reach the kth node from the beginning of the list. We set first to point to this node.\\n\\nNext, we continue to traverse the linked list using curr until we reach the end. At each step, we move second along with curr, so that when curr reaches the end of the list, second points to the kth node from the end of the list.\\n\\nFinally, we swap the values of the two nodes pointed to by first and second\\n\\n# Complexity\\n- Time complexity:\\n O(n), where n is the length of the linked list, since we traverse the list twice. \\n\\n- Space complexity:\\n O(1), since we only use a constant amount of additional memory to store the three pointers.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* first = head;\\n        ListNode* second = head;\\n        ListNode* curr = head;\\n\\n        // Traverse the linked list until the kth node from the beginning\\n        for (int i = 1; i < k; i++) {\\n            curr = curr->next;\\n        }\\n        first = curr;\\n\\n        // Traverse the linked list from the kth node until the end\\n        while (curr->next != NULL) {\\n            curr = curr->next;\\n            second = second->next;\\n        }\\n\\n        // Swap the values of the two nodes\\n        int temp = first->val;\\n        first->val = second->val;\\n        second->val = temp;\\n\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* first = head;\\n        ListNode* second = head;\\n        ListNode* curr = head;\\n\\n        // Traverse the linked list until the kth node from the beginning\\n        for (int i = 1; i < k; i++) {\\n            curr = curr->next;\\n        }\\n        first = curr;\\n\\n        // Traverse the linked list from the kth node until the end\\n        while (curr->next != NULL) {\\n            curr = curr->next;\\n            second = second->next;\\n        }\\n\\n        // Swap the values of the two nodes\\n        int temp = first->val;\\n        first->val = second->val;\\n        second->val = temp;\\n\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527208,
                "title": "simple-java-code-tc-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        // find length of LL\\n        int len = 1;\\n        ListNode temp = head;\\n        while(temp.next != null){\\n            len++;\\n            temp = temp.next;\\n        }\\n        int n = len-k+1; // kth elemebnt from end length - k + 1, lets call it nth element\\n        int count = 1;\\n        temp = head;\\n        // loop to reach till kth element\\n        while(count != k){\\n            temp = temp.next;\\n            count++;\\n        }\\n        //store value of kth element int nums1\\n        int num1 = temp.val;\\n        ListNode temp2 = head;\\n        count = 1;\\n        // loop to reach till nth element\\n        while(count != n){\\n            temp2 = temp2.next;\\n            count++;\\n        }\\n        //store valuse of nth element at kth place\\n        temp.val = temp2.val;\\n        // store valuse of kth (ie stored in num1) at nth place\\n        temp2.val = num1;\\n        return head; // return head \\n    }\\n}\\n```\\n[]()![478xve.jpg](https://assets.leetcode.com/users/images/7d4a1971-a28a-480d-b7a7-11c70b6955ae_1684155677.8641796.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        // find length of LL\\n        int len = 1;\\n        ListNode temp = head;\\n        while(temp.next != null){\\n            len++;\\n            temp = temp.next;\\n        }\\n        int n = len-k+1; // kth elemebnt from end length - k + 1, lets call it nth element\\n        int count = 1;\\n        temp = head;\\n        // loop to reach till kth element\\n        while(count != k){\\n            temp = temp.next;\\n            count++;\\n        }\\n        //store value of kth element int nums1\\n        int num1 = temp.val;\\n        ListNode temp2 = head;\\n        count = 1;\\n        // loop to reach till nth element\\n        while(count != n){\\n            temp2 = temp2.next;\\n            count++;\\n        }\\n        //store valuse of nth element at kth place\\n        temp.val = temp2.val;\\n        // store valuse of kth (ie stored in num1) at nth place\\n        temp2.val = num1;\\n        return head; // return head \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526678,
                "title": "simple-php-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Create a dummy node and set its next pointer to the head of the given linked list. This dummy node helps handle cases where the kth node is the head of the list.\\n2. Initialize two pointers, first and second, to the dummy node.\\n3. Move the first pointer k steps ahead in the linked list.\\n4. Store the reference of the first pointer in a temporary variable temp.\\n\\n5. Move both the first and second pointers simultaneously until the first pointer reaches the end of the list.\\n\\n6. Swap the values of the temp node and the node after the second pointer. Since the second pointer is already pointing to the (kth from end - 1) node, the next node is the kth node from the end.\\n\\n7. Return the next pointer of the dummy node, which will be the modified head of the linked list.\\n\\n8. This approach ensures that the swapping of nodes is done correctly and considers edge cases such as when the kth node is the head of the list.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a singly-linked list.\\n * class ListNode {\\n *     public $val = 0;\\n *     public $next = null;\\n *     function __construct($val = 0, $next = null) {\\n *         $this->val = $val;\\n *         $this->next = $next;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param ListNode $head\\n     * @param Integer $k\\n     * @return ListNode\\n     */\\n    function swapNodes($head, $k) {\\n        // Initialize pointers\\n        $dummy = new ListNode(0);\\n        $dummy->next = $head;\\n        $first = $dummy;\\n        $second = $dummy;\\n\\n        // Move the first pointer k steps ahead\\n        for ($i = 0; $i < $k; $i++) {\\n            $first = $first->next;\\n        }\\n\\n        $temp = $first;\\n\\n        // Move both pointers until first reaches the end of the list\\n        while ($first->next != null) {\\n            $first = $first->next;\\n            $second = $second->next;\\n        }\\n\\n        // Swap the values of the first and second pointers\\' nodes\\n        $temp_val = $temp->val;\\n        $temp->val = $second->next->val;\\n        $second->next->val = $temp_val;\\n\\n        return $dummy->next;\\n}\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n/**\\n * Definition for a singly-linked list.\\n * class ListNode {\\n *     public $val = 0;\\n *     public $next = null;\\n *     function __construct($val = 0, $next = null) {\\n *         $this->val = $val;\\n *         $this->next = $next;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param ListNode $head\\n     * @param Integer $k\\n     * @return ListNode\\n     */\\n    function swapNodes($head, $k) {\\n        // Initialize pointers\\n        $dummy = new ListNode(0);\\n        $dummy->next = $head;\\n        $first = $dummy;\\n        $second = $dummy;\\n\\n        // Move the first pointer k steps ahead\\n        for ($i = 0; $i < $k; $i++) {\\n            $first = $first->next;\\n        }\\n\\n        $temp = $first;\\n\\n        // Move both pointers until first reaches the end of the list\\n        while ($first->next != null) {\\n            $first = $first->next;\\n            $second = $second->next;\\n        }\\n\\n        // Swap the values of the first and second pointers\\' nodes\\n        $temp_val = $temp->val;\\n        $temp->val = $second->next->val;\\n        $second->next->val = $temp_val;\\n\\n        return $dummy->next;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526342,
                "title": "simple-c-code-fast-and-slow-traversal",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        k--;\\n        while(k--) temp=temp->next;\\n        cout<<temp->val;\\n        ListNode* right=head;\\n        ListNode* left=temp;\\n        while(temp->next!=NULL)\\n        {\\n            right=right->next;\\n            temp=temp->next;\\n        }\\n        swap(left->val,right->val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        k--;\\n        while(k--) temp=temp->next;\\n        cout<<temp->val;\\n        ListNode* right=head;\\n        ListNode* left=temp;\\n        while(temp->next!=NULL)\\n        {\\n            right=right->next;\\n            temp=temp->next;\\n        }\\n        swap(left->val,right->val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3526231,
                "title": "rust-unsafe",
                "content": "```\\nimpl Solution {\\n    pub fn swap_nodes(mut head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut a = head.as_mut().unwrap() as *mut Box<ListNode>;\\n        for _ in 1..k {\\n            unsafe { a = (*a).next.as_mut().unwrap(); }\\n        }\\n\\n        let mut b = head.as_mut().unwrap() as *mut Box<ListNode>;\\n        let mut t = a;\\n        unsafe {\\n            while let Some(ref mut tt) = (*t).next {\\n                t = tt;\\n                b = (*b).next.as_mut().unwrap();\\n            }\\n            std::mem::swap(&mut (*a).val, &mut (*b).val);\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn swap_nodes(mut head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\\n        let mut a = head.as_mut().unwrap() as *mut Box<ListNode>;\\n        for _ in 1..k {\\n            unsafe { a = (*a).next.as_mut().unwrap(); }\\n        }\\n\\n        let mut b = head.as_mut().unwrap() as *mut Box<ListNode>;\\n        let mut t = a;\\n        unsafe {\\n            while let Some(ref mut tt) = (*t).next {\\n                t = tt;\\n                b = (*b).next.as_mut().unwrap();\\n            }\\n            std::mem::swap(&mut (*a).val, &mut (*b).val);\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526099,
                "title": "python-solution-in-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over the list & store the pointers on node which needs to be swapped\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        #pointer one\\n        cur = head\\n        for i in range(k-1):\\n            cur = cur.next\\n\\n        #storing the left pointer which need to be swap \\n        left = cur\\n        right = head #storing the right pointer which need to be swap\\n\\n        #iterating over the list to get the correct right pointer\\n        while cur.next:\\n            cur = cur.next\\n            right = right.next\\n\\n        #swap left pointer & right pointer node value\\n        left.val,right.val = right.val,left.val\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        #pointer one\\n        cur = head\\n        for i in range(k-1):\\n            cur = cur.next\\n\\n        #storing the left pointer which need to be swap \\n        left = cur\\n        right = head #storing the right pointer which need to be swap\\n\\n        #iterating over the list to get the correct right pointer\\n        while cur.next:\\n            cur = cur.next\\n            right = right.next\\n\\n        #swap left pointer & right pointer node value\\n        left.val,right.val = right.val,left.val\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525904,
                "title": "python-one-loop",
                "content": "```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        node1, node2 = None, None\\n        counter = 0\\n        ans = head\\n        while head:\\n            counter += 1\\n            if counter == k:\\n                node1 = head\\n                node2 = ans\\n            elif counter > k:\\n                node2 = node2.next\\n            head = head.next\\n        node1.val, node2.val = node2.val, node1.val\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        node1, node2 = None, None\\n        counter = 0\\n        ans = head\\n        while head:\\n            counter += 1\\n            if counter == k:\\n                node1 = head\\n                node2 = ans\\n            elif counter > k:\\n                node2 = node2.next\\n            head = head.next\\n        node1.val, node2.val = node2.val, node1.val\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525868,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode first = current(head, k);\\n        ListNode second = current(head, Length(head) - k + 1);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n        \\n        return head;\\n    }\\n    public int Length(ListNode head) {\\n        int length = 0;\\n        ListNode current = head;\\n        \\n        while (current != null) {\\n            length++;\\n            current = current.next;\\n        }\\n        \\n        return length;\\n    }\\n    public ListNode current(ListNode head, int k){\\n        ListNode current = head;\\n        int l = 1;\\n        while(current != null && l < k){\\n            current = current.next;\\n            l++;\\n        }\\n        return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode first = current(head, k);\\n        ListNode second = current(head, Length(head) - k + 1);\\n        int temp = first.val;\\n        first.val = second.val;\\n        second.val = temp;\\n        \\n        return head;\\n    }\\n    public int Length(ListNode head) {\\n        int length = 0;\\n        ListNode current = head;\\n        \\n        while (current != null) {\\n            length++;\\n            current = current.next;\\n        }\\n        \\n        return length;\\n    }\\n    public ListNode current(ListNode head, int k){\\n        ListNode current = head;\\n        int l = 1;\\n        while(current != null && l < k){\\n            current = current.next;\\n            l++;\\n        }\\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525361,
                "title": "easiest-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* swapNodes(ListNode* head, int k) \\n\\t\\t{\\n\\t\\t\\tif(head -> next == NULL)\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\tListNode* curr = head;\\n\\t\\t\\tint count = k-1;\\n\\n\\t\\t\\twhile(count--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurr = curr -> next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tListNode* second = curr;\\n\\t\\t\\tListNode* beg = head;\\n\\n\\t\\t\\twhile(curr -> next != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurr = curr -> next;\\n\\t\\t\\t\\tbeg = beg -> next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint v1 = beg -> val;\\n\\t\\t\\tint v2 = second -> val;\\n\\n\\t\\t\\tsecond -> val = v1;\\n\\t\\t\\tbeg -> val = v2;\\n\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* swapNodes(ListNode* head, int k) \\n\\t\\t{\\n\\t\\t\\tif(head -> next == NULL)\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\tListNode* curr = head;\\n\\t\\t\\tint count = k-1;\\n\\n\\t\\t\\twhile(count--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurr = curr -> next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3525341,
                "title": "c-linked-list",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n    ListNode *itr = head, *ptr1 = NULL, *ptr2 = NULL;\\n    uint n = 0, count = 0;\\n    \\n    while(itr != NULL) {\\n        n++;\\n        itr = itr->next;\\n    }\\n    \\n    itr = head;\\n    while(itr != NULL) {\\n        count++;\\n        if(count == k) {\\n            ptr1 = itr;\\n        } else if(count == n - k + 1) {\\n            ptr2 = itr;\\n        }\\n        itr = itr->next;\\n    }\\n    \\n    if(ptr1 != NULL && ptr2 != NULL)\\n        swap(ptr1->val, ptr2->val);\\n    \\n    return head;\\n}\\n\\n    void swap(int &a, int &b) {\\n        int temp;\\n        temp = a;\\n        a = b;\\n        b = temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n    ListNode *itr = head, *ptr1 = NULL, *ptr2 = NULL;\\n    uint n = 0, count = 0;\\n    \\n    while(itr != NULL) {\\n        n++;\\n        itr = itr->next;\\n    }\\n    \\n    itr = head;\\n    while(itr != NULL) {\\n        count++;\\n        if(count == k) {\\n            ptr1 = itr;\\n        } else if(count == n - k + 1) {\\n            ptr2 = itr;\\n        }\\n        itr = itr->next;\\n    }\\n    \\n    if(ptr1 != NULL && ptr2 != NULL)\\n        swap(ptr1->val, ptr2->val);\\n    \\n    return head;\\n}\\n\\n    void swap(int &a, int &b) {\\n        int temp;\\n        temp = a;\\n        a = b;\\n        b = temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525271,
                "title": "1721-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity = O(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Runtime : 2 ms\\n- Beats : 99.56%\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode start = head , end = head;\\n        ListNode loop = head;\\n        for(int i = 2; loop.next != null; i++){\\n            if(i <= k) start = start.next;\\n            else end = end.next;\\n            loop = loop.next;\\n        }\\n        int temp = start.val;\\n        start.val = end.val;\\n        end.val = temp;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode start = head , end = head;\\n        ListNode loop = head;\\n        for(int i = 2; loop.next != null; i++){\\n            if(i <= k) start = start.next;\\n            else end = end.next;\\n            loop = loop.next;\\n        }\\n        int temp = start.val;\\n        start.val = end.val;\\n        end.val = temp;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517706,
                "title": "python-simple-solution-beats-99-55-with-explanation-key-takeaway-explained-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet n be the length of the array. Such that m = n - k\\nk + m = n: We need to find linklist index at -k. Therefore, it\\'s translate to n - k index. Therefore, m is the position. \\n\\n***\\nKey takeaway: m = n - k\\n***\\n\\n![image.png](https://assets.leetcode.com/users/images/3da4d56c-0e00-4288-82bd-eac259402c8e_1683931591.409171.png)\\n\\nPLZ UPVOTE OR ANYA WILL CRY :(\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        cur = head\\n        for _ in range (k - 1):\\n            cur = cur.next\\n        first = cur\\n        sec = head\\n        while cur.next:\\n            cur = cur.next\\n            sec = sec.next\\n        first.val , sec.val = sec.val, first.val\\n        return head\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        cur = head\\n        for _ in range (k - 1):\\n            cur = cur.next\\n        first = cur\\n        sec = head\\n        while cur.next:\\n            cur = cur.next\\n            sec = sec.next\\n        first.val , sec.val = sec.val, first.val\\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427009,
                "title": "c-code-without-using-array-two-pointers",
                "content": "# Approach\\nLet say we have n nodes in given Linked List.\\nYou can start by initializing two pointers, p1 and p2, to the head of the linked list. Then you move p2 k nodes ahead of p1, and after that, you move both p1 and p2 one node at a time until p2 reaches the end of the linked list. When p2 reaches the end of the list, p1 will be pointing to the kth node from the last.\\n# Complexity\\n- Time complexity: **O(n)** \\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode*h, int k) {\\n        ListNode*p=h,*q=h,*f;\\n        while(k!=1){q=q->next;k--;}\\n        f=q;\\n        while(q->next)\\n        {\\n            p=p->next;\\n            q=q->next;\\n        }\\n        swap(p->val,f->val);\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode*h, int k) {\\n        ListNode*p=h,*q=h,*f;\\n        while(k!=1){q=q->next;k--;}\\n        f=q;\\n        while(q->next)\\n        {\\n            p=p->next;\\n            q=q->next;\\n        }\\n        swap(p->val,f->val);\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308176,
                "title": "easy-java-solution",
                "content": "# Just Swap the value of two node\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n```start``` and ```end``` are two pointer.\\nFind start like this\\n```\\nwhile(count != k - 1){\\n            count++;\\n            start = start.next;\\n        }\\n```\\nAnd fiind end like this..\\n```\\nint i = 0;\\n        while(i < size - k){\\n            i++;\\n            end = end.next;\\n        }\\n```\\nthen just swap two values...\\n***There is another method to swap two node(discussed later here).***\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     public ListNode swapNodes(ListNode head, int k) {\\n//         int count = 0, size = 0;\\n//         ListNode curr = head;\\n//         while(curr != null){\\n//             size++;\\n//             curr = curr.next;\\n//         }\\n//         ListNode start = head;\\n//         ListNode end = head;\\n//         while(count != k - 1){\\n//             count++;\\n//             start = start.next;\\n//         }\\n//         int i = 0;\\n//         while(i < size - k){\\n//             i++;\\n//             end = end.next;\\n//         }\\n//         int temp = start.val;\\n//         start.val = end.val;\\n//         end.val = temp;\\n//         return head;\\n//     }\\n// }\\n```\\n**This code is contributed by @passionate_sumon**\\n```\\nclass Solution{\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode slow = head, fast = head;\\n        while(--k > 0){\\n            fast = fast.next;\\n        }\\n        int val = fast.val;\\n        ListNode temp = fast;\\n        while(fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        int t = slow.val;\\n        slow.val = val;\\n        temp.val = t;\\n        return head;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```start```\n```end```\n```\\nwhile(count != k - 1){\\n            count++;\\n            start = start.next;\\n        }\\n```\n```\\nint i = 0;\\n        while(i < size - k){\\n            i++;\\n            end = end.next;\\n        }\\n```\n```\\n// class Solution {\\n//     public ListNode swapNodes(ListNode head, int k) {\\n//         int count = 0, size = 0;\\n//         ListNode curr = head;\\n//         while(curr != null){\\n//             size++;\\n//             curr = curr.next;\\n//         }\\n//         ListNode start = head;\\n//         ListNode end = head;\\n//         while(count != k - 1){\\n//             count++;\\n//             start = start.next;\\n//         }\\n//         int i = 0;\\n//         while(i < size - k){\\n//             i++;\\n//             end = end.next;\\n//         }\\n//         int temp = start.val;\\n//         start.val = end.val;\\n//         end.val = temp;\\n//         return head;\\n//     }\\n// }\\n```\n```\\nclass Solution{\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode slow = head, fast = head;\\n        while(--k > 0){\\n            fast = fast.next;\\n        }\\n        int val = fast.val;\\n        ListNode temp = fast;\\n        while(fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        int t = slow.val;\\n        slow.val = val;\\n        temp.val = t;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236103,
                "title": "java-easy-code",
                "content": "#### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n\\n        ListNode beg = head, end= head, curr = head;\\n        ListNode newList = head;\\n\\n        // get total count\\n        int count = 0;\\n        while(curr!=null){\\n            count++;\\n            curr = curr.next;\\n        }\\n\\n        // place one pointer at kth position from beginning\\n        for(int i=1; i<k; i++){\\n            beg = beg.next;\\n        }\\n\\n        // place one pointer at kth position from end\\n        for(int i=0; i<count-k; i++){\\n            end = end.next;\\n        }\\n        \\n        //swap values;\\n        int temp = beg.val;\\n        beg.val = end.val;\\n        end.val = temp;\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n\\n        ListNode beg = head, end= head, curr = head;\\n        ListNode newList = head;\\n\\n        // get total count\\n        int count = 0;\\n        while(curr!=null){\\n            count++;\\n            curr = curr.next;\\n        }\\n\\n        // place one pointer at kth position from beginning\\n        for(int i=1; i<k; i++){\\n            beg = beg.next;\\n        }\\n\\n        // place one pointer at kth position from end\\n        for(int i=0; i<count-k; i++){\\n            end = end.next;\\n        }\\n        \\n        //swap values;\\n        int temp = beg.val;\\n        beg.val = end.val;\\n        end.val = temp;\\n\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171476,
                "title": "easy-c-vector-approach",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<int> ans;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            ans.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        swap(ans[k-1],ans[ans.size()-k]);\\n        ListNode* dummy=new ListNode();\\n        ListNode* temp2=dummy;\\n\\n        for(int i=0; i<ans.size(); i++){\\n            ListNode* newnode= new ListNode(ans[i]);\\n           dummy->next=newnode;\\n            dummy=dummy->next;\\n        }\\n        return temp2->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<int> ans;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            ans.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        swap(ans[k-1],ans[ans.size()-k]);\\n        ListNode* dummy=new ListNode();\\n        ListNode* temp2=dummy;\\n\\n        for(int i=0; i<ans.size(); i++){\\n            ListNode* newnode= new ListNode(ans[i]);\\n           dummy->next=newnode;\\n            dummy=dummy->next;\\n        }\\n        return temp2->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152799,
                "title": "java-easy-sol-beats-100-2ms",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (--k>0) {\\n            fast = fast.next;\\n        }\\n        int store = fast.val;\\n        ListNode temp = fast;\\n        while (fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        int store2 = slow.val;\\n        slow.val = store;\\n        temp.val = store2;\\n        return head;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (--k>0) {\\n            fast = fast.next;\\n        }\\n        int store = fast.val;\\n        ListNode temp = fast;\\n        while (fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        int store2 = slow.val;\\n        slow.val = store;\\n        temp.val = store2;\\n        return head;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148102,
                "title": "o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have just used two pointers which are pointing too kth node from begning i.e temp and kth node from end i.e Temp1 \\nAnd Then I have exchanged the values of these nodes.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode * temp=head;\\n        int count=0;\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            count++;\\n        }\\n     int n=1;\\n     temp=head;\\n     while(n<k){\\n         temp=temp->next;\\n         n++;\\n     }\\n     n=0;\\n     ListNode* temp1=head;\\n    while(n+k!=count){\\n        temp1=temp1->next;\\n        n++;\\n    }\\n    n=temp1->val;\\n    temp1->val=temp->val;\\n    temp->val=n;\\n\\n\\n     return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode * temp=head;\\n        int count=0;\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            count++;\\n        }\\n     int n=1;\\n     temp=head;\\n     while(n<k){\\n         temp=temp->next;\\n         n++;\\n     }\\n     n=0;\\n     ListNode* temp1=head;\\n    while(n+k!=count){\\n        temp1=temp1->next;\\n        n++;\\n    }\\n    n=temp1->val;\\n    temp1->val=temp->val;\\n    temp->val=n;\\n\\n\\n     return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109512,
                "title": "simple-solution-single-pass-python-easy-to-understand",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = head\\n        kth = head\\n        for _ in range(k - 1):\\n            kth = kth.next\\n        \\n        temp = kth\\n        while kth.next:\\n\\n            kth = kth.next\\n            curr = curr.next\\n\\n\\n        temp.val, curr.val = curr.val, temp.val\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        curr = head\\n        kth = head\\n        for _ in range(k - 1):\\n            kth = kth.next\\n        \\n        temp = kth\\n        while kth.next:\\n\\n            kth = kth.next\\n            curr = curr.next\\n\\n\\n        temp.val, curr.val = curr.val, temp.val\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082190,
                "title": "c-2-approaches-with-and-without-additional-space-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved - **Iteratively** OR using **Two Pointers** \\nApproach 1 - without additional space, traverse list to the nodes whose val are to be swapped \\nApproach 2 - store the val of entire list into a vector, swap the values of the 2 nodes and then update the val of entire list iteratively \\n\\n# Approach-1\\n<!-- Describe your approach to solving the problem. -->\\nWe created 2 list pointers,\\n1. `ListNode *begin` - points at the kth node from the beginning \\n2. `ListNode *end` - points at the kth node from the end \\n\\nTo reach the kth node from the end we first find the length of the string using user defined function `getLength` and then reach the kth node from the end.\\n\\nWe store their \"val\" in two different integer variables and then swap the values.\\n\\nReturn the head in the end.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$ - to find length of the string and traversals \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$ - no additional space or recursion was used \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getLength (ListNode *head)\\n    {\\n        int cnt = 0 ; \\n        ListNode *temp = head ; \\n        while (temp != NULL)\\n        {\\n            temp = temp -> next ;\\n            cnt ++ ; \\n        }\\n        return cnt ;\\n    }\\n\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *begin; \\n        ListNode *end ; \\n        ListNode *temp = head ; \\n        if(head == NULL)\\n        {\\n            return head ; \\n        }\\n        // list is 1-indexed \\n        int cnt1 =1 , cnt2 = 1 ;\\n        while (cnt1<k && temp != NULL)\\n        { \\n            temp = temp -> next ; \\n            cnt1 ++ ; \\n        }\\n        begin = temp ; \\n        int first = begin -> val ; \\n\\n        // placing temp back on head for 2nd iteration \\n        temp = head ; \\n        int length = getLength(head) ;\\n        while (cnt2 < (length-k+1) && temp != NULL)\\n        {\\n            temp = temp -> next ; \\n            cnt2 ++ ; \\n        }\\n        end = temp ; \\n        int second = end -> val;\\n\\n        // swapping the values of nodes\\' \"val\"\\n        int tmp ; \\n        tmp = first ;  \\n        first = second ; \\n        second = tmp ; \\n\\n        end->val = second; \\n        begin -> val = first ; \\n\\n        return head; \\n    }\\n};\\n```\\n> Simplified code for the above approach\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getLength (ListNode *head)\\n    {\\n        int cnt = 0 ; \\n        ListNode *temp = head ; \\n        while (temp != NULL)\\n        {\\n            temp = temp -> next ;\\n            cnt ++ ; \\n        }\\n        return cnt ;\\n    }\\n\\n    ListNode* swapNodes(ListNode* head, int k) {\\n\\n        ListNode *begin, *end ; \\n        ListNode *temp = head ;\\n\\n        if(head == NULL)\\n        {\\n            return head ; \\n        }\\n        int first, second ; \\n        int length = getLength(head) ;\\n        int cnt = 0 ; \\n        while (cnt<length && temp != NULL)\\n        { \\n            if(cnt == k-1)\\n            {\\n                begin = temp ; \\n                first = begin -> val ; \\n            }\\n\\n            if (cnt == (length-k))\\n            {\\n                end = temp ; \\n                second = end -> val ;\\n            }\\n            temp = temp -> next ; \\n            cnt ++ ;  \\n        }\\n        swap (begin->val, end->val) ;\\n        return head; \\n    }\\n};\\n```\\n\\n# Approach - 2 \\n\\n# Complexity \\n- Time complexity:$$O(n)$$ - to find length of the string and traversals \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ - additional vector was created to store data of list \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code -2 \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<int> data ; \\n        ListNode *temp = head ;\\n\\n        if (head == NULL)\\n        {\\n            return head; \\n        }\\n\\n        while (temp != NULL)\\n        {\\n            data.push_back(temp->val) ;\\n            temp = temp -> next ; \\n        }\\n        int n = data.size() ; \\n        swap (data[k-1], data[n-k]) ;\\n\\n        temp = head ; \\n        for (auto i : data)\\n        {\\n            temp->val = i ; \\n            temp = temp -> next ;  \\n        }\\n        return head ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023 (1).png](https://assets.leetcode.com/users/images/bb229e69-b069-4bd8-b4ea-9ac4bb868f52_1674322463.717472.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getLength (ListNode *head)\\n    {\\n        int cnt = 0 ; \\n        ListNode *temp = head ; \\n        while (temp != NULL)\\n        {\\n            temp = temp -> next ;\\n            cnt ++ ; \\n        }\\n        return cnt ;\\n    }\\n\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *begin; \\n        ListNode *end ; \\n        ListNode *temp = head ; \\n        if(head == NULL)\\n        {\\n            return head ; \\n        }\\n        // list is 1-indexed \\n        int cnt1 =1 , cnt2 = 1 ;\\n        while (cnt1<k && temp != NULL)\\n        { \\n            temp = temp -> next ; \\n            cnt1 ++ ; \\n        }\\n        begin = temp ; \\n        int first = begin -> val ; \\n\\n        // placing temp back on head for 2nd iteration \\n        temp = head ; \\n        int length = getLength(head) ;\\n        while (cnt2 < (length-k+1) && temp != NULL)\\n        {\\n            temp = temp -> next ; \\n            cnt2 ++ ; \\n        }\\n        end = temp ; \\n        int second = end -> val;\\n\\n        // swapping the values of nodes\\' \"val\"\\n        int tmp ; \\n        tmp = first ;  \\n        first = second ; \\n        second = tmp ; \\n\\n        end->val = second; \\n        begin -> val = first ; \\n\\n        return head; \\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getLength (ListNode *head)\\n    {\\n        int cnt = 0 ; \\n        ListNode *temp = head ; \\n        while (temp != NULL)\\n        {\\n            temp = temp -> next ;\\n            cnt ++ ; \\n        }\\n        return cnt ;\\n    }\\n\\n    ListNode* swapNodes(ListNode* head, int k) {\\n\\n        ListNode *begin, *end ; \\n        ListNode *temp = head ;\\n\\n        if(head == NULL)\\n        {\\n            return head ; \\n        }\\n        int first, second ; \\n        int length = getLength(head) ;\\n        int cnt = 0 ; \\n        while (cnt<length && temp != NULL)\\n        { \\n            if(cnt == k-1)\\n            {\\n                begin = temp ; \\n                first = begin -> val ; \\n            }\\n\\n            if (cnt == (length-k))\\n            {\\n                end = temp ; \\n                second = end -> val ;\\n            }\\n            temp = temp -> next ; \\n            cnt ++ ;  \\n        }\\n        swap (begin->val, end->val) ;\\n        return head; \\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        vector<int> data ; \\n        ListNode *temp = head ;\\n\\n        if (head == NULL)\\n        {\\n            return head; \\n        }\\n\\n        while (temp != NULL)\\n        {\\n            data.push_back(temp->val) ;\\n            temp = temp -> next ; \\n        }\\n        int n = data.size() ; \\n        swap (data[k-1], data[n-k]) ;\\n\\n        temp = head ; \\n        for (auto i : data)\\n        {\\n            temp->val = i ; \\n            temp = temp -> next ;  \\n        }\\n        return head ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059575,
                "title": "c-the-way-of-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    At first we have to find size of Node in order to find the specific value from Nth element from end using loop.\\n    Then substract k from size of Node which means we can find it using loop which starts from beginning.\\n    And again Run loop from beginning another 2 new pointers points\\nthose 2 elements from start and end.\\n    After loop just change the values and return the node.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        int length=0;\\n        while(temp) {\\n            temp=temp->next;\\n            length++;\\n        }\\n        length=length+1-k;\\n        if(length==k) return head;\\n        temp=head;\\n        int count=1;\\n        ListNode* fst=NULL;\\n        ListNode* snd=NULL;\\n        while(temp) {\\n            if(k==count) fst=temp;\\n            if(length==count) snd=temp;\\n            temp=temp->next;\\n            count++; \\n        }\\n        int tp=fst->val;\\n        fst->val=snd->val;\\n        snd->val=tp;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* temp=head;\\n        int length=0;\\n        while(temp) {\\n            temp=temp->next;\\n            length++;\\n        }\\n        length=length+1-k;\\n        if(length==k) return head;\\n        temp=head;\\n        int count=1;\\n        ListNode* fst=NULL;\\n        ListNode* snd=NULL;\\n        while(temp) {\\n            if(k==count) fst=temp;\\n            if(length==count) snd=temp;\\n            temp=temp->next;\\n            count++; \\n        }\\n        int tp=fst->val;\\n        fst->val=snd->val;\\n        snd->val=tp;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029837,
                "title": "c-beginner-friendly-solutions-one-pass-two-pass",
                "content": "**If you Helped, Please Upvote !!!**\\n> *Important : Only swap the values of left and right node*\\n\\n#### Two Pass\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left = head, *right = head;\\n        ListNode* curr = head;\\n\\n        int cnt = 0;\\n        while(curr) {\\n            if(cnt == k - 1) left = curr;\\n            curr = curr -> next;\\n            cnt++;\\n        }\\n\\n        int cnt0 = 0;\\n        while(right) {\\n            if(cnt0 == cnt - k) {\\n                swap(left -> val, right -> val);\\n                return head;\\n            };\\n            \\n            right = right -> next;\\n            cnt0++;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```\\n\\n##### One Pass\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *left = nullptr, *right = nullptr;\\n        for(ListNode* p = head; p != nullptr; p = p -> next) {\\n            right = right == nullptr ? nullptr : right -> next;\\n            if(--k == 0) {\\n                left = p;\\n                right = head;\\n            }\\n        }\\n        swap(left -> val, right -> val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode* left = head, *right = head;\\n        ListNode* curr = head;\\n\\n        int cnt = 0;\\n        while(curr) {\\n            if(cnt == k - 1) left = curr;\\n            curr = curr -> next;\\n            cnt++;\\n        }\\n\\n        int cnt0 = 0;\\n        while(right) {\\n            if(cnt0 == cnt - k) {\\n                swap(left -> val, right -> val);\\n                return head;\\n            };\\n            \\n            right = right -> next;\\n            cnt0++;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *left = nullptr, *right = nullptr;\\n        for(ListNode* p = head; p != nullptr; p = p -> next) {\\n            right = right == nullptr ? nullptr : right -> next;\\n            if(--k == 0) {\\n                left = p;\\n                right = head;\\n            }\\n        }\\n        swap(left -> val, right -> val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890523,
                "title": "java-2-solutions-clean-and-easy",
                "content": "# Please Upvote :D\\n\\n##### 1. By computing the node to be swapped from end:\\n```java []\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if (head.next ==  null) return head;\\n\\n        int kFromEnd = getSize(head) - k + 1;\\n        if (k == kFromEnd) return head;\\n\\n        int idx = 1;\\n        ListNode node1 = head, node2 = null;\\n\\n        while (idx != Math.max(kFromEnd, k)) {\\n            if (idx == Math.min(kFromEnd, k)) {\\n                node2 = node1;\\n            }\\n            node1 = node1.next;\\n            idx++;\\n        }\\n\\n        // swap\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n\\n        return head;\\n    }\\n\\n    private int getSize(ListNode head) {\\n        int size = 0;\\n\\n        while (head != null) {\\n            size++;\\n            head = head.next;\\n        }\\n\\n        return size;\\n    }\\n}\\n\\n// TC: O(n) + O(max(k, n-k+1))\\n// SC: O(1)\\n```\\n\\n##### 2. Using fast and slow pointers:\\n``` java []\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if (head.next == null) return head;\\n\\n        ListNode slow = head, fast = head;\\n        ListNode node1 = null, node2 = null;\\n\\n        for (int i = 1; i < k; i++) {\\n            fast = fast.next;\\n        }\\n\\n        node1 = fast;\\n\\n        while (fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n\\n        node2 = slow;\\n\\n        // swap\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n\\n        return head; \\n    }\\n}\\n\\n// TC: O(k) + O(n - k) => O(n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java []\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if (head.next ==  null) return head;\\n\\n        int kFromEnd = getSize(head) - k + 1;\\n        if (k == kFromEnd) return head;\\n\\n        int idx = 1;\\n        ListNode node1 = head, node2 = null;\\n\\n        while (idx != Math.max(kFromEnd, k)) {\\n            if (idx == Math.min(kFromEnd, k)) {\\n                node2 = node1;\\n            }\\n            node1 = node1.next;\\n            idx++;\\n        }\\n\\n        // swap\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n\\n        return head;\\n    }\\n\\n    private int getSize(ListNode head) {\\n        int size = 0;\\n\\n        while (head != null) {\\n            size++;\\n            head = head.next;\\n        }\\n\\n        return size;\\n    }\\n}\\n\\n// TC: O(n) + O(max(k, n-k+1))\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if (head.next == null) return head;\\n\\n        ListNode slow = head, fast = head;\\n        ListNode node1 = null, node2 = null;\\n\\n        for (int i = 1; i < k; i++) {\\n            fast = fast.next;\\n        }\\n\\n        node1 = fast;\\n\\n        while (fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n\\n        node2 = slow;\\n\\n        // swap\\n        int tmp = node1.val;\\n        node1.val = node2.val;\\n        node2.val = tmp;\\n\\n        return head; \\n    }\\n}\\n\\n// TC: O(k) + O(n - k) => O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879091,
                "title": "java",
                "content": "Pls upvote if you like it\\n\\n```\\n        public ListNode swapNodes(ListNode head, int k) {\\n            ListNode res = new ListNode(-1);\\n            res.next = head;\\n            ListNode first = res;\\n            ListNode second = res;\\n            ListNode three = res;\\n\\n            for (int i = 0; i < k; i++) {\\n                first = first.next;\\n                second = second.next;\\n            }\\n\\n            while (first != null) {\\n                first = first.next;\\n                three = three.next;\\n            }\\n\\n            int temp = second.val;\\n            second.val = three.val;\\n            three.val = temp;\\n\\n        return res.next;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        public ListNode swapNodes(ListNode head, int k) {\\n            ListNode res = new ListNode(-1);\\n            res.next = head;\\n            ListNode first = res;\\n            ListNode second = res;\\n            ListNode three = res;\\n\\n            for (int i = 0; i < k; i++) {\\n                first = first.next;\\n                second = second.next;\\n            }\\n\\n            while (first != null) {\\n                first = first.next;\\n                three = three.next;\\n            }\\n\\n            int temp = second.val;\\n            second.val = three.val;\\n            three.val = temp;\\n\\n        return res.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844187,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        \\n        int count=1;\\n        \\n        ListNode temp2=head;\\n        while(temp2.next!=null){\\n            temp2=temp2.next;\\n            count++;\\n        }\\n        \\n        ListNode temp1=head;\\n        int i=1;\\n        if(k==1){\\n            temp1=head;\\n        }\\n        else{\\n            while(i!=k){\\n                i++;\\n                temp1=temp1.next;\\n            }\\n        }\\n        \\n        int end=count-k+1;\\n        temp2=head;\\n        i=1;\\n        while(i!=end){\\n            i++;\\n            temp2=temp2.next;\\n        }\\n\\n        count=temp1.val;\\n        temp1.val=temp2.val;\\n        temp2.val=count;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        \\n        int count=1;\\n        \\n        ListNode temp2=head;\\n        while(temp2.next!=null){\\n            temp2=temp2.next;\\n            count++;\\n        }\\n        \\n        ListNode temp1=head;\\n        int i=1;\\n        if(k==1){\\n            temp1=head;\\n        }\\n        else{\\n            while(i!=k){\\n                i++;\\n                temp1=temp1.next;\\n            }\\n        }\\n        \\n        int end=count-k+1;\\n        temp2=head;\\n        i=1;\\n        while(i!=end){\\n            i++;\\n            temp2=temp2.next;\\n        }\\n\\n        count=temp1.val;\\n        temp1.val=temp2.val;\\n        temp2.val=count;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830480,
                "title": "java-two-easy-to-understand-java-solution",
                "content": "# Solution 1\\n```\\nclass Solution {\\n    static ListNode NthFromEnd(ListNode head, int n) {\\n        if(head==null || head.next==null) return null;    \\n        int c=0;                                          \\n        ListNode temp=head;\\n        while(temp!=null){\\n            temp=temp.next;\\n            c++;\\n        }\\n        if(n==c) return head.next;\\n        for(int i=0; i<c-n-1; i++) head=head.next;\\n        return head;\\n        \\n    }\\n\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head==null || head.next==null) return head;\\n        ListNode ptr=head;\\n        for(int i=0; i<k-1; i++) ptr=ptr.next;\\n        ListNode last=NthFromEnd(head, k-1);\\n        int temp=ptr.val;\\n        ptr.val=last.val;\\n        last.val= temp;\\n        return head;\\n\\n    }\\n}\\n\\n```\\n\\n---\\n\\n\\n# Solution 2\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head==null || head.next==null) return head;\\n        ListNode ptr1=head;\\n        for(int i=0; i<k-1; i++) ptr1=ptr1.next;\\n\\n        ListNode tmpPtr=ptr1;\\n        ListNode ptr2=head;\\n\\n        while(tmpPtr.next != null){\\n            tmpPtr=tmpPtr.next;\\n            ptr2=ptr2.next;\\n        }\\n        int temp=ptr1.val;\\n        ptr1.val=ptr2.val;\\n        ptr2.val= temp;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    static ListNode NthFromEnd(ListNode head, int n) {\\n        if(head==null || head.next==null) return null;    \\n        int c=0;                                          \\n        ListNode temp=head;\\n        while(temp!=null){\\n            temp=temp.next;\\n            c++;\\n        }\\n        if(n==c) return head.next;\\n        for(int i=0; i<c-n-1; i++) head=head.next;\\n        return head;\\n        \\n    }\\n\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head==null || head.next==null) return head;\\n        ListNode ptr=head;\\n        for(int i=0; i<k-1; i++) ptr=ptr.next;\\n        ListNode last=NthFromEnd(head, k-1);\\n        int temp=ptr.val;\\n        ptr.val=last.val;\\n        last.val= temp;\\n        return head;\\n\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head==null || head.next==null) return head;\\n        ListNode ptr1=head;\\n        for(int i=0; i<k-1; i++) ptr1=ptr1.next;\\n\\n        ListNode tmpPtr=ptr1;\\n        ListNode ptr2=head;\\n\\n        while(tmpPtr.next != null){\\n            tmpPtr=tmpPtr.next;\\n            ptr2=ptr2.next;\\n        }\\n        int temp=ptr1.val;\\n        ptr1.val=ptr2.val;\\n        ptr2.val= temp;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704172,
                "title": "python-simple-solution-in-o-n-complexity-faster-than-89-92",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        temp=head\\n        c=1\\n        while temp.next!=None:\\n            if c==k:\\n                temp2=temp\\n            temp=temp.next\\n            c+=1\\n        if c==k:\\n            temp.val,head.val=head.val,temp.val\\n            return head\\n        c,c2=c-k+1,1\\n        temp=head\\n        while c2!=c:\\n            temp=temp.next\\n            c2+=1\\n        temp.val,temp2.val=temp2.val,temp.val\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        temp=head\\n        c=1\\n        while temp.next!=None:\\n            if c==k:\\n                temp2=temp\\n            temp=temp.next\\n            c+=1\\n        if c==k:\\n            temp.val,head.val=head.val,temp.val\\n            return head\\n        c,c2=c-k+1,1\\n        temp=head\\n        while c2!=c:\\n            temp=temp.next\\n            c2+=1\\n        temp.val,temp2.val=temp2.val,temp.val\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594417,
                "title": "2-pointer-easy-java-clean-code",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode curr = head;\\n        ListNode p1 = head;\\n        ListNode p2= head;\\n        int ct = 1;\\n        \\n        while( curr != null )\\n        {\\n            if( ct < k )\\n                p1 = p1.next;\\n            \\n            if( ct > k )\\n                p2 = p2.next;\\n            \\n            \\n            curr = curr.next;\\n            ct++;\\n        }\\n        \\n        int temp = p1.val;\\n        p1.val = p2.val;\\n        p2.val = temp;\\n        \\n        return head;\\n    }\\n}\\n        \\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        ListNode curr = head;\\n        ListNode p1 = head;\\n        ListNode p2= head;\\n        int ct = 1;\\n        \\n        while( curr != null )\\n        {\\n            if( ct < k )\\n                p1 = p1.next;\\n            \\n            if( ct > k )\\n                p2 = p2.next;\\n            \\n            \\n            curr = curr.next;\\n            ct++;\\n        }\\n        \\n        int temp = p1.val;\\n        p1.val = p2.val;\\n        p2.val = temp;\\n        \\n        return head;\\n    }\\n}\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502742,
                "title": "very-easy-to-understand-implementation",
                "content": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def swapNodes(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        arr=[]\\n        curr=head\\n        while curr:\\n            tmp=curr\\n            curr=curr.next\\n            tmp.next=None\\n            arr.append(tmp)\\n            \\n        ### above code is for converting nodes into list\\n        arr[k-1],arr[-k]=arr[-k],arr[k-1]      #### swaping kth element with -kth element in list\\n\\t\\t\\n\\t\\t########  below code for reconstructing the list from list of nodes after swapping is done\\n        head=tmp=arr[0]\\n        for i in range(1,len(arr)):\\n            tmp.next=arr[i]\\n            tmp=tmp.next\\n        #print(head)\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def swapNodes(self, head, k):\\n        \"\"\"\\n        :type head: ListNode\\n        :type k: int\\n        :rtype: ListNode\\n        \"\"\"\\n        arr=[]\\n        curr=head\\n        while curr:\\n            tmp=curr\\n            curr=curr.next\\n            tmp.next=None\\n            arr.append(tmp)\\n            \\n        ### above code is for converting nodes into list\\n        arr[k-1],arr[-k]=arr[-k],arr[k-1]      #### swaping kth element with -kth element in list\\n\\t\\t\\n\\t\\t########  below code for reconstructing the list from list of nodes after swapping is done\\n        head=tmp=arr[0]\\n        for i in range(1,len(arr)):\\n            tmp.next=arr[i]\\n            tmp=tmp.next\\n        #print(head)\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338197,
                "title": "c-easy-in-one-iteration-o-n",
                "content": "**APPROACH :** \\n* We move the left pointer from head till we reaches the Kth node.\\n* Hance the right node will be K nodes behind the left, so after n = k we move the right pointer till we reache the last node (of current pointer).\\n* So ultimately left node will be K nodes from left and right one will be K nodes from right of th linked-list.\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *left = head, *right = head, *cur = head;\\n        \\n        int n = 1;\\n        while(cur!=NULL){\\n            if (n < k){\\n                left = left->next;\\n            }\\n            if (n > k){\\n                right = right->next;\\n            }\\n            cur = cur->next;\\n            n++;\\n        }\\n        \\n        swap(left->val, right->val);\\n        \\n        return head;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n        ListNode *left = head, *right = head, *cur = head;\\n        \\n        int n = 1;\\n        while(cur!=NULL){\\n            if (n < k){\\n                left = left->next;\\n            }\\n            if (n > k){\\n                right = right->next;\\n            }\\n            cur = cur->next;\\n            n++;\\n        }\\n        \\n        swap(left->val, right->val);\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272612,
                "title": "java-2-pointer-easy-100-faster",
                "content": "Here, \\nFirst We Traverse till ```n``` and find nth Node, then we find nth node from the end i.e ```\\'slow\\'```\\nand then we simply swap.\\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;\\n        ListNode nthNode = dummy;\\n        \\n        for(int i = 0; i<k; i++){                            //Finding nth Node from start\\n            nthNode = nthNode.next;\\n            fast = fast.next;\\n        }\\n        \\n        while(fast!=null){                       //Finding nth Node from end\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        int temp = nthNode.val;          //Swapping\\n        nthNode.val = slow.val;\\n        slow.val = temp;\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```n```\n```\\'slow\\'```\n```\\nclass Solution {\\n    public ListNode swapNodes(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        ListNode slow = dummy;\\n        ListNode fast = dummy;\\n        ListNode nthNode = dummy;\\n        \\n        for(int i = 0; i<k; i++){                            //Finding nth Node from start\\n            nthNode = nthNode.next;\\n            fast = fast.next;\\n        }\\n        \\n        while(fast!=null){                       //Finding nth Node from end\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        int temp = nthNode.val;          //Swapping\\n        nthNode.val = slow.val;\\n        slow.val = temp;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568751,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894509,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1895247,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1566216,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894310,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1570837,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894457,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1859829,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1957993,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894708,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1568751,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894509,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1895247,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1566216,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894310,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1570837,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894457,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1859829,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1957993,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894708,
                "content": [
                    {
                        "username": "mandy1339",
                        "content": "I focused my solution on swapping nodes instead of  swapping values which is considerably more difficult as there are multiple edge cases to consider. I see lots of short solutions where only the value is swapped. I feel like this problem description deserves more clarification as to what is expected."
                    },
                    {
                        "username": "pyush98",
                        "content": "who can blame u when the function is literally named swapNodes lmfao"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@satyam_rai15](/satyam_rai15) Reading your comment I really think of this quote: \\nThe problem with the world is that the intelligent people are full of doubts while the stupid ones are full of confidence. "
                    },
                    {
                        "username": "BatMe",
                        "content": "I literally gave up on the question because it kept failing as I was like you swapping the nodes. Even gave a whole goddamn day only to find your comment. What a waste of time I did just because of unclear Problem statement. At the same time I was thinking this question has so high acceptance rate and here I\\'m failing to clear the test cases lol. "
                    },
                    {
                        "username": "metamorphosis",
                        "content": "[@satyam_rai15](/satyam_rai15) So blatantly incorrect and yet spoken with such confidence xD"
                    },
                    {
                        "username": "hero080",
                        "content": "Swapping nodes are not difficult either, see [this solution](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525464/o-n-o-1-interview-safe-solution-actually-swap-the-nodes-easy-to-read-code/)"
                    },
                    {
                        "username": "hero080",
                        "content": "[@satyam_rai15](/satyam_rai15) There are many cases you would want to to swap nodes instead. For example, you might have other data structure which keeps pointers to the nodes here.\\nIn fact, as a basic library function, swapping values are mostly useless but swapping nodes could be used for many higher level algorithms."
                    },
                    {
                        "username": "benard_kong",
                        "content": "Agreed. This question\\'s title and description don\\'t match. Title says \"Swapping Nodes in a Linked List\" but description says \"swapping the values\" of the nodes. They\\'re two completely different things. Furthermore, the description only bolds the word \"swapping\", not the word \"values\", which brings further confusion as swapping values of nodes is not common.\\n\\n[@Satyam Rai](/satyam_rai15) I disagree. You are right that it doesn\\'t matter in *this* question, but it\\'s extremely rare in software engineering to just swap values of two nodes, it\\'s more common to change pointers, which is why [@Armando Toledo](/mandy1339) and presumably many others are confused."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "It makes zero sense to swap the nodes. Even if it was asked in the question to swap nodes instead, the end result would still be the same. And obviously, swapping the values is more easy and efficient."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "\"swapping values\" is clearly mentioned... though it\\'s good that you now know how to \"swap nodes\" !!"
                    },
                    {
                        "username": "jr-",
                        "content": "Title is not consistent with the description.\\n\\nTitle says \"Swapping Nodes\" and the description says \"swapping the values.\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The Hints are the worst: Making Array for a linked list question \\uD83D\\uDE12 "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Three Pass Approach\n\n  \n**Approach 2:** Two Pass Approach\n\n  \n**Approach 3:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "spent 20 minutes to swap the nodes until i realized i  just need to swap the values..."
                    },
                    {
                        "username": "skcode9",
                        "content": "same here.. and why do we need to swap values and how do the nodes get swap automatically then.."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not so diferent. It could be done with the same aproach of 3 pointers!! But we stop at the prev node instead the current node we want to modified ;)"
                    },
                    {
                        "username": "dhruvdabhi147",
                        "content": "![image](https://assets.leetcode.com/users/images/b8fd763e-e51d-4b2a-b985-8fd3af84de8c_1649080777.6241405.png)\\nLet me know if i have something wrong in understanding the problem.\\n"
                    },
                    {
                        "username": "ankita_111",
                        "content": "Feel like an idiot on solving it with swapping pointers :|"
                    },
                    {
                        "username": "anyvchyk",
                        "content": "Good job anyway!"
                    },
                    {
                        "username": "wangfred",
                        "content": "I am confused, is it swapping the nodes or just value? it would be an easy one if it swaps value. Why medium?"
                    },
                    {
                        "username": "BatMe",
                        "content": "[@anyvchyk](/anyvchyk) I think it\\'s medium becuase Most people including me wasted time in swapping nodes.  "
                    },
                    {
                        "username": "anyvchyk",
                        "content": "It\\'s swapping values. It\\'s stated in the description. The whole thing is to find an efficient way to track the k-th element from the end. And the array solution offered in tips sucks. Maybe, that\\'s the reason why it\\'s medium."
                    },
                    {
                        "username": "SilverCHN",
                        "content": "Swapping values is much easier than swapping nodes."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I\\'ve tried 2 different ways of solutions. One is using array, other uses 2 pointers"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3526153/2-c-solutions-1-with-stl-vector-1-using-2-pointers/"
                    }
                ]
            },
            {
                "id": 1894317,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 1894274,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 1894279,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 1576577,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 2071600,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 2069917,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 2065779,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 2059201,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 2050254,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 2023197,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n- Initialize three pointers \\'first\\', \\'second\\' and \\'current\\' as head of the linked list.\\n- Move the \\'first\\' pointer to the kth node of the linked list.\\n- Move the \\'current\\' pointer to the same node as the \\'first\\' pointer.\\n- Move the \\'second\\' pointer to the kth node from the end of the linked list.\\n- Swap the values of the kth node from the beginning and kth node from the end.\\n- Return the head of the modified linked list."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "I\\'m from GEHU too."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525268/easiest-solution-two-pointer-approach/"
                    },
                    {
                        "username": "alt909",
                        "content": "am I bad for assuming nodes or is the question bad for violating the sanctity of linked lists?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "if you read questions carefully it says values \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s not really so difficult swap nodes over swap values. Only take one or two pointers more. "
                    },
                    {
                        "username": "benard_kong",
                        "content": "Question is bad.  \n\n1. Question has an inaccurate title.  \n2. Description doesn't stress the word \"values\", only stresses \"swapping\".  \n3. Like you said, it's just... *really* **really** ***really*** weird to swap ***values*** of nodes instead of ***pointers***.\n\nSome poor decisions made by the question creator."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I had assumed nodes as well and spent a while trying to come up with a working solution only to realize the problem description said to swap *values*. Guess that\\'s what I get for not reading the description thoroughly."
                    },
                    {
                        "username": "gmk92lc",
                        "content": "think in terms of fast and slow pointers "
                    },
                    {
                        "username": "Vishal_Mishra_23",
                        "content": "![image](https://assets.leetcode.com/users/images/78ae51cc-6897-4b02-a40d-2084b1d04bbd_1649053387.174494.png)\\n"
                    },
                    {
                        "username": "kenimaru360",
                        "content": "Read the requirement carefully..."
                    },
                    {
                        "username": "dancaps",
                        "content": "The name will bite you on this one. Reread the question specifically focus on the bolded part saying \"SWAPPING the values\". You\\'re welcome. I wasted an hour so you don\\'t have to. "
                    },
                    {
                        "username": "thammayya",
                        "content": "I felt like this question lies in easy-medium range if we know slow and fast pointer approach.\\n Iterate for the k times using fast pointer and store it in temp.\\n and from that start a slow pointer from beginning and continue the fast pointer till last \\nswap the temp and slow pointer values\\n\\nhope that helps."
                    },
                    {
                        "username": "ceo-s",
                        "content": "Well... I swapped nodes instead of values. +1 lol"
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "what this error means\\n\\nerror: cannot find symbol\\n                temp.var = new_node;\\n                    ^\\n  symbol:   variable var\\n  location: variable temp of type ListNode"
                    },
                    {
                        "username": "user5410Mr",
                        "content": "this question should have been marked easy"
                    }
                ]
            },
            {
                "id": 1991431,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1979190,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1922770,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1895353,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1895216,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1895018,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1894909,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1894887,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1894881,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1894862,
                "content": [
                    {
                        "username": "Yashwantptl794",
                        "content": "Do we have any real solution to swap nodes instead of swapping values ?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "lol why did you ask?! but also i did it for you [swapping nodes](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/4030744/1ms-java-solution-one-pass-swapping-nodes/)"
                    },
                    {
                        "username": "urbinaismael56",
                        "content": "I wasted time swapping nodes before I saw the hint :(\\n"
                    },
                    {
                        "username": "BatMe",
                        "content": "The Only reason this question is medium is becuase they played us all with words. "
                    },
                    {
                        "username": "StefanelStan",
                        "content": "The title of this question is misleading: swapping nodes vs swapping values."
                    },
                    {
                        "username": "sudarshan_karthik",
                        "content": "recently started to use python for Leet Code for this problem I had to research entire DSA implementation on python.  The code is very easy to implement in python compared to C++. came back on time to submit the problem"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "I don\\'t get why this solution is not correct \\n // vector<int>v;\\n    // ListNode* pre=head;\\n    // while(pre->next!=NULL){\\n    //     v.push_back(pre->val);\\n    //     pre=pre->next;\\n    // }\\n    // int m=v[k-1],n=v[v.size()-k+1];\\n    // cout<<m<<n;\\n    //  ListNode* pr=head;\\n    //  int count=0;\\n    //   while(pr->next!=NULL){\\n    //       if(count==k-1) pr->val=n;\\n    //        if(count==v.size()-k+1) pr->val=m;\\n       \\n    //     pr=pr->next;\\n    //     count++;\\n    // }\\nreturn head;}"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 according to my view not a medium type problem"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "The `swapNodes` function swaps the nodes themselves, not just their values. In other words, it swaps the pointers to the nodes, not the contents of the nodes.\\n\\nWhen we locate the kth node from the beginning and the kth node from the end of the linked list, we actually locate their parent nodes (the nodes immediately preceding them). This allows us to swap the nodes themselves, rather than just their values.\\n\\nThe swap is performed by swapping the `next` pointers of the parent nodes of the kth node and the kth node from the end. Specifically, we swap `a->next` (which points to the kth node) with `b->next` (which points to the kth node from the end), and `a->next->next` (which points to the next node after the kth node) with `b->next->next` (which points to the next node after the kth node from the end).\\n\\nThis effectively swaps the two nodes, rather than just their values."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "swapped easily..."
                    },
                    {
                        "username": "Awadesh_Nautiyal",
                        "content": "it\\'s all about swapping values"
                    }
                ]
            },
            {
                "id": 1894857,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894763,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894531,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894524,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894508,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894498,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894468,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894380,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894348,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            },
            {
                "id": 1894298,
                "content": [
                    {
                        "username": "bit_weiser",
                        "content": "is it asking about swapping the value \\uD83E\\uDD14"
                    },
                    {
                        "username": "Abhay1708",
                        "content": "public:\\n    ListNode* swapNodes(ListNode* head, int k) {\\n         ListNode*slow=head,*fast=head;\\n        \\n        \\n        while(--k){\\n            fast=fast->next;\\n        }\\n            \\n                 ListNode *first = fast;\\n           while(fast->next != NULL){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n               \\n            swap(first->val, slow->val);\\n            return head;\\n    }"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Easy."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "I would prefer swaapping nodes instead of values . otherwise question\\'s name will make no sense;"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "What is the difference b/w swapping nodes and values ,\\nHow swapping the Nodes is different from   swapping nodes. I mean we are only concern with the values of our list?"
                    },
                    {
                        "username": "TobyCalledTodi",
                        "content": "       //why this one is giving runtime error\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;\\n\\n        if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n\\n      // But this one is running fine.\\n       if(prev1!=NULL){\\n        prev1->next = curr2;\\n        }\\n        else{\\n            head = curr2;\\n        }\\n\\n        if(prev2!=NULL){\\n        prev2->next = curr1;\\n        }\\n        else{\\n            head = curr1;\\n        }\\n\\n\\n        ListNode* curr1Next = curr1->next;\\n        curr1->next = curr2->next;\\n        curr2->next = curr1Next;"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Starting the week with a easy problem. Let\\'s see what\\'s up for this week.\\n"
                    },
                    {
                        "username": "sahebs450",
                        "content": "Question is asking for swap value not the node if we swap node ther are some edege cases we have handel wich make things little bit dificult."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Me: Swapping Nodes instead of values \\uD83D\\uDE16"
                    },
                    {
                        "username": "psionl0",
                        "content": "I originally did this problem 3 months ago. At the time, I was unaware that it was acceptable to simply swap values and swapped the nodes.\\n\\nSo I redid the problem swapping values instead. It only took a few minutes to code the solution and the code is much neater and shorter.\\n\\nHowever, the run time (300 ms) is only marginally better than the earlier case. Since the entire list needs to be traversed to find the kth node from the end, the time complexity is O(n)."
                    }
                ]
            }
        ]
    }
]